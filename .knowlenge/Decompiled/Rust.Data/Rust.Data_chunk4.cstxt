using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Item : IDisposable, IPooled, IProto<Item>, IProto
{
	public class ConditionData : IDisposable, IPooled, IProto<ConditionData>, IProto
	{
		[NonSerialized]
		public float condition;

		[NonSerialized]
		public float maxCondition;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(ConditionData instance)
		{
			if (instance.ShouldPool)
			{
				instance.condition = 0f;
				instance.maxCondition = 0f;
				Pool.Free<ConditionData>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose ConditionData with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(ConditionData instance)
		{
			instance.condition = condition;
			instance.maxCondition = maxCondition;
		}

		public ConditionData Copy()
		{
			ConditionData conditionData = Pool.Get<ConditionData>();
			CopyTo(conditionData);
			return conditionData;
		}

		public static ConditionData Deserialize(BufferStream stream)
		{
			ConditionData conditionData = Pool.Get<ConditionData>();
			Deserialize(stream, conditionData, isDelta: false);
			return conditionData;
		}

		public static ConditionData DeserializeLengthDelimited(BufferStream stream)
		{
			ConditionData conditionData = Pool.Get<ConditionData>();
			DeserializeLengthDelimited(stream, conditionData, isDelta: false);
			return conditionData;
		}

		public static ConditionData DeserializeLength(BufferStream stream, int length)
		{
			ConditionData conditionData = Pool.Get<ConditionData>();
			DeserializeLength(stream, length, conditionData, isDelta: false);
			return conditionData;
		}

		public static ConditionData Deserialize(byte[] buffer)
		{
			ConditionData conditionData = Pool.Get<ConditionData>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, conditionData, isDelta: false);
			return conditionData;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, ConditionData previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static ConditionData Deserialize(BufferStream stream, ConditionData instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 13:
					instance.condition = ProtocolParser.ReadSingle(stream);
					continue;
				case 21:
					instance.maxCondition = ProtocolParser.ReadSingle(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static ConditionData DeserializeLengthDelimited(BufferStream stream, ConditionData instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 13:
					instance.condition = ProtocolParser.ReadSingle(stream);
					continue;
				case 21:
					instance.maxCondition = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static ConditionData DeserializeLength(BufferStream stream, int length, ConditionData instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 13:
					instance.condition = ProtocolParser.ReadSingle(stream);
					continue;
				case 21:
					instance.maxCondition = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, ConditionData instance, ConditionData previous)
		{
			if (instance.condition != previous.condition)
			{
				stream.WriteByte(13);
				ProtocolParser.WriteSingle(stream, instance.condition);
			}
			if (instance.maxCondition != previous.maxCondition)
			{
				stream.WriteByte(21);
				ProtocolParser.WriteSingle(stream, instance.maxCondition);
			}
		}

		public static void Serialize(BufferStream stream, ConditionData instance)
		{
			if (instance.condition != 0f)
			{
				stream.WriteByte(13);
				ProtocolParser.WriteSingle(stream, instance.condition);
			}
			if (instance.maxCondition != 0f)
			{
				stream.WriteByte(21);
				ProtocolParser.WriteSingle(stream, instance.maxCondition);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class InstanceData : IDisposable, IPooled, IProto<InstanceData>, IProto
	{
		[NonSerialized]
		public int dataInt;

		[NonSerialized]
		public int blueprintTarget;

		[NonSerialized]
		public int blueprintAmount;

		[NonSerialized]
		public NetworkableId subEntity;

		[NonSerialized]
		public float dataFloat;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(InstanceData instance)
		{
			if (instance.ShouldPool)
			{
				instance.dataInt = 0;
				instance.blueprintTarget = 0;
				instance.blueprintAmount = 0;
				instance.subEntity = default(NetworkableId);
				instance.dataFloat = 0f;
				Pool.Free<InstanceData>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose InstanceData with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(InstanceData instance)
		{
			instance.dataInt = dataInt;
			instance.blueprintTarget = blueprintTarget;
			instance.blueprintAmount = blueprintAmount;
			instance.subEntity = subEntity;
			instance.dataFloat = dataFloat;
		}

		public InstanceData Copy()
		{
			InstanceData instanceData = Pool.Get<InstanceData>();
			CopyTo(instanceData);
			return instanceData;
		}

		public static InstanceData Deserialize(BufferStream stream)
		{
			InstanceData instanceData = Pool.Get<InstanceData>();
			Deserialize(stream, instanceData, isDelta: false);
			return instanceData;
		}

		public static InstanceData DeserializeLengthDelimited(BufferStream stream)
		{
			InstanceData instanceData = Pool.Get<InstanceData>();
			DeserializeLengthDelimited(stream, instanceData, isDelta: false);
			return instanceData;
		}

		public static InstanceData DeserializeLength(BufferStream stream, int length)
		{
			InstanceData instanceData = Pool.Get<InstanceData>();
			DeserializeLength(stream, length, instanceData, isDelta: false);
			return instanceData;
		}

		public static InstanceData Deserialize(byte[] buffer)
		{
			InstanceData instanceData = Pool.Get<InstanceData>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, instanceData, isDelta: false);
			return instanceData;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, InstanceData previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static InstanceData Deserialize(BufferStream stream, InstanceData instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.dataInt = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.blueprintTarget = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.blueprintAmount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.subEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 45:
					instance.dataFloat = ProtocolParser.ReadSingle(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static InstanceData DeserializeLengthDelimited(BufferStream stream, InstanceData instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.dataInt = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.blueprintTarget = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.blueprintAmount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.subEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 45:
					instance.dataFloat = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static InstanceData DeserializeLength(BufferStream stream, int length, InstanceData instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.dataInt = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.blueprintTarget = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.blueprintAmount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.subEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 45:
					instance.dataFloat = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, InstanceData instance, InstanceData previous)
		{
			if (instance.dataInt != previous.dataInt)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.dataInt);
			}
			if (instance.blueprintTarget != previous.blueprintTarget)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.blueprintTarget);
			}
			if (instance.blueprintAmount != previous.blueprintAmount)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.blueprintAmount);
			}
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.subEntity.Value);
			if (instance.dataFloat != previous.dataFloat)
			{
				stream.WriteByte(45);
				ProtocolParser.WriteSingle(stream, instance.dataFloat);
			}
		}

		public static void Serialize(BufferStream stream, InstanceData instance)
		{
			if (instance.dataInt != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.dataInt);
			}
			if (instance.blueprintTarget != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.blueprintTarget);
			}
			if (instance.blueprintAmount != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.blueprintAmount);
			}
			if (instance.subEntity != default(NetworkableId))
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, instance.subEntity.Value);
			}
			if (instance.dataFloat != 0f)
			{
				stream.WriteByte(45);
				ProtocolParser.WriteSingle(stream, instance.dataFloat);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			action(UidType.NetworkableId, ref subEntity.Value);
		}
	}

	[NonSerialized]
	public ItemId UID;

	[NonSerialized]
	public int itemid;

	[NonSerialized]
	public int slot;

	[NonSerialized]
	public int amount;

	[NonSerialized]
	public int flags;

	[NonSerialized]
	public float removetime;

	[NonSerialized]
	public float locktime;

	[NonSerialized]
	public NetworkableId worldEntity;

	[NonSerialized]
	public InstanceData instanceData;

	[NonSerialized]
	public NetworkableId heldEntity;

	[NonSerialized]
	public ConditionData conditionData;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public string text;

	[NonSerialized]
	public ulong skinid;

	[NonSerialized]
	public float cooktime;

	[NonSerialized]
	public string streamerName;

	[NonSerialized]
	public int ammoCount;

	[NonSerialized]
	public List<ItemOwnershipAmount> ownership;

	[NonSerialized]
	public uint iconImageId;

	[NonSerialized]
	public ItemContainer contents;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Item instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.UID = default(ItemId);
		instance.itemid = 0;
		instance.slot = 0;
		instance.amount = 0;
		instance.flags = 0;
		instance.removetime = 0f;
		instance.locktime = 0f;
		instance.worldEntity = default(NetworkableId);
		if (instance.instanceData != null)
		{
			instance.instanceData.ResetToPool();
			instance.instanceData = null;
		}
		instance.heldEntity = default(NetworkableId);
		if (instance.conditionData != null)
		{
			instance.conditionData.ResetToPool();
			instance.conditionData = null;
		}
		instance.name = string.Empty;
		instance.text = string.Empty;
		instance.skinid = 0uL;
		instance.cooktime = 0f;
		instance.streamerName = string.Empty;
		instance.ammoCount = 0;
		if (instance.ownership != null)
		{
			for (int i = 0; i < instance.ownership.Count; i++)
			{
				if (instance.ownership[i] != null)
				{
					instance.ownership[i].ResetToPool();
					instance.ownership[i] = null;
				}
			}
			List<ItemOwnershipAmount> list = instance.ownership;
			Pool.Free<ItemOwnershipAmount>(ref list, false);
			instance.ownership = list;
		}
		instance.iconImageId = 0u;
		if (instance.contents != null)
		{
			instance.contents.ResetToPool();
			instance.contents = null;
		}
		Pool.Free<Item>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Item with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Item instance)
	{
		instance.UID = UID;
		instance.itemid = itemid;
		instance.slot = slot;
		instance.amount = amount;
		instance.flags = flags;
		instance.removetime = removetime;
		instance.locktime = locktime;
		instance.worldEntity = worldEntity;
		if (instanceData != null)
		{
			if (instance.instanceData == null)
			{
				instance.instanceData = instanceData.Copy();
			}
			else
			{
				instanceData.CopyTo(instance.instanceData);
			}
		}
		else
		{
			instance.instanceData = null;
		}
		instance.heldEntity = heldEntity;
		if (conditionData != null)
		{
			if (instance.conditionData == null)
			{
				instance.conditionData = conditionData.Copy();
			}
			else
			{
				conditionData.CopyTo(instance.conditionData);
			}
		}
		else
		{
			instance.conditionData = null;
		}
		instance.name = name;
		instance.text = text;
		instance.skinid = skinid;
		instance.cooktime = cooktime;
		instance.streamerName = streamerName;
		instance.ammoCount = ammoCount;
		if (ownership != null)
		{
			instance.ownership = Pool.Get<List<ItemOwnershipAmount>>();
			for (int i = 0; i < ownership.Count; i++)
			{
				ItemOwnershipAmount item = ownership[i].Copy();
				instance.ownership.Add(item);
			}
		}
		else
		{
			instance.ownership = null;
		}
		instance.iconImageId = iconImageId;
		if (contents != null)
		{
			if (instance.contents == null)
			{
				instance.contents = contents.Copy();
			}
			else
			{
				contents.CopyTo(instance.contents);
			}
		}
		else
		{
			instance.contents = null;
		}
	}

	public Item Copy()
	{
		Item item = Pool.Get<Item>();
		CopyTo(item);
		return item;
	}

	public static Item Deserialize(BufferStream stream)
	{
		Item item = Pool.Get<Item>();
		Deserialize(stream, item, isDelta: false);
		return item;
	}

	public static Item DeserializeLengthDelimited(BufferStream stream)
	{
		Item item = Pool.Get<Item>();
		DeserializeLengthDelimited(stream, item, isDelta: false);
		return item;
	}

	public static Item DeserializeLength(BufferStream stream, int length)
	{
		Item item = Pool.Get<Item>();
		DeserializeLength(stream, length, item, isDelta: false);
		return item;
	}

	public static Item Deserialize(byte[] buffer)
	{
		Item item = Pool.Get<Item>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, item, isDelta: false);
		return item;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Item previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Item Deserialize(BufferStream stream, Item instance, bool isDelta)
	{
		if (!isDelta && instance.ownership == null)
		{
			instance.ownership = Pool.Get<List<ItemOwnershipAmount>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.UID = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.itemid = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.slot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.removetime = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.locktime = ProtocolParser.ReadSingle(stream);
				continue;
			case 64:
				instance.worldEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 74:
				if (instance.instanceData == null)
				{
					instance.instanceData = InstanceData.DeserializeLengthDelimited(stream);
				}
				else
				{
					InstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
				}
				continue;
			case 80:
				instance.heldEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 90:
				if (instance.conditionData == null)
				{
					instance.conditionData = ConditionData.DeserializeLengthDelimited(stream);
				}
				else
				{
					ConditionData.DeserializeLengthDelimited(stream, instance.conditionData, isDelta);
				}
				continue;
			case 114:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 122:
				instance.text = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Varint)
				{
					instance.skinid = ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.cooktime = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.streamerName = ProtocolParser.ReadString(stream);
				}
				break;
			case 19u:
				if (key.WireType == Wire.Varint)
				{
					instance.ammoCount = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.ownership.Add(ItemOwnershipAmount.DeserializeLengthDelimited(stream));
				}
				break;
			case 21u:
				if (key.WireType == Wire.Varint)
				{
					instance.iconImageId = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 100u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.contents == null)
					{
						instance.contents = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.contents, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
	}

	public static Item DeserializeLengthDelimited(BufferStream stream, Item instance, bool isDelta)
	{
		if (!isDelta && instance.ownership == null)
		{
			instance.ownership = Pool.Get<List<ItemOwnershipAmount>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.UID = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.itemid = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.slot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.removetime = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.locktime = ProtocolParser.ReadSingle(stream);
				continue;
			case 64:
				instance.worldEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 74:
				if (instance.instanceData == null)
				{
					instance.instanceData = InstanceData.DeserializeLengthDelimited(stream);
				}
				else
				{
					InstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
				}
				continue;
			case 80:
				instance.heldEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 90:
				if (instance.conditionData == null)
				{
					instance.conditionData = ConditionData.DeserializeLengthDelimited(stream);
				}
				else
				{
					ConditionData.DeserializeLengthDelimited(stream, instance.conditionData, isDelta);
				}
				continue;
			case 114:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 122:
				instance.text = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Varint)
				{
					instance.skinid = ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.cooktime = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.streamerName = ProtocolParser.ReadString(stream);
				}
				break;
			case 19u:
				if (key.WireType == Wire.Varint)
				{
					instance.ammoCount = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.ownership.Add(ItemOwnershipAmount.DeserializeLengthDelimited(stream));
				}
				break;
			case 21u:
				if (key.WireType == Wire.Varint)
				{
					instance.iconImageId = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 100u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.contents == null)
					{
						instance.contents = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.contents, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Item DeserializeLength(BufferStream stream, int length, Item instance, bool isDelta)
	{
		if (!isDelta && instance.ownership == null)
		{
			instance.ownership = Pool.Get<List<ItemOwnershipAmount>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.UID = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.itemid = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.slot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.removetime = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.locktime = ProtocolParser.ReadSingle(stream);
				continue;
			case 64:
				instance.worldEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 74:
				if (instance.instanceData == null)
				{
					instance.instanceData = InstanceData.DeserializeLengthDelimited(stream);
				}
				else
				{
					InstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
				}
				continue;
			case 80:
				instance.heldEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 90:
				if (instance.conditionData == null)
				{
					instance.conditionData = ConditionData.DeserializeLengthDelimited(stream);
				}
				else
				{
					ConditionData.DeserializeLengthDelimited(stream, instance.conditionData, isDelta);
				}
				continue;
			case 114:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 122:
				instance.text = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Varint)
				{
					instance.skinid = ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.cooktime = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.streamerName = ProtocolParser.ReadString(stream);
				}
				break;
			case 19u:
				if (key.WireType == Wire.Varint)
				{
					instance.ammoCount = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 20u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.ownership.Add(ItemOwnershipAmount.DeserializeLengthDelimited(stream));
				}
				break;
			case 21u:
				if (key.WireType == Wire.Varint)
				{
					instance.iconImageId = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 100u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.contents == null)
					{
						instance.contents = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.contents, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Item instance, Item previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.UID.Value);
		if (instance.itemid != previous.itemid)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemid);
		}
		if (instance.slot != previous.slot)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slot);
		}
		if (instance.amount != previous.amount)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
		if (instance.flags != previous.flags)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.flags);
		}
		if (instance.removetime != previous.removetime)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.removetime);
		}
		if (instance.locktime != previous.locktime)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.locktime);
		}
		stream.WriteByte(64);
		ProtocolParser.WriteUInt64(stream, instance.worldEntity.Value);
		if (instance.instanceData != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			InstanceData.SerializeDelta(stream, instance.instanceData, previous.instanceData);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field instanceData (ProtoBuf.Item.InstanceData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		stream.WriteByte(80);
		ProtocolParser.WriteUInt64(stream, instance.heldEntity.Value);
		if (instance.conditionData != null)
		{
			stream.WriteByte(90);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			ConditionData.SerializeDelta(stream, instance.conditionData, previous.conditionData);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field conditionData (ProtoBuf.Item.ConditionData)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.name != null && instance.name != previous.name)
		{
			stream.WriteByte(114);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.text != null && instance.text != previous.text)
		{
			stream.WriteByte(122);
			ProtocolParser.WriteString(stream, instance.text);
		}
		if (instance.skinid != previous.skinid)
		{
			stream.WriteByte(128);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, instance.skinid);
		}
		if (instance.cooktime != previous.cooktime)
		{
			stream.WriteByte(141);
			stream.WriteByte(1);
			ProtocolParser.WriteSingle(stream, instance.cooktime);
		}
		if (instance.streamerName != null && instance.streamerName != previous.streamerName)
		{
			stream.WriteByte(146);
			stream.WriteByte(1);
			ProtocolParser.WriteString(stream, instance.streamerName);
		}
		if (instance.ammoCount != previous.ammoCount)
		{
			stream.WriteByte(152);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoCount);
		}
		if (instance.ownership != null)
		{
			for (int i = 0; i < instance.ownership.Count; i++)
			{
				ItemOwnershipAmount itemOwnershipAmount = instance.ownership[i];
				stream.WriteByte(162);
				stream.WriteByte(1);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int position3 = stream.Position;
				ItemOwnershipAmount.SerializeDelta(stream, itemOwnershipAmount, itemOwnershipAmount);
				int val = stream.Position - position3;
				Span<byte> span3 = range3.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)val, span3, 0);
				if (num3 < 5)
				{
					span3[num3 - 1] |= 128;
					while (num3 < 4)
					{
						span3[num3++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		if (instance.iconImageId != previous.iconImageId)
		{
			stream.WriteByte(168);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt32(stream, instance.iconImageId);
		}
		if (instance.contents == null)
		{
			return;
		}
		stream.WriteByte(162);
		stream.WriteByte(6);
		BufferStream.RangeHandle range4 = stream.GetRange(5);
		int position4 = stream.Position;
		ItemContainer.SerializeDelta(stream, instance.contents, previous.contents);
		int val2 = stream.Position - position4;
		Span<byte> span4 = range4.GetSpan();
		int num4 = ProtocolParser.WriteUInt32((uint)val2, span4, 0);
		if (num4 < 5)
		{
			span4[num4 - 1] |= 128;
			while (num4 < 4)
			{
				span4[num4++] = 128;
			}
			span4[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, Item instance)
	{
		if (instance.UID != default(ItemId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.UID.Value);
		}
		if (instance.itemid != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemid);
		}
		if (instance.slot != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slot);
		}
		if (instance.amount != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
		if (instance.flags != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.flags);
		}
		if (instance.removetime != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.removetime);
		}
		if (instance.locktime != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.locktime);
		}
		if (instance.worldEntity != default(NetworkableId))
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, instance.worldEntity.Value);
		}
		if (instance.instanceData != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			InstanceData.Serialize(stream, instance.instanceData);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field instanceData (ProtoBuf.Item.InstanceData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.heldEntity != default(NetworkableId))
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, instance.heldEntity.Value);
		}
		if (instance.conditionData != null)
		{
			stream.WriteByte(90);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			ConditionData.Serialize(stream, instance.conditionData);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field conditionData (ProtoBuf.Item.ConditionData)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.name != null)
		{
			stream.WriteByte(114);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.text != null)
		{
			stream.WriteByte(122);
			ProtocolParser.WriteString(stream, instance.text);
		}
		if (instance.skinid != 0L)
		{
			stream.WriteByte(128);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, instance.skinid);
		}
		if (instance.cooktime != 0f)
		{
			stream.WriteByte(141);
			stream.WriteByte(1);
			ProtocolParser.WriteSingle(stream, instance.cooktime);
		}
		if (instance.streamerName != null)
		{
			stream.WriteByte(146);
			stream.WriteByte(1);
			ProtocolParser.WriteString(stream, instance.streamerName);
		}
		if (instance.ammoCount != 0)
		{
			stream.WriteByte(152);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoCount);
		}
		if (instance.ownership != null)
		{
			for (int i = 0; i < instance.ownership.Count; i++)
			{
				ItemOwnershipAmount instance2 = instance.ownership[i];
				stream.WriteByte(162);
				stream.WriteByte(1);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int position3 = stream.Position;
				ItemOwnershipAmount.Serialize(stream, instance2);
				int val = stream.Position - position3;
				Span<byte> span3 = range3.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)val, span3, 0);
				if (num3 < 5)
				{
					span3[num3 - 1] |= 128;
					while (num3 < 4)
					{
						span3[num3++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		if (instance.iconImageId != 0)
		{
			stream.WriteByte(168);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt32(stream, instance.iconImageId);
		}
		if (instance.contents == null)
		{
			return;
		}
		stream.WriteByte(162);
		stream.WriteByte(6);
		BufferStream.RangeHandle range4 = stream.GetRange(5);
		int position4 = stream.Position;
		ItemContainer.Serialize(stream, instance.contents);
		int val2 = stream.Position - position4;
		Span<byte> span4 = range4.GetSpan();
		int num4 = ProtocolParser.WriteUInt32((uint)val2, span4, 0);
		if (num4 < 5)
		{
			span4[num4 - 1] |= 128;
			while (num4 < 4)
			{
				span4[num4++] = 128;
			}
			span4[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.ItemId, ref UID.Value);
		action(UidType.NetworkableId, ref worldEntity.Value);
		instanceData?.InspectUids(action);
		action(UidType.NetworkableId, ref heldEntity.Value);
		conditionData?.InspectUids(action);
		if (ownership != null)
		{
			for (int i = 0; i < ownership.Count; i++)
			{
				ownership[i]?.InspectUids(action);
			}
		}
		contents?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ItemAmountList : IDisposable, IPooled, IProto<ItemAmountList>, IProto
{
	[NonSerialized]
	public List<int> itemID;

	[NonSerialized]
	public List<float> amount;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ItemAmountList instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.itemID != null)
			{
				List<int> list = instance.itemID;
				Pool.FreeUnmanaged<int>(ref list);
				instance.itemID = list;
			}
			if (instance.amount != null)
			{
				List<float> list2 = instance.amount;
				Pool.FreeUnmanaged<float>(ref list2);
				instance.amount = list2;
			}
			Pool.Free<ItemAmountList>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ItemAmountList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ItemAmountList instance)
	{
		if (itemID != null)
		{
			instance.itemID = Pool.Get<List<int>>();
			for (int i = 0; i < itemID.Count; i++)
			{
				int item = itemID[i];
				instance.itemID.Add(item);
			}
		}
		else
		{
			instance.itemID = null;
		}
		if (amount != null)
		{
			instance.amount = Pool.Get<List<float>>();
			for (int j = 0; j < amount.Count; j++)
			{
				float item2 = amount[j];
				instance.amount.Add(item2);
			}
		}
		else
		{
			instance.amount = null;
		}
	}

	public ItemAmountList Copy()
	{
		ItemAmountList itemAmountList = Pool.Get<ItemAmountList>();
		CopyTo(itemAmountList);
		return itemAmountList;
	}

	public static ItemAmountList Deserialize(BufferStream stream)
	{
		ItemAmountList itemAmountList = Pool.Get<ItemAmountList>();
		Deserialize(stream, itemAmountList, isDelta: false);
		return itemAmountList;
	}

	public static ItemAmountList DeserializeLengthDelimited(BufferStream stream)
	{
		ItemAmountList itemAmountList = Pool.Get<ItemAmountList>();
		DeserializeLengthDelimited(stream, itemAmountList, isDelta: false);
		return itemAmountList;
	}

	public static ItemAmountList DeserializeLength(BufferStream stream, int length)
	{
		ItemAmountList itemAmountList = Pool.Get<ItemAmountList>();
		DeserializeLength(stream, length, itemAmountList, isDelta: false);
		return itemAmountList;
	}

	public static ItemAmountList Deserialize(byte[] buffer)
	{
		ItemAmountList itemAmountList = Pool.Get<ItemAmountList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, itemAmountList, isDelta: false);
		return itemAmountList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ItemAmountList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ItemAmountList Deserialize(BufferStream stream, ItemAmountList instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.itemID == null)
			{
				instance.itemID = Pool.Get<List<int>>();
			}
			if (instance.amount == null)
			{
				instance.amount = Pool.Get<List<float>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemID.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.amount.Add(ProtocolParser.ReadSingle(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ItemAmountList DeserializeLengthDelimited(BufferStream stream, ItemAmountList instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.itemID == null)
			{
				instance.itemID = Pool.Get<List<int>>();
			}
			if (instance.amount == null)
			{
				instance.amount = Pool.Get<List<float>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.amount.Add(ProtocolParser.ReadSingle(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ItemAmountList DeserializeLength(BufferStream stream, int length, ItemAmountList instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.itemID == null)
			{
				instance.itemID = Pool.Get<List<int>>();
			}
			if (instance.amount == null)
			{
				instance.amount = Pool.Get<List<float>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.amount.Add(ProtocolParser.ReadSingle(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ItemAmountList instance, ItemAmountList previous)
	{
		if (instance.itemID != null)
		{
			for (int i = 0; i < instance.itemID.Count; i++)
			{
				int num = instance.itemID[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.amount != null)
		{
			for (int j = 0; j < instance.amount.Count; j++)
			{
				float f = instance.amount[j];
				stream.WriteByte(21);
				ProtocolParser.WriteSingle(stream, f);
			}
		}
	}

	public static void Serialize(BufferStream stream, ItemAmountList instance)
	{
		if (instance.itemID != null)
		{
			for (int i = 0; i < instance.itemID.Count; i++)
			{
				int num = instance.itemID[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.amount != null)
		{
			for (int j = 0; j < instance.amount.Count; j++)
			{
				float f = instance.amount[j];
				stream.WriteByte(21);
				ProtocolParser.WriteSingle(stream, f);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ItemContainer : IDisposable, IPooled, IProto<ItemContainer>, IProto
{
	[NonSerialized]
	public ItemContainerId UID;

	[NonSerialized]
	public int slots;

	[NonSerialized]
	public float temperature;

	[NonSerialized]
	public int flags;

	[NonSerialized]
	public int allowedContents;

	[NonSerialized]
	public int maxStackSize;

	[NonSerialized]
	public List<int> allowedItems;

	[NonSerialized]
	public List<int> availableSlots;

	[NonSerialized]
	public int volume;

	[NonSerialized]
	public List<Item> contents;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ItemContainer instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.UID = default(ItemContainerId);
		instance.slots = 0;
		instance.temperature = 0f;
		instance.flags = 0;
		instance.allowedContents = 0;
		instance.maxStackSize = 0;
		if (instance.allowedItems != null)
		{
			List<int> list = instance.allowedItems;
			Pool.FreeUnmanaged<int>(ref list);
			instance.allowedItems = list;
		}
		if (instance.availableSlots != null)
		{
			List<int> list2 = instance.availableSlots;
			Pool.FreeUnmanaged<int>(ref list2);
			instance.availableSlots = list2;
		}
		instance.volume = 0;
		if (instance.contents != null)
		{
			for (int i = 0; i < instance.contents.Count; i++)
			{
				if (instance.contents[i] != null)
				{
					instance.contents[i].ResetToPool();
					instance.contents[i] = null;
				}
			}
			List<Item> list3 = instance.contents;
			Pool.Free<Item>(ref list3, false);
			instance.contents = list3;
		}
		Pool.Free<ItemContainer>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ItemContainer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ItemContainer instance)
	{
		instance.UID = UID;
		instance.slots = slots;
		instance.temperature = temperature;
		instance.flags = flags;
		instance.allowedContents = allowedContents;
		instance.maxStackSize = maxStackSize;
		if (allowedItems != null)
		{
			instance.allowedItems = Pool.Get<List<int>>();
			for (int i = 0; i < allowedItems.Count; i++)
			{
				int item = allowedItems[i];
				instance.allowedItems.Add(item);
			}
		}
		else
		{
			instance.allowedItems = null;
		}
		if (availableSlots != null)
		{
			instance.availableSlots = Pool.Get<List<int>>();
			for (int j = 0; j < availableSlots.Count; j++)
			{
				int item2 = availableSlots[j];
				instance.availableSlots.Add(item2);
			}
		}
		else
		{
			instance.availableSlots = null;
		}
		instance.volume = volume;
		if (contents != null)
		{
			instance.contents = Pool.Get<List<Item>>();
			for (int k = 0; k < contents.Count; k++)
			{
				Item item3 = contents[k].Copy();
				instance.contents.Add(item3);
			}
		}
		else
		{
			instance.contents = null;
		}
	}

	public ItemContainer Copy()
	{
		ItemContainer itemContainer = Pool.Get<ItemContainer>();
		CopyTo(itemContainer);
		return itemContainer;
	}

	public static ItemContainer Deserialize(BufferStream stream)
	{
		ItemContainer itemContainer = Pool.Get<ItemContainer>();
		Deserialize(stream, itemContainer, isDelta: false);
		return itemContainer;
	}

	public static ItemContainer DeserializeLengthDelimited(BufferStream stream)
	{
		ItemContainer itemContainer = Pool.Get<ItemContainer>();
		DeserializeLengthDelimited(stream, itemContainer, isDelta: false);
		return itemContainer;
	}

	public static ItemContainer DeserializeLength(BufferStream stream, int length)
	{
		ItemContainer itemContainer = Pool.Get<ItemContainer>();
		DeserializeLength(stream, length, itemContainer, isDelta: false);
		return itemContainer;
	}

	public static ItemContainer Deserialize(byte[] buffer)
	{
		ItemContainer itemContainer = Pool.Get<ItemContainer>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, itemContainer, isDelta: false);
		return itemContainer;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ItemContainer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ItemContainer Deserialize(BufferStream stream, ItemContainer instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.allowedItems == null)
			{
				instance.allowedItems = Pool.Get<List<int>>();
			}
			if (instance.availableSlots == null)
			{
				instance.availableSlots = Pool.Get<List<int>>();
			}
			if (instance.contents == null)
			{
				instance.contents = Pool.Get<List<Item>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.UID = new ItemContainerId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.slots = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.temperature = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.allowedContents = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.maxStackSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.allowedItems.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.availableSlots.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 72:
				instance.volume = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 100)
			{
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.contents.Add(Item.DeserializeLengthDelimited(stream));
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
	}

	public static ItemContainer DeserializeLengthDelimited(BufferStream stream, ItemContainer instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.allowedItems == null)
			{
				instance.allowedItems = Pool.Get<List<int>>();
			}
			if (instance.availableSlots == null)
			{
				instance.availableSlots = Pool.Get<List<int>>();
			}
			if (instance.contents == null)
			{
				instance.contents = Pool.Get<List<Item>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.UID = new ItemContainerId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.slots = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.temperature = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.allowedContents = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.maxStackSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.allowedItems.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.availableSlots.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 72:
				instance.volume = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 100)
			{
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.contents.Add(Item.DeserializeLengthDelimited(stream));
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ItemContainer DeserializeLength(BufferStream stream, int length, ItemContainer instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.allowedItems == null)
			{
				instance.allowedItems = Pool.Get<List<int>>();
			}
			if (instance.availableSlots == null)
			{
				instance.availableSlots = Pool.Get<List<int>>();
			}
			if (instance.contents == null)
			{
				instance.contents = Pool.Get<List<Item>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.UID = new ItemContainerId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.slots = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.temperature = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.allowedContents = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.maxStackSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.allowedItems.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.availableSlots.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 72:
				instance.volume = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 100)
			{
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.contents.Add(Item.DeserializeLengthDelimited(stream));
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ItemContainer instance, ItemContainer previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.UID.Value);
		if (instance.slots != previous.slots)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slots);
		}
		if (instance.temperature != previous.temperature)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.temperature);
		}
		if (instance.flags != previous.flags)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.flags);
		}
		if (instance.allowedContents != previous.allowedContents)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.allowedContents);
		}
		if (instance.maxStackSize != previous.maxStackSize)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxStackSize);
		}
		if (instance.allowedItems != null)
		{
			for (int i = 0; i < instance.allowedItems.Count; i++)
			{
				int num = instance.allowedItems[i];
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.availableSlots != null)
		{
			for (int j = 0; j < instance.availableSlots.Count; j++)
			{
				int num2 = instance.availableSlots[j];
				stream.WriteByte(64);
				ProtocolParser.WriteUInt64(stream, (ulong)num2);
			}
		}
		if (instance.volume != previous.volume)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.volume);
		}
		if (instance.contents == null)
		{
			return;
		}
		for (int k = 0; k < instance.contents.Count; k++)
		{
			Item item = instance.contents[k];
			stream.WriteByte(162);
			stream.WriteByte(6);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Item.SerializeDelta(stream, item, item);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num3 < 5)
			{
				span[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span[num3++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, ItemContainer instance)
	{
		if (instance.UID != default(ItemContainerId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.UID.Value);
		}
		if (instance.slots != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slots);
		}
		if (instance.temperature != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.temperature);
		}
		if (instance.flags != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.flags);
		}
		if (instance.allowedContents != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.allowedContents);
		}
		if (instance.maxStackSize != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxStackSize);
		}
		if (instance.allowedItems != null)
		{
			for (int i = 0; i < instance.allowedItems.Count; i++)
			{
				int num = instance.allowedItems[i];
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.availableSlots != null)
		{
			for (int j = 0; j < instance.availableSlots.Count; j++)
			{
				int num2 = instance.availableSlots[j];
				stream.WriteByte(64);
				ProtocolParser.WriteUInt64(stream, (ulong)num2);
			}
		}
		if (instance.volume != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.volume);
		}
		if (instance.contents == null)
		{
			return;
		}
		for (int k = 0; k < instance.contents.Count; k++)
		{
			Item instance2 = instance.contents[k];
			stream.WriteByte(162);
			stream.WriteByte(6);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Item.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num3 < 5)
			{
				span[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span[num3++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.ItemContainerId, ref UID.Value);
		if (contents != null)
		{
			for (int i = 0; i < contents.Count; i++)
			{
				contents[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ItemCrafter : IDisposable, IPooled, IProto<ItemCrafter>, IProto
{
	public class Task : IDisposable, IPooled, IProto<Task>, IProto
	{
		[NonSerialized]
		public int itemID;

		[NonSerialized]
		public float remainingTime;

		[NonSerialized]
		public int taskUID;

		[NonSerialized]
		public bool cancelled;

		[NonSerialized]
		public Item.InstanceData instanceData;

		[NonSerialized]
		public int amount;

		[NonSerialized]
		public int skinID;

		[NonSerialized]
		public List<Item> takenItems;

		[NonSerialized]
		public int numCrafted;

		[NonSerialized]
		public float conditionScale;

		[NonSerialized]
		public NetworkableId workbenchEntity;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Task instance)
		{
			if (!instance.ShouldPool)
			{
				return;
			}
			instance.itemID = 0;
			instance.remainingTime = 0f;
			instance.taskUID = 0;
			instance.cancelled = false;
			if (instance.instanceData != null)
			{
				instance.instanceData.ResetToPool();
				instance.instanceData = null;
			}
			instance.amount = 0;
			instance.skinID = 0;
			if (instance.takenItems != null)
			{
				for (int i = 0; i < instance.takenItems.Count; i++)
				{
					if (instance.takenItems[i] != null)
					{
						instance.takenItems[i].ResetToPool();
						instance.takenItems[i] = null;
					}
				}
				List<Item> list = instance.takenItems;
				Pool.Free<Item>(ref list, false);
				instance.takenItems = list;
			}
			instance.numCrafted = 0;
			instance.conditionScale = 0f;
			instance.workbenchEntity = default(NetworkableId);
			Pool.Free<Task>(ref instance);
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Task with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Task instance)
		{
			instance.itemID = itemID;
			instance.remainingTime = remainingTime;
			instance.taskUID = taskUID;
			instance.cancelled = cancelled;
			if (instanceData != null)
			{
				if (instance.instanceData == null)
				{
					instance.instanceData = instanceData.Copy();
				}
				else
				{
					instanceData.CopyTo(instance.instanceData);
				}
			}
			else
			{
				instance.instanceData = null;
			}
			instance.amount = amount;
			instance.skinID = skinID;
			if (takenItems != null)
			{
				instance.takenItems = Pool.Get<List<Item>>();
				for (int i = 0; i < takenItems.Count; i++)
				{
					Item item = takenItems[i].Copy();
					instance.takenItems.Add(item);
				}
			}
			else
			{
				instance.takenItems = null;
			}
			instance.numCrafted = numCrafted;
			instance.conditionScale = conditionScale;
			instance.workbenchEntity = workbenchEntity;
		}

		public Task Copy()
		{
			Task task = Pool.Get<Task>();
			CopyTo(task);
			return task;
		}

		public static Task Deserialize(BufferStream stream)
		{
			Task task = Pool.Get<Task>();
			Deserialize(stream, task, isDelta: false);
			return task;
		}

		public static Task DeserializeLengthDelimited(BufferStream stream)
		{
			Task task = Pool.Get<Task>();
			DeserializeLengthDelimited(stream, task, isDelta: false);
			return task;
		}

		public static Task DeserializeLength(BufferStream stream, int length)
		{
			Task task = Pool.Get<Task>();
			DeserializeLength(stream, length, task, isDelta: false);
			return task;
		}

		public static Task Deserialize(byte[] buffer)
		{
			Task task = Pool.Get<Task>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, task, isDelta: false);
			return task;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Task previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Task Deserialize(BufferStream stream, Task instance, bool isDelta)
		{
			if (!isDelta && instance.takenItems == null)
			{
				instance.takenItems = Pool.Get<List<Item>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 21:
					instance.remainingTime = ProtocolParser.ReadSingle(stream);
					break;
				case 24:
					instance.taskUID = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 32:
					instance.cancelled = ProtocolParser.ReadBool(stream);
					break;
				case 42:
					if (instance.instanceData == null)
					{
						instance.instanceData = Item.InstanceData.DeserializeLengthDelimited(stream);
					}
					else
					{
						Item.InstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
					}
					break;
				case 48:
					instance.amount = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 56:
					instance.skinID = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 66:
					instance.takenItems.Add(Item.DeserializeLengthDelimited(stream));
					break;
				case 72:
					instance.numCrafted = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 85:
					instance.conditionScale = ProtocolParser.ReadSingle(stream);
					break;
				case 88:
					instance.workbenchEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				case -1:
				case 0:
					return instance;
				}
			}
		}

		public static Task DeserializeLengthDelimited(BufferStream stream, Task instance, bool isDelta)
		{
			if (!isDelta && instance.takenItems == null)
			{
				instance.takenItems = Pool.Get<List<Item>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 21:
					instance.remainingTime = ProtocolParser.ReadSingle(stream);
					break;
				case 24:
					instance.taskUID = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 32:
					instance.cancelled = ProtocolParser.ReadBool(stream);
					break;
				case 42:
					if (instance.instanceData == null)
					{
						instance.instanceData = Item.InstanceData.DeserializeLengthDelimited(stream);
					}
					else
					{
						Item.InstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
					}
					break;
				case 48:
					instance.amount = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 56:
					instance.skinID = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 66:
					instance.takenItems.Add(Item.DeserializeLengthDelimited(stream));
					break;
				case 72:
					instance.numCrafted = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 85:
					instance.conditionScale = ProtocolParser.ReadSingle(stream);
					break;
				case 88:
					instance.workbenchEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Task DeserializeLength(BufferStream stream, int length, Task instance, bool isDelta)
		{
			if (!isDelta && instance.takenItems == null)
			{
				instance.takenItems = Pool.Get<List<Item>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 21:
					instance.remainingTime = ProtocolParser.ReadSingle(stream);
					break;
				case 24:
					instance.taskUID = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 32:
					instance.cancelled = ProtocolParser.ReadBool(stream);
					break;
				case 42:
					if (instance.instanceData == null)
					{
						instance.instanceData = Item.InstanceData.DeserializeLengthDelimited(stream);
					}
					else
					{
						Item.InstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
					}
					break;
				case 48:
					instance.amount = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 56:
					instance.skinID = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 66:
					instance.takenItems.Add(Item.DeserializeLengthDelimited(stream));
					break;
				case 72:
					instance.numCrafted = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 85:
					instance.conditionScale = ProtocolParser.ReadSingle(stream);
					break;
				case 88:
					instance.workbenchEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Task instance, Task previous)
		{
			if (instance.itemID != previous.itemID)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
			}
			if (instance.remainingTime != previous.remainingTime)
			{
				stream.WriteByte(21);
				ProtocolParser.WriteSingle(stream, instance.remainingTime);
			}
			if (instance.taskUID != previous.taskUID)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.taskUID);
			}
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.cancelled);
			if (instance.instanceData != null)
			{
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Item.InstanceData.SerializeDelta(stream, instance.instanceData, previous.instanceData);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field instanceData (ProtoBuf.Item.InstanceData)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.amount != previous.amount)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
			}
			if (instance.skinID != previous.skinID)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.skinID);
			}
			if (instance.takenItems != null)
			{
				for (int i = 0; i < instance.takenItems.Count; i++)
				{
					Item item = instance.takenItems[i];
					stream.WriteByte(66);
					BufferStream.RangeHandle range2 = stream.GetRange(5);
					int position2 = stream.Position;
					Item.SerializeDelta(stream, item, item);
					int val = stream.Position - position2;
					Span<byte> span2 = range2.GetSpan();
					int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
					if (num2 < 5)
					{
						span2[num2 - 1] |= 128;
						while (num2 < 4)
						{
							span2[num2++] = 128;
						}
						span2[4] = 0;
					}
				}
			}
			if (instance.numCrafted != previous.numCrafted)
			{
				stream.WriteByte(72);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.numCrafted);
			}
			if (instance.conditionScale != previous.conditionScale)
			{
				stream.WriteByte(85);
				ProtocolParser.WriteSingle(stream, instance.conditionScale);
			}
			stream.WriteByte(88);
			ProtocolParser.WriteUInt64(stream, instance.workbenchEntity.Value);
		}

		public static void Serialize(BufferStream stream, Task instance)
		{
			if (instance.itemID != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
			}
			if (instance.remainingTime != 0f)
			{
				stream.WriteByte(21);
				ProtocolParser.WriteSingle(stream, instance.remainingTime);
			}
			if (instance.taskUID != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.taskUID);
			}
			if (instance.cancelled)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteBool(stream, instance.cancelled);
			}
			if (instance.instanceData != null)
			{
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Item.InstanceData.Serialize(stream, instance.instanceData);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field instanceData (ProtoBuf.Item.InstanceData)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.amount != 0)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
			}
			if (instance.skinID != 0)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.skinID);
			}
			if (instance.takenItems != null)
			{
				for (int i = 0; i < instance.takenItems.Count; i++)
				{
					Item instance2 = instance.takenItems[i];
					stream.WriteByte(66);
					BufferStream.RangeHandle range2 = stream.GetRange(5);
					int position2 = stream.Position;
					Item.Serialize(stream, instance2);
					int val = stream.Position - position2;
					Span<byte> span2 = range2.GetSpan();
					int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
					if (num2 < 5)
					{
						span2[num2 - 1] |= 128;
						while (num2 < 4)
						{
							span2[num2++] = 128;
						}
						span2[4] = 0;
					}
				}
			}
			if (instance.numCrafted != 0)
			{
				stream.WriteByte(72);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.numCrafted);
			}
			if (instance.conditionScale != 0f)
			{
				stream.WriteByte(85);
				ProtocolParser.WriteSingle(stream, instance.conditionScale);
			}
			if (instance.workbenchEntity != default(NetworkableId))
			{
				stream.WriteByte(88);
				ProtocolParser.WriteUInt64(stream, instance.workbenchEntity.Value);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			instanceData?.InspectUids(action);
			if (takenItems != null)
			{
				for (int i = 0; i < takenItems.Count; i++)
				{
					takenItems[i]?.InspectUids(action);
				}
			}
			action(UidType.Clear, ref workbenchEntity.Value);
		}
	}

	[NonSerialized]
	public List<Task> queue;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ItemCrafter instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.queue != null)
		{
			for (int i = 0; i < instance.queue.Count; i++)
			{
				if (instance.queue[i] != null)
				{
					instance.queue[i].ResetToPool();
					instance.queue[i] = null;
				}
			}
			List<Task> list = instance.queue;
			Pool.Free<Task>(ref list, false);
			instance.queue = list;
		}
		Pool.Free<ItemCrafter>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ItemCrafter with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ItemCrafter instance)
	{
		if (queue != null)
		{
			instance.queue = Pool.Get<List<Task>>();
			for (int i = 0; i < queue.Count; i++)
			{
				Task item = queue[i].Copy();
				instance.queue.Add(item);
			}
		}
		else
		{
			instance.queue = null;
		}
	}

	public ItemCrafter Copy()
	{
		ItemCrafter itemCrafter = Pool.Get<ItemCrafter>();
		CopyTo(itemCrafter);
		return itemCrafter;
	}

	public static ItemCrafter Deserialize(BufferStream stream)
	{
		ItemCrafter itemCrafter = Pool.Get<ItemCrafter>();
		Deserialize(stream, itemCrafter, isDelta: false);
		return itemCrafter;
	}

	public static ItemCrafter DeserializeLengthDelimited(BufferStream stream)
	{
		ItemCrafter itemCrafter = Pool.Get<ItemCrafter>();
		DeserializeLengthDelimited(stream, itemCrafter, isDelta: false);
		return itemCrafter;
	}

	public static ItemCrafter DeserializeLength(BufferStream stream, int length)
	{
		ItemCrafter itemCrafter = Pool.Get<ItemCrafter>();
		DeserializeLength(stream, length, itemCrafter, isDelta: false);
		return itemCrafter;
	}

	public static ItemCrafter Deserialize(byte[] buffer)
	{
		ItemCrafter itemCrafter = Pool.Get<ItemCrafter>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, itemCrafter, isDelta: false);
		return itemCrafter;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ItemCrafter previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ItemCrafter Deserialize(BufferStream stream, ItemCrafter instance, bool isDelta)
	{
		if (!isDelta && instance.queue == null)
		{
			instance.queue = Pool.Get<List<Task>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.queue.Add(Task.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ItemCrafter DeserializeLengthDelimited(BufferStream stream, ItemCrafter instance, bool isDelta)
	{
		if (!isDelta && instance.queue == null)
		{
			instance.queue = Pool.Get<List<Task>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.queue.Add(Task.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ItemCrafter DeserializeLength(BufferStream stream, int length, ItemCrafter instance, bool isDelta)
	{
		if (!isDelta && instance.queue == null)
		{
			instance.queue = Pool.Get<List<Task>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.queue.Add(Task.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ItemCrafter instance, ItemCrafter previous)
	{
		if (instance.queue == null)
		{
			return;
		}
		for (int i = 0; i < instance.queue.Count; i++)
		{
			Task task = instance.queue[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Task.SerializeDelta(stream, task, task);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, ItemCrafter instance)
	{
		if (instance.queue == null)
		{
			return;
		}
		for (int i = 0; i < instance.queue.Count; i++)
		{
			Task instance2 = instance.queue[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Task.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (queue != null)
		{
			for (int i = 0; i < queue.Count; i++)
			{
				queue[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ItemOwnershipAmount : IDisposable, IPooled, IProto<ItemOwnershipAmount>, IProto
{
	[NonSerialized]
	public string username;

	[NonSerialized]
	public string reason;

	[NonSerialized]
	public int amount;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ItemOwnershipAmount instance)
	{
		if (instance.ShouldPool)
		{
			instance.username = string.Empty;
			instance.reason = string.Empty;
			instance.amount = 0;
			Pool.Free<ItemOwnershipAmount>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ItemOwnershipAmount with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ItemOwnershipAmount instance)
	{
		instance.username = username;
		instance.reason = reason;
		instance.amount = amount;
	}

	public ItemOwnershipAmount Copy()
	{
		ItemOwnershipAmount itemOwnershipAmount = Pool.Get<ItemOwnershipAmount>();
		CopyTo(itemOwnershipAmount);
		return itemOwnershipAmount;
	}

	public static ItemOwnershipAmount Deserialize(BufferStream stream)
	{
		ItemOwnershipAmount itemOwnershipAmount = Pool.Get<ItemOwnershipAmount>();
		Deserialize(stream, itemOwnershipAmount, isDelta: false);
		return itemOwnershipAmount;
	}

	public static ItemOwnershipAmount DeserializeLengthDelimited(BufferStream stream)
	{
		ItemOwnershipAmount itemOwnershipAmount = Pool.Get<ItemOwnershipAmount>();
		DeserializeLengthDelimited(stream, itemOwnershipAmount, isDelta: false);
		return itemOwnershipAmount;
	}

	public static ItemOwnershipAmount DeserializeLength(BufferStream stream, int length)
	{
		ItemOwnershipAmount itemOwnershipAmount = Pool.Get<ItemOwnershipAmount>();
		DeserializeLength(stream, length, itemOwnershipAmount, isDelta: false);
		return itemOwnershipAmount;
	}

	public static ItemOwnershipAmount Deserialize(byte[] buffer)
	{
		ItemOwnershipAmount itemOwnershipAmount = Pool.Get<ItemOwnershipAmount>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, itemOwnershipAmount, isDelta: false);
		return itemOwnershipAmount;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ItemOwnershipAmount previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ItemOwnershipAmount Deserialize(BufferStream stream, ItemOwnershipAmount instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 26:
				instance.username = ProtocolParser.ReadString(stream);
				continue;
			case 10:
				instance.reason = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ItemOwnershipAmount DeserializeLengthDelimited(BufferStream stream, ItemOwnershipAmount instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 26:
				instance.username = ProtocolParser.ReadString(stream);
				continue;
			case 10:
				instance.reason = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ItemOwnershipAmount DeserializeLength(BufferStream stream, int length, ItemOwnershipAmount instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 26:
				instance.username = ProtocolParser.ReadString(stream);
				continue;
			case 10:
				instance.reason = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ItemOwnershipAmount instance, ItemOwnershipAmount previous)
	{
		if (instance.username != null && instance.username != previous.username)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.username);
		}
		if (instance.reason != null && instance.reason != previous.reason)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.reason);
		}
		if (instance.amount != previous.amount)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
	}

	public static void Serialize(BufferStream stream, ItemOwnershipAmount instance)
	{
		if (instance.username != null)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.username);
		}
		if (instance.reason != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.reason);
		}
		if (instance.amount != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class KeyLock : IDisposable, IPooled, IProto<KeyLock>, IProto
{
	[NonSerialized]
	public int code;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(KeyLock instance)
	{
		if (instance.ShouldPool)
		{
			instance.code = 0;
			Pool.Free<KeyLock>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose KeyLock with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(KeyLock instance)
	{
		instance.code = code;
	}

	public KeyLock Copy()
	{
		KeyLock keyLock = Pool.Get<KeyLock>();
		CopyTo(keyLock);
		return keyLock;
	}

	public static KeyLock Deserialize(BufferStream stream)
	{
		KeyLock keyLock = Pool.Get<KeyLock>();
		Deserialize(stream, keyLock, isDelta: false);
		return keyLock;
	}

	public static KeyLock DeserializeLengthDelimited(BufferStream stream)
	{
		KeyLock keyLock = Pool.Get<KeyLock>();
		DeserializeLengthDelimited(stream, keyLock, isDelta: false);
		return keyLock;
	}

	public static KeyLock DeserializeLength(BufferStream stream, int length)
	{
		KeyLock keyLock = Pool.Get<KeyLock>();
		DeserializeLength(stream, length, keyLock, isDelta: false);
		return keyLock;
	}

	public static KeyLock Deserialize(byte[] buffer)
	{
		KeyLock keyLock = Pool.Get<KeyLock>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, keyLock, isDelta: false);
		return keyLock;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, KeyLock previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static KeyLock Deserialize(BufferStream stream, KeyLock instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.code = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static KeyLock DeserializeLengthDelimited(BufferStream stream, KeyLock instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.code = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static KeyLock DeserializeLength(BufferStream stream, int length, KeyLock instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.code = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, KeyLock instance, KeyLock previous)
	{
		if (instance.code != previous.code)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.code);
		}
	}

	public static void Serialize(BufferStream stream, KeyLock instance)
	{
		if (instance.code != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.code);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Landmine : IDisposable, IPooled, IProto<Landmine>, IProto
{
	[NonSerialized]
	public ulong triggeredID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Landmine instance)
	{
		if (instance.ShouldPool)
		{
			instance.triggeredID = 0uL;
			Pool.Free<Landmine>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Landmine with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Landmine instance)
	{
		instance.triggeredID = triggeredID;
	}

	public Landmine Copy()
	{
		Landmine landmine = Pool.Get<Landmine>();
		CopyTo(landmine);
		return landmine;
	}

	public static Landmine Deserialize(BufferStream stream)
	{
		Landmine landmine = Pool.Get<Landmine>();
		Deserialize(stream, landmine, isDelta: false);
		return landmine;
	}

	public static Landmine DeserializeLengthDelimited(BufferStream stream)
	{
		Landmine landmine = Pool.Get<Landmine>();
		DeserializeLengthDelimited(stream, landmine, isDelta: false);
		return landmine;
	}

	public static Landmine DeserializeLength(BufferStream stream, int length)
	{
		Landmine landmine = Pool.Get<Landmine>();
		DeserializeLength(stream, length, landmine, isDelta: false);
		return landmine;
	}

	public static Landmine Deserialize(byte[] buffer)
	{
		Landmine landmine = Pool.Get<Landmine>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, landmine, isDelta: false);
		return landmine;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Landmine previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Landmine Deserialize(BufferStream stream, Landmine instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.triggeredID = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Landmine DeserializeLengthDelimited(BufferStream stream, Landmine instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.triggeredID = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Landmine DeserializeLength(BufferStream stream, int length, Landmine instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.triggeredID = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Landmine instance, Landmine previous)
	{
		if (instance.triggeredID != previous.triggeredID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.triggeredID);
		}
	}

	public static void Serialize(BufferStream stream, Landmine instance)
	{
		if (instance.triggeredID != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.triggeredID);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class LegacyShelter : IDisposable, IPooled, IProto<LegacyShelter>, IProto
{
	[NonSerialized]
	public NetworkableId doorID;

	[NonSerialized]
	public float timeSinceInteracted;

	[NonSerialized]
	public ulong ownerId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(LegacyShelter instance)
	{
		if (instance.ShouldPool)
		{
			instance.doorID = default(NetworkableId);
			instance.timeSinceInteracted = 0f;
			instance.ownerId = 0uL;
			Pool.Free<LegacyShelter>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose LegacyShelter with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(LegacyShelter instance)
	{
		instance.doorID = doorID;
		instance.timeSinceInteracted = timeSinceInteracted;
		instance.ownerId = ownerId;
	}

	public LegacyShelter Copy()
	{
		LegacyShelter legacyShelter = Pool.Get<LegacyShelter>();
		CopyTo(legacyShelter);
		return legacyShelter;
	}

	public static LegacyShelter Deserialize(BufferStream stream)
	{
		LegacyShelter legacyShelter = Pool.Get<LegacyShelter>();
		Deserialize(stream, legacyShelter, isDelta: false);
		return legacyShelter;
	}

	public static LegacyShelter DeserializeLengthDelimited(BufferStream stream)
	{
		LegacyShelter legacyShelter = Pool.Get<LegacyShelter>();
		DeserializeLengthDelimited(stream, legacyShelter, isDelta: false);
		return legacyShelter;
	}

	public static LegacyShelter DeserializeLength(BufferStream stream, int length)
	{
		LegacyShelter legacyShelter = Pool.Get<LegacyShelter>();
		DeserializeLength(stream, length, legacyShelter, isDelta: false);
		return legacyShelter;
	}

	public static LegacyShelter Deserialize(byte[] buffer)
	{
		LegacyShelter legacyShelter = Pool.Get<LegacyShelter>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, legacyShelter, isDelta: false);
		return legacyShelter;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, LegacyShelter previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static LegacyShelter Deserialize(BufferStream stream, LegacyShelter instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.doorID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.timeSinceInteracted = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.ownerId = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static LegacyShelter DeserializeLengthDelimited(BufferStream stream, LegacyShelter instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.doorID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.timeSinceInteracted = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.ownerId = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static LegacyShelter DeserializeLength(BufferStream stream, int length, LegacyShelter instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.doorID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.timeSinceInteracted = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.ownerId = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, LegacyShelter instance, LegacyShelter previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.doorID.Value);
		if (instance.timeSinceInteracted != previous.timeSinceInteracted)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.timeSinceInteracted);
		}
		if (instance.ownerId != previous.ownerId)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.ownerId);
		}
	}

	public static void Serialize(BufferStream stream, LegacyShelter instance)
	{
		if (instance.doorID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.doorID.Value);
		}
		if (instance.timeSinceInteracted != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.timeSinceInteracted);
		}
		if (instance.ownerId != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.ownerId);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref doorID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Lift : IDisposable, IPooled, IProto<Lift>, IProto
{
	[NonSerialized]
	public int floor;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Lift instance)
	{
		if (instance.ShouldPool)
		{
			instance.floor = 0;
			Pool.Free<Lift>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Lift with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Lift instance)
	{
		instance.floor = floor;
	}

	public Lift Copy()
	{
		Lift lift = Pool.Get<Lift>();
		CopyTo(lift);
		return lift;
	}

	public static Lift Deserialize(BufferStream stream)
	{
		Lift lift = Pool.Get<Lift>();
		Deserialize(stream, lift, isDelta: false);
		return lift;
	}

	public static Lift DeserializeLengthDelimited(BufferStream stream)
	{
		Lift lift = Pool.Get<Lift>();
		DeserializeLengthDelimited(stream, lift, isDelta: false);
		return lift;
	}

	public static Lift DeserializeLength(BufferStream stream, int length)
	{
		Lift lift = Pool.Get<Lift>();
		DeserializeLength(stream, length, lift, isDelta: false);
		return lift;
	}

	public static Lift Deserialize(byte[] buffer)
	{
		Lift lift = Pool.Get<Lift>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, lift, isDelta: false);
		return lift;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Lift previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Lift Deserialize(BufferStream stream, Lift instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.floor = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Lift DeserializeLengthDelimited(BufferStream stream, Lift instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.floor = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Lift DeserializeLength(BufferStream stream, int length, Lift instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.floor = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Lift instance, Lift previous)
	{
		if (instance.floor != previous.floor)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.floor);
		}
	}

	public static void Serialize(BufferStream stream, Lift instance)
	{
		if (instance.floor != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.floor);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class LightDeployer : IDisposable, IPooled, IProto<LightDeployer>, IProto
{
	[NonSerialized]
	public NetworkableId active;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(LightDeployer instance)
	{
		if (instance.ShouldPool)
		{
			instance.active = default(NetworkableId);
			Pool.Free<LightDeployer>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose LightDeployer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(LightDeployer instance)
	{
		instance.active = active;
	}

	public LightDeployer Copy()
	{
		LightDeployer lightDeployer = Pool.Get<LightDeployer>();
		CopyTo(lightDeployer);
		return lightDeployer;
	}

	public static LightDeployer Deserialize(BufferStream stream)
	{
		LightDeployer lightDeployer = Pool.Get<LightDeployer>();
		Deserialize(stream, lightDeployer, isDelta: false);
		return lightDeployer;
	}

	public static LightDeployer DeserializeLengthDelimited(BufferStream stream)
	{
		LightDeployer lightDeployer = Pool.Get<LightDeployer>();
		DeserializeLengthDelimited(stream, lightDeployer, isDelta: false);
		return lightDeployer;
	}

	public static LightDeployer DeserializeLength(BufferStream stream, int length)
	{
		LightDeployer lightDeployer = Pool.Get<LightDeployer>();
		DeserializeLength(stream, length, lightDeployer, isDelta: false);
		return lightDeployer;
	}

	public static LightDeployer Deserialize(byte[] buffer)
	{
		LightDeployer lightDeployer = Pool.Get<LightDeployer>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, lightDeployer, isDelta: false);
		return lightDeployer;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, LightDeployer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static LightDeployer Deserialize(BufferStream stream, LightDeployer instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.active = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static LightDeployer DeserializeLengthDelimited(BufferStream stream, LightDeployer instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.active = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static LightDeployer DeserializeLength(BufferStream stream, int length, LightDeployer instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.active = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, LightDeployer instance, LightDeployer previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.active.Value);
	}

	public static void Serialize(BufferStream stream, LightDeployer instance)
	{
		if (instance.active != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.active.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref active.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class LightString : IDisposable, IPooled, IProto<LightString>, IProto
{
	public class StringPoint : IDisposable, IPooled, IProto<StringPoint>, IProto
	{
		[NonSerialized]
		public Vector3 point;

		[NonSerialized]
		public Vector3 normal;

		[NonSerialized]
		public float slack;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(StringPoint instance)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.point = default(Vector3);
				instance.normal = default(Vector3);
				instance.slack = 0f;
				Pool.Free<StringPoint>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose StringPoint with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(StringPoint instance)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			instance.point = point;
			instance.normal = normal;
			instance.slack = slack;
		}

		public StringPoint Copy()
		{
			StringPoint stringPoint = Pool.Get<StringPoint>();
			CopyTo(stringPoint);
			return stringPoint;
		}

		public static StringPoint Deserialize(BufferStream stream)
		{
			StringPoint stringPoint = Pool.Get<StringPoint>();
			Deserialize(stream, stringPoint, isDelta: false);
			return stringPoint;
		}

		public static StringPoint DeserializeLengthDelimited(BufferStream stream)
		{
			StringPoint stringPoint = Pool.Get<StringPoint>();
			DeserializeLengthDelimited(stream, stringPoint, isDelta: false);
			return stringPoint;
		}

		public static StringPoint DeserializeLength(BufferStream stream, int length)
		{
			StringPoint stringPoint = Pool.Get<StringPoint>();
			DeserializeLength(stream, length, stringPoint, isDelta: false);
			return stringPoint;
		}

		public static StringPoint Deserialize(byte[] buffer)
		{
			StringPoint stringPoint = Pool.Get<StringPoint>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, stringPoint, isDelta: false);
			return stringPoint;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, StringPoint previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static StringPoint Deserialize(BufferStream stream, StringPoint instance, bool isDelta)
		{
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.point, isDelta);
					continue;
				case 18:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
					continue;
				case 29:
					instance.slack = ProtocolParser.ReadSingle(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static StringPoint DeserializeLengthDelimited(BufferStream stream, StringPoint instance, bool isDelta)
		{
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.point, isDelta);
					continue;
				case 18:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
					continue;
				case 29:
					instance.slack = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static StringPoint DeserializeLength(BufferStream stream, int length, StringPoint instance, bool isDelta)
		{
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.point, isDelta);
					continue;
				case 18:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
					continue;
				case 29:
					instance.slack = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, StringPoint instance, StringPoint previous)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			if (instance.point != previous.point)
			{
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.point, previous.point);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field point (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.normal != previous.normal)
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.normal, previous.normal);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field normal (UnityEngine.Vector3)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.slack != previous.slack)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.slack);
			}
		}

		public static void Serialize(BufferStream stream, StringPoint instance)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			if (instance.point != default(Vector3))
			{
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.Serialize(stream, instance.point);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field point (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.normal != default(Vector3))
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				Vector3Serialized.Serialize(stream, instance.normal);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field normal (UnityEngine.Vector3)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.slack != 0f)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.slack);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<StringPoint> points;

	[NonSerialized]
	public int lengthUsed;

	[NonSerialized]
	public int animationStyle;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(LightString instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.points != null)
		{
			for (int i = 0; i < instance.points.Count; i++)
			{
				if (instance.points[i] != null)
				{
					instance.points[i].ResetToPool();
					instance.points[i] = null;
				}
			}
			List<StringPoint> list = instance.points;
			Pool.Free<StringPoint>(ref list, false);
			instance.points = list;
		}
		instance.lengthUsed = 0;
		instance.animationStyle = 0;
		Pool.Free<LightString>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose LightString with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(LightString instance)
	{
		if (points != null)
		{
			instance.points = Pool.Get<List<StringPoint>>();
			for (int i = 0; i < points.Count; i++)
			{
				StringPoint item = points[i].Copy();
				instance.points.Add(item);
			}
		}
		else
		{
			instance.points = null;
		}
		instance.lengthUsed = lengthUsed;
		instance.animationStyle = animationStyle;
	}

	public LightString Copy()
	{
		LightString lightString = Pool.Get<LightString>();
		CopyTo(lightString);
		return lightString;
	}

	public static LightString Deserialize(BufferStream stream)
	{
		LightString lightString = Pool.Get<LightString>();
		Deserialize(stream, lightString, isDelta: false);
		return lightString;
	}

	public static LightString DeserializeLengthDelimited(BufferStream stream)
	{
		LightString lightString = Pool.Get<LightString>();
		DeserializeLengthDelimited(stream, lightString, isDelta: false);
		return lightString;
	}

	public static LightString DeserializeLength(BufferStream stream, int length)
	{
		LightString lightString = Pool.Get<LightString>();
		DeserializeLength(stream, length, lightString, isDelta: false);
		return lightString;
	}

	public static LightString Deserialize(byte[] buffer)
	{
		LightString lightString = Pool.Get<LightString>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, lightString, isDelta: false);
		return lightString;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, LightString previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static LightString Deserialize(BufferStream stream, LightString instance, bool isDelta)
	{
		if (!isDelta && instance.points == null)
		{
			instance.points = Pool.Get<List<StringPoint>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.points.Add(StringPoint.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.lengthUsed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.animationStyle = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static LightString DeserializeLengthDelimited(BufferStream stream, LightString instance, bool isDelta)
	{
		if (!isDelta && instance.points == null)
		{
			instance.points = Pool.Get<List<StringPoint>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.points.Add(StringPoint.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.lengthUsed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.animationStyle = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static LightString DeserializeLength(BufferStream stream, int length, LightString instance, bool isDelta)
	{
		if (!isDelta && instance.points == null)
		{
			instance.points = Pool.Get<List<StringPoint>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.points.Add(StringPoint.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.lengthUsed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.animationStyle = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, LightString instance, LightString previous)
	{
		if (instance.points != null)
		{
			for (int i = 0; i < instance.points.Count; i++)
			{
				StringPoint stringPoint = instance.points[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				StringPoint.SerializeDelta(stream, stringPoint, stringPoint);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field points (ProtoBuf.LightString.StringPoint)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.lengthUsed != previous.lengthUsed)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lengthUsed);
		}
		if (instance.animationStyle != previous.animationStyle)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.animationStyle);
		}
	}

	public static void Serialize(BufferStream stream, LightString instance)
	{
		if (instance.points != null)
		{
			for (int i = 0; i < instance.points.Count; i++)
			{
				StringPoint instance2 = instance.points[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				StringPoint.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field points (ProtoBuf.LightString.StringPoint)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.lengthUsed != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lengthUsed);
		}
		if (instance.animationStyle != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.animationStyle);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (points != null)
		{
			for (int i = 0; i < points.Count; i++)
			{
				points[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class LinePoint : IDisposable, IPooled, IProto<LinePoint>, IProto
{
	[NonSerialized]
	public Vector3 localPosition;

	[NonSerialized]
	public Vector3 worldNormal;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(LinePoint instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.localPosition = default(Vector3);
			instance.worldNormal = default(Vector3);
			Pool.Free<LinePoint>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose LinePoint with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(LinePoint instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.localPosition = localPosition;
		instance.worldNormal = worldNormal;
	}

	public LinePoint Copy()
	{
		LinePoint linePoint = Pool.Get<LinePoint>();
		CopyTo(linePoint);
		return linePoint;
	}

	public static LinePoint Deserialize(BufferStream stream)
	{
		LinePoint linePoint = Pool.Get<LinePoint>();
		Deserialize(stream, linePoint, isDelta: false);
		return linePoint;
	}

	public static LinePoint DeserializeLengthDelimited(BufferStream stream)
	{
		LinePoint linePoint = Pool.Get<LinePoint>();
		DeserializeLengthDelimited(stream, linePoint, isDelta: false);
		return linePoint;
	}

	public static LinePoint DeserializeLength(BufferStream stream, int length)
	{
		LinePoint linePoint = Pool.Get<LinePoint>();
		DeserializeLength(stream, length, linePoint, isDelta: false);
		return linePoint;
	}

	public static LinePoint Deserialize(byte[] buffer)
	{
		LinePoint linePoint = Pool.Get<LinePoint>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, linePoint, isDelta: false);
		return linePoint;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, LinePoint previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static LinePoint Deserialize(BufferStream stream, LinePoint instance, bool isDelta)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.localPosition, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldNormal, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static LinePoint DeserializeLengthDelimited(BufferStream stream, LinePoint instance, bool isDelta)
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.localPosition, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldNormal, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static LinePoint DeserializeLength(BufferStream stream, int length, LinePoint instance, bool isDelta)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.localPosition, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldNormal, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, LinePoint instance, LinePoint previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		if (instance.localPosition != previous.localPosition)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.localPosition, previous.localPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field localPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.worldNormal != previous.worldNormal)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.worldNormal, previous.worldNormal);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldNormal (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public static void Serialize(BufferStream stream, LinePoint instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		if (instance.localPosition != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.localPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field localPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.worldNormal != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.worldNormal);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldNormal (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Loot : IDisposable, IPooled, IProto<Loot>, IProto
{
	[NonSerialized]
	public ItemContainer contents;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Loot instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.contents != null)
			{
				instance.contents.ResetToPool();
				instance.contents = null;
			}
			Pool.Free<Loot>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Loot with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Loot instance)
	{
		if (contents != null)
		{
			if (instance.contents == null)
			{
				instance.contents = contents.Copy();
			}
			else
			{
				contents.CopyTo(instance.contents);
			}
		}
		else
		{
			instance.contents = null;
		}
	}

	public Loot Copy()
	{
		Loot loot = Pool.Get<Loot>();
		CopyTo(loot);
		return loot;
	}

	public static Loot Deserialize(BufferStream stream)
	{
		Loot loot = Pool.Get<Loot>();
		Deserialize(stream, loot, isDelta: false);
		return loot;
	}

	public static Loot DeserializeLengthDelimited(BufferStream stream)
	{
		Loot loot = Pool.Get<Loot>();
		DeserializeLengthDelimited(stream, loot, isDelta: false);
		return loot;
	}

	public static Loot DeserializeLength(BufferStream stream, int length)
	{
		Loot loot = Pool.Get<Loot>();
		DeserializeLength(stream, length, loot, isDelta: false);
		return loot;
	}

	public static Loot Deserialize(byte[] buffer)
	{
		Loot loot = Pool.Get<Loot>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, loot, isDelta: false);
		return loot;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Loot previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Loot Deserialize(BufferStream stream, Loot instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.contents == null)
				{
					instance.contents = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.contents, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static Loot DeserializeLengthDelimited(BufferStream stream, Loot instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.contents == null)
				{
					instance.contents = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.contents, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Loot DeserializeLength(BufferStream stream, int length, Loot instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.contents == null)
				{
					instance.contents = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.contents, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Loot instance, Loot previous)
	{
		if (instance.contents == null)
		{
			return;
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ItemContainer.SerializeDelta(stream, instance.contents, previous.contents);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, Loot instance)
	{
		if (instance.contents == null)
		{
			return;
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ItemContainer.Serialize(stream, instance.contents);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		contents?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class LootableCorpse : IDisposable, IPooled, IProto<LootableCorpse>, IProto
{
	public class Private : IDisposable, IPooled, IProto<Private>, IProto
	{
		[NonSerialized]
		public List<ItemContainer> container;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Private instance)
		{
			if (!instance.ShouldPool)
			{
				return;
			}
			if (instance.container != null)
			{
				for (int i = 0; i < instance.container.Count; i++)
				{
					if (instance.container[i] != null)
					{
						instance.container[i].ResetToPool();
						instance.container[i] = null;
					}
				}
				List<ItemContainer> list = instance.container;
				Pool.Free<ItemContainer>(ref list, false);
				instance.container = list;
			}
			Pool.Free<Private>(ref instance);
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Private with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Private instance)
		{
			if (container != null)
			{
				instance.container = Pool.Get<List<ItemContainer>>();
				for (int i = 0; i < container.Count; i++)
				{
					ItemContainer item = container[i].Copy();
					instance.container.Add(item);
				}
			}
			else
			{
				instance.container = null;
			}
		}

		public Private Copy()
		{
			Private @private = Pool.Get<Private>();
			CopyTo(@private);
			return @private;
		}

		public static Private Deserialize(BufferStream stream)
		{
			Private @private = Pool.Get<Private>();
			Deserialize(stream, @private, isDelta: false);
			return @private;
		}

		public static Private DeserializeLengthDelimited(BufferStream stream)
		{
			Private @private = Pool.Get<Private>();
			DeserializeLengthDelimited(stream, @private, isDelta: false);
			return @private;
		}

		public static Private DeserializeLength(BufferStream stream, int length)
		{
			Private @private = Pool.Get<Private>();
			DeserializeLength(stream, length, @private, isDelta: false);
			return @private;
		}

		public static Private Deserialize(byte[] buffer)
		{
			Private @private = Pool.Get<Private>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, @private, isDelta: false);
			return @private;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Private previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Private Deserialize(BufferStream stream, Private instance, bool isDelta)
		{
			if (!isDelta && instance.container == null)
			{
				instance.container = Pool.Get<List<ItemContainer>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.container.Add(ItemContainer.DeserializeLengthDelimited(stream));
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Private DeserializeLengthDelimited(BufferStream stream, Private instance, bool isDelta)
		{
			if (!isDelta && instance.container == null)
			{
				instance.container = Pool.Get<List<ItemContainer>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.container.Add(ItemContainer.DeserializeLengthDelimited(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Private DeserializeLength(BufferStream stream, int length, Private instance, bool isDelta)
		{
			if (!isDelta && instance.container == null)
			{
				instance.container = Pool.Get<List<ItemContainer>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.container.Add(ItemContainer.DeserializeLengthDelimited(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Private instance, Private previous)
		{
			if (instance.container == null)
			{
				return;
			}
			for (int i = 0; i < instance.container.Count; i++)
			{
				ItemContainer itemContainer = instance.container[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				ItemContainer.SerializeDelta(stream, itemContainer, itemContainer);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}

		public static void Serialize(BufferStream stream, Private instance)
		{
			if (instance.container == null)
			{
				return;
			}
			for (int i = 0; i < instance.container.Count; i++)
			{
				ItemContainer instance2 = instance.container[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				ItemContainer.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			if (container != null)
			{
				for (int i = 0; i < container.Count; i++)
				{
					container[i]?.InspectUids(action);
				}
			}
		}
	}

	[NonSerialized]
	public Private privateData;

	[NonSerialized]
	public ulong playerID;

	[NonSerialized]
	public string playerName;

	[NonSerialized]
	public uint underwearSkin;

	[NonSerialized]
	public string streamerName;

	[NonSerialized]
	public int paintballColor;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(LootableCorpse instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.privateData != null)
			{
				instance.privateData.ResetToPool();
				instance.privateData = null;
			}
			instance.playerID = 0uL;
			instance.playerName = string.Empty;
			instance.underwearSkin = 0u;
			instance.streamerName = string.Empty;
			instance.paintballColor = 0;
			Pool.Free<LootableCorpse>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose LootableCorpse with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(LootableCorpse instance)
	{
		if (privateData != null)
		{
			if (instance.privateData == null)
			{
				instance.privateData = privateData.Copy();
			}
			else
			{
				privateData.CopyTo(instance.privateData);
			}
		}
		else
		{
			instance.privateData = null;
		}
		instance.playerID = playerID;
		instance.playerName = playerName;
		instance.underwearSkin = underwearSkin;
		instance.streamerName = streamerName;
		instance.paintballColor = paintballColor;
	}

	public LootableCorpse Copy()
	{
		LootableCorpse lootableCorpse = Pool.Get<LootableCorpse>();
		CopyTo(lootableCorpse);
		return lootableCorpse;
	}

	public static LootableCorpse Deserialize(BufferStream stream)
	{
		LootableCorpse lootableCorpse = Pool.Get<LootableCorpse>();
		Deserialize(stream, lootableCorpse, isDelta: false);
		return lootableCorpse;
	}

	public static LootableCorpse DeserializeLengthDelimited(BufferStream stream)
	{
		LootableCorpse lootableCorpse = Pool.Get<LootableCorpse>();
		DeserializeLengthDelimited(stream, lootableCorpse, isDelta: false);
		return lootableCorpse;
	}

	public static LootableCorpse DeserializeLength(BufferStream stream, int length)
	{
		LootableCorpse lootableCorpse = Pool.Get<LootableCorpse>();
		DeserializeLength(stream, length, lootableCorpse, isDelta: false);
		return lootableCorpse;
	}

	public static LootableCorpse Deserialize(byte[] buffer)
	{
		LootableCorpse lootableCorpse = Pool.Get<LootableCorpse>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, lootableCorpse, isDelta: false);
		return lootableCorpse;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, LootableCorpse previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static LootableCorpse Deserialize(BufferStream stream, LootableCorpse instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.privateData == null)
				{
					instance.privateData = Private.DeserializeLengthDelimited(stream);
				}
				else
				{
					Private.DeserializeLengthDelimited(stream, instance.privateData, isDelta);
				}
				break;
			case 16:
				instance.playerID = ProtocolParser.ReadUInt64(stream);
				break;
			case 26:
				instance.playerName = ProtocolParser.ReadString(stream);
				break;
			case 32:
				instance.underwearSkin = ProtocolParser.ReadUInt32(stream);
				break;
			case 42:
				instance.streamerName = ProtocolParser.ReadString(stream);
				break;
			case 48:
				instance.paintballColor = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static LootableCorpse DeserializeLengthDelimited(BufferStream stream, LootableCorpse instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.privateData == null)
				{
					instance.privateData = Private.DeserializeLengthDelimited(stream);
				}
				else
				{
					Private.DeserializeLengthDelimited(stream, instance.privateData, isDelta);
				}
				break;
			case 16:
				instance.playerID = ProtocolParser.ReadUInt64(stream);
				break;
			case 26:
				instance.playerName = ProtocolParser.ReadString(stream);
				break;
			case 32:
				instance.underwearSkin = ProtocolParser.ReadUInt32(stream);
				break;
			case 42:
				instance.streamerName = ProtocolParser.ReadString(stream);
				break;
			case 48:
				instance.paintballColor = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static LootableCorpse DeserializeLength(BufferStream stream, int length, LootableCorpse instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.privateData == null)
				{
					instance.privateData = Private.DeserializeLengthDelimited(stream);
				}
				else
				{
					Private.DeserializeLengthDelimited(stream, instance.privateData, isDelta);
				}
				break;
			case 16:
				instance.playerID = ProtocolParser.ReadUInt64(stream);
				break;
			case 26:
				instance.playerName = ProtocolParser.ReadString(stream);
				break;
			case 32:
				instance.underwearSkin = ProtocolParser.ReadUInt32(stream);
				break;
			case 42:
				instance.streamerName = ProtocolParser.ReadString(stream);
				break;
			case 48:
				instance.paintballColor = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, LootableCorpse instance, LootableCorpse previous)
	{
		if (instance.privateData != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Private.SerializeDelta(stream, instance.privateData, previous.privateData);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.playerID != previous.playerID)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.playerID);
		}
		if (instance.playerName != null && instance.playerName != previous.playerName)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.playerName);
		}
		if (instance.underwearSkin != previous.underwearSkin)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.underwearSkin);
		}
		if (instance.streamerName != null && instance.streamerName != previous.streamerName)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.streamerName);
		}
		if (instance.paintballColor != previous.paintballColor)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.paintballColor);
		}
	}

	public static void Serialize(BufferStream stream, LootableCorpse instance)
	{
		if (instance.privateData != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Private.Serialize(stream, instance.privateData);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.playerID != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.playerID);
		}
		if (instance.playerName != null)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.playerName);
		}
		if (instance.underwearSkin != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.underwearSkin);
		}
		if (instance.streamerName != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.streamerName);
		}
		if (instance.paintballColor != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.paintballColor);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		privateData?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Magazine : IDisposable, IPooled, IProto<Magazine>, IProto
{
	[NonSerialized]
	public int capacity;

	[NonSerialized]
	public int contents;

	[NonSerialized]
	public int ammoType;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Magazine instance)
	{
		if (instance.ShouldPool)
		{
			instance.capacity = 0;
			instance.contents = 0;
			instance.ammoType = 0;
			Pool.Free<Magazine>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Magazine with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Magazine instance)
	{
		instance.capacity = capacity;
		instance.contents = contents;
		instance.ammoType = ammoType;
	}

	public Magazine Copy()
	{
		Magazine magazine = Pool.Get<Magazine>();
		CopyTo(magazine);
		return magazine;
	}

	public static Magazine Deserialize(BufferStream stream)
	{
		Magazine magazine = Pool.Get<Magazine>();
		Deserialize(stream, magazine, isDelta: false);
		return magazine;
	}

	public static Magazine DeserializeLengthDelimited(BufferStream stream)
	{
		Magazine magazine = Pool.Get<Magazine>();
		DeserializeLengthDelimited(stream, magazine, isDelta: false);
		return magazine;
	}

	public static Magazine DeserializeLength(BufferStream stream, int length)
	{
		Magazine magazine = Pool.Get<Magazine>();
		DeserializeLength(stream, length, magazine, isDelta: false);
		return magazine;
	}

	public static Magazine Deserialize(byte[] buffer)
	{
		Magazine magazine = Pool.Get<Magazine>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, magazine, isDelta: false);
		return magazine;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Magazine previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Magazine Deserialize(BufferStream stream, Magazine instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.capacity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.contents = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Magazine DeserializeLengthDelimited(BufferStream stream, Magazine instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.capacity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.contents = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Magazine DeserializeLength(BufferStream stream, int length, Magazine instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.capacity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.contents = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Magazine instance, Magazine previous)
	{
		if (instance.capacity != previous.capacity)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.capacity);
		}
		if (instance.contents != previous.contents)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.contents);
		}
		if (instance.ammoType != previous.ammoType)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoType);
		}
	}

	public static void Serialize(BufferStream stream, Magazine instance)
	{
		if (instance.capacity != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.capacity);
		}
		if (instance.contents != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.contents);
		}
		if (instance.ammoType != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoType);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Mailbox : IDisposable, IPooled, IProto<Mailbox>, IProto
{
	[NonSerialized]
	public ItemContainer inventory;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Mailbox instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.inventory != null)
			{
				instance.inventory.ResetToPool();
				instance.inventory = null;
			}
			Pool.Free<Mailbox>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Mailbox with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Mailbox instance)
	{
		if (inventory != null)
		{
			if (instance.inventory == null)
			{
				instance.inventory = inventory.Copy();
			}
			else
			{
				inventory.CopyTo(instance.inventory);
			}
		}
		else
		{
			instance.inventory = null;
		}
	}

	public Mailbox Copy()
	{
		Mailbox mailbox = Pool.Get<Mailbox>();
		CopyTo(mailbox);
		return mailbox;
	}

	public static Mailbox Deserialize(BufferStream stream)
	{
		Mailbox mailbox = Pool.Get<Mailbox>();
		Deserialize(stream, mailbox, isDelta: false);
		return mailbox;
	}

	public static Mailbox DeserializeLengthDelimited(BufferStream stream)
	{
		Mailbox mailbox = Pool.Get<Mailbox>();
		DeserializeLengthDelimited(stream, mailbox, isDelta: false);
		return mailbox;
	}

	public static Mailbox DeserializeLength(BufferStream stream, int length)
	{
		Mailbox mailbox = Pool.Get<Mailbox>();
		DeserializeLength(stream, length, mailbox, isDelta: false);
		return mailbox;
	}

	public static Mailbox Deserialize(byte[] buffer)
	{
		Mailbox mailbox = Pool.Get<Mailbox>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, mailbox, isDelta: false);
		return mailbox;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Mailbox previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Mailbox Deserialize(BufferStream stream, Mailbox instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.inventory == null)
				{
					instance.inventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.inventory, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static Mailbox DeserializeLengthDelimited(BufferStream stream, Mailbox instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.inventory == null)
				{
					instance.inventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.inventory, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Mailbox DeserializeLength(BufferStream stream, int length, Mailbox instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.inventory == null)
				{
					instance.inventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.inventory, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Mailbox instance, Mailbox previous)
	{
		if (instance.inventory == null)
		{
			return;
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ItemContainer.SerializeDelta(stream, instance.inventory, previous.inventory);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, Mailbox instance)
	{
		if (instance.inventory == null)
		{
			return;
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ItemContainer.Serialize(stream, instance.inventory);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		inventory?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Mannequin : IDisposable, IPooled, IProto<Mannequin>, IProto
{
	public class ClothingItem : IDisposable, IPooled, IProto<ClothingItem>, IProto
	{
		[NonSerialized]
		public int itemId;

		[NonSerialized]
		public ulong skin;

		[NonSerialized]
		public ItemId uid;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(ClothingItem instance)
		{
			if (instance.ShouldPool)
			{
				instance.itemId = 0;
				instance.skin = 0uL;
				instance.uid = default(ItemId);
				Pool.Free<ClothingItem>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose ClothingItem with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(ClothingItem instance)
		{
			instance.itemId = itemId;
			instance.skin = skin;
			instance.uid = uid;
		}

		public ClothingItem Copy()
		{
			ClothingItem clothingItem = Pool.Get<ClothingItem>();
			CopyTo(clothingItem);
			return clothingItem;
		}

		public static ClothingItem Deserialize(BufferStream stream)
		{
			ClothingItem clothingItem = Pool.Get<ClothingItem>();
			Deserialize(stream, clothingItem, isDelta: false);
			return clothingItem;
		}

		public static ClothingItem DeserializeLengthDelimited(BufferStream stream)
		{
			ClothingItem clothingItem = Pool.Get<ClothingItem>();
			DeserializeLengthDelimited(stream, clothingItem, isDelta: false);
			return clothingItem;
		}

		public static ClothingItem DeserializeLength(BufferStream stream, int length)
		{
			ClothingItem clothingItem = Pool.Get<ClothingItem>();
			DeserializeLength(stream, length, clothingItem, isDelta: false);
			return clothingItem;
		}

		public static ClothingItem Deserialize(byte[] buffer)
		{
			ClothingItem clothingItem = Pool.Get<ClothingItem>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, clothingItem, isDelta: false);
			return clothingItem;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, ClothingItem previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static ClothingItem Deserialize(BufferStream stream, ClothingItem instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.skin = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.uid = new ItemId(ProtocolParser.ReadUInt64(stream));
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static ClothingItem DeserializeLengthDelimited(BufferStream stream, ClothingItem instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.skin = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.uid = new ItemId(ProtocolParser.ReadUInt64(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static ClothingItem DeserializeLength(BufferStream stream, int length, ClothingItem instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.skin = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.uid = new ItemId(ProtocolParser.ReadUInt64(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, ClothingItem instance, ClothingItem previous)
		{
			if (instance.itemId != previous.itemId)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
			}
			if (instance.skin != previous.skin)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.skin);
			}
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.uid.Value);
		}

		public static void Serialize(BufferStream stream, ClothingItem instance)
		{
			if (instance.itemId != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
			}
			if (instance.skin != 0L)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.skin);
			}
			if (instance.uid != default(ItemId))
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, instance.uid.Value);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			action(UidType.ItemId, ref uid.Value);
		}
	}

	[NonSerialized]
	public List<ClothingItem> clothingItems;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Mannequin instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.clothingItems != null)
		{
			for (int i = 0; i < instance.clothingItems.Count; i++)
			{
				if (instance.clothingItems[i] != null)
				{
					instance.clothingItems[i].ResetToPool();
					instance.clothingItems[i] = null;
				}
			}
			List<ClothingItem> list = instance.clothingItems;
			Pool.Free<ClothingItem>(ref list, false);
			instance.clothingItems = list;
		}
		Pool.Free<Mannequin>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Mannequin with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Mannequin instance)
	{
		if (clothingItems != null)
		{
			instance.clothingItems = Pool.Get<List<ClothingItem>>();
			for (int i = 0; i < clothingItems.Count; i++)
			{
				ClothingItem item = clothingItems[i].Copy();
				instance.clothingItems.Add(item);
			}
		}
		else
		{
			instance.clothingItems = null;
		}
	}

	public Mannequin Copy()
	{
		Mannequin mannequin = Pool.Get<Mannequin>();
		CopyTo(mannequin);
		return mannequin;
	}

	public static Mannequin Deserialize(BufferStream stream)
	{
		Mannequin mannequin = Pool.Get<Mannequin>();
		Deserialize(stream, mannequin, isDelta: false);
		return mannequin;
	}

	public static Mannequin DeserializeLengthDelimited(BufferStream stream)
	{
		Mannequin mannequin = Pool.Get<Mannequin>();
		DeserializeLengthDelimited(stream, mannequin, isDelta: false);
		return mannequin;
	}

	public static Mannequin DeserializeLength(BufferStream stream, int length)
	{
		Mannequin mannequin = Pool.Get<Mannequin>();
		DeserializeLength(stream, length, mannequin, isDelta: false);
		return mannequin;
	}

	public static Mannequin Deserialize(byte[] buffer)
	{
		Mannequin mannequin = Pool.Get<Mannequin>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, mannequin, isDelta: false);
		return mannequin;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Mannequin previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Mannequin Deserialize(BufferStream stream, Mannequin instance, bool isDelta)
	{
		if (!isDelta && instance.clothingItems == null)
		{
			instance.clothingItems = Pool.Get<List<ClothingItem>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.clothingItems.Add(ClothingItem.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Mannequin DeserializeLengthDelimited(BufferStream stream, Mannequin instance, bool isDelta)
	{
		if (!isDelta && instance.clothingItems == null)
		{
			instance.clothingItems = Pool.Get<List<ClothingItem>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.clothingItems.Add(ClothingItem.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Mannequin DeserializeLength(BufferStream stream, int length, Mannequin instance, bool isDelta)
	{
		if (!isDelta && instance.clothingItems == null)
		{
			instance.clothingItems = Pool.Get<List<ClothingItem>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.clothingItems.Add(ClothingItem.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Mannequin instance, Mannequin previous)
	{
		if (instance.clothingItems == null)
		{
			return;
		}
		for (int i = 0; i < instance.clothingItems.Count; i++)
		{
			ClothingItem clothingItem = instance.clothingItems[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ClothingItem.SerializeDelta(stream, clothingItem, clothingItem);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field clothingItems (ProtoBuf.Mannequin.ClothingItem)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, Mannequin instance)
	{
		if (instance.clothingItems == null)
		{
			return;
		}
		for (int i = 0; i < instance.clothingItems.Count; i++)
		{
			ClothingItem instance2 = instance.clothingItems[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ClothingItem.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field clothingItems (ProtoBuf.Mannequin.ClothingItem)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (clothingItems != null)
		{
			for (int i = 0; i < clothingItems.Count; i++)
			{
				clothingItems[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MapData : IDisposable, IPooled, IProto<MapData>, IProto
{
	[NonSerialized]
	public string name;

	[NonSerialized]
	public byte[] data;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MapData instance)
	{
		if (instance.ShouldPool)
		{
			instance.name = string.Empty;
			instance.data = null;
			Pool.Free<MapData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MapData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MapData instance)
	{
		instance.name = name;
		if (data == null)
		{
			instance.data = null;
			return;
		}
		instance.data = new byte[data.Length];
		Array.Copy(data, instance.data, instance.data.Length);
	}

	public MapData Copy()
	{
		MapData mapData = Pool.Get<MapData>();
		CopyTo(mapData);
		return mapData;
	}

	public static MapData Deserialize(BufferStream stream)
	{
		MapData mapData = Pool.Get<MapData>();
		Deserialize(stream, mapData, isDelta: false);
		return mapData;
	}

	public static MapData DeserializeLengthDelimited(BufferStream stream)
	{
		MapData mapData = Pool.Get<MapData>();
		DeserializeLengthDelimited(stream, mapData, isDelta: false);
		return mapData;
	}

	public static MapData DeserializeLength(BufferStream stream, int length)
	{
		MapData mapData = Pool.Get<MapData>();
		DeserializeLength(stream, length, mapData, isDelta: false);
		return mapData;
	}

	public static MapData Deserialize(byte[] buffer)
	{
		MapData mapData = Pool.Get<MapData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, mapData, isDelta: false);
		return mapData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MapData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MapData Deserialize(BufferStream stream, MapData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MapData DeserializeLengthDelimited(BufferStream stream, MapData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MapData DeserializeLength(BufferStream stream, int length, MapData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MapData instance, MapData previous)
	{
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.data == null)
		{
			throw new ArgumentNullException("data", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteBytes(stream, instance.data);
	}

	public static void Serialize(BufferStream stream, MapData instance)
	{
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.data == null)
		{
			throw new ArgumentNullException("data", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteBytes(stream, instance.data);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MapEntity : IDisposable, IPooled, IProto<MapEntity>, IProto
{
	[NonSerialized]
	public List<uint> fogImages;

	[NonSerialized]
	public List<uint> paintImages;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MapEntity instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.fogImages != null)
			{
				List<uint> list = instance.fogImages;
				Pool.FreeUnmanaged<uint>(ref list);
				instance.fogImages = list;
			}
			if (instance.paintImages != null)
			{
				List<uint> list2 = instance.paintImages;
				Pool.FreeUnmanaged<uint>(ref list2);
				instance.paintImages = list2;
			}
			Pool.Free<MapEntity>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MapEntity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MapEntity instance)
	{
		if (fogImages != null)
		{
			instance.fogImages = Pool.Get<List<uint>>();
			for (int i = 0; i < fogImages.Count; i++)
			{
				uint item = fogImages[i];
				instance.fogImages.Add(item);
			}
		}
		else
		{
			instance.fogImages = null;
		}
		if (paintImages != null)
		{
			instance.paintImages = Pool.Get<List<uint>>();
			for (int j = 0; j < paintImages.Count; j++)
			{
				uint item2 = paintImages[j];
				instance.paintImages.Add(item2);
			}
		}
		else
		{
			instance.paintImages = null;
		}
	}

	public MapEntity Copy()
	{
		MapEntity mapEntity = Pool.Get<MapEntity>();
		CopyTo(mapEntity);
		return mapEntity;
	}

	public static MapEntity Deserialize(BufferStream stream)
	{
		MapEntity mapEntity = Pool.Get<MapEntity>();
		Deserialize(stream, mapEntity, isDelta: false);
		return mapEntity;
	}

	public static MapEntity DeserializeLengthDelimited(BufferStream stream)
	{
		MapEntity mapEntity = Pool.Get<MapEntity>();
		DeserializeLengthDelimited(stream, mapEntity, isDelta: false);
		return mapEntity;
	}

	public static MapEntity DeserializeLength(BufferStream stream, int length)
	{
		MapEntity mapEntity = Pool.Get<MapEntity>();
		DeserializeLength(stream, length, mapEntity, isDelta: false);
		return mapEntity;
	}

	public static MapEntity Deserialize(byte[] buffer)
	{
		MapEntity mapEntity = Pool.Get<MapEntity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, mapEntity, isDelta: false);
		return mapEntity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MapEntity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MapEntity Deserialize(BufferStream stream, MapEntity instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.fogImages == null)
			{
				instance.fogImages = Pool.Get<List<uint>>();
			}
			if (instance.paintImages == null)
			{
				instance.paintImages = Pool.Get<List<uint>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.fogImages.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 16:
				instance.paintImages.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MapEntity DeserializeLengthDelimited(BufferStream stream, MapEntity instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.fogImages == null)
			{
				instance.fogImages = Pool.Get<List<uint>>();
			}
			if (instance.paintImages == null)
			{
				instance.paintImages = Pool.Get<List<uint>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.fogImages.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 16:
				instance.paintImages.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MapEntity DeserializeLength(BufferStream stream, int length, MapEntity instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.fogImages == null)
			{
				instance.fogImages = Pool.Get<List<uint>>();
			}
			if (instance.paintImages == null)
			{
				instance.paintImages = Pool.Get<List<uint>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.fogImages.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 16:
				instance.paintImages.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MapEntity instance, MapEntity previous)
	{
		if (instance.fogImages != null)
		{
			for (int i = 0; i < instance.fogImages.Count; i++)
			{
				uint val = instance.fogImages[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt32(stream, val);
			}
		}
		if (instance.paintImages != null)
		{
			for (int j = 0; j < instance.paintImages.Count; j++)
			{
				uint val2 = instance.paintImages[j];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt32(stream, val2);
			}
		}
	}

	public static void Serialize(BufferStream stream, MapEntity instance)
	{
		if (instance.fogImages != null)
		{
			for (int i = 0; i < instance.fogImages.Count; i++)
			{
				uint val = instance.fogImages[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt32(stream, val);
			}
		}
		if (instance.paintImages != null)
		{
			for (int j = 0; j < instance.paintImages.Count; j++)
			{
				uint val2 = instance.paintImages[j];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt32(stream, val2);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class MapNote : IDisposable, IPooled, IProto<MapNote>, IProto
{
	[NonSerialized]
	public int noteType;

	[NonSerialized]
	public Vector3 worldPosition;

	[NonSerialized]
	public int icon;

	[NonSerialized]
	public int colourIndex;

	[NonSerialized]
	public string label;

	[NonSerialized]
	public bool isPing;

	[NonSerialized]
	public float timeRemaining;

	[NonSerialized]
	public float totalDuration;

	[NonSerialized]
	public NetworkableId associatedId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MapNote instance)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.noteType = 0;
			instance.worldPosition = default(Vector3);
			instance.icon = 0;
			instance.colourIndex = 0;
			instance.label = string.Empty;
			instance.isPing = false;
			instance.timeRemaining = 0f;
			instance.totalDuration = 0f;
			instance.associatedId = default(NetworkableId);
			Pool.Free<MapNote>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MapNote with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MapNote instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.noteType = noteType;
		instance.worldPosition = worldPosition;
		instance.icon = icon;
		instance.colourIndex = colourIndex;
		instance.label = label;
		instance.isPing = isPing;
		instance.timeRemaining = timeRemaining;
		instance.totalDuration = totalDuration;
		instance.associatedId = associatedId;
	}

	public MapNote Copy()
	{
		MapNote mapNote = Pool.Get<MapNote>();
		CopyTo(mapNote);
		return mapNote;
	}

	public static MapNote Deserialize(BufferStream stream)
	{
		MapNote mapNote = Pool.Get<MapNote>();
		Deserialize(stream, mapNote, isDelta: false);
		return mapNote;
	}

	public static MapNote DeserializeLengthDelimited(BufferStream stream)
	{
		MapNote mapNote = Pool.Get<MapNote>();
		DeserializeLengthDelimited(stream, mapNote, isDelta: false);
		return mapNote;
	}

	public static MapNote DeserializeLength(BufferStream stream, int length)
	{
		MapNote mapNote = Pool.Get<MapNote>();
		DeserializeLength(stream, length, mapNote, isDelta: false);
		return mapNote;
	}

	public static MapNote Deserialize(byte[] buffer)
	{
		MapNote mapNote = Pool.Get<MapNote>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, mapNote, isDelta: false);
		return mapNote;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MapNote previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MapNote Deserialize(BufferStream stream, MapNote instance, bool isDelta)
	{
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.noteType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
				continue;
			case 24:
				instance.icon = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.isPing = ProtocolParser.ReadBool(stream);
				continue;
			case 61:
				instance.timeRemaining = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.totalDuration = ProtocolParser.ReadSingle(stream);
				continue;
			case 72:
				instance.associatedId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MapNote DeserializeLengthDelimited(BufferStream stream, MapNote instance, bool isDelta)
	{
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.noteType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
				continue;
			case 24:
				instance.icon = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.isPing = ProtocolParser.ReadBool(stream);
				continue;
			case 61:
				instance.timeRemaining = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.totalDuration = ProtocolParser.ReadSingle(stream);
				continue;
			case 72:
				instance.associatedId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MapNote DeserializeLength(BufferStream stream, int length, MapNote instance, bool isDelta)
	{
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.noteType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
				continue;
			case 24:
				instance.icon = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.isPing = ProtocolParser.ReadBool(stream);
				continue;
			case 61:
				instance.timeRemaining = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.totalDuration = ProtocolParser.ReadSingle(stream);
				continue;
			case 72:
				instance.associatedId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MapNote instance, MapNote previous)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (instance.noteType != previous.noteType)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.noteType);
		}
		if (instance.worldPosition != previous.worldPosition)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.worldPosition, previous.worldPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.icon != previous.icon)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.icon);
		}
		if (instance.colourIndex != previous.colourIndex)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colourIndex);
		}
		if (instance.label != null && instance.label != previous.label)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.label);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.isPing);
		if (instance.timeRemaining != previous.timeRemaining)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.timeRemaining);
		}
		if (instance.totalDuration != previous.totalDuration)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.totalDuration);
		}
		stream.WriteByte(72);
		ProtocolParser.WriteUInt64(stream, instance.associatedId.Value);
	}

	public static void Serialize(BufferStream stream, MapNote instance)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.noteType != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.noteType);
		}
		if (instance.worldPosition != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.worldPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.icon != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.icon);
		}
		if (instance.colourIndex != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colourIndex);
		}
		if (instance.label != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.label);
		}
		if (instance.isPing)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.isPing);
		}
		if (instance.timeRemaining != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.timeRemaining);
		}
		if (instance.totalDuration != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.totalDuration);
		}
		if (instance.associatedId != default(NetworkableId))
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, instance.associatedId.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref associatedId.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MapNoteList : IDisposable, IPooled, IProto<MapNoteList>, IProto
{
	[NonSerialized]
	public List<MapNote> notes;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MapNoteList instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.notes != null)
		{
			for (int i = 0; i < instance.notes.Count; i++)
			{
				if (instance.notes[i] != null)
				{
					instance.notes[i].ResetToPool();
					instance.notes[i] = null;
				}
			}
			List<MapNote> list = instance.notes;
			Pool.Free<MapNote>(ref list, false);
			instance.notes = list;
		}
		Pool.Free<MapNoteList>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MapNoteList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MapNoteList instance)
	{
		if (notes != null)
		{
			instance.notes = Pool.Get<List<MapNote>>();
			for (int i = 0; i < notes.Count; i++)
			{
				MapNote item = notes[i].Copy();
				instance.notes.Add(item);
			}
		}
		else
		{
			instance.notes = null;
		}
	}

	public MapNoteList Copy()
	{
		MapNoteList mapNoteList = Pool.Get<MapNoteList>();
		CopyTo(mapNoteList);
		return mapNoteList;
	}

	public static MapNoteList Deserialize(BufferStream stream)
	{
		MapNoteList mapNoteList = Pool.Get<MapNoteList>();
		Deserialize(stream, mapNoteList, isDelta: false);
		return mapNoteList;
	}

	public static MapNoteList DeserializeLengthDelimited(BufferStream stream)
	{
		MapNoteList mapNoteList = Pool.Get<MapNoteList>();
		DeserializeLengthDelimited(stream, mapNoteList, isDelta: false);
		return mapNoteList;
	}

	public static MapNoteList DeserializeLength(BufferStream stream, int length)
	{
		MapNoteList mapNoteList = Pool.Get<MapNoteList>();
		DeserializeLength(stream, length, mapNoteList, isDelta: false);
		return mapNoteList;
	}

	public static MapNoteList Deserialize(byte[] buffer)
	{
		MapNoteList mapNoteList = Pool.Get<MapNoteList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, mapNoteList, isDelta: false);
		return mapNoteList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MapNoteList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MapNoteList Deserialize(BufferStream stream, MapNoteList instance, bool isDelta)
	{
		if (!isDelta && instance.notes == null)
		{
			instance.notes = Pool.Get<List<MapNote>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.notes.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MapNoteList DeserializeLengthDelimited(BufferStream stream, MapNoteList instance, bool isDelta)
	{
		if (!isDelta && instance.notes == null)
		{
			instance.notes = Pool.Get<List<MapNote>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.notes.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MapNoteList DeserializeLength(BufferStream stream, int length, MapNoteList instance, bool isDelta)
	{
		if (!isDelta && instance.notes == null)
		{
			instance.notes = Pool.Get<List<MapNote>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.notes.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MapNoteList instance, MapNoteList previous)
	{
		if (instance.notes == null)
		{
			return;
		}
		for (int i = 0; i < instance.notes.Count; i++)
		{
			MapNote mapNote = instance.notes[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			MapNote.SerializeDelta(stream, mapNote, mapNote);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, MapNoteList instance)
	{
		if (instance.notes == null)
		{
			return;
		}
		for (int i = 0; i < instance.notes.Count; i++)
		{
			MapNote instance2 = instance.notes[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			MapNote.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (notes != null)
		{
			for (int i = 0; i < notes.Count; i++)
			{
				notes[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MarketTerminal : IDisposable, IPooled, IProto<MarketTerminal>, IProto
{
	public class PendingOrder : IDisposable, IPooled, IProto<PendingOrder>, IProto
	{
		[NonSerialized]
		public NetworkableId vendingMachineId;

		[NonSerialized]
		public NetworkableId droneId;

		[NonSerialized]
		public TimeUntil timeUntilExpiry;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(PendingOrder instance)
		{
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.vendingMachineId = default(NetworkableId);
				instance.droneId = default(NetworkableId);
				instance.timeUntilExpiry = TimeUntil.op_Implicit(0f);
				Pool.Free<PendingOrder>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose PendingOrder with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(PendingOrder instance)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			instance.vendingMachineId = vendingMachineId;
			instance.droneId = droneId;
			instance.timeUntilExpiry = timeUntilExpiry;
		}

		public PendingOrder Copy()
		{
			PendingOrder pendingOrder = Pool.Get<PendingOrder>();
			CopyTo(pendingOrder);
			return pendingOrder;
		}

		public static PendingOrder Deserialize(BufferStream stream)
		{
			PendingOrder pendingOrder = Pool.Get<PendingOrder>();
			Deserialize(stream, pendingOrder, isDelta: false);
			return pendingOrder;
		}

		public static PendingOrder DeserializeLengthDelimited(BufferStream stream)
		{
			PendingOrder pendingOrder = Pool.Get<PendingOrder>();
			DeserializeLengthDelimited(stream, pendingOrder, isDelta: false);
			return pendingOrder;
		}

		public static PendingOrder DeserializeLength(BufferStream stream, int length)
		{
			PendingOrder pendingOrder = Pool.Get<PendingOrder>();
			DeserializeLength(stream, length, pendingOrder, isDelta: false);
			return pendingOrder;
		}

		public static PendingOrder Deserialize(byte[] buffer)
		{
			PendingOrder pendingOrder = Pool.Get<PendingOrder>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, pendingOrder, isDelta: false);
			return pendingOrder;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, PendingOrder previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static PendingOrder Deserialize(BufferStream stream, PendingOrder instance, bool isDelta)
		{
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.vendingMachineId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 24:
					instance.droneId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 37:
					instance.timeUntilExpiry = TimeUntil.op_Implicit(ProtocolParser.ReadSingle(stream));
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static PendingOrder DeserializeLengthDelimited(BufferStream stream, PendingOrder instance, bool isDelta)
		{
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_0089: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.vendingMachineId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 24:
					instance.droneId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 37:
					instance.timeUntilExpiry = TimeUntil.op_Implicit(ProtocolParser.ReadSingle(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static PendingOrder DeserializeLength(BufferStream stream, int length, PendingOrder instance, bool isDelta)
		{
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0081: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.vendingMachineId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 24:
					instance.droneId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 37:
					instance.timeUntilExpiry = TimeUntil.op_Implicit(ProtocolParser.ReadSingle(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, PendingOrder instance, PendingOrder previous)
		{
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.vendingMachineId.Value);
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.droneId.Value);
			if (TimeUntil.op_Implicit(instance.timeUntilExpiry) != TimeUntil.op_Implicit(previous.timeUntilExpiry))
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, TimeUntil.op_Implicit(instance.timeUntilExpiry));
			}
		}

		public static void Serialize(BufferStream stream, PendingOrder instance)
		{
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0079: Unknown result type (might be due to invalid IL or missing references)
			if (instance.vendingMachineId != default(NetworkableId))
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.vendingMachineId.Value);
			}
			if (instance.droneId != default(NetworkableId))
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, instance.droneId.Value);
			}
			if (TimeUntil.op_Implicit(instance.timeUntilExpiry) != 0f)
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, TimeUntil.op_Implicit(instance.timeUntilExpiry));
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			action(UidType.NetworkableId, ref vendingMachineId.Value);
			action(UidType.NetworkableId, ref droneId.Value);
		}
	}

	[NonSerialized]
	public ulong customerSteamId;

	[NonSerialized]
	public NetworkableId marketplaceId;

	[NonSerialized]
	public List<PendingOrder> orders;

	[NonSerialized]
	public string customerName;

	[NonSerialized]
	public TimeUntil timeUntilExpiry;

	[NonSerialized]
	public int deliveryFeeCurrency;

	[NonSerialized]
	public int deliveryFeeAmount;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MarketTerminal instance)
	{
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.customerSteamId = 0uL;
		instance.marketplaceId = default(NetworkableId);
		if (instance.orders != null)
		{
			for (int i = 0; i < instance.orders.Count; i++)
			{
				if (instance.orders[i] != null)
				{
					instance.orders[i].ResetToPool();
					instance.orders[i] = null;
				}
			}
			List<PendingOrder> list = instance.orders;
			Pool.Free<PendingOrder>(ref list, false);
			instance.orders = list;
		}
		instance.customerName = string.Empty;
		instance.timeUntilExpiry = TimeUntil.op_Implicit(0f);
		instance.deliveryFeeCurrency = 0;
		instance.deliveryFeeAmount = 0;
		Pool.Free<MarketTerminal>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MarketTerminal with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MarketTerminal instance)
	{
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		instance.customerSteamId = customerSteamId;
		instance.marketplaceId = marketplaceId;
		if (orders != null)
		{
			instance.orders = Pool.Get<List<PendingOrder>>();
			for (int i = 0; i < orders.Count; i++)
			{
				PendingOrder item = orders[i].Copy();
				instance.orders.Add(item);
			}
		}
		else
		{
			instance.orders = null;
		}
		instance.customerName = customerName;
		instance.timeUntilExpiry = timeUntilExpiry;
		instance.deliveryFeeCurrency = deliveryFeeCurrency;
		instance.deliveryFeeAmount = deliveryFeeAmount;
	}

	public MarketTerminal Copy()
	{
		MarketTerminal marketTerminal = Pool.Get<MarketTerminal>();
		CopyTo(marketTerminal);
		return marketTerminal;
	}

	public static MarketTerminal Deserialize(BufferStream stream)
	{
		MarketTerminal marketTerminal = Pool.Get<MarketTerminal>();
		Deserialize(stream, marketTerminal, isDelta: false);
		return marketTerminal;
	}

	public static MarketTerminal DeserializeLengthDelimited(BufferStream stream)
	{
		MarketTerminal marketTerminal = Pool.Get<MarketTerminal>();
		DeserializeLengthDelimited(stream, marketTerminal, isDelta: false);
		return marketTerminal;
	}

	public static MarketTerminal DeserializeLength(BufferStream stream, int length)
	{
		MarketTerminal marketTerminal = Pool.Get<MarketTerminal>();
		DeserializeLength(stream, length, marketTerminal, isDelta: false);
		return marketTerminal;
	}

	public static MarketTerminal Deserialize(byte[] buffer)
	{
		MarketTerminal marketTerminal = Pool.Get<MarketTerminal>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, marketTerminal, isDelta: false);
		return marketTerminal;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MarketTerminal previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MarketTerminal Deserialize(BufferStream stream, MarketTerminal instance, bool isDelta)
	{
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.orders == null)
		{
			instance.orders = Pool.Get<List<PendingOrder>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.customerSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.marketplaceId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 34:
				instance.orders.Add(PendingOrder.DeserializeLengthDelimited(stream));
				continue;
			case 42:
				instance.customerName = ProtocolParser.ReadString(stream);
				continue;
			case 53:
				instance.timeUntilExpiry = TimeUntil.op_Implicit(ProtocolParser.ReadSingle(stream));
				continue;
			case 56:
				instance.deliveryFeeCurrency = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.deliveryFeeAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MarketTerminal DeserializeLengthDelimited(BufferStream stream, MarketTerminal instance, bool isDelta)
	{
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.orders == null)
		{
			instance.orders = Pool.Get<List<PendingOrder>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.customerSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.marketplaceId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 34:
				instance.orders.Add(PendingOrder.DeserializeLengthDelimited(stream));
				continue;
			case 42:
				instance.customerName = ProtocolParser.ReadString(stream);
				continue;
			case 53:
				instance.timeUntilExpiry = TimeUntil.op_Implicit(ProtocolParser.ReadSingle(stream));
				continue;
			case 56:
				instance.deliveryFeeCurrency = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.deliveryFeeAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MarketTerminal DeserializeLength(BufferStream stream, int length, MarketTerminal instance, bool isDelta)
	{
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.orders == null)
		{
			instance.orders = Pool.Get<List<PendingOrder>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.customerSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.marketplaceId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 34:
				instance.orders.Add(PendingOrder.DeserializeLengthDelimited(stream));
				continue;
			case 42:
				instance.customerName = ProtocolParser.ReadString(stream);
				continue;
			case 53:
				instance.timeUntilExpiry = TimeUntil.op_Implicit(ProtocolParser.ReadSingle(stream));
				continue;
			case 56:
				instance.deliveryFeeCurrency = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.deliveryFeeAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MarketTerminal instance, MarketTerminal previous)
	{
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		if (instance.customerSteamId != previous.customerSteamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.customerSteamId);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, instance.marketplaceId.Value);
		if (instance.orders != null)
		{
			for (int i = 0; i < instance.orders.Count; i++)
			{
				PendingOrder pendingOrder = instance.orders[i];
				stream.WriteByte(34);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				PendingOrder.SerializeDelta(stream, pendingOrder, pendingOrder);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field orders (ProtoBuf.MarketTerminal.PendingOrder)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.customerName != null && instance.customerName != previous.customerName)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.customerName);
		}
		if (TimeUntil.op_Implicit(instance.timeUntilExpiry) != TimeUntil.op_Implicit(previous.timeUntilExpiry))
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, TimeUntil.op_Implicit(instance.timeUntilExpiry));
		}
		if (instance.deliveryFeeCurrency != previous.deliveryFeeCurrency)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.deliveryFeeCurrency);
		}
		if (instance.deliveryFeeAmount != previous.deliveryFeeAmount)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.deliveryFeeAmount);
		}
	}

	public static void Serialize(BufferStream stream, MarketTerminal instance)
	{
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		if (instance.customerSteamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.customerSteamId);
		}
		if (instance.marketplaceId != default(NetworkableId))
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.marketplaceId.Value);
		}
		if (instance.orders != null)
		{
			for (int i = 0; i < instance.orders.Count; i++)
			{
				PendingOrder instance2 = instance.orders[i];
				stream.WriteByte(34);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				PendingOrder.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field orders (ProtoBuf.MarketTerminal.PendingOrder)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.customerName != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.customerName);
		}
		if (TimeUntil.op_Implicit(instance.timeUntilExpiry) != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, TimeUntil.op_Implicit(instance.timeUntilExpiry));
		}
		if (instance.deliveryFeeCurrency != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.deliveryFeeCurrency);
		}
		if (instance.deliveryFeeAmount != 0)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.deliveryFeeAmount);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref marketplaceId.Value);
		if (orders != null)
		{
			for (int i = 0; i < orders.Count; i++)
			{
				orders[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MemoryBank : IDisposable, IPooled, IProto<MemoryBank>, IProto
{
	[NonSerialized]
	public int type;

	[NonSerialized]
	public int slotCount;

	[NonSerialized]
	public List<int> slots;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MemoryBank instance)
	{
		if (instance.ShouldPool)
		{
			instance.type = 0;
			instance.slotCount = 0;
			if (instance.slots != null)
			{
				List<int> list = instance.slots;
				Pool.FreeUnmanaged<int>(ref list);
				instance.slots = list;
			}
			Pool.Free<MemoryBank>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MemoryBank with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MemoryBank instance)
	{
		instance.type = type;
		instance.slotCount = slotCount;
		if (slots != null)
		{
			instance.slots = Pool.Get<List<int>>();
			for (int i = 0; i < slots.Count; i++)
			{
				int item = slots[i];
				instance.slots.Add(item);
			}
		}
		else
		{
			instance.slots = null;
		}
	}

	public MemoryBank Copy()
	{
		MemoryBank memoryBank = Pool.Get<MemoryBank>();
		CopyTo(memoryBank);
		return memoryBank;
	}

	public static MemoryBank Deserialize(BufferStream stream)
	{
		MemoryBank memoryBank = Pool.Get<MemoryBank>();
		Deserialize(stream, memoryBank, isDelta: false);
		return memoryBank;
	}

	public static MemoryBank DeserializeLengthDelimited(BufferStream stream)
	{
		MemoryBank memoryBank = Pool.Get<MemoryBank>();
		DeserializeLengthDelimited(stream, memoryBank, isDelta: false);
		return memoryBank;
	}

	public static MemoryBank DeserializeLength(BufferStream stream, int length)
	{
		MemoryBank memoryBank = Pool.Get<MemoryBank>();
		DeserializeLength(stream, length, memoryBank, isDelta: false);
		return memoryBank;
	}

	public static MemoryBank Deserialize(byte[] buffer)
	{
		MemoryBank memoryBank = Pool.Get<MemoryBank>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, memoryBank, isDelta: false);
		return memoryBank;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MemoryBank previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MemoryBank Deserialize(BufferStream stream, MemoryBank instance, bool isDelta)
	{
		if (!isDelta && instance.slots == null)
		{
			instance.slots = Pool.Get<List<int>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.slotCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.slots.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MemoryBank DeserializeLengthDelimited(BufferStream stream, MemoryBank instance, bool isDelta)
	{
		if (!isDelta && instance.slots == null)
		{
			instance.slots = Pool.Get<List<int>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.slotCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.slots.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MemoryBank DeserializeLength(BufferStream stream, int length, MemoryBank instance, bool isDelta)
	{
		if (!isDelta && instance.slots == null)
		{
			instance.slots = Pool.Get<List<int>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.slotCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.slots.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MemoryBank instance, MemoryBank previous)
	{
		if (instance.type != previous.type)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.slotCount != previous.slotCount)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slotCount);
		}
		if (instance.slots != null)
		{
			for (int i = 0; i < instance.slots.Count; i++)
			{
				int num = instance.slots[i];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
	}

	public static void Serialize(BufferStream stream, MemoryBank instance)
	{
		if (instance.type != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.slotCount != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slotCount);
		}
		if (instance.slots != null)
		{
			for (int i = 0; i < instance.slots.Count; i++)
			{
				int num = instance.slots[i];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class MetalDetectorSource : IDisposable, IPooled, IProto<MetalDetectorSource>, IProto
{
	[NonSerialized]
	public List<Vector3> spawnLocations;

	[NonSerialized]
	public float spawnRadius;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MetalDetectorSource instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.spawnLocations != null)
			{
				List<Vector3> list = instance.spawnLocations;
				Pool.FreeUnmanaged<Vector3>(ref list);
				instance.spawnLocations = list;
			}
			instance.spawnRadius = 0f;
			Pool.Free<MetalDetectorSource>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MetalDetectorSource with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MetalDetectorSource instance)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (spawnLocations != null)
		{
			instance.spawnLocations = Pool.Get<List<Vector3>>();
			for (int i = 0; i < spawnLocations.Count; i++)
			{
				Vector3 item = spawnLocations[i];
				instance.spawnLocations.Add(item);
			}
		}
		else
		{
			instance.spawnLocations = null;
		}
		instance.spawnRadius = spawnRadius;
	}

	public MetalDetectorSource Copy()
	{
		MetalDetectorSource metalDetectorSource = Pool.Get<MetalDetectorSource>();
		CopyTo(metalDetectorSource);
		return metalDetectorSource;
	}

	public static MetalDetectorSource Deserialize(BufferStream stream)
	{
		MetalDetectorSource metalDetectorSource = Pool.Get<MetalDetectorSource>();
		Deserialize(stream, metalDetectorSource, isDelta: false);
		return metalDetectorSource;
	}

	public static MetalDetectorSource DeserializeLengthDelimited(BufferStream stream)
	{
		MetalDetectorSource metalDetectorSource = Pool.Get<MetalDetectorSource>();
		DeserializeLengthDelimited(stream, metalDetectorSource, isDelta: false);
		return metalDetectorSource;
	}

	public static MetalDetectorSource DeserializeLength(BufferStream stream, int length)
	{
		MetalDetectorSource metalDetectorSource = Pool.Get<MetalDetectorSource>();
		DeserializeLength(stream, length, metalDetectorSource, isDelta: false);
		return metalDetectorSource;
	}

	public static MetalDetectorSource Deserialize(byte[] buffer)
	{
		MetalDetectorSource metalDetectorSource = Pool.Get<MetalDetectorSource>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, metalDetectorSource, isDelta: false);
		return metalDetectorSource;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MetalDetectorSource previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MetalDetectorSource Deserialize(BufferStream stream, MetalDetectorSource instance, bool isDelta)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.spawnLocations == null)
		{
			instance.spawnLocations = Pool.Get<List<Vector3>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.spawnLocations.Add(instance2);
				break;
			}
			case 21:
				instance.spawnRadius = ProtocolParser.ReadSingle(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static MetalDetectorSource DeserializeLengthDelimited(BufferStream stream, MetalDetectorSource instance, bool isDelta)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.spawnLocations == null)
		{
			instance.spawnLocations = Pool.Get<List<Vector3>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.spawnLocations.Add(instance2);
				break;
			}
			case 21:
				instance.spawnRadius = ProtocolParser.ReadSingle(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MetalDetectorSource DeserializeLength(BufferStream stream, int length, MetalDetectorSource instance, bool isDelta)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.spawnLocations == null)
		{
			instance.spawnLocations = Pool.Get<List<Vector3>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.spawnLocations.Add(instance2);
				break;
			}
			case 21:
				instance.spawnRadius = ProtocolParser.ReadSingle(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MetalDetectorSource instance, MetalDetectorSource previous)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.spawnLocations != null)
		{
			for (int i = 0; i < instance.spawnLocations.Count; i++)
			{
				Vector3 val = instance.spawnLocations[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.SerializeDelta(stream, val, val);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field spawnLocations (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.spawnRadius != previous.spawnRadius)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.spawnRadius);
		}
	}

	public static void Serialize(BufferStream stream, MetalDetectorSource instance)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if (instance.spawnLocations != null)
		{
			for (int i = 0; i < instance.spawnLocations.Count; i++)
			{
				Vector3 instance2 = instance.spawnLocations[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field spawnLocations (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.spawnRadius != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.spawnRadius);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MicrophoneStand : IDisposable, IPooled, IProto<MicrophoneStand>, IProto
{
	[NonSerialized]
	public int microphoneMode;

	[NonSerialized]
	public NetworkableId IORef;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MicrophoneStand instance)
	{
		if (instance.ShouldPool)
		{
			instance.microphoneMode = 0;
			instance.IORef = default(NetworkableId);
			Pool.Free<MicrophoneStand>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MicrophoneStand with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MicrophoneStand instance)
	{
		instance.microphoneMode = microphoneMode;
		instance.IORef = IORef;
	}

	public MicrophoneStand Copy()
	{
		MicrophoneStand microphoneStand = Pool.Get<MicrophoneStand>();
		CopyTo(microphoneStand);
		return microphoneStand;
	}

	public static MicrophoneStand Deserialize(BufferStream stream)
	{
		MicrophoneStand microphoneStand = Pool.Get<MicrophoneStand>();
		Deserialize(stream, microphoneStand, isDelta: false);
		return microphoneStand;
	}

	public static MicrophoneStand DeserializeLengthDelimited(BufferStream stream)
	{
		MicrophoneStand microphoneStand = Pool.Get<MicrophoneStand>();
		DeserializeLengthDelimited(stream, microphoneStand, isDelta: false);
		return microphoneStand;
	}

	public static MicrophoneStand DeserializeLength(BufferStream stream, int length)
	{
		MicrophoneStand microphoneStand = Pool.Get<MicrophoneStand>();
		DeserializeLength(stream, length, microphoneStand, isDelta: false);
		return microphoneStand;
	}

	public static MicrophoneStand Deserialize(byte[] buffer)
	{
		MicrophoneStand microphoneStand = Pool.Get<MicrophoneStand>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, microphoneStand, isDelta: false);
		return microphoneStand;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MicrophoneStand previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MicrophoneStand Deserialize(BufferStream stream, MicrophoneStand instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.microphoneMode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.IORef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MicrophoneStand DeserializeLengthDelimited(BufferStream stream, MicrophoneStand instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.microphoneMode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.IORef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MicrophoneStand DeserializeLength(BufferStream stream, int length, MicrophoneStand instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.microphoneMode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.IORef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MicrophoneStand instance, MicrophoneStand previous)
	{
		if (instance.microphoneMode != previous.microphoneMode)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.microphoneMode);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.IORef.Value);
	}

	public static void Serialize(BufferStream stream, MicrophoneStand instance)
	{
		if (instance.microphoneMode != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.microphoneMode);
		}
		if (instance.IORef != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.IORef.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref IORef.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Minicopter : IDisposable, IPooled, IProto<Minicopter>, IProto
{
	[NonSerialized]
	public NetworkableId fuelStorageID;

	[NonSerialized]
	public float fuelFraction;

	[NonSerialized]
	public float pitch;

	[NonSerialized]
	public float roll;

	[NonSerialized]
	public float yaw;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Minicopter instance)
	{
		if (instance.ShouldPool)
		{
			instance.fuelStorageID = default(NetworkableId);
			instance.fuelFraction = 0f;
			instance.pitch = 0f;
			instance.roll = 0f;
			instance.yaw = 0f;
			Pool.Free<Minicopter>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Minicopter with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Minicopter instance)
	{
		instance.fuelStorageID = fuelStorageID;
		instance.fuelFraction = fuelFraction;
		instance.pitch = pitch;
		instance.roll = roll;
		instance.yaw = yaw;
	}

	public Minicopter Copy()
	{
		Minicopter minicopter = Pool.Get<Minicopter>();
		CopyTo(minicopter);
		return minicopter;
	}

	public static Minicopter Deserialize(BufferStream stream)
	{
		Minicopter minicopter = Pool.Get<Minicopter>();
		Deserialize(stream, minicopter, isDelta: false);
		return minicopter;
	}

	public static Minicopter DeserializeLengthDelimited(BufferStream stream)
	{
		Minicopter minicopter = Pool.Get<Minicopter>();
		DeserializeLengthDelimited(stream, minicopter, isDelta: false);
		return minicopter;
	}

	public static Minicopter DeserializeLength(BufferStream stream, int length)
	{
		Minicopter minicopter = Pool.Get<Minicopter>();
		DeserializeLength(stream, length, minicopter, isDelta: false);
		return minicopter;
	}

	public static Minicopter Deserialize(byte[] buffer)
	{
		Minicopter minicopter = Pool.Get<Minicopter>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, minicopter, isDelta: false);
		return minicopter;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Minicopter previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Minicopter Deserialize(BufferStream stream, Minicopter instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.pitch = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.roll = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.yaw = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Minicopter DeserializeLengthDelimited(BufferStream stream, Minicopter instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.pitch = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.roll = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.yaw = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Minicopter DeserializeLength(BufferStream stream, int length, Minicopter instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.pitch = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.roll = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.yaw = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Minicopter instance, Minicopter previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		if (instance.fuelFraction != previous.fuelFraction)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
		if (instance.pitch != previous.pitch)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.pitch);
		}
		if (instance.roll != previous.roll)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.roll);
		}
		if (instance.yaw != previous.yaw)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.yaw);
		}
	}

	public static void Serialize(BufferStream stream, Minicopter instance)
	{
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
		if (instance.fuelFraction != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
		if (instance.pitch != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.pitch);
		}
		if (instance.roll != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.roll);
		}
		if (instance.yaw != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.yaw);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref fuelStorageID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MiningQuarry : IDisposable, IPooled, IProto<MiningQuarry>, IProto
{
	[NonSerialized]
	public ResourceExtractor extractor;

	[NonSerialized]
	public int staticType;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MiningQuarry instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.extractor != null)
			{
				instance.extractor.ResetToPool();
				instance.extractor = null;
			}
			instance.staticType = 0;
			Pool.Free<MiningQuarry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MiningQuarry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MiningQuarry instance)
	{
		if (extractor != null)
		{
			if (instance.extractor == null)
			{
				instance.extractor = extractor.Copy();
			}
			else
			{
				extractor.CopyTo(instance.extractor);
			}
		}
		else
		{
			instance.extractor = null;
		}
		instance.staticType = staticType;
	}

	public MiningQuarry Copy()
	{
		MiningQuarry miningQuarry = Pool.Get<MiningQuarry>();
		CopyTo(miningQuarry);
		return miningQuarry;
	}

	public static MiningQuarry Deserialize(BufferStream stream)
	{
		MiningQuarry miningQuarry = Pool.Get<MiningQuarry>();
		Deserialize(stream, miningQuarry, isDelta: false);
		return miningQuarry;
	}

	public static MiningQuarry DeserializeLengthDelimited(BufferStream stream)
	{
		MiningQuarry miningQuarry = Pool.Get<MiningQuarry>();
		DeserializeLengthDelimited(stream, miningQuarry, isDelta: false);
		return miningQuarry;
	}

	public static MiningQuarry DeserializeLength(BufferStream stream, int length)
	{
		MiningQuarry miningQuarry = Pool.Get<MiningQuarry>();
		DeserializeLength(stream, length, miningQuarry, isDelta: false);
		return miningQuarry;
	}

	public static MiningQuarry Deserialize(byte[] buffer)
	{
		MiningQuarry miningQuarry = Pool.Get<MiningQuarry>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, miningQuarry, isDelta: false);
		return miningQuarry;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MiningQuarry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MiningQuarry Deserialize(BufferStream stream, MiningQuarry instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.extractor == null)
				{
					instance.extractor = ResourceExtractor.DeserializeLengthDelimited(stream);
				}
				else
				{
					ResourceExtractor.DeserializeLengthDelimited(stream, instance.extractor, isDelta);
				}
				break;
			case 16:
				instance.staticType = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static MiningQuarry DeserializeLengthDelimited(BufferStream stream, MiningQuarry instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.extractor == null)
				{
					instance.extractor = ResourceExtractor.DeserializeLengthDelimited(stream);
				}
				else
				{
					ResourceExtractor.DeserializeLengthDelimited(stream, instance.extractor, isDelta);
				}
				break;
			case 16:
				instance.staticType = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MiningQuarry DeserializeLength(BufferStream stream, int length, MiningQuarry instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.extractor == null)
				{
					instance.extractor = ResourceExtractor.DeserializeLengthDelimited(stream);
				}
				else
				{
					ResourceExtractor.DeserializeLengthDelimited(stream, instance.extractor, isDelta);
				}
				break;
			case 16:
				instance.staticType = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MiningQuarry instance, MiningQuarry previous)
	{
		if (instance.extractor != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ResourceExtractor.SerializeDelta(stream, instance.extractor, previous.extractor);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.staticType != previous.staticType)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.staticType);
		}
	}

	public static void Serialize(BufferStream stream, MiningQuarry instance)
	{
		if (instance.extractor != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ResourceExtractor.Serialize(stream, instance.extractor);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.staticType != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.staticType);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		extractor?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MissionAcceptState : IDisposable, IPooled, IProto<MissionAcceptState>, IProto
{
	[NonSerialized]
	public NetworkableId providerNetId;

	[NonSerialized]
	public uint missionID;

	[NonSerialized]
	public bool canAccept;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MissionAcceptState instance)
	{
		if (instance.ShouldPool)
		{
			instance.providerNetId = default(NetworkableId);
			instance.missionID = 0u;
			instance.canAccept = false;
			Pool.Free<MissionAcceptState>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MissionAcceptState with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MissionAcceptState instance)
	{
		instance.providerNetId = providerNetId;
		instance.missionID = missionID;
		instance.canAccept = canAccept;
	}

	public MissionAcceptState Copy()
	{
		MissionAcceptState missionAcceptState = Pool.Get<MissionAcceptState>();
		CopyTo(missionAcceptState);
		return missionAcceptState;
	}

	public static MissionAcceptState Deserialize(BufferStream stream)
	{
		MissionAcceptState missionAcceptState = Pool.Get<MissionAcceptState>();
		Deserialize(stream, missionAcceptState, isDelta: false);
		return missionAcceptState;
	}

	public static MissionAcceptState DeserializeLengthDelimited(BufferStream stream)
	{
		MissionAcceptState missionAcceptState = Pool.Get<MissionAcceptState>();
		DeserializeLengthDelimited(stream, missionAcceptState, isDelta: false);
		return missionAcceptState;
	}

	public static MissionAcceptState DeserializeLength(BufferStream stream, int length)
	{
		MissionAcceptState missionAcceptState = Pool.Get<MissionAcceptState>();
		DeserializeLength(stream, length, missionAcceptState, isDelta: false);
		return missionAcceptState;
	}

	public static MissionAcceptState Deserialize(byte[] buffer)
	{
		MissionAcceptState missionAcceptState = Pool.Get<MissionAcceptState>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, missionAcceptState, isDelta: false);
		return missionAcceptState;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MissionAcceptState previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MissionAcceptState Deserialize(BufferStream stream, MissionAcceptState instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.providerNetId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.missionID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.canAccept = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MissionAcceptState DeserializeLengthDelimited(BufferStream stream, MissionAcceptState instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.providerNetId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.missionID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.canAccept = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MissionAcceptState DeserializeLength(BufferStream stream, int length, MissionAcceptState instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.providerNetId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.missionID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.canAccept = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MissionAcceptState instance, MissionAcceptState previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.providerNetId.Value);
		if (instance.missionID != previous.missionID)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.missionID);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.canAccept);
	}

	public static void Serialize(BufferStream stream, MissionAcceptState instance)
	{
		if (instance.providerNetId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.providerNetId.Value);
		}
		if (instance.missionID != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.missionID);
		}
		if (instance.canAccept)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.canAccept);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref providerNetId.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MissionAcceptStatesList : IDisposable, IPooled, IProto<MissionAcceptStatesList>, IProto
{
	[NonSerialized]
	public List<MissionAcceptState> missionAcceptStates;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MissionAcceptStatesList instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.missionAcceptStates != null)
		{
			for (int i = 0; i < instance.missionAcceptStates.Count; i++)
			{
				if (instance.missionAcceptStates[i] != null)
				{
					instance.missionAcceptStates[i].ResetToPool();
					instance.missionAcceptStates[i] = null;
				}
			}
			List<MissionAcceptState> list = instance.missionAcceptStates;
			Pool.Free<MissionAcceptState>(ref list, false);
			instance.missionAcceptStates = list;
		}
		Pool.Free<MissionAcceptStatesList>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MissionAcceptStatesList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MissionAcceptStatesList instance)
	{
		if (missionAcceptStates != null)
		{
			instance.missionAcceptStates = Pool.Get<List<MissionAcceptState>>();
			for (int i = 0; i < missionAcceptStates.Count; i++)
			{
				MissionAcceptState item = missionAcceptStates[i].Copy();
				instance.missionAcceptStates.Add(item);
			}
		}
		else
		{
			instance.missionAcceptStates = null;
		}
	}

	public MissionAcceptStatesList Copy()
	{
		MissionAcceptStatesList missionAcceptStatesList = Pool.Get<MissionAcceptStatesList>();
		CopyTo(missionAcceptStatesList);
		return missionAcceptStatesList;
	}

	public static MissionAcceptStatesList Deserialize(BufferStream stream)
	{
		MissionAcceptStatesList missionAcceptStatesList = Pool.Get<MissionAcceptStatesList>();
		Deserialize(stream, missionAcceptStatesList, isDelta: false);
		return missionAcceptStatesList;
	}

	public static MissionAcceptStatesList DeserializeLengthDelimited(BufferStream stream)
	{
		MissionAcceptStatesList missionAcceptStatesList = Pool.Get<MissionAcceptStatesList>();
		DeserializeLengthDelimited(stream, missionAcceptStatesList, isDelta: false);
		return missionAcceptStatesList;
	}

	public static MissionAcceptStatesList DeserializeLength(BufferStream stream, int length)
	{
		MissionAcceptStatesList missionAcceptStatesList = Pool.Get<MissionAcceptStatesList>();
		DeserializeLength(stream, length, missionAcceptStatesList, isDelta: false);
		return missionAcceptStatesList;
	}

	public static MissionAcceptStatesList Deserialize(byte[] buffer)
	{
		MissionAcceptStatesList missionAcceptStatesList = Pool.Get<MissionAcceptStatesList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, missionAcceptStatesList, isDelta: false);
		return missionAcceptStatesList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MissionAcceptStatesList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MissionAcceptStatesList Deserialize(BufferStream stream, MissionAcceptStatesList instance, bool isDelta)
	{
		if (!isDelta && instance.missionAcceptStates == null)
		{
			instance.missionAcceptStates = Pool.Get<List<MissionAcceptState>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.missionAcceptStates.Add(MissionAcceptState.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MissionAcceptStatesList DeserializeLengthDelimited(BufferStream stream, MissionAcceptStatesList instance, bool isDelta)
	{
		if (!isDelta && instance.missionAcceptStates == null)
		{
			instance.missionAcceptStates = Pool.Get<List<MissionAcceptState>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.missionAcceptStates.Add(MissionAcceptState.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MissionAcceptStatesList DeserializeLength(BufferStream stream, int length, MissionAcceptStatesList instance, bool isDelta)
	{
		if (!isDelta && instance.missionAcceptStates == null)
		{
			instance.missionAcceptStates = Pool.Get<List<MissionAcceptState>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.missionAcceptStates.Add(MissionAcceptState.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MissionAcceptStatesList instance, MissionAcceptStatesList previous)
	{
		if (instance.missionAcceptStates == null)
		{
			return;
		}
		for (int i = 0; i < instance.missionAcceptStates.Count; i++)
		{
			MissionAcceptState missionAcceptState = instance.missionAcceptStates[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			MissionAcceptState.SerializeDelta(stream, missionAcceptState, missionAcceptState);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field missionAcceptStates (ProtoBuf.MissionAcceptState)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, MissionAcceptStatesList instance)
	{
		if (instance.missionAcceptStates == null)
		{
			return;
		}
		for (int i = 0; i < instance.missionAcceptStates.Count; i++)
		{
			MissionAcceptState instance2 = instance.missionAcceptStates[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			MissionAcceptState.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field missionAcceptStates (ProtoBuf.MissionAcceptState)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (missionAcceptStates != null)
		{
			for (int i = 0; i < missionAcceptStates.Count; i++)
			{
				missionAcceptStates[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MissionEntity : IDisposable, IPooled, IProto<MissionEntity>, IProto
{
	[NonSerialized]
	public string identifier;

	[NonSerialized]
	public NetworkableId entityID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MissionEntity instance)
	{
		if (instance.ShouldPool)
		{
			instance.identifier = string.Empty;
			instance.entityID = default(NetworkableId);
			Pool.Free<MissionEntity>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MissionEntity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MissionEntity instance)
	{
		instance.identifier = identifier;
		instance.entityID = entityID;
	}

	public MissionEntity Copy()
	{
		MissionEntity missionEntity = Pool.Get<MissionEntity>();
		CopyTo(missionEntity);
		return missionEntity;
	}

	public static MissionEntity Deserialize(BufferStream stream)
	{
		MissionEntity missionEntity = Pool.Get<MissionEntity>();
		Deserialize(stream, missionEntity, isDelta: false);
		return missionEntity;
	}

	public static MissionEntity DeserializeLengthDelimited(BufferStream stream)
	{
		MissionEntity missionEntity = Pool.Get<MissionEntity>();
		DeserializeLengthDelimited(stream, missionEntity, isDelta: false);
		return missionEntity;
	}

	public static MissionEntity DeserializeLength(BufferStream stream, int length)
	{
		MissionEntity missionEntity = Pool.Get<MissionEntity>();
		DeserializeLength(stream, length, missionEntity, isDelta: false);
		return missionEntity;
	}

	public static MissionEntity Deserialize(byte[] buffer)
	{
		MissionEntity missionEntity = Pool.Get<MissionEntity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, missionEntity, isDelta: false);
		return missionEntity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MissionEntity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MissionEntity Deserialize(BufferStream stream, MissionEntity instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.identifier = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.entityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MissionEntity DeserializeLengthDelimited(BufferStream stream, MissionEntity instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.identifier = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.entityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MissionEntity DeserializeLength(BufferStream stream, int length, MissionEntity instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.identifier = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.entityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MissionEntity instance, MissionEntity previous)
	{
		if (instance.identifier != previous.identifier)
		{
			if (instance.identifier == null)
			{
				throw new ArgumentNullException("identifier", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.identifier);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.entityID.Value);
	}

	public static void Serialize(BufferStream stream, MissionEntity instance)
	{
		if (instance.identifier == null)
		{
			throw new ArgumentNullException("identifier", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.identifier);
		if (instance.entityID != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.entityID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entityID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MissionInstance : IDisposable, IPooled, IProto<MissionInstance>, IProto
{
	[NonSerialized]
	public uint missionID;

	[NonSerialized]
	public uint missionStatus;

	[NonSerialized]
	public MissionInstanceData instanceData;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MissionInstance instance)
	{
		if (instance.ShouldPool)
		{
			instance.missionID = 0u;
			instance.missionStatus = 0u;
			if (instance.instanceData != null)
			{
				instance.instanceData.ResetToPool();
				instance.instanceData = null;
			}
			Pool.Free<MissionInstance>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MissionInstance with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MissionInstance instance)
	{
		instance.missionID = missionID;
		instance.missionStatus = missionStatus;
		if (instanceData != null)
		{
			if (instance.instanceData == null)
			{
				instance.instanceData = instanceData.Copy();
			}
			else
			{
				instanceData.CopyTo(instance.instanceData);
			}
		}
		else
		{
			instance.instanceData = null;
		}
	}

	public MissionInstance Copy()
	{
		MissionInstance missionInstance = Pool.Get<MissionInstance>();
		CopyTo(missionInstance);
		return missionInstance;
	}

	public static MissionInstance Deserialize(BufferStream stream)
	{
		MissionInstance missionInstance = Pool.Get<MissionInstance>();
		Deserialize(stream, missionInstance, isDelta: false);
		return missionInstance;
	}

	public static MissionInstance DeserializeLengthDelimited(BufferStream stream)
	{
		MissionInstance missionInstance = Pool.Get<MissionInstance>();
		DeserializeLengthDelimited(stream, missionInstance, isDelta: false);
		return missionInstance;
	}

	public static MissionInstance DeserializeLength(BufferStream stream, int length)
	{
		MissionInstance missionInstance = Pool.Get<MissionInstance>();
		DeserializeLength(stream, length, missionInstance, isDelta: false);
		return missionInstance;
	}

	public static MissionInstance Deserialize(byte[] buffer)
	{
		MissionInstance missionInstance = Pool.Get<MissionInstance>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, missionInstance, isDelta: false);
		return missionInstance;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MissionInstance previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MissionInstance Deserialize(BufferStream stream, MissionInstance instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 16:
				instance.missionID = ProtocolParser.ReadUInt32(stream);
				break;
			case 24:
				instance.missionStatus = ProtocolParser.ReadUInt32(stream);
				break;
			case 98:
				if (instance.instanceData == null)
				{
					instance.instanceData = MissionInstanceData.DeserializeLengthDelimited(stream);
				}
				else
				{
					MissionInstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static MissionInstance DeserializeLengthDelimited(BufferStream stream, MissionInstance instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 16:
				instance.missionID = ProtocolParser.ReadUInt32(stream);
				break;
			case 24:
				instance.missionStatus = ProtocolParser.ReadUInt32(stream);
				break;
			case 98:
				if (instance.instanceData == null)
				{
					instance.instanceData = MissionInstanceData.DeserializeLengthDelimited(stream);
				}
				else
				{
					MissionInstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MissionInstance DeserializeLength(BufferStream stream, int length, MissionInstance instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 16:
				instance.missionID = ProtocolParser.ReadUInt32(stream);
				break;
			case 24:
				instance.missionStatus = ProtocolParser.ReadUInt32(stream);
				break;
			case 98:
				if (instance.instanceData == null)
				{
					instance.instanceData = MissionInstanceData.DeserializeLengthDelimited(stream);
				}
				else
				{
					MissionInstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MissionInstance instance, MissionInstance previous)
	{
		if (instance.missionID != previous.missionID)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.missionID);
		}
		if (instance.missionStatus != previous.missionStatus)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.missionStatus);
		}
		if (instance.instanceData == null)
		{
			return;
		}
		stream.WriteByte(98);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		MissionInstanceData.SerializeDelta(stream, instance.instanceData, previous.instanceData);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, MissionInstance instance)
	{
		if (instance.missionID != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.missionID);
		}
		if (instance.missionStatus != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.missionStatus);
		}
		if (instance.instanceData == null)
		{
			return;
		}
		stream.WriteByte(98);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		MissionInstanceData.Serialize(stream, instance.instanceData);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		instanceData?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MissionInstanceData : IDisposable, IPooled, IProto<MissionInstanceData>, IProto
{
	[NonSerialized]
	public NetworkableId providerID;

	[NonSerialized]
	public List<ObjectiveStatus> objectiveStatuses;

	[NonSerialized]
	public List<MissionPoint> missionPoints;

	[NonSerialized]
	public List<MissionEntity> missionEntities;

	[NonSerialized]
	public List<PersistentMissionEntityData> persistentMissionEntities;

	[NonSerialized]
	public int playerInputRequired;

	[NonSerialized]
	public long startTimeUtcSeconds;

	[NonSerialized]
	public long endTimeUtcSeconds;

	[NonSerialized]
	public bool hasDispensedRewards;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MissionInstanceData instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.providerID = default(NetworkableId);
		if (instance.objectiveStatuses != null)
		{
			for (int i = 0; i < instance.objectiveStatuses.Count; i++)
			{
				if (instance.objectiveStatuses[i] != null)
				{
					instance.objectiveStatuses[i].ResetToPool();
					instance.objectiveStatuses[i] = null;
				}
			}
			List<ObjectiveStatus> list = instance.objectiveStatuses;
			Pool.Free<ObjectiveStatus>(ref list, false);
			instance.objectiveStatuses = list;
		}
		if (instance.missionPoints != null)
		{
			for (int j = 0; j < instance.missionPoints.Count; j++)
			{
				if (instance.missionPoints[j] != null)
				{
					instance.missionPoints[j].ResetToPool();
					instance.missionPoints[j] = null;
				}
			}
			List<MissionPoint> list2 = instance.missionPoints;
			Pool.Free<MissionPoint>(ref list2, false);
			instance.missionPoints = list2;
		}
		if (instance.missionEntities != null)
		{
			for (int k = 0; k < instance.missionEntities.Count; k++)
			{
				if (instance.missionEntities[k] != null)
				{
					instance.missionEntities[k].ResetToPool();
					instance.missionEntities[k] = null;
				}
			}
			List<MissionEntity> list3 = instance.missionEntities;
			Pool.Free<MissionEntity>(ref list3, false);
			instance.missionEntities = list3;
		}
		if (instance.persistentMissionEntities != null)
		{
			for (int l = 0; l < instance.persistentMissionEntities.Count; l++)
			{
				if (instance.persistentMissionEntities[l] != null)
				{
					instance.persistentMissionEntities[l].ResetToPool();
					instance.persistentMissionEntities[l] = null;
				}
			}
			List<PersistentMissionEntityData> list4 = instance.persistentMissionEntities;
			Pool.Free<PersistentMissionEntityData>(ref list4, false);
			instance.persistentMissionEntities = list4;
		}
		instance.playerInputRequired = 0;
		instance.startTimeUtcSeconds = 0L;
		instance.endTimeUtcSeconds = 0L;
		instance.hasDispensedRewards = false;
		Pool.Free<MissionInstanceData>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MissionInstanceData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MissionInstanceData instance)
	{
		instance.providerID = providerID;
		if (objectiveStatuses != null)
		{
			instance.objectiveStatuses = Pool.Get<List<ObjectiveStatus>>();
			for (int i = 0; i < objectiveStatuses.Count; i++)
			{
				ObjectiveStatus item = objectiveStatuses[i].Copy();
				instance.objectiveStatuses.Add(item);
			}
		}
		else
		{
			instance.objectiveStatuses = null;
		}
		if (missionPoints != null)
		{
			instance.missionPoints = Pool.Get<List<MissionPoint>>();
			for (int j = 0; j < missionPoints.Count; j++)
			{
				MissionPoint item2 = missionPoints[j].Copy();
				instance.missionPoints.Add(item2);
			}
		}
		else
		{
			instance.missionPoints = null;
		}
		if (missionEntities != null)
		{
			instance.missionEntities = Pool.Get<List<MissionEntity>>();
			for (int k = 0; k < missionEntities.Count; k++)
			{
				MissionEntity item3 = missionEntities[k].Copy();
				instance.missionEntities.Add(item3);
			}
		}
		else
		{
			instance.missionEntities = null;
		}
		if (persistentMissionEntities != null)
		{
			instance.persistentMissionEntities = Pool.Get<List<PersistentMissionEntityData>>();
			for (int l = 0; l < persistentMissionEntities.Count; l++)
			{
				PersistentMissionEntityData item4 = persistentMissionEntities[l].Copy();
				instance.persistentMissionEntities.Add(item4);
			}
		}
		else
		{
			instance.persistentMissionEntities = null;
		}
		instance.playerInputRequired = playerInputRequired;
		instance.startTimeUtcSeconds = startTimeUtcSeconds;
		instance.endTimeUtcSeconds = endTimeUtcSeconds;
		instance.hasDispensedRewards = hasDispensedRewards;
	}

	public MissionInstanceData Copy()
	{
		MissionInstanceData missionInstanceData = Pool.Get<MissionInstanceData>();
		CopyTo(missionInstanceData);
		return missionInstanceData;
	}

	public static MissionInstanceData Deserialize(BufferStream stream)
	{
		MissionInstanceData missionInstanceData = Pool.Get<MissionInstanceData>();
		Deserialize(stream, missionInstanceData, isDelta: false);
		return missionInstanceData;
	}

	public static MissionInstanceData DeserializeLengthDelimited(BufferStream stream)
	{
		MissionInstanceData missionInstanceData = Pool.Get<MissionInstanceData>();
		DeserializeLengthDelimited(stream, missionInstanceData, isDelta: false);
		return missionInstanceData;
	}

	public static MissionInstanceData DeserializeLength(BufferStream stream, int length)
	{
		MissionInstanceData missionInstanceData = Pool.Get<MissionInstanceData>();
		DeserializeLength(stream, length, missionInstanceData, isDelta: false);
		return missionInstanceData;
	}

	public static MissionInstanceData Deserialize(byte[] buffer)
	{
		MissionInstanceData missionInstanceData = Pool.Get<MissionInstanceData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, missionInstanceData, isDelta: false);
		return missionInstanceData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MissionInstanceData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MissionInstanceData Deserialize(BufferStream stream, MissionInstanceData instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.objectiveStatuses == null)
			{
				instance.objectiveStatuses = Pool.Get<List<ObjectiveStatus>>();
			}
			if (instance.missionPoints == null)
			{
				instance.missionPoints = Pool.Get<List<MissionPoint>>();
			}
			if (instance.missionEntities == null)
			{
				instance.missionEntities = Pool.Get<List<MissionEntity>>();
			}
			if (instance.persistentMissionEntities == null)
			{
				instance.persistentMissionEntities = Pool.Get<List<PersistentMissionEntityData>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.providerID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 42:
				instance.objectiveStatuses.Add(ObjectiveStatus.DeserializeLengthDelimited(stream));
				continue;
			case 50:
				instance.missionPoints.Add(MissionPoint.DeserializeLengthDelimited(stream));
				continue;
			case 58:
				instance.missionEntities.Add(MissionEntity.DeserializeLengthDelimited(stream));
				continue;
			case 66:
				instance.persistentMissionEntities.Add(PersistentMissionEntityData.DeserializeLengthDelimited(stream));
				continue;
			case 72:
				instance.playerInputRequired = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 80:
				instance.startTimeUtcSeconds = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 88:
				instance.endTimeUtcSeconds = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 96:
				instance.hasDispensedRewards = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MissionInstanceData DeserializeLengthDelimited(BufferStream stream, MissionInstanceData instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.objectiveStatuses == null)
			{
				instance.objectiveStatuses = Pool.Get<List<ObjectiveStatus>>();
			}
			if (instance.missionPoints == null)
			{
				instance.missionPoints = Pool.Get<List<MissionPoint>>();
			}
			if (instance.missionEntities == null)
			{
				instance.missionEntities = Pool.Get<List<MissionEntity>>();
			}
			if (instance.persistentMissionEntities == null)
			{
				instance.persistentMissionEntities = Pool.Get<List<PersistentMissionEntityData>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.providerID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 42:
				instance.objectiveStatuses.Add(ObjectiveStatus.DeserializeLengthDelimited(stream));
				continue;
			case 50:
				instance.missionPoints.Add(MissionPoint.DeserializeLengthDelimited(stream));
				continue;
			case 58:
				instance.missionEntities.Add(MissionEntity.DeserializeLengthDelimited(stream));
				continue;
			case 66:
				instance.persistentMissionEntities.Add(PersistentMissionEntityData.DeserializeLengthDelimited(stream));
				continue;
			case 72:
				instance.playerInputRequired = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 80:
				instance.startTimeUtcSeconds = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 88:
				instance.endTimeUtcSeconds = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 96:
				instance.hasDispensedRewards = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MissionInstanceData DeserializeLength(BufferStream stream, int length, MissionInstanceData instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.objectiveStatuses == null)
			{
				instance.objectiveStatuses = Pool.Get<List<ObjectiveStatus>>();
			}
			if (instance.missionPoints == null)
			{
				instance.missionPoints = Pool.Get<List<MissionPoint>>();
			}
			if (instance.missionEntities == null)
			{
				instance.missionEntities = Pool.Get<List<MissionEntity>>();
			}
			if (instance.persistentMissionEntities == null)
			{
				instance.persistentMissionEntities = Pool.Get<List<PersistentMissionEntityData>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.providerID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 42:
				instance.objectiveStatuses.Add(ObjectiveStatus.DeserializeLengthDelimited(stream));
				continue;
			case 50:
				instance.missionPoints.Add(MissionPoint.DeserializeLengthDelimited(stream));
				continue;
			case 58:
				instance.missionEntities.Add(MissionEntity.DeserializeLengthDelimited(stream));
				continue;
			case 66:
				instance.persistentMissionEntities.Add(PersistentMissionEntityData.DeserializeLengthDelimited(stream));
				continue;
			case 72:
				instance.playerInputRequired = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 80:
				instance.startTimeUtcSeconds = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 88:
				instance.endTimeUtcSeconds = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 96:
				instance.hasDispensedRewards = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MissionInstanceData instance, MissionInstanceData previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.providerID.Value);
		if (instance.objectiveStatuses != null)
		{
			for (int i = 0; i < instance.objectiveStatuses.Count; i++)
			{
				ObjectiveStatus objectiveStatus = instance.objectiveStatuses[i];
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				ObjectiveStatus.SerializeDelta(stream, objectiveStatus, objectiveStatus);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field objectiveStatuses (ProtoBuf.ObjectiveStatus)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.missionPoints != null)
		{
			for (int j = 0; j < instance.missionPoints.Count; j++)
			{
				MissionPoint missionPoint = instance.missionPoints[j];
				stream.WriteByte(50);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				MissionPoint.SerializeDelta(stream, missionPoint, missionPoint);
				int val = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.missionEntities != null)
		{
			for (int k = 0; k < instance.missionEntities.Count; k++)
			{
				MissionEntity missionEntity = instance.missionEntities[k];
				stream.WriteByte(58);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int position3 = stream.Position;
				MissionEntity.SerializeDelta(stream, missionEntity, missionEntity);
				int val2 = stream.Position - position3;
				Span<byte> span3 = range3.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)val2, span3, 0);
				if (num3 < 5)
				{
					span3[num3 - 1] |= 128;
					while (num3 < 4)
					{
						span3[num3++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		if (instance.persistentMissionEntities != null)
		{
			for (int l = 0; l < instance.persistentMissionEntities.Count; l++)
			{
				PersistentMissionEntityData persistentMissionEntityData = instance.persistentMissionEntities[l];
				stream.WriteByte(66);
				BufferStream.RangeHandle range4 = stream.GetRange(1);
				int position4 = stream.Position;
				PersistentMissionEntityData.SerializeDelta(stream, persistentMissionEntityData, persistentMissionEntityData);
				int num4 = stream.Position - position4;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field persistentMissionEntities (ProtoBuf.PersistentMissionEntityData)");
				}
				Span<byte> span4 = range4.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span4, 0);
			}
		}
		if (instance.playerInputRequired != previous.playerInputRequired)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.playerInputRequired);
		}
		stream.WriteByte(80);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.startTimeUtcSeconds);
		stream.WriteByte(88);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.endTimeUtcSeconds);
		stream.WriteByte(96);
		ProtocolParser.WriteBool(stream, instance.hasDispensedRewards);
	}

	public static void Serialize(BufferStream stream, MissionInstanceData instance)
	{
		if (instance.providerID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.providerID.Value);
		}
		if (instance.objectiveStatuses != null)
		{
			for (int i = 0; i < instance.objectiveStatuses.Count; i++)
			{
				ObjectiveStatus instance2 = instance.objectiveStatuses[i];
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				ObjectiveStatus.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field objectiveStatuses (ProtoBuf.ObjectiveStatus)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.missionPoints != null)
		{
			for (int j = 0; j < instance.missionPoints.Count; j++)
			{
				MissionPoint instance3 = instance.missionPoints[j];
				stream.WriteByte(50);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				MissionPoint.Serialize(stream, instance3);
				int val = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.missionEntities != null)
		{
			for (int k = 0; k < instance.missionEntities.Count; k++)
			{
				MissionEntity instance4 = instance.missionEntities[k];
				stream.WriteByte(58);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int position3 = stream.Position;
				MissionEntity.Serialize(stream, instance4);
				int val2 = stream.Position - position3;
				Span<byte> span3 = range3.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)val2, span3, 0);
				if (num3 < 5)
				{
					span3[num3 - 1] |= 128;
					while (num3 < 4)
					{
						span3[num3++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		if (instance.persistentMissionEntities != null)
		{
			for (int l = 0; l < instance.persistentMissionEntities.Count; l++)
			{
				PersistentMissionEntityData instance5 = instance.persistentMissionEntities[l];
				stream.WriteByte(66);
				BufferStream.RangeHandle range4 = stream.GetRange(1);
				int position4 = stream.Position;
				PersistentMissionEntityData.Serialize(stream, instance5);
				int num4 = stream.Position - position4;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field persistentMissionEntities (ProtoBuf.PersistentMissionEntityData)");
				}
				Span<byte> span4 = range4.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span4, 0);
			}
		}
		if (instance.playerInputRequired != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.playerInputRequired);
		}
		if (instance.startTimeUtcSeconds != 0L)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.startTimeUtcSeconds);
		}
		if (instance.endTimeUtcSeconds != 0L)
		{
			stream.WriteByte(88);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.endTimeUtcSeconds);
		}
		if (instance.hasDispensedRewards)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteBool(stream, instance.hasDispensedRewards);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref providerID.Value);
		if (objectiveStatuses != null)
		{
			for (int i = 0; i < objectiveStatuses.Count; i++)
			{
				objectiveStatuses[i]?.InspectUids(action);
			}
		}
		if (missionPoints != null)
		{
			for (int j = 0; j < missionPoints.Count; j++)
			{
				missionPoints[j]?.InspectUids(action);
			}
		}
		if (missionEntities != null)
		{
			for (int k = 0; k < missionEntities.Count; k++)
			{
				missionEntities[k]?.InspectUids(action);
			}
		}
		if (persistentMissionEntities != null)
		{
			for (int l = 0; l < persistentMissionEntities.Count; l++)
			{
				persistentMissionEntities[l]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MissionMapMarker : IDisposable, IPooled, IProto<MissionMapMarker>, IProto
{
	[NonSerialized]
	public NetworkableId missionProviderNetId;

	[NonSerialized]
	public List<uint> missionIds;

	[NonSerialized]
	public string nameToken;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MissionMapMarker instance)
	{
		if (instance.ShouldPool)
		{
			instance.missionProviderNetId = default(NetworkableId);
			if (instance.missionIds != null)
			{
				List<uint> list = instance.missionIds;
				Pool.FreeUnmanaged<uint>(ref list);
				instance.missionIds = list;
			}
			instance.nameToken = string.Empty;
			Pool.Free<MissionMapMarker>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MissionMapMarker with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MissionMapMarker instance)
	{
		instance.missionProviderNetId = missionProviderNetId;
		if (missionIds != null)
		{
			instance.missionIds = Pool.Get<List<uint>>();
			for (int i = 0; i < missionIds.Count; i++)
			{
				uint item = missionIds[i];
				instance.missionIds.Add(item);
			}
		}
		else
		{
			instance.missionIds = null;
		}
		instance.nameToken = nameToken;
	}

	public MissionMapMarker Copy()
	{
		MissionMapMarker missionMapMarker = Pool.Get<MissionMapMarker>();
		CopyTo(missionMapMarker);
		return missionMapMarker;
	}

	public static MissionMapMarker Deserialize(BufferStream stream)
	{
		MissionMapMarker missionMapMarker = Pool.Get<MissionMapMarker>();
		Deserialize(stream, missionMapMarker, isDelta: false);
		return missionMapMarker;
	}

	public static MissionMapMarker DeserializeLengthDelimited(BufferStream stream)
	{
		MissionMapMarker missionMapMarker = Pool.Get<MissionMapMarker>();
		DeserializeLengthDelimited(stream, missionMapMarker, isDelta: false);
		return missionMapMarker;
	}

	public static MissionMapMarker DeserializeLength(BufferStream stream, int length)
	{
		MissionMapMarker missionMapMarker = Pool.Get<MissionMapMarker>();
		DeserializeLength(stream, length, missionMapMarker, isDelta: false);
		return missionMapMarker;
	}

	public static MissionMapMarker Deserialize(byte[] buffer)
	{
		MissionMapMarker missionMapMarker = Pool.Get<MissionMapMarker>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, missionMapMarker, isDelta: false);
		return missionMapMarker;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MissionMapMarker previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MissionMapMarker Deserialize(BufferStream stream, MissionMapMarker instance, bool isDelta)
	{
		if (!isDelta && instance.missionIds == null)
		{
			instance.missionIds = Pool.Get<List<uint>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.missionProviderNetId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.missionIds.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 26:
				instance.nameToken = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MissionMapMarker DeserializeLengthDelimited(BufferStream stream, MissionMapMarker instance, bool isDelta)
	{
		if (!isDelta && instance.missionIds == null)
		{
			instance.missionIds = Pool.Get<List<uint>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.missionProviderNetId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.missionIds.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 26:
				instance.nameToken = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MissionMapMarker DeserializeLength(BufferStream stream, int length, MissionMapMarker instance, bool isDelta)
	{
		if (!isDelta && instance.missionIds == null)
		{
			instance.missionIds = Pool.Get<List<uint>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.missionProviderNetId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.missionIds.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 26:
				instance.nameToken = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MissionMapMarker instance, MissionMapMarker previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.missionProviderNetId.Value);
		if (instance.missionIds != null)
		{
			for (int i = 0; i < instance.missionIds.Count; i++)
			{
				uint val = instance.missionIds[i];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt32(stream, val);
			}
		}
		if (instance.nameToken != previous.nameToken)
		{
			if (instance.nameToken == null)
			{
				throw new ArgumentNullException("nameToken", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.nameToken);
		}
	}

	public static void Serialize(BufferStream stream, MissionMapMarker instance)
	{
		if (instance.missionProviderNetId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.missionProviderNetId.Value);
		}
		if (instance.missionIds != null)
		{
			for (int i = 0; i < instance.missionIds.Count; i++)
			{
				uint val = instance.missionIds[i];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt32(stream, val);
			}
		}
		if (instance.nameToken == null)
		{
			throw new ArgumentNullException("nameToken", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.nameToken);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref missionProviderNetId.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class MissionPoint : IDisposable, IPooled, IProto<MissionPoint>, IProto
{
	[NonSerialized]
	public string identifier;

	[NonSerialized]
	public Vector3 location;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MissionPoint instance)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.identifier = string.Empty;
			instance.location = default(Vector3);
			Pool.Free<MissionPoint>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MissionPoint with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MissionPoint instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.identifier = identifier;
		instance.location = location;
	}

	public MissionPoint Copy()
	{
		MissionPoint missionPoint = Pool.Get<MissionPoint>();
		CopyTo(missionPoint);
		return missionPoint;
	}

	public static MissionPoint Deserialize(BufferStream stream)
	{
		MissionPoint missionPoint = Pool.Get<MissionPoint>();
		Deserialize(stream, missionPoint, isDelta: false);
		return missionPoint;
	}

	public static MissionPoint DeserializeLengthDelimited(BufferStream stream)
	{
		MissionPoint missionPoint = Pool.Get<MissionPoint>();
		DeserializeLengthDelimited(stream, missionPoint, isDelta: false);
		return missionPoint;
	}

	public static MissionPoint DeserializeLength(BufferStream stream, int length)
	{
		MissionPoint missionPoint = Pool.Get<MissionPoint>();
		DeserializeLength(stream, length, missionPoint, isDelta: false);
		return missionPoint;
	}

	public static MissionPoint Deserialize(byte[] buffer)
	{
		MissionPoint missionPoint = Pool.Get<MissionPoint>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, missionPoint, isDelta: false);
		return missionPoint;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MissionPoint previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MissionPoint Deserialize(BufferStream stream, MissionPoint instance, bool isDelta)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.identifier = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.location, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MissionPoint DeserializeLengthDelimited(BufferStream stream, MissionPoint instance, bool isDelta)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.identifier = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.location, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MissionPoint DeserializeLength(BufferStream stream, int length, MissionPoint instance, bool isDelta)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.identifier = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.location, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MissionPoint instance, MissionPoint previous)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		if (instance.identifier != previous.identifier)
		{
			if (instance.identifier == null)
			{
				throw new ArgumentNullException("identifier", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.identifier);
		}
		if (instance.location != previous.location)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.location, previous.location);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field location (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, MissionPoint instance)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.identifier == null)
		{
			throw new ArgumentNullException("identifier", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.identifier);
		if (instance.location != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.location);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field location (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MissionReward : IDisposable, IPooled, IProto<MissionReward>, IProto
{
	[NonSerialized]
	public int itemID;

	[NonSerialized]
	public int itemAmount;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MissionReward instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemID = 0;
			instance.itemAmount = 0;
			Pool.Free<MissionReward>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MissionReward with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MissionReward instance)
	{
		instance.itemID = itemID;
		instance.itemAmount = itemAmount;
	}

	public MissionReward Copy()
	{
		MissionReward missionReward = Pool.Get<MissionReward>();
		CopyTo(missionReward);
		return missionReward;
	}

	public static MissionReward Deserialize(BufferStream stream)
	{
		MissionReward missionReward = Pool.Get<MissionReward>();
		Deserialize(stream, missionReward, isDelta: false);
		return missionReward;
	}

	public static MissionReward DeserializeLengthDelimited(BufferStream stream)
	{
		MissionReward missionReward = Pool.Get<MissionReward>();
		DeserializeLengthDelimited(stream, missionReward, isDelta: false);
		return missionReward;
	}

	public static MissionReward DeserializeLength(BufferStream stream, int length)
	{
		MissionReward missionReward = Pool.Get<MissionReward>();
		DeserializeLength(stream, length, missionReward, isDelta: false);
		return missionReward;
	}

	public static MissionReward Deserialize(byte[] buffer)
	{
		MissionReward missionReward = Pool.Get<MissionReward>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, missionReward, isDelta: false);
		return missionReward;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MissionReward previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MissionReward Deserialize(BufferStream stream, MissionReward instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.itemAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MissionReward DeserializeLengthDelimited(BufferStream stream, MissionReward instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.itemAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MissionReward DeserializeLength(BufferStream stream, int length, MissionReward instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.itemAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MissionReward instance, MissionReward previous)
	{
		if (instance.itemID != previous.itemID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.itemAmount != previous.itemAmount)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemAmount);
		}
	}

	public static void Serialize(BufferStream stream, MissionReward instance)
	{
		if (instance.itemID != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.itemAmount != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemAmount);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Missions : IDisposable, IPooled, IProto<Missions>, IProto
{
	[NonSerialized]
	public List<MissionInstance> missions;

	[NonSerialized]
	public int activeMission;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Missions instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.missions != null)
		{
			for (int i = 0; i < instance.missions.Count; i++)
			{
				if (instance.missions[i] != null)
				{
					instance.missions[i].ResetToPool();
					instance.missions[i] = null;
				}
			}
			List<MissionInstance> list = instance.missions;
			Pool.Free<MissionInstance>(ref list, false);
			instance.missions = list;
		}
		instance.activeMission = 0;
		Pool.Free<Missions>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Missions with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Missions instance)
	{
		if (missions != null)
		{
			instance.missions = Pool.Get<List<MissionInstance>>();
			for (int i = 0; i < missions.Count; i++)
			{
				MissionInstance item = missions[i].Copy();
				instance.missions.Add(item);
			}
		}
		else
		{
			instance.missions = null;
		}
		instance.activeMission = activeMission;
	}

	public Missions Copy()
	{
		Missions missions = Pool.Get<Missions>();
		CopyTo(missions);
		return missions;
	}

	public static Missions Deserialize(BufferStream stream)
	{
		Missions missions = Pool.Get<Missions>();
		Deserialize(stream, missions, isDelta: false);
		return missions;
	}

	public static Missions DeserializeLengthDelimited(BufferStream stream)
	{
		Missions missions = Pool.Get<Missions>();
		DeserializeLengthDelimited(stream, missions, isDelta: false);
		return missions;
	}

	public static Missions DeserializeLength(BufferStream stream, int length)
	{
		Missions missions = Pool.Get<Missions>();
		DeserializeLength(stream, length, missions, isDelta: false);
		return missions;
	}

	public static Missions Deserialize(byte[] buffer)
	{
		Missions missions = Pool.Get<Missions>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, missions, isDelta: false);
		return missions;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Missions previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Missions Deserialize(BufferStream stream, Missions instance, bool isDelta)
	{
		if (!isDelta && instance.missions == null)
		{
			instance.missions = Pool.Get<List<MissionInstance>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.missions.Add(MissionInstance.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.activeMission = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Missions DeserializeLengthDelimited(BufferStream stream, Missions instance, bool isDelta)
	{
		if (!isDelta && instance.missions == null)
		{
			instance.missions = Pool.Get<List<MissionInstance>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.missions.Add(MissionInstance.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.activeMission = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Missions DeserializeLength(BufferStream stream, int length, Missions instance, bool isDelta)
	{
		if (!isDelta && instance.missions == null)
		{
			instance.missions = Pool.Get<List<MissionInstance>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.missions.Add(MissionInstance.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.activeMission = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Missions instance, Missions previous)
	{
		if (instance.missions != null)
		{
			for (int i = 0; i < instance.missions.Count; i++)
			{
				MissionInstance missionInstance = instance.missions[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				MissionInstance.SerializeDelta(stream, missionInstance, missionInstance);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.activeMission != previous.activeMission)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.activeMission);
		}
	}

	public static void Serialize(BufferStream stream, Missions instance)
	{
		if (instance.missions != null)
		{
			for (int i = 0; i < instance.missions.Count; i++)
			{
				MissionInstance instance2 = instance.missions[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				MissionInstance.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.activeMission != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.activeMission);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (missions != null)
		{
			for (int i = 0; i < missions.Count; i++)
			{
				missions[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MixingTable : IDisposable, IPooled, IProto<MixingTable>, IProto
{
	[NonSerialized]
	public float totalMixTime;

	[NonSerialized]
	public float remainingMixTime;

	[NonSerialized]
	public int currentRecipe;

	[NonSerialized]
	public int pendingItem;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MixingTable instance)
	{
		if (instance.ShouldPool)
		{
			instance.totalMixTime = 0f;
			instance.remainingMixTime = 0f;
			instance.currentRecipe = 0;
			instance.pendingItem = 0;
			Pool.Free<MixingTable>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MixingTable with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MixingTable instance)
	{
		instance.totalMixTime = totalMixTime;
		instance.remainingMixTime = remainingMixTime;
		instance.currentRecipe = currentRecipe;
		instance.pendingItem = pendingItem;
	}

	public MixingTable Copy()
	{
		MixingTable mixingTable = Pool.Get<MixingTable>();
		CopyTo(mixingTable);
		return mixingTable;
	}

	public static MixingTable Deserialize(BufferStream stream)
	{
		MixingTable mixingTable = Pool.Get<MixingTable>();
		Deserialize(stream, mixingTable, isDelta: false);
		return mixingTable;
	}

	public static MixingTable DeserializeLengthDelimited(BufferStream stream)
	{
		MixingTable mixingTable = Pool.Get<MixingTable>();
		DeserializeLengthDelimited(stream, mixingTable, isDelta: false);
		return mixingTable;
	}

	public static MixingTable DeserializeLength(BufferStream stream, int length)
	{
		MixingTable mixingTable = Pool.Get<MixingTable>();
		DeserializeLength(stream, length, mixingTable, isDelta: false);
		return mixingTable;
	}

	public static MixingTable Deserialize(byte[] buffer)
	{
		MixingTable mixingTable = Pool.Get<MixingTable>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, mixingTable, isDelta: false);
		return mixingTable;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MixingTable previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MixingTable Deserialize(BufferStream stream, MixingTable instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.totalMixTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.remainingMixTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.currentRecipe = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.pendingItem = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MixingTable DeserializeLengthDelimited(BufferStream stream, MixingTable instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.totalMixTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.remainingMixTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.currentRecipe = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.pendingItem = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MixingTable DeserializeLength(BufferStream stream, int length, MixingTable instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.totalMixTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.remainingMixTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.currentRecipe = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.pendingItem = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MixingTable instance, MixingTable previous)
	{
		if (instance.totalMixTime != previous.totalMixTime)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.totalMixTime);
		}
		if (instance.remainingMixTime != previous.remainingMixTime)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.remainingMixTime);
		}
		if (instance.currentRecipe != previous.currentRecipe)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentRecipe);
		}
		if (instance.pendingItem != previous.pendingItem)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.pendingItem);
		}
	}

	public static void Serialize(BufferStream stream, MixingTable instance)
	{
		if (instance.totalMixTime != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.totalMixTime);
		}
		if (instance.remainingMixTime != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.remainingMixTime);
		}
		if (instance.currentRecipe != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentRecipe);
		}
		if (instance.pendingItem != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.pendingItem);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class MLRS : IDisposable, IPooled, IProto<MLRS>, IProto
{
	[NonSerialized]
	public Vector3 targetPos;

	[NonSerialized]
	public Vector3 curHitPos;

	[NonSerialized]
	public NetworkableId rocketStorageID;

	[NonSerialized]
	public NetworkableId dashboardStorageID;

	[NonSerialized]
	public uint ammoCount;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MLRS instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.targetPos = default(Vector3);
			instance.curHitPos = default(Vector3);
			instance.rocketStorageID = default(NetworkableId);
			instance.dashboardStorageID = default(NetworkableId);
			instance.ammoCount = 0u;
			Pool.Free<MLRS>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MLRS with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MLRS instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.targetPos = targetPos;
		instance.curHitPos = curHitPos;
		instance.rocketStorageID = rocketStorageID;
		instance.dashboardStorageID = dashboardStorageID;
		instance.ammoCount = ammoCount;
	}

	public MLRS Copy()
	{
		MLRS mLRS = Pool.Get<MLRS>();
		CopyTo(mLRS);
		return mLRS;
	}

	public static MLRS Deserialize(BufferStream stream)
	{
		MLRS mLRS = Pool.Get<MLRS>();
		Deserialize(stream, mLRS, isDelta: false);
		return mLRS;
	}

	public static MLRS DeserializeLengthDelimited(BufferStream stream)
	{
		MLRS mLRS = Pool.Get<MLRS>();
		DeserializeLengthDelimited(stream, mLRS, isDelta: false);
		return mLRS;
	}

	public static MLRS DeserializeLength(BufferStream stream, int length)
	{
		MLRS mLRS = Pool.Get<MLRS>();
		DeserializeLength(stream, length, mLRS, isDelta: false);
		return mLRS;
	}

	public static MLRS Deserialize(byte[] buffer)
	{
		MLRS mLRS = Pool.Get<MLRS>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, mLRS, isDelta: false);
		return mLRS;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MLRS previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MLRS Deserialize(BufferStream stream, MLRS instance, bool isDelta)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.targetPos, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.curHitPos, isDelta);
				continue;
			case 32:
				instance.rocketStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.dashboardStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 48:
				instance.ammoCount = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MLRS DeserializeLengthDelimited(BufferStream stream, MLRS instance, bool isDelta)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.targetPos, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.curHitPos, isDelta);
				continue;
			case 32:
				instance.rocketStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.dashboardStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 48:
				instance.ammoCount = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MLRS DeserializeLength(BufferStream stream, int length, MLRS instance, bool isDelta)
	{
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.targetPos, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.curHitPos, isDelta);
				continue;
			case 32:
				instance.rocketStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 40:
				instance.dashboardStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 48:
				instance.ammoCount = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MLRS instance, MLRS previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		if (instance.targetPos != previous.targetPos)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.targetPos, previous.targetPos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetPos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.curHitPos != previous.curHitPos)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.curHitPos, previous.curHitPos);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field curHitPos (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.rocketStorageID.Value);
		stream.WriteByte(40);
		ProtocolParser.WriteUInt64(stream, instance.dashboardStorageID.Value);
		if (instance.ammoCount != previous.ammoCount)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt32(stream, instance.ammoCount);
		}
	}

	public static void Serialize(BufferStream stream, MLRS instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		if (instance.targetPos != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.targetPos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetPos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.curHitPos != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.curHitPos);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field curHitPos (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.rocketStorageID != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.rocketStorageID.Value);
		}
		if (instance.dashboardStorageID != default(NetworkableId))
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.dashboardStorageID.Value);
		}
		if (instance.ammoCount != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt32(stream, instance.ammoCount);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref rocketStorageID.Value);
		action(UidType.NetworkableId, ref dashboardStorageID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Modifier : IDisposable, IPooled, IProto<Modifier>, IProto
{
	[NonSerialized]
	public int type;

	[NonSerialized]
	public int source;

	[NonSerialized]
	public float value;

	[NonSerialized]
	public double timeRemaining;

	[NonSerialized]
	public float duration;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Modifier instance)
	{
		if (instance.ShouldPool)
		{
			instance.type = 0;
			instance.source = 0;
			instance.value = 0f;
			instance.timeRemaining = 0.0;
			instance.duration = 0f;
			Pool.Free<Modifier>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Modifier with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Modifier instance)
	{
		instance.type = type;
		instance.source = source;
		instance.value = value;
		instance.timeRemaining = timeRemaining;
		instance.duration = duration;
	}

	public Modifier Copy()
	{
		Modifier modifier = Pool.Get<Modifier>();
		CopyTo(modifier);
		return modifier;
	}

	public static Modifier Deserialize(BufferStream stream)
	{
		Modifier modifier = Pool.Get<Modifier>();
		Deserialize(stream, modifier, isDelta: false);
		return modifier;
	}

	public static Modifier DeserializeLengthDelimited(BufferStream stream)
	{
		Modifier modifier = Pool.Get<Modifier>();
		DeserializeLengthDelimited(stream, modifier, isDelta: false);
		return modifier;
	}

	public static Modifier DeserializeLength(BufferStream stream, int length)
	{
		Modifier modifier = Pool.Get<Modifier>();
		DeserializeLength(stream, length, modifier, isDelta: false);
		return modifier;
	}

	public static Modifier Deserialize(byte[] buffer)
	{
		Modifier modifier = Pool.Get<Modifier>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, modifier, isDelta: false);
		return modifier;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Modifier previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Modifier Deserialize(BufferStream stream, Modifier instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.source = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			case 33:
				instance.timeRemaining = ProtocolParser.ReadDouble(stream);
				continue;
			case 45:
				instance.duration = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Modifier DeserializeLengthDelimited(BufferStream stream, Modifier instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.source = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			case 33:
				instance.timeRemaining = ProtocolParser.ReadDouble(stream);
				continue;
			case 45:
				instance.duration = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Modifier DeserializeLength(BufferStream stream, int length, Modifier instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.source = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			case 33:
				instance.timeRemaining = ProtocolParser.ReadDouble(stream);
				continue;
			case 45:
				instance.duration = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Modifier instance, Modifier previous)
	{
		if (instance.type != previous.type)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.source != previous.source)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.source);
		}
		if (instance.value != previous.value)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
		if (instance.timeRemaining != previous.timeRemaining)
		{
			stream.WriteByte(33);
			ProtocolParser.WriteDouble(stream, instance.timeRemaining);
		}
		if (instance.duration != previous.duration)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.duration);
		}
	}

	public static void Serialize(BufferStream stream, Modifier instance)
	{
		if (instance.type != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.source != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.source);
		}
		if (instance.value != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
		if (instance.timeRemaining != 0.0)
		{
			stream.WriteByte(33);
			ProtocolParser.WriteDouble(stream, instance.timeRemaining);
		}
		if (instance.duration != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.duration);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ModularCar : IDisposable, IPooled, IProto<ModularCar>, IProto
{
	[NonSerialized]
	public float steerAngle;

	[NonSerialized]
	public float driveWheelVel;

	[NonSerialized]
	public float throttleInput;

	[NonSerialized]
	public float brakeInput;

	[NonSerialized]
	public NetworkableId fuelStorageID;

	[NonSerialized]
	public float fuelFraction;

	[NonSerialized]
	public bool hasLock;

	[NonSerialized]
	public string lockCode;

	[NonSerialized]
	public List<ulong> whitelistUsers;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ModularCar instance)
	{
		if (instance.ShouldPool)
		{
			instance.steerAngle = 0f;
			instance.driveWheelVel = 0f;
			instance.throttleInput = 0f;
			instance.brakeInput = 0f;
			instance.fuelStorageID = default(NetworkableId);
			instance.fuelFraction = 0f;
			instance.hasLock = false;
			instance.lockCode = string.Empty;
			if (instance.whitelistUsers != null)
			{
				List<ulong> list = instance.whitelistUsers;
				Pool.FreeUnmanaged<ulong>(ref list);
				instance.whitelistUsers = list;
			}
			Pool.Free<ModularCar>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ModularCar with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ModularCar instance)
	{
		instance.steerAngle = steerAngle;
		instance.driveWheelVel = driveWheelVel;
		instance.throttleInput = throttleInput;
		instance.brakeInput = brakeInput;
		instance.fuelStorageID = fuelStorageID;
		instance.fuelFraction = fuelFraction;
		instance.hasLock = hasLock;
		instance.lockCode = lockCode;
		if (whitelistUsers != null)
		{
			instance.whitelistUsers = Pool.Get<List<ulong>>();
			for (int i = 0; i < whitelistUsers.Count; i++)
			{
				ulong item = whitelistUsers[i];
				instance.whitelistUsers.Add(item);
			}
		}
		else
		{
			instance.whitelistUsers = null;
		}
	}

	public ModularCar Copy()
	{
		ModularCar modularCar = Pool.Get<ModularCar>();
		CopyTo(modularCar);
		return modularCar;
	}

	public static ModularCar Deserialize(BufferStream stream)
	{
		ModularCar modularCar = Pool.Get<ModularCar>();
		Deserialize(stream, modularCar, isDelta: false);
		return modularCar;
	}

	public static ModularCar DeserializeLengthDelimited(BufferStream stream)
	{
		ModularCar modularCar = Pool.Get<ModularCar>();
		DeserializeLengthDelimited(stream, modularCar, isDelta: false);
		return modularCar;
	}

	public static ModularCar DeserializeLength(BufferStream stream, int length)
	{
		ModularCar modularCar = Pool.Get<ModularCar>();
		DeserializeLength(stream, length, modularCar, isDelta: false);
		return modularCar;
	}

	public static ModularCar Deserialize(byte[] buffer)
	{
		ModularCar modularCar = Pool.Get<ModularCar>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, modularCar, isDelta: false);
		return modularCar;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ModularCar previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ModularCar Deserialize(BufferStream stream, ModularCar instance, bool isDelta)
	{
		if (!isDelta && instance.whitelistUsers == null)
		{
			instance.whitelistUsers = Pool.Get<List<ulong>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.steerAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 53:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.hasLock = ProtocolParser.ReadBool(stream);
				continue;
			case 66:
				instance.lockCode = ProtocolParser.ReadString(stream);
				continue;
			case 72:
				instance.whitelistUsers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ModularCar DeserializeLengthDelimited(BufferStream stream, ModularCar instance, bool isDelta)
	{
		if (!isDelta && instance.whitelistUsers == null)
		{
			instance.whitelistUsers = Pool.Get<List<ulong>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.steerAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 53:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.hasLock = ProtocolParser.ReadBool(stream);
				continue;
			case 66:
				instance.lockCode = ProtocolParser.ReadString(stream);
				continue;
			case 72:
				instance.whitelistUsers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ModularCar DeserializeLength(BufferStream stream, int length, ModularCar instance, bool isDelta)
	{
		if (!isDelta && instance.whitelistUsers == null)
		{
			instance.whitelistUsers = Pool.Get<List<ulong>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.steerAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 53:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.hasLock = ProtocolParser.ReadBool(stream);
				continue;
			case 66:
				instance.lockCode = ProtocolParser.ReadString(stream);
				continue;
			case 72:
				instance.whitelistUsers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ModularCar instance, ModularCar previous)
	{
		if (instance.steerAngle != previous.steerAngle)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.steerAngle);
		}
		if (instance.driveWheelVel != previous.driveWheelVel)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.driveWheelVel);
		}
		if (instance.throttleInput != previous.throttleInput)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.throttleInput);
		}
		if (instance.brakeInput != previous.brakeInput)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.brakeInput);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		if (instance.fuelFraction != previous.fuelFraction)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.hasLock);
		if (instance.lockCode != null && instance.lockCode != previous.lockCode)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteString(stream, instance.lockCode);
		}
		if (instance.whitelistUsers != null)
		{
			for (int i = 0; i < instance.whitelistUsers.Count; i++)
			{
				ulong val = instance.whitelistUsers[i];
				stream.WriteByte(72);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
	}

	public static void Serialize(BufferStream stream, ModularCar instance)
	{
		if (instance.steerAngle != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.steerAngle);
		}
		if (instance.driveWheelVel != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.driveWheelVel);
		}
		if (instance.throttleInput != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.throttleInput);
		}
		if (instance.brakeInput != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.brakeInput);
		}
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
		if (instance.fuelFraction != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
		if (instance.hasLock)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.hasLock);
		}
		if (instance.lockCode != null)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteString(stream, instance.lockCode);
		}
		if (instance.whitelistUsers != null)
		{
			for (int i = 0; i < instance.whitelistUsers.Count; i++)
			{
				ulong val = instance.whitelistUsers[i];
				stream.WriteByte(72);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref fuelStorageID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ModularVehicle : IDisposable, IPooled, IProto<ModularVehicle>, IProto
{
	[NonSerialized]
	public bool editable;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ModularVehicle instance)
	{
		if (instance.ShouldPool)
		{
			instance.editable = false;
			Pool.Free<ModularVehicle>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ModularVehicle with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ModularVehicle instance)
	{
		instance.editable = editable;
	}

	public ModularVehicle Copy()
	{
		ModularVehicle modularVehicle = Pool.Get<ModularVehicle>();
		CopyTo(modularVehicle);
		return modularVehicle;
	}

	public static ModularVehicle Deserialize(BufferStream stream)
	{
		ModularVehicle modularVehicle = Pool.Get<ModularVehicle>();
		Deserialize(stream, modularVehicle, isDelta: false);
		return modularVehicle;
	}

	public static ModularVehicle DeserializeLengthDelimited(BufferStream stream)
	{
		ModularVehicle modularVehicle = Pool.Get<ModularVehicle>();
		DeserializeLengthDelimited(stream, modularVehicle, isDelta: false);
		return modularVehicle;
	}

	public static ModularVehicle DeserializeLength(BufferStream stream, int length)
	{
		ModularVehicle modularVehicle = Pool.Get<ModularVehicle>();
		DeserializeLength(stream, length, modularVehicle, isDelta: false);
		return modularVehicle;
	}

	public static ModularVehicle Deserialize(byte[] buffer)
	{
		ModularVehicle modularVehicle = Pool.Get<ModularVehicle>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, modularVehicle, isDelta: false);
		return modularVehicle;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ModularVehicle previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ModularVehicle Deserialize(BufferStream stream, ModularVehicle instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.editable = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ModularVehicle DeserializeLengthDelimited(BufferStream stream, ModularVehicle instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.editable = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ModularVehicle DeserializeLength(BufferStream stream, int length, ModularVehicle instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.editable = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ModularVehicle instance, ModularVehicle previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.editable);
	}

	public static void Serialize(BufferStream stream, ModularVehicle instance)
	{
		if (instance.editable)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.editable);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ModuleMessage : IDisposable, IPooled, IProto<ModuleMessage>, IProto
{
	[NonSerialized]
	public uint itemid;

	[NonSerialized]
	public int moduleid;

	[NonSerialized]
	public int type;

	[NonSerialized]
	public byte[] data;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ModuleMessage instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemid = 0u;
			instance.moduleid = 0;
			instance.type = 0;
			instance.data = null;
			Pool.Free<ModuleMessage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ModuleMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ModuleMessage instance)
	{
		instance.itemid = itemid;
		instance.moduleid = moduleid;
		instance.type = type;
		if (data == null)
		{
			instance.data = null;
			return;
		}
		instance.data = new byte[data.Length];
		Array.Copy(data, instance.data, instance.data.Length);
	}

	public ModuleMessage Copy()
	{
		ModuleMessage moduleMessage = Pool.Get<ModuleMessage>();
		CopyTo(moduleMessage);
		return moduleMessage;
	}

	public static ModuleMessage Deserialize(BufferStream stream)
	{
		ModuleMessage moduleMessage = Pool.Get<ModuleMessage>();
		Deserialize(stream, moduleMessage, isDelta: false);
		return moduleMessage;
	}

	public static ModuleMessage DeserializeLengthDelimited(BufferStream stream)
	{
		ModuleMessage moduleMessage = Pool.Get<ModuleMessage>();
		DeserializeLengthDelimited(stream, moduleMessage, isDelta: false);
		return moduleMessage;
	}

	public static ModuleMessage DeserializeLength(BufferStream stream, int length)
	{
		ModuleMessage moduleMessage = Pool.Get<ModuleMessage>();
		DeserializeLength(stream, length, moduleMessage, isDelta: false);
		return moduleMessage;
	}

	public static ModuleMessage Deserialize(byte[] buffer)
	{
		ModuleMessage moduleMessage = Pool.Get<ModuleMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, moduleMessage, isDelta: false);
		return moduleMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ModuleMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ModuleMessage Deserialize(BufferStream stream, ModuleMessage instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemid = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.moduleid = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ModuleMessage DeserializeLengthDelimited(BufferStream stream, ModuleMessage instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemid = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.moduleid = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ModuleMessage DeserializeLength(BufferStream stream, int length, ModuleMessage instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemid = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.moduleid = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ModuleMessage instance, ModuleMessage previous)
	{
		if (instance.itemid != previous.itemid)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.itemid);
		}
		if (instance.moduleid != previous.moduleid)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.moduleid);
		}
		if (instance.type != previous.type)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.data != null)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteBytes(stream, instance.data);
		}
	}

	public static void Serialize(BufferStream stream, ModuleMessage instance)
	{
		if (instance.itemid != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.itemid);
		}
		if (instance.moduleid != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.moduleid);
		}
		if (instance.type != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.data != null)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteBytes(stream, instance.data);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Motorboat : IDisposable, IPooled, IProto<Motorboat>, IProto
{
	[NonSerialized]
	public NetworkableId storageid;

	[NonSerialized]
	public NetworkableId fuelStorageID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Motorboat instance)
	{
		if (instance.ShouldPool)
		{
			instance.storageid = default(NetworkableId);
			instance.fuelStorageID = default(NetworkableId);
			Pool.Free<Motorboat>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Motorboat with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Motorboat instance)
	{
		instance.storageid = storageid;
		instance.fuelStorageID = fuelStorageID;
	}

	public Motorboat Copy()
	{
		Motorboat motorboat = Pool.Get<Motorboat>();
		CopyTo(motorboat);
		return motorboat;
	}

	public static Motorboat Deserialize(BufferStream stream)
	{
		Motorboat motorboat = Pool.Get<Motorboat>();
		Deserialize(stream, motorboat, isDelta: false);
		return motorboat;
	}

	public static Motorboat DeserializeLengthDelimited(BufferStream stream)
	{
		Motorboat motorboat = Pool.Get<Motorboat>();
		DeserializeLengthDelimited(stream, motorboat, isDelta: false);
		return motorboat;
	}

	public static Motorboat DeserializeLength(BufferStream stream, int length)
	{
		Motorboat motorboat = Pool.Get<Motorboat>();
		DeserializeLength(stream, length, motorboat, isDelta: false);
		return motorboat;
	}

	public static Motorboat Deserialize(byte[] buffer)
	{
		Motorboat motorboat = Pool.Get<Motorboat>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, motorboat, isDelta: false);
		return motorboat;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Motorboat previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Motorboat Deserialize(BufferStream stream, Motorboat instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.storageid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Motorboat DeserializeLengthDelimited(BufferStream stream, Motorboat instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.storageid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Motorboat DeserializeLength(BufferStream stream, int length, Motorboat instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.storageid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Motorboat instance, Motorboat previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.storageid.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
	}

	public static void Serialize(BufferStream stream, Motorboat instance)
	{
		if (instance.storageid != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.storageid.Value);
		}
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref storageid.Value);
		action(UidType.NetworkableId, ref fuelStorageID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MountedWeapon : IDisposable, IPooled, IProto<MountedWeapon>, IProto
{
	[NonSerialized]
	public int ammoItemID;

	[NonSerialized]
	public int ammoStackSize;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MountedWeapon instance)
	{
		if (instance.ShouldPool)
		{
			instance.ammoItemID = 0;
			instance.ammoStackSize = 0;
			Pool.Free<MountedWeapon>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MountedWeapon with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MountedWeapon instance)
	{
		instance.ammoItemID = ammoItemID;
		instance.ammoStackSize = ammoStackSize;
	}

	public MountedWeapon Copy()
	{
		MountedWeapon mountedWeapon = Pool.Get<MountedWeapon>();
		CopyTo(mountedWeapon);
		return mountedWeapon;
	}

	public static MountedWeapon Deserialize(BufferStream stream)
	{
		MountedWeapon mountedWeapon = Pool.Get<MountedWeapon>();
		Deserialize(stream, mountedWeapon, isDelta: false);
		return mountedWeapon;
	}

	public static MountedWeapon DeserializeLengthDelimited(BufferStream stream)
	{
		MountedWeapon mountedWeapon = Pool.Get<MountedWeapon>();
		DeserializeLengthDelimited(stream, mountedWeapon, isDelta: false);
		return mountedWeapon;
	}

	public static MountedWeapon DeserializeLength(BufferStream stream, int length)
	{
		MountedWeapon mountedWeapon = Pool.Get<MountedWeapon>();
		DeserializeLength(stream, length, mountedWeapon, isDelta: false);
		return mountedWeapon;
	}

	public static MountedWeapon Deserialize(byte[] buffer)
	{
		MountedWeapon mountedWeapon = Pool.Get<MountedWeapon>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, mountedWeapon, isDelta: false);
		return mountedWeapon;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MountedWeapon previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MountedWeapon Deserialize(BufferStream stream, MountedWeapon instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.ammoItemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.ammoStackSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MountedWeapon DeserializeLengthDelimited(BufferStream stream, MountedWeapon instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.ammoItemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.ammoStackSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MountedWeapon DeserializeLength(BufferStream stream, int length, MountedWeapon instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.ammoItemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.ammoStackSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MountedWeapon instance, MountedWeapon previous)
	{
		if (instance.ammoItemID != previous.ammoItemID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoItemID);
		}
		if (instance.ammoStackSize != previous.ammoStackSize)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoStackSize);
		}
	}

	public static void Serialize(BufferStream stream, MountedWeapon instance)
	{
		if (instance.ammoItemID != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoItemID);
		}
		if (instance.ammoStackSize != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoStackSize);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class NeonSign : IDisposable, IPooled, IProto<NeonSign>, IProto
{
	public class Lights : IDisposable, IPooled, IProto<Lights>, IProto
	{
		[NonSerialized]
		public Color topLeft;

		[NonSerialized]
		public Color topRight;

		[NonSerialized]
		public Color bottomLeft;

		[NonSerialized]
		public Color bottomRight;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Lights instance)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.topLeft = default(Color);
				instance.topRight = default(Color);
				instance.bottomLeft = default(Color);
				instance.bottomRight = default(Color);
				Pool.Free<Lights>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Lights with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Lights instance)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			instance.topLeft = topLeft;
			instance.topRight = topRight;
			instance.bottomLeft = bottomLeft;
			instance.bottomRight = bottomRight;
		}

		public Lights Copy()
		{
			Lights lights = Pool.Get<Lights>();
			CopyTo(lights);
			return lights;
		}

		public static Lights Deserialize(BufferStream stream)
		{
			Lights lights = Pool.Get<Lights>();
			Deserialize(stream, lights, isDelta: false);
			return lights;
		}

		public static Lights DeserializeLengthDelimited(BufferStream stream)
		{
			Lights lights = Pool.Get<Lights>();
			DeserializeLengthDelimited(stream, lights, isDelta: false);
			return lights;
		}

		public static Lights DeserializeLength(BufferStream stream, int length)
		{
			Lights lights = Pool.Get<Lights>();
			DeserializeLength(stream, length, lights, isDelta: false);
			return lights;
		}

		public static Lights Deserialize(byte[] buffer)
		{
			Lights lights = Pool.Get<Lights>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, lights, isDelta: false);
			return lights;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Lights previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Lights Deserialize(BufferStream stream, Lights instance, bool isDelta)
		{
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topLeft, isDelta);
					continue;
				case 18:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topRight, isDelta);
					continue;
				case 26:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomLeft, isDelta);
					continue;
				case 34:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomRight, isDelta);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Lights DeserializeLengthDelimited(BufferStream stream, Lights instance, bool isDelta)
		{
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topLeft, isDelta);
					continue;
				case 18:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topRight, isDelta);
					continue;
				case 26:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomLeft, isDelta);
					continue;
				case 34:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomRight, isDelta);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Lights DeserializeLength(BufferStream stream, int length, Lights instance, bool isDelta)
		{
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			//IL_0094: Unknown result type (might be due to invalid IL or missing references)
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topLeft, isDelta);
					continue;
				case 18:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topRight, isDelta);
					continue;
				case 26:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomLeft, isDelta);
					continue;
				case 34:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomRight, isDelta);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Lights instance, Lights previous)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			//IL_0136: Unknown result type (might be due to invalid IL or missing references)
			//IL_013c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_0163: Unknown result type (might be due to invalid IL or missing references)
			//IL_0169: Unknown result type (might be due to invalid IL or missing references)
			if (instance.topLeft != previous.topLeft)
			{
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				ColorSerialized.SerializeDelta(stream, instance.topLeft, previous.topLeft);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field topLeft (UnityEngine.Color)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.topRight != previous.topRight)
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				ColorSerialized.SerializeDelta(stream, instance.topRight, previous.topRight);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field topRight (UnityEngine.Color)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.bottomLeft != previous.bottomLeft)
			{
				stream.WriteByte(26);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int position3 = stream.Position;
				ColorSerialized.SerializeDelta(stream, instance.bottomLeft, previous.bottomLeft);
				int num3 = stream.Position - position3;
				if (num3 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field bottomLeft (UnityEngine.Color)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			}
			if (instance.bottomRight != previous.bottomRight)
			{
				stream.WriteByte(34);
				BufferStream.RangeHandle range4 = stream.GetRange(1);
				int position4 = stream.Position;
				ColorSerialized.SerializeDelta(stream, instance.bottomRight, previous.bottomRight);
				int num4 = stream.Position - position4;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field bottomRight (UnityEngine.Color)");
				}
				Span<byte> span4 = range4.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span4, 0);
			}
		}

		public static void Serialize(BufferStream stream, Lights instance)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_012e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0135: Unknown result type (might be due to invalid IL or missing references)
			//IL_013b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
			//IL_015e: Unknown result type (might be due to invalid IL or missing references)
			if (instance.topLeft != default(Color))
			{
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				ColorSerialized.Serialize(stream, instance.topLeft);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field topLeft (UnityEngine.Color)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.topRight != default(Color))
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				ColorSerialized.Serialize(stream, instance.topRight);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field topRight (UnityEngine.Color)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.bottomLeft != default(Color))
			{
				stream.WriteByte(26);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int position3 = stream.Position;
				ColorSerialized.Serialize(stream, instance.bottomLeft);
				int num3 = stream.Position - position3;
				if (num3 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field bottomLeft (UnityEngine.Color)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			}
			if (instance.bottomRight != default(Color))
			{
				stream.WriteByte(34);
				BufferStream.RangeHandle range4 = stream.GetRange(1);
				int position4 = stream.Position;
				ColorSerialized.Serialize(stream, instance.bottomRight);
				int num4 = stream.Position - position4;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field bottomRight (UnityEngine.Color)");
				}
				Span<byte> span4 = range4.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span4, 0);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<Lights> frameLighting;

	[NonSerialized]
	public int currentFrame;

	[NonSerialized]
	public float animationSpeed;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(NeonSign instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.frameLighting != null)
		{
			for (int i = 0; i < instance.frameLighting.Count; i++)
			{
				if (instance.frameLighting[i] != null)
				{
					instance.frameLighting[i].ResetToPool();
					instance.frameLighting[i] = null;
				}
			}
			List<Lights> list = instance.frameLighting;
			Pool.Free<Lights>(ref list, false);
			instance.frameLighting = list;
		}
		instance.currentFrame = 0;
		instance.animationSpeed = 0f;
		Pool.Free<NeonSign>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose NeonSign with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(NeonSign instance)
	{
		if (frameLighting != null)
		{
			instance.frameLighting = Pool.Get<List<Lights>>();
			for (int i = 0; i < frameLighting.Count; i++)
			{
				Lights item = frameLighting[i].Copy();
				instance.frameLighting.Add(item);
			}
		}
		else
		{
			instance.frameLighting = null;
		}
		instance.currentFrame = currentFrame;
		instance.animationSpeed = animationSpeed;
	}

	public NeonSign Copy()
	{
		NeonSign neonSign = Pool.Get<NeonSign>();
		CopyTo(neonSign);
		return neonSign;
	}

	public static NeonSign Deserialize(BufferStream stream)
	{
		NeonSign neonSign = Pool.Get<NeonSign>();
		Deserialize(stream, neonSign, isDelta: false);
		return neonSign;
	}

	public static NeonSign DeserializeLengthDelimited(BufferStream stream)
	{
		NeonSign neonSign = Pool.Get<NeonSign>();
		DeserializeLengthDelimited(stream, neonSign, isDelta: false);
		return neonSign;
	}

	public static NeonSign DeserializeLength(BufferStream stream, int length)
	{
		NeonSign neonSign = Pool.Get<NeonSign>();
		DeserializeLength(stream, length, neonSign, isDelta: false);
		return neonSign;
	}

	public static NeonSign Deserialize(byte[] buffer)
	{
		NeonSign neonSign = Pool.Get<NeonSign>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, neonSign, isDelta: false);
		return neonSign;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, NeonSign previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static NeonSign Deserialize(BufferStream stream, NeonSign instance, bool isDelta)
	{
		if (!isDelta && instance.frameLighting == null)
		{
			instance.frameLighting = Pool.Get<List<Lights>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 42:
				instance.frameLighting.Add(Lights.DeserializeLengthDelimited(stream));
				continue;
			case 48:
				instance.currentFrame = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 61:
				instance.animationSpeed = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static NeonSign DeserializeLengthDelimited(BufferStream stream, NeonSign instance, bool isDelta)
	{
		if (!isDelta && instance.frameLighting == null)
		{
			instance.frameLighting = Pool.Get<List<Lights>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 42:
				instance.frameLighting.Add(Lights.DeserializeLengthDelimited(stream));
				continue;
			case 48:
				instance.currentFrame = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 61:
				instance.animationSpeed = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static NeonSign DeserializeLength(BufferStream stream, int length, NeonSign instance, bool isDelta)
	{
		if (!isDelta && instance.frameLighting == null)
		{
			instance.frameLighting = Pool.Get<List<Lights>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 42:
				instance.frameLighting.Add(Lights.DeserializeLengthDelimited(stream));
				continue;
			case 48:
				instance.currentFrame = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 61:
				instance.animationSpeed = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, NeonSign instance, NeonSign previous)
	{
		if (instance.frameLighting != null)
		{
			for (int i = 0; i < instance.frameLighting.Count; i++)
			{
				Lights lights = instance.frameLighting[i];
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Lights.SerializeDelta(stream, lights, lights);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field frameLighting (ProtoBuf.NeonSign.Lights)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.currentFrame != previous.currentFrame)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentFrame);
		}
		if (instance.animationSpeed != previous.animationSpeed)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.animationSpeed);
		}
	}

	public static void Serialize(BufferStream stream, NeonSign instance)
	{
		if (instance.frameLighting != null)
		{
			for (int i = 0; i < instance.frameLighting.Count; i++)
			{
				Lights instance2 = instance.frameLighting[i];
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Lights.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field frameLighting (ProtoBuf.NeonSign.Lights)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.currentFrame != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentFrame);
		}
		if (instance.animationSpeed != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.animationSpeed);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (frameLighting != null)
		{
			for (int i = 0; i < frameLighting.Count; i++)
			{
				frameLighting[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class NexusDockTerminal : IDisposable, IPooled, IProto<NexusDockTerminal>, IProto
{
	public class ScheduleEntry : IDisposable, IPooled, IProto<ScheduleEntry>, IProto
	{
		[NonSerialized]
		public int nextZoneId;

		[NonSerialized]
		public int estimate;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(ScheduleEntry instance)
		{
			if (instance.ShouldPool)
			{
				instance.nextZoneId = 0;
				instance.estimate = 0;
				Pool.Free<ScheduleEntry>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose ScheduleEntry with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(ScheduleEntry instance)
		{
			instance.nextZoneId = nextZoneId;
			instance.estimate = estimate;
		}

		public ScheduleEntry Copy()
		{
			ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
			CopyTo(scheduleEntry);
			return scheduleEntry;
		}

		public static ScheduleEntry Deserialize(BufferStream stream)
		{
			ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
			Deserialize(stream, scheduleEntry, isDelta: false);
			return scheduleEntry;
		}

		public static ScheduleEntry DeserializeLengthDelimited(BufferStream stream)
		{
			ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
			DeserializeLengthDelimited(stream, scheduleEntry, isDelta: false);
			return scheduleEntry;
		}

		public static ScheduleEntry DeserializeLength(BufferStream stream, int length)
		{
			ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
			DeserializeLength(stream, length, scheduleEntry, isDelta: false);
			return scheduleEntry;
		}

		public static ScheduleEntry Deserialize(byte[] buffer)
		{
			ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, scheduleEntry, isDelta: false);
			return scheduleEntry;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, ScheduleEntry previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static ScheduleEntry Deserialize(BufferStream stream, ScheduleEntry instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.nextZoneId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.estimate = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static ScheduleEntry DeserializeLengthDelimited(BufferStream stream, ScheduleEntry instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.nextZoneId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.estimate = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static ScheduleEntry DeserializeLength(BufferStream stream, int length, ScheduleEntry instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.nextZoneId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.estimate = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, ScheduleEntry instance, ScheduleEntry previous)
		{
			if (instance.nextZoneId != previous.nextZoneId)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.nextZoneId);
			}
			if (instance.estimate != previous.estimate)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.estimate);
			}
		}

		public static void Serialize(BufferStream stream, ScheduleEntry instance)
		{
			if (instance.nextZoneId != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.nextZoneId);
			}
			if (instance.estimate != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.estimate);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<ScheduleEntry> schedule;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(NexusDockTerminal instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.schedule != null)
		{
			for (int i = 0; i < instance.schedule.Count; i++)
			{
				if (instance.schedule[i] != null)
				{
					instance.schedule[i].ResetToPool();
					instance.schedule[i] = null;
				}
			}
			List<ScheduleEntry> list = instance.schedule;
			Pool.Free<ScheduleEntry>(ref list, false);
			instance.schedule = list;
		}
		Pool.Free<NexusDockTerminal>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose NexusDockTerminal with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(NexusDockTerminal instance)
	{
		if (schedule != null)
		{
			instance.schedule = Pool.Get<List<ScheduleEntry>>();
			for (int i = 0; i < schedule.Count; i++)
			{
				ScheduleEntry item = schedule[i].Copy();
				instance.schedule.Add(item);
			}
		}
		else
		{
			instance.schedule = null;
		}
	}

	public NexusDockTerminal Copy()
	{
		NexusDockTerminal nexusDockTerminal = Pool.Get<NexusDockTerminal>();
		CopyTo(nexusDockTerminal);
		return nexusDockTerminal;
	}

	public static NexusDockTerminal Deserialize(BufferStream stream)
	{
		NexusDockTerminal nexusDockTerminal = Pool.Get<NexusDockTerminal>();
		Deserialize(stream, nexusDockTerminal, isDelta: false);
		return nexusDockTerminal;
	}

	public static NexusDockTerminal DeserializeLengthDelimited(BufferStream stream)
	{
		NexusDockTerminal nexusDockTerminal = Pool.Get<NexusDockTerminal>();
		DeserializeLengthDelimited(stream, nexusDockTerminal, isDelta: false);
		return nexusDockTerminal;
	}

	public static NexusDockTerminal DeserializeLength(BufferStream stream, int length)
	{
		NexusDockTerminal nexusDockTerminal = Pool.Get<NexusDockTerminal>();
		DeserializeLength(stream, length, nexusDockTerminal, isDelta: false);
		return nexusDockTerminal;
	}

	public static NexusDockTerminal Deserialize(byte[] buffer)
	{
		NexusDockTerminal nexusDockTerminal = Pool.Get<NexusDockTerminal>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, nexusDockTerminal, isDelta: false);
		return nexusDockTerminal;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, NexusDockTerminal previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static NexusDockTerminal Deserialize(BufferStream stream, NexusDockTerminal instance, bool isDelta)
	{
		if (!isDelta && instance.schedule == null)
		{
			instance.schedule = Pool.Get<List<ScheduleEntry>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.schedule.Add(ScheduleEntry.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static NexusDockTerminal DeserializeLengthDelimited(BufferStream stream, NexusDockTerminal instance, bool isDelta)
	{
		if (!isDelta && instance.schedule == null)
		{
			instance.schedule = Pool.Get<List<ScheduleEntry>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.schedule.Add(ScheduleEntry.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static NexusDockTerminal DeserializeLength(BufferStream stream, int length, NexusDockTerminal instance, bool isDelta)
	{
		if (!isDelta && instance.schedule == null)
		{
			instance.schedule = Pool.Get<List<ScheduleEntry>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.schedule.Add(ScheduleEntry.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, NexusDockTerminal instance, NexusDockTerminal previous)
	{
		if (instance.schedule == null)
		{
			return;
		}
		for (int i = 0; i < instance.schedule.Count; i++)
		{
			ScheduleEntry scheduleEntry = instance.schedule[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ScheduleEntry.SerializeDelta(stream, scheduleEntry, scheduleEntry);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field schedule (ProtoBuf.NexusDockTerminal.ScheduleEntry)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, NexusDockTerminal instance)
	{
		if (instance.schedule == null)
		{
			return;
		}
		for (int i = 0; i < instance.schedule.Count; i++)
		{
			ScheduleEntry instance2 = instance.schedule[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ScheduleEntry.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field schedule (ProtoBuf.NexusDockTerminal.ScheduleEntry)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (schedule != null)
		{
			for (int i = 0; i < schedule.Count; i++)
			{
				schedule[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class NexusFerry : IDisposable, IPooled, IProto<NexusFerry>, IProto
{
	[NonSerialized]
	public long timestamp;

	[NonSerialized]
	public string ownerZone;

	[NonSerialized]
	public List<string> schedule;

	[NonSerialized]
	public int scheduleIndex;

	[NonSerialized]
	public int state;

	[NonSerialized]
	public bool isRetiring;

	[NonSerialized]
	public List<NetworkableId> transferredIds;

	[NonSerialized]
	public int nextScheduleIndex;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(NexusFerry instance)
	{
		if (instance.ShouldPool)
		{
			instance.timestamp = 0L;
			instance.ownerZone = string.Empty;
			if (instance.schedule != null)
			{
				List<string> list = instance.schedule;
				Pool.FreeUnmanaged<string>(ref list);
				instance.schedule = list;
			}
			instance.scheduleIndex = 0;
			instance.state = 0;
			instance.isRetiring = false;
			if (instance.transferredIds != null)
			{
				List<NetworkableId> list2 = instance.transferredIds;
				Pool.FreeUnmanaged<NetworkableId>(ref list2);
				instance.transferredIds = list2;
			}
			instance.nextScheduleIndex = 0;
			Pool.Free<NexusFerry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose NexusFerry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(NexusFerry instance)
	{
		instance.timestamp = timestamp;
		instance.ownerZone = ownerZone;
		if (schedule != null)
		{
			instance.schedule = Pool.Get<List<string>>();
			for (int i = 0; i < schedule.Count; i++)
			{
				string item = schedule[i];
				instance.schedule.Add(item);
			}
		}
		else
		{
			instance.schedule = null;
		}
		instance.scheduleIndex = scheduleIndex;
		instance.state = state;
		instance.isRetiring = isRetiring;
		if (transferredIds != null)
		{
			instance.transferredIds = Pool.Get<List<NetworkableId>>();
			for (int j = 0; j < transferredIds.Count; j++)
			{
				NetworkableId item2 = transferredIds[j];
				instance.transferredIds.Add(item2);
			}
		}
		else
		{
			instance.transferredIds = null;
		}
		instance.nextScheduleIndex = nextScheduleIndex;
	}

	public NexusFerry Copy()
	{
		NexusFerry nexusFerry = Pool.Get<NexusFerry>();
		CopyTo(nexusFerry);
		return nexusFerry;
	}

	public static NexusFerry Deserialize(BufferStream stream)
	{
		NexusFerry nexusFerry = Pool.Get<NexusFerry>();
		Deserialize(stream, nexusFerry, isDelta: false);
		return nexusFerry;
	}

	public static NexusFerry DeserializeLengthDelimited(BufferStream stream)
	{
		NexusFerry nexusFerry = Pool.Get<NexusFerry>();
		DeserializeLengthDelimited(stream, nexusFerry, isDelta: false);
		return nexusFerry;
	}

	public static NexusFerry DeserializeLength(BufferStream stream, int length)
	{
		NexusFerry nexusFerry = Pool.Get<NexusFerry>();
		DeserializeLength(stream, length, nexusFerry, isDelta: false);
		return nexusFerry;
	}

	public static NexusFerry Deserialize(byte[] buffer)
	{
		NexusFerry nexusFerry = Pool.Get<NexusFerry>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, nexusFerry, isDelta: false);
		return nexusFerry;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, NexusFerry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static NexusFerry Deserialize(BufferStream stream, NexusFerry instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.schedule == null)
			{
				instance.schedule = Pool.Get<List<string>>();
			}
			if (instance.transferredIds == null)
			{
				instance.transferredIds = Pool.Get<List<NetworkableId>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.ownerZone = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			case 32:
				instance.scheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.isRetiring = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.transferredIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			case 64:
				instance.nextScheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static NexusFerry DeserializeLengthDelimited(BufferStream stream, NexusFerry instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.schedule == null)
			{
				instance.schedule = Pool.Get<List<string>>();
			}
			if (instance.transferredIds == null)
			{
				instance.transferredIds = Pool.Get<List<NetworkableId>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.ownerZone = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			case 32:
				instance.scheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.isRetiring = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.transferredIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			case 64:
				instance.nextScheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static NexusFerry DeserializeLength(BufferStream stream, int length, NexusFerry instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.schedule == null)
			{
				instance.schedule = Pool.Get<List<string>>();
			}
			if (instance.transferredIds == null)
			{
				instance.transferredIds = Pool.Get<List<NetworkableId>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.ownerZone = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			case 32:
				instance.scheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.isRetiring = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.transferredIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			case 64:
				instance.nextScheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, NexusFerry instance, NexusFerry previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		if (instance.ownerZone != null && instance.ownerZone != previous.ownerZone)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.ownerZone);
		}
		if (instance.schedule != null)
		{
			for (int i = 0; i < instance.schedule.Count; i++)
			{
				string val = instance.schedule[i];
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, val);
			}
		}
		if (instance.scheduleIndex != previous.scheduleIndex)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.scheduleIndex);
		}
		if (instance.state != previous.state)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.isRetiring);
		if (instance.transferredIds != null)
		{
			for (int j = 0; j < instance.transferredIds.Count; j++)
			{
				NetworkableId networkableId = instance.transferredIds[j];
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
		if (instance.nextScheduleIndex != previous.nextScheduleIndex)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.nextScheduleIndex);
		}
	}

	public static void Serialize(BufferStream stream, NexusFerry instance)
	{
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
		if (instance.ownerZone != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.ownerZone);
		}
		if (instance.schedule != null)
		{
			for (int i = 0; i < instance.schedule.Count; i++)
			{
				string val = instance.schedule[i];
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, val);
			}
		}
		if (instance.scheduleIndex != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.scheduleIndex);
		}
		if (instance.state != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		if (instance.isRetiring)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.isRetiring);
		}
		if (instance.transferredIds != null)
		{
			for (int j = 0; j < instance.transferredIds.Count; j++)
			{
				NetworkableId networkableId = instance.transferredIds[j];
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
		if (instance.nextScheduleIndex != 0)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.nextScheduleIndex);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		for (int i = 0; i < transferredIds.Count; i++)
		{
			NetworkableId value = transferredIds[i];
			action(UidType.NetworkableId, ref value.Value);
			transferredIds[i] = value;
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class NexusIsland : IDisposable, IPooled, IProto<NexusIsland>, IProto
{
	[NonSerialized]
	public string zoneKey;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(NexusIsland instance)
	{
		if (instance.ShouldPool)
		{
			instance.zoneKey = string.Empty;
			Pool.Free<NexusIsland>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose NexusIsland with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(NexusIsland instance)
	{
		instance.zoneKey = zoneKey;
	}

	public NexusIsland Copy()
	{
		NexusIsland nexusIsland = Pool.Get<NexusIsland>();
		CopyTo(nexusIsland);
		return nexusIsland;
	}

	public static NexusIsland Deserialize(BufferStream stream)
	{
		NexusIsland nexusIsland = Pool.Get<NexusIsland>();
		Deserialize(stream, nexusIsland, isDelta: false);
		return nexusIsland;
	}

	public static NexusIsland DeserializeLengthDelimited(BufferStream stream)
	{
		NexusIsland nexusIsland = Pool.Get<NexusIsland>();
		DeserializeLengthDelimited(stream, nexusIsland, isDelta: false);
		return nexusIsland;
	}

	public static NexusIsland DeserializeLength(BufferStream stream, int length)
	{
		NexusIsland nexusIsland = Pool.Get<NexusIsland>();
		DeserializeLength(stream, length, nexusIsland, isDelta: false);
		return nexusIsland;
	}

	public static NexusIsland Deserialize(byte[] buffer)
	{
		NexusIsland nexusIsland = Pool.Get<NexusIsland>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, nexusIsland, isDelta: false);
		return nexusIsland;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, NexusIsland previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static NexusIsland Deserialize(BufferStream stream, NexusIsland instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.zoneKey = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static NexusIsland DeserializeLengthDelimited(BufferStream stream, NexusIsland instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.zoneKey = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static NexusIsland DeserializeLength(BufferStream stream, int length, NexusIsland instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.zoneKey = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, NexusIsland instance, NexusIsland previous)
	{
		if (instance.zoneKey != null && instance.zoneKey != previous.zoneKey)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.zoneKey);
		}
	}

	public static void Serialize(BufferStream stream, NexusIsland instance)
	{
		if (instance.zoneKey != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.zoneKey);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class NPCMovementState : IDisposable, IPooled, IProto<NPCMovementState>, IProto
{
	[NonSerialized]
	public Vector3 overrideDirection;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(NPCMovementState instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.overrideDirection = default(Vector3);
			Pool.Free<NPCMovementState>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose NPCMovementState with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(NPCMovementState instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		instance.overrideDirection = overrideDirection;
	}

	public NPCMovementState Copy()
	{
		NPCMovementState nPCMovementState = Pool.Get<NPCMovementState>();
		CopyTo(nPCMovementState);
		return nPCMovementState;
	}

	public static NPCMovementState Deserialize(BufferStream stream)
	{
		NPCMovementState nPCMovementState = Pool.Get<NPCMovementState>();
		Deserialize(stream, nPCMovementState, isDelta: false);
		return nPCMovementState;
	}

	public static NPCMovementState DeserializeLengthDelimited(BufferStream stream)
	{
		NPCMovementState nPCMovementState = Pool.Get<NPCMovementState>();
		DeserializeLengthDelimited(stream, nPCMovementState, isDelta: false);
		return nPCMovementState;
	}

	public static NPCMovementState DeserializeLength(BufferStream stream, int length)
	{
		NPCMovementState nPCMovementState = Pool.Get<NPCMovementState>();
		DeserializeLength(stream, length, nPCMovementState, isDelta: false);
		return nPCMovementState;
	}

	public static NPCMovementState Deserialize(byte[] buffer)
	{
		NPCMovementState nPCMovementState = Pool.Get<NPCMovementState>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, nPCMovementState, isDelta: false);
		return nPCMovementState;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, NPCMovementState previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static NPCMovementState Deserialize(BufferStream stream, NPCMovementState instance, bool isDelta)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.overrideDirection, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static NPCMovementState DeserializeLengthDelimited(BufferStream stream, NPCMovementState instance, bool isDelta)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.overrideDirection, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static NPCMovementState DeserializeLength(BufferStream stream, int length, NPCMovementState instance, bool isDelta)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.overrideDirection, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, NPCMovementState instance, NPCMovementState previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.overrideDirection != previous.overrideDirection)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.overrideDirection, previous.overrideDirection);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field overrideDirection (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, NPCMovementState instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.overrideDirection != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.overrideDirection);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field overrideDirection (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class NPCTargetState : IDisposable, IPooled, IProto<NPCTargetState>, IProto
{
	[NonSerialized]
	public NetworkableId targetId;

	[NonSerialized]
	public Vector3 targetLkp;

	[NonSerialized]
	public bool targetIsVisible;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(NPCTargetState instance)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.targetId = default(NetworkableId);
			instance.targetLkp = default(Vector3);
			instance.targetIsVisible = false;
			Pool.Free<NPCTargetState>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose NPCTargetState with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(NPCTargetState instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.targetId = targetId;
		instance.targetLkp = targetLkp;
		instance.targetIsVisible = targetIsVisible;
	}

	public NPCTargetState Copy()
	{
		NPCTargetState nPCTargetState = Pool.Get<NPCTargetState>();
		CopyTo(nPCTargetState);
		return nPCTargetState;
	}

	public static NPCTargetState Deserialize(BufferStream stream)
	{
		NPCTargetState nPCTargetState = Pool.Get<NPCTargetState>();
		Deserialize(stream, nPCTargetState, isDelta: false);
		return nPCTargetState;
	}

	public static NPCTargetState DeserializeLengthDelimited(BufferStream stream)
	{
		NPCTargetState nPCTargetState = Pool.Get<NPCTargetState>();
		DeserializeLengthDelimited(stream, nPCTargetState, isDelta: false);
		return nPCTargetState;
	}

	public static NPCTargetState DeserializeLength(BufferStream stream, int length)
	{
		NPCTargetState nPCTargetState = Pool.Get<NPCTargetState>();
		DeserializeLength(stream, length, nPCTargetState, isDelta: false);
		return nPCTargetState;
	}

	public static NPCTargetState Deserialize(byte[] buffer)
	{
		NPCTargetState nPCTargetState = Pool.Get<NPCTargetState>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, nPCTargetState, isDelta: false);
		return nPCTargetState;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, NPCTargetState previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static NPCTargetState Deserialize(BufferStream stream, NPCTargetState instance, bool isDelta)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.targetId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.targetLkp, isDelta);
				continue;
			case 24:
				instance.targetIsVisible = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static NPCTargetState DeserializeLengthDelimited(BufferStream stream, NPCTargetState instance, bool isDelta)
	{
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.targetLkp, isDelta);
				continue;
			case 24:
				instance.targetIsVisible = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static NPCTargetState DeserializeLength(BufferStream stream, int length, NPCTargetState instance, bool isDelta)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.targetLkp, isDelta);
				continue;
			case 24:
				instance.targetIsVisible = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, NPCTargetState instance, NPCTargetState previous)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.targetId.Value);
		if (instance.targetLkp != previous.targetLkp)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.targetLkp, previous.targetLkp);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetLkp (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.targetIsVisible);
	}

	public static void Serialize(BufferStream stream, NPCTargetState instance)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		if (instance.targetId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.targetId.Value);
		}
		if (instance.targetLkp != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.targetLkp);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetLkp (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.targetIsVisible)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.targetIsVisible);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref targetId.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class NPCVendingMachine : IDisposable, IPooled, IProto<NPCVendingMachine>, IProto
{
	[NonSerialized]
	public NetworkableId attachedNpc;

	[NonSerialized]
	public float nextRefresh;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(NPCVendingMachine instance)
	{
		if (instance.ShouldPool)
		{
			instance.attachedNpc = default(NetworkableId);
			instance.nextRefresh = 0f;
			Pool.Free<NPCVendingMachine>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose NPCVendingMachine with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(NPCVendingMachine instance)
	{
		instance.attachedNpc = attachedNpc;
		instance.nextRefresh = nextRefresh;
	}

	public NPCVendingMachine Copy()
	{
		NPCVendingMachine nPCVendingMachine = Pool.Get<NPCVendingMachine>();
		CopyTo(nPCVendingMachine);
		return nPCVendingMachine;
	}

	public static NPCVendingMachine Deserialize(BufferStream stream)
	{
		NPCVendingMachine nPCVendingMachine = Pool.Get<NPCVendingMachine>();
		Deserialize(stream, nPCVendingMachine, isDelta: false);
		return nPCVendingMachine;
	}

	public static NPCVendingMachine DeserializeLengthDelimited(BufferStream stream)
	{
		NPCVendingMachine nPCVendingMachine = Pool.Get<NPCVendingMachine>();
		DeserializeLengthDelimited(stream, nPCVendingMachine, isDelta: false);
		return nPCVendingMachine;
	}

	public static NPCVendingMachine DeserializeLength(BufferStream stream, int length)
	{
		NPCVendingMachine nPCVendingMachine = Pool.Get<NPCVendingMachine>();
		DeserializeLength(stream, length, nPCVendingMachine, isDelta: false);
		return nPCVendingMachine;
	}

	public static NPCVendingMachine Deserialize(byte[] buffer)
	{
		NPCVendingMachine nPCVendingMachine = Pool.Get<NPCVendingMachine>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, nPCVendingMachine, isDelta: false);
		return nPCVendingMachine;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, NPCVendingMachine previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static NPCVendingMachine Deserialize(BufferStream stream, NPCVendingMachine instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.attachedNpc = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.nextRefresh = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static NPCVendingMachine DeserializeLengthDelimited(BufferStream stream, NPCVendingMachine instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.attachedNpc = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.nextRefresh = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static NPCVendingMachine DeserializeLength(BufferStream stream, int length, NPCVendingMachine instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.attachedNpc = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.nextRefresh = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, NPCVendingMachine instance, NPCVendingMachine previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.attachedNpc.Value);
		if (instance.nextRefresh != previous.nextRefresh)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.nextRefresh);
		}
	}

	public static void Serialize(BufferStream stream, NPCVendingMachine instance)
	{
		if (instance.attachedNpc != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.attachedNpc.Value);
		}
		if (instance.nextRefresh != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.nextRefresh);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref attachedNpc.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class ObjectiveStatus : IDisposable, IPooled, IProto<ObjectiveStatus>, IProto
{
	[NonSerialized]
	public bool started;

	[NonSerialized]
	public bool completed;

	[NonSerialized]
	public bool failed;

	[NonSerialized]
	public float progressCurrent;

	[NonSerialized]
	public float progressTarget;

	[NonSerialized]
	public Vector3 worldLocation;

	[NonSerialized]
	public bool softCompleted;

	[NonSerialized]
	public bool blockReset;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ObjectiveStatus instance)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.started = false;
			instance.completed = false;
			instance.failed = false;
			instance.progressCurrent = 0f;
			instance.progressTarget = 0f;
			instance.worldLocation = default(Vector3);
			instance.softCompleted = false;
			instance.blockReset = false;
			Pool.Free<ObjectiveStatus>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ObjectiveStatus with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ObjectiveStatus instance)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		instance.started = started;
		instance.completed = completed;
		instance.failed = failed;
		instance.progressCurrent = progressCurrent;
		instance.progressTarget = progressTarget;
		instance.worldLocation = worldLocation;
		instance.softCompleted = softCompleted;
		instance.blockReset = blockReset;
	}

	public ObjectiveStatus Copy()
	{
		ObjectiveStatus objectiveStatus = Pool.Get<ObjectiveStatus>();
		CopyTo(objectiveStatus);
		return objectiveStatus;
	}

	public static ObjectiveStatus Deserialize(BufferStream stream)
	{
		ObjectiveStatus objectiveStatus = Pool.Get<ObjectiveStatus>();
		Deserialize(stream, objectiveStatus, isDelta: false);
		return objectiveStatus;
	}

	public static ObjectiveStatus DeserializeLengthDelimited(BufferStream stream)
	{
		ObjectiveStatus objectiveStatus = Pool.Get<ObjectiveStatus>();
		DeserializeLengthDelimited(stream, objectiveStatus, isDelta: false);
		return objectiveStatus;
	}

	public static ObjectiveStatus DeserializeLength(BufferStream stream, int length)
	{
		ObjectiveStatus objectiveStatus = Pool.Get<ObjectiveStatus>();
		DeserializeLength(stream, length, objectiveStatus, isDelta: false);
		return objectiveStatus;
	}

	public static ObjectiveStatus Deserialize(byte[] buffer)
	{
		ObjectiveStatus objectiveStatus = Pool.Get<ObjectiveStatus>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, objectiveStatus, isDelta: false);
		return objectiveStatus;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ObjectiveStatus previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ObjectiveStatus Deserialize(BufferStream stream, ObjectiveStatus instance, bool isDelta)
	{
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.started = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.completed = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.failed = ProtocolParser.ReadBool(stream);
				continue;
			case 37:
				instance.progressCurrent = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.progressTarget = ProtocolParser.ReadSingle(stream);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldLocation, isDelta);
				continue;
			case 56:
				instance.softCompleted = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.blockReset = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ObjectiveStatus DeserializeLengthDelimited(BufferStream stream, ObjectiveStatus instance, bool isDelta)
	{
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.started = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.completed = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.failed = ProtocolParser.ReadBool(stream);
				continue;
			case 37:
				instance.progressCurrent = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.progressTarget = ProtocolParser.ReadSingle(stream);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldLocation, isDelta);
				continue;
			case 56:
				instance.softCompleted = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.blockReset = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ObjectiveStatus DeserializeLength(BufferStream stream, int length, ObjectiveStatus instance, bool isDelta)
	{
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.started = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.completed = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.failed = ProtocolParser.ReadBool(stream);
				continue;
			case 37:
				instance.progressCurrent = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.progressTarget = ProtocolParser.ReadSingle(stream);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldLocation, isDelta);
				continue;
			case 56:
				instance.softCompleted = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.blockReset = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ObjectiveStatus instance, ObjectiveStatus previous)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.started);
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.completed);
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.failed);
		if (instance.progressCurrent != previous.progressCurrent)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.progressCurrent);
		}
		if (instance.progressTarget != previous.progressTarget)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.progressTarget);
		}
		if (instance.worldLocation != previous.worldLocation)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.worldLocation, previous.worldLocation);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldLocation (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.softCompleted);
		stream.WriteByte(64);
		ProtocolParser.WriteBool(stream, instance.blockReset);
	}

	public static void Serialize(BufferStream stream, ObjectiveStatus instance)
	{
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		if (instance.started)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.started);
		}
		if (instance.completed)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.completed);
		}
		if (instance.failed)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.failed);
		}
		if (instance.progressCurrent != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.progressCurrent);
		}
		if (instance.progressTarget != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.progressTarget);
		}
		if (instance.worldLocation != default(Vector3))
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.worldLocation);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldLocation (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.softCompleted)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.softCompleted);
		}
		if (instance.blockReset)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteBool(stream, instance.blockReset);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class OceanPaths : IDisposable, IPooled, IProto<OceanPaths>, IProto
{
	[NonSerialized]
	public List<Vector3> cargoPatrolPath;

	[NonSerialized]
	public List<VectorList> harborApproaches;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(OceanPaths instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.cargoPatrolPath != null)
		{
			List<Vector3> list = instance.cargoPatrolPath;
			Pool.FreeUnmanaged<Vector3>(ref list);
			instance.cargoPatrolPath = list;
		}
		if (instance.harborApproaches != null)
		{
			for (int i = 0; i < instance.harborApproaches.Count; i++)
			{
				if (instance.harborApproaches[i] != null)
				{
					instance.harborApproaches[i].ResetToPool();
					instance.harborApproaches[i] = null;
				}
			}
			List<VectorList> list2 = instance.harborApproaches;
			Pool.Free<VectorList>(ref list2, false);
			instance.harborApproaches = list2;
		}
		Pool.Free<OceanPaths>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose OceanPaths with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(OceanPaths instance)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (cargoPatrolPath != null)
		{
			instance.cargoPatrolPath = Pool.Get<List<Vector3>>();
			for (int i = 0; i < cargoPatrolPath.Count; i++)
			{
				Vector3 item = cargoPatrolPath[i];
				instance.cargoPatrolPath.Add(item);
			}
		}
		else
		{
			instance.cargoPatrolPath = null;
		}
		if (harborApproaches != null)
		{
			instance.harborApproaches = Pool.Get<List<VectorList>>();
			for (int j = 0; j < harborApproaches.Count; j++)
			{
				VectorList item2 = harborApproaches[j].Copy();
				instance.harborApproaches.Add(item2);
			}
		}
		else
		{
			instance.harborApproaches = null;
		}
	}

	public OceanPaths Copy()
	{
		OceanPaths oceanPaths = Pool.Get<OceanPaths>();
		CopyTo(oceanPaths);
		return oceanPaths;
	}

	public static OceanPaths Deserialize(BufferStream stream)
	{
		OceanPaths oceanPaths = Pool.Get<OceanPaths>();
		Deserialize(stream, oceanPaths, isDelta: false);
		return oceanPaths;
	}

	public static OceanPaths DeserializeLengthDelimited(BufferStream stream)
	{
		OceanPaths oceanPaths = Pool.Get<OceanPaths>();
		DeserializeLengthDelimited(stream, oceanPaths, isDelta: false);
		return oceanPaths;
	}

	public static OceanPaths DeserializeLength(BufferStream stream, int length)
	{
		OceanPaths oceanPaths = Pool.Get<OceanPaths>();
		DeserializeLength(stream, length, oceanPaths, isDelta: false);
		return oceanPaths;
	}

	public static OceanPaths Deserialize(byte[] buffer)
	{
		OceanPaths oceanPaths = Pool.Get<OceanPaths>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, oceanPaths, isDelta: false);
		return oceanPaths;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, OceanPaths previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static OceanPaths Deserialize(BufferStream stream, OceanPaths instance, bool isDelta)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.cargoPatrolPath == null)
			{
				instance.cargoPatrolPath = Pool.Get<List<Vector3>>();
			}
			if (instance.harborApproaches == null)
			{
				instance.harborApproaches = Pool.Get<List<VectorList>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.cargoPatrolPath.Add(instance2);
				break;
			}
			case 18:
				instance.harborApproaches.Add(VectorList.DeserializeLengthDelimited(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static OceanPaths DeserializeLengthDelimited(BufferStream stream, OceanPaths instance, bool isDelta)
	{
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.cargoPatrolPath == null)
			{
				instance.cargoPatrolPath = Pool.Get<List<Vector3>>();
			}
			if (instance.harborApproaches == null)
			{
				instance.harborApproaches = Pool.Get<List<VectorList>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.cargoPatrolPath.Add(instance2);
				break;
			}
			case 18:
				instance.harborApproaches.Add(VectorList.DeserializeLengthDelimited(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static OceanPaths DeserializeLength(BufferStream stream, int length, OceanPaths instance, bool isDelta)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.cargoPatrolPath == null)
			{
				instance.cargoPatrolPath = Pool.Get<List<Vector3>>();
			}
			if (instance.harborApproaches == null)
			{
				instance.harborApproaches = Pool.Get<List<VectorList>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.cargoPatrolPath.Add(instance2);
				break;
			}
			case 18:
				instance.harborApproaches.Add(VectorList.DeserializeLengthDelimited(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, OceanPaths instance, OceanPaths previous)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.cargoPatrolPath != null)
		{
			for (int i = 0; i < instance.cargoPatrolPath.Count; i++)
			{
				Vector3 val = instance.cargoPatrolPath[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.SerializeDelta(stream, val, val);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cargoPatrolPath (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.harborApproaches == null)
		{
			return;
		}
		for (int j = 0; j < instance.harborApproaches.Count; j++)
		{
			VectorList vectorList = instance.harborApproaches[j];
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(3);
			int position2 = stream.Position;
			VectorList.SerializeDelta(stream, vectorList, vectorList);
			int num2 = stream.Position - position2;
			if (num2 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field harborApproaches (ProtoBuf.VectorList)");
			}
			Span<byte> span2 = range2.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			if (num3 < 3)
			{
				span2[num3 - 1] |= 128;
				while (num3 < 2)
				{
					span2[num3++] = 128;
				}
				span2[2] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, OceanPaths instance)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if (instance.cargoPatrolPath != null)
		{
			for (int i = 0; i < instance.cargoPatrolPath.Count; i++)
			{
				Vector3 instance2 = instance.cargoPatrolPath[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field cargoPatrolPath (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.harborApproaches == null)
		{
			return;
		}
		for (int j = 0; j < instance.harborApproaches.Count; j++)
		{
			VectorList instance3 = instance.harborApproaches[j];
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(3);
			int position2 = stream.Position;
			VectorList.Serialize(stream, instance3);
			int num2 = stream.Position - position2;
			if (num2 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field harborApproaches (ProtoBuf.VectorList)");
			}
			Span<byte> span2 = range2.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			if (num3 < 3)
			{
				span2[num3 - 1] |= 128;
				while (num3 < 2)
				{
					span2[num3++] = 128;
				}
				span2[2] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (harborApproaches != null)
		{
			for (int i = 0; i < harborApproaches.Count; i++)
			{
				harborApproaches[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class OwnerInfo : IDisposable, IPooled, IProto<OwnerInfo>, IProto
{
	[NonSerialized]
	public ulong steamid;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(OwnerInfo instance)
	{
		if (instance.ShouldPool)
		{
			instance.steamid = 0uL;
			Pool.Free<OwnerInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose OwnerInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(OwnerInfo instance)
	{
		instance.steamid = steamid;
	}

	public OwnerInfo Copy()
	{
		OwnerInfo ownerInfo = Pool.Get<OwnerInfo>();
		CopyTo(ownerInfo);
		return ownerInfo;
	}

	public static OwnerInfo Deserialize(BufferStream stream)
	{
		OwnerInfo ownerInfo = Pool.Get<OwnerInfo>();
		Deserialize(stream, ownerInfo, isDelta: false);
		return ownerInfo;
	}

	public static OwnerInfo DeserializeLengthDelimited(BufferStream stream)
	{
		OwnerInfo ownerInfo = Pool.Get<OwnerInfo>();
		DeserializeLengthDelimited(stream, ownerInfo, isDelta: false);
		return ownerInfo;
	}

	public static OwnerInfo DeserializeLength(BufferStream stream, int length)
	{
		OwnerInfo ownerInfo = Pool.Get<OwnerInfo>();
		DeserializeLength(stream, length, ownerInfo, isDelta: false);
		return ownerInfo;
	}

	public static OwnerInfo Deserialize(byte[] buffer)
	{
		OwnerInfo ownerInfo = Pool.Get<OwnerInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ownerInfo, isDelta: false);
		return ownerInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, OwnerInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static OwnerInfo Deserialize(BufferStream stream, OwnerInfo instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.steamid = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static OwnerInfo DeserializeLengthDelimited(BufferStream stream, OwnerInfo instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamid = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static OwnerInfo DeserializeLength(BufferStream stream, int length, OwnerInfo instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamid = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, OwnerInfo instance, OwnerInfo previous)
	{
		if (instance.steamid != previous.steamid)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamid);
		}
	}

	public static void Serialize(BufferStream stream, OwnerInfo instance)
	{
		if (instance.steamid != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamid);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PaintableSign : IDisposable, IPooled, IProto<PaintableSign>, IProto
{
	[NonSerialized]
	public List<uint> crcs;

	[NonSerialized]
	public List<ulong> editHistory;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PaintableSign instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.crcs != null)
			{
				List<uint> list = instance.crcs;
				Pool.FreeUnmanaged<uint>(ref list);
				instance.crcs = list;
			}
			if (instance.editHistory != null)
			{
				List<ulong> list2 = instance.editHistory;
				Pool.FreeUnmanaged<ulong>(ref list2);
				instance.editHistory = list2;
			}
			Pool.Free<PaintableSign>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PaintableSign with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PaintableSign instance)
	{
		if (crcs != null)
		{
			instance.crcs = Pool.Get<List<uint>>();
			for (int i = 0; i < crcs.Count; i++)
			{
				uint item = crcs[i];
				instance.crcs.Add(item);
			}
		}
		else
		{
			instance.crcs = null;
		}
		if (editHistory != null)
		{
			instance.editHistory = Pool.Get<List<ulong>>();
			for (int j = 0; j < editHistory.Count; j++)
			{
				ulong item2 = editHistory[j];
				instance.editHistory.Add(item2);
			}
		}
		else
		{
			instance.editHistory = null;
		}
	}

	public PaintableSign Copy()
	{
		PaintableSign paintableSign = Pool.Get<PaintableSign>();
		CopyTo(paintableSign);
		return paintableSign;
	}

	public static PaintableSign Deserialize(BufferStream stream)
	{
		PaintableSign paintableSign = Pool.Get<PaintableSign>();
		Deserialize(stream, paintableSign, isDelta: false);
		return paintableSign;
	}

	public static PaintableSign DeserializeLengthDelimited(BufferStream stream)
	{
		PaintableSign paintableSign = Pool.Get<PaintableSign>();
		DeserializeLengthDelimited(stream, paintableSign, isDelta: false);
		return paintableSign;
	}

	public static PaintableSign DeserializeLength(BufferStream stream, int length)
	{
		PaintableSign paintableSign = Pool.Get<PaintableSign>();
		DeserializeLength(stream, length, paintableSign, isDelta: false);
		return paintableSign;
	}

	public static PaintableSign Deserialize(byte[] buffer)
	{
		PaintableSign paintableSign = Pool.Get<PaintableSign>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, paintableSign, isDelta: false);
		return paintableSign;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PaintableSign previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PaintableSign Deserialize(BufferStream stream, PaintableSign instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.crcs == null)
			{
				instance.crcs = Pool.Get<List<uint>>();
			}
			if (instance.editHistory == null)
			{
				instance.editHistory = Pool.Get<List<ulong>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.crcs.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 16:
				instance.editHistory.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PaintableSign DeserializeLengthDelimited(BufferStream stream, PaintableSign instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.crcs == null)
			{
				instance.crcs = Pool.Get<List<uint>>();
			}
			if (instance.editHistory == null)
			{
				instance.editHistory = Pool.Get<List<ulong>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.crcs.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 16:
				instance.editHistory.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PaintableSign DeserializeLength(BufferStream stream, int length, PaintableSign instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.crcs == null)
			{
				instance.crcs = Pool.Get<List<uint>>();
			}
			if (instance.editHistory == null)
			{
				instance.editHistory = Pool.Get<List<ulong>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.crcs.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 16:
				instance.editHistory.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PaintableSign instance, PaintableSign previous)
	{
		if (instance.crcs != null)
		{
			for (int i = 0; i < instance.crcs.Count; i++)
			{
				uint val = instance.crcs[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt32(stream, val);
			}
		}
		if (instance.editHistory != null)
		{
			for (int j = 0; j < instance.editHistory.Count; j++)
			{
				ulong val2 = instance.editHistory[j];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, val2);
			}
		}
	}

	public static void Serialize(BufferStream stream, PaintableSign instance)
	{
		if (instance.crcs != null)
		{
			for (int i = 0; i < instance.crcs.Count; i++)
			{
				uint val = instance.crcs[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt32(stream, val);
			}
		}
		if (instance.editHistory != null)
		{
			for (int j = 0; j < instance.editHistory.Count; j++)
			{
				ulong val2 = instance.editHistory[j];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, val2);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PaintedItem : IDisposable, IPooled, IProto<PaintedItem>, IProto
{
	[NonSerialized]
	public uint imageCrc;

	[NonSerialized]
	public ulong editedBy;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PaintedItem instance)
	{
		if (instance.ShouldPool)
		{
			instance.imageCrc = 0u;
			instance.editedBy = 0uL;
			Pool.Free<PaintedItem>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PaintedItem with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PaintedItem instance)
	{
		instance.imageCrc = imageCrc;
		instance.editedBy = editedBy;
	}

	public PaintedItem Copy()
	{
		PaintedItem paintedItem = Pool.Get<PaintedItem>();
		CopyTo(paintedItem);
		return paintedItem;
	}

	public static PaintedItem Deserialize(BufferStream stream)
	{
		PaintedItem paintedItem = Pool.Get<PaintedItem>();
		Deserialize(stream, paintedItem, isDelta: false);
		return paintedItem;
	}

	public static PaintedItem DeserializeLengthDelimited(BufferStream stream)
	{
		PaintedItem paintedItem = Pool.Get<PaintedItem>();
		DeserializeLengthDelimited(stream, paintedItem, isDelta: false);
		return paintedItem;
	}

	public static PaintedItem DeserializeLength(BufferStream stream, int length)
	{
		PaintedItem paintedItem = Pool.Get<PaintedItem>();
		DeserializeLength(stream, length, paintedItem, isDelta: false);
		return paintedItem;
	}

	public static PaintedItem Deserialize(byte[] buffer)
	{
		PaintedItem paintedItem = Pool.Get<PaintedItem>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, paintedItem, isDelta: false);
		return paintedItem;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PaintedItem previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PaintedItem Deserialize(BufferStream stream, PaintedItem instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.imageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.editedBy = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PaintedItem DeserializeLengthDelimited(BufferStream stream, PaintedItem instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.imageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.editedBy = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PaintedItem DeserializeLength(BufferStream stream, int length, PaintedItem instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.imageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.editedBy = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PaintedItem instance, PaintedItem previous)
	{
		if (instance.imageCrc != previous.imageCrc)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.imageCrc);
		}
		if (instance.editedBy != previous.editedBy)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.editedBy);
		}
	}

	public static void Serialize(BufferStream stream, PaintedItem instance)
	{
		if (instance.imageCrc != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.imageCrc);
		}
		if (instance.editedBy != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.editedBy);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ParentInfo : IDisposable, IPooled, IProto<ParentInfo>, IProto
{
	[NonSerialized]
	public NetworkableId uid;

	[NonSerialized]
	public uint bone;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ParentInfo instance)
	{
		if (instance.ShouldPool)
		{
			instance.uid = default(NetworkableId);
			instance.bone = 0u;
			Pool.Free<ParentInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ParentInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ParentInfo instance)
	{
		instance.uid = uid;
		instance.bone = bone;
	}

	public ParentInfo Copy()
	{
		ParentInfo parentInfo = Pool.Get<ParentInfo>();
		CopyTo(parentInfo);
		return parentInfo;
	}

	public static ParentInfo Deserialize(BufferStream stream)
	{
		ParentInfo parentInfo = Pool.Get<ParentInfo>();
		Deserialize(stream, parentInfo, isDelta: false);
		return parentInfo;
	}

	public static ParentInfo DeserializeLengthDelimited(BufferStream stream)
	{
		ParentInfo parentInfo = Pool.Get<ParentInfo>();
		DeserializeLengthDelimited(stream, parentInfo, isDelta: false);
		return parentInfo;
	}

	public static ParentInfo DeserializeLength(BufferStream stream, int length)
	{
		ParentInfo parentInfo = Pool.Get<ParentInfo>();
		DeserializeLength(stream, length, parentInfo, isDelta: false);
		return parentInfo;
	}

	public static ParentInfo Deserialize(byte[] buffer)
	{
		ParentInfo parentInfo = Pool.Get<ParentInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, parentInfo, isDelta: false);
		return parentInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ParentInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ParentInfo Deserialize(BufferStream stream, ParentInfo instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.uid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.bone = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ParentInfo DeserializeLengthDelimited(BufferStream stream, ParentInfo instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.uid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.bone = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ParentInfo DeserializeLength(BufferStream stream, int length, ParentInfo instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.uid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.bone = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ParentInfo instance, ParentInfo previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.uid.Value);
		if (instance.bone != previous.bone)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.bone);
		}
	}

	public static void Serialize(BufferStream stream, ParentInfo instance)
	{
		if (instance.uid != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.uid.Value);
		}
		if (instance.bone != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.bone);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref uid.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PartyData : IDisposable, IPooled, IProto<PartyData>, IProto
{
	[NonSerialized]
	public ulong lobbyId;

	[NonSerialized]
	public List<PartyMemberData> members;

	[NonSerialized]
	public string joinKey;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PartyData instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.lobbyId = 0uL;
		if (instance.members != null)
		{
			for (int i = 0; i < instance.members.Count; i++)
			{
				if (instance.members[i] != null)
				{
					instance.members[i].ResetToPool();
					instance.members[i] = null;
				}
			}
			List<PartyMemberData> list = instance.members;
			Pool.Free<PartyMemberData>(ref list, false);
			instance.members = list;
		}
		instance.joinKey = string.Empty;
		Pool.Free<PartyData>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PartyData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PartyData instance)
	{
		instance.lobbyId = lobbyId;
		if (members != null)
		{
			instance.members = Pool.Get<List<PartyMemberData>>();
			for (int i = 0; i < members.Count; i++)
			{
				PartyMemberData item = members[i].Copy();
				instance.members.Add(item);
			}
		}
		else
		{
			instance.members = null;
		}
		instance.joinKey = joinKey;
	}

	public PartyData Copy()
	{
		PartyData partyData = Pool.Get<PartyData>();
		CopyTo(partyData);
		return partyData;
	}

	public static PartyData Deserialize(BufferStream stream)
	{
		PartyData partyData = Pool.Get<PartyData>();
		Deserialize(stream, partyData, isDelta: false);
		return partyData;
	}

	public static PartyData DeserializeLengthDelimited(BufferStream stream)
	{
		PartyData partyData = Pool.Get<PartyData>();
		DeserializeLengthDelimited(stream, partyData, isDelta: false);
		return partyData;
	}

	public static PartyData DeserializeLength(BufferStream stream, int length)
	{
		PartyData partyData = Pool.Get<PartyData>();
		DeserializeLength(stream, length, partyData, isDelta: false);
		return partyData;
	}

	public static PartyData Deserialize(byte[] buffer)
	{
		PartyData partyData = Pool.Get<PartyData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, partyData, isDelta: false);
		return partyData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PartyData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PartyData Deserialize(BufferStream stream, PartyData instance, bool isDelta)
	{
		if (!isDelta && instance.members == null)
		{
			instance.members = Pool.Get<List<PartyMemberData>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.lobbyId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.members.Add(PartyMemberData.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.joinKey = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PartyData DeserializeLengthDelimited(BufferStream stream, PartyData instance, bool isDelta)
	{
		if (!isDelta && instance.members == null)
		{
			instance.members = Pool.Get<List<PartyMemberData>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.lobbyId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.members.Add(PartyMemberData.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.joinKey = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PartyData DeserializeLength(BufferStream stream, int length, PartyData instance, bool isDelta)
	{
		if (!isDelta && instance.members == null)
		{
			instance.members = Pool.Get<List<PartyMemberData>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.lobbyId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.members.Add(PartyMemberData.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.joinKey = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PartyData instance, PartyData previous)
	{
		if (instance.lobbyId != previous.lobbyId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.lobbyId);
		}
		if (instance.members != null)
		{
			for (int i = 0; i < instance.members.Count; i++)
			{
				PartyMemberData partyMemberData = instance.members[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PartyMemberData.SerializeDelta(stream, partyMemberData, partyMemberData);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.joinKey != previous.joinKey)
		{
			if (instance.joinKey == null)
			{
				throw new ArgumentNullException("joinKey", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.joinKey);
		}
	}

	public static void Serialize(BufferStream stream, PartyData instance)
	{
		if (instance.lobbyId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.lobbyId);
		}
		if (instance.members != null)
		{
			for (int i = 0; i < instance.members.Count; i++)
			{
				PartyMemberData instance2 = instance.members[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PartyMemberData.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.joinKey == null)
		{
			throw new ArgumentNullException("joinKey", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.joinKey);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (members != null)
		{
			for (int i = 0; i < members.Count; i++)
			{
				members[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PartyMemberData : IDisposable, IPooled, IProto<PartyMemberData>, IProto
{
	[NonSerialized]
	public ulong steamId;

	[NonSerialized]
	public bool isLeader;

	[NonSerialized]
	public string name;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PartyMemberData instance)
	{
		if (instance.ShouldPool)
		{
			instance.steamId = 0uL;
			instance.isLeader = false;
			instance.name = string.Empty;
			Pool.Free<PartyMemberData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PartyMemberData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PartyMemberData instance)
	{
		instance.steamId = steamId;
		instance.isLeader = isLeader;
		instance.name = name;
	}

	public PartyMemberData Copy()
	{
		PartyMemberData partyMemberData = Pool.Get<PartyMemberData>();
		CopyTo(partyMemberData);
		return partyMemberData;
	}

	public static PartyMemberData Deserialize(BufferStream stream)
	{
		PartyMemberData partyMemberData = Pool.Get<PartyMemberData>();
		Deserialize(stream, partyMemberData, isDelta: false);
		return partyMemberData;
	}

	public static PartyMemberData DeserializeLengthDelimited(BufferStream stream)
	{
		PartyMemberData partyMemberData = Pool.Get<PartyMemberData>();
		DeserializeLengthDelimited(stream, partyMemberData, isDelta: false);
		return partyMemberData;
	}

	public static PartyMemberData DeserializeLength(BufferStream stream, int length)
	{
		PartyMemberData partyMemberData = Pool.Get<PartyMemberData>();
		DeserializeLength(stream, length, partyMemberData, isDelta: false);
		return partyMemberData;
	}

	public static PartyMemberData Deserialize(byte[] buffer)
	{
		PartyMemberData partyMemberData = Pool.Get<PartyMemberData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, partyMemberData, isDelta: false);
		return partyMemberData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PartyMemberData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PartyMemberData Deserialize(BufferStream stream, PartyMemberData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.isLeader = ProtocolParser.ReadBool(stream);
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PartyMemberData DeserializeLengthDelimited(BufferStream stream, PartyMemberData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.isLeader = ProtocolParser.ReadBool(stream);
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PartyMemberData DeserializeLength(BufferStream stream, int length, PartyMemberData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.isLeader = ProtocolParser.ReadBool(stream);
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PartyMemberData instance, PartyMemberData previous)
	{
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.isLeader);
		if (instance.name != null && instance.name != previous.name)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.name);
		}
	}

	public static void Serialize(BufferStream stream, PartyMemberData instance)
	{
		if (instance.steamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.isLeader)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.isLeader);
		}
		if (instance.name != null)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.name);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class PasteRequest : IDisposable, IPooled, IProto<PasteRequest>, IProto
{
	[NonSerialized]
	public CopyPasteEntityInfo pasteData;

	[NonSerialized]
	public Vector3 origin;

	[NonSerialized]
	public Vector3 playerRotation;

	[NonSerialized]
	public Vector3 heightOffset;

	[NonSerialized]
	public bool resources;

	[NonSerialized]
	public bool npcs;

	[NonSerialized]
	public bool vehicles;

	[NonSerialized]
	public bool deployables;

	[NonSerialized]
	public bool foundationsOnly;

	[NonSerialized]
	public bool buildingBlocksOnly;

	[NonSerialized]
	public bool snapToTerrain;

	[NonSerialized]
	public bool players;

	[NonSerialized]
	public bool snapToZero;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PasteRequest instance)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			if (instance.pasteData != null)
			{
				instance.pasteData.ResetToPool();
				instance.pasteData = null;
			}
			instance.origin = default(Vector3);
			instance.playerRotation = default(Vector3);
			instance.heightOffset = default(Vector3);
			instance.resources = false;
			instance.npcs = false;
			instance.vehicles = false;
			instance.deployables = false;
			instance.foundationsOnly = false;
			instance.buildingBlocksOnly = false;
			instance.snapToTerrain = false;
			instance.players = false;
			instance.snapToZero = false;
			Pool.Free<PasteRequest>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PasteRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PasteRequest instance)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		if (pasteData != null)
		{
			if (instance.pasteData == null)
			{
				instance.pasteData = pasteData.Copy();
			}
			else
			{
				pasteData.CopyTo(instance.pasteData);
			}
		}
		else
		{
			instance.pasteData = null;
		}
		instance.origin = origin;
		instance.playerRotation = playerRotation;
		instance.heightOffset = heightOffset;
		instance.resources = resources;
		instance.npcs = npcs;
		instance.vehicles = vehicles;
		instance.deployables = deployables;
		instance.foundationsOnly = foundationsOnly;
		instance.buildingBlocksOnly = buildingBlocksOnly;
		instance.snapToTerrain = snapToTerrain;
		instance.players = players;
		instance.snapToZero = snapToZero;
	}

	public PasteRequest Copy()
	{
		PasteRequest pasteRequest = Pool.Get<PasteRequest>();
		CopyTo(pasteRequest);
		return pasteRequest;
	}

	public static PasteRequest Deserialize(BufferStream stream)
	{
		PasteRequest pasteRequest = Pool.Get<PasteRequest>();
		Deserialize(stream, pasteRequest, isDelta: false);
		return pasteRequest;
	}

	public static PasteRequest DeserializeLengthDelimited(BufferStream stream)
	{
		PasteRequest pasteRequest = Pool.Get<PasteRequest>();
		DeserializeLengthDelimited(stream, pasteRequest, isDelta: false);
		return pasteRequest;
	}

	public static PasteRequest DeserializeLength(BufferStream stream, int length)
	{
		PasteRequest pasteRequest = Pool.Get<PasteRequest>();
		DeserializeLength(stream, length, pasteRequest, isDelta: false);
		return pasteRequest;
	}

	public static PasteRequest Deserialize(byte[] buffer)
	{
		PasteRequest pasteRequest = Pool.Get<PasteRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, pasteRequest, isDelta: false);
		return pasteRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PasteRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PasteRequest Deserialize(BufferStream stream, PasteRequest instance, bool isDelta)
	{
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.pasteData == null)
				{
					instance.pasteData = CopyPasteEntityInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					CopyPasteEntityInfo.DeserializeLengthDelimited(stream, instance.pasteData, isDelta);
				}
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.origin, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.playerRotation, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heightOffset, isDelta);
				continue;
			case 80:
				instance.resources = ProtocolParser.ReadBool(stream);
				continue;
			case 88:
				instance.npcs = ProtocolParser.ReadBool(stream);
				continue;
			case 96:
				instance.vehicles = ProtocolParser.ReadBool(stream);
				continue;
			case 104:
				instance.deployables = ProtocolParser.ReadBool(stream);
				continue;
			case 112:
				instance.foundationsOnly = ProtocolParser.ReadBool(stream);
				continue;
			case 120:
				instance.buildingBlocksOnly = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Varint)
				{
					instance.snapToTerrain = ProtocolParser.ReadBool(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Varint)
				{
					instance.players = ProtocolParser.ReadBool(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.Varint)
				{
					instance.snapToZero = ProtocolParser.ReadBool(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
	}

	public static PasteRequest DeserializeLengthDelimited(BufferStream stream, PasteRequest instance, bool isDelta)
	{
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.pasteData == null)
				{
					instance.pasteData = CopyPasteEntityInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					CopyPasteEntityInfo.DeserializeLengthDelimited(stream, instance.pasteData, isDelta);
				}
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.origin, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.playerRotation, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heightOffset, isDelta);
				continue;
			case 80:
				instance.resources = ProtocolParser.ReadBool(stream);
				continue;
			case 88:
				instance.npcs = ProtocolParser.ReadBool(stream);
				continue;
			case 96:
				instance.vehicles = ProtocolParser.ReadBool(stream);
				continue;
			case 104:
				instance.deployables = ProtocolParser.ReadBool(stream);
				continue;
			case 112:
				instance.foundationsOnly = ProtocolParser.ReadBool(stream);
				continue;
			case 120:
				instance.buildingBlocksOnly = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Varint)
				{
					instance.snapToTerrain = ProtocolParser.ReadBool(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Varint)
				{
					instance.players = ProtocolParser.ReadBool(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.Varint)
				{
					instance.snapToZero = ProtocolParser.ReadBool(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PasteRequest DeserializeLength(BufferStream stream, int length, PasteRequest instance, bool isDelta)
	{
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.pasteData == null)
				{
					instance.pasteData = CopyPasteEntityInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					CopyPasteEntityInfo.DeserializeLengthDelimited(stream, instance.pasteData, isDelta);
				}
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.origin, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.playerRotation, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heightOffset, isDelta);
				continue;
			case 80:
				instance.resources = ProtocolParser.ReadBool(stream);
				continue;
			case 88:
				instance.npcs = ProtocolParser.ReadBool(stream);
				continue;
			case 96:
				instance.vehicles = ProtocolParser.ReadBool(stream);
				continue;
			case 104:
				instance.deployables = ProtocolParser.ReadBool(stream);
				continue;
			case 112:
				instance.foundationsOnly = ProtocolParser.ReadBool(stream);
				continue;
			case 120:
				instance.buildingBlocksOnly = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 16u:
				if (key.WireType == Wire.Varint)
				{
					instance.snapToTerrain = ProtocolParser.ReadBool(stream);
				}
				break;
			case 17u:
				if (key.WireType == Wire.Varint)
				{
					instance.players = ProtocolParser.ReadBool(stream);
				}
				break;
			case 18u:
				if (key.WireType == Wire.Varint)
				{
					instance.snapToZero = ProtocolParser.ReadBool(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PasteRequest instance, PasteRequest previous)
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		if (instance.pasteData != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			CopyPasteEntityInfo.SerializeDelta(stream, instance.pasteData, previous.pasteData);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.origin != previous.origin)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.origin, previous.origin);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field origin (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.playerRotation != previous.playerRotation)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.playerRotation, previous.playerRotation);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerRotation (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.heightOffset != previous.heightOffset)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.heightOffset, previous.heightOffset);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field heightOffset (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		stream.WriteByte(80);
		ProtocolParser.WriteBool(stream, instance.resources);
		stream.WriteByte(88);
		ProtocolParser.WriteBool(stream, instance.npcs);
		stream.WriteByte(96);
		ProtocolParser.WriteBool(stream, instance.vehicles);
		stream.WriteByte(104);
		ProtocolParser.WriteBool(stream, instance.deployables);
		stream.WriteByte(112);
		ProtocolParser.WriteBool(stream, instance.foundationsOnly);
		stream.WriteByte(120);
		ProtocolParser.WriteBool(stream, instance.buildingBlocksOnly);
		stream.WriteByte(128);
		stream.WriteByte(1);
		ProtocolParser.WriteBool(stream, instance.snapToTerrain);
		stream.WriteByte(136);
		stream.WriteByte(1);
		ProtocolParser.WriteBool(stream, instance.players);
		stream.WriteByte(144);
		stream.WriteByte(1);
		ProtocolParser.WriteBool(stream, instance.snapToZero);
	}

	public static void Serialize(BufferStream stream, PasteRequest instance)
	{
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		if (instance.pasteData != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			CopyPasteEntityInfo.Serialize(stream, instance.pasteData);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.origin != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.origin);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field origin (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.playerRotation != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.playerRotation);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerRotation (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.heightOffset != default(Vector3))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.heightOffset);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field heightOffset (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.resources)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteBool(stream, instance.resources);
		}
		if (instance.npcs)
		{
			stream.WriteByte(88);
			ProtocolParser.WriteBool(stream, instance.npcs);
		}
		if (instance.vehicles)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteBool(stream, instance.vehicles);
		}
		if (instance.deployables)
		{
			stream.WriteByte(104);
			ProtocolParser.WriteBool(stream, instance.deployables);
		}
		if (instance.foundationsOnly)
		{
			stream.WriteByte(112);
			ProtocolParser.WriteBool(stream, instance.foundationsOnly);
		}
		if (instance.buildingBlocksOnly)
		{
			stream.WriteByte(120);
			ProtocolParser.WriteBool(stream, instance.buildingBlocksOnly);
		}
		if (instance.snapToTerrain)
		{
			stream.WriteByte(128);
			stream.WriteByte(1);
			ProtocolParser.WriteBool(stream, instance.snapToTerrain);
		}
		if (instance.players)
		{
			stream.WriteByte(136);
			stream.WriteByte(1);
			ProtocolParser.WriteBool(stream, instance.players);
		}
		if (instance.snapToZero)
		{
			stream.WriteByte(144);
			stream.WriteByte(1);
			ProtocolParser.WriteBool(stream, instance.snapToZero);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		pasteData?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PathData : IDisposable, IPooled, IProto<PathData>, IProto
{
	[NonSerialized]
	public string name;

	[NonSerialized]
	public bool spline;

	[NonSerialized]
	public bool start;

	[NonSerialized]
	public bool end;

	[NonSerialized]
	public float width;

	[NonSerialized]
	public float innerPadding;

	[NonSerialized]
	public float outerPadding;

	[NonSerialized]
	public float innerFade;

	[NonSerialized]
	public float outerFade;

	[NonSerialized]
	public float randomScale;

	[NonSerialized]
	public float meshOffset;

	[NonSerialized]
	public float terrainOffset;

	[NonSerialized]
	public int splat;

	[NonSerialized]
	public int topology;

	[NonSerialized]
	public List<VectorData> nodes;

	[NonSerialized]
	public int hierarchy;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PathData instance)
	{
		if (instance.ShouldPool)
		{
			instance.name = string.Empty;
			instance.spline = false;
			instance.start = false;
			instance.end = false;
			instance.width = 0f;
			instance.innerPadding = 0f;
			instance.outerPadding = 0f;
			instance.innerFade = 0f;
			instance.outerFade = 0f;
			instance.randomScale = 0f;
			instance.meshOffset = 0f;
			instance.terrainOffset = 0f;
			instance.splat = 0;
			instance.topology = 0;
			if (instance.nodes != null)
			{
				List<VectorData> list = instance.nodes;
				Pool.FreeUnmanaged<VectorData>(ref list);
				instance.nodes = list;
			}
			instance.hierarchy = 0;
			Pool.Free<PathData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PathData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PathData instance)
	{
		instance.name = name;
		instance.spline = spline;
		instance.start = start;
		instance.end = end;
		instance.width = width;
		instance.innerPadding = innerPadding;
		instance.outerPadding = outerPadding;
		instance.innerFade = innerFade;
		instance.outerFade = outerFade;
		instance.randomScale = randomScale;
		instance.meshOffset = meshOffset;
		instance.terrainOffset = terrainOffset;
		instance.splat = splat;
		instance.topology = topology;
		if (nodes != null)
		{
			instance.nodes = Pool.Get<List<VectorData>>();
			for (int i = 0; i < nodes.Count; i++)
			{
				VectorData item = nodes[i];
				instance.nodes.Add(item);
			}
		}
		else
		{
			instance.nodes = null;
		}
		instance.hierarchy = hierarchy;
	}

	public PathData Copy()
	{
		PathData pathData = Pool.Get<PathData>();
		CopyTo(pathData);
		return pathData;
	}

	public static PathData Deserialize(BufferStream stream)
	{
		PathData pathData = Pool.Get<PathData>();
		Deserialize(stream, pathData, isDelta: false);
		return pathData;
	}

	public static PathData DeserializeLengthDelimited(BufferStream stream)
	{
		PathData pathData = Pool.Get<PathData>();
		DeserializeLengthDelimited(stream, pathData, isDelta: false);
		return pathData;
	}

	public static PathData DeserializeLength(BufferStream stream, int length)
	{
		PathData pathData = Pool.Get<PathData>();
		DeserializeLength(stream, length, pathData, isDelta: false);
		return pathData;
	}

	public static PathData Deserialize(byte[] buffer)
	{
		PathData pathData = Pool.Get<PathData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, pathData, isDelta: false);
		return pathData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PathData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PathData Deserialize(BufferStream stream, PathData instance, bool isDelta)
	{
		if (!isDelta && instance.nodes == null)
		{
			instance.nodes = Pool.Get<List<VectorData>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.spline = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.start = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.end = ProtocolParser.ReadBool(stream);
				continue;
			case 45:
				instance.width = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.innerPadding = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.outerPadding = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.innerFade = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.outerFade = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.randomScale = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.meshOffset = ProtocolParser.ReadSingle(stream);
				continue;
			case 101:
				instance.terrainOffset = ProtocolParser.ReadSingle(stream);
				continue;
			case 104:
				instance.splat = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 112:
				instance.topology = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 122:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.nodes.Add(instance2);
				continue;
			}
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 16)
			{
				if (key.WireType == Wire.Varint)
				{
					instance.hierarchy = (int)ProtocolParser.ReadUInt64(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
	}

	public static PathData DeserializeLengthDelimited(BufferStream stream, PathData instance, bool isDelta)
	{
		if (!isDelta && instance.nodes == null)
		{
			instance.nodes = Pool.Get<List<VectorData>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.spline = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.start = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.end = ProtocolParser.ReadBool(stream);
				continue;
			case 45:
				instance.width = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.innerPadding = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.outerPadding = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.innerFade = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.outerFade = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.randomScale = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.meshOffset = ProtocolParser.ReadSingle(stream);
				continue;
			case 101:
				instance.terrainOffset = ProtocolParser.ReadSingle(stream);
				continue;
			case 104:
				instance.splat = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 112:
				instance.topology = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 122:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.nodes.Add(instance2);
				continue;
			}
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 16)
			{
				if (key.WireType == Wire.Varint)
				{
					instance.hierarchy = (int)ProtocolParser.ReadUInt64(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PathData DeserializeLength(BufferStream stream, int length, PathData instance, bool isDelta)
	{
		if (!isDelta && instance.nodes == null)
		{
			instance.nodes = Pool.Get<List<VectorData>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.spline = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.start = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.end = ProtocolParser.ReadBool(stream);
				continue;
			case 45:
				instance.width = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.innerPadding = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.outerPadding = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.innerFade = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.outerFade = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.randomScale = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.meshOffset = ProtocolParser.ReadSingle(stream);
				continue;
			case 101:
				instance.terrainOffset = ProtocolParser.ReadSingle(stream);
				continue;
			case 104:
				instance.splat = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 112:
				instance.topology = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 122:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.nodes.Add(instance2);
				continue;
			}
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 16)
			{
				if (key.WireType == Wire.Varint)
				{
					instance.hierarchy = (int)ProtocolParser.ReadUInt64(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PathData instance, PathData previous)
	{
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.name);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.spline);
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.start);
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.end);
		if (instance.width != previous.width)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.width);
		}
		if (instance.innerPadding != previous.innerPadding)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.innerPadding);
		}
		if (instance.outerPadding != previous.outerPadding)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.outerPadding);
		}
		if (instance.innerFade != previous.innerFade)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.innerFade);
		}
		if (instance.outerFade != previous.outerFade)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.outerFade);
		}
		if (instance.randomScale != previous.randomScale)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.randomScale);
		}
		if (instance.meshOffset != previous.meshOffset)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.meshOffset);
		}
		if (instance.terrainOffset != previous.terrainOffset)
		{
			stream.WriteByte(101);
			ProtocolParser.WriteSingle(stream, instance.terrainOffset);
		}
		if (instance.splat != previous.splat)
		{
			stream.WriteByte(104);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.splat);
		}
		if (instance.topology != previous.topology)
		{
			stream.WriteByte(112);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.topology);
		}
		if (instance.nodes != null)
		{
			for (int i = 0; i < instance.nodes.Count; i++)
			{
				VectorData vectorData = instance.nodes[i];
				stream.WriteByte(122);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				VectorData.SerializeDelta(stream, vectorData, vectorData);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field nodes (ProtoBuf.VectorData)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.hierarchy != previous.hierarchy)
		{
			stream.WriteByte(128);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.hierarchy);
		}
	}

	public static void Serialize(BufferStream stream, PathData instance)
	{
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.spline)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.spline);
		}
		if (instance.start)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.start);
		}
		if (instance.end)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.end);
		}
		if (instance.width != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.width);
		}
		if (instance.innerPadding != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.innerPadding);
		}
		if (instance.outerPadding != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.outerPadding);
		}
		if (instance.innerFade != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.innerFade);
		}
		if (instance.outerFade != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.outerFade);
		}
		if (instance.randomScale != 0f)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.randomScale);
		}
		if (instance.meshOffset != 0f)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.meshOffset);
		}
		if (instance.terrainOffset != 0f)
		{
			stream.WriteByte(101);
			ProtocolParser.WriteSingle(stream, instance.terrainOffset);
		}
		if (instance.splat != 0)
		{
			stream.WriteByte(104);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.splat);
		}
		if (instance.topology != 0)
		{
			stream.WriteByte(112);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.topology);
		}
		if (instance.nodes != null)
		{
			for (int i = 0; i < instance.nodes.Count; i++)
			{
				VectorData instance2 = instance.nodes[i];
				stream.WriteByte(122);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				VectorData.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field nodes (ProtoBuf.VectorData)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.hierarchy != 0)
		{
			stream.WriteByte(128);
			stream.WriteByte(1);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.hierarchy);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (nodes != null)
		{
			for (int i = 0; i < nodes.Count; i++)
			{
				nodes[i].InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class PatternFirework : IDisposable, IPooled, IProto<PatternFirework>, IProto
{
	public class Design : IDisposable, IPooled, IProto<Design>, IProto
	{
		[NonSerialized]
		public List<Star> stars;

		[NonSerialized]
		public ulong editedBy;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Design instance)
		{
			if (!instance.ShouldPool)
			{
				return;
			}
			if (instance.stars != null)
			{
				for (int i = 0; i < instance.stars.Count; i++)
				{
					if (instance.stars[i] != null)
					{
						instance.stars[i].ResetToPool();
						instance.stars[i] = null;
					}
				}
				List<Star> list = instance.stars;
				Pool.Free<Star>(ref list, false);
				instance.stars = list;
			}
			instance.editedBy = 0uL;
			Pool.Free<Design>(ref instance);
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Design with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Design instance)
		{
			if (stars != null)
			{
				instance.stars = Pool.Get<List<Star>>();
				for (int i = 0; i < stars.Count; i++)
				{
					Star item = stars[i].Copy();
					instance.stars.Add(item);
				}
			}
			else
			{
				instance.stars = null;
			}
			instance.editedBy = editedBy;
		}

		public Design Copy()
		{
			Design design = Pool.Get<Design>();
			CopyTo(design);
			return design;
		}

		public static Design Deserialize(BufferStream stream)
		{
			Design design = Pool.Get<Design>();
			Deserialize(stream, design, isDelta: false);
			return design;
		}

		public static Design DeserializeLengthDelimited(BufferStream stream)
		{
			Design design = Pool.Get<Design>();
			DeserializeLengthDelimited(stream, design, isDelta: false);
			return design;
		}

		public static Design DeserializeLength(BufferStream stream, int length)
		{
			Design design = Pool.Get<Design>();
			DeserializeLength(stream, length, design, isDelta: false);
			return design;
		}

		public static Design Deserialize(byte[] buffer)
		{
			Design design = Pool.Get<Design>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, design, isDelta: false);
			return design;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Design previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Design Deserialize(BufferStream stream, Design instance, bool isDelta)
		{
			if (!isDelta && instance.stars == null)
			{
				instance.stars = Pool.Get<List<Star>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.stars.Add(Star.DeserializeLengthDelimited(stream));
					continue;
				case 16:
					instance.editedBy = ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Design DeserializeLengthDelimited(BufferStream stream, Design instance, bool isDelta)
		{
			if (!isDelta && instance.stars == null)
			{
				instance.stars = Pool.Get<List<Star>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.stars.Add(Star.DeserializeLengthDelimited(stream));
					continue;
				case 16:
					instance.editedBy = ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Design DeserializeLength(BufferStream stream, int length, Design instance, bool isDelta)
		{
			if (!isDelta && instance.stars == null)
			{
				instance.stars = Pool.Get<List<Star>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.stars.Add(Star.DeserializeLengthDelimited(stream));
					continue;
				case 16:
					instance.editedBy = ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Design instance, Design previous)
		{
			if (instance.stars != null)
			{
				for (int i = 0; i < instance.stars.Count; i++)
				{
					Star star = instance.stars[i];
					stream.WriteByte(10);
					BufferStream.RangeHandle range = stream.GetRange(1);
					int position = stream.Position;
					Star.SerializeDelta(stream, star, star);
					int num = stream.Position - position;
					if (num > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field stars (ProtoBuf.PatternFirework.Star)");
					}
					Span<byte> span = range.GetSpan();
					ProtocolParser.WriteUInt32((uint)num, span, 0);
				}
			}
			if (instance.editedBy != previous.editedBy)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.editedBy);
			}
		}

		public static void Serialize(BufferStream stream, Design instance)
		{
			if (instance.stars != null)
			{
				for (int i = 0; i < instance.stars.Count; i++)
				{
					Star instance2 = instance.stars[i];
					stream.WriteByte(10);
					BufferStream.RangeHandle range = stream.GetRange(1);
					int position = stream.Position;
					Star.Serialize(stream, instance2);
					int num = stream.Position - position;
					if (num > 127)
					{
						throw new InvalidOperationException("Not enough space was reserved for the length prefix of field stars (ProtoBuf.PatternFirework.Star)");
					}
					Span<byte> span = range.GetSpan();
					ProtocolParser.WriteUInt32((uint)num, span, 0);
				}
			}
			if (instance.editedBy != 0L)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.editedBy);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			if (stars != null)
			{
				for (int i = 0; i < stars.Count; i++)
				{
					stars[i]?.InspectUids(action);
				}
			}
		}
	}

	public class SavedDesign : IDisposable, IPooled, IProto<SavedDesign>, IProto
	{
		[NonSerialized]
		public int version;

		[NonSerialized]
		public string name;

		[NonSerialized]
		public Design design;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(SavedDesign instance)
		{
			if (instance.ShouldPool)
			{
				instance.version = 0;
				instance.name = string.Empty;
				if (instance.design != null)
				{
					instance.design.ResetToPool();
					instance.design = null;
				}
				Pool.Free<SavedDesign>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose SavedDesign with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(SavedDesign instance)
		{
			instance.version = version;
			instance.name = name;
			if (design != null)
			{
				if (instance.design == null)
				{
					instance.design = design.Copy();
				}
				else
				{
					design.CopyTo(instance.design);
				}
			}
			else
			{
				instance.design = null;
			}
		}

		public SavedDesign Copy()
		{
			SavedDesign savedDesign = Pool.Get<SavedDesign>();
			CopyTo(savedDesign);
			return savedDesign;
		}

		public static SavedDesign Deserialize(BufferStream stream)
		{
			SavedDesign savedDesign = Pool.Get<SavedDesign>();
			Deserialize(stream, savedDesign, isDelta: false);
			return savedDesign;
		}

		public static SavedDesign DeserializeLengthDelimited(BufferStream stream)
		{
			SavedDesign savedDesign = Pool.Get<SavedDesign>();
			DeserializeLengthDelimited(stream, savedDesign, isDelta: false);
			return savedDesign;
		}

		public static SavedDesign DeserializeLength(BufferStream stream, int length)
		{
			SavedDesign savedDesign = Pool.Get<SavedDesign>();
			DeserializeLength(stream, length, savedDesign, isDelta: false);
			return savedDesign;
		}

		public static SavedDesign Deserialize(byte[] buffer)
		{
			SavedDesign savedDesign = Pool.Get<SavedDesign>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, savedDesign, isDelta: false);
			return savedDesign;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, SavedDesign previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static SavedDesign Deserialize(BufferStream stream, SavedDesign instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.version = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					break;
				case 26:
					if (instance.design == null)
					{
						instance.design = Design.DeserializeLengthDelimited(stream);
					}
					else
					{
						Design.DeserializeLengthDelimited(stream, instance.design, isDelta);
					}
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				case -1:
				case 0:
					return instance;
				}
			}
		}

		public static SavedDesign DeserializeLengthDelimited(BufferStream stream, SavedDesign instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.version = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					break;
				case 26:
					if (instance.design == null)
					{
						instance.design = Design.DeserializeLengthDelimited(stream);
					}
					else
					{
						Design.DeserializeLengthDelimited(stream, instance.design, isDelta);
					}
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static SavedDesign DeserializeLength(BufferStream stream, int length, SavedDesign instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.version = (int)ProtocolParser.ReadUInt64(stream);
					break;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					break;
				case 26:
					if (instance.design == null)
					{
						instance.design = Design.DeserializeLengthDelimited(stream);
					}
					else
					{
						Design.DeserializeLengthDelimited(stream, instance.design, isDelta);
					}
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, SavedDesign instance, SavedDesign previous)
		{
			if (instance.version != previous.version)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.version);
			}
			if (instance.name != previous.name)
			{
				if (instance.name == null)
				{
					throw new ArgumentNullException("name", "Required by proto specification.");
				}
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.name);
			}
			if (instance.design == null)
			{
				throw new ArgumentNullException("design", "Required by proto specification.");
			}
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(3);
			int position = stream.Position;
			Design.SerializeDelta(stream, instance.design, previous.design);
			int num = stream.Position - position;
			if (num > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field design (ProtoBuf.PatternFirework.Design)");
			}
			Span<byte> span = range.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
			if (num2 < 3)
			{
				span[num2 - 1] |= 128;
				while (num2 < 2)
				{
					span[num2++] = 128;
				}
				span[2] = 0;
			}
		}

		public static void Serialize(BufferStream stream, SavedDesign instance)
		{
			if (instance.version != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.version);
			}
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
			if (instance.design == null)
			{
				throw new ArgumentNullException("design", "Required by proto specification.");
			}
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(3);
			int position = stream.Position;
			Design.Serialize(stream, instance.design);
			int num = stream.Position - position;
			if (num > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field design (ProtoBuf.PatternFirework.Design)");
			}
			Span<byte> span = range.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
			if (num2 < 3)
			{
				span[num2 - 1] |= 128;
				while (num2 < 2)
				{
					span[num2++] = 128;
				}
				span[2] = 0;
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			design?.InspectUids(action);
		}
	}

	public class Star : IDisposable, IPooled, IProto<Star>, IProto
	{
		[NonSerialized]
		public Vector2 position;

		[NonSerialized]
		public Color color;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Star instance)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.position = default(Vector2);
				instance.color = default(Color);
				Pool.Free<Star>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Star with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Star instance)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			instance.position = position;
			instance.color = color;
		}

		public Star Copy()
		{
			Star star = Pool.Get<Star>();
			CopyTo(star);
			return star;
		}

		public static Star Deserialize(BufferStream stream)
		{
			Star star = Pool.Get<Star>();
			Deserialize(stream, star, isDelta: false);
			return star;
		}

		public static Star DeserializeLengthDelimited(BufferStream stream)
		{
			Star star = Pool.Get<Star>();
			DeserializeLengthDelimited(stream, star, isDelta: false);
			return star;
		}

		public static Star DeserializeLength(BufferStream stream, int length)
		{
			Star star = Pool.Get<Star>();
			DeserializeLength(stream, length, star, isDelta: false);
			return star;
		}

		public static Star Deserialize(byte[] buffer)
		{
			Star star = Pool.Get<Star>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, star, isDelta: false);
			return star;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Star previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Star Deserialize(BufferStream stream, Star instance, bool isDelta)
		{
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 18:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.color, isDelta);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Star DeserializeLengthDelimited(BufferStream stream, Star instance, bool isDelta)
		{
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 18:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.color, isDelta);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Star DeserializeLength(BufferStream stream, int length, Star instance, bool isDelta)
		{
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 18:
					ColorSerialized.DeserializeLengthDelimited(stream, ref instance.color, isDelta);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Star instance, Star previous)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			if (instance.position != previous.position)
			{
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int num = stream.Position;
				Vector2Serialized.SerializeDelta(stream, instance.position, previous.position);
				int num2 = stream.Position - num;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector2)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span, 0);
			}
			if (instance.color != previous.color)
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int num3 = stream.Position;
				ColorSerialized.SerializeDelta(stream, instance.color, previous.color);
				int num4 = stream.Position - num3;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field color (UnityEngine.Color)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span2, 0);
			}
		}

		public static void Serialize(BufferStream stream, Star instance)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0093: Unknown result type (might be due to invalid IL or missing references)
			if (instance.position != default(Vector2))
			{
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int num = stream.Position;
				Vector2Serialized.Serialize(stream, instance.position);
				int num2 = stream.Position - num;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector2)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span, 0);
			}
			if (instance.color != default(Color))
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int num3 = stream.Position;
				ColorSerialized.Serialize(stream, instance.color);
				int num4 = stream.Position - num3;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field color (UnityEngine.Color)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span2, 0);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public Design design;

	[NonSerialized]
	public int shellFuseLength;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PatternFirework instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.design != null)
			{
				instance.design.ResetToPool();
				instance.design = null;
			}
			instance.shellFuseLength = 0;
			Pool.Free<PatternFirework>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PatternFirework with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PatternFirework instance)
	{
		if (design != null)
		{
			if (instance.design == null)
			{
				instance.design = design.Copy();
			}
			else
			{
				design.CopyTo(instance.design);
			}
		}
		else
		{
			instance.design = null;
		}
		instance.shellFuseLength = shellFuseLength;
	}

	public PatternFirework Copy()
	{
		PatternFirework patternFirework = Pool.Get<PatternFirework>();
		CopyTo(patternFirework);
		return patternFirework;
	}

	public static PatternFirework Deserialize(BufferStream stream)
	{
		PatternFirework patternFirework = Pool.Get<PatternFirework>();
		Deserialize(stream, patternFirework, isDelta: false);
		return patternFirework;
	}

	public static PatternFirework DeserializeLengthDelimited(BufferStream stream)
	{
		PatternFirework patternFirework = Pool.Get<PatternFirework>();
		DeserializeLengthDelimited(stream, patternFirework, isDelta: false);
		return patternFirework;
	}

	public static PatternFirework DeserializeLength(BufferStream stream, int length)
	{
		PatternFirework patternFirework = Pool.Get<PatternFirework>();
		DeserializeLength(stream, length, patternFirework, isDelta: false);
		return patternFirework;
	}

	public static PatternFirework Deserialize(byte[] buffer)
	{
		PatternFirework patternFirework = Pool.Get<PatternFirework>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, patternFirework, isDelta: false);
		return patternFirework;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PatternFirework previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PatternFirework Deserialize(BufferStream stream, PatternFirework instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.design == null)
				{
					instance.design = Design.DeserializeLengthDelimited(stream);
				}
				else
				{
					Design.DeserializeLengthDelimited(stream, instance.design, isDelta);
				}
				break;
			case 16:
				instance.shellFuseLength = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static PatternFirework DeserializeLengthDelimited(BufferStream stream, PatternFirework instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.design == null)
				{
					instance.design = Design.DeserializeLengthDelimited(stream);
				}
				else
				{
					Design.DeserializeLengthDelimited(stream, instance.design, isDelta);
				}
				break;
			case 16:
				instance.shellFuseLength = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PatternFirework DeserializeLength(BufferStream stream, int length, PatternFirework instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.design == null)
				{
					instance.design = Design.DeserializeLengthDelimited(stream);
				}
				else
				{
					Design.DeserializeLengthDelimited(stream, instance.design, isDelta);
				}
				break;
			case 16:
				instance.shellFuseLength = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PatternFirework instance, PatternFirework previous)
	{
		if (instance.design != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(3);
			int position = stream.Position;
			Design.SerializeDelta(stream, instance.design, previous.design);
			int num = stream.Position - position;
			if (num > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field design (ProtoBuf.PatternFirework.Design)");
			}
			Span<byte> span = range.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
			if (num2 < 3)
			{
				span[num2 - 1] |= 128;
				while (num2 < 2)
				{
					span[num2++] = 128;
				}
				span[2] = 0;
			}
		}
		if (instance.shellFuseLength != previous.shellFuseLength)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.shellFuseLength);
		}
	}

	public static void Serialize(BufferStream stream, PatternFirework instance)
	{
		if (instance.design != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(3);
			int position = stream.Position;
			Design.Serialize(stream, instance.design);
			int num = stream.Position - position;
			if (num > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field design (ProtoBuf.PatternFirework.Design)");
			}
			Span<byte> span = range.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
			if (num2 < 3)
			{
				span[num2 - 1] |= 128;
				while (num2 < 2)
				{
					span[num2++] = 128;
				}
				span[2] = 0;
			}
		}
		if (instance.shellFuseLength != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.shellFuseLength);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		design?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PersistantPlayer : IDisposable, IPooled, IProto<PersistantPlayer>, IProto
{
	[NonSerialized]
	public List<int> unlockedItems;

	[NonSerialized]
	public int protocolVersion;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PersistantPlayer instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.unlockedItems != null)
			{
				List<int> list = instance.unlockedItems;
				Pool.FreeUnmanaged<int>(ref list);
				instance.unlockedItems = list;
			}
			instance.protocolVersion = 0;
			Pool.Free<PersistantPlayer>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PersistantPlayer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PersistantPlayer instance)
	{
		if (unlockedItems != null)
		{
			instance.unlockedItems = Pool.Get<List<int>>();
			for (int i = 0; i < unlockedItems.Count; i++)
			{
				int item = unlockedItems[i];
				instance.unlockedItems.Add(item);
			}
		}
		else
		{
			instance.unlockedItems = null;
		}
		instance.protocolVersion = protocolVersion;
	}

	public PersistantPlayer Copy()
	{
		PersistantPlayer persistantPlayer = Pool.Get<PersistantPlayer>();
		CopyTo(persistantPlayer);
		return persistantPlayer;
	}

	public static PersistantPlayer Deserialize(BufferStream stream)
	{
		PersistantPlayer persistantPlayer = Pool.Get<PersistantPlayer>();
		Deserialize(stream, persistantPlayer, isDelta: false);
		return persistantPlayer;
	}

	public static PersistantPlayer DeserializeLengthDelimited(BufferStream stream)
	{
		PersistantPlayer persistantPlayer = Pool.Get<PersistantPlayer>();
		DeserializeLengthDelimited(stream, persistantPlayer, isDelta: false);
		return persistantPlayer;
	}

	public static PersistantPlayer DeserializeLength(BufferStream stream, int length)
	{
		PersistantPlayer persistantPlayer = Pool.Get<PersistantPlayer>();
		DeserializeLength(stream, length, persistantPlayer, isDelta: false);
		return persistantPlayer;
	}

	public static PersistantPlayer Deserialize(byte[] buffer)
	{
		PersistantPlayer persistantPlayer = Pool.Get<PersistantPlayer>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, persistantPlayer, isDelta: false);
		return persistantPlayer;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PersistantPlayer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PersistantPlayer Deserialize(BufferStream stream, PersistantPlayer instance, bool isDelta)
	{
		if (!isDelta && instance.unlockedItems == null)
		{
			instance.unlockedItems = Pool.Get<List<int>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 24:
				instance.unlockedItems.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 100)
			{
				if (key.WireType == Wire.Varint)
				{
					instance.protocolVersion = (int)ProtocolParser.ReadUInt64(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
	}

	public static PersistantPlayer DeserializeLengthDelimited(BufferStream stream, PersistantPlayer instance, bool isDelta)
	{
		if (!isDelta && instance.unlockedItems == null)
		{
			instance.unlockedItems = Pool.Get<List<int>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 24:
				instance.unlockedItems.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 100)
			{
				if (key.WireType == Wire.Varint)
				{
					instance.protocolVersion = (int)ProtocolParser.ReadUInt64(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PersistantPlayer DeserializeLength(BufferStream stream, int length, PersistantPlayer instance, bool isDelta)
	{
		if (!isDelta && instance.unlockedItems == null)
		{
			instance.unlockedItems = Pool.Get<List<int>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 24:
				instance.unlockedItems.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 100)
			{
				if (key.WireType == Wire.Varint)
				{
					instance.protocolVersion = (int)ProtocolParser.ReadUInt64(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PersistantPlayer instance, PersistantPlayer previous)
	{
		if (instance.unlockedItems != null)
		{
			for (int i = 0; i < instance.unlockedItems.Count; i++)
			{
				int num = instance.unlockedItems[i];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.protocolVersion != previous.protocolVersion)
		{
			stream.WriteByte(160);
			stream.WriteByte(6);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.protocolVersion);
		}
	}

	public static void Serialize(BufferStream stream, PersistantPlayer instance)
	{
		if (instance.unlockedItems != null)
		{
			for (int i = 0; i < instance.unlockedItems.Count; i++)
			{
				int num = instance.unlockedItems[i];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.protocolVersion != 0)
		{
			stream.WriteByte(160);
			stream.WriteByte(6);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.protocolVersion);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PersistentMissionEntityData : IDisposable, IPooled, IProto<PersistentMissionEntityData>, IProto
{
	[NonSerialized]
	public NetworkableId entityID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PersistentMissionEntityData instance)
	{
		if (instance.ShouldPool)
		{
			instance.entityID = default(NetworkableId);
			Pool.Free<PersistentMissionEntityData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PersistentMissionEntityData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PersistentMissionEntityData instance)
	{
		instance.entityID = entityID;
	}

	public PersistentMissionEntityData Copy()
	{
		PersistentMissionEntityData persistentMissionEntityData = Pool.Get<PersistentMissionEntityData>();
		CopyTo(persistentMissionEntityData);
		return persistentMissionEntityData;
	}

	public static PersistentMissionEntityData Deserialize(BufferStream stream)
	{
		PersistentMissionEntityData persistentMissionEntityData = Pool.Get<PersistentMissionEntityData>();
		Deserialize(stream, persistentMissionEntityData, isDelta: false);
		return persistentMissionEntityData;
	}

	public static PersistentMissionEntityData DeserializeLengthDelimited(BufferStream stream)
	{
		PersistentMissionEntityData persistentMissionEntityData = Pool.Get<PersistentMissionEntityData>();
		DeserializeLengthDelimited(stream, persistentMissionEntityData, isDelta: false);
		return persistentMissionEntityData;
	}

	public static PersistentMissionEntityData DeserializeLength(BufferStream stream, int length)
	{
		PersistentMissionEntityData persistentMissionEntityData = Pool.Get<PersistentMissionEntityData>();
		DeserializeLength(stream, length, persistentMissionEntityData, isDelta: false);
		return persistentMissionEntityData;
	}

	public static PersistentMissionEntityData Deserialize(byte[] buffer)
	{
		PersistentMissionEntityData persistentMissionEntityData = Pool.Get<PersistentMissionEntityData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, persistentMissionEntityData, isDelta: false);
		return persistentMissionEntityData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PersistentMissionEntityData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PersistentMissionEntityData Deserialize(BufferStream stream, PersistentMissionEntityData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.entityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PersistentMissionEntityData DeserializeLengthDelimited(BufferStream stream, PersistentMissionEntityData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PersistentMissionEntityData DeserializeLength(BufferStream stream, int length, PersistentMissionEntityData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PersistentMissionEntityData instance, PersistentMissionEntityData previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.entityID.Value);
	}

	public static void Serialize(BufferStream stream, PersistentMissionEntityData instance)
	{
		if (instance.entityID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.entityID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entityID.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PhoneDirectory : IDisposable, IPooled, IProto<PhoneDirectory>, IProto
{
	public class DirectoryEntry : IDisposable, IPooled, IProto<DirectoryEntry>, IProto
	{
		[NonSerialized]
		public int phoneNumber;

		[NonSerialized]
		public string phoneName;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(DirectoryEntry instance)
		{
			if (instance.ShouldPool)
			{
				instance.phoneNumber = 0;
				instance.phoneName = string.Empty;
				Pool.Free<DirectoryEntry>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose DirectoryEntry with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(DirectoryEntry instance)
		{
			instance.phoneNumber = phoneNumber;
			instance.phoneName = phoneName;
		}

		public DirectoryEntry Copy()
		{
			DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
			CopyTo(directoryEntry);
			return directoryEntry;
		}

		public static DirectoryEntry Deserialize(BufferStream stream)
		{
			DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
			Deserialize(stream, directoryEntry, isDelta: false);
			return directoryEntry;
		}

		public static DirectoryEntry DeserializeLengthDelimited(BufferStream stream)
		{
			DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
			DeserializeLengthDelimited(stream, directoryEntry, isDelta: false);
			return directoryEntry;
		}

		public static DirectoryEntry DeserializeLength(BufferStream stream, int length)
		{
			DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
			DeserializeLength(stream, length, directoryEntry, isDelta: false);
			return directoryEntry;
		}

		public static DirectoryEntry Deserialize(byte[] buffer)
		{
			DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, directoryEntry, isDelta: false);
			return directoryEntry;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, DirectoryEntry previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static DirectoryEntry Deserialize(BufferStream stream, DirectoryEntry instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.phoneName = ProtocolParser.ReadString(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static DirectoryEntry DeserializeLengthDelimited(BufferStream stream, DirectoryEntry instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.phoneName = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static DirectoryEntry DeserializeLength(BufferStream stream, int length, DirectoryEntry instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.phoneName = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, DirectoryEntry instance, DirectoryEntry previous)
		{
			if (instance.phoneNumber != previous.phoneNumber)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.phoneNumber);
			}
			if (instance.phoneName != previous.phoneName)
			{
				if (instance.phoneName == null)
				{
					throw new ArgumentNullException("phoneName", "Required by proto specification.");
				}
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.phoneName);
			}
		}

		public static void Serialize(BufferStream stream, DirectoryEntry instance)
		{
			if (instance.phoneNumber != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.phoneNumber);
			}
			if (instance.phoneName == null)
			{
				throw new ArgumentNullException("phoneName", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.phoneName);
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<DirectoryEntry> entries;

	[NonSerialized]
	public bool atEnd;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PhoneDirectory instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.entries != null)
		{
			for (int i = 0; i < instance.entries.Count; i++)
			{
				if (instance.entries[i] != null)
				{
					instance.entries[i].ResetToPool();
					instance.entries[i] = null;
				}
			}
			List<DirectoryEntry> list = instance.entries;
			Pool.Free<DirectoryEntry>(ref list, false);
			instance.entries = list;
		}
		instance.atEnd = false;
		Pool.Free<PhoneDirectory>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PhoneDirectory with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PhoneDirectory instance)
	{
		if (entries != null)
		{
			instance.entries = Pool.Get<List<DirectoryEntry>>();
			for (int i = 0; i < entries.Count; i++)
			{
				DirectoryEntry item = entries[i].Copy();
				instance.entries.Add(item);
			}
		}
		else
		{
			instance.entries = null;
		}
		instance.atEnd = atEnd;
	}

	public PhoneDirectory Copy()
	{
		PhoneDirectory phoneDirectory = Pool.Get<PhoneDirectory>();
		CopyTo(phoneDirectory);
		return phoneDirectory;
	}

	public static PhoneDirectory Deserialize(BufferStream stream)
	{
		PhoneDirectory phoneDirectory = Pool.Get<PhoneDirectory>();
		Deserialize(stream, phoneDirectory, isDelta: false);
		return phoneDirectory;
	}

	public static PhoneDirectory DeserializeLengthDelimited(BufferStream stream)
	{
		PhoneDirectory phoneDirectory = Pool.Get<PhoneDirectory>();
		DeserializeLengthDelimited(stream, phoneDirectory, isDelta: false);
		return phoneDirectory;
	}

	public static PhoneDirectory DeserializeLength(BufferStream stream, int length)
	{
		PhoneDirectory phoneDirectory = Pool.Get<PhoneDirectory>();
		DeserializeLength(stream, length, phoneDirectory, isDelta: false);
		return phoneDirectory;
	}

	public static PhoneDirectory Deserialize(byte[] buffer)
	{
		PhoneDirectory phoneDirectory = Pool.Get<PhoneDirectory>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, phoneDirectory, isDelta: false);
		return phoneDirectory;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PhoneDirectory previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PhoneDirectory Deserialize(BufferStream stream, PhoneDirectory instance, bool isDelta)
	{
		if (!isDelta && instance.entries == null)
		{
			instance.entries = Pool.Get<List<DirectoryEntry>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.entries.Add(DirectoryEntry.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.atEnd = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PhoneDirectory DeserializeLengthDelimited(BufferStream stream, PhoneDirectory instance, bool isDelta)
	{
		if (!isDelta && instance.entries == null)
		{
			instance.entries = Pool.Get<List<DirectoryEntry>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entries.Add(DirectoryEntry.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.atEnd = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PhoneDirectory DeserializeLength(BufferStream stream, int length, PhoneDirectory instance, bool isDelta)
	{
		if (!isDelta && instance.entries == null)
		{
			instance.entries = Pool.Get<List<DirectoryEntry>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entries.Add(DirectoryEntry.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.atEnd = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PhoneDirectory instance, PhoneDirectory previous)
	{
		if (instance.entries != null)
		{
			for (int i = 0; i < instance.entries.Count; i++)
			{
				DirectoryEntry directoryEntry = instance.entries[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				DirectoryEntry.SerializeDelta(stream, directoryEntry, directoryEntry);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.atEnd);
	}

	public static void Serialize(BufferStream stream, PhoneDirectory instance)
	{
		if (instance.entries != null)
		{
			for (int i = 0; i < instance.entries.Count; i++)
			{
				DirectoryEntry instance2 = instance.entries[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				DirectoryEntry.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.atEnd)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.atEnd);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (entries != null)
		{
			for (int i = 0; i < entries.Count; i++)
			{
				entries[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Photo : IDisposable, IPooled, IProto<Photo>, IProto
{
	[NonSerialized]
	public ulong photographerSteamId;

	[NonSerialized]
	public uint imageCrc;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Photo instance)
	{
		if (instance.ShouldPool)
		{
			instance.photographerSteamId = 0uL;
			instance.imageCrc = 0u;
			Pool.Free<Photo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Photo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Photo instance)
	{
		instance.photographerSteamId = photographerSteamId;
		instance.imageCrc = imageCrc;
	}

	public Photo Copy()
	{
		Photo photo = Pool.Get<Photo>();
		CopyTo(photo);
		return photo;
	}

	public static Photo Deserialize(BufferStream stream)
	{
		Photo photo = Pool.Get<Photo>();
		Deserialize(stream, photo, isDelta: false);
		return photo;
	}

	public static Photo DeserializeLengthDelimited(BufferStream stream)
	{
		Photo photo = Pool.Get<Photo>();
		DeserializeLengthDelimited(stream, photo, isDelta: false);
		return photo;
	}

	public static Photo DeserializeLength(BufferStream stream, int length)
	{
		Photo photo = Pool.Get<Photo>();
		DeserializeLength(stream, length, photo, isDelta: false);
		return photo;
	}

	public static Photo Deserialize(byte[] buffer)
	{
		Photo photo = Pool.Get<Photo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, photo, isDelta: false);
		return photo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Photo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Photo Deserialize(BufferStream stream, Photo instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.photographerSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.imageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Photo DeserializeLengthDelimited(BufferStream stream, Photo instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.photographerSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.imageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Photo DeserializeLength(BufferStream stream, int length, Photo instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.photographerSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.imageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Photo instance, Photo previous)
	{
		if (instance.photographerSteamId != previous.photographerSteamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.photographerSteamId);
		}
		if (instance.imageCrc != previous.imageCrc)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.imageCrc);
		}
	}

	public static void Serialize(BufferStream stream, Photo instance)
	{
		if (instance.photographerSteamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.photographerSteamId);
		}
		if (instance.imageCrc != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.imageCrc);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PhotoFrame : IDisposable, IPooled, IProto<PhotoFrame>, IProto
{
	[NonSerialized]
	public NetworkableId photoEntityId;

	[NonSerialized]
	public uint overlayImageCrc;

	[NonSerialized]
	public List<ulong> editHistory;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PhotoFrame instance)
	{
		if (instance.ShouldPool)
		{
			instance.photoEntityId = default(NetworkableId);
			instance.overlayImageCrc = 0u;
			if (instance.editHistory != null)
			{
				List<ulong> list = instance.editHistory;
				Pool.FreeUnmanaged<ulong>(ref list);
				instance.editHistory = list;
			}
			Pool.Free<PhotoFrame>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PhotoFrame with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PhotoFrame instance)
	{
		instance.photoEntityId = photoEntityId;
		instance.overlayImageCrc = overlayImageCrc;
		if (editHistory != null)
		{
			instance.editHistory = Pool.Get<List<ulong>>();
			for (int i = 0; i < editHistory.Count; i++)
			{
				ulong item = editHistory[i];
				instance.editHistory.Add(item);
			}
		}
		else
		{
			instance.editHistory = null;
		}
	}

	public PhotoFrame Copy()
	{
		PhotoFrame photoFrame = Pool.Get<PhotoFrame>();
		CopyTo(photoFrame);
		return photoFrame;
	}

	public static PhotoFrame Deserialize(BufferStream stream)
	{
		PhotoFrame photoFrame = Pool.Get<PhotoFrame>();
		Deserialize(stream, photoFrame, isDelta: false);
		return photoFrame;
	}

	public static PhotoFrame DeserializeLengthDelimited(BufferStream stream)
	{
		PhotoFrame photoFrame = Pool.Get<PhotoFrame>();
		DeserializeLengthDelimited(stream, photoFrame, isDelta: false);
		return photoFrame;
	}

	public static PhotoFrame DeserializeLength(BufferStream stream, int length)
	{
		PhotoFrame photoFrame = Pool.Get<PhotoFrame>();
		DeserializeLength(stream, length, photoFrame, isDelta: false);
		return photoFrame;
	}

	public static PhotoFrame Deserialize(byte[] buffer)
	{
		PhotoFrame photoFrame = Pool.Get<PhotoFrame>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, photoFrame, isDelta: false);
		return photoFrame;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PhotoFrame previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PhotoFrame Deserialize(BufferStream stream, PhotoFrame instance, bool isDelta)
	{
		if (!isDelta && instance.editHistory == null)
		{
			instance.editHistory = Pool.Get<List<ulong>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.photoEntityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.overlayImageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.editHistory.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PhotoFrame DeserializeLengthDelimited(BufferStream stream, PhotoFrame instance, bool isDelta)
	{
		if (!isDelta && instance.editHistory == null)
		{
			instance.editHistory = Pool.Get<List<ulong>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.photoEntityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.overlayImageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.editHistory.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PhotoFrame DeserializeLength(BufferStream stream, int length, PhotoFrame instance, bool isDelta)
	{
		if (!isDelta && instance.editHistory == null)
		{
			instance.editHistory = Pool.Get<List<ulong>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.photoEntityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.overlayImageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.editHistory.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PhotoFrame instance, PhotoFrame previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.photoEntityId.Value);
		if (instance.overlayImageCrc != previous.overlayImageCrc)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.overlayImageCrc);
		}
		if (instance.editHistory != null)
		{
			for (int i = 0; i < instance.editHistory.Count; i++)
			{
				ulong val = instance.editHistory[i];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
	}

	public static void Serialize(BufferStream stream, PhotoFrame instance)
	{
		if (instance.photoEntityId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.photoEntityId.Value);
		}
		if (instance.overlayImageCrc != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.overlayImageCrc);
		}
		if (instance.editHistory != null)
		{
			for (int i = 0; i < instance.editHistory.Count; i++)
			{
				ulong val = instance.editHistory[i];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref photoEntityId.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PlayerAttack : IDisposable, IPooled, IProto<PlayerAttack>, IProto
{
	[NonSerialized]
	public Attack attack;

	[NonSerialized]
	public int projectileID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerAttack instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.attack != null)
			{
				instance.attack.ResetToPool();
				instance.attack = null;
			}
			instance.projectileID = 0;
			Pool.Free<PlayerAttack>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerAttack with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerAttack instance)
	{
		if (attack != null)
		{
			if (instance.attack == null)
			{
				instance.attack = attack.Copy();
			}
			else
			{
				attack.CopyTo(instance.attack);
			}
		}
		else
		{
			instance.attack = null;
		}
		instance.projectileID = projectileID;
	}

	public PlayerAttack Copy()
	{
		PlayerAttack playerAttack = Pool.Get<PlayerAttack>();
		CopyTo(playerAttack);
		return playerAttack;
	}

	public static PlayerAttack Deserialize(BufferStream stream)
	{
		PlayerAttack playerAttack = Pool.Get<PlayerAttack>();
		Deserialize(stream, playerAttack, isDelta: false);
		return playerAttack;
	}

	public static PlayerAttack DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerAttack playerAttack = Pool.Get<PlayerAttack>();
		DeserializeLengthDelimited(stream, playerAttack, isDelta: false);
		return playerAttack;
	}

	public static PlayerAttack DeserializeLength(BufferStream stream, int length)
	{
		PlayerAttack playerAttack = Pool.Get<PlayerAttack>();
		DeserializeLength(stream, length, playerAttack, isDelta: false);
		return playerAttack;
	}

	public static PlayerAttack Deserialize(byte[] buffer)
	{
		PlayerAttack playerAttack = Pool.Get<PlayerAttack>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerAttack, isDelta: false);
		return playerAttack;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerAttack previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerAttack Deserialize(BufferStream stream, PlayerAttack instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.attack == null)
				{
					instance.attack = Attack.DeserializeLengthDelimited(stream);
				}
				else
				{
					Attack.DeserializeLengthDelimited(stream, instance.attack, isDelta);
				}
				break;
			case 16:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static PlayerAttack DeserializeLengthDelimited(BufferStream stream, PlayerAttack instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.attack == null)
				{
					instance.attack = Attack.DeserializeLengthDelimited(stream);
				}
				else
				{
					Attack.DeserializeLengthDelimited(stream, instance.attack, isDelta);
				}
				break;
			case 16:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerAttack DeserializeLength(BufferStream stream, int length, PlayerAttack instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.attack == null)
				{
					instance.attack = Attack.DeserializeLengthDelimited(stream);
				}
				else
				{
					Attack.DeserializeLengthDelimited(stream, instance.attack, isDelta);
				}
				break;
			case 16:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerAttack instance, PlayerAttack previous)
	{
		if (instance.attack == null)
		{
			throw new ArgumentNullException("attack", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(2);
		int position = stream.Position;
		Attack.SerializeDelta(stream, instance.attack, previous.attack);
		int num = stream.Position - position;
		if (num > 16383)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field attack (ProtoBuf.Attack)");
		}
		Span<byte> span = range.GetSpan();
		if (ProtocolParser.WriteUInt32((uint)num, span, 0) < 2)
		{
			span[0] |= 128;
			span[1] = 0;
		}
		if (instance.projectileID != previous.projectileID)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
		}
	}

	public static void Serialize(BufferStream stream, PlayerAttack instance)
	{
		if (instance.attack == null)
		{
			throw new ArgumentNullException("attack", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(2);
		int position = stream.Position;
		Attack.Serialize(stream, instance.attack);
		int num = stream.Position - position;
		if (num > 16383)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field attack (ProtoBuf.Attack)");
		}
		Span<byte> span = range.GetSpan();
		if (ProtocolParser.WriteUInt32((uint)num, span, 0) < 2)
		{
			span[0] |= 128;
			span[1] = 0;
		}
		if (instance.projectileID != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		attack?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class PlayerBoat : IDisposable, IPooled, IProto<PlayerBoat>, IProto
{
	[NonSerialized]
	public Vector3 size;

	[NonSerialized]
	public bool hasLock;

	[NonSerialized]
	public string lockCode;

	[NonSerialized]
	public List<ulong> whitelistUsers;

	[NonSerialized]
	public Vector3 lastEditLocalPos;

	[NonSerialized]
	public Vector3 lastEditLocalRot;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerBoat instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.size = default(Vector3);
			instance.hasLock = false;
			instance.lockCode = string.Empty;
			if (instance.whitelistUsers != null)
			{
				List<ulong> list = instance.whitelistUsers;
				Pool.FreeUnmanaged<ulong>(ref list);
				instance.whitelistUsers = list;
			}
			instance.lastEditLocalPos = default(Vector3);
			instance.lastEditLocalRot = default(Vector3);
			Pool.Free<PlayerBoat>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerBoat with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerBoat instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		instance.size = size;
		instance.hasLock = hasLock;
		instance.lockCode = lockCode;
		if (whitelistUsers != null)
		{
			instance.whitelistUsers = Pool.Get<List<ulong>>();
			for (int i = 0; i < whitelistUsers.Count; i++)
			{
				ulong item = whitelistUsers[i];
				instance.whitelistUsers.Add(item);
			}
		}
		else
		{
			instance.whitelistUsers = null;
		}
		instance.lastEditLocalPos = lastEditLocalPos;
		instance.lastEditLocalRot = lastEditLocalRot;
	}

	public PlayerBoat Copy()
	{
		PlayerBoat playerBoat = Pool.Get<PlayerBoat>();
		CopyTo(playerBoat);
		return playerBoat;
	}

	public static PlayerBoat Deserialize(BufferStream stream)
	{
		PlayerBoat playerBoat = Pool.Get<PlayerBoat>();
		Deserialize(stream, playerBoat, isDelta: false);
		return playerBoat;
	}

	public static PlayerBoat DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerBoat playerBoat = Pool.Get<PlayerBoat>();
		DeserializeLengthDelimited(stream, playerBoat, isDelta: false);
		return playerBoat;
	}

	public static PlayerBoat DeserializeLength(BufferStream stream, int length)
	{
		PlayerBoat playerBoat = Pool.Get<PlayerBoat>();
		DeserializeLength(stream, length, playerBoat, isDelta: false);
		return playerBoat;
	}

	public static PlayerBoat Deserialize(byte[] buffer)
	{
		PlayerBoat playerBoat = Pool.Get<PlayerBoat>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerBoat, isDelta: false);
		return playerBoat;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerBoat previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerBoat Deserialize(BufferStream stream, PlayerBoat instance, bool isDelta)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.whitelistUsers == null)
		{
			instance.whitelistUsers = Pool.Get<List<ulong>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.size, isDelta);
				continue;
			case 16:
				instance.hasLock = ProtocolParser.ReadBool(stream);
				continue;
			case 26:
				instance.lockCode = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.whitelistUsers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.lastEditLocalPos, isDelta);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.lastEditLocalRot, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerBoat DeserializeLengthDelimited(BufferStream stream, PlayerBoat instance, bool isDelta)
	{
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.whitelistUsers == null)
		{
			instance.whitelistUsers = Pool.Get<List<ulong>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.size, isDelta);
				continue;
			case 16:
				instance.hasLock = ProtocolParser.ReadBool(stream);
				continue;
			case 26:
				instance.lockCode = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.whitelistUsers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.lastEditLocalPos, isDelta);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.lastEditLocalRot, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerBoat DeserializeLength(BufferStream stream, int length, PlayerBoat instance, bool isDelta)
	{
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.whitelistUsers == null)
		{
			instance.whitelistUsers = Pool.Get<List<ulong>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.size, isDelta);
				continue;
			case 16:
				instance.hasLock = ProtocolParser.ReadBool(stream);
				continue;
			case 26:
				instance.lockCode = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.whitelistUsers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.lastEditLocalPos, isDelta);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.lastEditLocalRot, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerBoat instance, PlayerBoat previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		if (instance.size != previous.size)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.size, previous.size);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field size (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.hasLock);
		if (instance.lockCode != null && instance.lockCode != previous.lockCode)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.lockCode);
		}
		if (instance.whitelistUsers != null)
		{
			for (int i = 0; i < instance.whitelistUsers.Count; i++)
			{
				ulong val = instance.whitelistUsers[i];
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
		if (instance.lastEditLocalPos != previous.lastEditLocalPos)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.lastEditLocalPos, previous.lastEditLocalPos);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field lastEditLocalPos (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.lastEditLocalRot != previous.lastEditLocalRot)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.lastEditLocalRot, previous.lastEditLocalRot);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field lastEditLocalRot (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
	}

	public static void Serialize(BufferStream stream, PlayerBoat instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		if (instance.size != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.size);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field size (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.hasLock)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.hasLock);
		}
		if (instance.lockCode != null)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.lockCode);
		}
		if (instance.whitelistUsers != null)
		{
			for (int i = 0; i < instance.whitelistUsers.Count; i++)
			{
				ulong val = instance.whitelistUsers[i];
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
		if (instance.lastEditLocalPos != default(Vector3))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.lastEditLocalPos);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field lastEditLocalPos (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.lastEditLocalRot != default(Vector3))
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.lastEditLocalRot);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field lastEditLocalRot (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PlayerDetectedAIEventData : IDisposable, IPooled, IProto<PlayerDetectedAIEventData>, IProto
{
	[NonSerialized]
	public float range;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerDetectedAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.range = 0f;
			Pool.Free<PlayerDetectedAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerDetectedAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerDetectedAIEventData instance)
	{
		instance.range = range;
	}

	public PlayerDetectedAIEventData Copy()
	{
		PlayerDetectedAIEventData playerDetectedAIEventData = Pool.Get<PlayerDetectedAIEventData>();
		CopyTo(playerDetectedAIEventData);
		return playerDetectedAIEventData;
	}

	public static PlayerDetectedAIEventData Deserialize(BufferStream stream)
	{
		PlayerDetectedAIEventData playerDetectedAIEventData = Pool.Get<PlayerDetectedAIEventData>();
		Deserialize(stream, playerDetectedAIEventData, isDelta: false);
		return playerDetectedAIEventData;
	}

	public static PlayerDetectedAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerDetectedAIEventData playerDetectedAIEventData = Pool.Get<PlayerDetectedAIEventData>();
		DeserializeLengthDelimited(stream, playerDetectedAIEventData, isDelta: false);
		return playerDetectedAIEventData;
	}

	public static PlayerDetectedAIEventData DeserializeLength(BufferStream stream, int length)
	{
		PlayerDetectedAIEventData playerDetectedAIEventData = Pool.Get<PlayerDetectedAIEventData>();
		DeserializeLength(stream, length, playerDetectedAIEventData, isDelta: false);
		return playerDetectedAIEventData;
	}

	public static PlayerDetectedAIEventData Deserialize(byte[] buffer)
	{
		PlayerDetectedAIEventData playerDetectedAIEventData = Pool.Get<PlayerDetectedAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerDetectedAIEventData, isDelta: false);
		return playerDetectedAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerDetectedAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerDetectedAIEventData Deserialize(BufferStream stream, PlayerDetectedAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerDetectedAIEventData DeserializeLengthDelimited(BufferStream stream, PlayerDetectedAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerDetectedAIEventData DeserializeLength(BufferStream stream, int length, PlayerDetectedAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerDetectedAIEventData instance, PlayerDetectedAIEventData previous)
	{
		if (instance.range != previous.range)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.range);
		}
	}

	public static void Serialize(BufferStream stream, PlayerDetectedAIEventData instance)
	{
		if (instance.range != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.range);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PlayerInventory : IDisposable, IPooled, IProto<PlayerInventory>, IProto
{
	[NonSerialized]
	public ItemContainer invMain;

	[NonSerialized]
	public ItemContainer invBelt;

	[NonSerialized]
	public ItemContainer invWear;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerInventory instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.invMain != null)
			{
				instance.invMain.ResetToPool();
				instance.invMain = null;
			}
			if (instance.invBelt != null)
			{
				instance.invBelt.ResetToPool();
				instance.invBelt = null;
			}
			if (instance.invWear != null)
			{
				instance.invWear.ResetToPool();
				instance.invWear = null;
			}
			Pool.Free<PlayerInventory>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerInventory with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerInventory instance)
	{
		if (invMain != null)
		{
			if (instance.invMain == null)
			{
				instance.invMain = invMain.Copy();
			}
			else
			{
				invMain.CopyTo(instance.invMain);
			}
		}
		else
		{
			instance.invMain = null;
		}
		if (invBelt != null)
		{
			if (instance.invBelt == null)
			{
				instance.invBelt = invBelt.Copy();
			}
			else
			{
				invBelt.CopyTo(instance.invBelt);
			}
		}
		else
		{
			instance.invBelt = null;
		}
		if (invWear != null)
		{
			if (instance.invWear == null)
			{
				instance.invWear = invWear.Copy();
			}
			else
			{
				invWear.CopyTo(instance.invWear);
			}
		}
		else
		{
			instance.invWear = null;
		}
	}

	public PlayerInventory Copy()
	{
		PlayerInventory playerInventory = Pool.Get<PlayerInventory>();
		CopyTo(playerInventory);
		return playerInventory;
	}

	public static PlayerInventory Deserialize(BufferStream stream)
	{
		PlayerInventory playerInventory = Pool.Get<PlayerInventory>();
		Deserialize(stream, playerInventory, isDelta: false);
		return playerInventory;
	}

	public static PlayerInventory DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerInventory playerInventory = Pool.Get<PlayerInventory>();
		DeserializeLengthDelimited(stream, playerInventory, isDelta: false);
		return playerInventory;
	}

	public static PlayerInventory DeserializeLength(BufferStream stream, int length)
	{
		PlayerInventory playerInventory = Pool.Get<PlayerInventory>();
		DeserializeLength(stream, length, playerInventory, isDelta: false);
		return playerInventory;
	}

	public static PlayerInventory Deserialize(byte[] buffer)
	{
		PlayerInventory playerInventory = Pool.Get<PlayerInventory>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerInventory, isDelta: false);
		return playerInventory;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerInventory previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerInventory Deserialize(BufferStream stream, PlayerInventory instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.invMain == null)
				{
					instance.invMain = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.invMain, isDelta);
				}
				break;
			case 18:
				if (instance.invBelt == null)
				{
					instance.invBelt = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.invBelt, isDelta);
				}
				break;
			case 26:
				if (instance.invWear == null)
				{
					instance.invWear = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.invWear, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static PlayerInventory DeserializeLengthDelimited(BufferStream stream, PlayerInventory instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.invMain == null)
				{
					instance.invMain = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.invMain, isDelta);
				}
				break;
			case 18:
				if (instance.invBelt == null)
				{
					instance.invBelt = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.invBelt, isDelta);
				}
				break;
			case 26:
				if (instance.invWear == null)
				{
					instance.invWear = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.invWear, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerInventory DeserializeLength(BufferStream stream, int length, PlayerInventory instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.invMain == null)
				{
					instance.invMain = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.invMain, isDelta);
				}
				break;
			case 18:
				if (instance.invBelt == null)
				{
					instance.invBelt = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.invBelt, isDelta);
				}
				break;
			case 26:
				if (instance.invWear == null)
				{
					instance.invWear = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.invWear, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerInventory instance, PlayerInventory previous)
	{
		if (instance.invMain != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.SerializeDelta(stream, instance.invMain, previous.invMain);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.invBelt != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			ItemContainer.SerializeDelta(stream, instance.invBelt, previous.invBelt);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.invWear == null)
		{
			return;
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range3 = stream.GetRange(5);
		int position3 = stream.Position;
		ItemContainer.SerializeDelta(stream, instance.invWear, previous.invWear);
		int val3 = stream.Position - position3;
		Span<byte> span3 = range3.GetSpan();
		int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
		if (num3 < 5)
		{
			span3[num3 - 1] |= 128;
			while (num3 < 4)
			{
				span3[num3++] = 128;
			}
			span3[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, PlayerInventory instance)
	{
		if (instance.invMain != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.Serialize(stream, instance.invMain);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.invBelt != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			ItemContainer.Serialize(stream, instance.invBelt);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.invWear == null)
		{
			return;
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range3 = stream.GetRange(5);
		int position3 = stream.Position;
		ItemContainer.Serialize(stream, instance.invWear);
		int val3 = stream.Position - position3;
		Span<byte> span3 = range3.GetSpan();
		int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
		if (num3 < 5)
		{
			span3[num3 - 1] |= 128;
			while (num3 < 4)
			{
				span3[num3++] = 128;
			}
			span3[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		invMain?.InspectUids(action);
		invBelt?.InspectUids(action);
		invWear?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PlayerLifeStory : IDisposable, IPooled, IProto<PlayerLifeStory>, IProto
{
	public class DeathInfo : IDisposable, IPooled, IProto<DeathInfo>, IProto
	{
		[NonSerialized]
		public string attackerName;

		[NonSerialized]
		public ulong attackerSteamID;

		[NonSerialized]
		public string hitBone;

		[NonSerialized]
		public string inflictorName;

		[NonSerialized]
		public int lastDamageType;

		[NonSerialized]
		public float attackerDistance;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(DeathInfo instance)
		{
			if (instance.ShouldPool)
			{
				instance.attackerName = string.Empty;
				instance.attackerSteamID = 0uL;
				instance.hitBone = string.Empty;
				instance.inflictorName = string.Empty;
				instance.lastDamageType = 0;
				instance.attackerDistance = 0f;
				Pool.Free<DeathInfo>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose DeathInfo with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(DeathInfo instance)
		{
			instance.attackerName = attackerName;
			instance.attackerSteamID = attackerSteamID;
			instance.hitBone = hitBone;
			instance.inflictorName = inflictorName;
			instance.lastDamageType = lastDamageType;
			instance.attackerDistance = attackerDistance;
		}

		public DeathInfo Copy()
		{
			DeathInfo deathInfo = Pool.Get<DeathInfo>();
			CopyTo(deathInfo);
			return deathInfo;
		}

		public static DeathInfo Deserialize(BufferStream stream)
		{
			DeathInfo deathInfo = Pool.Get<DeathInfo>();
			Deserialize(stream, deathInfo, isDelta: false);
			return deathInfo;
		}

		public static DeathInfo DeserializeLengthDelimited(BufferStream stream)
		{
			DeathInfo deathInfo = Pool.Get<DeathInfo>();
			DeserializeLengthDelimited(stream, deathInfo, isDelta: false);
			return deathInfo;
		}

		public static DeathInfo DeserializeLength(BufferStream stream, int length)
		{
			DeathInfo deathInfo = Pool.Get<DeathInfo>();
			DeserializeLength(stream, length, deathInfo, isDelta: false);
			return deathInfo;
		}

		public static DeathInfo Deserialize(byte[] buffer)
		{
			DeathInfo deathInfo = Pool.Get<DeathInfo>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, deathInfo, isDelta: false);
			return deathInfo;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, DeathInfo previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static DeathInfo Deserialize(BufferStream stream, DeathInfo instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.attackerName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.attackerSteamID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					instance.hitBone = ProtocolParser.ReadString(stream);
					continue;
				case 34:
					instance.inflictorName = ProtocolParser.ReadString(stream);
					continue;
				case 40:
					instance.lastDamageType = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 53:
					instance.attackerDistance = ProtocolParser.ReadSingle(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static DeathInfo DeserializeLengthDelimited(BufferStream stream, DeathInfo instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.attackerName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.attackerSteamID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					instance.hitBone = ProtocolParser.ReadString(stream);
					continue;
				case 34:
					instance.inflictorName = ProtocolParser.ReadString(stream);
					continue;
				case 40:
					instance.lastDamageType = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 53:
					instance.attackerDistance = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static DeathInfo DeserializeLength(BufferStream stream, int length, DeathInfo instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.attackerName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.attackerSteamID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					instance.hitBone = ProtocolParser.ReadString(stream);
					continue;
				case 34:
					instance.inflictorName = ProtocolParser.ReadString(stream);
					continue;
				case 40:
					instance.lastDamageType = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 53:
					instance.attackerDistance = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, DeathInfo instance, DeathInfo previous)
		{
			if (instance.attackerName != null && instance.attackerName != previous.attackerName)
			{
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.attackerName);
			}
			if (instance.attackerSteamID != previous.attackerSteamID)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.attackerSteamID);
			}
			if (instance.hitBone != null && instance.hitBone != previous.hitBone)
			{
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, instance.hitBone);
			}
			if (instance.inflictorName != null && instance.inflictorName != previous.inflictorName)
			{
				stream.WriteByte(34);
				ProtocolParser.WriteString(stream, instance.inflictorName);
			}
			if (instance.lastDamageType != previous.lastDamageType)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.lastDamageType);
			}
			if (instance.attackerDistance != previous.attackerDistance)
			{
				stream.WriteByte(53);
				ProtocolParser.WriteSingle(stream, instance.attackerDistance);
			}
		}

		public static void Serialize(BufferStream stream, DeathInfo instance)
		{
			if (instance.attackerName != null)
			{
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.attackerName);
			}
			if (instance.attackerSteamID != 0L)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.attackerSteamID);
			}
			if (instance.hitBone != null)
			{
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, instance.hitBone);
			}
			if (instance.inflictorName != null)
			{
				stream.WriteByte(34);
				ProtocolParser.WriteString(stream, instance.inflictorName);
			}
			if (instance.lastDamageType != 0)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.lastDamageType);
			}
			if (instance.attackerDistance != 0f)
			{
				stream.WriteByte(53);
				ProtocolParser.WriteSingle(stream, instance.attackerDistance);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class GenericStat : IDisposable, IPooled, IProto<GenericStat>, IProto
	{
		[NonSerialized]
		public string key;

		[NonSerialized]
		public int value;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(GenericStat instance)
		{
			if (instance.ShouldPool)
			{
				instance.key = string.Empty;
				instance.value = 0;
				Pool.Free<GenericStat>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose GenericStat with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(GenericStat instance)
		{
			instance.key = key;
			instance.value = value;
		}

		public GenericStat Copy()
		{
			GenericStat genericStat = Pool.Get<GenericStat>();
			CopyTo(genericStat);
			return genericStat;
		}

		public static GenericStat Deserialize(BufferStream stream)
		{
			GenericStat genericStat = Pool.Get<GenericStat>();
			Deserialize(stream, genericStat, isDelta: false);
			return genericStat;
		}

		public static GenericStat DeserializeLengthDelimited(BufferStream stream)
		{
			GenericStat genericStat = Pool.Get<GenericStat>();
			DeserializeLengthDelimited(stream, genericStat, isDelta: false);
			return genericStat;
		}

		public static GenericStat DeserializeLength(BufferStream stream, int length)
		{
			GenericStat genericStat = Pool.Get<GenericStat>();
			DeserializeLength(stream, length, genericStat, isDelta: false);
			return genericStat;
		}

		public static GenericStat Deserialize(byte[] buffer)
		{
			GenericStat genericStat = Pool.Get<GenericStat>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, genericStat, isDelta: false);
			return genericStat;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, GenericStat previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static GenericStat Deserialize(BufferStream stream, GenericStat instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.key = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.value = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static GenericStat DeserializeLengthDelimited(BufferStream stream, GenericStat instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.key = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.value = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static GenericStat DeserializeLength(BufferStream stream, int length, GenericStat instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.key = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.value = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, GenericStat instance, GenericStat previous)
		{
			if (instance.key != previous.key)
			{
				if (instance.key == null)
				{
					throw new ArgumentNullException("key", "Required by proto specification.");
				}
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.key);
			}
			if (instance.value != previous.value)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.value);
			}
		}

		public static void Serialize(BufferStream stream, GenericStat instance)
		{
			if (instance.key == null)
			{
				throw new ArgumentNullException("key", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.key);
			if (instance.value != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.value);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class WeaponStats : IDisposable, IPooled, IProto<WeaponStats>, IProto
	{
		[NonSerialized]
		public string weaponName;

		[NonSerialized]
		public ulong shotsFired;

		[NonSerialized]
		public ulong shotsHit;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(WeaponStats instance)
		{
			if (instance.ShouldPool)
			{
				instance.weaponName = string.Empty;
				instance.shotsFired = 0uL;
				instance.shotsHit = 0uL;
				Pool.Free<WeaponStats>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose WeaponStats with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(WeaponStats instance)
		{
			instance.weaponName = weaponName;
			instance.shotsFired = shotsFired;
			instance.shotsHit = shotsHit;
		}

		public WeaponStats Copy()
		{
			WeaponStats weaponStats = Pool.Get<WeaponStats>();
			CopyTo(weaponStats);
			return weaponStats;
		}

		public static WeaponStats Deserialize(BufferStream stream)
		{
			WeaponStats weaponStats = Pool.Get<WeaponStats>();
			Deserialize(stream, weaponStats, isDelta: false);
			return weaponStats;
		}

		public static WeaponStats DeserializeLengthDelimited(BufferStream stream)
		{
			WeaponStats weaponStats = Pool.Get<WeaponStats>();
			DeserializeLengthDelimited(stream, weaponStats, isDelta: false);
			return weaponStats;
		}

		public static WeaponStats DeserializeLength(BufferStream stream, int length)
		{
			WeaponStats weaponStats = Pool.Get<WeaponStats>();
			DeserializeLength(stream, length, weaponStats, isDelta: false);
			return weaponStats;
		}

		public static WeaponStats Deserialize(byte[] buffer)
		{
			WeaponStats weaponStats = Pool.Get<WeaponStats>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, weaponStats, isDelta: false);
			return weaponStats;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, WeaponStats previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static WeaponStats Deserialize(BufferStream stream, WeaponStats instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.weaponName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.shotsFired = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.shotsHit = ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static WeaponStats DeserializeLengthDelimited(BufferStream stream, WeaponStats instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.weaponName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.shotsFired = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.shotsHit = ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static WeaponStats DeserializeLength(BufferStream stream, int length, WeaponStats instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.weaponName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.shotsFired = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.shotsHit = ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, WeaponStats instance, WeaponStats previous)
		{
			if (instance.weaponName != previous.weaponName)
			{
				if (instance.weaponName == null)
				{
					throw new ArgumentNullException("weaponName", "Required by proto specification.");
				}
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.weaponName);
			}
			if (instance.shotsFired != previous.shotsFired)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.shotsFired);
			}
			if (instance.shotsHit != previous.shotsHit)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, instance.shotsHit);
			}
		}

		public static void Serialize(BufferStream stream, WeaponStats instance)
		{
			if (instance.weaponName == null)
			{
				throw new ArgumentNullException("weaponName", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.weaponName);
			if (instance.shotsFired != 0L)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.shotsFired);
			}
			if (instance.shotsHit != 0L)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, instance.shotsHit);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public float secondsAlive;

	[NonSerialized]
	public float metersWalked;

	[NonSerialized]
	public float metersRun;

	[NonSerialized]
	public float secondsSleeping;

	[NonSerialized]
	public uint timeBorn;

	[NonSerialized]
	public uint timeDied;

	[NonSerialized]
	public float secondsWilderness;

	[NonSerialized]
	public float secondsSwimming;

	[NonSerialized]
	public float secondsInBase;

	[NonSerialized]
	public float secondsInMonument;

	[NonSerialized]
	public float secondsFlying;

	[NonSerialized]
	public float secondsBoating;

	[NonSerialized]
	public float secondsDriving;

	[NonSerialized]
	public float totalDamageTaken;

	[NonSerialized]
	public float totalHealing;

	[NonSerialized]
	public DeathInfo deathInfo;

	[NonSerialized]
	public List<WeaponStats> weaponStats;

	[NonSerialized]
	public int killedPlayers;

	[NonSerialized]
	public int killedScientists;

	[NonSerialized]
	public int killedAnimals;

	[NonSerialized]
	public List<GenericStat> genericStats;

	[NonSerialized]
	public string wipeId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerLifeStory instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.secondsAlive = 0f;
		instance.metersWalked = 0f;
		instance.metersRun = 0f;
		instance.secondsSleeping = 0f;
		instance.timeBorn = 0u;
		instance.timeDied = 0u;
		instance.secondsWilderness = 0f;
		instance.secondsSwimming = 0f;
		instance.secondsInBase = 0f;
		instance.secondsInMonument = 0f;
		instance.secondsFlying = 0f;
		instance.secondsBoating = 0f;
		instance.secondsDriving = 0f;
		instance.totalDamageTaken = 0f;
		instance.totalHealing = 0f;
		if (instance.deathInfo != null)
		{
			instance.deathInfo.ResetToPool();
			instance.deathInfo = null;
		}
		if (instance.weaponStats != null)
		{
			for (int i = 0; i < instance.weaponStats.Count; i++)
			{
				if (instance.weaponStats[i] != null)
				{
					instance.weaponStats[i].ResetToPool();
					instance.weaponStats[i] = null;
				}
			}
			List<WeaponStats> list = instance.weaponStats;
			Pool.Free<WeaponStats>(ref list, false);
			instance.weaponStats = list;
		}
		instance.killedPlayers = 0;
		instance.killedScientists = 0;
		instance.killedAnimals = 0;
		if (instance.genericStats != null)
		{
			for (int j = 0; j < instance.genericStats.Count; j++)
			{
				if (instance.genericStats[j] != null)
				{
					instance.genericStats[j].ResetToPool();
					instance.genericStats[j] = null;
				}
			}
			List<GenericStat> list2 = instance.genericStats;
			Pool.Free<GenericStat>(ref list2, false);
			instance.genericStats = list2;
		}
		instance.wipeId = string.Empty;
		Pool.Free<PlayerLifeStory>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerLifeStory with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerLifeStory instance)
	{
		instance.secondsAlive = secondsAlive;
		instance.metersWalked = metersWalked;
		instance.metersRun = metersRun;
		instance.secondsSleeping = secondsSleeping;
		instance.timeBorn = timeBorn;
		instance.timeDied = timeDied;
		instance.secondsWilderness = secondsWilderness;
		instance.secondsSwimming = secondsSwimming;
		instance.secondsInBase = secondsInBase;
		instance.secondsInMonument = secondsInMonument;
		instance.secondsFlying = secondsFlying;
		instance.secondsBoating = secondsBoating;
		instance.secondsDriving = secondsDriving;
		instance.totalDamageTaken = totalDamageTaken;
		instance.totalHealing = totalHealing;
		if (deathInfo != null)
		{
			if (instance.deathInfo == null)
			{
				instance.deathInfo = deathInfo.Copy();
			}
			else
			{
				deathInfo.CopyTo(instance.deathInfo);
			}
		}
		else
		{
			instance.deathInfo = null;
		}
		if (weaponStats != null)
		{
			instance.weaponStats = Pool.Get<List<WeaponStats>>();
			for (int i = 0; i < weaponStats.Count; i++)
			{
				WeaponStats item = weaponStats[i].Copy();
				instance.weaponStats.Add(item);
			}
		}
		else
		{
			instance.weaponStats = null;
		}
		instance.killedPlayers = killedPlayers;
		instance.killedScientists = killedScientists;
		instance.killedAnimals = killedAnimals;
		if (genericStats != null)
		{
			instance.genericStats = Pool.Get<List<GenericStat>>();
			for (int j = 0; j < genericStats.Count; j++)
			{
				GenericStat item2 = genericStats[j].Copy();
				instance.genericStats.Add(item2);
			}
		}
		else
		{
			instance.genericStats = null;
		}
		instance.wipeId = wipeId;
	}

	public PlayerLifeStory Copy()
	{
		PlayerLifeStory playerLifeStory = Pool.Get<PlayerLifeStory>();
		CopyTo(playerLifeStory);
		return playerLifeStory;
	}

	public static PlayerLifeStory Deserialize(BufferStream stream)
	{
		PlayerLifeStory playerLifeStory = Pool.Get<PlayerLifeStory>();
		Deserialize(stream, playerLifeStory, isDelta: false);
		return playerLifeStory;
	}

	public static PlayerLifeStory DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerLifeStory playerLifeStory = Pool.Get<PlayerLifeStory>();
		DeserializeLengthDelimited(stream, playerLifeStory, isDelta: false);
		return playerLifeStory;
	}

	public static PlayerLifeStory DeserializeLength(BufferStream stream, int length)
	{
		PlayerLifeStory playerLifeStory = Pool.Get<PlayerLifeStory>();
		DeserializeLength(stream, length, playerLifeStory, isDelta: false);
		return playerLifeStory;
	}

	public static PlayerLifeStory Deserialize(byte[] buffer)
	{
		PlayerLifeStory playerLifeStory = Pool.Get<PlayerLifeStory>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerLifeStory, isDelta: false);
		return playerLifeStory;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerLifeStory previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerLifeStory Deserialize(BufferStream stream, PlayerLifeStory instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.weaponStats == null)
			{
				instance.weaponStats = Pool.Get<List<WeaponStats>>();
			}
			if (instance.genericStats == null)
			{
				instance.genericStats = Pool.Get<List<GenericStat>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			if (num == -1 || num == 0)
			{
				break;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 100u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsAlive = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 101u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.metersWalked = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 102u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.metersRun = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 103u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsSleeping = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 104u:
				if (key.WireType == Wire.Varint)
				{
					instance.timeBorn = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 105u:
				if (key.WireType == Wire.Varint)
				{
					instance.timeDied = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 110u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsWilderness = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 111u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsSwimming = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 112u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsInBase = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 113u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsInMonument = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 114u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsFlying = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 115u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsBoating = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 116u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsDriving = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 150u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.totalDamageTaken = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 151u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.totalHealing = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 200u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.deathInfo == null)
					{
						instance.deathInfo = DeathInfo.DeserializeLengthDelimited(stream);
					}
					else
					{
						DeathInfo.DeserializeLengthDelimited(stream, instance.deathInfo, isDelta);
					}
				}
				break;
			case 300u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.weaponStats.Add(WeaponStats.DeserializeLengthDelimited(stream));
				}
				break;
			case 301u:
				if (key.WireType == Wire.Varint)
				{
					instance.killedPlayers = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 302u:
				if (key.WireType == Wire.Varint)
				{
					instance.killedScientists = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 303u:
				if (key.WireType == Wire.Varint)
				{
					instance.killedAnimals = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 400u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.genericStats.Add(GenericStat.DeserializeLengthDelimited(stream));
				}
				break;
			case 401u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.wipeId = ProtocolParser.ReadString(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	public static PlayerLifeStory DeserializeLengthDelimited(BufferStream stream, PlayerLifeStory instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.weaponStats == null)
			{
				instance.weaponStats = Pool.Get<List<WeaponStats>>();
			}
			if (instance.genericStats == null)
			{
				instance.genericStats = Pool.Get<List<GenericStat>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 100u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsAlive = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 101u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.metersWalked = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 102u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.metersRun = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 103u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsSleeping = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 104u:
				if (key.WireType == Wire.Varint)
				{
					instance.timeBorn = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 105u:
				if (key.WireType == Wire.Varint)
				{
					instance.timeDied = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 110u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsWilderness = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 111u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsSwimming = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 112u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsInBase = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 113u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsInMonument = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 114u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsFlying = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 115u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsBoating = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 116u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsDriving = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 150u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.totalDamageTaken = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 151u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.totalHealing = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 200u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.deathInfo == null)
					{
						instance.deathInfo = DeathInfo.DeserializeLengthDelimited(stream);
					}
					else
					{
						DeathInfo.DeserializeLengthDelimited(stream, instance.deathInfo, isDelta);
					}
				}
				break;
			case 300u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.weaponStats.Add(WeaponStats.DeserializeLengthDelimited(stream));
				}
				break;
			case 301u:
				if (key.WireType == Wire.Varint)
				{
					instance.killedPlayers = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 302u:
				if (key.WireType == Wire.Varint)
				{
					instance.killedScientists = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 303u:
				if (key.WireType == Wire.Varint)
				{
					instance.killedAnimals = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 400u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.genericStats.Add(GenericStat.DeserializeLengthDelimited(stream));
				}
				break;
			case 401u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.wipeId = ProtocolParser.ReadString(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	public static PlayerLifeStory DeserializeLength(BufferStream stream, int length, PlayerLifeStory instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.weaponStats == null)
			{
				instance.weaponStats = Pool.Get<List<WeaponStats>>();
			}
			if (instance.genericStats == null)
			{
				instance.genericStats = Pool.Get<List<GenericStat>>();
			}
		}
		long num = stream.Position + length;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 100u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsAlive = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 101u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.metersWalked = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 102u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.metersRun = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 103u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsSleeping = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 104u:
				if (key.WireType == Wire.Varint)
				{
					instance.timeBorn = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 105u:
				if (key.WireType == Wire.Varint)
				{
					instance.timeDied = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 110u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsWilderness = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 111u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsSwimming = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 112u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsInBase = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 113u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsInMonument = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 114u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsFlying = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 115u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsBoating = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 116u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.secondsDriving = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 150u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.totalDamageTaken = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 151u:
				if (key.WireType == Wire.Fixed32)
				{
					instance.totalHealing = ProtocolParser.ReadSingle(stream);
				}
				break;
			case 200u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.deathInfo == null)
					{
						instance.deathInfo = DeathInfo.DeserializeLengthDelimited(stream);
					}
					else
					{
						DeathInfo.DeserializeLengthDelimited(stream, instance.deathInfo, isDelta);
					}
				}
				break;
			case 300u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.weaponStats.Add(WeaponStats.DeserializeLengthDelimited(stream));
				}
				break;
			case 301u:
				if (key.WireType == Wire.Varint)
				{
					instance.killedPlayers = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 302u:
				if (key.WireType == Wire.Varint)
				{
					instance.killedScientists = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 303u:
				if (key.WireType == Wire.Varint)
				{
					instance.killedAnimals = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 400u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.genericStats.Add(GenericStat.DeserializeLengthDelimited(stream));
				}
				break;
			case 401u:
				if (key.WireType == Wire.LengthDelimited)
				{
					instance.wipeId = ProtocolParser.ReadString(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerLifeStory instance, PlayerLifeStory previous)
	{
		if (instance.secondsAlive != previous.secondsAlive)
		{
			stream.WriteByte(165);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.secondsAlive);
		}
		if (instance.metersWalked != previous.metersWalked)
		{
			stream.WriteByte(173);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.metersWalked);
		}
		if (instance.metersRun != previous.metersRun)
		{
			stream.WriteByte(181);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.metersRun);
		}
		if (instance.secondsSleeping != previous.secondsSleeping)
		{
			stream.WriteByte(189);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.secondsSleeping);
		}
		if (instance.timeBorn != previous.timeBorn)
		{
			stream.WriteByte(192);
			stream.WriteByte(6);
			ProtocolParser.WriteUInt32(stream, instance.timeBorn);
		}
		if (instance.timeDied != previous.timeDied)
		{
			stream.WriteByte(200);
			stream.WriteByte(6);
			ProtocolParser.WriteUInt32(stream, instance.timeDied);
		}
		if (instance.secondsWilderness != previous.secondsWilderness)
		{
			stream.WriteByte(245);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.secondsWilderness);
		}
		if (instance.secondsSwimming != previous.secondsSwimming)
		{
			stream.WriteByte(253);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.secondsSwimming);
		}
		if (instance.secondsInBase != previous.secondsInBase)
		{
			stream.WriteByte(133);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsInBase);
		}
		if (instance.secondsInMonument != previous.secondsInMonument)
		{
			stream.WriteByte(141);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsInMonument);
		}
		if (instance.secondsFlying != previous.secondsFlying)
		{
			stream.WriteByte(149);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsFlying);
		}
		if (instance.secondsBoating != previous.secondsBoating)
		{
			stream.WriteByte(157);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsBoating);
		}
		if (instance.secondsDriving != previous.secondsDriving)
		{
			stream.WriteByte(165);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsDriving);
		}
		if (instance.totalDamageTaken != previous.totalDamageTaken)
		{
			stream.WriteByte(181);
			stream.WriteByte(9);
			ProtocolParser.WriteSingle(stream, instance.totalDamageTaken);
		}
		if (instance.totalHealing != previous.totalHealing)
		{
			stream.WriteByte(189);
			stream.WriteByte(9);
			ProtocolParser.WriteSingle(stream, instance.totalHealing);
		}
		if (instance.deathInfo != null)
		{
			stream.WriteByte(194);
			stream.WriteByte(12);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			DeathInfo.SerializeDelta(stream, instance.deathInfo, previous.deathInfo);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.weaponStats != null)
		{
			for (int i = 0; i < instance.weaponStats.Count; i++)
			{
				WeaponStats weaponStats = instance.weaponStats[i];
				stream.WriteByte(226);
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				WeaponStats.SerializeDelta(stream, weaponStats, weaponStats);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.killedPlayers != previous.killedPlayers)
		{
			stream.WriteByte(232);
			stream.WriteByte(18);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.killedPlayers);
		}
		if (instance.killedScientists != previous.killedScientists)
		{
			stream.WriteByte(240);
			stream.WriteByte(18);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.killedScientists);
		}
		if (instance.killedAnimals != previous.killedAnimals)
		{
			stream.WriteByte(248);
			stream.WriteByte(18);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.killedAnimals);
		}
		if (instance.genericStats != null)
		{
			for (int j = 0; j < instance.genericStats.Count; j++)
			{
				GenericStat genericStat = instance.genericStats[j];
				stream.WriteByte(130);
				stream.WriteByte(25);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int position3 = stream.Position;
				GenericStat.SerializeDelta(stream, genericStat, genericStat);
				int val3 = stream.Position - position3;
				Span<byte> span3 = range3.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
				if (num3 < 5)
				{
					span3[num3 - 1] |= 128;
					while (num3 < 4)
					{
						span3[num3++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		if (instance.wipeId != null && instance.wipeId != previous.wipeId)
		{
			stream.WriteByte(138);
			stream.WriteByte(25);
			ProtocolParser.WriteString(stream, instance.wipeId);
		}
	}

	public static void Serialize(BufferStream stream, PlayerLifeStory instance)
	{
		if (instance.secondsAlive != 0f)
		{
			stream.WriteByte(165);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.secondsAlive);
		}
		if (instance.metersWalked != 0f)
		{
			stream.WriteByte(173);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.metersWalked);
		}
		if (instance.metersRun != 0f)
		{
			stream.WriteByte(181);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.metersRun);
		}
		if (instance.secondsSleeping != 0f)
		{
			stream.WriteByte(189);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.secondsSleeping);
		}
		if (instance.timeBorn != 0)
		{
			stream.WriteByte(192);
			stream.WriteByte(6);
			ProtocolParser.WriteUInt32(stream, instance.timeBorn);
		}
		if (instance.timeDied != 0)
		{
			stream.WriteByte(200);
			stream.WriteByte(6);
			ProtocolParser.WriteUInt32(stream, instance.timeDied);
		}
		if (instance.secondsWilderness != 0f)
		{
			stream.WriteByte(245);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.secondsWilderness);
		}
		if (instance.secondsSwimming != 0f)
		{
			stream.WriteByte(253);
			stream.WriteByte(6);
			ProtocolParser.WriteSingle(stream, instance.secondsSwimming);
		}
		if (instance.secondsInBase != 0f)
		{
			stream.WriteByte(133);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsInBase);
		}
		if (instance.secondsInMonument != 0f)
		{
			stream.WriteByte(141);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsInMonument);
		}
		if (instance.secondsFlying != 0f)
		{
			stream.WriteByte(149);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsFlying);
		}
		if (instance.secondsBoating != 0f)
		{
			stream.WriteByte(157);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsBoating);
		}
		if (instance.secondsDriving != 0f)
		{
			stream.WriteByte(165);
			stream.WriteByte(7);
			ProtocolParser.WriteSingle(stream, instance.secondsDriving);
		}
		if (instance.totalDamageTaken != 0f)
		{
			stream.WriteByte(181);
			stream.WriteByte(9);
			ProtocolParser.WriteSingle(stream, instance.totalDamageTaken);
		}
		if (instance.totalHealing != 0f)
		{
			stream.WriteByte(189);
			stream.WriteByte(9);
			ProtocolParser.WriteSingle(stream, instance.totalHealing);
		}
		if (instance.deathInfo != null)
		{
			stream.WriteByte(194);
			stream.WriteByte(12);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			DeathInfo.Serialize(stream, instance.deathInfo);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.weaponStats != null)
		{
			for (int i = 0; i < instance.weaponStats.Count; i++)
			{
				WeaponStats instance2 = instance.weaponStats[i];
				stream.WriteByte(226);
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				WeaponStats.Serialize(stream, instance2);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.killedPlayers != 0)
		{
			stream.WriteByte(232);
			stream.WriteByte(18);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.killedPlayers);
		}
		if (instance.killedScientists != 0)
		{
			stream.WriteByte(240);
			stream.WriteByte(18);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.killedScientists);
		}
		if (instance.killedAnimals != 0)
		{
			stream.WriteByte(248);
			stream.WriteByte(18);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.killedAnimals);
		}
		if (instance.genericStats != null)
		{
			for (int j = 0; j < instance.genericStats.Count; j++)
			{
				GenericStat instance3 = instance.genericStats[j];
				stream.WriteByte(130);
				stream.WriteByte(25);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int position3 = stream.Position;
				GenericStat.Serialize(stream, instance3);
				int val3 = stream.Position - position3;
				Span<byte> span3 = range3.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
				if (num3 < 5)
				{
					span3[num3 - 1] |= 128;
					while (num3 < 4)
					{
						span3[num3++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		if (instance.wipeId != null)
		{
			stream.WriteByte(138);
			stream.WriteByte(25);
			ProtocolParser.WriteString(stream, instance.wipeId);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		deathInfo?.InspectUids(action);
		if (weaponStats != null)
		{
			for (int i = 0; i < weaponStats.Count; i++)
			{
				weaponStats[i]?.InspectUids(action);
			}
		}
		if (genericStats != null)
		{
			for (int j = 0; j < genericStats.Count; j++)
			{
				genericStats[j]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PlayerMetabolism : IDisposable, IPooled, IProto<PlayerMetabolism>, IProto
{
	[NonSerialized]
	public float health;

	[NonSerialized]
	public float calories;

	[NonSerialized]
	public float hydration;

	[NonSerialized]
	public float heartrate;

	[NonSerialized]
	public float temperature;

	[NonSerialized]
	public float poison;

	[NonSerialized]
	public float radiation_level;

	[NonSerialized]
	public float wetness;

	[NonSerialized]
	public float dirtyness;

	[NonSerialized]
	public float oxygen;

	[NonSerialized]
	public float bleeding;

	[NonSerialized]
	public float radiation_poisoning;

	[NonSerialized]
	public float comfort;

	[NonSerialized]
	public float pending_health;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerMetabolism instance)
	{
		if (instance.ShouldPool)
		{
			instance.health = 0f;
			instance.calories = 0f;
			instance.hydration = 0f;
			instance.heartrate = 0f;
			instance.temperature = 0f;
			instance.poison = 0f;
			instance.radiation_level = 0f;
			instance.wetness = 0f;
			instance.dirtyness = 0f;
			instance.oxygen = 0f;
			instance.bleeding = 0f;
			instance.radiation_poisoning = 0f;
			instance.comfort = 0f;
			instance.pending_health = 0f;
			Pool.Free<PlayerMetabolism>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerMetabolism with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerMetabolism instance)
	{
		instance.health = health;
		instance.calories = calories;
		instance.hydration = hydration;
		instance.heartrate = heartrate;
		instance.temperature = temperature;
		instance.poison = poison;
		instance.radiation_level = radiation_level;
		instance.wetness = wetness;
		instance.dirtyness = dirtyness;
		instance.oxygen = oxygen;
		instance.bleeding = bleeding;
		instance.radiation_poisoning = radiation_poisoning;
		instance.comfort = comfort;
		instance.pending_health = pending_health;
	}

	public PlayerMetabolism Copy()
	{
		PlayerMetabolism playerMetabolism = Pool.Get<PlayerMetabolism>();
		CopyTo(playerMetabolism);
		return playerMetabolism;
	}

	public static PlayerMetabolism Deserialize(BufferStream stream)
	{
		PlayerMetabolism playerMetabolism = Pool.Get<PlayerMetabolism>();
		Deserialize(stream, playerMetabolism, isDelta: false);
		return playerMetabolism;
	}

	public static PlayerMetabolism DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerMetabolism playerMetabolism = Pool.Get<PlayerMetabolism>();
		DeserializeLengthDelimited(stream, playerMetabolism, isDelta: false);
		return playerMetabolism;
	}

	public static PlayerMetabolism DeserializeLength(BufferStream stream, int length)
	{
		PlayerMetabolism playerMetabolism = Pool.Get<PlayerMetabolism>();
		DeserializeLength(stream, length, playerMetabolism, isDelta: false);
		return playerMetabolism;
	}

	public static PlayerMetabolism Deserialize(byte[] buffer)
	{
		PlayerMetabolism playerMetabolism = Pool.Get<PlayerMetabolism>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerMetabolism, isDelta: false);
		return playerMetabolism;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerMetabolism previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerMetabolism Deserialize(BufferStream stream, PlayerMetabolism instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.calories = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.hydration = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.heartrate = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.temperature = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.poison = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.radiation_level = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.wetness = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.dirtyness = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.oxygen = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.bleeding = ProtocolParser.ReadSingle(stream);
				continue;
			case 101:
				instance.radiation_poisoning = ProtocolParser.ReadSingle(stream);
				continue;
			case 109:
				instance.comfort = ProtocolParser.ReadSingle(stream);
				continue;
			case 117:
				instance.pending_health = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerMetabolism DeserializeLengthDelimited(BufferStream stream, PlayerMetabolism instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.calories = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.hydration = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.heartrate = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.temperature = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.poison = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.radiation_level = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.wetness = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.dirtyness = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.oxygen = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.bleeding = ProtocolParser.ReadSingle(stream);
				continue;
			case 101:
				instance.radiation_poisoning = ProtocolParser.ReadSingle(stream);
				continue;
			case 109:
				instance.comfort = ProtocolParser.ReadSingle(stream);
				continue;
			case 117:
				instance.pending_health = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerMetabolism DeserializeLength(BufferStream stream, int length, PlayerMetabolism instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.calories = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.hydration = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.heartrate = ProtocolParser.ReadSingle(stream);
				continue;
			case 45:
				instance.temperature = ProtocolParser.ReadSingle(stream);
				continue;
			case 53:
				instance.poison = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.radiation_level = ProtocolParser.ReadSingle(stream);
				continue;
			case 69:
				instance.wetness = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.dirtyness = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.oxygen = ProtocolParser.ReadSingle(stream);
				continue;
			case 93:
				instance.bleeding = ProtocolParser.ReadSingle(stream);
				continue;
			case 101:
				instance.radiation_poisoning = ProtocolParser.ReadSingle(stream);
				continue;
			case 109:
				instance.comfort = ProtocolParser.ReadSingle(stream);
				continue;
			case 117:
				instance.pending_health = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerMetabolism instance, PlayerMetabolism previous)
	{
		if (instance.health != previous.health)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.health);
		}
		if (instance.calories != previous.calories)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.calories);
		}
		if (instance.hydration != previous.hydration)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.hydration);
		}
		if (instance.heartrate != previous.heartrate)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.heartrate);
		}
		if (instance.temperature != previous.temperature)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.temperature);
		}
		if (instance.poison != previous.poison)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.poison);
		}
		if (instance.radiation_level != previous.radiation_level)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.radiation_level);
		}
		if (instance.wetness != previous.wetness)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.wetness);
		}
		if (instance.dirtyness != previous.dirtyness)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.dirtyness);
		}
		if (instance.oxygen != previous.oxygen)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.oxygen);
		}
		if (instance.bleeding != previous.bleeding)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.bleeding);
		}
		if (instance.radiation_poisoning != previous.radiation_poisoning)
		{
			stream.WriteByte(101);
			ProtocolParser.WriteSingle(stream, instance.radiation_poisoning);
		}
		if (instance.comfort != previous.comfort)
		{
			stream.WriteByte(109);
			ProtocolParser.WriteSingle(stream, instance.comfort);
		}
		if (instance.pending_health != previous.pending_health)
		{
			stream.WriteByte(117);
			ProtocolParser.WriteSingle(stream, instance.pending_health);
		}
	}

	public static void Serialize(BufferStream stream, PlayerMetabolism instance)
	{
		if (instance.health != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.health);
		}
		if (instance.calories != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.calories);
		}
		if (instance.hydration != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.hydration);
		}
		if (instance.heartrate != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.heartrate);
		}
		if (instance.temperature != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.temperature);
		}
		if (instance.poison != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.poison);
		}
		if (instance.radiation_level != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.radiation_level);
		}
		if (instance.wetness != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.wetness);
		}
		if (instance.dirtyness != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.dirtyness);
		}
		if (instance.oxygen != 0f)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.oxygen);
		}
		if (instance.bleeding != 0f)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.bleeding);
		}
		if (instance.radiation_poisoning != 0f)
		{
			stream.WriteByte(101);
			ProtocolParser.WriteSingle(stream, instance.radiation_poisoning);
		}
		if (instance.comfort != 0f)
		{
			stream.WriteByte(109);
			ProtocolParser.WriteSingle(stream, instance.comfort);
		}
		if (instance.pending_health != 0f)
		{
			stream.WriteByte(117);
			ProtocolParser.WriteSingle(stream, instance.pending_health);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PlayerModifiers : IDisposable, IPooled, IProto<PlayerModifiers>, IProto
{
	[NonSerialized]
	public List<Modifier> modifiers;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerModifiers instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.modifiers != null)
		{
			for (int i = 0; i < instance.modifiers.Count; i++)
			{
				if (instance.modifiers[i] != null)
				{
					instance.modifiers[i].ResetToPool();
					instance.modifiers[i] = null;
				}
			}
			List<Modifier> list = instance.modifiers;
			Pool.Free<Modifier>(ref list, false);
			instance.modifiers = list;
		}
		Pool.Free<PlayerModifiers>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerModifiers with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerModifiers instance)
	{
		if (modifiers != null)
		{
			instance.modifiers = Pool.Get<List<Modifier>>();
			for (int i = 0; i < modifiers.Count; i++)
			{
				Modifier item = modifiers[i].Copy();
				instance.modifiers.Add(item);
			}
		}
		else
		{
			instance.modifiers = null;
		}
	}

	public PlayerModifiers Copy()
	{
		PlayerModifiers playerModifiers = Pool.Get<PlayerModifiers>();
		CopyTo(playerModifiers);
		return playerModifiers;
	}

	public static PlayerModifiers Deserialize(BufferStream stream)
	{
		PlayerModifiers playerModifiers = Pool.Get<PlayerModifiers>();
		Deserialize(stream, playerModifiers, isDelta: false);
		return playerModifiers;
	}

	public static PlayerModifiers DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerModifiers playerModifiers = Pool.Get<PlayerModifiers>();
		DeserializeLengthDelimited(stream, playerModifiers, isDelta: false);
		return playerModifiers;
	}

	public static PlayerModifiers DeserializeLength(BufferStream stream, int length)
	{
		PlayerModifiers playerModifiers = Pool.Get<PlayerModifiers>();
		DeserializeLength(stream, length, playerModifiers, isDelta: false);
		return playerModifiers;
	}

	public static PlayerModifiers Deserialize(byte[] buffer)
	{
		PlayerModifiers playerModifiers = Pool.Get<PlayerModifiers>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerModifiers, isDelta: false);
		return playerModifiers;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerModifiers previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerModifiers Deserialize(BufferStream stream, PlayerModifiers instance, bool isDelta)
	{
		if (!isDelta && instance.modifiers == null)
		{
			instance.modifiers = Pool.Get<List<Modifier>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.modifiers.Add(Modifier.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerModifiers DeserializeLengthDelimited(BufferStream stream, PlayerModifiers instance, bool isDelta)
	{
		if (!isDelta && instance.modifiers == null)
		{
			instance.modifiers = Pool.Get<List<Modifier>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.modifiers.Add(Modifier.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerModifiers DeserializeLength(BufferStream stream, int length, PlayerModifiers instance, bool isDelta)
	{
		if (!isDelta && instance.modifiers == null)
		{
			instance.modifiers = Pool.Get<List<Modifier>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.modifiers.Add(Modifier.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerModifiers instance, PlayerModifiers previous)
	{
		if (instance.modifiers == null)
		{
			return;
		}
		for (int i = 0; i < instance.modifiers.Count; i++)
		{
			Modifier modifier = instance.modifiers[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Modifier.SerializeDelta(stream, modifier, modifier);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modifiers (ProtoBuf.Modifier)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, PlayerModifiers instance)
	{
		if (instance.modifiers == null)
		{
			return;
		}
		for (int i = 0; i < instance.modifiers.Count; i++)
		{
			Modifier instance2 = instance.modifiers[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Modifier.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field modifiers (ProtoBuf.Modifier)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (modifiers != null)
		{
			for (int i = 0; i < modifiers.Count; i++)
			{
				modifiers[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PlayerNameID : IDisposable, IPooled, IProto<PlayerNameID>, IProto
{
	[NonSerialized]
	public string username;

	[NonSerialized]
	public ulong userid;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerNameID instance)
	{
		if (instance.ShouldPool)
		{
			instance.username = string.Empty;
			instance.userid = 0uL;
			Pool.Free<PlayerNameID>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerNameID with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerNameID instance)
	{
		instance.username = username;
		instance.userid = userid;
	}

	public PlayerNameID Copy()
	{
		PlayerNameID playerNameID = Pool.Get<PlayerNameID>();
		CopyTo(playerNameID);
		return playerNameID;
	}

	public static PlayerNameID Deserialize(BufferStream stream)
	{
		PlayerNameID playerNameID = Pool.Get<PlayerNameID>();
		Deserialize(stream, playerNameID, isDelta: false);
		return playerNameID;
	}

	public static PlayerNameID DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerNameID playerNameID = Pool.Get<PlayerNameID>();
		DeserializeLengthDelimited(stream, playerNameID, isDelta: false);
		return playerNameID;
	}

	public static PlayerNameID DeserializeLength(BufferStream stream, int length)
	{
		PlayerNameID playerNameID = Pool.Get<PlayerNameID>();
		DeserializeLength(stream, length, playerNameID, isDelta: false);
		return playerNameID;
	}

	public static PlayerNameID Deserialize(byte[] buffer)
	{
		PlayerNameID playerNameID = Pool.Get<PlayerNameID>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerNameID, isDelta: false);
		return playerNameID;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerNameID previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerNameID Deserialize(BufferStream stream, PlayerNameID instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.username = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerNameID DeserializeLengthDelimited(BufferStream stream, PlayerNameID instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.username = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerNameID DeserializeLength(BufferStream stream, int length, PlayerNameID instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.username = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerNameID instance, PlayerNameID previous)
	{
		if (instance.username != null && instance.username != previous.username)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.username);
		}
		if (instance.userid != previous.userid)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userid);
		}
	}

	public static void Serialize(BufferStream stream, PlayerNameID instance)
	{
		if (instance.username != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.username);
		}
		if (instance.userid != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userid);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class PlayerProjectileAttack : IDisposable, IPooled, IProto<PlayerProjectileAttack>, IProto
{
	[NonSerialized]
	public PlayerAttack playerAttack;

	[NonSerialized]
	public Vector3 hitVelocity;

	[NonSerialized]
	public float hitDistance;

	[NonSerialized]
	public float travelTime;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerProjectileAttack instance)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			if (instance.playerAttack != null)
			{
				instance.playerAttack.ResetToPool();
				instance.playerAttack = null;
			}
			instance.hitVelocity = default(Vector3);
			instance.hitDistance = 0f;
			instance.travelTime = 0f;
			Pool.Free<PlayerProjectileAttack>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerProjectileAttack with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerProjectileAttack instance)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if (playerAttack != null)
		{
			if (instance.playerAttack == null)
			{
				instance.playerAttack = playerAttack.Copy();
			}
			else
			{
				playerAttack.CopyTo(instance.playerAttack);
			}
		}
		else
		{
			instance.playerAttack = null;
		}
		instance.hitVelocity = hitVelocity;
		instance.hitDistance = hitDistance;
		instance.travelTime = travelTime;
	}

	public PlayerProjectileAttack Copy()
	{
		PlayerProjectileAttack playerProjectileAttack = Pool.Get<PlayerProjectileAttack>();
		CopyTo(playerProjectileAttack);
		return playerProjectileAttack;
	}

	public static PlayerProjectileAttack Deserialize(BufferStream stream)
	{
		PlayerProjectileAttack playerProjectileAttack = Pool.Get<PlayerProjectileAttack>();
		Deserialize(stream, playerProjectileAttack, isDelta: false);
		return playerProjectileAttack;
	}

	public static PlayerProjectileAttack DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerProjectileAttack playerProjectileAttack = Pool.Get<PlayerProjectileAttack>();
		DeserializeLengthDelimited(stream, playerProjectileAttack, isDelta: false);
		return playerProjectileAttack;
	}

	public static PlayerProjectileAttack DeserializeLength(BufferStream stream, int length)
	{
		PlayerProjectileAttack playerProjectileAttack = Pool.Get<PlayerProjectileAttack>();
		DeserializeLength(stream, length, playerProjectileAttack, isDelta: false);
		return playerProjectileAttack;
	}

	public static PlayerProjectileAttack Deserialize(byte[] buffer)
	{
		PlayerProjectileAttack playerProjectileAttack = Pool.Get<PlayerProjectileAttack>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerProjectileAttack, isDelta: false);
		return playerProjectileAttack;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerProjectileAttack previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerProjectileAttack Deserialize(BufferStream stream, PlayerProjectileAttack instance, bool isDelta)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.playerAttack == null)
				{
					instance.playerAttack = PlayerAttack.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerAttack.DeserializeLengthDelimited(stream, instance.playerAttack, isDelta);
				}
				break;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitVelocity, isDelta);
				break;
			case 29:
				instance.hitDistance = ProtocolParser.ReadSingle(stream);
				break;
			case 37:
				instance.travelTime = ProtocolParser.ReadSingle(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static PlayerProjectileAttack DeserializeLengthDelimited(BufferStream stream, PlayerProjectileAttack instance, bool isDelta)
	{
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.playerAttack == null)
				{
					instance.playerAttack = PlayerAttack.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerAttack.DeserializeLengthDelimited(stream, instance.playerAttack, isDelta);
				}
				break;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitVelocity, isDelta);
				break;
			case 29:
				instance.hitDistance = ProtocolParser.ReadSingle(stream);
				break;
			case 37:
				instance.travelTime = ProtocolParser.ReadSingle(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerProjectileAttack DeserializeLength(BufferStream stream, int length, PlayerProjectileAttack instance, bool isDelta)
	{
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.playerAttack == null)
				{
					instance.playerAttack = PlayerAttack.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerAttack.DeserializeLengthDelimited(stream, instance.playerAttack, isDelta);
				}
				break;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitVelocity, isDelta);
				break;
			case 29:
				instance.hitDistance = ProtocolParser.ReadSingle(stream);
				break;
			case 37:
				instance.travelTime = ProtocolParser.ReadSingle(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerProjectileAttack instance, PlayerProjectileAttack previous)
	{
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		if (instance.playerAttack == null)
		{
			throw new ArgumentNullException("playerAttack", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(2);
		int position = stream.Position;
		PlayerAttack.SerializeDelta(stream, instance.playerAttack, previous.playerAttack);
		int num = stream.Position - position;
		if (num > 16383)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerAttack (ProtoBuf.PlayerAttack)");
		}
		Span<byte> span = range.GetSpan();
		if (ProtocolParser.WriteUInt32((uint)num, span, 0) < 2)
		{
			span[0] |= 128;
			span[1] = 0;
		}
		if (instance.hitVelocity != previous.hitVelocity)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.hitVelocity, previous.hitVelocity);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitVelocity (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.hitDistance != previous.hitDistance)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.hitDistance);
		}
		if (instance.travelTime != previous.travelTime)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.travelTime);
		}
	}

	public static void Serialize(BufferStream stream, PlayerProjectileAttack instance)
	{
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		if (instance.playerAttack == null)
		{
			throw new ArgumentNullException("playerAttack", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(2);
		int position = stream.Position;
		PlayerAttack.Serialize(stream, instance.playerAttack);
		int num = stream.Position - position;
		if (num > 16383)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerAttack (ProtoBuf.PlayerAttack)");
		}
		Span<byte> span = range.GetSpan();
		if (ProtocolParser.WriteUInt32((uint)num, span, 0) < 2)
		{
			span[0] |= 128;
			span[1] = 0;
		}
		if (instance.hitVelocity != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.hitVelocity);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitVelocity (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.hitDistance != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.hitDistance);
		}
		if (instance.travelTime != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.travelTime);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		playerAttack?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class PlayerProjectileRicochet : IDisposable, IPooled, IProto<PlayerProjectileRicochet>, IProto
{
	[NonSerialized]
	public int projectileID;

	[NonSerialized]
	public Vector3 hitPosition;

	[NonSerialized]
	public Vector3 inVelocity;

	[NonSerialized]
	public Vector3 outVelocity;

	[NonSerialized]
	public Vector3 hitNormal;

	[NonSerialized]
	public float travelTime;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerProjectileRicochet instance)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.projectileID = 0;
			instance.hitPosition = default(Vector3);
			instance.inVelocity = default(Vector3);
			instance.outVelocity = default(Vector3);
			instance.hitNormal = default(Vector3);
			instance.travelTime = 0f;
			Pool.Free<PlayerProjectileRicochet>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerProjectileRicochet with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerProjectileRicochet instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		instance.projectileID = projectileID;
		instance.hitPosition = hitPosition;
		instance.inVelocity = inVelocity;
		instance.outVelocity = outVelocity;
		instance.hitNormal = hitNormal;
		instance.travelTime = travelTime;
	}

	public PlayerProjectileRicochet Copy()
	{
		PlayerProjectileRicochet playerProjectileRicochet = Pool.Get<PlayerProjectileRicochet>();
		CopyTo(playerProjectileRicochet);
		return playerProjectileRicochet;
	}

	public static PlayerProjectileRicochet Deserialize(BufferStream stream)
	{
		PlayerProjectileRicochet playerProjectileRicochet = Pool.Get<PlayerProjectileRicochet>();
		Deserialize(stream, playerProjectileRicochet, isDelta: false);
		return playerProjectileRicochet;
	}

	public static PlayerProjectileRicochet DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerProjectileRicochet playerProjectileRicochet = Pool.Get<PlayerProjectileRicochet>();
		DeserializeLengthDelimited(stream, playerProjectileRicochet, isDelta: false);
		return playerProjectileRicochet;
	}

	public static PlayerProjectileRicochet DeserializeLength(BufferStream stream, int length)
	{
		PlayerProjectileRicochet playerProjectileRicochet = Pool.Get<PlayerProjectileRicochet>();
		DeserializeLength(stream, length, playerProjectileRicochet, isDelta: false);
		return playerProjectileRicochet;
	}

	public static PlayerProjectileRicochet Deserialize(byte[] buffer)
	{
		PlayerProjectileRicochet playerProjectileRicochet = Pool.Get<PlayerProjectileRicochet>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerProjectileRicochet, isDelta: false);
		return playerProjectileRicochet;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerProjectileRicochet previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerProjectileRicochet Deserialize(BufferStream stream, PlayerProjectileRicochet instance, bool isDelta)
	{
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitPosition, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.inVelocity, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.outVelocity, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitNormal, isDelta);
				continue;
			case 53:
				instance.travelTime = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerProjectileRicochet DeserializeLengthDelimited(BufferStream stream, PlayerProjectileRicochet instance, bool isDelta)
	{
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitPosition, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.inVelocity, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.outVelocity, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitNormal, isDelta);
				continue;
			case 53:
				instance.travelTime = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerProjectileRicochet DeserializeLength(BufferStream stream, int length, PlayerProjectileRicochet instance, bool isDelta)
	{
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitPosition, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.inVelocity, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.outVelocity, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.hitNormal, isDelta);
				continue;
			case 53:
				instance.travelTime = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerProjectileRicochet instance, PlayerProjectileRicochet previous)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.projectileID != previous.projectileID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
		}
		if (instance.hitPosition != previous.hitPosition)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.hitPosition, previous.hitPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.inVelocity != previous.inVelocity)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.inVelocity, previous.inVelocity);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field inVelocity (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.outVelocity != previous.outVelocity)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.outVelocity, previous.outVelocity);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field outVelocity (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.hitNormal != previous.hitNormal)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.hitNormal, previous.hitNormal);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitNormal (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.travelTime != previous.travelTime)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.travelTime);
		}
	}

	public static void Serialize(BufferStream stream, PlayerProjectileRicochet instance)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		if (instance.projectileID != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
		}
		if (instance.hitPosition != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.hitPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.inVelocity != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.inVelocity);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field inVelocity (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.outVelocity != default(Vector3))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.outVelocity);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field outVelocity (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.hitNormal != default(Vector3))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.hitNormal);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hitNormal (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.travelTime != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.travelTime);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class PlayerProjectileUpdate : IDisposable, IPooled, IProto<PlayerProjectileUpdate>, IProto
{
	[NonSerialized]
	public int projectileID;

	[NonSerialized]
	public Vector3 curPosition;

	[NonSerialized]
	public Vector3 curVelocity;

	[NonSerialized]
	public float travelTime;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerProjectileUpdate instance)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.projectileID = 0;
			instance.curPosition = default(Vector3);
			instance.curVelocity = default(Vector3);
			instance.travelTime = 0f;
			Pool.Free<PlayerProjectileUpdate>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerProjectileUpdate with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerProjectileUpdate instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		instance.projectileID = projectileID;
		instance.curPosition = curPosition;
		instance.curVelocity = curVelocity;
		instance.travelTime = travelTime;
	}

	public PlayerProjectileUpdate Copy()
	{
		PlayerProjectileUpdate playerProjectileUpdate = Pool.Get<PlayerProjectileUpdate>();
		CopyTo(playerProjectileUpdate);
		return playerProjectileUpdate;
	}

	public static PlayerProjectileUpdate Deserialize(BufferStream stream)
	{
		PlayerProjectileUpdate playerProjectileUpdate = Pool.Get<PlayerProjectileUpdate>();
		Deserialize(stream, playerProjectileUpdate, isDelta: false);
		return playerProjectileUpdate;
	}

	public static PlayerProjectileUpdate DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerProjectileUpdate playerProjectileUpdate = Pool.Get<PlayerProjectileUpdate>();
		DeserializeLengthDelimited(stream, playerProjectileUpdate, isDelta: false);
		return playerProjectileUpdate;
	}

	public static PlayerProjectileUpdate DeserializeLength(BufferStream stream, int length)
	{
		PlayerProjectileUpdate playerProjectileUpdate = Pool.Get<PlayerProjectileUpdate>();
		DeserializeLength(stream, length, playerProjectileUpdate, isDelta: false);
		return playerProjectileUpdate;
	}

	public static PlayerProjectileUpdate Deserialize(byte[] buffer)
	{
		PlayerProjectileUpdate playerProjectileUpdate = Pool.Get<PlayerProjectileUpdate>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerProjectileUpdate, isDelta: false);
		return playerProjectileUpdate;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerProjectileUpdate previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerProjectileUpdate Deserialize(BufferStream stream, PlayerProjectileUpdate instance, bool isDelta)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.curPosition, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.curVelocity, isDelta);
				continue;
			case 37:
				instance.travelTime = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerProjectileUpdate DeserializeLengthDelimited(BufferStream stream, PlayerProjectileUpdate instance, bool isDelta)
	{
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.curPosition, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.curVelocity, isDelta);
				continue;
			case 37:
				instance.travelTime = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerProjectileUpdate DeserializeLength(BufferStream stream, int length, PlayerProjectileUpdate instance, bool isDelta)
	{
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.curPosition, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.curVelocity, isDelta);
				continue;
			case 37:
				instance.travelTime = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerProjectileUpdate instance, PlayerProjectileUpdate previous)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		if (instance.projectileID != previous.projectileID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
		}
		if (instance.curPosition != previous.curPosition)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.curPosition, previous.curPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field curPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.curVelocity != previous.curVelocity)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.curVelocity, previous.curVelocity);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field curVelocity (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.travelTime != previous.travelTime)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.travelTime);
		}
	}

	public static void Serialize(BufferStream stream, PlayerProjectileUpdate instance)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		if (instance.projectileID != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
		}
		if (instance.curPosition != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.curPosition);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field curPosition (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.curVelocity != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.curVelocity);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field curVelocity (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.travelTime != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.travelTime);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PlayerState : IDisposable, IPooled, IProto<PlayerState>, IProto
{
	[NonSerialized]
	public double unHostileTimestamp;

	[NonSerialized]
	public List<MapNote> pointsOfInterest;

	[NonSerialized]
	public MapNote deathMarker;

	[NonSerialized]
	public Missions missions;

	[NonSerialized]
	public List<MapNote> pings;

	[NonSerialized]
	public bool chatMuted;

	[NonSerialized]
	public double chatMuteExpiryTimestamp;

	[NonSerialized]
	public int numberOfTimesReported;

	[NonSerialized]
	public List<uint> fogImagesMainland;

	[NonSerialized]
	public NetworkableId fogImageNetId;

	[NonSerialized]
	public List<uint> fogImagesDeepSea;

	[NonSerialized]
	public int paintballColor;

	[NonSerialized]
	public int protocol;

	[NonSerialized]
	public uint seed;

	[NonSerialized]
	public int saveCreatedTime;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerState instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.unHostileTimestamp = 0.0;
		if (instance.pointsOfInterest != null)
		{
			for (int i = 0; i < instance.pointsOfInterest.Count; i++)
			{
				if (instance.pointsOfInterest[i] != null)
				{
					instance.pointsOfInterest[i].ResetToPool();
					instance.pointsOfInterest[i] = null;
				}
			}
			List<MapNote> list = instance.pointsOfInterest;
			Pool.Free<MapNote>(ref list, false);
			instance.pointsOfInterest = list;
		}
		if (instance.deathMarker != null)
		{
			instance.deathMarker.ResetToPool();
			instance.deathMarker = null;
		}
		if (instance.missions != null)
		{
			instance.missions.ResetToPool();
			instance.missions = null;
		}
		if (instance.pings != null)
		{
			for (int j = 0; j < instance.pings.Count; j++)
			{
				if (instance.pings[j] != null)
				{
					instance.pings[j].ResetToPool();
					instance.pings[j] = null;
				}
			}
			List<MapNote> list2 = instance.pings;
			Pool.Free<MapNote>(ref list2, false);
			instance.pings = list2;
		}
		instance.chatMuted = false;
		instance.chatMuteExpiryTimestamp = 0.0;
		instance.numberOfTimesReported = 0;
		if (instance.fogImagesMainland != null)
		{
			List<uint> list3 = instance.fogImagesMainland;
			Pool.FreeUnmanaged<uint>(ref list3);
			instance.fogImagesMainland = list3;
		}
		instance.fogImageNetId = default(NetworkableId);
		if (instance.fogImagesDeepSea != null)
		{
			List<uint> list4 = instance.fogImagesDeepSea;
			Pool.FreeUnmanaged<uint>(ref list4);
			instance.fogImagesDeepSea = list4;
		}
		instance.paintballColor = 0;
		instance.protocol = 0;
		instance.seed = 0u;
		instance.saveCreatedTime = 0;
		Pool.Free<PlayerState>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerState with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerState instance)
	{
		instance.unHostileTimestamp = unHostileTimestamp;
		if (pointsOfInterest != null)
		{
			instance.pointsOfInterest = Pool.Get<List<MapNote>>();
			for (int i = 0; i < pointsOfInterest.Count; i++)
			{
				MapNote item = pointsOfInterest[i].Copy();
				instance.pointsOfInterest.Add(item);
			}
		}
		else
		{
			instance.pointsOfInterest = null;
		}
		if (deathMarker != null)
		{
			if (instance.deathMarker == null)
			{
				instance.deathMarker = deathMarker.Copy();
			}
			else
			{
				deathMarker.CopyTo(instance.deathMarker);
			}
		}
		else
		{
			instance.deathMarker = null;
		}
		if (missions != null)
		{
			if (instance.missions == null)
			{
				instance.missions = missions.Copy();
			}
			else
			{
				missions.CopyTo(instance.missions);
			}
		}
		else
		{
			instance.missions = null;
		}
		if (pings != null)
		{
			instance.pings = Pool.Get<List<MapNote>>();
			for (int j = 0; j < pings.Count; j++)
			{
				MapNote item2 = pings[j].Copy();
				instance.pings.Add(item2);
			}
		}
		else
		{
			instance.pings = null;
		}
		instance.chatMuted = chatMuted;
		instance.chatMuteExpiryTimestamp = chatMuteExpiryTimestamp;
		instance.numberOfTimesReported = numberOfTimesReported;
		if (fogImagesMainland != null)
		{
			instance.fogImagesMainland = Pool.Get<List<uint>>();
			for (int k = 0; k < fogImagesMainland.Count; k++)
			{
				uint item3 = fogImagesMainland[k];
				instance.fogImagesMainland.Add(item3);
			}
		}
		else
		{
			instance.fogImagesMainland = null;
		}
		instance.fogImageNetId = fogImageNetId;
		if (fogImagesDeepSea != null)
		{
			instance.fogImagesDeepSea = Pool.Get<List<uint>>();
			for (int l = 0; l < fogImagesDeepSea.Count; l++)
			{
				uint item4 = fogImagesDeepSea[l];
				instance.fogImagesDeepSea.Add(item4);
			}
		}
		else
		{
			instance.fogImagesDeepSea = null;
		}
		instance.paintballColor = paintballColor;
		instance.protocol = protocol;
		instance.seed = seed;
		instance.saveCreatedTime = saveCreatedTime;
	}

	public PlayerState Copy()
	{
		PlayerState playerState = Pool.Get<PlayerState>();
		CopyTo(playerState);
		return playerState;
	}

	public static PlayerState Deserialize(BufferStream stream)
	{
		PlayerState playerState = Pool.Get<PlayerState>();
		Deserialize(stream, playerState, isDelta: false);
		return playerState;
	}

	public static PlayerState DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerState playerState = Pool.Get<PlayerState>();
		DeserializeLengthDelimited(stream, playerState, isDelta: false);
		return playerState;
	}

	public static PlayerState DeserializeLength(BufferStream stream, int length)
	{
		PlayerState playerState = Pool.Get<PlayerState>();
		DeserializeLength(stream, length, playerState, isDelta: false);
		return playerState;
	}

	public static PlayerState Deserialize(byte[] buffer)
	{
		PlayerState playerState = Pool.Get<PlayerState>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerState, isDelta: false);
		return playerState;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerState previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerState Deserialize(BufferStream stream, PlayerState instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.pointsOfInterest == null)
			{
				instance.pointsOfInterest = Pool.Get<List<MapNote>>();
			}
			if (instance.pings == null)
			{
				instance.pings = Pool.Get<List<MapNote>>();
			}
			if (instance.fogImagesMainland == null)
			{
				instance.fogImagesMainland = Pool.Get<List<uint>>();
			}
			if (instance.fogImagesDeepSea == null)
			{
				instance.fogImagesDeepSea = Pool.Get<List<uint>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 9:
				instance.unHostileTimestamp = ProtocolParser.ReadDouble(stream);
				continue;
			case 26:
				instance.pointsOfInterest.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 34:
				if (instance.deathMarker == null)
				{
					instance.deathMarker = MapNote.DeserializeLengthDelimited(stream);
				}
				else
				{
					MapNote.DeserializeLengthDelimited(stream, instance.deathMarker, isDelta);
				}
				continue;
			case 42:
				if (instance.missions == null)
				{
					instance.missions = Missions.DeserializeLengthDelimited(stream);
				}
				else
				{
					Missions.DeserializeLengthDelimited(stream, instance.missions, isDelta);
				}
				continue;
			case 50:
				instance.pings.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 56:
				instance.chatMuted = ProtocolParser.ReadBool(stream);
				continue;
			case 65:
				instance.chatMuteExpiryTimestamp = ProtocolParser.ReadDouble(stream);
				continue;
			case 72:
				instance.numberOfTimesReported = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 80:
				instance.fogImagesMainland.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 88:
				instance.fogImageNetId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 96:
				instance.fogImagesDeepSea.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 104:
				instance.paintballColor = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 50u:
				if (key.WireType == Wire.Varint)
				{
					instance.protocol = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 51u:
				if (key.WireType == Wire.Varint)
				{
					instance.seed = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 52u:
				if (key.WireType == Wire.Varint)
				{
					instance.saveCreatedTime = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
	}

	public static PlayerState DeserializeLengthDelimited(BufferStream stream, PlayerState instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.pointsOfInterest == null)
			{
				instance.pointsOfInterest = Pool.Get<List<MapNote>>();
			}
			if (instance.pings == null)
			{
				instance.pings = Pool.Get<List<MapNote>>();
			}
			if (instance.fogImagesMainland == null)
			{
				instance.fogImagesMainland = Pool.Get<List<uint>>();
			}
			if (instance.fogImagesDeepSea == null)
			{
				instance.fogImagesDeepSea = Pool.Get<List<uint>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 9:
				instance.unHostileTimestamp = ProtocolParser.ReadDouble(stream);
				continue;
			case 26:
				instance.pointsOfInterest.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 34:
				if (instance.deathMarker == null)
				{
					instance.deathMarker = MapNote.DeserializeLengthDelimited(stream);
				}
				else
				{
					MapNote.DeserializeLengthDelimited(stream, instance.deathMarker, isDelta);
				}
				continue;
			case 42:
				if (instance.missions == null)
				{
					instance.missions = Missions.DeserializeLengthDelimited(stream);
				}
				else
				{
					Missions.DeserializeLengthDelimited(stream, instance.missions, isDelta);
				}
				continue;
			case 50:
				instance.pings.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 56:
				instance.chatMuted = ProtocolParser.ReadBool(stream);
				continue;
			case 65:
				instance.chatMuteExpiryTimestamp = ProtocolParser.ReadDouble(stream);
				continue;
			case 72:
				instance.numberOfTimesReported = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 80:
				instance.fogImagesMainland.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 88:
				instance.fogImageNetId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 96:
				instance.fogImagesDeepSea.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 104:
				instance.paintballColor = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 50u:
				if (key.WireType == Wire.Varint)
				{
					instance.protocol = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 51u:
				if (key.WireType == Wire.Varint)
				{
					instance.seed = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 52u:
				if (key.WireType == Wire.Varint)
				{
					instance.saveCreatedTime = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerState DeserializeLength(BufferStream stream, int length, PlayerState instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.pointsOfInterest == null)
			{
				instance.pointsOfInterest = Pool.Get<List<MapNote>>();
			}
			if (instance.pings == null)
			{
				instance.pings = Pool.Get<List<MapNote>>();
			}
			if (instance.fogImagesMainland == null)
			{
				instance.fogImagesMainland = Pool.Get<List<uint>>();
			}
			if (instance.fogImagesDeepSea == null)
			{
				instance.fogImagesDeepSea = Pool.Get<List<uint>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 9:
				instance.unHostileTimestamp = ProtocolParser.ReadDouble(stream);
				continue;
			case 26:
				instance.pointsOfInterest.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 34:
				if (instance.deathMarker == null)
				{
					instance.deathMarker = MapNote.DeserializeLengthDelimited(stream);
				}
				else
				{
					MapNote.DeserializeLengthDelimited(stream, instance.deathMarker, isDelta);
				}
				continue;
			case 42:
				if (instance.missions == null)
				{
					instance.missions = Missions.DeserializeLengthDelimited(stream);
				}
				else
				{
					Missions.DeserializeLengthDelimited(stream, instance.missions, isDelta);
				}
				continue;
			case 50:
				instance.pings.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 56:
				instance.chatMuted = ProtocolParser.ReadBool(stream);
				continue;
			case 65:
				instance.chatMuteExpiryTimestamp = ProtocolParser.ReadDouble(stream);
				continue;
			case 72:
				instance.numberOfTimesReported = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 80:
				instance.fogImagesMainland.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 88:
				instance.fogImageNetId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 96:
				instance.fogImagesDeepSea.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 104:
				instance.paintballColor = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 50u:
				if (key.WireType == Wire.Varint)
				{
					instance.protocol = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			case 51u:
				if (key.WireType == Wire.Varint)
				{
					instance.seed = ProtocolParser.ReadUInt32(stream);
				}
				break;
			case 52u:
				if (key.WireType == Wire.Varint)
				{
					instance.saveCreatedTime = (int)ProtocolParser.ReadUInt64(stream);
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerState instance, PlayerState previous)
	{
		if (instance.unHostileTimestamp != previous.unHostileTimestamp)
		{
			stream.WriteByte(9);
			ProtocolParser.WriteDouble(stream, instance.unHostileTimestamp);
		}
		if (instance.pointsOfInterest != null)
		{
			for (int i = 0; i < instance.pointsOfInterest.Count; i++)
			{
				MapNote mapNote = instance.pointsOfInterest[i];
				stream.WriteByte(26);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				MapNote.SerializeDelta(stream, mapNote, mapNote);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.deathMarker != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			MapNote.SerializeDelta(stream, instance.deathMarker, previous.deathMarker);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.missions != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			Missions.SerializeDelta(stream, instance.missions, previous.missions);
			int val3 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
		if (instance.pings != null)
		{
			for (int j = 0; j < instance.pings.Count; j++)
			{
				MapNote mapNote2 = instance.pings[j];
				stream.WriteByte(50);
				BufferStream.RangeHandle range4 = stream.GetRange(5);
				int position4 = stream.Position;
				MapNote.SerializeDelta(stream, mapNote2, mapNote2);
				int val4 = stream.Position - position4;
				Span<byte> span4 = range4.GetSpan();
				int num4 = ProtocolParser.WriteUInt32((uint)val4, span4, 0);
				if (num4 < 5)
				{
					span4[num4 - 1] |= 128;
					while (num4 < 4)
					{
						span4[num4++] = 128;
					}
					span4[4] = 0;
				}
			}
		}
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.chatMuted);
		if (instance.chatMuteExpiryTimestamp != previous.chatMuteExpiryTimestamp)
		{
			stream.WriteByte(65);
			ProtocolParser.WriteDouble(stream, instance.chatMuteExpiryTimestamp);
		}
		if (instance.numberOfTimesReported != previous.numberOfTimesReported)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.numberOfTimesReported);
		}
		if (instance.fogImagesMainland != null)
		{
			for (int k = 0; k < instance.fogImagesMainland.Count; k++)
			{
				uint val5 = instance.fogImagesMainland[k];
				stream.WriteByte(80);
				ProtocolParser.WriteUInt32(stream, val5);
			}
		}
		stream.WriteByte(88);
		ProtocolParser.WriteUInt64(stream, instance.fogImageNetId.Value);
		if (instance.fogImagesDeepSea != null)
		{
			for (int l = 0; l < instance.fogImagesDeepSea.Count; l++)
			{
				uint val6 = instance.fogImagesDeepSea[l];
				stream.WriteByte(96);
				ProtocolParser.WriteUInt32(stream, val6);
			}
		}
		if (instance.paintballColor != previous.paintballColor)
		{
			stream.WriteByte(104);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.paintballColor);
		}
		if (instance.protocol != previous.protocol)
		{
			stream.WriteByte(144);
			stream.WriteByte(3);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.protocol);
		}
		if (instance.seed != previous.seed)
		{
			stream.WriteByte(152);
			stream.WriteByte(3);
			ProtocolParser.WriteUInt32(stream, instance.seed);
		}
		if (instance.saveCreatedTime != previous.saveCreatedTime)
		{
			stream.WriteByte(160);
			stream.WriteByte(3);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.saveCreatedTime);
		}
	}

	public static void Serialize(BufferStream stream, PlayerState instance)
	{
		if (instance.unHostileTimestamp != 0.0)
		{
			stream.WriteByte(9);
			ProtocolParser.WriteDouble(stream, instance.unHostileTimestamp);
		}
		if (instance.pointsOfInterest != null)
		{
			for (int i = 0; i < instance.pointsOfInterest.Count; i++)
			{
				MapNote instance2 = instance.pointsOfInterest[i];
				stream.WriteByte(26);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				MapNote.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.deathMarker != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			MapNote.Serialize(stream, instance.deathMarker);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.missions != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			Missions.Serialize(stream, instance.missions);
			int val3 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
		if (instance.pings != null)
		{
			for (int j = 0; j < instance.pings.Count; j++)
			{
				MapNote instance3 = instance.pings[j];
				stream.WriteByte(50);
				BufferStream.RangeHandle range4 = stream.GetRange(5);
				int position4 = stream.Position;
				MapNote.Serialize(stream, instance3);
				int val4 = stream.Position - position4;
				Span<byte> span4 = range4.GetSpan();
				int num4 = ProtocolParser.WriteUInt32((uint)val4, span4, 0);
				if (num4 < 5)
				{
					span4[num4 - 1] |= 128;
					while (num4 < 4)
					{
						span4[num4++] = 128;
					}
					span4[4] = 0;
				}
			}
		}
		if (instance.chatMuted)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.chatMuted);
		}
		if (instance.chatMuteExpiryTimestamp != 0.0)
		{
			stream.WriteByte(65);
			ProtocolParser.WriteDouble(stream, instance.chatMuteExpiryTimestamp);
		}
		if (instance.numberOfTimesReported != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.numberOfTimesReported);
		}
		if (instance.fogImagesMainland != null)
		{
			for (int k = 0; k < instance.fogImagesMainland.Count; k++)
			{
				uint val5 = instance.fogImagesMainland[k];
				stream.WriteByte(80);
				ProtocolParser.WriteUInt32(stream, val5);
			}
		}
		if (instance.fogImageNetId != default(NetworkableId))
		{
			stream.WriteByte(88);
			ProtocolParser.WriteUInt64(stream, instance.fogImageNetId.Value);
		}
		if (instance.fogImagesDeepSea != null)
		{
			for (int l = 0; l < instance.fogImagesDeepSea.Count; l++)
			{
				uint val6 = instance.fogImagesDeepSea[l];
				stream.WriteByte(96);
				ProtocolParser.WriteUInt32(stream, val6);
			}
		}
		if (instance.paintballColor != 0)
		{
			stream.WriteByte(104);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.paintballColor);
		}
		if (instance.protocol != 0)
		{
			stream.WriteByte(144);
			stream.WriteByte(3);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.protocol);
		}
		if (instance.seed != 0)
		{
			stream.WriteByte(152);
			stream.WriteByte(3);
			ProtocolParser.WriteUInt32(stream, instance.seed);
		}
		if (instance.saveCreatedTime != 0)
		{
			stream.WriteByte(160);
			stream.WriteByte(3);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.saveCreatedTime);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (pointsOfInterest != null)
		{
			for (int i = 0; i < pointsOfInterest.Count; i++)
			{
				pointsOfInterest[i]?.InspectUids(action);
			}
		}
		deathMarker?.InspectUids(action);
		missions?.InspectUids(action);
		if (pings != null)
		{
			for (int j = 0; j < pings.Count; j++)
			{
				pings[j]?.InspectUids(action);
			}
		}
		action(UidType.NetworkableId, ref fogImageNetId.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class PlayerTeam : IDisposable, IPooled, IProto<PlayerTeam>, IProto
{
	public class TeamMember : IDisposable, IPooled, IProto<TeamMember>, IProto
	{
		[NonSerialized]
		public string displayName;

		[NonSerialized]
		public ulong userID;

		[NonSerialized]
		public float healthFraction;

		[NonSerialized]
		public Vector3 position;

		[NonSerialized]
		public bool online;

		[NonSerialized]
		public bool wounded;

		[NonSerialized]
		public ulong teamID;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(TeamMember instance)
		{
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.displayName = string.Empty;
				instance.userID = 0uL;
				instance.healthFraction = 0f;
				instance.position = default(Vector3);
				instance.online = false;
				instance.wounded = false;
				instance.teamID = 0uL;
				Pool.Free<TeamMember>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose TeamMember with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(TeamMember instance)
		{
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			instance.displayName = displayName;
			instance.userID = userID;
			instance.healthFraction = healthFraction;
			instance.position = position;
			instance.online = online;
			instance.wounded = wounded;
			instance.teamID = teamID;
		}

		public TeamMember Copy()
		{
			TeamMember teamMember = Pool.Get<TeamMember>();
			CopyTo(teamMember);
			return teamMember;
		}

		public static TeamMember Deserialize(BufferStream stream)
		{
			TeamMember teamMember = Pool.Get<TeamMember>();
			Deserialize(stream, teamMember, isDelta: false);
			return teamMember;
		}

		public static TeamMember DeserializeLengthDelimited(BufferStream stream)
		{
			TeamMember teamMember = Pool.Get<TeamMember>();
			DeserializeLengthDelimited(stream, teamMember, isDelta: false);
			return teamMember;
		}

		public static TeamMember DeserializeLength(BufferStream stream, int length)
		{
			TeamMember teamMember = Pool.Get<TeamMember>();
			DeserializeLength(stream, length, teamMember, isDelta: false);
			return teamMember;
		}

		public static TeamMember Deserialize(byte[] buffer)
		{
			TeamMember teamMember = Pool.Get<TeamMember>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, teamMember, isDelta: false);
			return teamMember;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, TeamMember previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static TeamMember Deserialize(BufferStream stream, TeamMember instance, bool isDelta)
		{
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.userID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 29:
					instance.healthFraction = ProtocolParser.ReadSingle(stream);
					continue;
				case 34:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 40:
					instance.online = ProtocolParser.ReadBool(stream);
					continue;
				case 48:
					instance.wounded = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.teamID = ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static TeamMember DeserializeLengthDelimited(BufferStream stream, TeamMember instance, bool isDelta)
		{
			//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.userID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 29:
					instance.healthFraction = ProtocolParser.ReadSingle(stream);
					continue;
				case 34:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 40:
					instance.online = ProtocolParser.ReadBool(stream);
					continue;
				case 48:
					instance.wounded = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.teamID = ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static TeamMember DeserializeLength(BufferStream stream, int length, TeamMember instance, bool isDelta)
		{
			//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 16:
					instance.userID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 29:
					instance.healthFraction = ProtocolParser.ReadSingle(stream);
					continue;
				case 34:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 40:
					instance.online = ProtocolParser.ReadBool(stream);
					continue;
				case 48:
					instance.wounded = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.teamID = ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, TeamMember instance, TeamMember previous)
		{
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
			if (instance.displayName != null && instance.displayName != previous.displayName)
			{
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.displayName);
			}
			if (instance.userID != previous.userID)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.userID);
			}
			if (instance.healthFraction != previous.healthFraction)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.healthFraction);
			}
			if (instance.position != previous.position)
			{
				stream.WriteByte(34);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int num = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.position, previous.position);
				int num2 = stream.Position - num;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span, 0);
			}
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.online);
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.wounded);
			if (instance.teamID != previous.teamID)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, instance.teamID);
			}
		}

		public static void Serialize(BufferStream stream, TeamMember instance)
		{
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_0088: Unknown result type (might be due to invalid IL or missing references)
			if (instance.displayName != null)
			{
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.displayName);
			}
			if (instance.userID != 0L)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.userID);
			}
			if (instance.healthFraction != 0f)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.healthFraction);
			}
			if (instance.position != default(Vector3))
			{
				stream.WriteByte(34);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int num = stream.Position;
				Vector3Serialized.Serialize(stream, instance.position);
				int num2 = stream.Position - num;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span, 0);
			}
			if (instance.online)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteBool(stream, instance.online);
			}
			if (instance.wounded)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteBool(stream, instance.wounded);
			}
			if (instance.teamID != 0L)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, instance.teamID);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public ulong teamID;

	[NonSerialized]
	public string teamName;

	[NonSerialized]
	public ulong teamLeader;

	[NonSerialized]
	public List<TeamMember> members;

	[NonSerialized]
	public float teamLifetime;

	[NonSerialized]
	public List<MapNote> leaderMapNotes;

	[NonSerialized]
	public List<MapNote> teamPings;

	[NonSerialized]
	public List<ulong> invites;

	[NonSerialized]
	public string joinKey;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerTeam instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.teamID = 0uL;
		instance.teamName = string.Empty;
		instance.teamLeader = 0uL;
		if (instance.members != null)
		{
			for (int i = 0; i < instance.members.Count; i++)
			{
				if (instance.members[i] != null)
				{
					instance.members[i].ResetToPool();
					instance.members[i] = null;
				}
			}
			List<TeamMember> list = instance.members;
			Pool.Free<TeamMember>(ref list, false);
			instance.members = list;
		}
		instance.teamLifetime = 0f;
		if (instance.leaderMapNotes != null)
		{
			for (int j = 0; j < instance.leaderMapNotes.Count; j++)
			{
				if (instance.leaderMapNotes[j] != null)
				{
					instance.leaderMapNotes[j].ResetToPool();
					instance.leaderMapNotes[j] = null;
				}
			}
			List<MapNote> list2 = instance.leaderMapNotes;
			Pool.Free<MapNote>(ref list2, false);
			instance.leaderMapNotes = list2;
		}
		if (instance.teamPings != null)
		{
			for (int k = 0; k < instance.teamPings.Count; k++)
			{
				if (instance.teamPings[k] != null)
				{
					instance.teamPings[k].ResetToPool();
					instance.teamPings[k] = null;
				}
			}
			List<MapNote> list3 = instance.teamPings;
			Pool.Free<MapNote>(ref list3, false);
			instance.teamPings = list3;
		}
		if (instance.invites != null)
		{
			List<ulong> list4 = instance.invites;
			Pool.FreeUnmanaged<ulong>(ref list4);
			instance.invites = list4;
		}
		instance.joinKey = string.Empty;
		Pool.Free<PlayerTeam>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerTeam with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerTeam instance)
	{
		instance.teamID = teamID;
		instance.teamName = teamName;
		instance.teamLeader = teamLeader;
		if (members != null)
		{
			instance.members = Pool.Get<List<TeamMember>>();
			for (int i = 0; i < members.Count; i++)
			{
				TeamMember item = members[i].Copy();
				instance.members.Add(item);
			}
		}
		else
		{
			instance.members = null;
		}
		instance.teamLifetime = teamLifetime;
		if (leaderMapNotes != null)
		{
			instance.leaderMapNotes = Pool.Get<List<MapNote>>();
			for (int j = 0; j < leaderMapNotes.Count; j++)
			{
				MapNote item2 = leaderMapNotes[j].Copy();
				instance.leaderMapNotes.Add(item2);
			}
		}
		else
		{
			instance.leaderMapNotes = null;
		}
		if (teamPings != null)
		{
			instance.teamPings = Pool.Get<List<MapNote>>();
			for (int k = 0; k < teamPings.Count; k++)
			{
				MapNote item3 = teamPings[k].Copy();
				instance.teamPings.Add(item3);
			}
		}
		else
		{
			instance.teamPings = null;
		}
		if (invites != null)
		{
			instance.invites = Pool.Get<List<ulong>>();
			for (int l = 0; l < invites.Count; l++)
			{
				ulong item4 = invites[l];
				instance.invites.Add(item4);
			}
		}
		else
		{
			instance.invites = null;
		}
		instance.joinKey = joinKey;
	}

	public PlayerTeam Copy()
	{
		PlayerTeam playerTeam = Pool.Get<PlayerTeam>();
		CopyTo(playerTeam);
		return playerTeam;
	}

	public static PlayerTeam Deserialize(BufferStream stream)
	{
		PlayerTeam playerTeam = Pool.Get<PlayerTeam>();
		Deserialize(stream, playerTeam, isDelta: false);
		return playerTeam;
	}

	public static PlayerTeam DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerTeam playerTeam = Pool.Get<PlayerTeam>();
		DeserializeLengthDelimited(stream, playerTeam, isDelta: false);
		return playerTeam;
	}

	public static PlayerTeam DeserializeLength(BufferStream stream, int length)
	{
		PlayerTeam playerTeam = Pool.Get<PlayerTeam>();
		DeserializeLength(stream, length, playerTeam, isDelta: false);
		return playerTeam;
	}

	public static PlayerTeam Deserialize(byte[] buffer)
	{
		PlayerTeam playerTeam = Pool.Get<PlayerTeam>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerTeam, isDelta: false);
		return playerTeam;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerTeam previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerTeam Deserialize(BufferStream stream, PlayerTeam instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.members == null)
			{
				instance.members = Pool.Get<List<TeamMember>>();
			}
			if (instance.leaderMapNotes == null)
			{
				instance.leaderMapNotes = Pool.Get<List<MapNote>>();
			}
			if (instance.teamPings == null)
			{
				instance.teamPings = Pool.Get<List<MapNote>>();
			}
			if (instance.invites == null)
			{
				instance.invites = Pool.Get<List<ulong>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.teamID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.teamName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.teamLeader = ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.members.Add(TeamMember.DeserializeLengthDelimited(stream));
				continue;
			case 53:
				instance.teamLifetime = ProtocolParser.ReadSingle(stream);
				continue;
			case 58:
				instance.leaderMapNotes.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 66:
				instance.teamPings.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 72:
				instance.invites.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 82:
				instance.joinKey = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerTeam DeserializeLengthDelimited(BufferStream stream, PlayerTeam instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.members == null)
			{
				instance.members = Pool.Get<List<TeamMember>>();
			}
			if (instance.leaderMapNotes == null)
			{
				instance.leaderMapNotes = Pool.Get<List<MapNote>>();
			}
			if (instance.teamPings == null)
			{
				instance.teamPings = Pool.Get<List<MapNote>>();
			}
			if (instance.invites == null)
			{
				instance.invites = Pool.Get<List<ulong>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.teamID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.teamName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.teamLeader = ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.members.Add(TeamMember.DeserializeLengthDelimited(stream));
				continue;
			case 53:
				instance.teamLifetime = ProtocolParser.ReadSingle(stream);
				continue;
			case 58:
				instance.leaderMapNotes.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 66:
				instance.teamPings.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 72:
				instance.invites.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 82:
				instance.joinKey = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerTeam DeserializeLength(BufferStream stream, int length, PlayerTeam instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.members == null)
			{
				instance.members = Pool.Get<List<TeamMember>>();
			}
			if (instance.leaderMapNotes == null)
			{
				instance.leaderMapNotes = Pool.Get<List<MapNote>>();
			}
			if (instance.teamPings == null)
			{
				instance.teamPings = Pool.Get<List<MapNote>>();
			}
			if (instance.invites == null)
			{
				instance.invites = Pool.Get<List<ulong>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.teamID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.teamName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.teamLeader = ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.members.Add(TeamMember.DeserializeLengthDelimited(stream));
				continue;
			case 53:
				instance.teamLifetime = ProtocolParser.ReadSingle(stream);
				continue;
			case 58:
				instance.leaderMapNotes.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 66:
				instance.teamPings.Add(MapNote.DeserializeLengthDelimited(stream));
				continue;
			case 72:
				instance.invites.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 82:
				instance.joinKey = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerTeam instance, PlayerTeam previous)
	{
		if (instance.teamID != previous.teamID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.teamID);
		}
		if (instance.teamName != null && instance.teamName != previous.teamName)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.teamName);
		}
		if (instance.teamLeader != previous.teamLeader)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.teamLeader);
		}
		if (instance.members != null)
		{
			for (int i = 0; i < instance.members.Count; i++)
			{
				TeamMember teamMember = instance.members[i];
				stream.WriteByte(34);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				TeamMember.SerializeDelta(stream, teamMember, teamMember);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.teamLifetime != previous.teamLifetime)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.teamLifetime);
		}
		if (instance.leaderMapNotes != null)
		{
			for (int j = 0; j < instance.leaderMapNotes.Count; j++)
			{
				MapNote mapNote = instance.leaderMapNotes[j];
				stream.WriteByte(58);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				MapNote.SerializeDelta(stream, mapNote, mapNote);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.teamPings != null)
		{
			for (int k = 0; k < instance.teamPings.Count; k++)
			{
				MapNote mapNote2 = instance.teamPings[k];
				stream.WriteByte(66);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int position3 = stream.Position;
				MapNote.SerializeDelta(stream, mapNote2, mapNote2);
				int val3 = stream.Position - position3;
				Span<byte> span3 = range3.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
				if (num3 < 5)
				{
					span3[num3 - 1] |= 128;
					while (num3 < 4)
					{
						span3[num3++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		if (instance.invites != null)
		{
			for (int l = 0; l < instance.invites.Count; l++)
			{
				ulong val4 = instance.invites[l];
				stream.WriteByte(72);
				ProtocolParser.WriteUInt64(stream, val4);
			}
		}
		if (instance.joinKey != null && instance.joinKey != previous.joinKey)
		{
			stream.WriteByte(82);
			ProtocolParser.WriteString(stream, instance.joinKey);
		}
	}

	public static void Serialize(BufferStream stream, PlayerTeam instance)
	{
		if (instance.teamID != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.teamID);
		}
		if (instance.teamName != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.teamName);
		}
		if (instance.teamLeader != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.teamLeader);
		}
		if (instance.members != null)
		{
			for (int i = 0; i < instance.members.Count; i++)
			{
				TeamMember instance2 = instance.members[i];
				stream.WriteByte(34);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				TeamMember.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.teamLifetime != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.teamLifetime);
		}
		if (instance.leaderMapNotes != null)
		{
			for (int j = 0; j < instance.leaderMapNotes.Count; j++)
			{
				MapNote instance3 = instance.leaderMapNotes[j];
				stream.WriteByte(58);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				MapNote.Serialize(stream, instance3);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.teamPings != null)
		{
			for (int k = 0; k < instance.teamPings.Count; k++)
			{
				MapNote instance4 = instance.teamPings[k];
				stream.WriteByte(66);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int position3 = stream.Position;
				MapNote.Serialize(stream, instance4);
				int val3 = stream.Position - position3;
				Span<byte> span3 = range3.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
				if (num3 < 5)
				{
					span3[num3 - 1] |= 128;
					while (num3 < 4)
					{
						span3[num3++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		if (instance.invites != null)
		{
			for (int l = 0; l < instance.invites.Count; l++)
			{
				ulong val4 = instance.invites[l];
				stream.WriteByte(72);
				ProtocolParser.WriteUInt64(stream, val4);
			}
		}
		if (instance.joinKey != null)
		{
			stream.WriteByte(82);
			ProtocolParser.WriteString(stream, instance.joinKey);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (members != null)
		{
			for (int i = 0; i < members.Count; i++)
			{
				members[i]?.InspectUids(action);
			}
		}
		if (leaderMapNotes != null)
		{
			for (int j = 0; j < leaderMapNotes.Count; j++)
			{
				leaderMapNotes[j]?.InspectUids(action);
			}
		}
		if (teamPings != null)
		{
			for (int k = 0; k < teamPings.Count; k++)
			{
				teamPings[k]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PlayerUpdateLoot : IDisposable, IPooled, IProto<PlayerUpdateLoot>, IProto
{
	[NonSerialized]
	public ItemId itemID;

	[NonSerialized]
	public NetworkableId entityID;

	[NonSerialized]
	public List<ItemContainer> containers;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerUpdateLoot instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.itemID = default(ItemId);
		instance.entityID = default(NetworkableId);
		if (instance.containers != null)
		{
			for (int i = 0; i < instance.containers.Count; i++)
			{
				if (instance.containers[i] != null)
				{
					instance.containers[i].ResetToPool();
					instance.containers[i] = null;
				}
			}
			List<ItemContainer> list = instance.containers;
			Pool.Free<ItemContainer>(ref list, false);
			instance.containers = list;
		}
		Pool.Free<PlayerUpdateLoot>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerUpdateLoot with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerUpdateLoot instance)
	{
		instance.itemID = itemID;
		instance.entityID = entityID;
		if (containers != null)
		{
			instance.containers = Pool.Get<List<ItemContainer>>();
			for (int i = 0; i < containers.Count; i++)
			{
				ItemContainer item = containers[i].Copy();
				instance.containers.Add(item);
			}
		}
		else
		{
			instance.containers = null;
		}
	}

	public PlayerUpdateLoot Copy()
	{
		PlayerUpdateLoot playerUpdateLoot = Pool.Get<PlayerUpdateLoot>();
		CopyTo(playerUpdateLoot);
		return playerUpdateLoot;
	}

	public static PlayerUpdateLoot Deserialize(BufferStream stream)
	{
		PlayerUpdateLoot playerUpdateLoot = Pool.Get<PlayerUpdateLoot>();
		Deserialize(stream, playerUpdateLoot, isDelta: false);
		return playerUpdateLoot;
	}

	public static PlayerUpdateLoot DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerUpdateLoot playerUpdateLoot = Pool.Get<PlayerUpdateLoot>();
		DeserializeLengthDelimited(stream, playerUpdateLoot, isDelta: false);
		return playerUpdateLoot;
	}

	public static PlayerUpdateLoot DeserializeLength(BufferStream stream, int length)
	{
		PlayerUpdateLoot playerUpdateLoot = Pool.Get<PlayerUpdateLoot>();
		DeserializeLength(stream, length, playerUpdateLoot, isDelta: false);
		return playerUpdateLoot;
	}

	public static PlayerUpdateLoot Deserialize(byte[] buffer)
	{
		PlayerUpdateLoot playerUpdateLoot = Pool.Get<PlayerUpdateLoot>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerUpdateLoot, isDelta: false);
		return playerUpdateLoot;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerUpdateLoot previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerUpdateLoot Deserialize(BufferStream stream, PlayerUpdateLoot instance, bool isDelta)
	{
		if (!isDelta && instance.containers == null)
		{
			instance.containers = Pool.Get<List<ItemContainer>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemID = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.entityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.containers.Add(ItemContainer.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerUpdateLoot DeserializeLengthDelimited(BufferStream stream, PlayerUpdateLoot instance, bool isDelta)
	{
		if (!isDelta && instance.containers == null)
		{
			instance.containers = Pool.Get<List<ItemContainer>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.entityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.containers.Add(ItemContainer.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerUpdateLoot DeserializeLength(BufferStream stream, int length, PlayerUpdateLoot instance, bool isDelta)
	{
		if (!isDelta && instance.containers == null)
		{
			instance.containers = Pool.Get<List<ItemContainer>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = new ItemId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.entityID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.containers.Add(ItemContainer.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerUpdateLoot instance, PlayerUpdateLoot previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.itemID.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.entityID.Value);
		if (instance.containers == null)
		{
			return;
		}
		for (int i = 0; i < instance.containers.Count; i++)
		{
			ItemContainer itemContainer = instance.containers[i];
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.SerializeDelta(stream, itemContainer, itemContainer);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, PlayerUpdateLoot instance)
	{
		if (instance.itemID != default(ItemId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.itemID.Value);
		}
		if (instance.entityID != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.entityID.Value);
		}
		if (instance.containers == null)
		{
			return;
		}
		for (int i = 0; i < instance.containers.Count; i++)
		{
			ItemContainer instance2 = instance.containers[i];
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.ItemId, ref itemID.Value);
		action(UidType.NetworkableId, ref entityID.Value);
		if (containers != null)
		{
			for (int i = 0; i < containers.Count; i++)
			{
				containers[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PrefabData : IDisposable, IPooled, IProto<PrefabData>, IProto
{
	[NonSerialized]
	public string category;

	[NonSerialized]
	public uint id;

	[NonSerialized]
	public VectorData position;

	[NonSerialized]
	public VectorData rotation;

	[NonSerialized]
	public VectorData scale;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PrefabData instance)
	{
		if (instance.ShouldPool)
		{
			instance.category = string.Empty;
			instance.id = 0u;
			instance.position = default(VectorData);
			instance.rotation = default(VectorData);
			instance.scale = default(VectorData);
			Pool.Free<PrefabData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PrefabData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PrefabData instance)
	{
		instance.category = category;
		instance.id = id;
		instance.position = position;
		instance.rotation = rotation;
		instance.scale = scale;
	}

	public PrefabData Copy()
	{
		PrefabData prefabData = Pool.Get<PrefabData>();
		CopyTo(prefabData);
		return prefabData;
	}

	public static PrefabData Deserialize(BufferStream stream)
	{
		PrefabData prefabData = Pool.Get<PrefabData>();
		Deserialize(stream, prefabData, isDelta: false);
		return prefabData;
	}

	public static PrefabData DeserializeLengthDelimited(BufferStream stream)
	{
		PrefabData prefabData = Pool.Get<PrefabData>();
		DeserializeLengthDelimited(stream, prefabData, isDelta: false);
		return prefabData;
	}

	public static PrefabData DeserializeLength(BufferStream stream, int length)
	{
		PrefabData prefabData = Pool.Get<PrefabData>();
		DeserializeLength(stream, length, prefabData, isDelta: false);
		return prefabData;
	}

	public static PrefabData Deserialize(byte[] buffer)
	{
		PrefabData prefabData = Pool.Get<PrefabData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, prefabData, isDelta: false);
		return prefabData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PrefabData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PrefabData Deserialize(BufferStream stream, PrefabData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.category = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.id = ProtocolParser.ReadUInt32(stream);
				continue;
			case 26:
				VectorData.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 34:
				VectorData.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 42:
				VectorData.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PrefabData DeserializeLengthDelimited(BufferStream stream, PrefabData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.category = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.id = ProtocolParser.ReadUInt32(stream);
				continue;
			case 26:
				VectorData.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 34:
				VectorData.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 42:
				VectorData.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PrefabData DeserializeLength(BufferStream stream, int length, PrefabData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.category = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.id = ProtocolParser.ReadUInt32(stream);
				continue;
			case 26:
				VectorData.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 34:
				VectorData.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 42:
				VectorData.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PrefabData instance, PrefabData previous)
	{
		if (instance.category != previous.category)
		{
			if (instance.category == null)
			{
				throw new ArgumentNullException("category", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.category);
		}
		if (instance.id != previous.id)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.id);
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range = stream.GetRange(1);
		int num = stream.Position;
		VectorData.SerializeDelta(stream, instance.position, previous.position);
		int num2 = stream.Position - num;
		if (num2 > 127)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (ProtoBuf.VectorData)");
		}
		Span<byte> span = range.GetSpan();
		ProtocolParser.WriteUInt32((uint)num2, span, 0);
		stream.WriteByte(34);
		BufferStream.RangeHandle range2 = stream.GetRange(1);
		int num3 = stream.Position;
		VectorData.SerializeDelta(stream, instance.rotation, previous.rotation);
		int num4 = stream.Position - num3;
		if (num4 > 127)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (ProtoBuf.VectorData)");
		}
		Span<byte> span2 = range2.GetSpan();
		ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		stream.WriteByte(42);
		BufferStream.RangeHandle range3 = stream.GetRange(1);
		int num5 = stream.Position;
		VectorData.SerializeDelta(stream, instance.scale, previous.scale);
		int num6 = stream.Position - num5;
		if (num6 > 127)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field scale (ProtoBuf.VectorData)");
		}
		Span<byte> span3 = range3.GetSpan();
		ProtocolParser.WriteUInt32((uint)num6, span3, 0);
	}

	public static void Serialize(BufferStream stream, PrefabData instance)
	{
		if (instance.category == null)
		{
			throw new ArgumentNullException("category", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.category);
		if (instance.id != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.id);
		}
		if (instance.position != default(VectorData))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			VectorData.Serialize(stream, instance.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (ProtoBuf.VectorData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.rotation != default(VectorData))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			VectorData.Serialize(stream, instance.rotation);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (ProtoBuf.VectorData)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
		if (instance.scale != default(VectorData))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int num5 = stream.Position;
			VectorData.Serialize(stream, instance.scale);
			int num6 = stream.Position - num5;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field scale (ProtoBuf.VectorData)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span3, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		position.InspectUids(action);
		rotation.InspectUids(action);
		scale.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class ProceduralDungeon : IDisposable, IPooled, IProto<ProceduralDungeon>, IProto
{
	[NonSerialized]
	public uint seed;

	[NonSerialized]
	public NetworkableId exitPortalID;

	[NonSerialized]
	public Vector3 mapOffset;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ProceduralDungeon instance)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.seed = 0u;
			instance.exitPortalID = default(NetworkableId);
			instance.mapOffset = default(Vector3);
			Pool.Free<ProceduralDungeon>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ProceduralDungeon with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ProceduralDungeon instance)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		instance.seed = seed;
		instance.exitPortalID = exitPortalID;
		instance.mapOffset = mapOffset;
	}

	public ProceduralDungeon Copy()
	{
		ProceduralDungeon proceduralDungeon = Pool.Get<ProceduralDungeon>();
		CopyTo(proceduralDungeon);
		return proceduralDungeon;
	}

	public static ProceduralDungeon Deserialize(BufferStream stream)
	{
		ProceduralDungeon proceduralDungeon = Pool.Get<ProceduralDungeon>();
		Deserialize(stream, proceduralDungeon, isDelta: false);
		return proceduralDungeon;
	}

	public static ProceduralDungeon DeserializeLengthDelimited(BufferStream stream)
	{
		ProceduralDungeon proceduralDungeon = Pool.Get<ProceduralDungeon>();
		DeserializeLengthDelimited(stream, proceduralDungeon, isDelta: false);
		return proceduralDungeon;
	}

	public static ProceduralDungeon DeserializeLength(BufferStream stream, int length)
	{
		ProceduralDungeon proceduralDungeon = Pool.Get<ProceduralDungeon>();
		DeserializeLength(stream, length, proceduralDungeon, isDelta: false);
		return proceduralDungeon;
	}

	public static ProceduralDungeon Deserialize(byte[] buffer)
	{
		ProceduralDungeon proceduralDungeon = Pool.Get<ProceduralDungeon>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, proceduralDungeon, isDelta: false);
		return proceduralDungeon;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ProceduralDungeon previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ProceduralDungeon Deserialize(BufferStream stream, ProceduralDungeon instance, bool isDelta)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.seed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.exitPortalID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.mapOffset, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ProceduralDungeon DeserializeLengthDelimited(BufferStream stream, ProceduralDungeon instance, bool isDelta)
	{
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.seed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.exitPortalID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.mapOffset, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ProceduralDungeon DeserializeLength(BufferStream stream, int length, ProceduralDungeon instance, bool isDelta)
	{
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.seed = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.exitPortalID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.mapOffset, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ProceduralDungeon instance, ProceduralDungeon previous)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		if (instance.seed != previous.seed)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.seed);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.exitPortalID.Value);
		if (instance.mapOffset != previous.mapOffset)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.mapOffset, previous.mapOffset);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field mapOffset (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, ProceduralDungeon instance)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		if (instance.seed != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.seed);
		}
		if (instance.exitPortalID != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.exitPortalID.Value);
		}
		if (instance.mapOffset != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.mapOffset);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field mapOffset (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref exitPortalID.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class ProjectileShoot : IDisposable, IPooled, IProto<ProjectileShoot>, IProto
{
	public class Projectile : IDisposable, IPooled, IProto<Projectile>, IProto
	{
		[NonSerialized]
		public int projectileID;

		[NonSerialized]
		public Vector3 startPos;

		[NonSerialized]
		public Vector3 startVel;

		[NonSerialized]
		public int seed;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Projectile instance)
		{
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.projectileID = 0;
				instance.startPos = default(Vector3);
				instance.startVel = default(Vector3);
				instance.seed = 0;
				Pool.Free<Projectile>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Projectile with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Projectile instance)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			instance.projectileID = projectileID;
			instance.startPos = startPos;
			instance.startVel = startVel;
			instance.seed = seed;
		}

		public Projectile Copy()
		{
			Projectile projectile = Pool.Get<Projectile>();
			CopyTo(projectile);
			return projectile;
		}

		public static Projectile Deserialize(BufferStream stream)
		{
			Projectile projectile = Pool.Get<Projectile>();
			Deserialize(stream, projectile, isDelta: false);
			return projectile;
		}

		public static Projectile DeserializeLengthDelimited(BufferStream stream)
		{
			Projectile projectile = Pool.Get<Projectile>();
			DeserializeLengthDelimited(stream, projectile, isDelta: false);
			return projectile;
		}

		public static Projectile DeserializeLength(BufferStream stream, int length)
		{
			Projectile projectile = Pool.Get<Projectile>();
			DeserializeLength(stream, length, projectile, isDelta: false);
			return projectile;
		}

		public static Projectile Deserialize(byte[] buffer)
		{
			Projectile projectile = Pool.Get<Projectile>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, projectile, isDelta: false);
			return projectile;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Projectile previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Projectile Deserialize(BufferStream stream, Projectile instance, bool isDelta)
		{
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startPos, isDelta);
					continue;
				case 26:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startVel, isDelta);
					continue;
				case 32:
					instance.seed = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Projectile DeserializeLengthDelimited(BufferStream stream, Projectile instance, bool isDelta)
		{
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startPos, isDelta);
					continue;
				case 26:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startVel, isDelta);
					continue;
				case 32:
					instance.seed = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Projectile DeserializeLength(BufferStream stream, int length, Projectile instance, bool isDelta)
		{
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startPos, isDelta);
					continue;
				case 26:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startVel, isDelta);
					continue;
				case 32:
					instance.seed = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Projectile instance, Projectile previous)
		{
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			if (instance.projectileID != previous.projectileID)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
			}
			if (instance.startPos != previous.startPos)
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.startPos, previous.startPos);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startPos (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.startVel != previous.startVel)
			{
				stream.WriteByte(26);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.startVel, previous.startVel);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startVel (UnityEngine.Vector3)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.seed != previous.seed)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.seed);
			}
		}

		public static void Serialize(BufferStream stream, Projectile instance)
		{
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
			if (instance.projectileID != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
			}
			if (instance.startPos != default(Vector3))
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.Serialize(stream, instance.startPos);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startPos (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.startVel != default(Vector3))
			{
				stream.WriteByte(26);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				Vector3Serialized.Serialize(stream, instance.startVel);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field startVel (UnityEngine.Vector3)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.seed != 0)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.seed);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public int ammoType;

	[NonSerialized]
	public List<Projectile> projectiles;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ProjectileShoot instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.ammoType = 0;
		if (instance.projectiles != null)
		{
			for (int i = 0; i < instance.projectiles.Count; i++)
			{
				if (instance.projectiles[i] != null)
				{
					instance.projectiles[i].ResetToPool();
					instance.projectiles[i] = null;
				}
			}
			List<Projectile> list = instance.projectiles;
			Pool.Free<Projectile>(ref list, false);
			instance.projectiles = list;
		}
		Pool.Free<ProjectileShoot>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ProjectileShoot with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ProjectileShoot instance)
	{
		instance.ammoType = ammoType;
		if (projectiles != null)
		{
			instance.projectiles = Pool.Get<List<Projectile>>();
			for (int i = 0; i < projectiles.Count; i++)
			{
				Projectile item = projectiles[i].Copy();
				instance.projectiles.Add(item);
			}
		}
		else
		{
			instance.projectiles = null;
		}
	}

	public ProjectileShoot Copy()
	{
		ProjectileShoot projectileShoot = Pool.Get<ProjectileShoot>();
		CopyTo(projectileShoot);
		return projectileShoot;
	}

	public static ProjectileShoot Deserialize(BufferStream stream)
	{
		ProjectileShoot projectileShoot = Pool.Get<ProjectileShoot>();
		Deserialize(stream, projectileShoot, isDelta: false);
		return projectileShoot;
	}

	public static ProjectileShoot DeserializeLengthDelimited(BufferStream stream)
	{
		ProjectileShoot projectileShoot = Pool.Get<ProjectileShoot>();
		DeserializeLengthDelimited(stream, projectileShoot, isDelta: false);
		return projectileShoot;
	}

	public static ProjectileShoot DeserializeLength(BufferStream stream, int length)
	{
		ProjectileShoot projectileShoot = Pool.Get<ProjectileShoot>();
		DeserializeLength(stream, length, projectileShoot, isDelta: false);
		return projectileShoot;
	}

	public static ProjectileShoot Deserialize(byte[] buffer)
	{
		ProjectileShoot projectileShoot = Pool.Get<ProjectileShoot>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, projectileShoot, isDelta: false);
		return projectileShoot;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ProjectileShoot previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ProjectileShoot Deserialize(BufferStream stream, ProjectileShoot instance, bool isDelta)
	{
		if (!isDelta && instance.projectiles == null)
		{
			instance.projectiles = Pool.Get<List<Projectile>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.projectiles.Add(Projectile.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ProjectileShoot DeserializeLengthDelimited(BufferStream stream, ProjectileShoot instance, bool isDelta)
	{
		if (!isDelta && instance.projectiles == null)
		{
			instance.projectiles = Pool.Get<List<Projectile>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.projectiles.Add(Projectile.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ProjectileShoot DeserializeLength(BufferStream stream, int length, ProjectileShoot instance, bool isDelta)
	{
		if (!isDelta && instance.projectiles == null)
		{
			instance.projectiles = Pool.Get<List<Projectile>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.projectiles.Add(Projectile.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ProjectileShoot instance, ProjectileShoot previous)
	{
		if (instance.ammoType != previous.ammoType)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoType);
		}
		if (instance.projectiles == null)
		{
			return;
		}
		for (int i = 0; i < instance.projectiles.Count; i++)
		{
			Projectile projectile = instance.projectiles[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Projectile.SerializeDelta(stream, projectile, projectile);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field projectiles (ProtoBuf.ProjectileShoot.Projectile)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, ProjectileShoot instance)
	{
		if (instance.ammoType != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoType);
		}
		if (instance.projectiles == null)
		{
			return;
		}
		for (int i = 0; i < instance.projectiles.Count; i++)
		{
			Projectile instance2 = instance.projectiles[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Projectile.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field projectiles (ProtoBuf.ProjectileShoot.Projectile)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (projectiles != null)
		{
			for (int i = 0; i < projectiles.Count; i++)
			{
				projectiles[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class PuzzleReset : IDisposable, IPooled, IProto<PuzzleReset>, IProto
{
	[NonSerialized]
	public bool playerBlocksReset;

	[NonSerialized]
	public float playerDetectionRadius;

	[NonSerialized]
	public Vector3 playerDetectionOrigin;

	[NonSerialized]
	public float timeBetweenResets;

	[NonSerialized]
	public bool scaleWithServerPopulation;

	[NonSerialized]
	public bool checkSleepingAIZForPlayers;

	[NonSerialized]
	public bool ignoreAboveGroundPlayers;

	[NonSerialized]
	public bool broadcastResetMessage;

	[NonSerialized]
	public string resetPhrase;

	[NonSerialized]
	public bool radiationReset;

	[NonSerialized]
	public bool pauseUntilLooted;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PuzzleReset instance)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.playerBlocksReset = false;
			instance.playerDetectionRadius = 0f;
			instance.playerDetectionOrigin = default(Vector3);
			instance.timeBetweenResets = 0f;
			instance.scaleWithServerPopulation = false;
			instance.checkSleepingAIZForPlayers = false;
			instance.ignoreAboveGroundPlayers = false;
			instance.broadcastResetMessage = false;
			instance.resetPhrase = string.Empty;
			instance.radiationReset = false;
			instance.pauseUntilLooted = false;
			Pool.Free<PuzzleReset>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PuzzleReset with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PuzzleReset instance)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		instance.playerBlocksReset = playerBlocksReset;
		instance.playerDetectionRadius = playerDetectionRadius;
		instance.playerDetectionOrigin = playerDetectionOrigin;
		instance.timeBetweenResets = timeBetweenResets;
		instance.scaleWithServerPopulation = scaleWithServerPopulation;
		instance.checkSleepingAIZForPlayers = checkSleepingAIZForPlayers;
		instance.ignoreAboveGroundPlayers = ignoreAboveGroundPlayers;
		instance.broadcastResetMessage = broadcastResetMessage;
		instance.resetPhrase = resetPhrase;
		instance.radiationReset = radiationReset;
		instance.pauseUntilLooted = pauseUntilLooted;
	}

	public PuzzleReset Copy()
	{
		PuzzleReset puzzleReset = Pool.Get<PuzzleReset>();
		CopyTo(puzzleReset);
		return puzzleReset;
	}

	public static PuzzleReset Deserialize(BufferStream stream)
	{
		PuzzleReset puzzleReset = Pool.Get<PuzzleReset>();
		Deserialize(stream, puzzleReset, isDelta: false);
		return puzzleReset;
	}

	public static PuzzleReset DeserializeLengthDelimited(BufferStream stream)
	{
		PuzzleReset puzzleReset = Pool.Get<PuzzleReset>();
		DeserializeLengthDelimited(stream, puzzleReset, isDelta: false);
		return puzzleReset;
	}

	public static PuzzleReset DeserializeLength(BufferStream stream, int length)
	{
		PuzzleReset puzzleReset = Pool.Get<PuzzleReset>();
		DeserializeLength(stream, length, puzzleReset, isDelta: false);
		return puzzleReset;
	}

	public static PuzzleReset Deserialize(byte[] buffer)
	{
		PuzzleReset puzzleReset = Pool.Get<PuzzleReset>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, puzzleReset, isDelta: false);
		return puzzleReset;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PuzzleReset previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PuzzleReset Deserialize(BufferStream stream, PuzzleReset instance, bool isDelta)
	{
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.playerBlocksReset = ProtocolParser.ReadBool(stream);
				continue;
			case 21:
				instance.playerDetectionRadius = ProtocolParser.ReadSingle(stream);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.playerDetectionOrigin, isDelta);
				continue;
			case 37:
				instance.timeBetweenResets = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.scaleWithServerPopulation = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.checkSleepingAIZForPlayers = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.ignoreAboveGroundPlayers = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.broadcastResetMessage = ProtocolParser.ReadBool(stream);
				continue;
			case 74:
				instance.resetPhrase = ProtocolParser.ReadString(stream);
				continue;
			case 80:
				instance.radiationReset = ProtocolParser.ReadBool(stream);
				continue;
			case 88:
				instance.pauseUntilLooted = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PuzzleReset DeserializeLengthDelimited(BufferStream stream, PuzzleReset instance, bool isDelta)
	{
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.playerBlocksReset = ProtocolParser.ReadBool(stream);
				continue;
			case 21:
				instance.playerDetectionRadius = ProtocolParser.ReadSingle(stream);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.playerDetectionOrigin, isDelta);
				continue;
			case 37:
				instance.timeBetweenResets = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.scaleWithServerPopulation = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.checkSleepingAIZForPlayers = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.ignoreAboveGroundPlayers = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.broadcastResetMessage = ProtocolParser.ReadBool(stream);
				continue;
			case 74:
				instance.resetPhrase = ProtocolParser.ReadString(stream);
				continue;
			case 80:
				instance.radiationReset = ProtocolParser.ReadBool(stream);
				continue;
			case 88:
				instance.pauseUntilLooted = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PuzzleReset DeserializeLength(BufferStream stream, int length, PuzzleReset instance, bool isDelta)
	{
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.playerBlocksReset = ProtocolParser.ReadBool(stream);
				continue;
			case 21:
				instance.playerDetectionRadius = ProtocolParser.ReadSingle(stream);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.playerDetectionOrigin, isDelta);
				continue;
			case 37:
				instance.timeBetweenResets = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.scaleWithServerPopulation = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.checkSleepingAIZForPlayers = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.ignoreAboveGroundPlayers = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.broadcastResetMessage = ProtocolParser.ReadBool(stream);
				continue;
			case 74:
				instance.resetPhrase = ProtocolParser.ReadString(stream);
				continue;
			case 80:
				instance.radiationReset = ProtocolParser.ReadBool(stream);
				continue;
			case 88:
				instance.pauseUntilLooted = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PuzzleReset instance, PuzzleReset previous)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.playerBlocksReset);
		if (instance.playerDetectionRadius != previous.playerDetectionRadius)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.playerDetectionRadius);
		}
		if (instance.playerDetectionOrigin != previous.playerDetectionOrigin)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.playerDetectionOrigin, previous.playerDetectionOrigin);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerDetectionOrigin (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.timeBetweenResets != previous.timeBetweenResets)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.timeBetweenResets);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.scaleWithServerPopulation);
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.checkSleepingAIZForPlayers);
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.ignoreAboveGroundPlayers);
		stream.WriteByte(64);
		ProtocolParser.WriteBool(stream, instance.broadcastResetMessage);
		if (instance.resetPhrase != null && instance.resetPhrase != previous.resetPhrase)
		{
			stream.WriteByte(74);
			ProtocolParser.WriteString(stream, instance.resetPhrase);
		}
		stream.WriteByte(80);
		ProtocolParser.WriteBool(stream, instance.radiationReset);
		stream.WriteByte(88);
		ProtocolParser.WriteBool(stream, instance.pauseUntilLooted);
	}

	public static void Serialize(BufferStream stream, PuzzleReset instance)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.playerBlocksReset)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.playerBlocksReset);
		}
		if (instance.playerDetectionRadius != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.playerDetectionRadius);
		}
		if (instance.playerDetectionOrigin != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.playerDetectionOrigin);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerDetectionOrigin (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.timeBetweenResets != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.timeBetweenResets);
		}
		if (instance.scaleWithServerPopulation)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.scaleWithServerPopulation);
		}
		if (instance.checkSleepingAIZForPlayers)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.checkSleepingAIZForPlayers);
		}
		if (instance.ignoreAboveGroundPlayers)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.ignoreAboveGroundPlayers);
		}
		if (instance.broadcastResetMessage)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteBool(stream, instance.broadcastResetMessage);
		}
		if (instance.resetPhrase != null)
		{
			stream.WriteByte(74);
			ProtocolParser.WriteString(stream, instance.resetPhrase);
		}
		if (instance.radiationReset)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteBool(stream, instance.radiationReset);
		}
		if (instance.pauseUntilLooted)
		{
			stream.WriteByte(88);
			ProtocolParser.WriteBool(stream, instance.pauseUntilLooted);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class RadioList : IDisposable, IPooled, IProto<RadioList>, IProto
{
	[NonSerialized]
	public List<string> stationUrls;

	[NonSerialized]
	public List<string> stationNames;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(RadioList instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.stationUrls != null)
			{
				List<string> list = instance.stationUrls;
				Pool.FreeUnmanaged<string>(ref list);
				instance.stationUrls = list;
			}
			if (instance.stationNames != null)
			{
				List<string> list2 = instance.stationNames;
				Pool.FreeUnmanaged<string>(ref list2);
				instance.stationNames = list2;
			}
			Pool.Free<RadioList>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose RadioList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(RadioList instance)
	{
		if (stationUrls != null)
		{
			instance.stationUrls = Pool.Get<List<string>>();
			for (int i = 0; i < stationUrls.Count; i++)
			{
				string item = stationUrls[i];
				instance.stationUrls.Add(item);
			}
		}
		else
		{
			instance.stationUrls = null;
		}
		if (stationNames != null)
		{
			instance.stationNames = Pool.Get<List<string>>();
			for (int j = 0; j < stationNames.Count; j++)
			{
				string item2 = stationNames[j];
				instance.stationNames.Add(item2);
			}
		}
		else
		{
			instance.stationNames = null;
		}
	}

	public RadioList Copy()
	{
		RadioList radioList = Pool.Get<RadioList>();
		CopyTo(radioList);
		return radioList;
	}

	public static RadioList Deserialize(BufferStream stream)
	{
		RadioList radioList = Pool.Get<RadioList>();
		Deserialize(stream, radioList, isDelta: false);
		return radioList;
	}

	public static RadioList DeserializeLengthDelimited(BufferStream stream)
	{
		RadioList radioList = Pool.Get<RadioList>();
		DeserializeLengthDelimited(stream, radioList, isDelta: false);
		return radioList;
	}

	public static RadioList DeserializeLength(BufferStream stream, int length)
	{
		RadioList radioList = Pool.Get<RadioList>();
		DeserializeLength(stream, length, radioList, isDelta: false);
		return radioList;
	}

	public static RadioList Deserialize(byte[] buffer)
	{
		RadioList radioList = Pool.Get<RadioList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, radioList, isDelta: false);
		return radioList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, RadioList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static RadioList Deserialize(BufferStream stream, RadioList instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.stationUrls == null)
			{
				instance.stationUrls = Pool.Get<List<string>>();
			}
			if (instance.stationNames == null)
			{
				instance.stationNames = Pool.Get<List<string>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.stationUrls.Add(ProtocolParser.ReadString(stream));
				continue;
			case 18:
				instance.stationNames.Add(ProtocolParser.ReadString(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static RadioList DeserializeLengthDelimited(BufferStream stream, RadioList instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.stationUrls == null)
			{
				instance.stationUrls = Pool.Get<List<string>>();
			}
			if (instance.stationNames == null)
			{
				instance.stationNames = Pool.Get<List<string>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.stationUrls.Add(ProtocolParser.ReadString(stream));
				continue;
			case 18:
				instance.stationNames.Add(ProtocolParser.ReadString(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static RadioList DeserializeLength(BufferStream stream, int length, RadioList instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.stationUrls == null)
			{
				instance.stationUrls = Pool.Get<List<string>>();
			}
			if (instance.stationNames == null)
			{
				instance.stationNames = Pool.Get<List<string>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.stationUrls.Add(ProtocolParser.ReadString(stream));
				continue;
			case 18:
				instance.stationNames.Add(ProtocolParser.ReadString(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, RadioList instance, RadioList previous)
	{
		if (instance.stationUrls != null)
		{
			for (int i = 0; i < instance.stationUrls.Count; i++)
			{
				string val = instance.stationUrls[i];
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, val);
			}
		}
		if (instance.stationNames != null)
		{
			for (int j = 0; j < instance.stationNames.Count; j++)
			{
				string val2 = instance.stationNames[j];
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, val2);
			}
		}
	}

	public static void Serialize(BufferStream stream, RadioList instance)
	{
		if (instance.stationUrls != null)
		{
			for (int i = 0; i < instance.stationUrls.Count; i++)
			{
				string val = instance.stationUrls[i];
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, val);
			}
		}
		if (instance.stationNames != null)
		{
			for (int j = 0; j < instance.stationNames.Count; j++)
			{
				string val2 = instance.stationNames[j];
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, val2);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Ragdoll : IDisposable, IPooled, IProto<Ragdoll>, IProto
{
	[NonSerialized]
	public float time;

	[NonSerialized]
	public List<int> positions;

	[NonSerialized]
	public List<int> rotations;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Ragdoll instance)
	{
		if (instance.ShouldPool)
		{
			instance.time = 0f;
			if (instance.positions != null)
			{
				List<int> list = instance.positions;
				Pool.FreeUnmanaged<int>(ref list);
				instance.positions = list;
			}
			if (instance.rotations != null)
			{
				List<int> list2 = instance.rotations;
				Pool.FreeUnmanaged<int>(ref list2);
				instance.rotations = list2;
			}
			Pool.Free<Ragdoll>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Ragdoll with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Ragdoll instance)
	{
		instance.time = time;
		if (positions != null)
		{
			instance.positions = Pool.Get<List<int>>();
			for (int i = 0; i < positions.Count; i++)
			{
				int item = positions[i];
				instance.positions.Add(item);
			}
		}
		else
		{
			instance.positions = null;
		}
		if (rotations != null)
		{
			instance.rotations = Pool.Get<List<int>>();
			for (int j = 0; j < rotations.Count; j++)
			{
				int item2 = rotations[j];
				instance.rotations.Add(item2);
			}
		}
		else
		{
			instance.rotations = null;
		}
	}

	public Ragdoll Copy()
	{
		Ragdoll ragdoll = Pool.Get<Ragdoll>();
		CopyTo(ragdoll);
		return ragdoll;
	}

	public static Ragdoll Deserialize(BufferStream stream)
	{
		Ragdoll ragdoll = Pool.Get<Ragdoll>();
		Deserialize(stream, ragdoll, isDelta: false);
		return ragdoll;
	}

	public static Ragdoll DeserializeLengthDelimited(BufferStream stream)
	{
		Ragdoll ragdoll = Pool.Get<Ragdoll>();
		DeserializeLengthDelimited(stream, ragdoll, isDelta: false);
		return ragdoll;
	}

	public static Ragdoll DeserializeLength(BufferStream stream, int length)
	{
		Ragdoll ragdoll = Pool.Get<Ragdoll>();
		DeserializeLength(stream, length, ragdoll, isDelta: false);
		return ragdoll;
	}

	public static Ragdoll Deserialize(byte[] buffer)
	{
		Ragdoll ragdoll = Pool.Get<Ragdoll>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ragdoll, isDelta: false);
		return ragdoll;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Ragdoll previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Ragdoll Deserialize(BufferStream stream, Ragdoll instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.positions == null)
			{
				instance.positions = Pool.Get<List<int>>();
			}
			if (instance.rotations == null)
			{
				instance.rotations = Pool.Get<List<int>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.positions.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.rotations.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Ragdoll DeserializeLengthDelimited(BufferStream stream, Ragdoll instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.positions == null)
			{
				instance.positions = Pool.Get<List<int>>();
			}
			if (instance.rotations == null)
			{
				instance.rotations = Pool.Get<List<int>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.positions.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.rotations.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Ragdoll DeserializeLength(BufferStream stream, int length, Ragdoll instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.positions == null)
			{
				instance.positions = Pool.Get<List<int>>();
			}
			if (instance.rotations == null)
			{
				instance.rotations = Pool.Get<List<int>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.positions.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.rotations.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Ragdoll instance, Ragdoll previous)
	{
		if (instance.time != previous.time)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		if (instance.positions != null)
		{
			for (int i = 0; i < instance.positions.Count; i++)
			{
				int num = instance.positions[i];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.rotations != null)
		{
			for (int j = 0; j < instance.rotations.Count; j++)
			{
				int num2 = instance.rotations[j];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)num2);
			}
		}
	}

	public static void Serialize(BufferStream stream, Ragdoll instance)
	{
		if (instance.time != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		if (instance.positions != null)
		{
			for (int i = 0; i < instance.positions.Count; i++)
			{
				int num = instance.positions[i];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.rotations != null)
		{
			for (int j = 0; j < instance.rotations.Count; j++)
			{
				int num2 = instance.rotations[j];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)num2);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class RCEntity : IDisposable, IPooled, IProto<RCEntity>, IProto
{
	[NonSerialized]
	public Vector3 aim;

	[NonSerialized]
	public float zoom;

	[NonSerialized]
	public string identifier;

	[NonSerialized]
	public string password;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(RCEntity instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.aim = default(Vector3);
			instance.zoom = 0f;
			instance.identifier = string.Empty;
			instance.password = string.Empty;
			Pool.Free<RCEntity>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose RCEntity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(RCEntity instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		instance.aim = aim;
		instance.zoom = zoom;
		instance.identifier = identifier;
		instance.password = password;
	}

	public RCEntity Copy()
	{
		RCEntity rCEntity = Pool.Get<RCEntity>();
		CopyTo(rCEntity);
		return rCEntity;
	}

	public static RCEntity Deserialize(BufferStream stream)
	{
		RCEntity rCEntity = Pool.Get<RCEntity>();
		Deserialize(stream, rCEntity, isDelta: false);
		return rCEntity;
	}

	public static RCEntity DeserializeLengthDelimited(BufferStream stream)
	{
		RCEntity rCEntity = Pool.Get<RCEntity>();
		DeserializeLengthDelimited(stream, rCEntity, isDelta: false);
		return rCEntity;
	}

	public static RCEntity DeserializeLength(BufferStream stream, int length)
	{
		RCEntity rCEntity = Pool.Get<RCEntity>();
		DeserializeLength(stream, length, rCEntity, isDelta: false);
		return rCEntity;
	}

	public static RCEntity Deserialize(byte[] buffer)
	{
		RCEntity rCEntity = Pool.Get<RCEntity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, rCEntity, isDelta: false);
		return rCEntity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, RCEntity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static RCEntity Deserialize(BufferStream stream, RCEntity instance, bool isDelta)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aim, isDelta);
				continue;
			case 21:
				instance.zoom = ProtocolParser.ReadSingle(stream);
				continue;
			case 26:
				instance.identifier = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.password = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static RCEntity DeserializeLengthDelimited(BufferStream stream, RCEntity instance, bool isDelta)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aim, isDelta);
				continue;
			case 21:
				instance.zoom = ProtocolParser.ReadSingle(stream);
				continue;
			case 26:
				instance.identifier = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.password = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static RCEntity DeserializeLength(BufferStream stream, int length, RCEntity instance, bool isDelta)
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aim, isDelta);
				continue;
			case 21:
				instance.zoom = ProtocolParser.ReadSingle(stream);
				continue;
			case 26:
				instance.identifier = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.password = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, RCEntity instance, RCEntity previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.aim != previous.aim)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.aim, previous.aim);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aim (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.zoom != previous.zoom)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.zoom);
		}
		if (instance.identifier != null && instance.identifier != previous.identifier)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.identifier);
		}
		if (instance.password != null && instance.password != previous.password)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.password);
		}
	}

	public static void Serialize(BufferStream stream, RCEntity instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.aim != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.aim);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aim (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.zoom != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.zoom);
		}
		if (instance.identifier != null)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.identifier);
		}
		if (instance.password != null)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.password);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


