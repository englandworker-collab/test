using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ReclaimManager : IDisposable, IPooled, IProto<ReclaimManager>, IProto
{
	public class ReclaimInfo : IDisposable, IPooled, IProto<ReclaimInfo>, IProto
	{
		[NonSerialized]
		public ulong victimID;

		[NonSerialized]
		public ItemContainer mainInventory;

		[NonSerialized]
		public ItemContainer wearInventory;

		[NonSerialized]
		public ItemContainer beltInventory;

		[NonSerialized]
		public ItemContainer backpackInventory;

		[NonSerialized]
		public int reclaimId;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(ReclaimInfo instance)
		{
			if (instance.ShouldPool)
			{
				instance.victimID = 0uL;
				if (instance.mainInventory != null)
				{
					instance.mainInventory.ResetToPool();
					instance.mainInventory = null;
				}
				if (instance.wearInventory != null)
				{
					instance.wearInventory.ResetToPool();
					instance.wearInventory = null;
				}
				if (instance.beltInventory != null)
				{
					instance.beltInventory.ResetToPool();
					instance.beltInventory = null;
				}
				if (instance.backpackInventory != null)
				{
					instance.backpackInventory.ResetToPool();
					instance.backpackInventory = null;
				}
				instance.reclaimId = 0;
				Pool.Free<ReclaimInfo>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose ReclaimInfo with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(ReclaimInfo instance)
		{
			instance.victimID = victimID;
			if (mainInventory != null)
			{
				if (instance.mainInventory == null)
				{
					instance.mainInventory = mainInventory.Copy();
				}
				else
				{
					mainInventory.CopyTo(instance.mainInventory);
				}
			}
			else
			{
				instance.mainInventory = null;
			}
			if (wearInventory != null)
			{
				if (instance.wearInventory == null)
				{
					instance.wearInventory = wearInventory.Copy();
				}
				else
				{
					wearInventory.CopyTo(instance.wearInventory);
				}
			}
			else
			{
				instance.wearInventory = null;
			}
			if (beltInventory != null)
			{
				if (instance.beltInventory == null)
				{
					instance.beltInventory = beltInventory.Copy();
				}
				else
				{
					beltInventory.CopyTo(instance.beltInventory);
				}
			}
			else
			{
				instance.beltInventory = null;
			}
			if (backpackInventory != null)
			{
				if (instance.backpackInventory == null)
				{
					instance.backpackInventory = backpackInventory.Copy();
				}
				else
				{
					backpackInventory.CopyTo(instance.backpackInventory);
				}
			}
			else
			{
				instance.backpackInventory = null;
			}
			instance.reclaimId = reclaimId;
		}

		public ReclaimInfo Copy()
		{
			ReclaimInfo reclaimInfo = Pool.Get<ReclaimInfo>();
			CopyTo(reclaimInfo);
			return reclaimInfo;
		}

		public static ReclaimInfo Deserialize(BufferStream stream)
		{
			ReclaimInfo reclaimInfo = Pool.Get<ReclaimInfo>();
			Deserialize(stream, reclaimInfo, isDelta: false);
			return reclaimInfo;
		}

		public static ReclaimInfo DeserializeLengthDelimited(BufferStream stream)
		{
			ReclaimInfo reclaimInfo = Pool.Get<ReclaimInfo>();
			DeserializeLengthDelimited(stream, reclaimInfo, isDelta: false);
			return reclaimInfo;
		}

		public static ReclaimInfo DeserializeLength(BufferStream stream, int length)
		{
			ReclaimInfo reclaimInfo = Pool.Get<ReclaimInfo>();
			DeserializeLength(stream, length, reclaimInfo, isDelta: false);
			return reclaimInfo;
		}

		public static ReclaimInfo Deserialize(byte[] buffer)
		{
			ReclaimInfo reclaimInfo = Pool.Get<ReclaimInfo>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, reclaimInfo, isDelta: false);
			return reclaimInfo;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, ReclaimInfo previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static ReclaimInfo Deserialize(BufferStream stream, ReclaimInfo instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.victimID = ProtocolParser.ReadUInt64(stream);
					break;
				case 34:
					if (instance.mainInventory == null)
					{
						instance.mainInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.mainInventory, isDelta);
					}
					break;
				case 42:
					if (instance.wearInventory == null)
					{
						instance.wearInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.wearInventory, isDelta);
					}
					break;
				case 50:
					if (instance.beltInventory == null)
					{
						instance.beltInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.beltInventory, isDelta);
					}
					break;
				case 58:
					if (instance.backpackInventory == null)
					{
						instance.backpackInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.backpackInventory, isDelta);
					}
					break;
				case 64:
					instance.reclaimId = (int)ProtocolParser.ReadUInt64(stream);
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				case -1:
				case 0:
					return instance;
				}
			}
		}

		public static ReclaimInfo DeserializeLengthDelimited(BufferStream stream, ReclaimInfo instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.victimID = ProtocolParser.ReadUInt64(stream);
					break;
				case 34:
					if (instance.mainInventory == null)
					{
						instance.mainInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.mainInventory, isDelta);
					}
					break;
				case 42:
					if (instance.wearInventory == null)
					{
						instance.wearInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.wearInventory, isDelta);
					}
					break;
				case 50:
					if (instance.beltInventory == null)
					{
						instance.beltInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.beltInventory, isDelta);
					}
					break;
				case 58:
					if (instance.backpackInventory == null)
					{
						instance.backpackInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.backpackInventory, isDelta);
					}
					break;
				case 64:
					instance.reclaimId = (int)ProtocolParser.ReadUInt64(stream);
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static ReclaimInfo DeserializeLength(BufferStream stream, int length, ReclaimInfo instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.victimID = ProtocolParser.ReadUInt64(stream);
					break;
				case 34:
					if (instance.mainInventory == null)
					{
						instance.mainInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.mainInventory, isDelta);
					}
					break;
				case 42:
					if (instance.wearInventory == null)
					{
						instance.wearInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.wearInventory, isDelta);
					}
					break;
				case 50:
					if (instance.beltInventory == null)
					{
						instance.beltInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.beltInventory, isDelta);
					}
					break;
				case 58:
					if (instance.backpackInventory == null)
					{
						instance.backpackInventory = ItemContainer.DeserializeLengthDelimited(stream);
					}
					else
					{
						ItemContainer.DeserializeLengthDelimited(stream, instance.backpackInventory, isDelta);
					}
					break;
				case 64:
					instance.reclaimId = (int)ProtocolParser.ReadUInt64(stream);
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, ReclaimInfo instance, ReclaimInfo previous)
		{
			if (instance.victimID != previous.victimID)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.victimID);
			}
			if (instance.mainInventory == null)
			{
				throw new ArgumentNullException("mainInventory", "Required by proto specification.");
			}
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.SerializeDelta(stream, instance.mainInventory, previous.mainInventory);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
			if (instance.wearInventory == null)
			{
				throw new ArgumentNullException("wearInventory", "Required by proto specification.");
			}
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			ItemContainer.SerializeDelta(stream, instance.wearInventory, previous.wearInventory);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
			if (instance.beltInventory == null)
			{
				throw new ArgumentNullException("beltInventory", "Required by proto specification.");
			}
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			ItemContainer.SerializeDelta(stream, instance.beltInventory, previous.beltInventory);
			int val3 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
			if (instance.backpackInventory == null)
			{
				throw new ArgumentNullException("backpackInventory", "Required by proto specification.");
			}
			stream.WriteByte(58);
			BufferStream.RangeHandle range4 = stream.GetRange(5);
			int position4 = stream.Position;
			ItemContainer.SerializeDelta(stream, instance.backpackInventory, previous.backpackInventory);
			int val4 = stream.Position - position4;
			Span<byte> span4 = range4.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)val4, span4, 0);
			if (num4 < 5)
			{
				span4[num4 - 1] |= 128;
				while (num4 < 4)
				{
					span4[num4++] = 128;
				}
				span4[4] = 0;
			}
			if (instance.reclaimId != previous.reclaimId)
			{
				stream.WriteByte(64);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.reclaimId);
			}
		}

		public static void Serialize(BufferStream stream, ReclaimInfo instance)
		{
			if (instance.victimID != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.victimID);
			}
			if (instance.mainInventory == null)
			{
				throw new ArgumentNullException("mainInventory", "Required by proto specification.");
			}
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.Serialize(stream, instance.mainInventory);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
			if (instance.wearInventory == null)
			{
				throw new ArgumentNullException("wearInventory", "Required by proto specification.");
			}
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			ItemContainer.Serialize(stream, instance.wearInventory);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
			if (instance.beltInventory == null)
			{
				throw new ArgumentNullException("beltInventory", "Required by proto specification.");
			}
			stream.WriteByte(50);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			ItemContainer.Serialize(stream, instance.beltInventory);
			int val3 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
			if (instance.backpackInventory == null)
			{
				throw new ArgumentNullException("backpackInventory", "Required by proto specification.");
			}
			stream.WriteByte(58);
			BufferStream.RangeHandle range4 = stream.GetRange(5);
			int position4 = stream.Position;
			ItemContainer.Serialize(stream, instance.backpackInventory);
			int val4 = stream.Position - position4;
			Span<byte> span4 = range4.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)val4, span4, 0);
			if (num4 < 5)
			{
				span4[num4 - 1] |= 128;
				while (num4 < 4)
				{
					span4[num4++] = 128;
				}
				span4[4] = 0;
			}
			if (instance.reclaimId != 0)
			{
				stream.WriteByte(64);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.reclaimId);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			mainInventory?.InspectUids(action);
			wearInventory?.InspectUids(action);
			beltInventory?.InspectUids(action);
			backpackInventory?.InspectUids(action);
		}
	}

	[NonSerialized]
	public List<ReclaimInfo> reclaimEntries;

	[NonSerialized]
	public int lastReclaimID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ReclaimManager instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.reclaimEntries != null)
		{
			for (int i = 0; i < instance.reclaimEntries.Count; i++)
			{
				if (instance.reclaimEntries[i] != null)
				{
					instance.reclaimEntries[i].ResetToPool();
					instance.reclaimEntries[i] = null;
				}
			}
			List<ReclaimInfo> list = instance.reclaimEntries;
			Pool.Free<ReclaimInfo>(ref list, false);
			instance.reclaimEntries = list;
		}
		instance.lastReclaimID = 0;
		Pool.Free<ReclaimManager>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ReclaimManager with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ReclaimManager instance)
	{
		if (reclaimEntries != null)
		{
			instance.reclaimEntries = Pool.Get<List<ReclaimInfo>>();
			for (int i = 0; i < reclaimEntries.Count; i++)
			{
				ReclaimInfo item = reclaimEntries[i].Copy();
				instance.reclaimEntries.Add(item);
			}
		}
		else
		{
			instance.reclaimEntries = null;
		}
		instance.lastReclaimID = lastReclaimID;
	}

	public ReclaimManager Copy()
	{
		ReclaimManager reclaimManager = Pool.Get<ReclaimManager>();
		CopyTo(reclaimManager);
		return reclaimManager;
	}

	public static ReclaimManager Deserialize(BufferStream stream)
	{
		ReclaimManager reclaimManager = Pool.Get<ReclaimManager>();
		Deserialize(stream, reclaimManager, isDelta: false);
		return reclaimManager;
	}

	public static ReclaimManager DeserializeLengthDelimited(BufferStream stream)
	{
		ReclaimManager reclaimManager = Pool.Get<ReclaimManager>();
		DeserializeLengthDelimited(stream, reclaimManager, isDelta: false);
		return reclaimManager;
	}

	public static ReclaimManager DeserializeLength(BufferStream stream, int length)
	{
		ReclaimManager reclaimManager = Pool.Get<ReclaimManager>();
		DeserializeLength(stream, length, reclaimManager, isDelta: false);
		return reclaimManager;
	}

	public static ReclaimManager Deserialize(byte[] buffer)
	{
		ReclaimManager reclaimManager = Pool.Get<ReclaimManager>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, reclaimManager, isDelta: false);
		return reclaimManager;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ReclaimManager previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ReclaimManager Deserialize(BufferStream stream, ReclaimManager instance, bool isDelta)
	{
		if (!isDelta && instance.reclaimEntries == null)
		{
			instance.reclaimEntries = Pool.Get<List<ReclaimInfo>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.reclaimEntries.Add(ReclaimInfo.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.lastReclaimID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ReclaimManager DeserializeLengthDelimited(BufferStream stream, ReclaimManager instance, bool isDelta)
	{
		if (!isDelta && instance.reclaimEntries == null)
		{
			instance.reclaimEntries = Pool.Get<List<ReclaimInfo>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.reclaimEntries.Add(ReclaimInfo.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.lastReclaimID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ReclaimManager DeserializeLength(BufferStream stream, int length, ReclaimManager instance, bool isDelta)
	{
		if (!isDelta && instance.reclaimEntries == null)
		{
			instance.reclaimEntries = Pool.Get<List<ReclaimInfo>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.reclaimEntries.Add(ReclaimInfo.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.lastReclaimID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ReclaimManager instance, ReclaimManager previous)
	{
		if (instance.reclaimEntries != null)
		{
			for (int i = 0; i < instance.reclaimEntries.Count; i++)
			{
				ReclaimInfo reclaimInfo = instance.reclaimEntries[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				ReclaimInfo.SerializeDelta(stream, reclaimInfo, reclaimInfo);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.lastReclaimID != previous.lastReclaimID)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastReclaimID);
		}
	}

	public static void Serialize(BufferStream stream, ReclaimManager instance)
	{
		if (instance.reclaimEntries != null)
		{
			for (int i = 0; i < instance.reclaimEntries.Count; i++)
			{
				ReclaimInfo instance2 = instance.reclaimEntries[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				ReclaimInfo.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.lastReclaimID != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastReclaimID);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (reclaimEntries != null)
		{
			for (int i = 0; i < reclaimEntries.Count; i++)
			{
				reclaimEntries[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ReclaimTerminal : IDisposable, IPooled, IProto<ReclaimTerminal>, IProto
{
	[NonSerialized]
	public int itemCount;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ReclaimTerminal instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemCount = 0;
			Pool.Free<ReclaimTerminal>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ReclaimTerminal with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ReclaimTerminal instance)
	{
		instance.itemCount = itemCount;
	}

	public ReclaimTerminal Copy()
	{
		ReclaimTerminal reclaimTerminal = Pool.Get<ReclaimTerminal>();
		CopyTo(reclaimTerminal);
		return reclaimTerminal;
	}

	public static ReclaimTerminal Deserialize(BufferStream stream)
	{
		ReclaimTerminal reclaimTerminal = Pool.Get<ReclaimTerminal>();
		Deserialize(stream, reclaimTerminal, isDelta: false);
		return reclaimTerminal;
	}

	public static ReclaimTerminal DeserializeLengthDelimited(BufferStream stream)
	{
		ReclaimTerminal reclaimTerminal = Pool.Get<ReclaimTerminal>();
		DeserializeLengthDelimited(stream, reclaimTerminal, isDelta: false);
		return reclaimTerminal;
	}

	public static ReclaimTerminal DeserializeLength(BufferStream stream, int length)
	{
		ReclaimTerminal reclaimTerminal = Pool.Get<ReclaimTerminal>();
		DeserializeLength(stream, length, reclaimTerminal, isDelta: false);
		return reclaimTerminal;
	}

	public static ReclaimTerminal Deserialize(byte[] buffer)
	{
		ReclaimTerminal reclaimTerminal = Pool.Get<ReclaimTerminal>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, reclaimTerminal, isDelta: false);
		return reclaimTerminal;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ReclaimTerminal previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ReclaimTerminal Deserialize(BufferStream stream, ReclaimTerminal instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ReclaimTerminal DeserializeLengthDelimited(BufferStream stream, ReclaimTerminal instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ReclaimTerminal DeserializeLength(BufferStream stream, int length, ReclaimTerminal instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ReclaimTerminal instance, ReclaimTerminal previous)
	{
		if (instance.itemCount != previous.itemCount)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemCount);
		}
	}

	public static void Serialize(BufferStream stream, ReclaimTerminal instance)
	{
		if (instance.itemCount != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemCount);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class RelationshipManager : IDisposable, IPooled, IProto<RelationshipManager>, IProto
{
	public class PlayerRelationshipInfo : IDisposable, IPooled, IProto<PlayerRelationshipInfo>, IProto
	{
		[NonSerialized]
		public ulong playerID;

		[NonSerialized]
		public int type;

		[NonSerialized]
		public int weight;

		[NonSerialized]
		public uint mugshotCrc;

		[NonSerialized]
		public string displayName;

		[NonSerialized]
		public string notes;

		[NonSerialized]
		public float timeSinceSeen;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(PlayerRelationshipInfo instance)
		{
			if (instance.ShouldPool)
			{
				instance.playerID = 0uL;
				instance.type = 0;
				instance.weight = 0;
				instance.mugshotCrc = 0u;
				instance.displayName = string.Empty;
				instance.notes = string.Empty;
				instance.timeSinceSeen = 0f;
				Pool.Free<PlayerRelationshipInfo>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose PlayerRelationshipInfo with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(PlayerRelationshipInfo instance)
		{
			instance.playerID = playerID;
			instance.type = type;
			instance.weight = weight;
			instance.mugshotCrc = mugshotCrc;
			instance.displayName = displayName;
			instance.notes = notes;
			instance.timeSinceSeen = timeSinceSeen;
		}

		public PlayerRelationshipInfo Copy()
		{
			PlayerRelationshipInfo playerRelationshipInfo = Pool.Get<PlayerRelationshipInfo>();
			CopyTo(playerRelationshipInfo);
			return playerRelationshipInfo;
		}

		public static PlayerRelationshipInfo Deserialize(BufferStream stream)
		{
			PlayerRelationshipInfo playerRelationshipInfo = Pool.Get<PlayerRelationshipInfo>();
			Deserialize(stream, playerRelationshipInfo, isDelta: false);
			return playerRelationshipInfo;
		}

		public static PlayerRelationshipInfo DeserializeLengthDelimited(BufferStream stream)
		{
			PlayerRelationshipInfo playerRelationshipInfo = Pool.Get<PlayerRelationshipInfo>();
			DeserializeLengthDelimited(stream, playerRelationshipInfo, isDelta: false);
			return playerRelationshipInfo;
		}

		public static PlayerRelationshipInfo DeserializeLength(BufferStream stream, int length)
		{
			PlayerRelationshipInfo playerRelationshipInfo = Pool.Get<PlayerRelationshipInfo>();
			DeserializeLength(stream, length, playerRelationshipInfo, isDelta: false);
			return playerRelationshipInfo;
		}

		public static PlayerRelationshipInfo Deserialize(byte[] buffer)
		{
			PlayerRelationshipInfo playerRelationshipInfo = Pool.Get<PlayerRelationshipInfo>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, playerRelationshipInfo, isDelta: false);
			return playerRelationshipInfo;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, PlayerRelationshipInfo previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static PlayerRelationshipInfo Deserialize(BufferStream stream, PlayerRelationshipInfo instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.weight = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.mugshotCrc = ProtocolParser.ReadUInt32(stream);
					continue;
				case 42:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 50:
					instance.notes = ProtocolParser.ReadString(stream);
					continue;
				case 61:
					instance.timeSinceSeen = ProtocolParser.ReadSingle(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static PlayerRelationshipInfo DeserializeLengthDelimited(BufferStream stream, PlayerRelationshipInfo instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.weight = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.mugshotCrc = ProtocolParser.ReadUInt32(stream);
					continue;
				case 42:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 50:
					instance.notes = ProtocolParser.ReadString(stream);
					continue;
				case 61:
					instance.timeSinceSeen = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static PlayerRelationshipInfo DeserializeLength(BufferStream stream, int length, PlayerRelationshipInfo instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.weight = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.mugshotCrc = ProtocolParser.ReadUInt32(stream);
					continue;
				case 42:
					instance.displayName = ProtocolParser.ReadString(stream);
					continue;
				case 50:
					instance.notes = ProtocolParser.ReadString(stream);
					continue;
				case 61:
					instance.timeSinceSeen = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, PlayerRelationshipInfo instance, PlayerRelationshipInfo previous)
		{
			if (instance.playerID != previous.playerID)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.playerID);
			}
			if (instance.type != previous.type)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			}
			if (instance.weight != previous.weight)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.weight);
			}
			if (instance.mugshotCrc != previous.mugshotCrc)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt32(stream, instance.mugshotCrc);
			}
			if (instance.displayName != null && instance.displayName != previous.displayName)
			{
				stream.WriteByte(42);
				ProtocolParser.WriteString(stream, instance.displayName);
			}
			if (instance.notes != null && instance.notes != previous.notes)
			{
				stream.WriteByte(50);
				ProtocolParser.WriteString(stream, instance.notes);
			}
			if (instance.timeSinceSeen != previous.timeSinceSeen)
			{
				stream.WriteByte(61);
				ProtocolParser.WriteSingle(stream, instance.timeSinceSeen);
			}
		}

		public static void Serialize(BufferStream stream, PlayerRelationshipInfo instance)
		{
			if (instance.playerID != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.playerID);
			}
			if (instance.type != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			}
			if (instance.weight != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.weight);
			}
			if (instance.mugshotCrc != 0)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt32(stream, instance.mugshotCrc);
			}
			if (instance.displayName != null)
			{
				stream.WriteByte(42);
				ProtocolParser.WriteString(stream, instance.displayName);
			}
			if (instance.notes != null)
			{
				stream.WriteByte(50);
				ProtocolParser.WriteString(stream, instance.notes);
			}
			if (instance.timeSinceSeen != 0f)
			{
				stream.WriteByte(61);
				ProtocolParser.WriteSingle(stream, instance.timeSinceSeen);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class PlayerRelationships : IDisposable, IPooled, IProto<PlayerRelationships>, IProto
	{
		[NonSerialized]
		public ulong playerID;

		[NonSerialized]
		public List<PlayerRelationshipInfo> relations;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(PlayerRelationships instance)
		{
			if (!instance.ShouldPool)
			{
				return;
			}
			instance.playerID = 0uL;
			if (instance.relations != null)
			{
				for (int i = 0; i < instance.relations.Count; i++)
				{
					if (instance.relations[i] != null)
					{
						instance.relations[i].ResetToPool();
						instance.relations[i] = null;
					}
				}
				List<PlayerRelationshipInfo> list = instance.relations;
				Pool.Free<PlayerRelationshipInfo>(ref list, false);
				instance.relations = list;
			}
			Pool.Free<PlayerRelationships>(ref instance);
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose PlayerRelationships with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(PlayerRelationships instance)
		{
			instance.playerID = playerID;
			if (relations != null)
			{
				instance.relations = Pool.Get<List<PlayerRelationshipInfo>>();
				for (int i = 0; i < relations.Count; i++)
				{
					PlayerRelationshipInfo item = relations[i].Copy();
					instance.relations.Add(item);
				}
			}
			else
			{
				instance.relations = null;
			}
		}

		public PlayerRelationships Copy()
		{
			PlayerRelationships playerRelationships = Pool.Get<PlayerRelationships>();
			CopyTo(playerRelationships);
			return playerRelationships;
		}

		public static PlayerRelationships Deserialize(BufferStream stream)
		{
			PlayerRelationships playerRelationships = Pool.Get<PlayerRelationships>();
			Deserialize(stream, playerRelationships, isDelta: false);
			return playerRelationships;
		}

		public static PlayerRelationships DeserializeLengthDelimited(BufferStream stream)
		{
			PlayerRelationships playerRelationships = Pool.Get<PlayerRelationships>();
			DeserializeLengthDelimited(stream, playerRelationships, isDelta: false);
			return playerRelationships;
		}

		public static PlayerRelationships DeserializeLength(BufferStream stream, int length)
		{
			PlayerRelationships playerRelationships = Pool.Get<PlayerRelationships>();
			DeserializeLength(stream, length, playerRelationships, isDelta: false);
			return playerRelationships;
		}

		public static PlayerRelationships Deserialize(byte[] buffer)
		{
			PlayerRelationships playerRelationships = Pool.Get<PlayerRelationships>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, playerRelationships, isDelta: false);
			return playerRelationships;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, PlayerRelationships previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static PlayerRelationships Deserialize(BufferStream stream, PlayerRelationships instance, bool isDelta)
		{
			if (!isDelta && instance.relations == null)
			{
				instance.relations = Pool.Get<List<PlayerRelationshipInfo>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.relations.Add(PlayerRelationshipInfo.DeserializeLengthDelimited(stream));
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static PlayerRelationships DeserializeLengthDelimited(BufferStream stream, PlayerRelationships instance, bool isDelta)
		{
			if (!isDelta && instance.relations == null)
			{
				instance.relations = Pool.Get<List<PlayerRelationshipInfo>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.relations.Add(PlayerRelationshipInfo.DeserializeLengthDelimited(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static PlayerRelationships DeserializeLength(BufferStream stream, int length, PlayerRelationships instance, bool isDelta)
		{
			if (!isDelta && instance.relations == null)
			{
				instance.relations = Pool.Get<List<PlayerRelationshipInfo>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.playerID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.relations.Add(PlayerRelationshipInfo.DeserializeLengthDelimited(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, PlayerRelationships instance, PlayerRelationships previous)
		{
			if (instance.playerID != previous.playerID)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.playerID);
			}
			if (instance.relations == null)
			{
				return;
			}
			for (int i = 0; i < instance.relations.Count; i++)
			{
				PlayerRelationshipInfo playerRelationshipInfo = instance.relations[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PlayerRelationshipInfo.SerializeDelta(stream, playerRelationshipInfo, playerRelationshipInfo);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}

		public static void Serialize(BufferStream stream, PlayerRelationships instance)
		{
			if (instance.playerID != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.playerID);
			}
			if (instance.relations == null)
			{
				return;
			}
			for (int i = 0; i < instance.relations.Count; i++)
			{
				PlayerRelationshipInfo instance2 = instance.relations[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PlayerRelationshipInfo.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			if (relations != null)
			{
				for (int i = 0; i < relations.Count; i++)
				{
					relations[i]?.InspectUids(action);
				}
			}
		}
	}

	[NonSerialized]
	public List<PlayerTeam> teamList;

	[NonSerialized]
	public int maxTeamSize;

	[NonSerialized]
	public List<PlayerRelationships> relationships;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(RelationshipManager instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.teamList != null)
		{
			for (int i = 0; i < instance.teamList.Count; i++)
			{
				if (instance.teamList[i] != null)
				{
					instance.teamList[i].ResetToPool();
					instance.teamList[i] = null;
				}
			}
			List<PlayerTeam> list = instance.teamList;
			Pool.Free<PlayerTeam>(ref list, false);
			instance.teamList = list;
		}
		instance.maxTeamSize = 0;
		if (instance.relationships != null)
		{
			for (int j = 0; j < instance.relationships.Count; j++)
			{
				if (instance.relationships[j] != null)
				{
					instance.relationships[j].ResetToPool();
					instance.relationships[j] = null;
				}
			}
			List<PlayerRelationships> list2 = instance.relationships;
			Pool.Free<PlayerRelationships>(ref list2, false);
			instance.relationships = list2;
		}
		Pool.Free<RelationshipManager>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose RelationshipManager with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(RelationshipManager instance)
	{
		if (teamList != null)
		{
			instance.teamList = Pool.Get<List<PlayerTeam>>();
			for (int i = 0; i < teamList.Count; i++)
			{
				PlayerTeam item = teamList[i].Copy();
				instance.teamList.Add(item);
			}
		}
		else
		{
			instance.teamList = null;
		}
		instance.maxTeamSize = maxTeamSize;
		if (relationships != null)
		{
			instance.relationships = Pool.Get<List<PlayerRelationships>>();
			for (int j = 0; j < relationships.Count; j++)
			{
				PlayerRelationships item2 = relationships[j].Copy();
				instance.relationships.Add(item2);
			}
		}
		else
		{
			instance.relationships = null;
		}
	}

	public RelationshipManager Copy()
	{
		RelationshipManager relationshipManager = Pool.Get<RelationshipManager>();
		CopyTo(relationshipManager);
		return relationshipManager;
	}

	public static RelationshipManager Deserialize(BufferStream stream)
	{
		RelationshipManager relationshipManager = Pool.Get<RelationshipManager>();
		Deserialize(stream, relationshipManager, isDelta: false);
		return relationshipManager;
	}

	public static RelationshipManager DeserializeLengthDelimited(BufferStream stream)
	{
		RelationshipManager relationshipManager = Pool.Get<RelationshipManager>();
		DeserializeLengthDelimited(stream, relationshipManager, isDelta: false);
		return relationshipManager;
	}

	public static RelationshipManager DeserializeLength(BufferStream stream, int length)
	{
		RelationshipManager relationshipManager = Pool.Get<RelationshipManager>();
		DeserializeLength(stream, length, relationshipManager, isDelta: false);
		return relationshipManager;
	}

	public static RelationshipManager Deserialize(byte[] buffer)
	{
		RelationshipManager relationshipManager = Pool.Get<RelationshipManager>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, relationshipManager, isDelta: false);
		return relationshipManager;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, RelationshipManager previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static RelationshipManager Deserialize(BufferStream stream, RelationshipManager instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.teamList == null)
			{
				instance.teamList = Pool.Get<List<PlayerTeam>>();
			}
			if (instance.relationships == null)
			{
				instance.relationships = Pool.Get<List<PlayerRelationships>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 18:
				instance.teamList.Add(PlayerTeam.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.maxTeamSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.relationships.Add(PlayerRelationships.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static RelationshipManager DeserializeLengthDelimited(BufferStream stream, RelationshipManager instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.teamList == null)
			{
				instance.teamList = Pool.Get<List<PlayerTeam>>();
			}
			if (instance.relationships == null)
			{
				instance.relationships = Pool.Get<List<PlayerRelationships>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 18:
				instance.teamList.Add(PlayerTeam.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.maxTeamSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.relationships.Add(PlayerRelationships.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static RelationshipManager DeserializeLength(BufferStream stream, int length, RelationshipManager instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.teamList == null)
			{
				instance.teamList = Pool.Get<List<PlayerTeam>>();
			}
			if (instance.relationships == null)
			{
				instance.relationships = Pool.Get<List<PlayerRelationships>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 18:
				instance.teamList.Add(PlayerTeam.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.maxTeamSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.relationships.Add(PlayerRelationships.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, RelationshipManager instance, RelationshipManager previous)
	{
		if (instance.teamList != null)
		{
			for (int i = 0; i < instance.teamList.Count; i++)
			{
				PlayerTeam playerTeam = instance.teamList[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PlayerTeam.SerializeDelta(stream, playerTeam, playerTeam);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.maxTeamSize != previous.maxTeamSize)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxTeamSize);
		}
		if (instance.relationships == null)
		{
			return;
		}
		for (int j = 0; j < instance.relationships.Count; j++)
		{
			PlayerRelationships playerRelationships = instance.relationships[j];
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			PlayerRelationships.SerializeDelta(stream, playerRelationships, playerRelationships);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, RelationshipManager instance)
	{
		if (instance.teamList != null)
		{
			for (int i = 0; i < instance.teamList.Count; i++)
			{
				PlayerTeam instance2 = instance.teamList[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PlayerTeam.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.maxTeamSize != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxTeamSize);
		}
		if (instance.relationships == null)
		{
			return;
		}
		for (int j = 0; j < instance.relationships.Count; j++)
		{
			PlayerRelationships instance3 = instance.relationships[j];
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			PlayerRelationships.Serialize(stream, instance3);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (teamList != null)
		{
			for (int i = 0; i < teamList.Count; i++)
			{
				teamList[i]?.InspectUids(action);
			}
		}
		if (relationships != null)
		{
			for (int j = 0; j < relationships.Count; j++)
			{
				relationships[j]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ResearchTable : IDisposable, IPooled, IProto<ResearchTable>, IProto
{
	[NonSerialized]
	public float researchTimeLeft;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ResearchTable instance)
	{
		if (instance.ShouldPool)
		{
			instance.researchTimeLeft = 0f;
			Pool.Free<ResearchTable>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ResearchTable with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ResearchTable instance)
	{
		instance.researchTimeLeft = researchTimeLeft;
	}

	public ResearchTable Copy()
	{
		ResearchTable researchTable = Pool.Get<ResearchTable>();
		CopyTo(researchTable);
		return researchTable;
	}

	public static ResearchTable Deserialize(BufferStream stream)
	{
		ResearchTable researchTable = Pool.Get<ResearchTable>();
		Deserialize(stream, researchTable, isDelta: false);
		return researchTable;
	}

	public static ResearchTable DeserializeLengthDelimited(BufferStream stream)
	{
		ResearchTable researchTable = Pool.Get<ResearchTable>();
		DeserializeLengthDelimited(stream, researchTable, isDelta: false);
		return researchTable;
	}

	public static ResearchTable DeserializeLength(BufferStream stream, int length)
	{
		ResearchTable researchTable = Pool.Get<ResearchTable>();
		DeserializeLength(stream, length, researchTable, isDelta: false);
		return researchTable;
	}

	public static ResearchTable Deserialize(byte[] buffer)
	{
		ResearchTable researchTable = Pool.Get<ResearchTable>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, researchTable, isDelta: false);
		return researchTable;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ResearchTable previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ResearchTable Deserialize(BufferStream stream, ResearchTable instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.researchTimeLeft = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ResearchTable DeserializeLengthDelimited(BufferStream stream, ResearchTable instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.researchTimeLeft = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ResearchTable DeserializeLength(BufferStream stream, int length, ResearchTable instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.researchTimeLeft = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ResearchTable instance, ResearchTable previous)
	{
		if (instance.researchTimeLeft != previous.researchTimeLeft)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.researchTimeLeft);
		}
	}

	public static void Serialize(BufferStream stream, ResearchTable instance)
	{
		if (instance.researchTimeLeft != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.researchTimeLeft);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ResourceExtractor : IDisposable, IPooled, IProto<ResourceExtractor>, IProto
{
	[NonSerialized]
	public ItemContainer fuelContents;

	[NonSerialized]
	public ItemContainer outputContents;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ResourceExtractor instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.fuelContents != null)
			{
				instance.fuelContents.ResetToPool();
				instance.fuelContents = null;
			}
			if (instance.outputContents != null)
			{
				instance.outputContents.ResetToPool();
				instance.outputContents = null;
			}
			Pool.Free<ResourceExtractor>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ResourceExtractor with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ResourceExtractor instance)
	{
		if (fuelContents != null)
		{
			if (instance.fuelContents == null)
			{
				instance.fuelContents = fuelContents.Copy();
			}
			else
			{
				fuelContents.CopyTo(instance.fuelContents);
			}
		}
		else
		{
			instance.fuelContents = null;
		}
		if (outputContents != null)
		{
			if (instance.outputContents == null)
			{
				instance.outputContents = outputContents.Copy();
			}
			else
			{
				outputContents.CopyTo(instance.outputContents);
			}
		}
		else
		{
			instance.outputContents = null;
		}
	}

	public ResourceExtractor Copy()
	{
		ResourceExtractor resourceExtractor = Pool.Get<ResourceExtractor>();
		CopyTo(resourceExtractor);
		return resourceExtractor;
	}

	public static ResourceExtractor Deserialize(BufferStream stream)
	{
		ResourceExtractor resourceExtractor = Pool.Get<ResourceExtractor>();
		Deserialize(stream, resourceExtractor, isDelta: false);
		return resourceExtractor;
	}

	public static ResourceExtractor DeserializeLengthDelimited(BufferStream stream)
	{
		ResourceExtractor resourceExtractor = Pool.Get<ResourceExtractor>();
		DeserializeLengthDelimited(stream, resourceExtractor, isDelta: false);
		return resourceExtractor;
	}

	public static ResourceExtractor DeserializeLength(BufferStream stream, int length)
	{
		ResourceExtractor resourceExtractor = Pool.Get<ResourceExtractor>();
		DeserializeLength(stream, length, resourceExtractor, isDelta: false);
		return resourceExtractor;
	}

	public static ResourceExtractor Deserialize(byte[] buffer)
	{
		ResourceExtractor resourceExtractor = Pool.Get<ResourceExtractor>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, resourceExtractor, isDelta: false);
		return resourceExtractor;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ResourceExtractor previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ResourceExtractor Deserialize(BufferStream stream, ResourceExtractor instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.fuelContents == null)
				{
					instance.fuelContents = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.fuelContents, isDelta);
				}
				break;
			case 18:
				if (instance.outputContents == null)
				{
					instance.outputContents = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.outputContents, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static ResourceExtractor DeserializeLengthDelimited(BufferStream stream, ResourceExtractor instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.fuelContents == null)
				{
					instance.fuelContents = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.fuelContents, isDelta);
				}
				break;
			case 18:
				if (instance.outputContents == null)
				{
					instance.outputContents = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.outputContents, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ResourceExtractor DeserializeLength(BufferStream stream, int length, ResourceExtractor instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.fuelContents == null)
				{
					instance.fuelContents = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.fuelContents, isDelta);
				}
				break;
			case 18:
				if (instance.outputContents == null)
				{
					instance.outputContents = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.outputContents, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ResourceExtractor instance, ResourceExtractor previous)
	{
		if (instance.fuelContents != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.SerializeDelta(stream, instance.fuelContents, previous.fuelContents);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.outputContents == null)
		{
			return;
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		ItemContainer.SerializeDelta(stream, instance.outputContents, previous.outputContents);
		int val2 = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, ResourceExtractor instance)
	{
		if (instance.fuelContents != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.Serialize(stream, instance.fuelContents);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.outputContents == null)
		{
			return;
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		ItemContainer.Serialize(stream, instance.outputContents);
		int val2 = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		fuelContents?.InspectUids(action);
		outputContents?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class RespawnInformation : IDisposable, IPooled, IProto<RespawnInformation>, IProto
{
	public class SpawnOptions : IDisposable, IPooled, IProto<SpawnOptions>, IProto
	{
		public enum RespawnType
		{
			SleepingBag = 1,
			Bed,
			BeachTowel,
			Camper,
			Static
		}

		public enum RespawnState
		{
			OK = 1,
			Occupied,
			Underwater,
			InNoRespawnZone
		}

		[NonSerialized]
		public RespawnType type;

		[NonSerialized]
		public NetworkableId id;

		[NonSerialized]
		public string name;

		[NonSerialized]
		public float unlockSeconds;

		[NonSerialized]
		public Vector3 worldPosition;

		[NonSerialized]
		public RespawnState respawnState;

		[NonSerialized]
		public bool mobile;

		[NonSerialized]
		public string nexusZone;

		[NonSerialized]
		public bool corpse;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(SpawnOptions instance)
		{
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.type = (RespawnType)0;
				instance.id = default(NetworkableId);
				instance.name = string.Empty;
				instance.unlockSeconds = 0f;
				instance.worldPosition = default(Vector3);
				instance.respawnState = (RespawnState)0;
				instance.mobile = false;
				instance.nexusZone = string.Empty;
				instance.corpse = false;
				Pool.Free<SpawnOptions>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose SpawnOptions with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(SpawnOptions instance)
		{
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			instance.type = type;
			instance.id = id;
			instance.name = name;
			instance.unlockSeconds = unlockSeconds;
			instance.worldPosition = worldPosition;
			instance.respawnState = respawnState;
			instance.mobile = mobile;
			instance.nexusZone = nexusZone;
			instance.corpse = corpse;
		}

		public SpawnOptions Copy()
		{
			SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
			CopyTo(spawnOptions);
			return spawnOptions;
		}

		public static SpawnOptions Deserialize(BufferStream stream)
		{
			SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
			Deserialize(stream, spawnOptions, isDelta: false);
			return spawnOptions;
		}

		public static SpawnOptions DeserializeLengthDelimited(BufferStream stream)
		{
			SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
			DeserializeLengthDelimited(stream, spawnOptions, isDelta: false);
			return spawnOptions;
		}

		public static SpawnOptions DeserializeLength(BufferStream stream, int length)
		{
			SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
			DeserializeLength(stream, length, spawnOptions, isDelta: false);
			return spawnOptions;
		}

		public static SpawnOptions Deserialize(byte[] buffer)
		{
			SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, spawnOptions, isDelta: false);
			return spawnOptions;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, SpawnOptions previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static SpawnOptions Deserialize(BufferStream stream, SpawnOptions instance, bool isDelta)
		{
			//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
			if (!isDelta)
			{
				instance.respawnState = RespawnState.OK;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.type = (RespawnType)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 26:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 37:
					instance.unlockSeconds = ProtocolParser.ReadSingle(stream);
					continue;
				case 42:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
					continue;
				case 48:
					instance.respawnState = (RespawnState)ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.mobile = ProtocolParser.ReadBool(stream);
					continue;
				case 66:
					instance.nexusZone = ProtocolParser.ReadString(stream);
					continue;
				case 72:
					instance.corpse = ProtocolParser.ReadBool(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static SpawnOptions DeserializeLengthDelimited(BufferStream stream, SpawnOptions instance, bool isDelta)
		{
			//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
			if (!isDelta)
			{
				instance.respawnState = RespawnState.OK;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.type = (RespawnType)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 26:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 37:
					instance.unlockSeconds = ProtocolParser.ReadSingle(stream);
					continue;
				case 42:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
					continue;
				case 48:
					instance.respawnState = (RespawnState)ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.mobile = ProtocolParser.ReadBool(stream);
					continue;
				case 66:
					instance.nexusZone = ProtocolParser.ReadString(stream);
					continue;
				case 72:
					instance.corpse = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static SpawnOptions DeserializeLength(BufferStream stream, int length, SpawnOptions instance, bool isDelta)
		{
			//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
			if (!isDelta)
			{
				instance.respawnState = RespawnState.OK;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.type = (RespawnType)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 26:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 37:
					instance.unlockSeconds = ProtocolParser.ReadSingle(stream);
					continue;
				case 42:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
					continue;
				case 48:
					instance.respawnState = (RespawnState)ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.mobile = ProtocolParser.ReadBool(stream);
					continue;
				case 66:
					instance.nexusZone = ProtocolParser.ReadString(stream);
					continue;
				case 72:
					instance.corpse = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, SpawnOptions instance, SpawnOptions previous)
		{
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.id.Value);
			if (instance.name != previous.name)
			{
				if (instance.name == null)
				{
					throw new ArgumentNullException("name", "Required by proto specification.");
				}
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, instance.name);
			}
			if (instance.unlockSeconds != previous.unlockSeconds)
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, instance.unlockSeconds);
			}
			if (instance.worldPosition != previous.worldPosition)
			{
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.worldPosition, previous.worldPosition);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldPosition (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.respawnState);
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.mobile);
			if (instance.nexusZone != null && instance.nexusZone != previous.nexusZone)
			{
				stream.WriteByte(66);
				ProtocolParser.WriteString(stream, instance.nexusZone);
			}
			stream.WriteByte(72);
			ProtocolParser.WriteBool(stream, instance.corpse);
		}

		public static void Serialize(BufferStream stream, SpawnOptions instance)
		{
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			if (instance.id != default(NetworkableId))
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.id.Value);
			}
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.name);
			if (instance.unlockSeconds != 0f)
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, instance.unlockSeconds);
			}
			if (instance.worldPosition != default(Vector3))
			{
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.Serialize(stream, instance.worldPosition);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldPosition (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.respawnState);
			if (instance.mobile)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteBool(stream, instance.mobile);
			}
			if (instance.nexusZone != null)
			{
				stream.WriteByte(66);
				ProtocolParser.WriteString(stream, instance.nexusZone);
			}
			if (instance.corpse)
			{
				stream.WriteByte(72);
				ProtocolParser.WriteBool(stream, instance.corpse);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			action(UidType.NetworkableId, ref id.Value);
		}
	}

	[NonSerialized]
	public List<SpawnOptions> spawnOptions;

	[NonSerialized]
	public PlayerLifeStory previousLife;

	[NonSerialized]
	public bool fadeIn;

	[NonSerialized]
	public bool loading;

	[NonSerialized]
	public List<Vector3> shelterPositions;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(RespawnInformation instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.spawnOptions != null)
		{
			for (int i = 0; i < instance.spawnOptions.Count; i++)
			{
				if (instance.spawnOptions[i] != null)
				{
					instance.spawnOptions[i].ResetToPool();
					instance.spawnOptions[i] = null;
				}
			}
			List<SpawnOptions> list = instance.spawnOptions;
			Pool.Free<SpawnOptions>(ref list, false);
			instance.spawnOptions = list;
		}
		if (instance.previousLife != null)
		{
			instance.previousLife.ResetToPool();
			instance.previousLife = null;
		}
		instance.fadeIn = false;
		instance.loading = false;
		if (instance.shelterPositions != null)
		{
			List<Vector3> list2 = instance.shelterPositions;
			Pool.FreeUnmanaged<Vector3>(ref list2);
			instance.shelterPositions = list2;
		}
		Pool.Free<RespawnInformation>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose RespawnInformation with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(RespawnInformation instance)
	{
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		if (spawnOptions != null)
		{
			instance.spawnOptions = Pool.Get<List<SpawnOptions>>();
			for (int i = 0; i < spawnOptions.Count; i++)
			{
				SpawnOptions item = spawnOptions[i].Copy();
				instance.spawnOptions.Add(item);
			}
		}
		else
		{
			instance.spawnOptions = null;
		}
		if (previousLife != null)
		{
			if (instance.previousLife == null)
			{
				instance.previousLife = previousLife.Copy();
			}
			else
			{
				previousLife.CopyTo(instance.previousLife);
			}
		}
		else
		{
			instance.previousLife = null;
		}
		instance.fadeIn = fadeIn;
		instance.loading = loading;
		if (shelterPositions != null)
		{
			instance.shelterPositions = Pool.Get<List<Vector3>>();
			for (int j = 0; j < shelterPositions.Count; j++)
			{
				Vector3 item2 = shelterPositions[j];
				instance.shelterPositions.Add(item2);
			}
		}
		else
		{
			instance.shelterPositions = null;
		}
	}

	public RespawnInformation Copy()
	{
		RespawnInformation respawnInformation = Pool.Get<RespawnInformation>();
		CopyTo(respawnInformation);
		return respawnInformation;
	}

	public static RespawnInformation Deserialize(BufferStream stream)
	{
		RespawnInformation respawnInformation = Pool.Get<RespawnInformation>();
		Deserialize(stream, respawnInformation, isDelta: false);
		return respawnInformation;
	}

	public static RespawnInformation DeserializeLengthDelimited(BufferStream stream)
	{
		RespawnInformation respawnInformation = Pool.Get<RespawnInformation>();
		DeserializeLengthDelimited(stream, respawnInformation, isDelta: false);
		return respawnInformation;
	}

	public static RespawnInformation DeserializeLength(BufferStream stream, int length)
	{
		RespawnInformation respawnInformation = Pool.Get<RespawnInformation>();
		DeserializeLength(stream, length, respawnInformation, isDelta: false);
		return respawnInformation;
	}

	public static RespawnInformation Deserialize(byte[] buffer)
	{
		RespawnInformation respawnInformation = Pool.Get<RespawnInformation>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, respawnInformation, isDelta: false);
		return respawnInformation;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, RespawnInformation previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static RespawnInformation Deserialize(BufferStream stream, RespawnInformation instance, bool isDelta)
	{
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.spawnOptions == null)
			{
				instance.spawnOptions = Pool.Get<List<SpawnOptions>>();
			}
			if (instance.shelterPositions == null)
			{
				instance.shelterPositions = Pool.Get<List<Vector3>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.spawnOptions.Add(SpawnOptions.DeserializeLengthDelimited(stream));
				break;
			case 18:
				if (instance.previousLife == null)
				{
					instance.previousLife = PlayerLifeStory.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerLifeStory.DeserializeLengthDelimited(stream, instance.previousLife, isDelta);
				}
				break;
			case 24:
				instance.fadeIn = ProtocolParser.ReadBool(stream);
				break;
			case 32:
				instance.loading = ProtocolParser.ReadBool(stream);
				break;
			case 42:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.shelterPositions.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static RespawnInformation DeserializeLengthDelimited(BufferStream stream, RespawnInformation instance, bool isDelta)
	{
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.spawnOptions == null)
			{
				instance.spawnOptions = Pool.Get<List<SpawnOptions>>();
			}
			if (instance.shelterPositions == null)
			{
				instance.shelterPositions = Pool.Get<List<Vector3>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.spawnOptions.Add(SpawnOptions.DeserializeLengthDelimited(stream));
				break;
			case 18:
				if (instance.previousLife == null)
				{
					instance.previousLife = PlayerLifeStory.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerLifeStory.DeserializeLengthDelimited(stream, instance.previousLife, isDelta);
				}
				break;
			case 24:
				instance.fadeIn = ProtocolParser.ReadBool(stream);
				break;
			case 32:
				instance.loading = ProtocolParser.ReadBool(stream);
				break;
			case 42:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.shelterPositions.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static RespawnInformation DeserializeLength(BufferStream stream, int length, RespawnInformation instance, bool isDelta)
	{
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.spawnOptions == null)
			{
				instance.spawnOptions = Pool.Get<List<SpawnOptions>>();
			}
			if (instance.shelterPositions == null)
			{
				instance.shelterPositions = Pool.Get<List<Vector3>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.spawnOptions.Add(SpawnOptions.DeserializeLengthDelimited(stream));
				break;
			case 18:
				if (instance.previousLife == null)
				{
					instance.previousLife = PlayerLifeStory.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerLifeStory.DeserializeLengthDelimited(stream, instance.previousLife, isDelta);
				}
				break;
			case 24:
				instance.fadeIn = ProtocolParser.ReadBool(stream);
				break;
			case 32:
				instance.loading = ProtocolParser.ReadBool(stream);
				break;
			case 42:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.shelterPositions.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, RespawnInformation instance, RespawnInformation previous)
	{
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		if (instance.spawnOptions != null)
		{
			for (int i = 0; i < instance.spawnOptions.Count; i++)
			{
				SpawnOptions spawnOptions = instance.spawnOptions[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				SpawnOptions.SerializeDelta(stream, spawnOptions, spawnOptions);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.previousLife != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			PlayerLifeStory.SerializeDelta(stream, instance.previousLife, previous.previousLife);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.fadeIn);
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.loading);
		if (instance.shelterPositions == null)
		{
			return;
		}
		for (int j = 0; j < instance.shelterPositions.Count; j++)
		{
			Vector3 val3 = instance.shelterPositions[j];
			stream.WriteByte(42);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, val3, val3);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field shelterPositions (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
	}

	public static void Serialize(BufferStream stream, RespawnInformation instance)
	{
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		if (instance.spawnOptions != null)
		{
			for (int i = 0; i < instance.spawnOptions.Count; i++)
			{
				SpawnOptions instance2 = instance.spawnOptions[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				SpawnOptions.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.previousLife != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			PlayerLifeStory.Serialize(stream, instance.previousLife);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
		if (instance.fadeIn)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.fadeIn);
		}
		if (instance.loading)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.loading);
		}
		if (instance.shelterPositions == null)
		{
			return;
		}
		for (int j = 0; j < instance.shelterPositions.Count; j++)
		{
			Vector3 instance3 = instance.shelterPositions[j];
			stream.WriteByte(42);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance3);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field shelterPositions (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (spawnOptions != null)
		{
			for (int i = 0; i < spawnOptions.Count; i++)
			{
				spawnOptions[i]?.InspectUids(action);
			}
		}
		previousLife?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class RockingChair : IDisposable, IPooled, IProto<RockingChair>, IProto
{
	[NonSerialized]
	public Vector3 initEuler;

	[NonSerialized]
	public float initY;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(RockingChair instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.initEuler = default(Vector3);
			instance.initY = 0f;
			Pool.Free<RockingChair>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose RockingChair with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(RockingChair instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		instance.initEuler = initEuler;
		instance.initY = initY;
	}

	public RockingChair Copy()
	{
		RockingChair rockingChair = Pool.Get<RockingChair>();
		CopyTo(rockingChair);
		return rockingChair;
	}

	public static RockingChair Deserialize(BufferStream stream)
	{
		RockingChair rockingChair = Pool.Get<RockingChair>();
		Deserialize(stream, rockingChair, isDelta: false);
		return rockingChair;
	}

	public static RockingChair DeserializeLengthDelimited(BufferStream stream)
	{
		RockingChair rockingChair = Pool.Get<RockingChair>();
		DeserializeLengthDelimited(stream, rockingChair, isDelta: false);
		return rockingChair;
	}

	public static RockingChair DeserializeLength(BufferStream stream, int length)
	{
		RockingChair rockingChair = Pool.Get<RockingChair>();
		DeserializeLength(stream, length, rockingChair, isDelta: false);
		return rockingChair;
	}

	public static RockingChair Deserialize(byte[] buffer)
	{
		RockingChair rockingChair = Pool.Get<RockingChair>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, rockingChair, isDelta: false);
		return rockingChair;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, RockingChair previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static RockingChair Deserialize(BufferStream stream, RockingChair instance, bool isDelta)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.initEuler, isDelta);
				continue;
			case 21:
				instance.initY = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static RockingChair DeserializeLengthDelimited(BufferStream stream, RockingChair instance, bool isDelta)
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.initEuler, isDelta);
				continue;
			case 21:
				instance.initY = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static RockingChair DeserializeLength(BufferStream stream, int length, RockingChair instance, bool isDelta)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.initEuler, isDelta);
				continue;
			case 21:
				instance.initY = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, RockingChair instance, RockingChair previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.initEuler != previous.initEuler)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.initEuler, previous.initEuler);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field initEuler (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.initY != previous.initY)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.initY);
		}
	}

	public static void Serialize(BufferStream stream, RockingChair instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.initEuler != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.initEuler);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field initEuler (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.initY != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.initY);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SalesData : IDisposable, IPooled, IProto<SalesData>, IProto
{
	[NonSerialized]
	public ulong totalSales;

	[NonSerialized]
	public ulong totalIntervals;

	[NonSerialized]
	public ulong soldThisInterval;

	[NonSerialized]
	public float currentMultiplier;

	[NonSerialized]
	public bool isForReceivedQuantity;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SalesData instance)
	{
		if (instance.ShouldPool)
		{
			instance.totalSales = 0uL;
			instance.totalIntervals = 0uL;
			instance.soldThisInterval = 0uL;
			instance.currentMultiplier = 0f;
			instance.isForReceivedQuantity = false;
			Pool.Free<SalesData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SalesData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SalesData instance)
	{
		instance.totalSales = totalSales;
		instance.totalIntervals = totalIntervals;
		instance.soldThisInterval = soldThisInterval;
		instance.currentMultiplier = currentMultiplier;
		instance.isForReceivedQuantity = isForReceivedQuantity;
	}

	public SalesData Copy()
	{
		SalesData salesData = Pool.Get<SalesData>();
		CopyTo(salesData);
		return salesData;
	}

	public static SalesData Deserialize(BufferStream stream)
	{
		SalesData salesData = Pool.Get<SalesData>();
		Deserialize(stream, salesData, isDelta: false);
		return salesData;
	}

	public static SalesData DeserializeLengthDelimited(BufferStream stream)
	{
		SalesData salesData = Pool.Get<SalesData>();
		DeserializeLengthDelimited(stream, salesData, isDelta: false);
		return salesData;
	}

	public static SalesData DeserializeLength(BufferStream stream, int length)
	{
		SalesData salesData = Pool.Get<SalesData>();
		DeserializeLength(stream, length, salesData, isDelta: false);
		return salesData;
	}

	public static SalesData Deserialize(byte[] buffer)
	{
		SalesData salesData = Pool.Get<SalesData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, salesData, isDelta: false);
		return salesData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SalesData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SalesData Deserialize(BufferStream stream, SalesData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 24:
				instance.totalSales = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.totalIntervals = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.soldThisInterval = ProtocolParser.ReadUInt64(stream);
				continue;
			case 61:
				instance.currentMultiplier = ProtocolParser.ReadSingle(stream);
				continue;
			case 64:
				instance.isForReceivedQuantity = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SalesData DeserializeLengthDelimited(BufferStream stream, SalesData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 24:
				instance.totalSales = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.totalIntervals = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.soldThisInterval = ProtocolParser.ReadUInt64(stream);
				continue;
			case 61:
				instance.currentMultiplier = ProtocolParser.ReadSingle(stream);
				continue;
			case 64:
				instance.isForReceivedQuantity = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SalesData DeserializeLength(BufferStream stream, int length, SalesData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 24:
				instance.totalSales = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.totalIntervals = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.soldThisInterval = ProtocolParser.ReadUInt64(stream);
				continue;
			case 61:
				instance.currentMultiplier = ProtocolParser.ReadSingle(stream);
				continue;
			case 64:
				instance.isForReceivedQuantity = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SalesData instance, SalesData previous)
	{
		if (instance.totalSales != previous.totalSales)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.totalSales);
		}
		if (instance.totalIntervals != previous.totalIntervals)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.totalIntervals);
		}
		if (instance.soldThisInterval != previous.soldThisInterval)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.soldThisInterval);
		}
		if (instance.currentMultiplier != previous.currentMultiplier)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.currentMultiplier);
		}
		stream.WriteByte(64);
		ProtocolParser.WriteBool(stream, instance.isForReceivedQuantity);
	}

	public static void Serialize(BufferStream stream, SalesData instance)
	{
		if (instance.totalSales != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.totalSales);
		}
		if (instance.totalIntervals != 0L)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.totalIntervals);
		}
		if (instance.soldThisInterval != 0L)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.soldThisInterval);
		}
		if (instance.currentMultiplier != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.currentMultiplier);
		}
		if (instance.isForReceivedQuantity)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteBool(stream, instance.isForReceivedQuantity);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class SAMSite : IDisposable, IPooled, IProto<SAMSite>, IProto
{
	[NonSerialized]
	public Vector3 aimDir;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SAMSite instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.aimDir = default(Vector3);
			Pool.Free<SAMSite>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SAMSite with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SAMSite instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		instance.aimDir = aimDir;
	}

	public SAMSite Copy()
	{
		SAMSite sAMSite = Pool.Get<SAMSite>();
		CopyTo(sAMSite);
		return sAMSite;
	}

	public static SAMSite Deserialize(BufferStream stream)
	{
		SAMSite sAMSite = Pool.Get<SAMSite>();
		Deserialize(stream, sAMSite, isDelta: false);
		return sAMSite;
	}

	public static SAMSite DeserializeLengthDelimited(BufferStream stream)
	{
		SAMSite sAMSite = Pool.Get<SAMSite>();
		DeserializeLengthDelimited(stream, sAMSite, isDelta: false);
		return sAMSite;
	}

	public static SAMSite DeserializeLength(BufferStream stream, int length)
	{
		SAMSite sAMSite = Pool.Get<SAMSite>();
		DeserializeLength(stream, length, sAMSite, isDelta: false);
		return sAMSite;
	}

	public static SAMSite Deserialize(byte[] buffer)
	{
		SAMSite sAMSite = Pool.Get<SAMSite>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, sAMSite, isDelta: false);
		return sAMSite;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SAMSite previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SAMSite Deserialize(BufferStream stream, SAMSite instance, bool isDelta)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimDir, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SAMSite DeserializeLengthDelimited(BufferStream stream, SAMSite instance, bool isDelta)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimDir, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SAMSite DeserializeLength(BufferStream stream, int length, SAMSite instance, bool isDelta)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.aimDir, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SAMSite instance, SAMSite previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.aimDir != previous.aimDir)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.aimDir, previous.aimDir);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aimDir (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, SAMSite instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.aimDir != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.aimDir);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aimDir (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ScientistBoatOilrigManager : IDisposable, IPooled, IProto<ScientistBoatOilrigManager>, IProto
{
	[NonSerialized]
	public List<NetworkableId> boatIds;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ScientistBoatOilrigManager instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.boatIds != null)
			{
				List<NetworkableId> list = instance.boatIds;
				Pool.FreeUnmanaged<NetworkableId>(ref list);
				instance.boatIds = list;
			}
			Pool.Free<ScientistBoatOilrigManager>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ScientistBoatOilrigManager with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ScientistBoatOilrigManager instance)
	{
		if (boatIds != null)
		{
			instance.boatIds = Pool.Get<List<NetworkableId>>();
			for (int i = 0; i < boatIds.Count; i++)
			{
				NetworkableId item = boatIds[i];
				instance.boatIds.Add(item);
			}
		}
		else
		{
			instance.boatIds = null;
		}
	}

	public ScientistBoatOilrigManager Copy()
	{
		ScientistBoatOilrigManager scientistBoatOilrigManager = Pool.Get<ScientistBoatOilrigManager>();
		CopyTo(scientistBoatOilrigManager);
		return scientistBoatOilrigManager;
	}

	public static ScientistBoatOilrigManager Deserialize(BufferStream stream)
	{
		ScientistBoatOilrigManager scientistBoatOilrigManager = Pool.Get<ScientistBoatOilrigManager>();
		Deserialize(stream, scientistBoatOilrigManager, isDelta: false);
		return scientistBoatOilrigManager;
	}

	public static ScientistBoatOilrigManager DeserializeLengthDelimited(BufferStream stream)
	{
		ScientistBoatOilrigManager scientistBoatOilrigManager = Pool.Get<ScientistBoatOilrigManager>();
		DeserializeLengthDelimited(stream, scientistBoatOilrigManager, isDelta: false);
		return scientistBoatOilrigManager;
	}

	public static ScientistBoatOilrigManager DeserializeLength(BufferStream stream, int length)
	{
		ScientistBoatOilrigManager scientistBoatOilrigManager = Pool.Get<ScientistBoatOilrigManager>();
		DeserializeLength(stream, length, scientistBoatOilrigManager, isDelta: false);
		return scientistBoatOilrigManager;
	}

	public static ScientistBoatOilrigManager Deserialize(byte[] buffer)
	{
		ScientistBoatOilrigManager scientistBoatOilrigManager = Pool.Get<ScientistBoatOilrigManager>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, scientistBoatOilrigManager, isDelta: false);
		return scientistBoatOilrigManager;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ScientistBoatOilrigManager previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ScientistBoatOilrigManager Deserialize(BufferStream stream, ScientistBoatOilrigManager instance, bool isDelta)
	{
		if (!isDelta && instance.boatIds == null)
		{
			instance.boatIds = Pool.Get<List<NetworkableId>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.boatIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ScientistBoatOilrigManager DeserializeLengthDelimited(BufferStream stream, ScientistBoatOilrigManager instance, bool isDelta)
	{
		if (!isDelta && instance.boatIds == null)
		{
			instance.boatIds = Pool.Get<List<NetworkableId>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.boatIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ScientistBoatOilrigManager DeserializeLength(BufferStream stream, int length, ScientistBoatOilrigManager instance, bool isDelta)
	{
		if (!isDelta && instance.boatIds == null)
		{
			instance.boatIds = Pool.Get<List<NetworkableId>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.boatIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ScientistBoatOilrigManager instance, ScientistBoatOilrigManager previous)
	{
		if (instance.boatIds != null)
		{
			for (int i = 0; i < instance.boatIds.Count; i++)
			{
				NetworkableId networkableId = instance.boatIds[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
	}

	public static void Serialize(BufferStream stream, ScientistBoatOilrigManager instance)
	{
		if (instance.boatIds != null)
		{
			for (int i = 0; i < instance.boatIds.Count; i++)
			{
				NetworkableId networkableId = instance.boatIds[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		for (int i = 0; i < boatIds.Count; i++)
		{
			NetworkableId value = boatIds[i];
			action(UidType.NetworkableId, ref value.Value);
			boatIds[i] = value;
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ServerGib : IDisposable, IPooled, IProto<ServerGib>, IProto
{
	[NonSerialized]
	public string gibName;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ServerGib instance)
	{
		if (instance.ShouldPool)
		{
			instance.gibName = string.Empty;
			Pool.Free<ServerGib>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ServerGib with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ServerGib instance)
	{
		instance.gibName = gibName;
	}

	public ServerGib Copy()
	{
		ServerGib serverGib = Pool.Get<ServerGib>();
		CopyTo(serverGib);
		return serverGib;
	}

	public static ServerGib Deserialize(BufferStream stream)
	{
		ServerGib serverGib = Pool.Get<ServerGib>();
		Deserialize(stream, serverGib, isDelta: false);
		return serverGib;
	}

	public static ServerGib DeserializeLengthDelimited(BufferStream stream)
	{
		ServerGib serverGib = Pool.Get<ServerGib>();
		DeserializeLengthDelimited(stream, serverGib, isDelta: false);
		return serverGib;
	}

	public static ServerGib DeserializeLength(BufferStream stream, int length)
	{
		ServerGib serverGib = Pool.Get<ServerGib>();
		DeserializeLength(stream, length, serverGib, isDelta: false);
		return serverGib;
	}

	public static ServerGib Deserialize(byte[] buffer)
	{
		ServerGib serverGib = Pool.Get<ServerGib>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, serverGib, isDelta: false);
		return serverGib;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ServerGib previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ServerGib Deserialize(BufferStream stream, ServerGib instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.gibName = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ServerGib DeserializeLengthDelimited(BufferStream stream, ServerGib instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.gibName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ServerGib DeserializeLength(BufferStream stream, int length, ServerGib instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.gibName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ServerGib instance, ServerGib previous)
	{
		if (instance.gibName != null && instance.gibName != previous.gibName)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.gibName);
		}
	}

	public static void Serialize(BufferStream stream, ServerGib instance)
	{
		if (instance.gibName != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.gibName);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ServersideMountedWeaponSnapshot : IDisposable, IPooled, IProto<ServersideMountedWeaponSnapshot>, IProto
{
	[NonSerialized]
	public float time;

	[NonSerialized]
	public float pitch;

	[NonSerialized]
	public float yaw;

	[NonSerialized]
	public bool force;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ServersideMountedWeaponSnapshot instance)
	{
		if (instance.ShouldPool)
		{
			instance.time = 0f;
			instance.pitch = 0f;
			instance.yaw = 0f;
			instance.force = false;
			Pool.Free<ServersideMountedWeaponSnapshot>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ServersideMountedWeaponSnapshot with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ServersideMountedWeaponSnapshot instance)
	{
		instance.time = time;
		instance.pitch = pitch;
		instance.yaw = yaw;
		instance.force = force;
	}

	public ServersideMountedWeaponSnapshot Copy()
	{
		ServersideMountedWeaponSnapshot serversideMountedWeaponSnapshot = Pool.Get<ServersideMountedWeaponSnapshot>();
		CopyTo(serversideMountedWeaponSnapshot);
		return serversideMountedWeaponSnapshot;
	}

	public static ServersideMountedWeaponSnapshot Deserialize(BufferStream stream)
	{
		ServersideMountedWeaponSnapshot serversideMountedWeaponSnapshot = Pool.Get<ServersideMountedWeaponSnapshot>();
		Deserialize(stream, serversideMountedWeaponSnapshot, isDelta: false);
		return serversideMountedWeaponSnapshot;
	}

	public static ServersideMountedWeaponSnapshot DeserializeLengthDelimited(BufferStream stream)
	{
		ServersideMountedWeaponSnapshot serversideMountedWeaponSnapshot = Pool.Get<ServersideMountedWeaponSnapshot>();
		DeserializeLengthDelimited(stream, serversideMountedWeaponSnapshot, isDelta: false);
		return serversideMountedWeaponSnapshot;
	}

	public static ServersideMountedWeaponSnapshot DeserializeLength(BufferStream stream, int length)
	{
		ServersideMountedWeaponSnapshot serversideMountedWeaponSnapshot = Pool.Get<ServersideMountedWeaponSnapshot>();
		DeserializeLength(stream, length, serversideMountedWeaponSnapshot, isDelta: false);
		return serversideMountedWeaponSnapshot;
	}

	public static ServersideMountedWeaponSnapshot Deserialize(byte[] buffer)
	{
		ServersideMountedWeaponSnapshot serversideMountedWeaponSnapshot = Pool.Get<ServersideMountedWeaponSnapshot>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, serversideMountedWeaponSnapshot, isDelta: false);
		return serversideMountedWeaponSnapshot;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ServersideMountedWeaponSnapshot previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ServersideMountedWeaponSnapshot Deserialize(BufferStream stream, ServersideMountedWeaponSnapshot instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.pitch = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.yaw = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.force = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ServersideMountedWeaponSnapshot DeserializeLengthDelimited(BufferStream stream, ServersideMountedWeaponSnapshot instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.pitch = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.yaw = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.force = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ServersideMountedWeaponSnapshot DeserializeLength(BufferStream stream, int length, ServersideMountedWeaponSnapshot instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.time = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.pitch = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.yaw = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.force = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ServersideMountedWeaponSnapshot instance, ServersideMountedWeaponSnapshot previous)
	{
		if (instance.time != previous.time)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		if (instance.pitch != previous.pitch)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.pitch);
		}
		if (instance.yaw != previous.yaw)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.yaw);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.force);
	}

	public static void Serialize(BufferStream stream, ServersideMountedWeaponSnapshot instance)
	{
		if (instance.time != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.time);
		}
		if (instance.pitch != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.pitch);
		}
		if (instance.yaw != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.yaw);
		}
		if (instance.force)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.force);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ShopKeeper : IDisposable, IPooled, IProto<ShopKeeper>, IProto
{
	[NonSerialized]
	public NetworkableId vendingRef;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ShopKeeper instance)
	{
		if (instance.ShouldPool)
		{
			instance.vendingRef = default(NetworkableId);
			Pool.Free<ShopKeeper>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ShopKeeper with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ShopKeeper instance)
	{
		instance.vendingRef = vendingRef;
	}

	public ShopKeeper Copy()
	{
		ShopKeeper shopKeeper = Pool.Get<ShopKeeper>();
		CopyTo(shopKeeper);
		return shopKeeper;
	}

	public static ShopKeeper Deserialize(BufferStream stream)
	{
		ShopKeeper shopKeeper = Pool.Get<ShopKeeper>();
		Deserialize(stream, shopKeeper, isDelta: false);
		return shopKeeper;
	}

	public static ShopKeeper DeserializeLengthDelimited(BufferStream stream)
	{
		ShopKeeper shopKeeper = Pool.Get<ShopKeeper>();
		DeserializeLengthDelimited(stream, shopKeeper, isDelta: false);
		return shopKeeper;
	}

	public static ShopKeeper DeserializeLength(BufferStream stream, int length)
	{
		ShopKeeper shopKeeper = Pool.Get<ShopKeeper>();
		DeserializeLength(stream, length, shopKeeper, isDelta: false);
		return shopKeeper;
	}

	public static ShopKeeper Deserialize(byte[] buffer)
	{
		ShopKeeper shopKeeper = Pool.Get<ShopKeeper>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, shopKeeper, isDelta: false);
		return shopKeeper;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ShopKeeper previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ShopKeeper Deserialize(BufferStream stream, ShopKeeper instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.vendingRef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ShopKeeper DeserializeLengthDelimited(BufferStream stream, ShopKeeper instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.vendingRef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ShopKeeper DeserializeLength(BufferStream stream, int length, ShopKeeper instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.vendingRef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ShopKeeper instance, ShopKeeper previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.vendingRef.Value);
	}

	public static void Serialize(BufferStream stream, ShopKeeper instance)
	{
		if (instance.vendingRef != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.vendingRef.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref vendingRef.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SiegeTower : IDisposable, IPooled, IProto<SiegeTower>, IProto
{
	[NonSerialized]
	public NetworkableId doorID;

	[NonSerialized]
	public NetworkableId drawBridgeID;

	[NonSerialized]
	public NetworkableId drawBridge2ID;

	[NonSerialized]
	public NetworkableId drawBridge3ID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SiegeTower instance)
	{
		if (instance.ShouldPool)
		{
			instance.doorID = default(NetworkableId);
			instance.drawBridgeID = default(NetworkableId);
			instance.drawBridge2ID = default(NetworkableId);
			instance.drawBridge3ID = default(NetworkableId);
			Pool.Free<SiegeTower>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SiegeTower with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SiegeTower instance)
	{
		instance.doorID = doorID;
		instance.drawBridgeID = drawBridgeID;
		instance.drawBridge2ID = drawBridge2ID;
		instance.drawBridge3ID = drawBridge3ID;
	}

	public SiegeTower Copy()
	{
		SiegeTower siegeTower = Pool.Get<SiegeTower>();
		CopyTo(siegeTower);
		return siegeTower;
	}

	public static SiegeTower Deserialize(BufferStream stream)
	{
		SiegeTower siegeTower = Pool.Get<SiegeTower>();
		Deserialize(stream, siegeTower, isDelta: false);
		return siegeTower;
	}

	public static SiegeTower DeserializeLengthDelimited(BufferStream stream)
	{
		SiegeTower siegeTower = Pool.Get<SiegeTower>();
		DeserializeLengthDelimited(stream, siegeTower, isDelta: false);
		return siegeTower;
	}

	public static SiegeTower DeserializeLength(BufferStream stream, int length)
	{
		SiegeTower siegeTower = Pool.Get<SiegeTower>();
		DeserializeLength(stream, length, siegeTower, isDelta: false);
		return siegeTower;
	}

	public static SiegeTower Deserialize(byte[] buffer)
	{
		SiegeTower siegeTower = Pool.Get<SiegeTower>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, siegeTower, isDelta: false);
		return siegeTower;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SiegeTower previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SiegeTower Deserialize(BufferStream stream, SiegeTower instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.doorID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.drawBridgeID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.drawBridge2ID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.drawBridge3ID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SiegeTower DeserializeLengthDelimited(BufferStream stream, SiegeTower instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.doorID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.drawBridgeID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.drawBridge2ID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.drawBridge3ID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SiegeTower DeserializeLength(BufferStream stream, int length, SiegeTower instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.doorID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.drawBridgeID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.drawBridge2ID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.drawBridge3ID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SiegeTower instance, SiegeTower previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.doorID.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.drawBridgeID.Value);
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, instance.drawBridge2ID.Value);
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.drawBridge3ID.Value);
	}

	public static void Serialize(BufferStream stream, SiegeTower instance)
	{
		if (instance.doorID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.doorID.Value);
		}
		if (instance.drawBridgeID != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.drawBridgeID.Value);
		}
		if (instance.drawBridge2ID != default(NetworkableId))
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.drawBridge2ID.Value);
		}
		if (instance.drawBridge3ID != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.drawBridge3ID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref doorID.Value);
		action(UidType.NetworkableId, ref drawBridgeID.Value);
		action(UidType.NetworkableId, ref drawBridge2ID.Value);
		action(UidType.NetworkableId, ref drawBridge3ID.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Sign : IDisposable, IPooled, IProto<Sign>, IProto
{
	[NonSerialized]
	public uint imageid;

	[NonSerialized]
	public List<uint> imageIds;

	[NonSerialized]
	public List<ulong> editHistory;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Sign instance)
	{
		if (instance.ShouldPool)
		{
			instance.imageid = 0u;
			if (instance.imageIds != null)
			{
				List<uint> list = instance.imageIds;
				Pool.FreeUnmanaged<uint>(ref list);
				instance.imageIds = list;
			}
			if (instance.editHistory != null)
			{
				List<ulong> list2 = instance.editHistory;
				Pool.FreeUnmanaged<ulong>(ref list2);
				instance.editHistory = list2;
			}
			Pool.Free<Sign>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Sign with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Sign instance)
	{
		instance.imageid = imageid;
		if (imageIds != null)
		{
			instance.imageIds = Pool.Get<List<uint>>();
			for (int i = 0; i < imageIds.Count; i++)
			{
				uint item = imageIds[i];
				instance.imageIds.Add(item);
			}
		}
		else
		{
			instance.imageIds = null;
		}
		if (editHistory != null)
		{
			instance.editHistory = Pool.Get<List<ulong>>();
			for (int j = 0; j < editHistory.Count; j++)
			{
				ulong item2 = editHistory[j];
				instance.editHistory.Add(item2);
			}
		}
		else
		{
			instance.editHistory = null;
		}
	}

	public Sign Copy()
	{
		Sign sign = Pool.Get<Sign>();
		CopyTo(sign);
		return sign;
	}

	public static Sign Deserialize(BufferStream stream)
	{
		Sign sign = Pool.Get<Sign>();
		Deserialize(stream, sign, isDelta: false);
		return sign;
	}

	public static Sign DeserializeLengthDelimited(BufferStream stream)
	{
		Sign sign = Pool.Get<Sign>();
		DeserializeLengthDelimited(stream, sign, isDelta: false);
		return sign;
	}

	public static Sign DeserializeLength(BufferStream stream, int length)
	{
		Sign sign = Pool.Get<Sign>();
		DeserializeLength(stream, length, sign, isDelta: false);
		return sign;
	}

	public static Sign Deserialize(byte[] buffer)
	{
		Sign sign = Pool.Get<Sign>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, sign, isDelta: false);
		return sign;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Sign previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Sign Deserialize(BufferStream stream, Sign instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.imageIds == null)
			{
				instance.imageIds = Pool.Get<List<uint>>();
			}
			if (instance.editHistory == null)
			{
				instance.editHistory = Pool.Get<List<ulong>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 24:
				instance.imageid = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.imageIds.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 40:
				instance.editHistory.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Sign DeserializeLengthDelimited(BufferStream stream, Sign instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.imageIds == null)
			{
				instance.imageIds = Pool.Get<List<uint>>();
			}
			if (instance.editHistory == null)
			{
				instance.editHistory = Pool.Get<List<ulong>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 24:
				instance.imageid = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.imageIds.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 40:
				instance.editHistory.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Sign DeserializeLength(BufferStream stream, int length, Sign instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.imageIds == null)
			{
				instance.imageIds = Pool.Get<List<uint>>();
			}
			if (instance.editHistory == null)
			{
				instance.editHistory = Pool.Get<List<ulong>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 24:
				instance.imageid = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.imageIds.Add(ProtocolParser.ReadUInt32(stream));
				continue;
			case 40:
				instance.editHistory.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Sign instance, Sign previous)
	{
		if (instance.imageid != previous.imageid)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.imageid);
		}
		if (instance.imageIds != null)
		{
			for (int i = 0; i < instance.imageIds.Count; i++)
			{
				uint val = instance.imageIds[i];
				stream.WriteByte(32);
				ProtocolParser.WriteUInt32(stream, val);
			}
		}
		if (instance.editHistory != null)
		{
			for (int j = 0; j < instance.editHistory.Count; j++)
			{
				ulong val2 = instance.editHistory[j];
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, val2);
			}
		}
	}

	public static void Serialize(BufferStream stream, Sign instance)
	{
		if (instance.imageid != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.imageid);
		}
		if (instance.imageIds != null)
		{
			for (int i = 0; i < instance.imageIds.Count; i++)
			{
				uint val = instance.imageIds[i];
				stream.WriteByte(32);
				ProtocolParser.WriteUInt32(stream, val);
			}
		}
		if (instance.editHistory != null)
		{
			for (int j = 0; j < instance.editHistory.Count; j++)
			{
				ulong val2 = instance.editHistory[j];
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, val2);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SimpleInt : IDisposable, IPooled, IProto<SimpleInt>, IProto
{
	[NonSerialized]
	public int value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SimpleInt instance)
	{
		if (instance.ShouldPool)
		{
			instance.value = 0;
			Pool.Free<SimpleInt>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SimpleInt with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SimpleInt instance)
	{
		instance.value = value;
	}

	public SimpleInt Copy()
	{
		SimpleInt simpleInt = Pool.Get<SimpleInt>();
		CopyTo(simpleInt);
		return simpleInt;
	}

	public static SimpleInt Deserialize(BufferStream stream)
	{
		SimpleInt simpleInt = Pool.Get<SimpleInt>();
		Deserialize(stream, simpleInt, isDelta: false);
		return simpleInt;
	}

	public static SimpleInt DeserializeLengthDelimited(BufferStream stream)
	{
		SimpleInt simpleInt = Pool.Get<SimpleInt>();
		DeserializeLengthDelimited(stream, simpleInt, isDelta: false);
		return simpleInt;
	}

	public static SimpleInt DeserializeLength(BufferStream stream, int length)
	{
		SimpleInt simpleInt = Pool.Get<SimpleInt>();
		DeserializeLength(stream, length, simpleInt, isDelta: false);
		return simpleInt;
	}

	public static SimpleInt Deserialize(byte[] buffer)
	{
		SimpleInt simpleInt = Pool.Get<SimpleInt>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, simpleInt, isDelta: false);
		return simpleInt;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SimpleInt previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SimpleInt Deserialize(BufferStream stream, SimpleInt instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.value = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SimpleInt DeserializeLengthDelimited(BufferStream stream, SimpleInt instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SimpleInt DeserializeLength(BufferStream stream, int length, SimpleInt instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SimpleInt instance, SimpleInt previous)
	{
		if (instance.value != previous.value)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.value);
		}
	}

	public static void Serialize(BufferStream stream, SimpleInt instance)
	{
		if (instance.value != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SimpleUID : IDisposable, IPooled, IProto<SimpleUID>, IProto
{
	[NonSerialized]
	public NetworkableId uid;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SimpleUID instance)
	{
		if (instance.ShouldPool)
		{
			instance.uid = default(NetworkableId);
			Pool.Free<SimpleUID>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SimpleUID with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SimpleUID instance)
	{
		instance.uid = uid;
	}

	public SimpleUID Copy()
	{
		SimpleUID simpleUID = Pool.Get<SimpleUID>();
		CopyTo(simpleUID);
		return simpleUID;
	}

	public static SimpleUID Deserialize(BufferStream stream)
	{
		SimpleUID simpleUID = Pool.Get<SimpleUID>();
		Deserialize(stream, simpleUID, isDelta: false);
		return simpleUID;
	}

	public static SimpleUID DeserializeLengthDelimited(BufferStream stream)
	{
		SimpleUID simpleUID = Pool.Get<SimpleUID>();
		DeserializeLengthDelimited(stream, simpleUID, isDelta: false);
		return simpleUID;
	}

	public static SimpleUID DeserializeLength(BufferStream stream, int length)
	{
		SimpleUID simpleUID = Pool.Get<SimpleUID>();
		DeserializeLength(stream, length, simpleUID, isDelta: false);
		return simpleUID;
	}

	public static SimpleUID Deserialize(byte[] buffer)
	{
		SimpleUID simpleUID = Pool.Get<SimpleUID>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, simpleUID, isDelta: false);
		return simpleUID;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SimpleUID previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SimpleUID Deserialize(BufferStream stream, SimpleUID instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.uid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SimpleUID DeserializeLengthDelimited(BufferStream stream, SimpleUID instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.uid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SimpleUID DeserializeLength(BufferStream stream, int length, SimpleUID instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.uid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SimpleUID instance, SimpleUID previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.uid.Value);
	}

	public static void Serialize(BufferStream stream, SimpleUID instance)
	{
		if (instance.uid != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.uid.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref uid.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SimpleUInt : IDisposable, IPooled, IProto<SimpleUInt>, IProto
{
	[NonSerialized]
	public uint value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SimpleUInt instance)
	{
		if (instance.ShouldPool)
		{
			instance.value = 0u;
			Pool.Free<SimpleUInt>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SimpleUInt with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SimpleUInt instance)
	{
		instance.value = value;
	}

	public SimpleUInt Copy()
	{
		SimpleUInt simpleUInt = Pool.Get<SimpleUInt>();
		CopyTo(simpleUInt);
		return simpleUInt;
	}

	public static SimpleUInt Deserialize(BufferStream stream)
	{
		SimpleUInt simpleUInt = Pool.Get<SimpleUInt>();
		Deserialize(stream, simpleUInt, isDelta: false);
		return simpleUInt;
	}

	public static SimpleUInt DeserializeLengthDelimited(BufferStream stream)
	{
		SimpleUInt simpleUInt = Pool.Get<SimpleUInt>();
		DeserializeLengthDelimited(stream, simpleUInt, isDelta: false);
		return simpleUInt;
	}

	public static SimpleUInt DeserializeLength(BufferStream stream, int length)
	{
		SimpleUInt simpleUInt = Pool.Get<SimpleUInt>();
		DeserializeLength(stream, length, simpleUInt, isDelta: false);
		return simpleUInt;
	}

	public static SimpleUInt Deserialize(byte[] buffer)
	{
		SimpleUInt simpleUInt = Pool.Get<SimpleUInt>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, simpleUInt, isDelta: false);
		return simpleUInt;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SimpleUInt previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SimpleUInt Deserialize(BufferStream stream, SimpleUInt instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.value = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SimpleUInt DeserializeLengthDelimited(BufferStream stream, SimpleUInt instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SimpleUInt DeserializeLength(BufferStream stream, int length, SimpleUInt instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.value = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SimpleUInt instance, SimpleUInt previous)
	{
		if (instance.value != previous.value)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.value);
		}
	}

	public static void Serialize(BufferStream stream, SimpleUInt instance)
	{
		if (instance.value != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SkullTrophy : IDisposable, IPooled, IProto<SkullTrophy>, IProto
{
	[NonSerialized]
	public string playerName;

	[NonSerialized]
	public string streamerName;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SkullTrophy instance)
	{
		if (instance.ShouldPool)
		{
			instance.playerName = string.Empty;
			instance.streamerName = string.Empty;
			Pool.Free<SkullTrophy>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SkullTrophy with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SkullTrophy instance)
	{
		instance.playerName = playerName;
		instance.streamerName = streamerName;
	}

	public SkullTrophy Copy()
	{
		SkullTrophy skullTrophy = Pool.Get<SkullTrophy>();
		CopyTo(skullTrophy);
		return skullTrophy;
	}

	public static SkullTrophy Deserialize(BufferStream stream)
	{
		SkullTrophy skullTrophy = Pool.Get<SkullTrophy>();
		Deserialize(stream, skullTrophy, isDelta: false);
		return skullTrophy;
	}

	public static SkullTrophy DeserializeLengthDelimited(BufferStream stream)
	{
		SkullTrophy skullTrophy = Pool.Get<SkullTrophy>();
		DeserializeLengthDelimited(stream, skullTrophy, isDelta: false);
		return skullTrophy;
	}

	public static SkullTrophy DeserializeLength(BufferStream stream, int length)
	{
		SkullTrophy skullTrophy = Pool.Get<SkullTrophy>();
		DeserializeLength(stream, length, skullTrophy, isDelta: false);
		return skullTrophy;
	}

	public static SkullTrophy Deserialize(byte[] buffer)
	{
		SkullTrophy skullTrophy = Pool.Get<SkullTrophy>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, skullTrophy, isDelta: false);
		return skullTrophy;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SkullTrophy previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SkullTrophy Deserialize(BufferStream stream, SkullTrophy instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.streamerName = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SkullTrophy DeserializeLengthDelimited(BufferStream stream, SkullTrophy instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.streamerName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SkullTrophy DeserializeLength(BufferStream stream, int length, SkullTrophy instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.streamerName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SkullTrophy instance, SkullTrophy previous)
	{
		if (instance.playerName != null && instance.playerName != previous.playerName)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.playerName);
		}
		if (instance.streamerName != null && instance.streamerName != previous.streamerName)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.streamerName);
		}
	}

	public static void Serialize(BufferStream stream, SkullTrophy instance)
	{
		if (instance.playerName != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.playerName);
		}
		if (instance.streamerName != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.streamerName);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SleepingBag : IDisposable, IPooled, IProto<SleepingBag>, IProto
{
	[NonSerialized]
	public string name;

	[NonSerialized]
	public ulong deployerID;

	[NonSerialized]
	public bool clientAssigned;

	[NonSerialized]
	public bool isAssigned;

	[NonSerialized]
	public string teamMemberName;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SleepingBag instance)
	{
		if (instance.ShouldPool)
		{
			instance.name = string.Empty;
			instance.deployerID = 0uL;
			instance.clientAssigned = false;
			instance.isAssigned = false;
			instance.teamMemberName = string.Empty;
			Pool.Free<SleepingBag>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SleepingBag with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SleepingBag instance)
	{
		instance.name = name;
		instance.deployerID = deployerID;
		instance.clientAssigned = clientAssigned;
		instance.isAssigned = isAssigned;
		instance.teamMemberName = teamMemberName;
	}

	public SleepingBag Copy()
	{
		SleepingBag sleepingBag = Pool.Get<SleepingBag>();
		CopyTo(sleepingBag);
		return sleepingBag;
	}

	public static SleepingBag Deserialize(BufferStream stream)
	{
		SleepingBag sleepingBag = Pool.Get<SleepingBag>();
		Deserialize(stream, sleepingBag, isDelta: false);
		return sleepingBag;
	}

	public static SleepingBag DeserializeLengthDelimited(BufferStream stream)
	{
		SleepingBag sleepingBag = Pool.Get<SleepingBag>();
		DeserializeLengthDelimited(stream, sleepingBag, isDelta: false);
		return sleepingBag;
	}

	public static SleepingBag DeserializeLength(BufferStream stream, int length)
	{
		SleepingBag sleepingBag = Pool.Get<SleepingBag>();
		DeserializeLength(stream, length, sleepingBag, isDelta: false);
		return sleepingBag;
	}

	public static SleepingBag Deserialize(byte[] buffer)
	{
		SleepingBag sleepingBag = Pool.Get<SleepingBag>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, sleepingBag, isDelta: false);
		return sleepingBag;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SleepingBag previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SleepingBag Deserialize(BufferStream stream, SleepingBag instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.deployerID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.clientAssigned = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.isAssigned = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				instance.teamMemberName = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SleepingBag DeserializeLengthDelimited(BufferStream stream, SleepingBag instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.deployerID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.clientAssigned = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.isAssigned = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				instance.teamMemberName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SleepingBag DeserializeLength(BufferStream stream, int length, SleepingBag instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.deployerID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.clientAssigned = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.isAssigned = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				instance.teamMemberName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SleepingBag instance, SleepingBag previous)
	{
		if (instance.name != null && instance.name != previous.name)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.deployerID != previous.deployerID)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.deployerID);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.clientAssigned);
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.isAssigned);
		if (instance.teamMemberName != null && instance.teamMemberName != previous.teamMemberName)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.teamMemberName);
		}
	}

	public static void Serialize(BufferStream stream, SleepingBag instance)
	{
		if (instance.name != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.deployerID != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.deployerID);
		}
		if (instance.clientAssigned)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.clientAssigned);
		}
		if (instance.isAssigned)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.isAssigned);
		}
		if (instance.teamMemberName != null)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.teamMemberName);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SleepingBagCamper : IDisposable, IPooled, IProto<SleepingBagCamper>, IProto
{
	[NonSerialized]
	public NetworkableId seatID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SleepingBagCamper instance)
	{
		if (instance.ShouldPool)
		{
			instance.seatID = default(NetworkableId);
			Pool.Free<SleepingBagCamper>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SleepingBagCamper with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SleepingBagCamper instance)
	{
		instance.seatID = seatID;
	}

	public SleepingBagCamper Copy()
	{
		SleepingBagCamper sleepingBagCamper = Pool.Get<SleepingBagCamper>();
		CopyTo(sleepingBagCamper);
		return sleepingBagCamper;
	}

	public static SleepingBagCamper Deserialize(BufferStream stream)
	{
		SleepingBagCamper sleepingBagCamper = Pool.Get<SleepingBagCamper>();
		Deserialize(stream, sleepingBagCamper, isDelta: false);
		return sleepingBagCamper;
	}

	public static SleepingBagCamper DeserializeLengthDelimited(BufferStream stream)
	{
		SleepingBagCamper sleepingBagCamper = Pool.Get<SleepingBagCamper>();
		DeserializeLengthDelimited(stream, sleepingBagCamper, isDelta: false);
		return sleepingBagCamper;
	}

	public static SleepingBagCamper DeserializeLength(BufferStream stream, int length)
	{
		SleepingBagCamper sleepingBagCamper = Pool.Get<SleepingBagCamper>();
		DeserializeLength(stream, length, sleepingBagCamper, isDelta: false);
		return sleepingBagCamper;
	}

	public static SleepingBagCamper Deserialize(byte[] buffer)
	{
		SleepingBagCamper sleepingBagCamper = Pool.Get<SleepingBagCamper>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, sleepingBagCamper, isDelta: false);
		return sleepingBagCamper;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SleepingBagCamper previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SleepingBagCamper Deserialize(BufferStream stream, SleepingBagCamper instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.seatID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SleepingBagCamper DeserializeLengthDelimited(BufferStream stream, SleepingBagCamper instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.seatID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SleepingBagCamper DeserializeLength(BufferStream stream, int length, SleepingBagCamper instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.seatID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SleepingBagCamper instance, SleepingBagCamper previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.seatID.Value);
	}

	public static void Serialize(BufferStream stream, SleepingBagCamper instance)
	{
		if (instance.seatID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.seatID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref seatID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SlotMachine : IDisposable, IPooled, IProto<SlotMachine>, IProto
{
	[NonSerialized]
	public int oldResult1;

	[NonSerialized]
	public int oldResult2;

	[NonSerialized]
	public int oldResult3;

	[NonSerialized]
	public int newResult1;

	[NonSerialized]
	public int newResult2;

	[NonSerialized]
	public int newResult3;

	[NonSerialized]
	public bool isSpinning;

	[NonSerialized]
	public float spinTime;

	[NonSerialized]
	public NetworkableId storageID;

	[NonSerialized]
	public int multiplier;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SlotMachine instance)
	{
		if (instance.ShouldPool)
		{
			instance.oldResult1 = 0;
			instance.oldResult2 = 0;
			instance.oldResult3 = 0;
			instance.newResult1 = 0;
			instance.newResult2 = 0;
			instance.newResult3 = 0;
			instance.isSpinning = false;
			instance.spinTime = 0f;
			instance.storageID = default(NetworkableId);
			instance.multiplier = 0;
			Pool.Free<SlotMachine>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SlotMachine with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SlotMachine instance)
	{
		instance.oldResult1 = oldResult1;
		instance.oldResult2 = oldResult2;
		instance.oldResult3 = oldResult3;
		instance.newResult1 = newResult1;
		instance.newResult2 = newResult2;
		instance.newResult3 = newResult3;
		instance.isSpinning = isSpinning;
		instance.spinTime = spinTime;
		instance.storageID = storageID;
		instance.multiplier = multiplier;
	}

	public SlotMachine Copy()
	{
		SlotMachine slotMachine = Pool.Get<SlotMachine>();
		CopyTo(slotMachine);
		return slotMachine;
	}

	public static SlotMachine Deserialize(BufferStream stream)
	{
		SlotMachine slotMachine = Pool.Get<SlotMachine>();
		Deserialize(stream, slotMachine, isDelta: false);
		return slotMachine;
	}

	public static SlotMachine DeserializeLengthDelimited(BufferStream stream)
	{
		SlotMachine slotMachine = Pool.Get<SlotMachine>();
		DeserializeLengthDelimited(stream, slotMachine, isDelta: false);
		return slotMachine;
	}

	public static SlotMachine DeserializeLength(BufferStream stream, int length)
	{
		SlotMachine slotMachine = Pool.Get<SlotMachine>();
		DeserializeLength(stream, length, slotMachine, isDelta: false);
		return slotMachine;
	}

	public static SlotMachine Deserialize(byte[] buffer)
	{
		SlotMachine slotMachine = Pool.Get<SlotMachine>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, slotMachine, isDelta: false);
		return slotMachine;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SlotMachine previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SlotMachine Deserialize(BufferStream stream, SlotMachine instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.oldResult1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.oldResult2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.oldResult3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.newResult1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.newResult2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.newResult3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.isSpinning = ProtocolParser.ReadBool(stream);
				continue;
			case 69:
				instance.spinTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 72:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 80:
				instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SlotMachine DeserializeLengthDelimited(BufferStream stream, SlotMachine instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.oldResult1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.oldResult2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.oldResult3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.newResult1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.newResult2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.newResult3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.isSpinning = ProtocolParser.ReadBool(stream);
				continue;
			case 69:
				instance.spinTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 72:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 80:
				instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SlotMachine DeserializeLength(BufferStream stream, int length, SlotMachine instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.oldResult1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.oldResult2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.oldResult3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.newResult1 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.newResult2 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.newResult3 = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.isSpinning = ProtocolParser.ReadBool(stream);
				continue;
			case 69:
				instance.spinTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 72:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 80:
				instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SlotMachine instance, SlotMachine previous)
	{
		if (instance.oldResult1 != previous.oldResult1)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.oldResult1);
		}
		if (instance.oldResult2 != previous.oldResult2)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.oldResult2);
		}
		if (instance.oldResult3 != previous.oldResult3)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.oldResult3);
		}
		if (instance.newResult1 != previous.newResult1)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.newResult1);
		}
		if (instance.newResult2 != previous.newResult2)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.newResult2);
		}
		if (instance.newResult3 != previous.newResult3)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.newResult3);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.isSpinning);
		if (instance.spinTime != previous.spinTime)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.spinTime);
		}
		stream.WriteByte(72);
		ProtocolParser.WriteUInt64(stream, instance.storageID.Value);
		if (instance.multiplier != previous.multiplier)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.multiplier);
		}
	}

	public static void Serialize(BufferStream stream, SlotMachine instance)
	{
		if (instance.oldResult1 != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.oldResult1);
		}
		if (instance.oldResult2 != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.oldResult2);
		}
		if (instance.oldResult3 != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.oldResult3);
		}
		if (instance.newResult1 != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.newResult1);
		}
		if (instance.newResult2 != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.newResult2);
		}
		if (instance.newResult3 != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.newResult3);
		}
		if (instance.isSpinning)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.isSpinning);
		}
		if (instance.spinTime != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.spinTime);
		}
		if (instance.storageID != default(NetworkableId))
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, instance.storageID.Value);
		}
		if (instance.multiplier != 0)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.multiplier);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref storageID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SmallEngine : IDisposable, IPooled, IProto<SmallEngine>, IProto
{
	[NonSerialized]
	public NetworkableId fuelStorageID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SmallEngine instance)
	{
		if (instance.ShouldPool)
		{
			instance.fuelStorageID = default(NetworkableId);
			Pool.Free<SmallEngine>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SmallEngine with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SmallEngine instance)
	{
		instance.fuelStorageID = fuelStorageID;
	}

	public SmallEngine Copy()
	{
		SmallEngine smallEngine = Pool.Get<SmallEngine>();
		CopyTo(smallEngine);
		return smallEngine;
	}

	public static SmallEngine Deserialize(BufferStream stream)
	{
		SmallEngine smallEngine = Pool.Get<SmallEngine>();
		Deserialize(stream, smallEngine, isDelta: false);
		return smallEngine;
	}

	public static SmallEngine DeserializeLengthDelimited(BufferStream stream)
	{
		SmallEngine smallEngine = Pool.Get<SmallEngine>();
		DeserializeLengthDelimited(stream, smallEngine, isDelta: false);
		return smallEngine;
	}

	public static SmallEngine DeserializeLength(BufferStream stream, int length)
	{
		SmallEngine smallEngine = Pool.Get<SmallEngine>();
		DeserializeLength(stream, length, smallEngine, isDelta: false);
		return smallEngine;
	}

	public static SmallEngine Deserialize(byte[] buffer)
	{
		SmallEngine smallEngine = Pool.Get<SmallEngine>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, smallEngine, isDelta: false);
		return smallEngine;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SmallEngine previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SmallEngine Deserialize(BufferStream stream, SmallEngine instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SmallEngine DeserializeLengthDelimited(BufferStream stream, SmallEngine instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SmallEngine DeserializeLength(BufferStream stream, int length, SmallEngine instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SmallEngine instance, SmallEngine previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
	}

	public static void Serialize(BufferStream stream, SmallEngine instance)
	{
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref fuelStorageID.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SmartAlarm : IDisposable, IPooled, IProto<SmartAlarm>, IProto
{
	[NonSerialized]
	public List<ulong> subscriptions;

	[NonSerialized]
	public string notificationTitle;

	[NonSerialized]
	public string notificationBody;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SmartAlarm instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.subscriptions != null)
			{
				List<ulong> list = instance.subscriptions;
				Pool.FreeUnmanaged<ulong>(ref list);
				instance.subscriptions = list;
			}
			instance.notificationTitle = string.Empty;
			instance.notificationBody = string.Empty;
			Pool.Free<SmartAlarm>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SmartAlarm with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SmartAlarm instance)
	{
		if (subscriptions != null)
		{
			instance.subscriptions = Pool.Get<List<ulong>>();
			for (int i = 0; i < subscriptions.Count; i++)
			{
				ulong item = subscriptions[i];
				instance.subscriptions.Add(item);
			}
		}
		else
		{
			instance.subscriptions = null;
		}
		instance.notificationTitle = notificationTitle;
		instance.notificationBody = notificationBody;
	}

	public SmartAlarm Copy()
	{
		SmartAlarm smartAlarm = Pool.Get<SmartAlarm>();
		CopyTo(smartAlarm);
		return smartAlarm;
	}

	public static SmartAlarm Deserialize(BufferStream stream)
	{
		SmartAlarm smartAlarm = Pool.Get<SmartAlarm>();
		Deserialize(stream, smartAlarm, isDelta: false);
		return smartAlarm;
	}

	public static SmartAlarm DeserializeLengthDelimited(BufferStream stream)
	{
		SmartAlarm smartAlarm = Pool.Get<SmartAlarm>();
		DeserializeLengthDelimited(stream, smartAlarm, isDelta: false);
		return smartAlarm;
	}

	public static SmartAlarm DeserializeLength(BufferStream stream, int length)
	{
		SmartAlarm smartAlarm = Pool.Get<SmartAlarm>();
		DeserializeLength(stream, length, smartAlarm, isDelta: false);
		return smartAlarm;
	}

	public static SmartAlarm Deserialize(byte[] buffer)
	{
		SmartAlarm smartAlarm = Pool.Get<SmartAlarm>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, smartAlarm, isDelta: false);
		return smartAlarm;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SmartAlarm previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SmartAlarm Deserialize(BufferStream stream, SmartAlarm instance, bool isDelta)
	{
		if (!isDelta && instance.subscriptions == null)
		{
			instance.subscriptions = Pool.Get<List<ulong>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.subscriptions.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.notificationTitle = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.notificationBody = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SmartAlarm DeserializeLengthDelimited(BufferStream stream, SmartAlarm instance, bool isDelta)
	{
		if (!isDelta && instance.subscriptions == null)
		{
			instance.subscriptions = Pool.Get<List<ulong>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.subscriptions.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.notificationTitle = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.notificationBody = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SmartAlarm DeserializeLength(BufferStream stream, int length, SmartAlarm instance, bool isDelta)
	{
		if (!isDelta && instance.subscriptions == null)
		{
			instance.subscriptions = Pool.Get<List<ulong>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.subscriptions.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.notificationTitle = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.notificationBody = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SmartAlarm instance, SmartAlarm previous)
	{
		if (instance.subscriptions != null)
		{
			for (int i = 0; i < instance.subscriptions.Count; i++)
			{
				ulong val = instance.subscriptions[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
		if (instance.notificationTitle != null && instance.notificationTitle != previous.notificationTitle)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.notificationTitle);
		}
		if (instance.notificationBody != null && instance.notificationBody != previous.notificationBody)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.notificationBody);
		}
	}

	public static void Serialize(BufferStream stream, SmartAlarm instance)
	{
		if (instance.subscriptions != null)
		{
			for (int i = 0; i < instance.subscriptions.Count; i++)
			{
				ulong val = instance.subscriptions[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
		if (instance.notificationTitle != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.notificationTitle);
		}
		if (instance.notificationBody != null)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.notificationBody);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Snowmobile : IDisposable, IPooled, IProto<Snowmobile>, IProto
{
	[NonSerialized]
	public float steerInput;

	[NonSerialized]
	public float driveWheelVel;

	[NonSerialized]
	public float throttleInput;

	[NonSerialized]
	public float brakeInput;

	[NonSerialized]
	public NetworkableId storageID;

	[NonSerialized]
	public NetworkableId fuelStorageID;

	[NonSerialized]
	public float fuelFraction;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Snowmobile instance)
	{
		if (instance.ShouldPool)
		{
			instance.steerInput = 0f;
			instance.driveWheelVel = 0f;
			instance.throttleInput = 0f;
			instance.brakeInput = 0f;
			instance.storageID = default(NetworkableId);
			instance.fuelStorageID = default(NetworkableId);
			instance.fuelFraction = 0f;
			Pool.Free<Snowmobile>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Snowmobile with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Snowmobile instance)
	{
		instance.steerInput = steerInput;
		instance.driveWheelVel = driveWheelVel;
		instance.throttleInput = throttleInput;
		instance.brakeInput = brakeInput;
		instance.storageID = storageID;
		instance.fuelStorageID = fuelStorageID;
		instance.fuelFraction = fuelFraction;
	}

	public Snowmobile Copy()
	{
		Snowmobile snowmobile = Pool.Get<Snowmobile>();
		CopyTo(snowmobile);
		return snowmobile;
	}

	public static Snowmobile Deserialize(BufferStream stream)
	{
		Snowmobile snowmobile = Pool.Get<Snowmobile>();
		Deserialize(stream, snowmobile, isDelta: false);
		return snowmobile;
	}

	public static Snowmobile DeserializeLengthDelimited(BufferStream stream)
	{
		Snowmobile snowmobile = Pool.Get<Snowmobile>();
		DeserializeLengthDelimited(stream, snowmobile, isDelta: false);
		return snowmobile;
	}

	public static Snowmobile DeserializeLength(BufferStream stream, int length)
	{
		Snowmobile snowmobile = Pool.Get<Snowmobile>();
		DeserializeLength(stream, length, snowmobile, isDelta: false);
		return snowmobile;
	}

	public static Snowmobile Deserialize(byte[] buffer)
	{
		Snowmobile snowmobile = Pool.Get<Snowmobile>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, snowmobile, isDelta: false);
		return snowmobile;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Snowmobile previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Snowmobile Deserialize(BufferStream stream, Snowmobile instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.steerInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 77:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Snowmobile DeserializeLengthDelimited(BufferStream stream, Snowmobile instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.steerInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 77:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Snowmobile DeserializeLength(BufferStream stream, int length, Snowmobile instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.steerInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.driveWheelVel = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.throttleInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.brakeInput = ProtocolParser.ReadSingle(stream);
				continue;
			case 56:
				instance.storageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 64:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 77:
				instance.fuelFraction = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Snowmobile instance, Snowmobile previous)
	{
		if (instance.steerInput != previous.steerInput)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.steerInput);
		}
		if (instance.driveWheelVel != previous.driveWheelVel)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.driveWheelVel);
		}
		if (instance.throttleInput != previous.throttleInput)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.throttleInput);
		}
		if (instance.brakeInput != previous.brakeInput)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.brakeInput);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteUInt64(stream, instance.storageID.Value);
		stream.WriteByte(64);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		if (instance.fuelFraction != previous.fuelFraction)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
	}

	public static void Serialize(BufferStream stream, Snowmobile instance)
	{
		if (instance.steerInput != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.steerInput);
		}
		if (instance.driveWheelVel != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.driveWheelVel);
		}
		if (instance.throttleInput != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.throttleInput);
		}
		if (instance.brakeInput != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.brakeInput);
		}
		if (instance.storageID != default(NetworkableId))
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, instance.storageID.Value);
		}
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
		if (instance.fuelFraction != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.fuelFraction);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref storageID.Value);
		action(UidType.NetworkableId, ref fuelStorageID.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SortSettings : IDisposable, IPooled, IProto<SortSettings>, IProto
{
	[NonSerialized]
	public bool enabled;

	[NonSerialized]
	public int sortMode;

	[NonSerialized]
	public bool reverse;

	[NonSerialized]
	public bool stack;

	[NonSerialized]
	public List<string> customList;

	[NonSerialized]
	public string translateLanguage;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SortSettings instance)
	{
		if (instance.ShouldPool)
		{
			instance.enabled = false;
			instance.sortMode = 0;
			instance.reverse = false;
			instance.stack = false;
			if (instance.customList != null)
			{
				List<string> list = instance.customList;
				Pool.FreeUnmanaged<string>(ref list);
				instance.customList = list;
			}
			instance.translateLanguage = string.Empty;
			Pool.Free<SortSettings>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SortSettings with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SortSettings instance)
	{
		instance.enabled = enabled;
		instance.sortMode = sortMode;
		instance.reverse = reverse;
		instance.stack = stack;
		if (customList != null)
		{
			instance.customList = Pool.Get<List<string>>();
			for (int i = 0; i < customList.Count; i++)
			{
				string item = customList[i];
				instance.customList.Add(item);
			}
		}
		else
		{
			instance.customList = null;
		}
		instance.translateLanguage = translateLanguage;
	}

	public SortSettings Copy()
	{
		SortSettings sortSettings = Pool.Get<SortSettings>();
		CopyTo(sortSettings);
		return sortSettings;
	}

	public static SortSettings Deserialize(BufferStream stream)
	{
		SortSettings sortSettings = Pool.Get<SortSettings>();
		Deserialize(stream, sortSettings, isDelta: false);
		return sortSettings;
	}

	public static SortSettings DeserializeLengthDelimited(BufferStream stream)
	{
		SortSettings sortSettings = Pool.Get<SortSettings>();
		DeserializeLengthDelimited(stream, sortSettings, isDelta: false);
		return sortSettings;
	}

	public static SortSettings DeserializeLength(BufferStream stream, int length)
	{
		SortSettings sortSettings = Pool.Get<SortSettings>();
		DeserializeLength(stream, length, sortSettings, isDelta: false);
		return sortSettings;
	}

	public static SortSettings Deserialize(byte[] buffer)
	{
		SortSettings sortSettings = Pool.Get<SortSettings>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, sortSettings, isDelta: false);
		return sortSettings;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SortSettings previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SortSettings Deserialize(BufferStream stream, SortSettings instance, bool isDelta)
	{
		if (!isDelta && instance.customList == null)
		{
			instance.customList = Pool.Get<List<string>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.enabled = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.sortMode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.reverse = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.stack = ProtocolParser.ReadBool(stream);
				continue;
			case 42:
				instance.customList.Add(ProtocolParser.ReadString(stream));
				continue;
			case 58:
				instance.translateLanguage = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SortSettings DeserializeLengthDelimited(BufferStream stream, SortSettings instance, bool isDelta)
	{
		if (!isDelta && instance.customList == null)
		{
			instance.customList = Pool.Get<List<string>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.enabled = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.sortMode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.reverse = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.stack = ProtocolParser.ReadBool(stream);
				continue;
			case 42:
				instance.customList.Add(ProtocolParser.ReadString(stream));
				continue;
			case 58:
				instance.translateLanguage = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SortSettings DeserializeLength(BufferStream stream, int length, SortSettings instance, bool isDelta)
	{
		if (!isDelta && instance.customList == null)
		{
			instance.customList = Pool.Get<List<string>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.enabled = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.sortMode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.reverse = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.stack = ProtocolParser.ReadBool(stream);
				continue;
			case 42:
				instance.customList.Add(ProtocolParser.ReadString(stream));
				continue;
			case 58:
				instance.translateLanguage = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SortSettings instance, SortSettings previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.enabled);
		if (instance.sortMode != previous.sortMode)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.sortMode);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.reverse);
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.stack);
		if (instance.customList != null)
		{
			for (int i = 0; i < instance.customList.Count; i++)
			{
				string val = instance.customList[i];
				stream.WriteByte(42);
				ProtocolParser.WriteString(stream, val);
			}
		}
		if (instance.translateLanguage != null && instance.translateLanguage != previous.translateLanguage)
		{
			stream.WriteByte(58);
			ProtocolParser.WriteString(stream, instance.translateLanguage);
		}
	}

	public static void Serialize(BufferStream stream, SortSettings instance)
	{
		if (instance.enabled)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.enabled);
		}
		if (instance.sortMode != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.sortMode);
		}
		if (instance.reverse)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.reverse);
		}
		if (instance.stack)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.stack);
		}
		if (instance.customList != null)
		{
			for (int i = 0; i < instance.customList.Count; i++)
			{
				string val = instance.customList[i];
				stream.WriteByte(42);
				ProtocolParser.WriteString(stream, val);
			}
		}
		if (instance.translateLanguage != null)
		{
			stream.WriteByte(58);
			ProtocolParser.WriteString(stream, instance.translateLanguage);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Spawnable : IDisposable, IPooled, IProto<Spawnable>, IProto
{
	[NonSerialized]
	public uint population;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Spawnable instance)
	{
		if (instance.ShouldPool)
		{
			instance.population = 0u;
			Pool.Free<Spawnable>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Spawnable with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Spawnable instance)
	{
		instance.population = population;
	}

	public Spawnable Copy()
	{
		Spawnable spawnable = Pool.Get<Spawnable>();
		CopyTo(spawnable);
		return spawnable;
	}

	public static Spawnable Deserialize(BufferStream stream)
	{
		Spawnable spawnable = Pool.Get<Spawnable>();
		Deserialize(stream, spawnable, isDelta: false);
		return spawnable;
	}

	public static Spawnable DeserializeLengthDelimited(BufferStream stream)
	{
		Spawnable spawnable = Pool.Get<Spawnable>();
		DeserializeLengthDelimited(stream, spawnable, isDelta: false);
		return spawnable;
	}

	public static Spawnable DeserializeLength(BufferStream stream, int length)
	{
		Spawnable spawnable = Pool.Get<Spawnable>();
		DeserializeLength(stream, length, spawnable, isDelta: false);
		return spawnable;
	}

	public static Spawnable Deserialize(byte[] buffer)
	{
		Spawnable spawnable = Pool.Get<Spawnable>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, spawnable, isDelta: false);
		return spawnable;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Spawnable previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Spawnable Deserialize(BufferStream stream, Spawnable instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.population = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Spawnable DeserializeLengthDelimited(BufferStream stream, Spawnable instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.population = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Spawnable DeserializeLength(BufferStream stream, int length, Spawnable instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.population = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Spawnable instance, Spawnable previous)
	{
		if (instance.population != previous.population)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.population);
		}
	}

	public static void Serialize(BufferStream stream, Spawnable instance)
	{
		if (instance.population != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.population);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SpectateTeam : IDisposable, IPooled, IProto<SpectateTeam>, IProto
{
	[NonSerialized]
	public ulong teamId;

	[NonSerialized]
	public List<PlayerTeam.TeamMember> teamMembers;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SpectateTeam instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.teamId = 0uL;
		if (instance.teamMembers != null)
		{
			for (int i = 0; i < instance.teamMembers.Count; i++)
			{
				if (instance.teamMembers[i] != null)
				{
					instance.teamMembers[i].ResetToPool();
					instance.teamMembers[i] = null;
				}
			}
			List<PlayerTeam.TeamMember> list = instance.teamMembers;
			Pool.Free<PlayerTeam.TeamMember>(ref list, false);
			instance.teamMembers = list;
		}
		Pool.Free<SpectateTeam>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SpectateTeam with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SpectateTeam instance)
	{
		instance.teamId = teamId;
		if (teamMembers != null)
		{
			instance.teamMembers = Pool.Get<List<PlayerTeam.TeamMember>>();
			for (int i = 0; i < teamMembers.Count; i++)
			{
				PlayerTeam.TeamMember item = teamMembers[i].Copy();
				instance.teamMembers.Add(item);
			}
		}
		else
		{
			instance.teamMembers = null;
		}
	}

	public SpectateTeam Copy()
	{
		SpectateTeam spectateTeam = Pool.Get<SpectateTeam>();
		CopyTo(spectateTeam);
		return spectateTeam;
	}

	public static SpectateTeam Deserialize(BufferStream stream)
	{
		SpectateTeam spectateTeam = Pool.Get<SpectateTeam>();
		Deserialize(stream, spectateTeam, isDelta: false);
		return spectateTeam;
	}

	public static SpectateTeam DeserializeLengthDelimited(BufferStream stream)
	{
		SpectateTeam spectateTeam = Pool.Get<SpectateTeam>();
		DeserializeLengthDelimited(stream, spectateTeam, isDelta: false);
		return spectateTeam;
	}

	public static SpectateTeam DeserializeLength(BufferStream stream, int length)
	{
		SpectateTeam spectateTeam = Pool.Get<SpectateTeam>();
		DeserializeLength(stream, length, spectateTeam, isDelta: false);
		return spectateTeam;
	}

	public static SpectateTeam Deserialize(byte[] buffer)
	{
		SpectateTeam spectateTeam = Pool.Get<SpectateTeam>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, spectateTeam, isDelta: false);
		return spectateTeam;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SpectateTeam previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SpectateTeam Deserialize(BufferStream stream, SpectateTeam instance, bool isDelta)
	{
		if (!isDelta && instance.teamMembers == null)
		{
			instance.teamMembers = Pool.Get<List<PlayerTeam.TeamMember>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.teamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.teamMembers.Add(PlayerTeam.TeamMember.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SpectateTeam DeserializeLengthDelimited(BufferStream stream, SpectateTeam instance, bool isDelta)
	{
		if (!isDelta && instance.teamMembers == null)
		{
			instance.teamMembers = Pool.Get<List<PlayerTeam.TeamMember>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.teamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.teamMembers.Add(PlayerTeam.TeamMember.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SpectateTeam DeserializeLength(BufferStream stream, int length, SpectateTeam instance, bool isDelta)
	{
		if (!isDelta && instance.teamMembers == null)
		{
			instance.teamMembers = Pool.Get<List<PlayerTeam.TeamMember>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.teamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.teamMembers.Add(PlayerTeam.TeamMember.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SpectateTeam instance, SpectateTeam previous)
	{
		if (instance.teamId != previous.teamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.teamId);
		}
		if (instance.teamMembers == null)
		{
			return;
		}
		for (int i = 0; i < instance.teamMembers.Count; i++)
		{
			PlayerTeam.TeamMember teamMember = instance.teamMembers[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PlayerTeam.TeamMember.SerializeDelta(stream, teamMember, teamMember);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, SpectateTeam instance)
	{
		if (instance.teamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.teamId);
		}
		if (instance.teamMembers == null)
		{
			return;
		}
		for (int i = 0; i < instance.teamMembers.Count; i++)
		{
			PlayerTeam.TeamMember instance2 = instance.teamMembers[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PlayerTeam.TeamMember.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (teamMembers != null)
		{
			for (int i = 0; i < teamMembers.Count; i++)
			{
				teamMembers[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SpectateTeamInfo : IDisposable, IPooled, IProto<SpectateTeamInfo>, IProto
{
	[NonSerialized]
	public List<SpectateTeam> teams;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SpectateTeamInfo instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.teams != null)
		{
			for (int i = 0; i < instance.teams.Count; i++)
			{
				if (instance.teams[i] != null)
				{
					instance.teams[i].ResetToPool();
					instance.teams[i] = null;
				}
			}
			List<SpectateTeam> list = instance.teams;
			Pool.Free<SpectateTeam>(ref list, false);
			instance.teams = list;
		}
		Pool.Free<SpectateTeamInfo>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SpectateTeamInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SpectateTeamInfo instance)
	{
		if (teams != null)
		{
			instance.teams = Pool.Get<List<SpectateTeam>>();
			for (int i = 0; i < teams.Count; i++)
			{
				SpectateTeam item = teams[i].Copy();
				instance.teams.Add(item);
			}
		}
		else
		{
			instance.teams = null;
		}
	}

	public SpectateTeamInfo Copy()
	{
		SpectateTeamInfo spectateTeamInfo = Pool.Get<SpectateTeamInfo>();
		CopyTo(spectateTeamInfo);
		return spectateTeamInfo;
	}

	public static SpectateTeamInfo Deserialize(BufferStream stream)
	{
		SpectateTeamInfo spectateTeamInfo = Pool.Get<SpectateTeamInfo>();
		Deserialize(stream, spectateTeamInfo, isDelta: false);
		return spectateTeamInfo;
	}

	public static SpectateTeamInfo DeserializeLengthDelimited(BufferStream stream)
	{
		SpectateTeamInfo spectateTeamInfo = Pool.Get<SpectateTeamInfo>();
		DeserializeLengthDelimited(stream, spectateTeamInfo, isDelta: false);
		return spectateTeamInfo;
	}

	public static SpectateTeamInfo DeserializeLength(BufferStream stream, int length)
	{
		SpectateTeamInfo spectateTeamInfo = Pool.Get<SpectateTeamInfo>();
		DeserializeLength(stream, length, spectateTeamInfo, isDelta: false);
		return spectateTeamInfo;
	}

	public static SpectateTeamInfo Deserialize(byte[] buffer)
	{
		SpectateTeamInfo spectateTeamInfo = Pool.Get<SpectateTeamInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, spectateTeamInfo, isDelta: false);
		return spectateTeamInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SpectateTeamInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SpectateTeamInfo Deserialize(BufferStream stream, SpectateTeamInfo instance, bool isDelta)
	{
		if (!isDelta && instance.teams == null)
		{
			instance.teams = Pool.Get<List<SpectateTeam>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.teams.Add(SpectateTeam.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SpectateTeamInfo DeserializeLengthDelimited(BufferStream stream, SpectateTeamInfo instance, bool isDelta)
	{
		if (!isDelta && instance.teams == null)
		{
			instance.teams = Pool.Get<List<SpectateTeam>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.teams.Add(SpectateTeam.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SpectateTeamInfo DeserializeLength(BufferStream stream, int length, SpectateTeamInfo instance, bool isDelta)
	{
		if (!isDelta && instance.teams == null)
		{
			instance.teams = Pool.Get<List<SpectateTeam>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.teams.Add(SpectateTeam.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SpectateTeamInfo instance, SpectateTeamInfo previous)
	{
		if (instance.teams == null)
		{
			return;
		}
		for (int i = 0; i < instance.teams.Count; i++)
		{
			SpectateTeam spectateTeam = instance.teams[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			SpectateTeam.SerializeDelta(stream, spectateTeam, spectateTeam);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, SpectateTeamInfo instance)
	{
		if (instance.teams == null)
		{
			return;
		}
		for (int i = 0; i < instance.teams.Count; i++)
		{
			SpectateTeam instance2 = instance.teams[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			SpectateTeam.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (teams != null)
		{
			for (int i = 0; i < teams.Count; i++)
			{
				teams[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SphereEntity : IDisposable, IPooled, IProto<SphereEntity>, IProto
{
	[NonSerialized]
	public float radius;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SphereEntity instance)
	{
		if (instance.ShouldPool)
		{
			instance.radius = 0f;
			Pool.Free<SphereEntity>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SphereEntity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SphereEntity instance)
	{
		instance.radius = radius;
	}

	public SphereEntity Copy()
	{
		SphereEntity sphereEntity = Pool.Get<SphereEntity>();
		CopyTo(sphereEntity);
		return sphereEntity;
	}

	public static SphereEntity Deserialize(BufferStream stream)
	{
		SphereEntity sphereEntity = Pool.Get<SphereEntity>();
		Deserialize(stream, sphereEntity, isDelta: false);
		return sphereEntity;
	}

	public static SphereEntity DeserializeLengthDelimited(BufferStream stream)
	{
		SphereEntity sphereEntity = Pool.Get<SphereEntity>();
		DeserializeLengthDelimited(stream, sphereEntity, isDelta: false);
		return sphereEntity;
	}

	public static SphereEntity DeserializeLength(BufferStream stream, int length)
	{
		SphereEntity sphereEntity = Pool.Get<SphereEntity>();
		DeserializeLength(stream, length, sphereEntity, isDelta: false);
		return sphereEntity;
	}

	public static SphereEntity Deserialize(byte[] buffer)
	{
		SphereEntity sphereEntity = Pool.Get<SphereEntity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, sphereEntity, isDelta: false);
		return sphereEntity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SphereEntity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SphereEntity Deserialize(BufferStream stream, SphereEntity instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.radius = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SphereEntity DeserializeLengthDelimited(BufferStream stream, SphereEntity instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.radius = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SphereEntity DeserializeLength(BufferStream stream, int length, SphereEntity instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.radius = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SphereEntity instance, SphereEntity previous)
	{
		if (instance.radius != previous.radius)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.radius);
		}
	}

	public static void Serialize(BufferStream stream, SphereEntity instance)
	{
		if (instance.radius != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.radius);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class SpinnerWheel : IDisposable, IPooled, IProto<SpinnerWheel>, IProto
{
	[NonSerialized]
	public Vector3 spin;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SpinnerWheel instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.spin = default(Vector3);
			Pool.Free<SpinnerWheel>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SpinnerWheel with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SpinnerWheel instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		instance.spin = spin;
	}

	public SpinnerWheel Copy()
	{
		SpinnerWheel spinnerWheel = Pool.Get<SpinnerWheel>();
		CopyTo(spinnerWheel);
		return spinnerWheel;
	}

	public static SpinnerWheel Deserialize(BufferStream stream)
	{
		SpinnerWheel spinnerWheel = Pool.Get<SpinnerWheel>();
		Deserialize(stream, spinnerWheel, isDelta: false);
		return spinnerWheel;
	}

	public static SpinnerWheel DeserializeLengthDelimited(BufferStream stream)
	{
		SpinnerWheel spinnerWheel = Pool.Get<SpinnerWheel>();
		DeserializeLengthDelimited(stream, spinnerWheel, isDelta: false);
		return spinnerWheel;
	}

	public static SpinnerWheel DeserializeLength(BufferStream stream, int length)
	{
		SpinnerWheel spinnerWheel = Pool.Get<SpinnerWheel>();
		DeserializeLength(stream, length, spinnerWheel, isDelta: false);
		return spinnerWheel;
	}

	public static SpinnerWheel Deserialize(byte[] buffer)
	{
		SpinnerWheel spinnerWheel = Pool.Get<SpinnerWheel>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, spinnerWheel, isDelta: false);
		return spinnerWheel;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SpinnerWheel previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SpinnerWheel Deserialize(BufferStream stream, SpinnerWheel instance, bool isDelta)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.spin, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SpinnerWheel DeserializeLengthDelimited(BufferStream stream, SpinnerWheel instance, bool isDelta)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.spin, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SpinnerWheel DeserializeLength(BufferStream stream, int length, SpinnerWheel instance, bool isDelta)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.spin, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SpinnerWheel instance, SpinnerWheel previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.spin != previous.spin)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.spin, previous.spin);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field spin (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, SpinnerWheel instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.spin != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.spin);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field spin (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Spray : IDisposable, IPooled, IProto<Spray>, IProto
{
	[NonSerialized]
	public ulong sprayedBy;

	[NonSerialized]
	public long timestamp;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Spray instance)
	{
		if (instance.ShouldPool)
		{
			instance.sprayedBy = 0uL;
			instance.timestamp = 0L;
			Pool.Free<Spray>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Spray with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Spray instance)
	{
		instance.sprayedBy = sprayedBy;
		instance.timestamp = timestamp;
	}

	public Spray Copy()
	{
		Spray spray = Pool.Get<Spray>();
		CopyTo(spray);
		return spray;
	}

	public static Spray Deserialize(BufferStream stream)
	{
		Spray spray = Pool.Get<Spray>();
		Deserialize(stream, spray, isDelta: false);
		return spray;
	}

	public static Spray DeserializeLengthDelimited(BufferStream stream)
	{
		Spray spray = Pool.Get<Spray>();
		DeserializeLengthDelimited(stream, spray, isDelta: false);
		return spray;
	}

	public static Spray DeserializeLength(BufferStream stream, int length)
	{
		Spray spray = Pool.Get<Spray>();
		DeserializeLength(stream, length, spray, isDelta: false);
		return spray;
	}

	public static Spray Deserialize(byte[] buffer)
	{
		Spray spray = Pool.Get<Spray>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, spray, isDelta: false);
		return spray;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Spray previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Spray Deserialize(BufferStream stream, Spray instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.sprayedBy = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Spray DeserializeLengthDelimited(BufferStream stream, Spray instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.sprayedBy = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Spray DeserializeLength(BufferStream stream, int length, Spray instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.sprayedBy = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Spray instance, Spray previous)
	{
		if (instance.sprayedBy != previous.sprayedBy)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.sprayedBy);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
	}

	public static void Serialize(BufferStream stream, Spray instance)
	{
		if (instance.sprayedBy != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.sprayedBy);
		}
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class SprayLine : IDisposable, IPooled, IProto<SprayLine>, IProto
{
	[NonSerialized]
	public List<LinePoint> linePoints;

	[NonSerialized]
	public Vector3 colour;

	[NonSerialized]
	public float width;

	[NonSerialized]
	public NetworkableId editingPlayer;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SprayLine instance)
	{
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.linePoints != null)
		{
			for (int i = 0; i < instance.linePoints.Count; i++)
			{
				if (instance.linePoints[i] != null)
				{
					instance.linePoints[i].ResetToPool();
					instance.linePoints[i] = null;
				}
			}
			List<LinePoint> list = instance.linePoints;
			Pool.Free<LinePoint>(ref list, false);
			instance.linePoints = list;
		}
		instance.colour = default(Vector3);
		instance.width = 0f;
		instance.editingPlayer = default(NetworkableId);
		Pool.Free<SprayLine>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SprayLine with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SprayLine instance)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		if (linePoints != null)
		{
			instance.linePoints = Pool.Get<List<LinePoint>>();
			for (int i = 0; i < linePoints.Count; i++)
			{
				LinePoint item = linePoints[i].Copy();
				instance.linePoints.Add(item);
			}
		}
		else
		{
			instance.linePoints = null;
		}
		instance.colour = colour;
		instance.width = width;
		instance.editingPlayer = editingPlayer;
	}

	public SprayLine Copy()
	{
		SprayLine sprayLine = Pool.Get<SprayLine>();
		CopyTo(sprayLine);
		return sprayLine;
	}

	public static SprayLine Deserialize(BufferStream stream)
	{
		SprayLine sprayLine = Pool.Get<SprayLine>();
		Deserialize(stream, sprayLine, isDelta: false);
		return sprayLine;
	}

	public static SprayLine DeserializeLengthDelimited(BufferStream stream)
	{
		SprayLine sprayLine = Pool.Get<SprayLine>();
		DeserializeLengthDelimited(stream, sprayLine, isDelta: false);
		return sprayLine;
	}

	public static SprayLine DeserializeLength(BufferStream stream, int length)
	{
		SprayLine sprayLine = Pool.Get<SprayLine>();
		DeserializeLength(stream, length, sprayLine, isDelta: false);
		return sprayLine;
	}

	public static SprayLine Deserialize(byte[] buffer)
	{
		SprayLine sprayLine = Pool.Get<SprayLine>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, sprayLine, isDelta: false);
		return sprayLine;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SprayLine previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SprayLine Deserialize(BufferStream stream, SprayLine instance, bool isDelta)
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<LinePoint>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.linePoints.Add(LinePoint.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colour, isDelta);
				continue;
			case 29:
				instance.width = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.editingPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SprayLine DeserializeLengthDelimited(BufferStream stream, SprayLine instance, bool isDelta)
	{
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<LinePoint>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.linePoints.Add(LinePoint.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colour, isDelta);
				continue;
			case 29:
				instance.width = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.editingPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SprayLine DeserializeLength(BufferStream stream, int length, SprayLine instance, bool isDelta)
	{
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<LinePoint>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.linePoints.Add(LinePoint.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colour, isDelta);
				continue;
			case 29:
				instance.width = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.editingPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SprayLine instance, SprayLine previous)
	{
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		if (instance.linePoints != null)
		{
			for (int i = 0; i < instance.linePoints.Count; i++)
			{
				LinePoint linePoint = instance.linePoints[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				LinePoint.SerializeDelta(stream, linePoint, linePoint);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (ProtoBuf.LinePoint)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.colour != previous.colour)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.colour, previous.colour);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field colour (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.width != previous.width)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.width);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.editingPlayer.Value);
	}

	public static void Serialize(BufferStream stream, SprayLine instance)
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		if (instance.linePoints != null)
		{
			for (int i = 0; i < instance.linePoints.Count; i++)
			{
				LinePoint instance2 = instance.linePoints[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				LinePoint.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (ProtoBuf.LinePoint)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.colour != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.colour);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field colour (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.width != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.width);
		}
		if (instance.editingPlayer != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.editingPlayer.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (linePoints != null)
		{
			for (int i = 0; i < linePoints.Count; i++)
			{
				linePoints[i]?.InspectUids(action);
			}
		}
		action(UidType.NetworkableId, ref editingPlayer.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SprayList : IDisposable, IPooled, IProto<SprayList>, IProto
{
	[NonSerialized]
	public List<LinePoint> linePoints;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SprayList instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.linePoints != null)
		{
			for (int i = 0; i < instance.linePoints.Count; i++)
			{
				if (instance.linePoints[i] != null)
				{
					instance.linePoints[i].ResetToPool();
					instance.linePoints[i] = null;
				}
			}
			List<LinePoint> list = instance.linePoints;
			Pool.Free<LinePoint>(ref list, false);
			instance.linePoints = list;
		}
		Pool.Free<SprayList>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SprayList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SprayList instance)
	{
		if (linePoints != null)
		{
			instance.linePoints = Pool.Get<List<LinePoint>>();
			for (int i = 0; i < linePoints.Count; i++)
			{
				LinePoint item = linePoints[i].Copy();
				instance.linePoints.Add(item);
			}
		}
		else
		{
			instance.linePoints = null;
		}
	}

	public SprayList Copy()
	{
		SprayList sprayList = Pool.Get<SprayList>();
		CopyTo(sprayList);
		return sprayList;
	}

	public static SprayList Deserialize(BufferStream stream)
	{
		SprayList sprayList = Pool.Get<SprayList>();
		Deserialize(stream, sprayList, isDelta: false);
		return sprayList;
	}

	public static SprayList DeserializeLengthDelimited(BufferStream stream)
	{
		SprayList sprayList = Pool.Get<SprayList>();
		DeserializeLengthDelimited(stream, sprayList, isDelta: false);
		return sprayList;
	}

	public static SprayList DeserializeLength(BufferStream stream, int length)
	{
		SprayList sprayList = Pool.Get<SprayList>();
		DeserializeLength(stream, length, sprayList, isDelta: false);
		return sprayList;
	}

	public static SprayList Deserialize(byte[] buffer)
	{
		SprayList sprayList = Pool.Get<SprayList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, sprayList, isDelta: false);
		return sprayList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SprayList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SprayList Deserialize(BufferStream stream, SprayList instance, bool isDelta)
	{
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<LinePoint>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.linePoints.Add(LinePoint.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SprayList DeserializeLengthDelimited(BufferStream stream, SprayList instance, bool isDelta)
	{
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<LinePoint>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.linePoints.Add(LinePoint.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SprayList DeserializeLength(BufferStream stream, int length, SprayList instance, bool isDelta)
	{
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<LinePoint>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.linePoints.Add(LinePoint.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SprayList instance, SprayList previous)
	{
		if (instance.linePoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.linePoints.Count; i++)
		{
			LinePoint linePoint = instance.linePoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			LinePoint.SerializeDelta(stream, linePoint, linePoint);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (ProtoBuf.LinePoint)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, SprayList instance)
	{
		if (instance.linePoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.linePoints.Count; i++)
		{
			LinePoint instance2 = instance.linePoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			LinePoint.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (ProtoBuf.LinePoint)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (linePoints != null)
		{
			for (int i = 0; i < linePoints.Count; i++)
			{
				linePoints[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class StabilityEntity : IDisposable, IPooled, IProto<StabilityEntity>, IProto
{
	[NonSerialized]
	public float stability;

	[NonSerialized]
	public int distanceFromGround;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(StabilityEntity instance)
	{
		if (instance.ShouldPool)
		{
			instance.stability = 0f;
			instance.distanceFromGround = 0;
			Pool.Free<StabilityEntity>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose StabilityEntity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(StabilityEntity instance)
	{
		instance.stability = stability;
		instance.distanceFromGround = distanceFromGround;
	}

	public StabilityEntity Copy()
	{
		StabilityEntity stabilityEntity = Pool.Get<StabilityEntity>();
		CopyTo(stabilityEntity);
		return stabilityEntity;
	}

	public static StabilityEntity Deserialize(BufferStream stream)
	{
		StabilityEntity stabilityEntity = Pool.Get<StabilityEntity>();
		Deserialize(stream, stabilityEntity, isDelta: false);
		return stabilityEntity;
	}

	public static StabilityEntity DeserializeLengthDelimited(BufferStream stream)
	{
		StabilityEntity stabilityEntity = Pool.Get<StabilityEntity>();
		DeserializeLengthDelimited(stream, stabilityEntity, isDelta: false);
		return stabilityEntity;
	}

	public static StabilityEntity DeserializeLength(BufferStream stream, int length)
	{
		StabilityEntity stabilityEntity = Pool.Get<StabilityEntity>();
		DeserializeLength(stream, length, stabilityEntity, isDelta: false);
		return stabilityEntity;
	}

	public static StabilityEntity Deserialize(byte[] buffer)
	{
		StabilityEntity stabilityEntity = Pool.Get<StabilityEntity>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, stabilityEntity, isDelta: false);
		return stabilityEntity;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, StabilityEntity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static StabilityEntity Deserialize(BufferStream stream, StabilityEntity instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.stability = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.distanceFromGround = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static StabilityEntity DeserializeLengthDelimited(BufferStream stream, StabilityEntity instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.stability = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.distanceFromGround = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static StabilityEntity DeserializeLength(BufferStream stream, int length, StabilityEntity instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.stability = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.distanceFromGround = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, StabilityEntity instance, StabilityEntity previous)
	{
		if (instance.stability != previous.stability)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.stability);
		}
		if (instance.distanceFromGround != previous.distanceFromGround)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.distanceFromGround);
		}
	}

	public static void Serialize(BufferStream stream, StabilityEntity instance)
	{
		if (instance.stability != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.stability);
		}
		if (instance.distanceFromGround != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.distanceFromGround);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class StaticRespawnAreaData : IDisposable, IPooled, IProto<StaticRespawnAreaData>, IProto
{
	[NonSerialized]
	public List<ulong> authorizedUsers;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(StaticRespawnAreaData instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.authorizedUsers != null)
			{
				List<ulong> list = instance.authorizedUsers;
				Pool.FreeUnmanaged<ulong>(ref list);
				instance.authorizedUsers = list;
			}
			Pool.Free<StaticRespawnAreaData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose StaticRespawnAreaData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(StaticRespawnAreaData instance)
	{
		if (authorizedUsers != null)
		{
			instance.authorizedUsers = Pool.Get<List<ulong>>();
			for (int i = 0; i < authorizedUsers.Count; i++)
			{
				ulong item = authorizedUsers[i];
				instance.authorizedUsers.Add(item);
			}
		}
		else
		{
			instance.authorizedUsers = null;
		}
	}

	public StaticRespawnAreaData Copy()
	{
		StaticRespawnAreaData staticRespawnAreaData = Pool.Get<StaticRespawnAreaData>();
		CopyTo(staticRespawnAreaData);
		return staticRespawnAreaData;
	}

	public static StaticRespawnAreaData Deserialize(BufferStream stream)
	{
		StaticRespawnAreaData staticRespawnAreaData = Pool.Get<StaticRespawnAreaData>();
		Deserialize(stream, staticRespawnAreaData, isDelta: false);
		return staticRespawnAreaData;
	}

	public static StaticRespawnAreaData DeserializeLengthDelimited(BufferStream stream)
	{
		StaticRespawnAreaData staticRespawnAreaData = Pool.Get<StaticRespawnAreaData>();
		DeserializeLengthDelimited(stream, staticRespawnAreaData, isDelta: false);
		return staticRespawnAreaData;
	}

	public static StaticRespawnAreaData DeserializeLength(BufferStream stream, int length)
	{
		StaticRespawnAreaData staticRespawnAreaData = Pool.Get<StaticRespawnAreaData>();
		DeserializeLength(stream, length, staticRespawnAreaData, isDelta: false);
		return staticRespawnAreaData;
	}

	public static StaticRespawnAreaData Deserialize(byte[] buffer)
	{
		StaticRespawnAreaData staticRespawnAreaData = Pool.Get<StaticRespawnAreaData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, staticRespawnAreaData, isDelta: false);
		return staticRespawnAreaData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, StaticRespawnAreaData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static StaticRespawnAreaData Deserialize(BufferStream stream, StaticRespawnAreaData instance, bool isDelta)
	{
		if (!isDelta && instance.authorizedUsers == null)
		{
			instance.authorizedUsers = Pool.Get<List<ulong>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.authorizedUsers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static StaticRespawnAreaData DeserializeLengthDelimited(BufferStream stream, StaticRespawnAreaData instance, bool isDelta)
	{
		if (!isDelta && instance.authorizedUsers == null)
		{
			instance.authorizedUsers = Pool.Get<List<ulong>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.authorizedUsers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static StaticRespawnAreaData DeserializeLength(BufferStream stream, int length, StaticRespawnAreaData instance, bool isDelta)
	{
		if (!isDelta && instance.authorizedUsers == null)
		{
			instance.authorizedUsers = Pool.Get<List<ulong>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.authorizedUsers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, StaticRespawnAreaData instance, StaticRespawnAreaData previous)
	{
		if (instance.authorizedUsers != null)
		{
			for (int i = 0; i < instance.authorizedUsers.Count; i++)
			{
				ulong val = instance.authorizedUsers[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
	}

	public static void Serialize(BufferStream stream, StaticRespawnAreaData instance)
	{
		if (instance.authorizedUsers != null)
		{
			for (int i = 0; i < instance.authorizedUsers.Count; i++)
			{
				ulong val = instance.authorizedUsers[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SteeringWheel : IDisposable, IPooled, IProto<SteeringWheel>, IProto
{
	[NonSerialized]
	public bool hasLock;

	[NonSerialized]
	public string lockCode;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SteeringWheel instance)
	{
		if (instance.ShouldPool)
		{
			instance.hasLock = false;
			instance.lockCode = string.Empty;
			Pool.Free<SteeringWheel>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SteeringWheel with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SteeringWheel instance)
	{
		instance.hasLock = hasLock;
		instance.lockCode = lockCode;
	}

	public SteeringWheel Copy()
	{
		SteeringWheel steeringWheel = Pool.Get<SteeringWheel>();
		CopyTo(steeringWheel);
		return steeringWheel;
	}

	public static SteeringWheel Deserialize(BufferStream stream)
	{
		SteeringWheel steeringWheel = Pool.Get<SteeringWheel>();
		Deserialize(stream, steeringWheel, isDelta: false);
		return steeringWheel;
	}

	public static SteeringWheel DeserializeLengthDelimited(BufferStream stream)
	{
		SteeringWheel steeringWheel = Pool.Get<SteeringWheel>();
		DeserializeLengthDelimited(stream, steeringWheel, isDelta: false);
		return steeringWheel;
	}

	public static SteeringWheel DeserializeLength(BufferStream stream, int length)
	{
		SteeringWheel steeringWheel = Pool.Get<SteeringWheel>();
		DeserializeLength(stream, length, steeringWheel, isDelta: false);
		return steeringWheel;
	}

	public static SteeringWheel Deserialize(byte[] buffer)
	{
		SteeringWheel steeringWheel = Pool.Get<SteeringWheel>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, steeringWheel, isDelta: false);
		return steeringWheel;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SteeringWheel previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SteeringWheel Deserialize(BufferStream stream, SteeringWheel instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.hasLock = ProtocolParser.ReadBool(stream);
				continue;
			case 18:
				instance.lockCode = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SteeringWheel DeserializeLengthDelimited(BufferStream stream, SteeringWheel instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.hasLock = ProtocolParser.ReadBool(stream);
				continue;
			case 18:
				instance.lockCode = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SteeringWheel DeserializeLength(BufferStream stream, int length, SteeringWheel instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.hasLock = ProtocolParser.ReadBool(stream);
				continue;
			case 18:
				instance.lockCode = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SteeringWheel instance, SteeringWheel previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.hasLock);
		if (instance.lockCode != null && instance.lockCode != previous.lockCode)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.lockCode);
		}
	}

	public static void Serialize(BufferStream stream, SteeringWheel instance)
	{
		if (instance.hasLock)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.hasLock);
		}
		if (instance.lockCode != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.lockCode);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class StorageAdaptor : IDisposable, IPooled, IProto<StorageAdaptor>, IProto
{
	[NonSerialized]
	public SortSettings sortingSettings;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(StorageAdaptor instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.sortingSettings != null)
			{
				instance.sortingSettings.ResetToPool();
				instance.sortingSettings = null;
			}
			Pool.Free<StorageAdaptor>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose StorageAdaptor with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(StorageAdaptor instance)
	{
		if (sortingSettings != null)
		{
			if (instance.sortingSettings == null)
			{
				instance.sortingSettings = sortingSettings.Copy();
			}
			else
			{
				sortingSettings.CopyTo(instance.sortingSettings);
			}
		}
		else
		{
			instance.sortingSettings = null;
		}
	}

	public StorageAdaptor Copy()
	{
		StorageAdaptor storageAdaptor = Pool.Get<StorageAdaptor>();
		CopyTo(storageAdaptor);
		return storageAdaptor;
	}

	public static StorageAdaptor Deserialize(BufferStream stream)
	{
		StorageAdaptor storageAdaptor = Pool.Get<StorageAdaptor>();
		Deserialize(stream, storageAdaptor, isDelta: false);
		return storageAdaptor;
	}

	public static StorageAdaptor DeserializeLengthDelimited(BufferStream stream)
	{
		StorageAdaptor storageAdaptor = Pool.Get<StorageAdaptor>();
		DeserializeLengthDelimited(stream, storageAdaptor, isDelta: false);
		return storageAdaptor;
	}

	public static StorageAdaptor DeserializeLength(BufferStream stream, int length)
	{
		StorageAdaptor storageAdaptor = Pool.Get<StorageAdaptor>();
		DeserializeLength(stream, length, storageAdaptor, isDelta: false);
		return storageAdaptor;
	}

	public static StorageAdaptor Deserialize(byte[] buffer)
	{
		StorageAdaptor storageAdaptor = Pool.Get<StorageAdaptor>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, storageAdaptor, isDelta: false);
		return storageAdaptor;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, StorageAdaptor previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static StorageAdaptor Deserialize(BufferStream stream, StorageAdaptor instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.sortingSettings == null)
				{
					instance.sortingSettings = SortSettings.DeserializeLengthDelimited(stream);
				}
				else
				{
					SortSettings.DeserializeLengthDelimited(stream, instance.sortingSettings, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static StorageAdaptor DeserializeLengthDelimited(BufferStream stream, StorageAdaptor instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.sortingSettings == null)
				{
					instance.sortingSettings = SortSettings.DeserializeLengthDelimited(stream);
				}
				else
				{
					SortSettings.DeserializeLengthDelimited(stream, instance.sortingSettings, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static StorageAdaptor DeserializeLength(BufferStream stream, int length, StorageAdaptor instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.sortingSettings == null)
				{
					instance.sortingSettings = SortSettings.DeserializeLengthDelimited(stream);
				}
				else
				{
					SortSettings.DeserializeLengthDelimited(stream, instance.sortingSettings, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, StorageAdaptor instance, StorageAdaptor previous)
	{
		if (instance.sortingSettings == null)
		{
			return;
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		SortSettings.SerializeDelta(stream, instance.sortingSettings, previous.sortingSettings);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, StorageAdaptor instance)
	{
		if (instance.sortingSettings == null)
		{
			return;
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		SortSettings.Serialize(stream, instance.sortingSettings);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		sortingSettings?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class StorageBox : IDisposable, IPooled, IProto<StorageBox>, IProto
{
	[NonSerialized]
	public ItemContainer contents;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(StorageBox instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.contents != null)
			{
				instance.contents.ResetToPool();
				instance.contents = null;
			}
			Pool.Free<StorageBox>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose StorageBox with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(StorageBox instance)
	{
		if (contents != null)
		{
			if (instance.contents == null)
			{
				instance.contents = contents.Copy();
			}
			else
			{
				contents.CopyTo(instance.contents);
			}
		}
		else
		{
			instance.contents = null;
		}
	}

	public StorageBox Copy()
	{
		StorageBox storageBox = Pool.Get<StorageBox>();
		CopyTo(storageBox);
		return storageBox;
	}

	public static StorageBox Deserialize(BufferStream stream)
	{
		StorageBox storageBox = Pool.Get<StorageBox>();
		Deserialize(stream, storageBox, isDelta: false);
		return storageBox;
	}

	public static StorageBox DeserializeLengthDelimited(BufferStream stream)
	{
		StorageBox storageBox = Pool.Get<StorageBox>();
		DeserializeLengthDelimited(stream, storageBox, isDelta: false);
		return storageBox;
	}

	public static StorageBox DeserializeLength(BufferStream stream, int length)
	{
		StorageBox storageBox = Pool.Get<StorageBox>();
		DeserializeLength(stream, length, storageBox, isDelta: false);
		return storageBox;
	}

	public static StorageBox Deserialize(byte[] buffer)
	{
		StorageBox storageBox = Pool.Get<StorageBox>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, storageBox, isDelta: false);
		return storageBox;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, StorageBox previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static StorageBox Deserialize(BufferStream stream, StorageBox instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.contents == null)
				{
					instance.contents = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.contents, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static StorageBox DeserializeLengthDelimited(BufferStream stream, StorageBox instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.contents == null)
				{
					instance.contents = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.contents, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static StorageBox DeserializeLength(BufferStream stream, int length, StorageBox instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.contents == null)
				{
					instance.contents = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.contents, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, StorageBox instance, StorageBox previous)
	{
		if (instance.contents == null)
		{
			return;
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ItemContainer.SerializeDelta(stream, instance.contents, previous.contents);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, StorageBox instance)
	{
		if (instance.contents == null)
		{
			return;
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ItemContainer.Serialize(stream, instance.contents);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		contents?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class SubEntityList : IDisposable, IPooled, IProto<SubEntityList>, IProto
{
	[NonSerialized]
	public List<NetworkableId> subEntityIds;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SubEntityList instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.subEntityIds != null)
			{
				List<NetworkableId> list = instance.subEntityIds;
				Pool.FreeUnmanaged<NetworkableId>(ref list);
				instance.subEntityIds = list;
			}
			Pool.Free<SubEntityList>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SubEntityList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SubEntityList instance)
	{
		if (subEntityIds != null)
		{
			instance.subEntityIds = Pool.Get<List<NetworkableId>>();
			for (int i = 0; i < subEntityIds.Count; i++)
			{
				NetworkableId item = subEntityIds[i];
				instance.subEntityIds.Add(item);
			}
		}
		else
		{
			instance.subEntityIds = null;
		}
	}

	public SubEntityList Copy()
	{
		SubEntityList subEntityList = Pool.Get<SubEntityList>();
		CopyTo(subEntityList);
		return subEntityList;
	}

	public static SubEntityList Deserialize(BufferStream stream)
	{
		SubEntityList subEntityList = Pool.Get<SubEntityList>();
		Deserialize(stream, subEntityList, isDelta: false);
		return subEntityList;
	}

	public static SubEntityList DeserializeLengthDelimited(BufferStream stream)
	{
		SubEntityList subEntityList = Pool.Get<SubEntityList>();
		DeserializeLengthDelimited(stream, subEntityList, isDelta: false);
		return subEntityList;
	}

	public static SubEntityList DeserializeLength(BufferStream stream, int length)
	{
		SubEntityList subEntityList = Pool.Get<SubEntityList>();
		DeserializeLength(stream, length, subEntityList, isDelta: false);
		return subEntityList;
	}

	public static SubEntityList Deserialize(byte[] buffer)
	{
		SubEntityList subEntityList = Pool.Get<SubEntityList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, subEntityList, isDelta: false);
		return subEntityList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SubEntityList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SubEntityList Deserialize(BufferStream stream, SubEntityList instance, bool isDelta)
	{
		if (!isDelta && instance.subEntityIds == null)
		{
			instance.subEntityIds = Pool.Get<List<NetworkableId>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.subEntityIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SubEntityList DeserializeLengthDelimited(BufferStream stream, SubEntityList instance, bool isDelta)
	{
		if (!isDelta && instance.subEntityIds == null)
		{
			instance.subEntityIds = Pool.Get<List<NetworkableId>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.subEntityIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SubEntityList DeserializeLength(BufferStream stream, int length, SubEntityList instance, bool isDelta)
	{
		if (!isDelta && instance.subEntityIds == null)
		{
			instance.subEntityIds = Pool.Get<List<NetworkableId>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.subEntityIds.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SubEntityList instance, SubEntityList previous)
	{
		if (instance.subEntityIds != null)
		{
			for (int i = 0; i < instance.subEntityIds.Count; i++)
			{
				NetworkableId networkableId = instance.subEntityIds[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
	}

	public static void Serialize(BufferStream stream, SubEntityList instance)
	{
		if (instance.subEntityIds != null)
		{
			for (int i = 0; i < instance.subEntityIds.Count; i++)
			{
				NetworkableId networkableId = instance.subEntityIds[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		for (int i = 0; i < subEntityIds.Count; i++)
		{
			NetworkableId value = subEntityIds[i];
			action(UidType.NetworkableId, ref value.Value);
			subEntityIds[i] = value;
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Submarine : IDisposable, IPooled, IProto<Submarine>, IProto
{
	[NonSerialized]
	public float throttle;

	[NonSerialized]
	public float upDown;

	[NonSerialized]
	public float rudder;

	[NonSerialized]
	public NetworkableId fuelStorageID;

	[NonSerialized]
	public float fuelAmount;

	[NonSerialized]
	public NetworkableId torpedoStorageID;

	[NonSerialized]
	public float oxygen;

	[NonSerialized]
	public NetworkableId itemStorageID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Submarine instance)
	{
		if (instance.ShouldPool)
		{
			instance.throttle = 0f;
			instance.upDown = 0f;
			instance.rudder = 0f;
			instance.fuelStorageID = default(NetworkableId);
			instance.fuelAmount = 0f;
			instance.torpedoStorageID = default(NetworkableId);
			instance.oxygen = 0f;
			instance.itemStorageID = default(NetworkableId);
			Pool.Free<Submarine>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Submarine with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Submarine instance)
	{
		instance.throttle = throttle;
		instance.upDown = upDown;
		instance.rudder = rudder;
		instance.fuelStorageID = fuelStorageID;
		instance.fuelAmount = fuelAmount;
		instance.torpedoStorageID = torpedoStorageID;
		instance.oxygen = oxygen;
		instance.itemStorageID = itemStorageID;
	}

	public Submarine Copy()
	{
		Submarine submarine = Pool.Get<Submarine>();
		CopyTo(submarine);
		return submarine;
	}

	public static Submarine Deserialize(BufferStream stream)
	{
		Submarine submarine = Pool.Get<Submarine>();
		Deserialize(stream, submarine, isDelta: false);
		return submarine;
	}

	public static Submarine DeserializeLengthDelimited(BufferStream stream)
	{
		Submarine submarine = Pool.Get<Submarine>();
		DeserializeLengthDelimited(stream, submarine, isDelta: false);
		return submarine;
	}

	public static Submarine DeserializeLength(BufferStream stream, int length)
	{
		Submarine submarine = Pool.Get<Submarine>();
		DeserializeLength(stream, length, submarine, isDelta: false);
		return submarine;
	}

	public static Submarine Deserialize(byte[] buffer)
	{
		Submarine submarine = Pool.Get<Submarine>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, submarine, isDelta: false);
		return submarine;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Submarine previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Submarine Deserialize(BufferStream stream, Submarine instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.throttle = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.upDown = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.rudder = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 45:
				instance.fuelAmount = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.torpedoStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 61:
				instance.oxygen = ProtocolParser.ReadSingle(stream);
				continue;
			case 64:
				instance.itemStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Submarine DeserializeLengthDelimited(BufferStream stream, Submarine instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.throttle = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.upDown = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.rudder = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 45:
				instance.fuelAmount = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.torpedoStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 61:
				instance.oxygen = ProtocolParser.ReadSingle(stream);
				continue;
			case 64:
				instance.itemStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Submarine DeserializeLength(BufferStream stream, int length, Submarine instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.throttle = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.upDown = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.rudder = ProtocolParser.ReadSingle(stream);
				continue;
			case 32:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 45:
				instance.fuelAmount = ProtocolParser.ReadSingle(stream);
				continue;
			case 48:
				instance.torpedoStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 61:
				instance.oxygen = ProtocolParser.ReadSingle(stream);
				continue;
			case 64:
				instance.itemStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Submarine instance, Submarine previous)
	{
		if (instance.throttle != previous.throttle)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.throttle);
		}
		if (instance.upDown != previous.upDown)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.upDown);
		}
		if (instance.rudder != previous.rudder)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.rudder);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		if (instance.fuelAmount != previous.fuelAmount)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.fuelAmount);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteUInt64(stream, instance.torpedoStorageID.Value);
		if (instance.oxygen != previous.oxygen)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.oxygen);
		}
		stream.WriteByte(64);
		ProtocolParser.WriteUInt64(stream, instance.itemStorageID.Value);
	}

	public static void Serialize(BufferStream stream, Submarine instance)
	{
		if (instance.throttle != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.throttle);
		}
		if (instance.upDown != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.upDown);
		}
		if (instance.rudder != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.rudder);
		}
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
		if (instance.fuelAmount != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.fuelAmount);
		}
		if (instance.torpedoStorageID != default(NetworkableId))
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.torpedoStorageID.Value);
		}
		if (instance.oxygen != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.oxygen);
		}
		if (instance.itemStorageID != default(NetworkableId))
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, instance.itemStorageID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref fuelStorageID.Value);
		action(UidType.NetworkableId, ref torpedoStorageID.Value);
		action(UidType.NetworkableId, ref itemStorageID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class TakeDamage : IDisposable, IPooled, IProto<TakeDamage>, IProto
{
	[NonSerialized]
	public float amount;

	[NonSerialized]
	public Vector3 direction;

	[NonSerialized]
	public int type;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TakeDamage instance)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.amount = 0f;
			instance.direction = default(Vector3);
			instance.type = 0;
			Pool.Free<TakeDamage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TakeDamage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TakeDamage instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.amount = amount;
		instance.direction = direction;
		instance.type = type;
	}

	public TakeDamage Copy()
	{
		TakeDamage takeDamage = Pool.Get<TakeDamage>();
		CopyTo(takeDamage);
		return takeDamage;
	}

	public static TakeDamage Deserialize(BufferStream stream)
	{
		TakeDamage takeDamage = Pool.Get<TakeDamage>();
		Deserialize(stream, takeDamage, isDelta: false);
		return takeDamage;
	}

	public static TakeDamage DeserializeLengthDelimited(BufferStream stream)
	{
		TakeDamage takeDamage = Pool.Get<TakeDamage>();
		DeserializeLengthDelimited(stream, takeDamage, isDelta: false);
		return takeDamage;
	}

	public static TakeDamage DeserializeLength(BufferStream stream, int length)
	{
		TakeDamage takeDamage = Pool.Get<TakeDamage>();
		DeserializeLength(stream, length, takeDamage, isDelta: false);
		return takeDamage;
	}

	public static TakeDamage Deserialize(byte[] buffer)
	{
		TakeDamage takeDamage = Pool.Get<TakeDamage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, takeDamage, isDelta: false);
		return takeDamage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TakeDamage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TakeDamage Deserialize(BufferStream stream, TakeDamage instance, bool isDelta)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.amount = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.direction, isDelta);
				continue;
			case 24:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TakeDamage DeserializeLengthDelimited(BufferStream stream, TakeDamage instance, bool isDelta)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.amount = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.direction, isDelta);
				continue;
			case 24:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TakeDamage DeserializeLength(BufferStream stream, int length, TakeDamage instance, bool isDelta)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.amount = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.direction, isDelta);
				continue;
			case 24:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TakeDamage instance, TakeDamage previous)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (instance.amount != previous.amount)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.amount);
		}
		if (instance.direction != previous.direction)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.direction, previous.direction);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field direction (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.type != previous.type)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
	}

	public static void Serialize(BufferStream stream, TakeDamage instance)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (instance.amount != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.amount);
		}
		if (instance.direction != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.direction);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field direction (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.type != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class TargetDetectedAIEventData : IDisposable, IPooled, IProto<TargetDetectedAIEventData>, IProto
{
	[NonSerialized]
	public float range;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TargetDetectedAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.range = 0f;
			Pool.Free<TargetDetectedAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TargetDetectedAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TargetDetectedAIEventData instance)
	{
		instance.range = range;
	}

	public TargetDetectedAIEventData Copy()
	{
		TargetDetectedAIEventData targetDetectedAIEventData = Pool.Get<TargetDetectedAIEventData>();
		CopyTo(targetDetectedAIEventData);
		return targetDetectedAIEventData;
	}

	public static TargetDetectedAIEventData Deserialize(BufferStream stream)
	{
		TargetDetectedAIEventData targetDetectedAIEventData = Pool.Get<TargetDetectedAIEventData>();
		Deserialize(stream, targetDetectedAIEventData, isDelta: false);
		return targetDetectedAIEventData;
	}

	public static TargetDetectedAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		TargetDetectedAIEventData targetDetectedAIEventData = Pool.Get<TargetDetectedAIEventData>();
		DeserializeLengthDelimited(stream, targetDetectedAIEventData, isDelta: false);
		return targetDetectedAIEventData;
	}

	public static TargetDetectedAIEventData DeserializeLength(BufferStream stream, int length)
	{
		TargetDetectedAIEventData targetDetectedAIEventData = Pool.Get<TargetDetectedAIEventData>();
		DeserializeLength(stream, length, targetDetectedAIEventData, isDelta: false);
		return targetDetectedAIEventData;
	}

	public static TargetDetectedAIEventData Deserialize(byte[] buffer)
	{
		TargetDetectedAIEventData targetDetectedAIEventData = Pool.Get<TargetDetectedAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, targetDetectedAIEventData, isDelta: false);
		return targetDetectedAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TargetDetectedAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TargetDetectedAIEventData Deserialize(BufferStream stream, TargetDetectedAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TargetDetectedAIEventData DeserializeLengthDelimited(BufferStream stream, TargetDetectedAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TargetDetectedAIEventData DeserializeLength(BufferStream stream, int length, TargetDetectedAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TargetDetectedAIEventData instance, TargetDetectedAIEventData previous)
	{
		if (instance.range != previous.range)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.range);
		}
	}

	public static void Serialize(BufferStream stream, TargetDetectedAIEventData instance)
	{
		if (instance.range != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.range);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Telephone : IDisposable, IPooled, IProto<Telephone>, IProto
{
	[NonSerialized]
	public int lastNumber;

	[NonSerialized]
	public int phoneNumber;

	[NonSerialized]
	public NetworkableId usingPlayer;

	[NonSerialized]
	public string phoneName;

	[NonSerialized]
	public PhoneDirectory savedNumbers;

	[NonSerialized]
	public List<VoicemailEntry> voicemail;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Telephone instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.lastNumber = 0;
		instance.phoneNumber = 0;
		instance.usingPlayer = default(NetworkableId);
		instance.phoneName = string.Empty;
		if (instance.savedNumbers != null)
		{
			instance.savedNumbers.ResetToPool();
			instance.savedNumbers = null;
		}
		if (instance.voicemail != null)
		{
			for (int i = 0; i < instance.voicemail.Count; i++)
			{
				if (instance.voicemail[i] != null)
				{
					instance.voicemail[i].ResetToPool();
					instance.voicemail[i] = null;
				}
			}
			List<VoicemailEntry> list = instance.voicemail;
			Pool.Free<VoicemailEntry>(ref list, false);
			instance.voicemail = list;
		}
		Pool.Free<Telephone>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Telephone with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Telephone instance)
	{
		instance.lastNumber = lastNumber;
		instance.phoneNumber = phoneNumber;
		instance.usingPlayer = usingPlayer;
		instance.phoneName = phoneName;
		if (savedNumbers != null)
		{
			if (instance.savedNumbers == null)
			{
				instance.savedNumbers = savedNumbers.Copy();
			}
			else
			{
				savedNumbers.CopyTo(instance.savedNumbers);
			}
		}
		else
		{
			instance.savedNumbers = null;
		}
		if (voicemail != null)
		{
			instance.voicemail = Pool.Get<List<VoicemailEntry>>();
			for (int i = 0; i < voicemail.Count; i++)
			{
				VoicemailEntry item = voicemail[i].Copy();
				instance.voicemail.Add(item);
			}
		}
		else
		{
			instance.voicemail = null;
		}
	}

	public Telephone Copy()
	{
		Telephone telephone = Pool.Get<Telephone>();
		CopyTo(telephone);
		return telephone;
	}

	public static Telephone Deserialize(BufferStream stream)
	{
		Telephone telephone = Pool.Get<Telephone>();
		Deserialize(stream, telephone, isDelta: false);
		return telephone;
	}

	public static Telephone DeserializeLengthDelimited(BufferStream stream)
	{
		Telephone telephone = Pool.Get<Telephone>();
		DeserializeLengthDelimited(stream, telephone, isDelta: false);
		return telephone;
	}

	public static Telephone DeserializeLength(BufferStream stream, int length)
	{
		Telephone telephone = Pool.Get<Telephone>();
		DeserializeLength(stream, length, telephone, isDelta: false);
		return telephone;
	}

	public static Telephone Deserialize(byte[] buffer)
	{
		Telephone telephone = Pool.Get<Telephone>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, telephone, isDelta: false);
		return telephone;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Telephone previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Telephone Deserialize(BufferStream stream, Telephone instance, bool isDelta)
	{
		if (!isDelta && instance.voicemail == null)
		{
			instance.voicemail = Pool.Get<List<VoicemailEntry>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.lastNumber = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 16:
				instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.usingPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 42:
				instance.phoneName = ProtocolParser.ReadString(stream);
				break;
			case 50:
				if (instance.savedNumbers == null)
				{
					instance.savedNumbers = PhoneDirectory.DeserializeLengthDelimited(stream);
				}
				else
				{
					PhoneDirectory.DeserializeLengthDelimited(stream, instance.savedNumbers, isDelta);
				}
				break;
			case 58:
				instance.voicemail.Add(VoicemailEntry.DeserializeLengthDelimited(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static Telephone DeserializeLengthDelimited(BufferStream stream, Telephone instance, bool isDelta)
	{
		if (!isDelta && instance.voicemail == null)
		{
			instance.voicemail = Pool.Get<List<VoicemailEntry>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.lastNumber = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 16:
				instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.usingPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 42:
				instance.phoneName = ProtocolParser.ReadString(stream);
				break;
			case 50:
				if (instance.savedNumbers == null)
				{
					instance.savedNumbers = PhoneDirectory.DeserializeLengthDelimited(stream);
				}
				else
				{
					PhoneDirectory.DeserializeLengthDelimited(stream, instance.savedNumbers, isDelta);
				}
				break;
			case 58:
				instance.voicemail.Add(VoicemailEntry.DeserializeLengthDelimited(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Telephone DeserializeLength(BufferStream stream, int length, Telephone instance, bool isDelta)
	{
		if (!isDelta && instance.voicemail == null)
		{
			instance.voicemail = Pool.Get<List<VoicemailEntry>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.lastNumber = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 16:
				instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.usingPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 42:
				instance.phoneName = ProtocolParser.ReadString(stream);
				break;
			case 50:
				if (instance.savedNumbers == null)
				{
					instance.savedNumbers = PhoneDirectory.DeserializeLengthDelimited(stream);
				}
				else
				{
					PhoneDirectory.DeserializeLengthDelimited(stream, instance.savedNumbers, isDelta);
				}
				break;
			case 58:
				instance.voicemail.Add(VoicemailEntry.DeserializeLengthDelimited(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Telephone instance, Telephone previous)
	{
		if (instance.lastNumber != previous.lastNumber)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastNumber);
		}
		if (instance.phoneNumber != previous.phoneNumber)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.phoneNumber);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.usingPlayer.Value);
		if (instance.phoneName != null && instance.phoneName != previous.phoneName)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.phoneName);
		}
		if (instance.savedNumbers != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PhoneDirectory.SerializeDelta(stream, instance.savedNumbers, previous.savedNumbers);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.voicemail == null)
		{
			return;
		}
		for (int i = 0; i < instance.voicemail.Count; i++)
		{
			VoicemailEntry voicemailEntry = instance.voicemail[i];
			stream.WriteByte(58);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			VoicemailEntry.SerializeDelta(stream, voicemailEntry, voicemailEntry);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, Telephone instance)
	{
		if (instance.lastNumber != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastNumber);
		}
		if (instance.phoneNumber != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.phoneNumber);
		}
		if (instance.usingPlayer != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.usingPlayer.Value);
		}
		if (instance.phoneName != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.phoneName);
		}
		if (instance.savedNumbers != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PhoneDirectory.Serialize(stream, instance.savedNumbers);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.voicemail == null)
		{
			return;
		}
		for (int i = 0; i < instance.voicemail.Count; i++)
		{
			VoicemailEntry instance2 = instance.voicemail[i];
			stream.WriteByte(58);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			VoicemailEntry.Serialize(stream, instance2);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref usingPlayer.Value);
		savedNumbers?.InspectUids(action);
		if (voicemail != null)
		{
			for (int i = 0; i < voicemail.Count; i++)
			{
				voicemail[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class TemporaryRagdoll : IDisposable, IPooled, IProto<TemporaryRagdoll>, IProto
{
	[NonSerialized]
	public NetworkableId parentID;

	[NonSerialized]
	public int mountPose;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TemporaryRagdoll instance)
	{
		if (instance.ShouldPool)
		{
			instance.parentID = default(NetworkableId);
			instance.mountPose = 0;
			Pool.Free<TemporaryRagdoll>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TemporaryRagdoll with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TemporaryRagdoll instance)
	{
		instance.parentID = parentID;
		instance.mountPose = mountPose;
	}

	public TemporaryRagdoll Copy()
	{
		TemporaryRagdoll temporaryRagdoll = Pool.Get<TemporaryRagdoll>();
		CopyTo(temporaryRagdoll);
		return temporaryRagdoll;
	}

	public static TemporaryRagdoll Deserialize(BufferStream stream)
	{
		TemporaryRagdoll temporaryRagdoll = Pool.Get<TemporaryRagdoll>();
		Deserialize(stream, temporaryRagdoll, isDelta: false);
		return temporaryRagdoll;
	}

	public static TemporaryRagdoll DeserializeLengthDelimited(BufferStream stream)
	{
		TemporaryRagdoll temporaryRagdoll = Pool.Get<TemporaryRagdoll>();
		DeserializeLengthDelimited(stream, temporaryRagdoll, isDelta: false);
		return temporaryRagdoll;
	}

	public static TemporaryRagdoll DeserializeLength(BufferStream stream, int length)
	{
		TemporaryRagdoll temporaryRagdoll = Pool.Get<TemporaryRagdoll>();
		DeserializeLength(stream, length, temporaryRagdoll, isDelta: false);
		return temporaryRagdoll;
	}

	public static TemporaryRagdoll Deserialize(byte[] buffer)
	{
		TemporaryRagdoll temporaryRagdoll = Pool.Get<TemporaryRagdoll>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, temporaryRagdoll, isDelta: false);
		return temporaryRagdoll;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TemporaryRagdoll previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TemporaryRagdoll Deserialize(BufferStream stream, TemporaryRagdoll instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.parentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.mountPose = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TemporaryRagdoll DeserializeLengthDelimited(BufferStream stream, TemporaryRagdoll instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.parentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.mountPose = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TemporaryRagdoll DeserializeLength(BufferStream stream, int length, TemporaryRagdoll instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.parentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.mountPose = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TemporaryRagdoll instance, TemporaryRagdoll previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.parentID.Value);
		if (instance.mountPose != previous.mountPose)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.mountPose);
		}
	}

	public static void Serialize(BufferStream stream, TemporaryRagdoll instance)
	{
		if (instance.parentID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.parentID.Value);
		}
		if (instance.mountPose != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.mountPose);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref parentID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ThreatDetectedAIEventData : IDisposable, IPooled, IProto<ThreatDetectedAIEventData>, IProto
{
	[NonSerialized]
	public float range;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ThreatDetectedAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.range = 0f;
			Pool.Free<ThreatDetectedAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ThreatDetectedAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ThreatDetectedAIEventData instance)
	{
		instance.range = range;
	}

	public ThreatDetectedAIEventData Copy()
	{
		ThreatDetectedAIEventData threatDetectedAIEventData = Pool.Get<ThreatDetectedAIEventData>();
		CopyTo(threatDetectedAIEventData);
		return threatDetectedAIEventData;
	}

	public static ThreatDetectedAIEventData Deserialize(BufferStream stream)
	{
		ThreatDetectedAIEventData threatDetectedAIEventData = Pool.Get<ThreatDetectedAIEventData>();
		Deserialize(stream, threatDetectedAIEventData, isDelta: false);
		return threatDetectedAIEventData;
	}

	public static ThreatDetectedAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		ThreatDetectedAIEventData threatDetectedAIEventData = Pool.Get<ThreatDetectedAIEventData>();
		DeserializeLengthDelimited(stream, threatDetectedAIEventData, isDelta: false);
		return threatDetectedAIEventData;
	}

	public static ThreatDetectedAIEventData DeserializeLength(BufferStream stream, int length)
	{
		ThreatDetectedAIEventData threatDetectedAIEventData = Pool.Get<ThreatDetectedAIEventData>();
		DeserializeLength(stream, length, threatDetectedAIEventData, isDelta: false);
		return threatDetectedAIEventData;
	}

	public static ThreatDetectedAIEventData Deserialize(byte[] buffer)
	{
		ThreatDetectedAIEventData threatDetectedAIEventData = Pool.Get<ThreatDetectedAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, threatDetectedAIEventData, isDelta: false);
		return threatDetectedAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ThreatDetectedAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ThreatDetectedAIEventData Deserialize(BufferStream stream, ThreatDetectedAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ThreatDetectedAIEventData DeserializeLengthDelimited(BufferStream stream, ThreatDetectedAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ThreatDetectedAIEventData DeserializeLength(BufferStream stream, int length, ThreatDetectedAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ThreatDetectedAIEventData instance, ThreatDetectedAIEventData previous)
	{
		if (instance.range != previous.range)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.range);
		}
	}

	public static void Serialize(BufferStream stream, ThreatDetectedAIEventData instance)
	{
		if (instance.range != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.range);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class TimedExplosive : IDisposable, IPooled, IProto<TimedExplosive>, IProto
{
	[NonSerialized]
	public NetworkableId parentid;

	[NonSerialized]
	public Vector3 pos;

	[NonSerialized]
	public Vector3 normal;

	[NonSerialized]
	public bool rfOn;

	[NonSerialized]
	public int freq;

	[NonSerialized]
	public ulong creatorID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TimedExplosive instance)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.parentid = default(NetworkableId);
			instance.pos = default(Vector3);
			instance.normal = default(Vector3);
			instance.rfOn = false;
			instance.freq = 0;
			instance.creatorID = 0uL;
			Pool.Free<TimedExplosive>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TimedExplosive with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TimedExplosive instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		instance.parentid = parentid;
		instance.pos = pos;
		instance.normal = normal;
		instance.rfOn = rfOn;
		instance.freq = freq;
		instance.creatorID = creatorID;
	}

	public TimedExplosive Copy()
	{
		TimedExplosive timedExplosive = Pool.Get<TimedExplosive>();
		CopyTo(timedExplosive);
		return timedExplosive;
	}

	public static TimedExplosive Deserialize(BufferStream stream)
	{
		TimedExplosive timedExplosive = Pool.Get<TimedExplosive>();
		Deserialize(stream, timedExplosive, isDelta: false);
		return timedExplosive;
	}

	public static TimedExplosive DeserializeLengthDelimited(BufferStream stream)
	{
		TimedExplosive timedExplosive = Pool.Get<TimedExplosive>();
		DeserializeLengthDelimited(stream, timedExplosive, isDelta: false);
		return timedExplosive;
	}

	public static TimedExplosive DeserializeLength(BufferStream stream, int length)
	{
		TimedExplosive timedExplosive = Pool.Get<TimedExplosive>();
		DeserializeLength(stream, length, timedExplosive, isDelta: false);
		return timedExplosive;
	}

	public static TimedExplosive Deserialize(byte[] buffer)
	{
		TimedExplosive timedExplosive = Pool.Get<TimedExplosive>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, timedExplosive, isDelta: false);
		return timedExplosive;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TimedExplosive previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TimedExplosive Deserialize(BufferStream stream, TimedExplosive instance, bool isDelta)
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.parentid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pos, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 32:
				instance.rfOn = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.freq = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.creatorID = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TimedExplosive DeserializeLengthDelimited(BufferStream stream, TimedExplosive instance, bool isDelta)
	{
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.parentid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pos, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 32:
				instance.rfOn = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.freq = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.creatorID = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TimedExplosive DeserializeLength(BufferStream stream, int length, TimedExplosive instance, bool isDelta)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.parentid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pos, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 32:
				instance.rfOn = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.freq = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.creatorID = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TimedExplosive instance, TimedExplosive previous)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.parentid.Value);
		if (instance.pos != previous.pos)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.pos, previous.pos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field pos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.normal != previous.normal)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.normal, previous.normal);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field normal (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.rfOn);
		if (instance.freq != previous.freq)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.freq);
		}
		if (instance.creatorID != previous.creatorID)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.creatorID);
		}
	}

	public static void Serialize(BufferStream stream, TimedExplosive instance)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		if (instance.parentid != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.parentid.Value);
		}
		if (instance.pos != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.pos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field pos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.normal != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.normal);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field normal (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.rfOn)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.rfOn);
		}
		if (instance.freq != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.freq);
		}
		if (instance.creatorID != 0L)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.creatorID);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref parentid.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class TimerAIEventData : IDisposable, IPooled, IProto<TimerAIEventData>, IProto
{
	[NonSerialized]
	public float duration;

	[NonSerialized]
	public float durationMax;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TimerAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.duration = 0f;
			instance.durationMax = 0f;
			Pool.Free<TimerAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TimerAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TimerAIEventData instance)
	{
		instance.duration = duration;
		instance.durationMax = durationMax;
	}

	public TimerAIEventData Copy()
	{
		TimerAIEventData timerAIEventData = Pool.Get<TimerAIEventData>();
		CopyTo(timerAIEventData);
		return timerAIEventData;
	}

	public static TimerAIEventData Deserialize(BufferStream stream)
	{
		TimerAIEventData timerAIEventData = Pool.Get<TimerAIEventData>();
		Deserialize(stream, timerAIEventData, isDelta: false);
		return timerAIEventData;
	}

	public static TimerAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		TimerAIEventData timerAIEventData = Pool.Get<TimerAIEventData>();
		DeserializeLengthDelimited(stream, timerAIEventData, isDelta: false);
		return timerAIEventData;
	}

	public static TimerAIEventData DeserializeLength(BufferStream stream, int length)
	{
		TimerAIEventData timerAIEventData = Pool.Get<TimerAIEventData>();
		DeserializeLength(stream, length, timerAIEventData, isDelta: false);
		return timerAIEventData;
	}

	public static TimerAIEventData Deserialize(byte[] buffer)
	{
		TimerAIEventData timerAIEventData = Pool.Get<TimerAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, timerAIEventData, isDelta: false);
		return timerAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TimerAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TimerAIEventData Deserialize(BufferStream stream, TimerAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.duration = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.durationMax = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TimerAIEventData DeserializeLengthDelimited(BufferStream stream, TimerAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.duration = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.durationMax = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TimerAIEventData DeserializeLength(BufferStream stream, int length, TimerAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.duration = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.durationMax = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TimerAIEventData instance, TimerAIEventData previous)
	{
		if (instance.duration != previous.duration)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.duration);
		}
		if (instance.durationMax != previous.durationMax)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.durationMax);
		}
	}

	public static void Serialize(BufferStream stream, TimerAIEventData instance)
	{
		if (instance.duration != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.duration);
		}
		if (instance.durationMax != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.durationMax);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class TimeSinceThreatAIEventData : IDisposable, IPooled, IProto<TimeSinceThreatAIEventData>, IProto
{
	[NonSerialized]
	public float value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TimeSinceThreatAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.value = 0f;
			Pool.Free<TimeSinceThreatAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TimeSinceThreatAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TimeSinceThreatAIEventData instance)
	{
		instance.value = value;
	}

	public TimeSinceThreatAIEventData Copy()
	{
		TimeSinceThreatAIEventData timeSinceThreatAIEventData = Pool.Get<TimeSinceThreatAIEventData>();
		CopyTo(timeSinceThreatAIEventData);
		return timeSinceThreatAIEventData;
	}

	public static TimeSinceThreatAIEventData Deserialize(BufferStream stream)
	{
		TimeSinceThreatAIEventData timeSinceThreatAIEventData = Pool.Get<TimeSinceThreatAIEventData>();
		Deserialize(stream, timeSinceThreatAIEventData, isDelta: false);
		return timeSinceThreatAIEventData;
	}

	public static TimeSinceThreatAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		TimeSinceThreatAIEventData timeSinceThreatAIEventData = Pool.Get<TimeSinceThreatAIEventData>();
		DeserializeLengthDelimited(stream, timeSinceThreatAIEventData, isDelta: false);
		return timeSinceThreatAIEventData;
	}

	public static TimeSinceThreatAIEventData DeserializeLength(BufferStream stream, int length)
	{
		TimeSinceThreatAIEventData timeSinceThreatAIEventData = Pool.Get<TimeSinceThreatAIEventData>();
		DeserializeLength(stream, length, timeSinceThreatAIEventData, isDelta: false);
		return timeSinceThreatAIEventData;
	}

	public static TimeSinceThreatAIEventData Deserialize(byte[] buffer)
	{
		TimeSinceThreatAIEventData timeSinceThreatAIEventData = Pool.Get<TimeSinceThreatAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, timeSinceThreatAIEventData, isDelta: false);
		return timeSinceThreatAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TimeSinceThreatAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TimeSinceThreatAIEventData Deserialize(BufferStream stream, TimeSinceThreatAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TimeSinceThreatAIEventData DeserializeLengthDelimited(BufferStream stream, TimeSinceThreatAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TimeSinceThreatAIEventData DeserializeLength(BufferStream stream, int length, TimeSinceThreatAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TimeSinceThreatAIEventData instance, TimeSinceThreatAIEventData previous)
	{
		if (instance.value != previous.value)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public static void Serialize(BufferStream stream, TimeSinceThreatAIEventData instance)
	{
		if (instance.value != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class TinCanAlarm : IDisposable, IPooled, IProto<TinCanAlarm>, IProto
{
	[NonSerialized]
	public Vector3 endPoint;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TinCanAlarm instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.endPoint = default(Vector3);
			Pool.Free<TinCanAlarm>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TinCanAlarm with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TinCanAlarm instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		instance.endPoint = endPoint;
	}

	public TinCanAlarm Copy()
	{
		TinCanAlarm tinCanAlarm = Pool.Get<TinCanAlarm>();
		CopyTo(tinCanAlarm);
		return tinCanAlarm;
	}

	public static TinCanAlarm Deserialize(BufferStream stream)
	{
		TinCanAlarm tinCanAlarm = Pool.Get<TinCanAlarm>();
		Deserialize(stream, tinCanAlarm, isDelta: false);
		return tinCanAlarm;
	}

	public static TinCanAlarm DeserializeLengthDelimited(BufferStream stream)
	{
		TinCanAlarm tinCanAlarm = Pool.Get<TinCanAlarm>();
		DeserializeLengthDelimited(stream, tinCanAlarm, isDelta: false);
		return tinCanAlarm;
	}

	public static TinCanAlarm DeserializeLength(BufferStream stream, int length)
	{
		TinCanAlarm tinCanAlarm = Pool.Get<TinCanAlarm>();
		DeserializeLength(stream, length, tinCanAlarm, isDelta: false);
		return tinCanAlarm;
	}

	public static TinCanAlarm Deserialize(byte[] buffer)
	{
		TinCanAlarm tinCanAlarm = Pool.Get<TinCanAlarm>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, tinCanAlarm, isDelta: false);
		return tinCanAlarm;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TinCanAlarm previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TinCanAlarm Deserialize(BufferStream stream, TinCanAlarm instance, bool isDelta)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.endPoint, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TinCanAlarm DeserializeLengthDelimited(BufferStream stream, TinCanAlarm instance, bool isDelta)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.endPoint, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TinCanAlarm DeserializeLength(BufferStream stream, int length, TinCanAlarm instance, bool isDelta)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.endPoint, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TinCanAlarm instance, TinCanAlarm previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.endPoint != previous.endPoint)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.endPoint, previous.endPoint);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field endPoint (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, TinCanAlarm instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.endPoint != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.endPoint);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field endPoint (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class TirednessAboveAIEventData : IDisposable, IPooled, IProto<TirednessAboveAIEventData>, IProto
{
	[NonSerialized]
	public float value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TirednessAboveAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.value = 0f;
			Pool.Free<TirednessAboveAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TirednessAboveAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TirednessAboveAIEventData instance)
	{
		instance.value = value;
	}

	public TirednessAboveAIEventData Copy()
	{
		TirednessAboveAIEventData tirednessAboveAIEventData = Pool.Get<TirednessAboveAIEventData>();
		CopyTo(tirednessAboveAIEventData);
		return tirednessAboveAIEventData;
	}

	public static TirednessAboveAIEventData Deserialize(BufferStream stream)
	{
		TirednessAboveAIEventData tirednessAboveAIEventData = Pool.Get<TirednessAboveAIEventData>();
		Deserialize(stream, tirednessAboveAIEventData, isDelta: false);
		return tirednessAboveAIEventData;
	}

	public static TirednessAboveAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		TirednessAboveAIEventData tirednessAboveAIEventData = Pool.Get<TirednessAboveAIEventData>();
		DeserializeLengthDelimited(stream, tirednessAboveAIEventData, isDelta: false);
		return tirednessAboveAIEventData;
	}

	public static TirednessAboveAIEventData DeserializeLength(BufferStream stream, int length)
	{
		TirednessAboveAIEventData tirednessAboveAIEventData = Pool.Get<TirednessAboveAIEventData>();
		DeserializeLength(stream, length, tirednessAboveAIEventData, isDelta: false);
		return tirednessAboveAIEventData;
	}

	public static TirednessAboveAIEventData Deserialize(byte[] buffer)
	{
		TirednessAboveAIEventData tirednessAboveAIEventData = Pool.Get<TirednessAboveAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, tirednessAboveAIEventData, isDelta: false);
		return tirednessAboveAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TirednessAboveAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TirednessAboveAIEventData Deserialize(BufferStream stream, TirednessAboveAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TirednessAboveAIEventData DeserializeLengthDelimited(BufferStream stream, TirednessAboveAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TirednessAboveAIEventData DeserializeLength(BufferStream stream, int length, TirednessAboveAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TirednessAboveAIEventData instance, TirednessAboveAIEventData previous)
	{
		if (instance.value != previous.value)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public static void Serialize(BufferStream stream, TirednessAboveAIEventData instance)
	{
		if (instance.value != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class TrainEngine : IDisposable, IPooled, IProto<TrainEngine>, IProto
{
	[NonSerialized]
	public int throttleSetting;

	[NonSerialized]
	public NetworkableId fuelStorageID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TrainEngine instance)
	{
		if (instance.ShouldPool)
		{
			instance.throttleSetting = 0;
			instance.fuelStorageID = default(NetworkableId);
			Pool.Free<TrainEngine>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TrainEngine with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TrainEngine instance)
	{
		instance.throttleSetting = throttleSetting;
		instance.fuelStorageID = fuelStorageID;
	}

	public TrainEngine Copy()
	{
		TrainEngine trainEngine = Pool.Get<TrainEngine>();
		CopyTo(trainEngine);
		return trainEngine;
	}

	public static TrainEngine Deserialize(BufferStream stream)
	{
		TrainEngine trainEngine = Pool.Get<TrainEngine>();
		Deserialize(stream, trainEngine, isDelta: false);
		return trainEngine;
	}

	public static TrainEngine DeserializeLengthDelimited(BufferStream stream)
	{
		TrainEngine trainEngine = Pool.Get<TrainEngine>();
		DeserializeLengthDelimited(stream, trainEngine, isDelta: false);
		return trainEngine;
	}

	public static TrainEngine DeserializeLength(BufferStream stream, int length)
	{
		TrainEngine trainEngine = Pool.Get<TrainEngine>();
		DeserializeLength(stream, length, trainEngine, isDelta: false);
		return trainEngine;
	}

	public static TrainEngine Deserialize(byte[] buffer)
	{
		TrainEngine trainEngine = Pool.Get<TrainEngine>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, trainEngine, isDelta: false);
		return trainEngine;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TrainEngine previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TrainEngine Deserialize(BufferStream stream, TrainEngine instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.throttleSetting = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TrainEngine DeserializeLengthDelimited(BufferStream stream, TrainEngine instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.throttleSetting = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TrainEngine DeserializeLength(BufferStream stream, int length, TrainEngine instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.throttleSetting = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.fuelStorageID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TrainEngine instance, TrainEngine previous)
	{
		if (instance.throttleSetting != previous.throttleSetting)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.throttleSetting);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
	}

	public static void Serialize(BufferStream stream, TrainEngine instance)
	{
		if (instance.throttleSetting != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.throttleSetting);
		}
		if (instance.fuelStorageID != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.fuelStorageID.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref fuelStorageID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class TravellingVendor : IDisposable, IPooled, IProto<TravellingVendor>, IProto
{
	[NonSerialized]
	public float steeringAngle;

	[NonSerialized]
	public Vector3 velocity;

	[NonSerialized]
	public int wheelFlags;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TravellingVendor instance)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.steeringAngle = 0f;
			instance.velocity = default(Vector3);
			instance.wheelFlags = 0;
			Pool.Free<TravellingVendor>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TravellingVendor with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TravellingVendor instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.steeringAngle = steeringAngle;
		instance.velocity = velocity;
		instance.wheelFlags = wheelFlags;
	}

	public TravellingVendor Copy()
	{
		TravellingVendor travellingVendor = Pool.Get<TravellingVendor>();
		CopyTo(travellingVendor);
		return travellingVendor;
	}

	public static TravellingVendor Deserialize(BufferStream stream)
	{
		TravellingVendor travellingVendor = Pool.Get<TravellingVendor>();
		Deserialize(stream, travellingVendor, isDelta: false);
		return travellingVendor;
	}

	public static TravellingVendor DeserializeLengthDelimited(BufferStream stream)
	{
		TravellingVendor travellingVendor = Pool.Get<TravellingVendor>();
		DeserializeLengthDelimited(stream, travellingVendor, isDelta: false);
		return travellingVendor;
	}

	public static TravellingVendor DeserializeLength(BufferStream stream, int length)
	{
		TravellingVendor travellingVendor = Pool.Get<TravellingVendor>();
		DeserializeLength(stream, length, travellingVendor, isDelta: false);
		return travellingVendor;
	}

	public static TravellingVendor Deserialize(byte[] buffer)
	{
		TravellingVendor travellingVendor = Pool.Get<TravellingVendor>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, travellingVendor, isDelta: false);
		return travellingVendor;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TravellingVendor previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TravellingVendor Deserialize(BufferStream stream, TravellingVendor instance, bool isDelta)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.steeringAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.velocity, isDelta);
				continue;
			case 24:
				instance.wheelFlags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TravellingVendor DeserializeLengthDelimited(BufferStream stream, TravellingVendor instance, bool isDelta)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.steeringAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.velocity, isDelta);
				continue;
			case 24:
				instance.wheelFlags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TravellingVendor DeserializeLength(BufferStream stream, int length, TravellingVendor instance, bool isDelta)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.steeringAngle = ProtocolParser.ReadSingle(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.velocity, isDelta);
				continue;
			case 24:
				instance.wheelFlags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TravellingVendor instance, TravellingVendor previous)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (instance.steeringAngle != previous.steeringAngle)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.steeringAngle);
		}
		if (instance.velocity != previous.velocity)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.velocity, previous.velocity);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field velocity (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.wheelFlags != previous.wheelFlags)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.wheelFlags);
		}
	}

	public static void Serialize(BufferStream stream, TravellingVendor instance)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (instance.steeringAngle != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.steeringAngle);
		}
		if (instance.velocity != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.velocity);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field velocity (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.wheelFlags != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.wheelFlags);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Tree : IDisposable, IPooled, IProto<Tree>, IProto
{
	[NonSerialized]
	public NetworkableId netId;

	[NonSerialized]
	public uint prefabId;

	[NonSerialized]
	public Half3 position;

	[NonSerialized]
	public float scale;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Tree instance)
	{
		if (instance.ShouldPool)
		{
			instance.netId = default(NetworkableId);
			instance.prefabId = 0u;
			instance.position = default(Half3);
			instance.scale = 0f;
			Pool.Free<Tree>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Tree with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Tree instance)
	{
		instance.netId = netId;
		instance.prefabId = prefabId;
		instance.position = position;
		instance.scale = scale;
	}

	public Tree Copy()
	{
		Tree tree = Pool.Get<Tree>();
		CopyTo(tree);
		return tree;
	}

	public static Tree Deserialize(BufferStream stream)
	{
		Tree tree = Pool.Get<Tree>();
		Deserialize(stream, tree, isDelta: false);
		return tree;
	}

	public static Tree DeserializeLengthDelimited(BufferStream stream)
	{
		Tree tree = Pool.Get<Tree>();
		DeserializeLengthDelimited(stream, tree, isDelta: false);
		return tree;
	}

	public static Tree DeserializeLength(BufferStream stream, int length)
	{
		Tree tree = Pool.Get<Tree>();
		DeserializeLength(stream, length, tree, isDelta: false);
		return tree;
	}

	public static Tree Deserialize(byte[] buffer)
	{
		Tree tree = Pool.Get<Tree>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, tree, isDelta: false);
		return tree;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Tree previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Tree Deserialize(BufferStream stream, Tree instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.netId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.prefabId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 26:
				Half3.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 37:
				instance.scale = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Tree DeserializeLengthDelimited(BufferStream stream, Tree instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.netId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.prefabId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 26:
				Half3.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 37:
				instance.scale = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Tree DeserializeLength(BufferStream stream, int length, Tree instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.netId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.prefabId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 26:
				Half3.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 37:
				instance.scale = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Tree instance, Tree previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.netId.Value);
		if (instance.prefabId != previous.prefabId)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.prefabId);
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range = stream.GetRange(1);
		int num = stream.Position;
		Half3.SerializeDelta(stream, instance.position, previous.position);
		int num2 = stream.Position - num;
		if (num2 > 127)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (ProtoBuf.Half3)");
		}
		Span<byte> span = range.GetSpan();
		ProtocolParser.WriteUInt32((uint)num2, span, 0);
		if (instance.scale != previous.scale)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.scale);
		}
	}

	public static void Serialize(BufferStream stream, Tree instance)
	{
		if (instance.netId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.netId.Value);
		}
		if (instance.prefabId != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.prefabId);
		}
		if (instance.position != default(Half3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Half3.Serialize(stream, instance.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (ProtoBuf.Half3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.scale != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.scale);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref netId.Value);
		position.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class TreeList : IDisposable, IPooled, IProto<TreeList>, IProto
{
	[NonSerialized]
	public List<Tree> trees;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TreeList instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.trees != null)
		{
			for (int i = 0; i < instance.trees.Count; i++)
			{
				if (instance.trees[i] != null)
				{
					instance.trees[i].ResetToPool();
					instance.trees[i] = null;
				}
			}
			List<Tree> list = instance.trees;
			Pool.Free<Tree>(ref list, false);
			instance.trees = list;
		}
		Pool.Free<TreeList>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TreeList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TreeList instance)
	{
		if (trees != null)
		{
			instance.trees = Pool.Get<List<Tree>>();
			for (int i = 0; i < trees.Count; i++)
			{
				Tree item = trees[i].Copy();
				instance.trees.Add(item);
			}
		}
		else
		{
			instance.trees = null;
		}
	}

	public TreeList Copy()
	{
		TreeList treeList = Pool.Get<TreeList>();
		CopyTo(treeList);
		return treeList;
	}

	public static TreeList Deserialize(BufferStream stream)
	{
		TreeList treeList = Pool.Get<TreeList>();
		Deserialize(stream, treeList, isDelta: false);
		return treeList;
	}

	public static TreeList DeserializeLengthDelimited(BufferStream stream)
	{
		TreeList treeList = Pool.Get<TreeList>();
		DeserializeLengthDelimited(stream, treeList, isDelta: false);
		return treeList;
	}

	public static TreeList DeserializeLength(BufferStream stream, int length)
	{
		TreeList treeList = Pool.Get<TreeList>();
		DeserializeLength(stream, length, treeList, isDelta: false);
		return treeList;
	}

	public static TreeList Deserialize(byte[] buffer)
	{
		TreeList treeList = Pool.Get<TreeList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, treeList, isDelta: false);
		return treeList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TreeList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TreeList Deserialize(BufferStream stream, TreeList instance, bool isDelta)
	{
		if (!isDelta && instance.trees == null)
		{
			instance.trees = Pool.Get<List<Tree>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.trees.Add(Tree.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TreeList DeserializeLengthDelimited(BufferStream stream, TreeList instance, bool isDelta)
	{
		if (!isDelta && instance.trees == null)
		{
			instance.trees = Pool.Get<List<Tree>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.trees.Add(Tree.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TreeList DeserializeLength(BufferStream stream, int length, TreeList instance, bool isDelta)
	{
		if (!isDelta && instance.trees == null)
		{
			instance.trees = Pool.Get<List<Tree>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.trees.Add(Tree.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TreeList instance, TreeList previous)
	{
		if (instance.trees == null)
		{
			return;
		}
		for (int i = 0; i < instance.trees.Count; i++)
		{
			Tree tree = instance.trees[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Tree.SerializeDelta(stream, tree, tree);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field trees (ProtoBuf.Tree)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, TreeList instance)
	{
		if (instance.trees == null)
		{
			return;
		}
		for (int i = 0; i < instance.trees.Count; i++)
		{
			Tree instance2 = instance.trees[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Tree.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field trees (ProtoBuf.Tree)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (trees != null)
		{
			for (int i = 0; i < trees.Count; i++)
			{
				trees[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class TreeRespawn : IDisposable, IPooled, IProto<TreeRespawn>, IProto
{
	[NonSerialized]
	public float timeToRespawn;

	[NonSerialized]
	public int treeIndex;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TreeRespawn instance)
	{
		if (instance.ShouldPool)
		{
			instance.timeToRespawn = 0f;
			instance.treeIndex = 0;
			Pool.Free<TreeRespawn>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TreeRespawn with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TreeRespawn instance)
	{
		instance.timeToRespawn = timeToRespawn;
		instance.treeIndex = treeIndex;
	}

	public TreeRespawn Copy()
	{
		TreeRespawn treeRespawn = Pool.Get<TreeRespawn>();
		CopyTo(treeRespawn);
		return treeRespawn;
	}

	public static TreeRespawn Deserialize(BufferStream stream)
	{
		TreeRespawn treeRespawn = Pool.Get<TreeRespawn>();
		Deserialize(stream, treeRespawn, isDelta: false);
		return treeRespawn;
	}

	public static TreeRespawn DeserializeLengthDelimited(BufferStream stream)
	{
		TreeRespawn treeRespawn = Pool.Get<TreeRespawn>();
		DeserializeLengthDelimited(stream, treeRespawn, isDelta: false);
		return treeRespawn;
	}

	public static TreeRespawn DeserializeLength(BufferStream stream, int length)
	{
		TreeRespawn treeRespawn = Pool.Get<TreeRespawn>();
		DeserializeLength(stream, length, treeRespawn, isDelta: false);
		return treeRespawn;
	}

	public static TreeRespawn Deserialize(byte[] buffer)
	{
		TreeRespawn treeRespawn = Pool.Get<TreeRespawn>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, treeRespawn, isDelta: false);
		return treeRespawn;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TreeRespawn previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TreeRespawn Deserialize(BufferStream stream, TreeRespawn instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.timeToRespawn = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.treeIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TreeRespawn DeserializeLengthDelimited(BufferStream stream, TreeRespawn instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.timeToRespawn = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.treeIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TreeRespawn DeserializeLength(BufferStream stream, int length, TreeRespawn instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.timeToRespawn = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.treeIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TreeRespawn instance, TreeRespawn previous)
	{
		if (instance.timeToRespawn != previous.timeToRespawn)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.timeToRespawn);
		}
		if (instance.treeIndex != previous.treeIndex)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.treeIndex);
		}
	}

	public static void Serialize(BufferStream stream, TreeRespawn instance)
	{
		if (instance.timeToRespawn != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.timeToRespawn);
		}
		if (instance.treeIndex != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.treeIndex);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class TutorialIsland : IDisposable, IPooled, IProto<TutorialIsland>, IProto
{
	[NonSerialized]
	public NetworkableId targetPlayer;

	[NonSerialized]
	public float disconnectDuration;

	[NonSerialized]
	public int spawnLocationIndex;

	[NonSerialized]
	public float tutorialDuration;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TutorialIsland instance)
	{
		if (instance.ShouldPool)
		{
			instance.targetPlayer = default(NetworkableId);
			instance.disconnectDuration = 0f;
			instance.spawnLocationIndex = 0;
			instance.tutorialDuration = 0f;
			Pool.Free<TutorialIsland>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TutorialIsland with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TutorialIsland instance)
	{
		instance.targetPlayer = targetPlayer;
		instance.disconnectDuration = disconnectDuration;
		instance.spawnLocationIndex = spawnLocationIndex;
		instance.tutorialDuration = tutorialDuration;
	}

	public TutorialIsland Copy()
	{
		TutorialIsland tutorialIsland = Pool.Get<TutorialIsland>();
		CopyTo(tutorialIsland);
		return tutorialIsland;
	}

	public static TutorialIsland Deserialize(BufferStream stream)
	{
		TutorialIsland tutorialIsland = Pool.Get<TutorialIsland>();
		Deserialize(stream, tutorialIsland, isDelta: false);
		return tutorialIsland;
	}

	public static TutorialIsland DeserializeLengthDelimited(BufferStream stream)
	{
		TutorialIsland tutorialIsland = Pool.Get<TutorialIsland>();
		DeserializeLengthDelimited(stream, tutorialIsland, isDelta: false);
		return tutorialIsland;
	}

	public static TutorialIsland DeserializeLength(BufferStream stream, int length)
	{
		TutorialIsland tutorialIsland = Pool.Get<TutorialIsland>();
		DeserializeLength(stream, length, tutorialIsland, isDelta: false);
		return tutorialIsland;
	}

	public static TutorialIsland Deserialize(byte[] buffer)
	{
		TutorialIsland tutorialIsland = Pool.Get<TutorialIsland>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, tutorialIsland, isDelta: false);
		return tutorialIsland;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TutorialIsland previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TutorialIsland Deserialize(BufferStream stream, TutorialIsland instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.targetPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.disconnectDuration = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.spawnLocationIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.tutorialDuration = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TutorialIsland DeserializeLengthDelimited(BufferStream stream, TutorialIsland instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.disconnectDuration = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.spawnLocationIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.tutorialDuration = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TutorialIsland DeserializeLength(BufferStream stream, int length, TutorialIsland instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetPlayer = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 21:
				instance.disconnectDuration = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.spawnLocationIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.tutorialDuration = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TutorialIsland instance, TutorialIsland previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.targetPlayer.Value);
		if (instance.disconnectDuration != previous.disconnectDuration)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.disconnectDuration);
		}
		if (instance.spawnLocationIndex != previous.spawnLocationIndex)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.spawnLocationIndex);
		}
		if (instance.tutorialDuration != previous.tutorialDuration)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.tutorialDuration);
		}
	}

	public static void Serialize(BufferStream stream, TutorialIsland instance)
	{
		if (instance.targetPlayer != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.targetPlayer.Value);
		}
		if (instance.disconnectDuration != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.disconnectDuration);
		}
		if (instance.spawnLocationIndex != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.spawnLocationIndex);
		}
		if (instance.tutorialDuration != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.tutorialDuration);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref targetPlayer.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class UpdateItem : IDisposable, IPooled, IProto<UpdateItem>, IProto
{
	[NonSerialized]
	public Item item;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(UpdateItem instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.item != null)
			{
				instance.item.ResetToPool();
				instance.item = null;
			}
			Pool.Free<UpdateItem>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose UpdateItem with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(UpdateItem instance)
	{
		if (item != null)
		{
			if (instance.item == null)
			{
				instance.item = item.Copy();
			}
			else
			{
				item.CopyTo(instance.item);
			}
		}
		else
		{
			instance.item = null;
		}
	}

	public UpdateItem Copy()
	{
		UpdateItem updateItem = Pool.Get<UpdateItem>();
		CopyTo(updateItem);
		return updateItem;
	}

	public static UpdateItem Deserialize(BufferStream stream)
	{
		UpdateItem updateItem = Pool.Get<UpdateItem>();
		Deserialize(stream, updateItem, isDelta: false);
		return updateItem;
	}

	public static UpdateItem DeserializeLengthDelimited(BufferStream stream)
	{
		UpdateItem updateItem = Pool.Get<UpdateItem>();
		DeserializeLengthDelimited(stream, updateItem, isDelta: false);
		return updateItem;
	}

	public static UpdateItem DeserializeLength(BufferStream stream, int length)
	{
		UpdateItem updateItem = Pool.Get<UpdateItem>();
		DeserializeLength(stream, length, updateItem, isDelta: false);
		return updateItem;
	}

	public static UpdateItem Deserialize(byte[] buffer)
	{
		UpdateItem updateItem = Pool.Get<UpdateItem>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, updateItem, isDelta: false);
		return updateItem;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, UpdateItem previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static UpdateItem Deserialize(BufferStream stream, UpdateItem instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.item == null)
				{
					instance.item = Item.DeserializeLengthDelimited(stream);
				}
				else
				{
					Item.DeserializeLengthDelimited(stream, instance.item, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static UpdateItem DeserializeLengthDelimited(BufferStream stream, UpdateItem instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.item == null)
				{
					instance.item = Item.DeserializeLengthDelimited(stream);
				}
				else
				{
					Item.DeserializeLengthDelimited(stream, instance.item, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static UpdateItem DeserializeLength(BufferStream stream, int length, UpdateItem instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.item == null)
				{
					instance.item = Item.DeserializeLengthDelimited(stream);
				}
				else
				{
					Item.DeserializeLengthDelimited(stream, instance.item, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, UpdateItem instance, UpdateItem previous)
	{
		if (instance.item == null)
		{
			throw new ArgumentNullException("item", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		Item.SerializeDelta(stream, instance.item, previous.item);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, UpdateItem instance)
	{
		if (instance.item == null)
		{
			throw new ArgumentNullException("item", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		Item.Serialize(stream, instance.item);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		item?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class UpdateItemContainer : IDisposable, IPooled, IProto<UpdateItemContainer>, IProto
{
	[NonSerialized]
	public int type;

	[NonSerialized]
	public List<ItemContainer> container;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(UpdateItemContainer instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.type = 0;
		if (instance.container != null)
		{
			for (int i = 0; i < instance.container.Count; i++)
			{
				if (instance.container[i] != null)
				{
					instance.container[i].ResetToPool();
					instance.container[i] = null;
				}
			}
			List<ItemContainer> list = instance.container;
			Pool.Free<ItemContainer>(ref list, false);
			instance.container = list;
		}
		Pool.Free<UpdateItemContainer>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose UpdateItemContainer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(UpdateItemContainer instance)
	{
		instance.type = type;
		if (container != null)
		{
			instance.container = Pool.Get<List<ItemContainer>>();
			for (int i = 0; i < container.Count; i++)
			{
				ItemContainer item = container[i].Copy();
				instance.container.Add(item);
			}
		}
		else
		{
			instance.container = null;
		}
	}

	public UpdateItemContainer Copy()
	{
		UpdateItemContainer updateItemContainer = Pool.Get<UpdateItemContainer>();
		CopyTo(updateItemContainer);
		return updateItemContainer;
	}

	public static UpdateItemContainer Deserialize(BufferStream stream)
	{
		UpdateItemContainer updateItemContainer = Pool.Get<UpdateItemContainer>();
		Deserialize(stream, updateItemContainer, isDelta: false);
		return updateItemContainer;
	}

	public static UpdateItemContainer DeserializeLengthDelimited(BufferStream stream)
	{
		UpdateItemContainer updateItemContainer = Pool.Get<UpdateItemContainer>();
		DeserializeLengthDelimited(stream, updateItemContainer, isDelta: false);
		return updateItemContainer;
	}

	public static UpdateItemContainer DeserializeLength(BufferStream stream, int length)
	{
		UpdateItemContainer updateItemContainer = Pool.Get<UpdateItemContainer>();
		DeserializeLength(stream, length, updateItemContainer, isDelta: false);
		return updateItemContainer;
	}

	public static UpdateItemContainer Deserialize(byte[] buffer)
	{
		UpdateItemContainer updateItemContainer = Pool.Get<UpdateItemContainer>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, updateItemContainer, isDelta: false);
		return updateItemContainer;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, UpdateItemContainer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static UpdateItemContainer Deserialize(BufferStream stream, UpdateItemContainer instance, bool isDelta)
	{
		if (!isDelta && instance.container == null)
		{
			instance.container = Pool.Get<List<ItemContainer>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.container.Add(ItemContainer.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static UpdateItemContainer DeserializeLengthDelimited(BufferStream stream, UpdateItemContainer instance, bool isDelta)
	{
		if (!isDelta && instance.container == null)
		{
			instance.container = Pool.Get<List<ItemContainer>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.container.Add(ItemContainer.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static UpdateItemContainer DeserializeLength(BufferStream stream, int length, UpdateItemContainer instance, bool isDelta)
	{
		if (!isDelta && instance.container == null)
		{
			instance.container = Pool.Get<List<ItemContainer>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.container.Add(ItemContainer.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, UpdateItemContainer instance, UpdateItemContainer previous)
	{
		if (instance.type != previous.type)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.container == null)
		{
			return;
		}
		for (int i = 0; i < instance.container.Count; i++)
		{
			ItemContainer itemContainer = instance.container[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.SerializeDelta(stream, itemContainer, itemContainer);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, UpdateItemContainer instance)
	{
		if (instance.type != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.container == null)
		{
			return;
		}
		for (int i = 0; i < instance.container.Count; i++)
		{
			ItemContainer instance2 = instance.container[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (container != null)
		{
			for (int i = 0; i < container.Count; i++)
			{
				container[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class VDDrawEntry : IDisposable, IPooled, IProto<VDDrawEntry>, IProto
{
	public enum Category
	{
		Line,
		Log,
		Text,
		Sphere,
		Box
	}

	[NonSerialized]
	public string entityName;

	[NonSerialized]
	public int frame;

	[NonSerialized]
	public string label;

	[NonSerialized]
	public Category category;

	[NonSerialized]
	public Color color;

	[NonSerialized]
	public Vector3 start;

	[NonSerialized]
	public Vector3 end;

	[NonSerialized]
	public float sizeX;

	[NonSerialized]
	public float sizeY;

	[NonSerialized]
	public float sizeZ;

	[NonSerialized]
	public string message;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VDDrawEntry instance)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.entityName = string.Empty;
			instance.frame = 0;
			instance.label = string.Empty;
			instance.category = Category.Line;
			instance.color = default(Color);
			instance.start = default(Vector3);
			instance.end = default(Vector3);
			instance.sizeX = 0f;
			instance.sizeY = 0f;
			instance.sizeZ = 0f;
			instance.message = string.Empty;
			Pool.Free<VDDrawEntry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VDDrawEntry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VDDrawEntry instance)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		instance.entityName = entityName;
		instance.frame = frame;
		instance.label = label;
		instance.category = category;
		instance.color = color;
		instance.start = start;
		instance.end = end;
		instance.sizeX = sizeX;
		instance.sizeY = sizeY;
		instance.sizeZ = sizeZ;
		instance.message = message;
	}

	public VDDrawEntry Copy()
	{
		VDDrawEntry vDDrawEntry = Pool.Get<VDDrawEntry>();
		CopyTo(vDDrawEntry);
		return vDDrawEntry;
	}

	public static VDDrawEntry Deserialize(BufferStream stream)
	{
		VDDrawEntry vDDrawEntry = Pool.Get<VDDrawEntry>();
		Deserialize(stream, vDDrawEntry, isDelta: false);
		return vDDrawEntry;
	}

	public static VDDrawEntry DeserializeLengthDelimited(BufferStream stream)
	{
		VDDrawEntry vDDrawEntry = Pool.Get<VDDrawEntry>();
		DeserializeLengthDelimited(stream, vDDrawEntry, isDelta: false);
		return vDDrawEntry;
	}

	public static VDDrawEntry DeserializeLength(BufferStream stream, int length)
	{
		VDDrawEntry vDDrawEntry = Pool.Get<VDDrawEntry>();
		DeserializeLength(stream, length, vDDrawEntry, isDelta: false);
		return vDDrawEntry;
	}

	public static VDDrawEntry Deserialize(byte[] buffer)
	{
		VDDrawEntry vDDrawEntry = Pool.Get<VDDrawEntry>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vDDrawEntry, isDelta: false);
		return vDDrawEntry;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VDDrawEntry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VDDrawEntry Deserialize(BufferStream stream, VDDrawEntry instance, bool isDelta)
	{
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.entityName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.frame = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.category = (Category)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.color, isDelta);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.start, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.end, isDelta);
				continue;
			case 69:
				instance.sizeX = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.sizeY = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.sizeZ = ProtocolParser.ReadSingle(stream);
				continue;
			case 90:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VDDrawEntry DeserializeLengthDelimited(BufferStream stream, VDDrawEntry instance, bool isDelta)
	{
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entityName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.frame = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.category = (Category)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.color, isDelta);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.start, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.end, isDelta);
				continue;
			case 69:
				instance.sizeX = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.sizeY = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.sizeZ = ProtocolParser.ReadSingle(stream);
				continue;
			case 90:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VDDrawEntry DeserializeLength(BufferStream stream, int length, VDDrawEntry instance, bool isDelta)
	{
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entityName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.frame = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.category = (Category)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.color, isDelta);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.start, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.end, isDelta);
				continue;
			case 69:
				instance.sizeX = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.sizeY = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.sizeZ = ProtocolParser.ReadSingle(stream);
				continue;
			case 90:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VDDrawEntry instance, VDDrawEntry previous)
	{
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		if (instance.entityName != previous.entityName)
		{
			if (instance.entityName == null)
			{
				throw new ArgumentNullException("entityName", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.entityName);
		}
		if (instance.frame != previous.frame)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.frame);
		}
		if (instance.label != previous.label)
		{
			if (instance.label == null)
			{
				throw new ArgumentNullException("label", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.label);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.category);
		if (instance.color != previous.color)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ColorSerialized.SerializeDelta(stream, instance.color, previous.color);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field color (UnityEngine.Color)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.start != previous.start)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.start, previous.start);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field start (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.end != previous.end)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.end, previous.end);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field end (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.sizeX != previous.sizeX)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.sizeX);
		}
		if (instance.sizeY != previous.sizeY)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.sizeY);
		}
		if (instance.sizeZ != previous.sizeZ)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.sizeZ);
		}
		if (instance.message != null && instance.message != previous.message)
		{
			stream.WriteByte(90);
			ProtocolParser.WriteString(stream, instance.message);
		}
	}

	public static void Serialize(BufferStream stream, VDDrawEntry instance)
	{
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		if (instance.entityName == null)
		{
			throw new ArgumentNullException("entityName", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.entityName);
		if (instance.frame != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.frame);
		}
		if (instance.label == null)
		{
			throw new ArgumentNullException("label", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.label);
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.category);
		if (instance.color != default(Color))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ColorSerialized.Serialize(stream, instance.color);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field color (UnityEngine.Color)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.start != default(Vector3))
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.start);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field start (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.end != default(Vector3))
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.end);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field end (UnityEngine.Vector3)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.sizeX != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.sizeX);
		}
		if (instance.sizeY != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.sizeY);
		}
		if (instance.sizeZ != 0f)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.sizeZ);
		}
		if (instance.message != null)
		{
			stream.WriteByte(90);
			ProtocolParser.WriteString(stream, instance.message);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public struct VectorData : IProto<VectorData>, IProto, IEquatable<VectorData>
{
	[NonSerialized]
	public float x;

	[NonSerialized]
	public float y;

	[NonSerialized]
	public float z;

	public static void ResetToPool(VectorData instance)
	{
		instance.x = 0f;
		instance.y = 0f;
		instance.z = 0f;
	}

	public void CopyTo(VectorData instance)
	{
		instance.x = x;
		instance.y = y;
		instance.z = z;
	}

	public VectorData Copy()
	{
		VectorData vectorData = default(VectorData);
		CopyTo(vectorData);
		return vectorData;
	}

	public static VectorData Deserialize(BufferStream stream)
	{
		VectorData instance = default(VectorData);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public static VectorData DeserializeLengthDelimited(BufferStream stream)
	{
		VectorData instance = default(VectorData);
		DeserializeLengthDelimited(stream, ref instance, isDelta: false);
		return instance;
	}

	public static VectorData DeserializeLength(BufferStream stream, int length)
	{
		VectorData instance = default(VectorData);
		DeserializeLength(stream, length, ref instance, isDelta: false);
		return instance;
	}

	public static VectorData Deserialize(byte[] buffer)
	{
		VectorData instance = default(VectorData);
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void WriteToStreamDelta(BufferStream stream, VectorData previous)
	{
		SerializeDelta(stream, this, previous);
	}

	public void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, ref this, isDelta);
	}

	public static VectorData Deserialize(BufferStream stream, ref VectorData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.z = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VectorData DeserializeLengthDelimited(BufferStream stream, ref VectorData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.z = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VectorData DeserializeLength(BufferStream stream, int length, ref VectorData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.z = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VectorData instance, VectorData previous)
	{
		if (instance.x != previous.x)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != previous.y)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.z != previous.z)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.z);
		}
	}

	public static void Serialize(BufferStream stream, VectorData instance)
	{
		if (instance.x != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.z != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.z);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}

	public VectorData(float x, float y, float z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}

	public static implicit operator VectorData(Vector3 v)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return new VectorData(v.x, v.y, v.z);
	}

	public static implicit operator VectorData(Quaternion q)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return ((Quaternion)(ref q)).eulerAngles;
	}

	public static implicit operator Vector3(VectorData v)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(v.x, v.y, v.z);
	}

	public static implicit operator Quaternion(VectorData v)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.Euler((Vector3)v);
	}

	public bool Equals(VectorData other)
	{
		if (x == other.x && y == other.y)
		{
			return z == other.z;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (obj is VectorData)
		{
			return Equals((VectorData)obj);
		}
		return false;
	}

	public static bool operator ==(VectorData a, VectorData b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(VectorData a, VectorData b)
	{
		return !a.Equals(b);
	}

	public override int GetHashCode()
	{
		return HashCode.Combine(x, y, z);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class VectorList : IDisposable, IPooled, IProto<VectorList>, IProto
{
	[NonSerialized]
	public List<Vector3> vectorPoints;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VectorList instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.vectorPoints != null)
			{
				List<Vector3> list = instance.vectorPoints;
				Pool.FreeUnmanaged<Vector3>(ref list);
				instance.vectorPoints = list;
			}
			Pool.Free<VectorList>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VectorList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VectorList instance)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (vectorPoints != null)
		{
			instance.vectorPoints = Pool.Get<List<Vector3>>();
			for (int i = 0; i < vectorPoints.Count; i++)
			{
				Vector3 item = vectorPoints[i];
				instance.vectorPoints.Add(item);
			}
		}
		else
		{
			instance.vectorPoints = null;
		}
	}

	public VectorList Copy()
	{
		VectorList vectorList = Pool.Get<VectorList>();
		CopyTo(vectorList);
		return vectorList;
	}

	public static VectorList Deserialize(BufferStream stream)
	{
		VectorList vectorList = Pool.Get<VectorList>();
		Deserialize(stream, vectorList, isDelta: false);
		return vectorList;
	}

	public static VectorList DeserializeLengthDelimited(BufferStream stream)
	{
		VectorList vectorList = Pool.Get<VectorList>();
		DeserializeLengthDelimited(stream, vectorList, isDelta: false);
		return vectorList;
	}

	public static VectorList DeserializeLength(BufferStream stream, int length)
	{
		VectorList vectorList = Pool.Get<VectorList>();
		DeserializeLength(stream, length, vectorList, isDelta: false);
		return vectorList;
	}

	public static VectorList Deserialize(byte[] buffer)
	{
		VectorList vectorList = Pool.Get<VectorList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vectorList, isDelta: false);
		return vectorList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VectorList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VectorList Deserialize(BufferStream stream, VectorList instance, bool isDelta)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.vectorPoints == null)
		{
			instance.vectorPoints = Pool.Get<List<Vector3>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.vectorPoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static VectorList DeserializeLengthDelimited(BufferStream stream, VectorList instance, bool isDelta)
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.vectorPoints == null)
		{
			instance.vectorPoints = Pool.Get<List<Vector3>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.vectorPoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VectorList DeserializeLength(BufferStream stream, int length, VectorList instance, bool isDelta)
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.vectorPoints == null)
		{
			instance.vectorPoints = Pool.Get<List<Vector3>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.vectorPoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VectorList instance, VectorList previous)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.vectorPoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.vectorPoints.Count; i++)
		{
			Vector3 val = instance.vectorPoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, val, val);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field vectorPoints (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, VectorList instance)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if (instance.vectorPoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.vectorPoints.Count; i++)
		{
			Vector3 instance2 = instance.vectorPoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field vectorPoints (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VehicleLift : IDisposable, IPooled, IProto<VehicleLift>, IProto
{
	[NonSerialized]
	public bool platformIsOccupied;

	[NonSerialized]
	public bool editableOccupant;

	[NonSerialized]
	public bool driveableOccupant;

	[NonSerialized]
	public int occupantLockState;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VehicleLift instance)
	{
		if (instance.ShouldPool)
		{
			instance.platformIsOccupied = false;
			instance.editableOccupant = false;
			instance.driveableOccupant = false;
			instance.occupantLockState = 0;
			Pool.Free<VehicleLift>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VehicleLift with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VehicleLift instance)
	{
		instance.platformIsOccupied = platformIsOccupied;
		instance.editableOccupant = editableOccupant;
		instance.driveableOccupant = driveableOccupant;
		instance.occupantLockState = occupantLockState;
	}

	public VehicleLift Copy()
	{
		VehicleLift vehicleLift = Pool.Get<VehicleLift>();
		CopyTo(vehicleLift);
		return vehicleLift;
	}

	public static VehicleLift Deserialize(BufferStream stream)
	{
		VehicleLift vehicleLift = Pool.Get<VehicleLift>();
		Deserialize(stream, vehicleLift, isDelta: false);
		return vehicleLift;
	}

	public static VehicleLift DeserializeLengthDelimited(BufferStream stream)
	{
		VehicleLift vehicleLift = Pool.Get<VehicleLift>();
		DeserializeLengthDelimited(stream, vehicleLift, isDelta: false);
		return vehicleLift;
	}

	public static VehicleLift DeserializeLength(BufferStream stream, int length)
	{
		VehicleLift vehicleLift = Pool.Get<VehicleLift>();
		DeserializeLength(stream, length, vehicleLift, isDelta: false);
		return vehicleLift;
	}

	public static VehicleLift Deserialize(byte[] buffer)
	{
		VehicleLift vehicleLift = Pool.Get<VehicleLift>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vehicleLift, isDelta: false);
		return vehicleLift;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VehicleLift previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VehicleLift Deserialize(BufferStream stream, VehicleLift instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.platformIsOccupied = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.editableOccupant = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.driveableOccupant = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.occupantLockState = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VehicleLift DeserializeLengthDelimited(BufferStream stream, VehicleLift instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.platformIsOccupied = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.editableOccupant = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.driveableOccupant = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.occupantLockState = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VehicleLift DeserializeLength(BufferStream stream, int length, VehicleLift instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.platformIsOccupied = ProtocolParser.ReadBool(stream);
				continue;
			case 16:
				instance.editableOccupant = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.driveableOccupant = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.occupantLockState = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VehicleLift instance, VehicleLift previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.platformIsOccupied);
		stream.WriteByte(16);
		ProtocolParser.WriteBool(stream, instance.editableOccupant);
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.driveableOccupant);
		if (instance.occupantLockState != previous.occupantLockState)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.occupantLockState);
		}
	}

	public static void Serialize(BufferStream stream, VehicleLift instance)
	{
		if (instance.platformIsOccupied)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.platformIsOccupied);
		}
		if (instance.editableOccupant)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteBool(stream, instance.editableOccupant);
		}
		if (instance.driveableOccupant)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.driveableOccupant);
		}
		if (instance.occupantLockState != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.occupantLockState);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VehicleModule : IDisposable, IPooled, IProto<VehicleModule>, IProto
{
	[NonSerialized]
	public int socketIndex;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VehicleModule instance)
	{
		if (instance.ShouldPool)
		{
			instance.socketIndex = 0;
			Pool.Free<VehicleModule>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VehicleModule with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VehicleModule instance)
	{
		instance.socketIndex = socketIndex;
	}

	public VehicleModule Copy()
	{
		VehicleModule vehicleModule = Pool.Get<VehicleModule>();
		CopyTo(vehicleModule);
		return vehicleModule;
	}

	public static VehicleModule Deserialize(BufferStream stream)
	{
		VehicleModule vehicleModule = Pool.Get<VehicleModule>();
		Deserialize(stream, vehicleModule, isDelta: false);
		return vehicleModule;
	}

	public static VehicleModule DeserializeLengthDelimited(BufferStream stream)
	{
		VehicleModule vehicleModule = Pool.Get<VehicleModule>();
		DeserializeLengthDelimited(stream, vehicleModule, isDelta: false);
		return vehicleModule;
	}

	public static VehicleModule DeserializeLength(BufferStream stream, int length)
	{
		VehicleModule vehicleModule = Pool.Get<VehicleModule>();
		DeserializeLength(stream, length, vehicleModule, isDelta: false);
		return vehicleModule;
	}

	public static VehicleModule Deserialize(byte[] buffer)
	{
		VehicleModule vehicleModule = Pool.Get<VehicleModule>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vehicleModule, isDelta: false);
		return vehicleModule;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VehicleModule previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VehicleModule Deserialize(BufferStream stream, VehicleModule instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.socketIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VehicleModule DeserializeLengthDelimited(BufferStream stream, VehicleModule instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.socketIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VehicleModule DeserializeLength(BufferStream stream, int length, VehicleModule instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.socketIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VehicleModule instance, VehicleModule previous)
	{
		if (instance.socketIndex != previous.socketIndex)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.socketIndex);
		}
	}

	public static void Serialize(BufferStream stream, VehicleModule instance)
	{
		if (instance.socketIndex != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.socketIndex);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VehicleVendor : IDisposable, IPooled, IProto<VehicleVendor>, IProto
{
	public class PlayerStorage : IDisposable, IPooled, IProto<PlayerStorage>, IProto
	{
		public class PlayerStoredVehicle : IDisposable, IPooled, IProto<PlayerStoredVehicle>, IProto
		{
			[NonSerialized]
			public string shortname;

			[NonSerialized]
			public string resourcePath;

			[NonSerialized]
			public float health;

			public bool ShouldPool = true;

			private bool _disposed;

			public static void ResetToPool(PlayerStoredVehicle instance)
			{
				if (instance.ShouldPool)
				{
					instance.shortname = string.Empty;
					instance.resourcePath = string.Empty;
					instance.health = 0f;
					Pool.Free<PlayerStoredVehicle>(ref instance);
				}
			}

			public void ResetToPool()
			{
				ResetToPool(this);
			}

			public virtual void Dispose()
			{
				if (!ShouldPool)
				{
					throw new Exception("Trying to dispose PlayerStoredVehicle with ShouldPool set to false!");
				}
				if (!_disposed)
				{
					ResetToPool();
					_disposed = true;
				}
			}

			public virtual void EnterPool()
			{
				_disposed = true;
			}

			public virtual void LeavePool()
			{
				_disposed = false;
			}

			public void CopyTo(PlayerStoredVehicle instance)
			{
				instance.shortname = shortname;
				instance.resourcePath = resourcePath;
				instance.health = health;
			}

			public PlayerStoredVehicle Copy()
			{
				PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
				CopyTo(playerStoredVehicle);
				return playerStoredVehicle;
			}

			public static PlayerStoredVehicle Deserialize(BufferStream stream)
			{
				PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
				Deserialize(stream, playerStoredVehicle, isDelta: false);
				return playerStoredVehicle;
			}

			public static PlayerStoredVehicle DeserializeLengthDelimited(BufferStream stream)
			{
				PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
				DeserializeLengthDelimited(stream, playerStoredVehicle, isDelta: false);
				return playerStoredVehicle;
			}

			public static PlayerStoredVehicle DeserializeLength(BufferStream stream, int length)
			{
				PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
				DeserializeLength(stream, length, playerStoredVehicle, isDelta: false);
				return playerStoredVehicle;
			}

			public static PlayerStoredVehicle Deserialize(byte[] buffer)
			{
				PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
				using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
				Deserialize(stream, playerStoredVehicle, isDelta: false);
				return playerStoredVehicle;
			}

			public void FromProto(BufferStream stream, bool isDelta = false)
			{
				Deserialize(stream, this, isDelta);
			}

			public virtual void WriteToStream(BufferStream stream)
			{
				Serialize(stream, this);
			}

			public virtual void WriteToStreamDelta(BufferStream stream, PlayerStoredVehicle previous)
			{
				if (previous == null)
				{
					Serialize(stream, this);
				}
				else
				{
					SerializeDelta(stream, this, previous);
				}
			}

			public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
			{
				Deserialize(stream, this, isDelta);
			}

			public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
			{
				DeserializeLength(stream, size, this, isDelta);
			}

			public static PlayerStoredVehicle Deserialize(BufferStream stream, PlayerStoredVehicle instance, bool isDelta)
			{
				while (true)
				{
					int num = stream.ReadByte();
					switch (num)
					{
					case 10:
						instance.shortname = ProtocolParser.ReadString(stream);
						continue;
					case 18:
						instance.resourcePath = ProtocolParser.ReadString(stream);
						continue;
					case 29:
						instance.health = ProtocolParser.ReadSingle(stream);
						continue;
					case -1:
					case 0:
						return instance;
					}
					Key key = ProtocolParser.ReadKey((byte)num, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
			}

			public static PlayerStoredVehicle DeserializeLengthDelimited(BufferStream stream, PlayerStoredVehicle instance, bool isDelta)
			{
				long num = ProtocolParser.ReadUInt32(stream);
				num += stream.Position;
				while (stream.Position < num)
				{
					int num2 = stream.ReadByte();
					switch (num2)
					{
					case -1:
						throw new EndOfStreamException();
					case 10:
						instance.shortname = ProtocolParser.ReadString(stream);
						continue;
					case 18:
						instance.resourcePath = ProtocolParser.ReadString(stream);
						continue;
					case 29:
						instance.health = ProtocolParser.ReadSingle(stream);
						continue;
					}
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
				if (stream.Position != num)
				{
					throw new ProtocolBufferException("Read past max limit");
				}
				return instance;
			}

			public static PlayerStoredVehicle DeserializeLength(BufferStream stream, int length, PlayerStoredVehicle instance, bool isDelta)
			{
				long num = stream.Position + length;
				while (stream.Position < num)
				{
					int num2 = stream.ReadByte();
					switch (num2)
					{
					case -1:
						throw new EndOfStreamException();
					case 10:
						instance.shortname = ProtocolParser.ReadString(stream);
						continue;
					case 18:
						instance.resourcePath = ProtocolParser.ReadString(stream);
						continue;
					case 29:
						instance.health = ProtocolParser.ReadSingle(stream);
						continue;
					}
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
				}
				if (stream.Position != num)
				{
					throw new ProtocolBufferException("Read past max limit");
				}
				return instance;
			}

			public static void SerializeDelta(BufferStream stream, PlayerStoredVehicle instance, PlayerStoredVehicle previous)
			{
				if (instance.shortname != null && instance.shortname != previous.shortname)
				{
					stream.WriteByte(10);
					ProtocolParser.WriteString(stream, instance.shortname);
				}
				if (instance.resourcePath != null && instance.resourcePath != previous.resourcePath)
				{
					stream.WriteByte(18);
					ProtocolParser.WriteString(stream, instance.resourcePath);
				}
				if (instance.health != previous.health)
				{
					stream.WriteByte(29);
					ProtocolParser.WriteSingle(stream, instance.health);
				}
			}

			public static void Serialize(BufferStream stream, PlayerStoredVehicle instance)
			{
				if (instance.shortname != null)
				{
					stream.WriteByte(10);
					ProtocolParser.WriteString(stream, instance.shortname);
				}
				if (instance.resourcePath != null)
				{
					stream.WriteByte(18);
					ProtocolParser.WriteString(stream, instance.resourcePath);
				}
				if (instance.health != 0f)
				{
					stream.WriteByte(29);
					ProtocolParser.WriteSingle(stream, instance.health);
				}
			}

			public void ToProto(BufferStream stream)
			{
				Serialize(stream, this);
			}

			public void InspectUids(UidInspector<ulong> action)
			{
			}
		}

		[NonSerialized]
		public ulong userid;

		[NonSerialized]
		public List<PlayerStoredVehicle> storedVehicles;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(PlayerStorage instance)
		{
			if (!instance.ShouldPool)
			{
				return;
			}
			instance.userid = 0uL;
			if (instance.storedVehicles != null)
			{
				for (int i = 0; i < instance.storedVehicles.Count; i++)
				{
					if (instance.storedVehicles[i] != null)
					{
						instance.storedVehicles[i].ResetToPool();
						instance.storedVehicles[i] = null;
					}
				}
				List<PlayerStoredVehicle> list = instance.storedVehicles;
				Pool.Free<PlayerStoredVehicle>(ref list, false);
				instance.storedVehicles = list;
			}
			Pool.Free<PlayerStorage>(ref instance);
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose PlayerStorage with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(PlayerStorage instance)
		{
			instance.userid = userid;
			if (storedVehicles != null)
			{
				instance.storedVehicles = Pool.Get<List<PlayerStoredVehicle>>();
				for (int i = 0; i < storedVehicles.Count; i++)
				{
					PlayerStoredVehicle item = storedVehicles[i].Copy();
					instance.storedVehicles.Add(item);
				}
			}
			else
			{
				instance.storedVehicles = null;
			}
		}

		public PlayerStorage Copy()
		{
			PlayerStorage playerStorage = Pool.Get<PlayerStorage>();
			CopyTo(playerStorage);
			return playerStorage;
		}

		public static PlayerStorage Deserialize(BufferStream stream)
		{
			PlayerStorage playerStorage = Pool.Get<PlayerStorage>();
			Deserialize(stream, playerStorage, isDelta: false);
			return playerStorage;
		}

		public static PlayerStorage DeserializeLengthDelimited(BufferStream stream)
		{
			PlayerStorage playerStorage = Pool.Get<PlayerStorage>();
			DeserializeLengthDelimited(stream, playerStorage, isDelta: false);
			return playerStorage;
		}

		public static PlayerStorage DeserializeLength(BufferStream stream, int length)
		{
			PlayerStorage playerStorage = Pool.Get<PlayerStorage>();
			DeserializeLength(stream, length, playerStorage, isDelta: false);
			return playerStorage;
		}

		public static PlayerStorage Deserialize(byte[] buffer)
		{
			PlayerStorage playerStorage = Pool.Get<PlayerStorage>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, playerStorage, isDelta: false);
			return playerStorage;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, PlayerStorage previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static PlayerStorage Deserialize(BufferStream stream, PlayerStorage instance, bool isDelta)
		{
			if (!isDelta && instance.storedVehicles == null)
			{
				instance.storedVehicles = Pool.Get<List<PlayerStoredVehicle>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.userid = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.storedVehicles.Add(PlayerStoredVehicle.DeserializeLengthDelimited(stream));
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static PlayerStorage DeserializeLengthDelimited(BufferStream stream, PlayerStorage instance, bool isDelta)
		{
			if (!isDelta && instance.storedVehicles == null)
			{
				instance.storedVehicles = Pool.Get<List<PlayerStoredVehicle>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.userid = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.storedVehicles.Add(PlayerStoredVehicle.DeserializeLengthDelimited(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static PlayerStorage DeserializeLength(BufferStream stream, int length, PlayerStorage instance, bool isDelta)
		{
			if (!isDelta && instance.storedVehicles == null)
			{
				instance.storedVehicles = Pool.Get<List<PlayerStoredVehicle>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.userid = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.storedVehicles.Add(PlayerStoredVehicle.DeserializeLengthDelimited(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, PlayerStorage instance, PlayerStorage previous)
		{
			if (instance.userid != previous.userid)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.userid);
			}
			if (instance.storedVehicles == null)
			{
				return;
			}
			for (int i = 0; i < instance.storedVehicles.Count; i++)
			{
				PlayerStoredVehicle playerStoredVehicle = instance.storedVehicles[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PlayerStoredVehicle.SerializeDelta(stream, playerStoredVehicle, playerStoredVehicle);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}

		public static void Serialize(BufferStream stream, PlayerStorage instance)
		{
			if (instance.userid != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.userid);
			}
			if (instance.storedVehicles == null)
			{
				return;
			}
			for (int i = 0; i < instance.storedVehicles.Count; i++)
			{
				PlayerStoredVehicle instance2 = instance.storedVehicles[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PlayerStoredVehicle.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			if (storedVehicles != null)
			{
				for (int i = 0; i < storedVehicles.Count; i++)
				{
					storedVehicles[i]?.InspectUids(action);
				}
			}
		}
	}

	[NonSerialized]
	public List<PlayerStorage> playerStorage;

	[NonSerialized]
	public NetworkableId spawnerRef;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VehicleVendor instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.playerStorage != null)
		{
			for (int i = 0; i < instance.playerStorage.Count; i++)
			{
				if (instance.playerStorage[i] != null)
				{
					instance.playerStorage[i].ResetToPool();
					instance.playerStorage[i] = null;
				}
			}
			List<PlayerStorage> list = instance.playerStorage;
			Pool.Free<PlayerStorage>(ref list, false);
			instance.playerStorage = list;
		}
		instance.spawnerRef = default(NetworkableId);
		Pool.Free<VehicleVendor>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VehicleVendor with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VehicleVendor instance)
	{
		if (playerStorage != null)
		{
			instance.playerStorage = Pool.Get<List<PlayerStorage>>();
			for (int i = 0; i < playerStorage.Count; i++)
			{
				PlayerStorage item = playerStorage[i].Copy();
				instance.playerStorage.Add(item);
			}
		}
		else
		{
			instance.playerStorage = null;
		}
		instance.spawnerRef = spawnerRef;
	}

	public VehicleVendor Copy()
	{
		VehicleVendor vehicleVendor = Pool.Get<VehicleVendor>();
		CopyTo(vehicleVendor);
		return vehicleVendor;
	}

	public static VehicleVendor Deserialize(BufferStream stream)
	{
		VehicleVendor vehicleVendor = Pool.Get<VehicleVendor>();
		Deserialize(stream, vehicleVendor, isDelta: false);
		return vehicleVendor;
	}

	public static VehicleVendor DeserializeLengthDelimited(BufferStream stream)
	{
		VehicleVendor vehicleVendor = Pool.Get<VehicleVendor>();
		DeserializeLengthDelimited(stream, vehicleVendor, isDelta: false);
		return vehicleVendor;
	}

	public static VehicleVendor DeserializeLength(BufferStream stream, int length)
	{
		VehicleVendor vehicleVendor = Pool.Get<VehicleVendor>();
		DeserializeLength(stream, length, vehicleVendor, isDelta: false);
		return vehicleVendor;
	}

	public static VehicleVendor Deserialize(byte[] buffer)
	{
		VehicleVendor vehicleVendor = Pool.Get<VehicleVendor>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vehicleVendor, isDelta: false);
		return vehicleVendor;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VehicleVendor previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VehicleVendor Deserialize(BufferStream stream, VehicleVendor instance, bool isDelta)
	{
		if (!isDelta && instance.playerStorage == null)
		{
			instance.playerStorage = Pool.Get<List<PlayerStorage>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.playerStorage.Add(PlayerStorage.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.spawnerRef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VehicleVendor DeserializeLengthDelimited(BufferStream stream, VehicleVendor instance, bool isDelta)
	{
		if (!isDelta && instance.playerStorage == null)
		{
			instance.playerStorage = Pool.Get<List<PlayerStorage>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.playerStorage.Add(PlayerStorage.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.spawnerRef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VehicleVendor DeserializeLength(BufferStream stream, int length, VehicleVendor instance, bool isDelta)
	{
		if (!isDelta && instance.playerStorage == null)
		{
			instance.playerStorage = Pool.Get<List<PlayerStorage>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.playerStorage.Add(PlayerStorage.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.spawnerRef = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VehicleVendor instance, VehicleVendor previous)
	{
		if (instance.playerStorage != null)
		{
			for (int i = 0; i < instance.playerStorage.Count; i++)
			{
				PlayerStorage playerStorage = instance.playerStorage[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PlayerStorage.SerializeDelta(stream, playerStorage, playerStorage);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.spawnerRef.Value);
	}

	public static void Serialize(BufferStream stream, VehicleVendor instance)
	{
		if (instance.playerStorage != null)
		{
			for (int i = 0; i < instance.playerStorage.Count; i++)
			{
				PlayerStorage instance2 = instance.playerStorage[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PlayerStorage.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.spawnerRef != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.spawnerRef.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (playerStorage != null)
		{
			for (int i = 0; i < playerStorage.Count; i++)
			{
				playerStorage[i]?.InspectUids(action);
			}
		}
		action(UidType.NetworkableId, ref spawnerRef.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VendingDynamicPricing : IDisposable, IPooled, IProto<VendingDynamicPricing>, IProto
{
	[NonSerialized]
	public List<SalesData> allSalesData;

	[NonSerialized]
	public float timeToNextSalesUpdate;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VendingDynamicPricing instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.allSalesData != null)
		{
			for (int i = 0; i < instance.allSalesData.Count; i++)
			{
				if (instance.allSalesData[i] != null)
				{
					instance.allSalesData[i].ResetToPool();
					instance.allSalesData[i] = null;
				}
			}
			List<SalesData> list = instance.allSalesData;
			Pool.Free<SalesData>(ref list, false);
			instance.allSalesData = list;
		}
		instance.timeToNextSalesUpdate = 0f;
		Pool.Free<VendingDynamicPricing>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VendingDynamicPricing with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VendingDynamicPricing instance)
	{
		if (allSalesData != null)
		{
			instance.allSalesData = Pool.Get<List<SalesData>>();
			for (int i = 0; i < allSalesData.Count; i++)
			{
				SalesData item = allSalesData[i].Copy();
				instance.allSalesData.Add(item);
			}
		}
		else
		{
			instance.allSalesData = null;
		}
		instance.timeToNextSalesUpdate = timeToNextSalesUpdate;
	}

	public VendingDynamicPricing Copy()
	{
		VendingDynamicPricing vendingDynamicPricing = Pool.Get<VendingDynamicPricing>();
		CopyTo(vendingDynamicPricing);
		return vendingDynamicPricing;
	}

	public static VendingDynamicPricing Deserialize(BufferStream stream)
	{
		VendingDynamicPricing vendingDynamicPricing = Pool.Get<VendingDynamicPricing>();
		Deserialize(stream, vendingDynamicPricing, isDelta: false);
		return vendingDynamicPricing;
	}

	public static VendingDynamicPricing DeserializeLengthDelimited(BufferStream stream)
	{
		VendingDynamicPricing vendingDynamicPricing = Pool.Get<VendingDynamicPricing>();
		DeserializeLengthDelimited(stream, vendingDynamicPricing, isDelta: false);
		return vendingDynamicPricing;
	}

	public static VendingDynamicPricing DeserializeLength(BufferStream stream, int length)
	{
		VendingDynamicPricing vendingDynamicPricing = Pool.Get<VendingDynamicPricing>();
		DeserializeLength(stream, length, vendingDynamicPricing, isDelta: false);
		return vendingDynamicPricing;
	}

	public static VendingDynamicPricing Deserialize(byte[] buffer)
	{
		VendingDynamicPricing vendingDynamicPricing = Pool.Get<VendingDynamicPricing>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vendingDynamicPricing, isDelta: false);
		return vendingDynamicPricing;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VendingDynamicPricing previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VendingDynamicPricing Deserialize(BufferStream stream, VendingDynamicPricing instance, bool isDelta)
	{
		if (!isDelta && instance.allSalesData == null)
		{
			instance.allSalesData = Pool.Get<List<SalesData>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.allSalesData.Add(SalesData.DeserializeLengthDelimited(stream));
				continue;
			case 29:
				instance.timeToNextSalesUpdate = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VendingDynamicPricing DeserializeLengthDelimited(BufferStream stream, VendingDynamicPricing instance, bool isDelta)
	{
		if (!isDelta && instance.allSalesData == null)
		{
			instance.allSalesData = Pool.Get<List<SalesData>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.allSalesData.Add(SalesData.DeserializeLengthDelimited(stream));
				continue;
			case 29:
				instance.timeToNextSalesUpdate = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VendingDynamicPricing DeserializeLength(BufferStream stream, int length, VendingDynamicPricing instance, bool isDelta)
	{
		if (!isDelta && instance.allSalesData == null)
		{
			instance.allSalesData = Pool.Get<List<SalesData>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.allSalesData.Add(SalesData.DeserializeLengthDelimited(stream));
				continue;
			case 29:
				instance.timeToNextSalesUpdate = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VendingDynamicPricing instance, VendingDynamicPricing previous)
	{
		if (instance.allSalesData != null)
		{
			for (int i = 0; i < instance.allSalesData.Count; i++)
			{
				SalesData salesData = instance.allSalesData[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				SalesData.SerializeDelta(stream, salesData, salesData);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field allSalesData (ProtoBuf.SalesData)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.timeToNextSalesUpdate != previous.timeToNextSalesUpdate)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.timeToNextSalesUpdate);
		}
	}

	public static void Serialize(BufferStream stream, VendingDynamicPricing instance)
	{
		if (instance.allSalesData != null)
		{
			for (int i = 0; i < instance.allSalesData.Count; i++)
			{
				SalesData instance2 = instance.allSalesData[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				SalesData.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field allSalesData (ProtoBuf.SalesData)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.timeToNextSalesUpdate != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.timeToNextSalesUpdate);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (allSalesData != null)
		{
			for (int i = 0; i < allSalesData.Count; i++)
			{
				allSalesData[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VendingMachine : IDisposable, IPooled, IProto<VendingMachine>, IProto
{
	public class SellOrder : IDisposable, IPooled, IProto<SellOrder>, IProto
	{
		[NonSerialized]
		public int itemToSellID;

		[NonSerialized]
		public int itemToSellAmount;

		[NonSerialized]
		public int currencyID;

		[NonSerialized]
		public int currencyAmountPerItem;

		[NonSerialized]
		public int inStock;

		[NonSerialized]
		public bool currencyIsBP;

		[NonSerialized]
		public bool itemToSellIsBP;

		[NonSerialized]
		public float itemCondition;

		[NonSerialized]
		public float itemConditionMax;

		[NonSerialized]
		public int instanceData;

		[NonSerialized]
		public List<int> attachmentsList;

		[NonSerialized]
		public int totalAttachmentSlots;

		[NonSerialized]
		public float priceMultiplier;

		[NonSerialized]
		public int ammoType;

		[NonSerialized]
		public int ammoCount;

		[NonSerialized]
		public float receivedQuantityMultiplier;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(SellOrder instance)
		{
			if (instance.ShouldPool)
			{
				instance.itemToSellID = 0;
				instance.itemToSellAmount = 0;
				instance.currencyID = 0;
				instance.currencyAmountPerItem = 0;
				instance.inStock = 0;
				instance.currencyIsBP = false;
				instance.itemToSellIsBP = false;
				instance.itemCondition = 0f;
				instance.itemConditionMax = 0f;
				instance.instanceData = 0;
				if (instance.attachmentsList != null)
				{
					List<int> list = instance.attachmentsList;
					Pool.FreeUnmanaged<int>(ref list);
					instance.attachmentsList = list;
				}
				instance.totalAttachmentSlots = 0;
				instance.priceMultiplier = 0f;
				instance.ammoType = 0;
				instance.ammoCount = 0;
				instance.receivedQuantityMultiplier = 0f;
				Pool.Free<SellOrder>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose SellOrder with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(SellOrder instance)
		{
			instance.itemToSellID = itemToSellID;
			instance.itemToSellAmount = itemToSellAmount;
			instance.currencyID = currencyID;
			instance.currencyAmountPerItem = currencyAmountPerItem;
			instance.inStock = inStock;
			instance.currencyIsBP = currencyIsBP;
			instance.itemToSellIsBP = itemToSellIsBP;
			instance.itemCondition = itemCondition;
			instance.itemConditionMax = itemConditionMax;
			instance.instanceData = instanceData;
			if (attachmentsList != null)
			{
				instance.attachmentsList = Pool.Get<List<int>>();
				for (int i = 0; i < attachmentsList.Count; i++)
				{
					int item = attachmentsList[i];
					instance.attachmentsList.Add(item);
				}
			}
			else
			{
				instance.attachmentsList = null;
			}
			instance.totalAttachmentSlots = totalAttachmentSlots;
			instance.priceMultiplier = priceMultiplier;
			instance.ammoType = ammoType;
			instance.ammoCount = ammoCount;
			instance.receivedQuantityMultiplier = receivedQuantityMultiplier;
		}

		public SellOrder Copy()
		{
			SellOrder sellOrder = Pool.Get<SellOrder>();
			CopyTo(sellOrder);
			return sellOrder;
		}

		public static SellOrder Deserialize(BufferStream stream)
		{
			SellOrder sellOrder = Pool.Get<SellOrder>();
			Deserialize(stream, sellOrder, isDelta: false);
			return sellOrder;
		}

		public static SellOrder DeserializeLengthDelimited(BufferStream stream)
		{
			SellOrder sellOrder = Pool.Get<SellOrder>();
			DeserializeLengthDelimited(stream, sellOrder, isDelta: false);
			return sellOrder;
		}

		public static SellOrder DeserializeLength(BufferStream stream, int length)
		{
			SellOrder sellOrder = Pool.Get<SellOrder>();
			DeserializeLength(stream, length, sellOrder, isDelta: false);
			return sellOrder;
		}

		public static SellOrder Deserialize(byte[] buffer)
		{
			SellOrder sellOrder = Pool.Get<SellOrder>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, sellOrder, isDelta: false);
			return sellOrder;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, SellOrder previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static SellOrder Deserialize(BufferStream stream, SellOrder instance, bool isDelta)
		{
			if (!isDelta && instance.attachmentsList == null)
			{
				instance.attachmentsList = Pool.Get<List<int>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.itemToSellID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.itemToSellAmount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.currencyID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.currencyAmountPerItem = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.inStock = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.currencyIsBP = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.itemToSellIsBP = ProtocolParser.ReadBool(stream);
					continue;
				case 69:
					instance.itemCondition = ProtocolParser.ReadSingle(stream);
					continue;
				case 77:
					instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
					continue;
				case 80:
					instance.instanceData = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 88:
					instance.attachmentsList.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 96:
					instance.totalAttachmentSlots = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 109:
					instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
					continue;
				case 112:
					instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 120:
					instance.ammoCount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				if (key.Field == 16)
				{
					if (key.WireType == Wire.Fixed32)
					{
						instance.receivedQuantityMultiplier = ProtocolParser.ReadSingle(stream);
					}
				}
				else
				{
					ProtocolParser.SkipKey(stream, key);
				}
			}
		}

		public static SellOrder DeserializeLengthDelimited(BufferStream stream, SellOrder instance, bool isDelta)
		{
			if (!isDelta && instance.attachmentsList == null)
			{
				instance.attachmentsList = Pool.Get<List<int>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemToSellID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.itemToSellAmount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.currencyID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.currencyAmountPerItem = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.inStock = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.currencyIsBP = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.itemToSellIsBP = ProtocolParser.ReadBool(stream);
					continue;
				case 69:
					instance.itemCondition = ProtocolParser.ReadSingle(stream);
					continue;
				case 77:
					instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
					continue;
				case 80:
					instance.instanceData = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 88:
					instance.attachmentsList.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 96:
					instance.totalAttachmentSlots = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 109:
					instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
					continue;
				case 112:
					instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 120:
					instance.ammoCount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				if (key.Field == 16)
				{
					if (key.WireType == Wire.Fixed32)
					{
						instance.receivedQuantityMultiplier = ProtocolParser.ReadSingle(stream);
					}
				}
				else
				{
					ProtocolParser.SkipKey(stream, key);
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static SellOrder DeserializeLength(BufferStream stream, int length, SellOrder instance, bool isDelta)
		{
			if (!isDelta && instance.attachmentsList == null)
			{
				instance.attachmentsList = Pool.Get<List<int>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemToSellID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.itemToSellAmount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.currencyID = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.currencyAmountPerItem = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.inStock = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.currencyIsBP = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.itemToSellIsBP = ProtocolParser.ReadBool(stream);
					continue;
				case 69:
					instance.itemCondition = ProtocolParser.ReadSingle(stream);
					continue;
				case 77:
					instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
					continue;
				case 80:
					instance.instanceData = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 88:
					instance.attachmentsList.Add((int)ProtocolParser.ReadUInt64(stream));
					continue;
				case 96:
					instance.totalAttachmentSlots = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 109:
					instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
					continue;
				case 112:
					instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 120:
					instance.ammoCount = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				if (key.Field == 16)
				{
					if (key.WireType == Wire.Fixed32)
					{
						instance.receivedQuantityMultiplier = ProtocolParser.ReadSingle(stream);
					}
				}
				else
				{
					ProtocolParser.SkipKey(stream, key);
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, SellOrder instance, SellOrder previous)
		{
			if (instance.itemToSellID != previous.itemToSellID)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemToSellID);
			}
			if (instance.itemToSellAmount != previous.itemToSellAmount)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemToSellAmount);
			}
			if (instance.currencyID != previous.currencyID)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyID);
			}
			if (instance.currencyAmountPerItem != previous.currencyAmountPerItem)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyAmountPerItem);
			}
			if (instance.inStock != previous.inStock)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.inStock);
			}
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.currencyIsBP);
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.itemToSellIsBP);
			if (instance.itemCondition != previous.itemCondition)
			{
				stream.WriteByte(69);
				ProtocolParser.WriteSingle(stream, instance.itemCondition);
			}
			if (instance.itemConditionMax != previous.itemConditionMax)
			{
				stream.WriteByte(77);
				ProtocolParser.WriteSingle(stream, instance.itemConditionMax);
			}
			if (instance.instanceData != previous.instanceData)
			{
				stream.WriteByte(80);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.instanceData);
			}
			if (instance.attachmentsList != null)
			{
				for (int i = 0; i < instance.attachmentsList.Count; i++)
				{
					int num = instance.attachmentsList[i];
					stream.WriteByte(88);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.totalAttachmentSlots != previous.totalAttachmentSlots)
			{
				stream.WriteByte(96);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.totalAttachmentSlots);
			}
			if (instance.priceMultiplier != previous.priceMultiplier)
			{
				stream.WriteByte(109);
				ProtocolParser.WriteSingle(stream, instance.priceMultiplier);
			}
			if (instance.ammoType != previous.ammoType)
			{
				stream.WriteByte(112);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoType);
			}
			if (instance.ammoCount != previous.ammoCount)
			{
				stream.WriteByte(120);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoCount);
			}
			if (instance.receivedQuantityMultiplier != previous.receivedQuantityMultiplier)
			{
				stream.WriteByte(133);
				stream.WriteByte(1);
				ProtocolParser.WriteSingle(stream, instance.receivedQuantityMultiplier);
			}
		}

		public static void Serialize(BufferStream stream, SellOrder instance)
		{
			if (instance.itemToSellID != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemToSellID);
			}
			if (instance.itemToSellAmount != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemToSellAmount);
			}
			if (instance.currencyID != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyID);
			}
			if (instance.currencyAmountPerItem != 0)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyAmountPerItem);
			}
			if (instance.inStock != 0)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.inStock);
			}
			if (instance.currencyIsBP)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteBool(stream, instance.currencyIsBP);
			}
			if (instance.itemToSellIsBP)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteBool(stream, instance.itemToSellIsBP);
			}
			if (instance.itemCondition != 0f)
			{
				stream.WriteByte(69);
				ProtocolParser.WriteSingle(stream, instance.itemCondition);
			}
			if (instance.itemConditionMax != 0f)
			{
				stream.WriteByte(77);
				ProtocolParser.WriteSingle(stream, instance.itemConditionMax);
			}
			if (instance.instanceData != 0)
			{
				stream.WriteByte(80);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.instanceData);
			}
			if (instance.attachmentsList != null)
			{
				for (int i = 0; i < instance.attachmentsList.Count; i++)
				{
					int num = instance.attachmentsList[i];
					stream.WriteByte(88);
					ProtocolParser.WriteUInt64(stream, (ulong)num);
				}
			}
			if (instance.totalAttachmentSlots != 0)
			{
				stream.WriteByte(96);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.totalAttachmentSlots);
			}
			if (instance.priceMultiplier != 0f)
			{
				stream.WriteByte(109);
				ProtocolParser.WriteSingle(stream, instance.priceMultiplier);
			}
			if (instance.ammoType != 0)
			{
				stream.WriteByte(112);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoType);
			}
			if (instance.ammoCount != 0)
			{
				stream.WriteByte(120);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoCount);
			}
			if (instance.receivedQuantityMultiplier != 0f)
			{
				stream.WriteByte(133);
				stream.WriteByte(1);
				ProtocolParser.WriteSingle(stream, instance.receivedQuantityMultiplier);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class SellOrderContainer : IDisposable, IPooled, IProto<SellOrderContainer>, IProto
	{
		[NonSerialized]
		public List<SellOrder> sellOrders;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(SellOrderContainer instance)
		{
			if (!instance.ShouldPool)
			{
				return;
			}
			if (instance.sellOrders != null)
			{
				for (int i = 0; i < instance.sellOrders.Count; i++)
				{
					if (instance.sellOrders[i] != null)
					{
						instance.sellOrders[i].ResetToPool();
						instance.sellOrders[i] = null;
					}
				}
				List<SellOrder> list = instance.sellOrders;
				Pool.Free<SellOrder>(ref list, false);
				instance.sellOrders = list;
			}
			Pool.Free<SellOrderContainer>(ref instance);
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose SellOrderContainer with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(SellOrderContainer instance)
		{
			if (sellOrders != null)
			{
				instance.sellOrders = Pool.Get<List<SellOrder>>();
				for (int i = 0; i < sellOrders.Count; i++)
				{
					SellOrder item = sellOrders[i].Copy();
					instance.sellOrders.Add(item);
				}
			}
			else
			{
				instance.sellOrders = null;
			}
		}

		public SellOrderContainer Copy()
		{
			SellOrderContainer sellOrderContainer = Pool.Get<SellOrderContainer>();
			CopyTo(sellOrderContainer);
			return sellOrderContainer;
		}

		public static SellOrderContainer Deserialize(BufferStream stream)
		{
			SellOrderContainer sellOrderContainer = Pool.Get<SellOrderContainer>();
			Deserialize(stream, sellOrderContainer, isDelta: false);
			return sellOrderContainer;
		}

		public static SellOrderContainer DeserializeLengthDelimited(BufferStream stream)
		{
			SellOrderContainer sellOrderContainer = Pool.Get<SellOrderContainer>();
			DeserializeLengthDelimited(stream, sellOrderContainer, isDelta: false);
			return sellOrderContainer;
		}

		public static SellOrderContainer DeserializeLength(BufferStream stream, int length)
		{
			SellOrderContainer sellOrderContainer = Pool.Get<SellOrderContainer>();
			DeserializeLength(stream, length, sellOrderContainer, isDelta: false);
			return sellOrderContainer;
		}

		public static SellOrderContainer Deserialize(byte[] buffer)
		{
			SellOrderContainer sellOrderContainer = Pool.Get<SellOrderContainer>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, sellOrderContainer, isDelta: false);
			return sellOrderContainer;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, SellOrderContainer previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static SellOrderContainer Deserialize(BufferStream stream, SellOrderContainer instance, bool isDelta)
		{
			if (!isDelta && instance.sellOrders == null)
			{
				instance.sellOrders = Pool.Get<List<SellOrder>>();
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.sellOrders.Add(SellOrder.DeserializeLengthDelimited(stream));
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static SellOrderContainer DeserializeLengthDelimited(BufferStream stream, SellOrderContainer instance, bool isDelta)
		{
			if (!isDelta && instance.sellOrders == null)
			{
				instance.sellOrders = Pool.Get<List<SellOrder>>();
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.sellOrders.Add(SellOrder.DeserializeLengthDelimited(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static SellOrderContainer DeserializeLength(BufferStream stream, int length, SellOrderContainer instance, bool isDelta)
		{
			if (!isDelta && instance.sellOrders == null)
			{
				instance.sellOrders = Pool.Get<List<SellOrder>>();
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.sellOrders.Add(SellOrder.DeserializeLengthDelimited(stream));
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, SellOrderContainer instance, SellOrderContainer previous)
		{
			if (instance.sellOrders == null)
			{
				return;
			}
			for (int i = 0; i < instance.sellOrders.Count; i++)
			{
				SellOrder sellOrder = instance.sellOrders[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(3);
				int position = stream.Position;
				SellOrder.SerializeDelta(stream, sellOrder, sellOrder);
				int num = stream.Position - position;
				if (num > 2097151)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field sellOrders (ProtoBuf.VendingMachine.SellOrder)");
				}
				Span<byte> span = range.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
				if (num2 < 3)
				{
					span[num2 - 1] |= 128;
					while (num2 < 2)
					{
						span[num2++] = 128;
					}
					span[2] = 0;
				}
			}
		}

		public static void Serialize(BufferStream stream, SellOrderContainer instance)
		{
			if (instance.sellOrders == null)
			{
				return;
			}
			for (int i = 0; i < instance.sellOrders.Count; i++)
			{
				SellOrder instance2 = instance.sellOrders[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(3);
				int position = stream.Position;
				SellOrder.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 2097151)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field sellOrders (ProtoBuf.VendingMachine.SellOrder)");
				}
				Span<byte> span = range.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
				if (num2 < 3)
				{
					span[num2 - 1] |= 128;
					while (num2 < 2)
					{
						span[num2++] = 128;
					}
					span[2] = 0;
				}
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			if (sellOrders != null)
			{
				for (int i = 0; i < sellOrders.Count; i++)
				{
					sellOrders[i]?.InspectUids(action);
				}
			}
		}
	}

	[NonSerialized]
	public SellOrderContainer sellOrderContainer;

	[NonSerialized]
	public string shopName;

	[NonSerialized]
	public int vmoIndex;

	[NonSerialized]
	public NetworkableId networkID;

	[NonSerialized]
	public string translationToken;

	[NonSerialized]
	public ulong nameLastEditedBy;

	[NonSerialized]
	public bool droneAccessible;

	[NonSerialized]
	public bool inDeepSea;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VendingMachine instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.sellOrderContainer != null)
			{
				instance.sellOrderContainer.ResetToPool();
				instance.sellOrderContainer = null;
			}
			instance.shopName = string.Empty;
			instance.vmoIndex = 0;
			instance.networkID = default(NetworkableId);
			instance.translationToken = string.Empty;
			instance.nameLastEditedBy = 0uL;
			instance.droneAccessible = false;
			instance.inDeepSea = false;
			Pool.Free<VendingMachine>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VendingMachine with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VendingMachine instance)
	{
		if (sellOrderContainer != null)
		{
			if (instance.sellOrderContainer == null)
			{
				instance.sellOrderContainer = sellOrderContainer.Copy();
			}
			else
			{
				sellOrderContainer.CopyTo(instance.sellOrderContainer);
			}
		}
		else
		{
			instance.sellOrderContainer = null;
		}
		instance.shopName = shopName;
		instance.vmoIndex = vmoIndex;
		instance.networkID = networkID;
		instance.translationToken = translationToken;
		instance.nameLastEditedBy = nameLastEditedBy;
		instance.droneAccessible = droneAccessible;
		instance.inDeepSea = inDeepSea;
	}

	public VendingMachine Copy()
	{
		VendingMachine vendingMachine = Pool.Get<VendingMachine>();
		CopyTo(vendingMachine);
		return vendingMachine;
	}

	public static VendingMachine Deserialize(BufferStream stream)
	{
		VendingMachine vendingMachine = Pool.Get<VendingMachine>();
		Deserialize(stream, vendingMachine, isDelta: false);
		return vendingMachine;
	}

	public static VendingMachine DeserializeLengthDelimited(BufferStream stream)
	{
		VendingMachine vendingMachine = Pool.Get<VendingMachine>();
		DeserializeLengthDelimited(stream, vendingMachine, isDelta: false);
		return vendingMachine;
	}

	public static VendingMachine DeserializeLength(BufferStream stream, int length)
	{
		VendingMachine vendingMachine = Pool.Get<VendingMachine>();
		DeserializeLength(stream, length, vendingMachine, isDelta: false);
		return vendingMachine;
	}

	public static VendingMachine Deserialize(byte[] buffer)
	{
		VendingMachine vendingMachine = Pool.Get<VendingMachine>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vendingMachine, isDelta: false);
		return vendingMachine;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VendingMachine previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VendingMachine Deserialize(BufferStream stream, VendingMachine instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.sellOrderContainer == null)
				{
					instance.sellOrderContainer = SellOrderContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					SellOrderContainer.DeserializeLengthDelimited(stream, instance.sellOrderContainer, isDelta);
				}
				break;
			case 18:
				instance.shopName = ProtocolParser.ReadString(stream);
				break;
			case 24:
				instance.vmoIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.networkID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 42:
				instance.translationToken = ProtocolParser.ReadString(stream);
				break;
			case 48:
				instance.nameLastEditedBy = ProtocolParser.ReadUInt64(stream);
				break;
			case 56:
				instance.droneAccessible = ProtocolParser.ReadBool(stream);
				break;
			case 64:
				instance.inDeepSea = ProtocolParser.ReadBool(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static VendingMachine DeserializeLengthDelimited(BufferStream stream, VendingMachine instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.sellOrderContainer == null)
				{
					instance.sellOrderContainer = SellOrderContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					SellOrderContainer.DeserializeLengthDelimited(stream, instance.sellOrderContainer, isDelta);
				}
				break;
			case 18:
				instance.shopName = ProtocolParser.ReadString(stream);
				break;
			case 24:
				instance.vmoIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.networkID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 42:
				instance.translationToken = ProtocolParser.ReadString(stream);
				break;
			case 48:
				instance.nameLastEditedBy = ProtocolParser.ReadUInt64(stream);
				break;
			case 56:
				instance.droneAccessible = ProtocolParser.ReadBool(stream);
				break;
			case 64:
				instance.inDeepSea = ProtocolParser.ReadBool(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VendingMachine DeserializeLength(BufferStream stream, int length, VendingMachine instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.sellOrderContainer == null)
				{
					instance.sellOrderContainer = SellOrderContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					SellOrderContainer.DeserializeLengthDelimited(stream, instance.sellOrderContainer, isDelta);
				}
				break;
			case 18:
				instance.shopName = ProtocolParser.ReadString(stream);
				break;
			case 24:
				instance.vmoIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.networkID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 42:
				instance.translationToken = ProtocolParser.ReadString(stream);
				break;
			case 48:
				instance.nameLastEditedBy = ProtocolParser.ReadUInt64(stream);
				break;
			case 56:
				instance.droneAccessible = ProtocolParser.ReadBool(stream);
				break;
			case 64:
				instance.inDeepSea = ProtocolParser.ReadBool(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VendingMachine instance, VendingMachine previous)
	{
		if (instance.sellOrderContainer != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			SellOrderContainer.SerializeDelta(stream, instance.sellOrderContainer, previous.sellOrderContainer);
			int num = stream.Position - position;
			if (num > int.MaxValue)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field sellOrderContainer (ProtoBuf.VendingMachine.SellOrderContainer)");
			}
			Span<byte> span = range.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
			if (num2 < 5)
			{
				span[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span[num2++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.shopName != null && instance.shopName != previous.shopName)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.shopName);
		}
		if (instance.vmoIndex != previous.vmoIndex)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.vmoIndex);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.networkID.Value);
		if (instance.translationToken != null && instance.translationToken != previous.translationToken)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.translationToken);
		}
		if (instance.nameLastEditedBy != previous.nameLastEditedBy)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.nameLastEditedBy);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.droneAccessible);
		stream.WriteByte(64);
		ProtocolParser.WriteBool(stream, instance.inDeepSea);
	}

	public static void Serialize(BufferStream stream, VendingMachine instance)
	{
		if (instance.sellOrderContainer != null)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			SellOrderContainer.Serialize(stream, instance.sellOrderContainer);
			int num = stream.Position - position;
			if (num > int.MaxValue)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field sellOrderContainer (ProtoBuf.VendingMachine.SellOrderContainer)");
			}
			Span<byte> span = range.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
			if (num2 < 5)
			{
				span[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span[num2++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.shopName != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.shopName);
		}
		if (instance.vmoIndex != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.vmoIndex);
		}
		if (instance.networkID != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.networkID.Value);
		}
		if (instance.translationToken != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.translationToken);
		}
		if (instance.nameLastEditedBy != 0L)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.nameLastEditedBy);
		}
		if (instance.droneAccessible)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.droneAccessible);
		}
		if (instance.inDeepSea)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteBool(stream, instance.inDeepSea);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		sellOrderContainer?.InspectUids(action);
		action(UidType.NetworkableId, ref networkID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VendingMachineLongTermStats : IDisposable, IPooled, IProto<VendingMachineLongTermStats>, IProto
{
	[NonSerialized]
	public int numberOfPurchases;

	[NonSerialized]
	public long bestSalesHour;

	[NonSerialized]
	public int uniqueCustomers;

	[NonSerialized]
	public int repeatCustomers;

	[NonSerialized]
	public int bestCustomer;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VendingMachineLongTermStats instance)
	{
		if (instance.ShouldPool)
		{
			instance.numberOfPurchases = 0;
			instance.bestSalesHour = 0L;
			instance.uniqueCustomers = 0;
			instance.repeatCustomers = 0;
			instance.bestCustomer = 0;
			Pool.Free<VendingMachineLongTermStats>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VendingMachineLongTermStats with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VendingMachineLongTermStats instance)
	{
		instance.numberOfPurchases = numberOfPurchases;
		instance.bestSalesHour = bestSalesHour;
		instance.uniqueCustomers = uniqueCustomers;
		instance.repeatCustomers = repeatCustomers;
		instance.bestCustomer = bestCustomer;
	}

	public VendingMachineLongTermStats Copy()
	{
		VendingMachineLongTermStats vendingMachineLongTermStats = Pool.Get<VendingMachineLongTermStats>();
		CopyTo(vendingMachineLongTermStats);
		return vendingMachineLongTermStats;
	}

	public static VendingMachineLongTermStats Deserialize(BufferStream stream)
	{
		VendingMachineLongTermStats vendingMachineLongTermStats = Pool.Get<VendingMachineLongTermStats>();
		Deserialize(stream, vendingMachineLongTermStats, isDelta: false);
		return vendingMachineLongTermStats;
	}

	public static VendingMachineLongTermStats DeserializeLengthDelimited(BufferStream stream)
	{
		VendingMachineLongTermStats vendingMachineLongTermStats = Pool.Get<VendingMachineLongTermStats>();
		DeserializeLengthDelimited(stream, vendingMachineLongTermStats, isDelta: false);
		return vendingMachineLongTermStats;
	}

	public static VendingMachineLongTermStats DeserializeLength(BufferStream stream, int length)
	{
		VendingMachineLongTermStats vendingMachineLongTermStats = Pool.Get<VendingMachineLongTermStats>();
		DeserializeLength(stream, length, vendingMachineLongTermStats, isDelta: false);
		return vendingMachineLongTermStats;
	}

	public static VendingMachineLongTermStats Deserialize(byte[] buffer)
	{
		VendingMachineLongTermStats vendingMachineLongTermStats = Pool.Get<VendingMachineLongTermStats>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vendingMachineLongTermStats, isDelta: false);
		return vendingMachineLongTermStats;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VendingMachineLongTermStats previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VendingMachineLongTermStats Deserialize(BufferStream stream, VendingMachineLongTermStats instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.numberOfPurchases = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.bestSalesHour = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.uniqueCustomers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.repeatCustomers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.bestCustomer = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VendingMachineLongTermStats DeserializeLengthDelimited(BufferStream stream, VendingMachineLongTermStats instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.numberOfPurchases = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.bestSalesHour = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.uniqueCustomers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.repeatCustomers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.bestCustomer = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VendingMachineLongTermStats DeserializeLength(BufferStream stream, int length, VendingMachineLongTermStats instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.numberOfPurchases = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.bestSalesHour = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.uniqueCustomers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.repeatCustomers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.bestCustomer = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VendingMachineLongTermStats instance, VendingMachineLongTermStats previous)
	{
		if (instance.numberOfPurchases != previous.numberOfPurchases)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.numberOfPurchases);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.bestSalesHour);
		if (instance.uniqueCustomers != previous.uniqueCustomers)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.uniqueCustomers);
		}
		if (instance.repeatCustomers != previous.repeatCustomers)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.repeatCustomers);
		}
		if (instance.bestCustomer != previous.bestCustomer)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.bestCustomer);
		}
	}

	public static void Serialize(BufferStream stream, VendingMachineLongTermStats instance)
	{
		if (instance.numberOfPurchases != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.numberOfPurchases);
		}
		if (instance.bestSalesHour != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.bestSalesHour);
		}
		if (instance.uniqueCustomers != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.uniqueCustomers);
		}
		if (instance.repeatCustomers != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.repeatCustomers);
		}
		if (instance.bestCustomer != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.bestCustomer);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VendingMachinePurchaseHistoryEntryMessage : IDisposable, IPooled, IProto<VendingMachinePurchaseHistoryEntryMessage>, IProto
{
	[NonSerialized]
	public int itemID;

	[NonSerialized]
	public int amount;

	[NonSerialized]
	public int priceID;

	[NonSerialized]
	public int price;

	[NonSerialized]
	public int dateTime;

	[NonSerialized]
	public bool itemIsBp;

	[NonSerialized]
	public bool priceIsBp;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VendingMachinePurchaseHistoryEntryMessage instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemID = 0;
			instance.amount = 0;
			instance.priceID = 0;
			instance.price = 0;
			instance.dateTime = 0;
			instance.itemIsBp = false;
			instance.priceIsBp = false;
			Pool.Free<VendingMachinePurchaseHistoryEntryMessage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VendingMachinePurchaseHistoryEntryMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VendingMachinePurchaseHistoryEntryMessage instance)
	{
		instance.itemID = itemID;
		instance.amount = amount;
		instance.priceID = priceID;
		instance.price = price;
		instance.dateTime = dateTime;
		instance.itemIsBp = itemIsBp;
		instance.priceIsBp = priceIsBp;
	}

	public VendingMachinePurchaseHistoryEntryMessage Copy()
	{
		VendingMachinePurchaseHistoryEntryMessage vendingMachinePurchaseHistoryEntryMessage = Pool.Get<VendingMachinePurchaseHistoryEntryMessage>();
		CopyTo(vendingMachinePurchaseHistoryEntryMessage);
		return vendingMachinePurchaseHistoryEntryMessage;
	}

	public static VendingMachinePurchaseHistoryEntryMessage Deserialize(BufferStream stream)
	{
		VendingMachinePurchaseHistoryEntryMessage vendingMachinePurchaseHistoryEntryMessage = Pool.Get<VendingMachinePurchaseHistoryEntryMessage>();
		Deserialize(stream, vendingMachinePurchaseHistoryEntryMessage, isDelta: false);
		return vendingMachinePurchaseHistoryEntryMessage;
	}

	public static VendingMachinePurchaseHistoryEntryMessage DeserializeLengthDelimited(BufferStream stream)
	{
		VendingMachinePurchaseHistoryEntryMessage vendingMachinePurchaseHistoryEntryMessage = Pool.Get<VendingMachinePurchaseHistoryEntryMessage>();
		DeserializeLengthDelimited(stream, vendingMachinePurchaseHistoryEntryMessage, isDelta: false);
		return vendingMachinePurchaseHistoryEntryMessage;
	}

	public static VendingMachinePurchaseHistoryEntryMessage DeserializeLength(BufferStream stream, int length)
	{
		VendingMachinePurchaseHistoryEntryMessage vendingMachinePurchaseHistoryEntryMessage = Pool.Get<VendingMachinePurchaseHistoryEntryMessage>();
		DeserializeLength(stream, length, vendingMachinePurchaseHistoryEntryMessage, isDelta: false);
		return vendingMachinePurchaseHistoryEntryMessage;
	}

	public static VendingMachinePurchaseHistoryEntryMessage Deserialize(byte[] buffer)
	{
		VendingMachinePurchaseHistoryEntryMessage vendingMachinePurchaseHistoryEntryMessage = Pool.Get<VendingMachinePurchaseHistoryEntryMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vendingMachinePurchaseHistoryEntryMessage, isDelta: false);
		return vendingMachinePurchaseHistoryEntryMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VendingMachinePurchaseHistoryEntryMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VendingMachinePurchaseHistoryEntryMessage Deserialize(BufferStream stream, VendingMachinePurchaseHistoryEntryMessage instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.priceID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.price = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.dateTime = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.itemIsBp = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.priceIsBp = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VendingMachinePurchaseHistoryEntryMessage DeserializeLengthDelimited(BufferStream stream, VendingMachinePurchaseHistoryEntryMessage instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.priceID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.price = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.dateTime = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.itemIsBp = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.priceIsBp = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VendingMachinePurchaseHistoryEntryMessage DeserializeLength(BufferStream stream, int length, VendingMachinePurchaseHistoryEntryMessage instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.priceID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.price = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.dateTime = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.itemIsBp = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.priceIsBp = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VendingMachinePurchaseHistoryEntryMessage instance, VendingMachinePurchaseHistoryEntryMessage previous)
	{
		if (instance.itemID != previous.itemID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.amount != previous.amount)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
		if (instance.priceID != previous.priceID)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.priceID);
		}
		if (instance.price != previous.price)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.price);
		}
		if (instance.dateTime != previous.dateTime)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.dateTime);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.itemIsBp);
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.priceIsBp);
	}

	public static void Serialize(BufferStream stream, VendingMachinePurchaseHistoryEntryMessage instance)
	{
		if (instance.itemID != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.amount != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
		if (instance.priceID != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.priceID);
		}
		if (instance.price != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.price);
		}
		if (instance.dateTime != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.dateTime);
		}
		if (instance.itemIsBp)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.itemIsBp);
		}
		if (instance.priceIsBp)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.priceIsBp);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VendingMachinePurchaseHistoryEntrySmallMessage : IDisposable, IPooled, IProto<VendingMachinePurchaseHistoryEntrySmallMessage>, IProto
{
	[NonSerialized]
	public int itemID;

	[NonSerialized]
	public int amount;

	[NonSerialized]
	public int priceID;

	[NonSerialized]
	public int price;

	[NonSerialized]
	public bool itemIsBp;

	[NonSerialized]
	public bool priceIsBp;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VendingMachinePurchaseHistoryEntrySmallMessage instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemID = 0;
			instance.amount = 0;
			instance.priceID = 0;
			instance.price = 0;
			instance.itemIsBp = false;
			instance.priceIsBp = false;
			Pool.Free<VendingMachinePurchaseHistoryEntrySmallMessage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VendingMachinePurchaseHistoryEntrySmallMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VendingMachinePurchaseHistoryEntrySmallMessage instance)
	{
		instance.itemID = itemID;
		instance.amount = amount;
		instance.priceID = priceID;
		instance.price = price;
		instance.itemIsBp = itemIsBp;
		instance.priceIsBp = priceIsBp;
	}

	public VendingMachinePurchaseHistoryEntrySmallMessage Copy()
	{
		VendingMachinePurchaseHistoryEntrySmallMessage vendingMachinePurchaseHistoryEntrySmallMessage = Pool.Get<VendingMachinePurchaseHistoryEntrySmallMessage>();
		CopyTo(vendingMachinePurchaseHistoryEntrySmallMessage);
		return vendingMachinePurchaseHistoryEntrySmallMessage;
	}

	public static VendingMachinePurchaseHistoryEntrySmallMessage Deserialize(BufferStream stream)
	{
		VendingMachinePurchaseHistoryEntrySmallMessage vendingMachinePurchaseHistoryEntrySmallMessage = Pool.Get<VendingMachinePurchaseHistoryEntrySmallMessage>();
		Deserialize(stream, vendingMachinePurchaseHistoryEntrySmallMessage, isDelta: false);
		return vendingMachinePurchaseHistoryEntrySmallMessage;
	}

	public static VendingMachinePurchaseHistoryEntrySmallMessage DeserializeLengthDelimited(BufferStream stream)
	{
		VendingMachinePurchaseHistoryEntrySmallMessage vendingMachinePurchaseHistoryEntrySmallMessage = Pool.Get<VendingMachinePurchaseHistoryEntrySmallMessage>();
		DeserializeLengthDelimited(stream, vendingMachinePurchaseHistoryEntrySmallMessage, isDelta: false);
		return vendingMachinePurchaseHistoryEntrySmallMessage;
	}

	public static VendingMachinePurchaseHistoryEntrySmallMessage DeserializeLength(BufferStream stream, int length)
	{
		VendingMachinePurchaseHistoryEntrySmallMessage vendingMachinePurchaseHistoryEntrySmallMessage = Pool.Get<VendingMachinePurchaseHistoryEntrySmallMessage>();
		DeserializeLength(stream, length, vendingMachinePurchaseHistoryEntrySmallMessage, isDelta: false);
		return vendingMachinePurchaseHistoryEntrySmallMessage;
	}

	public static VendingMachinePurchaseHistoryEntrySmallMessage Deserialize(byte[] buffer)
	{
		VendingMachinePurchaseHistoryEntrySmallMessage vendingMachinePurchaseHistoryEntrySmallMessage = Pool.Get<VendingMachinePurchaseHistoryEntrySmallMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vendingMachinePurchaseHistoryEntrySmallMessage, isDelta: false);
		return vendingMachinePurchaseHistoryEntrySmallMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VendingMachinePurchaseHistoryEntrySmallMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VendingMachinePurchaseHistoryEntrySmallMessage Deserialize(BufferStream stream, VendingMachinePurchaseHistoryEntrySmallMessage instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.priceID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.price = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.itemIsBp = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.priceIsBp = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VendingMachinePurchaseHistoryEntrySmallMessage DeserializeLengthDelimited(BufferStream stream, VendingMachinePurchaseHistoryEntrySmallMessage instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.priceID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.price = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.itemIsBp = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.priceIsBp = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VendingMachinePurchaseHistoryEntrySmallMessage DeserializeLength(BufferStream stream, int length, VendingMachinePurchaseHistoryEntrySmallMessage instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.priceID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.price = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.itemIsBp = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.priceIsBp = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VendingMachinePurchaseHistoryEntrySmallMessage instance, VendingMachinePurchaseHistoryEntrySmallMessage previous)
	{
		if (instance.itemID != previous.itemID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.amount != previous.amount)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
		if (instance.priceID != previous.priceID)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.priceID);
		}
		if (instance.price != previous.price)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.price);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.itemIsBp);
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.priceIsBp);
	}

	public static void Serialize(BufferStream stream, VendingMachinePurchaseHistoryEntrySmallMessage instance)
	{
		if (instance.itemID != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.amount != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
		if (instance.priceID != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.priceID);
		}
		if (instance.price != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.price);
		}
		if (instance.itemIsBp)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.itemIsBp);
		}
		if (instance.priceIsBp)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.priceIsBp);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VendingMachinePurchaseHistoryMessage : IDisposable, IPooled, IProto<VendingMachinePurchaseHistoryMessage>, IProto
{
	[NonSerialized]
	public List<VendingMachinePurchaseHistoryEntryMessage> transactions;

	[NonSerialized]
	public List<VendingMachinePurchaseHistoryEntrySmallMessage> smallTransactions;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VendingMachinePurchaseHistoryMessage instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.transactions != null)
		{
			for (int i = 0; i < instance.transactions.Count; i++)
			{
				if (instance.transactions[i] != null)
				{
					instance.transactions[i].ResetToPool();
					instance.transactions[i] = null;
				}
			}
			List<VendingMachinePurchaseHistoryEntryMessage> list = instance.transactions;
			Pool.Free<VendingMachinePurchaseHistoryEntryMessage>(ref list, false);
			instance.transactions = list;
		}
		if (instance.smallTransactions != null)
		{
			for (int j = 0; j < instance.smallTransactions.Count; j++)
			{
				if (instance.smallTransactions[j] != null)
				{
					instance.smallTransactions[j].ResetToPool();
					instance.smallTransactions[j] = null;
				}
			}
			List<VendingMachinePurchaseHistoryEntrySmallMessage> list2 = instance.smallTransactions;
			Pool.Free<VendingMachinePurchaseHistoryEntrySmallMessage>(ref list2, false);
			instance.smallTransactions = list2;
		}
		Pool.Free<VendingMachinePurchaseHistoryMessage>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VendingMachinePurchaseHistoryMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VendingMachinePurchaseHistoryMessage instance)
	{
		if (transactions != null)
		{
			instance.transactions = Pool.Get<List<VendingMachinePurchaseHistoryEntryMessage>>();
			for (int i = 0; i < transactions.Count; i++)
			{
				VendingMachinePurchaseHistoryEntryMessage item = transactions[i].Copy();
				instance.transactions.Add(item);
			}
		}
		else
		{
			instance.transactions = null;
		}
		if (smallTransactions != null)
		{
			instance.smallTransactions = Pool.Get<List<VendingMachinePurchaseHistoryEntrySmallMessage>>();
			for (int j = 0; j < smallTransactions.Count; j++)
			{
				VendingMachinePurchaseHistoryEntrySmallMessage item2 = smallTransactions[j].Copy();
				instance.smallTransactions.Add(item2);
			}
		}
		else
		{
			instance.smallTransactions = null;
		}
	}

	public VendingMachinePurchaseHistoryMessage Copy()
	{
		VendingMachinePurchaseHistoryMessage vendingMachinePurchaseHistoryMessage = Pool.Get<VendingMachinePurchaseHistoryMessage>();
		CopyTo(vendingMachinePurchaseHistoryMessage);
		return vendingMachinePurchaseHistoryMessage;
	}

	public static VendingMachinePurchaseHistoryMessage Deserialize(BufferStream stream)
	{
		VendingMachinePurchaseHistoryMessage vendingMachinePurchaseHistoryMessage = Pool.Get<VendingMachinePurchaseHistoryMessage>();
		Deserialize(stream, vendingMachinePurchaseHistoryMessage, isDelta: false);
		return vendingMachinePurchaseHistoryMessage;
	}

	public static VendingMachinePurchaseHistoryMessage DeserializeLengthDelimited(BufferStream stream)
	{
		VendingMachinePurchaseHistoryMessage vendingMachinePurchaseHistoryMessage = Pool.Get<VendingMachinePurchaseHistoryMessage>();
		DeserializeLengthDelimited(stream, vendingMachinePurchaseHistoryMessage, isDelta: false);
		return vendingMachinePurchaseHistoryMessage;
	}

	public static VendingMachinePurchaseHistoryMessage DeserializeLength(BufferStream stream, int length)
	{
		VendingMachinePurchaseHistoryMessage vendingMachinePurchaseHistoryMessage = Pool.Get<VendingMachinePurchaseHistoryMessage>();
		DeserializeLength(stream, length, vendingMachinePurchaseHistoryMessage, isDelta: false);
		return vendingMachinePurchaseHistoryMessage;
	}

	public static VendingMachinePurchaseHistoryMessage Deserialize(byte[] buffer)
	{
		VendingMachinePurchaseHistoryMessage vendingMachinePurchaseHistoryMessage = Pool.Get<VendingMachinePurchaseHistoryMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vendingMachinePurchaseHistoryMessage, isDelta: false);
		return vendingMachinePurchaseHistoryMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VendingMachinePurchaseHistoryMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VendingMachinePurchaseHistoryMessage Deserialize(BufferStream stream, VendingMachinePurchaseHistoryMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.transactions == null)
			{
				instance.transactions = Pool.Get<List<VendingMachinePurchaseHistoryEntryMessage>>();
			}
			if (instance.smallTransactions == null)
			{
				instance.smallTransactions = Pool.Get<List<VendingMachinePurchaseHistoryEntrySmallMessage>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.transactions.Add(VendingMachinePurchaseHistoryEntryMessage.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				instance.smallTransactions.Add(VendingMachinePurchaseHistoryEntrySmallMessage.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VendingMachinePurchaseHistoryMessage DeserializeLengthDelimited(BufferStream stream, VendingMachinePurchaseHistoryMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.transactions == null)
			{
				instance.transactions = Pool.Get<List<VendingMachinePurchaseHistoryEntryMessage>>();
			}
			if (instance.smallTransactions == null)
			{
				instance.smallTransactions = Pool.Get<List<VendingMachinePurchaseHistoryEntrySmallMessage>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.transactions.Add(VendingMachinePurchaseHistoryEntryMessage.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				instance.smallTransactions.Add(VendingMachinePurchaseHistoryEntrySmallMessage.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VendingMachinePurchaseHistoryMessage DeserializeLength(BufferStream stream, int length, VendingMachinePurchaseHistoryMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.transactions == null)
			{
				instance.transactions = Pool.Get<List<VendingMachinePurchaseHistoryEntryMessage>>();
			}
			if (instance.smallTransactions == null)
			{
				instance.smallTransactions = Pool.Get<List<VendingMachinePurchaseHistoryEntrySmallMessage>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.transactions.Add(VendingMachinePurchaseHistoryEntryMessage.DeserializeLengthDelimited(stream));
				continue;
			case 18:
				instance.smallTransactions.Add(VendingMachinePurchaseHistoryEntrySmallMessage.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VendingMachinePurchaseHistoryMessage instance, VendingMachinePurchaseHistoryMessage previous)
	{
		if (instance.transactions != null)
		{
			for (int i = 0; i < instance.transactions.Count; i++)
			{
				VendingMachinePurchaseHistoryEntryMessage vendingMachinePurchaseHistoryEntryMessage = instance.transactions[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				VendingMachinePurchaseHistoryEntryMessage.SerializeDelta(stream, vendingMachinePurchaseHistoryEntryMessage, vendingMachinePurchaseHistoryEntryMessage);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field transactions (ProtoBuf.VendingMachinePurchaseHistoryEntryMessage)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.smallTransactions == null)
		{
			return;
		}
		for (int j = 0; j < instance.smallTransactions.Count; j++)
		{
			VendingMachinePurchaseHistoryEntrySmallMessage vendingMachinePurchaseHistoryEntrySmallMessage = instance.smallTransactions[j];
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			VendingMachinePurchaseHistoryEntrySmallMessage.SerializeDelta(stream, vendingMachinePurchaseHistoryEntrySmallMessage, vendingMachinePurchaseHistoryEntrySmallMessage);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field smallTransactions (ProtoBuf.VendingMachinePurchaseHistoryEntrySmallMessage)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public static void Serialize(BufferStream stream, VendingMachinePurchaseHistoryMessage instance)
	{
		if (instance.transactions != null)
		{
			for (int i = 0; i < instance.transactions.Count; i++)
			{
				VendingMachinePurchaseHistoryEntryMessage instance2 = instance.transactions[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				VendingMachinePurchaseHistoryEntryMessage.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field transactions (ProtoBuf.VendingMachinePurchaseHistoryEntryMessage)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.smallTransactions == null)
		{
			return;
		}
		for (int j = 0; j < instance.smallTransactions.Count; j++)
		{
			VendingMachinePurchaseHistoryEntrySmallMessage instance3 = instance.smallTransactions[j];
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			VendingMachinePurchaseHistoryEntrySmallMessage.Serialize(stream, instance3);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field smallTransactions (ProtoBuf.VendingMachinePurchaseHistoryEntrySmallMessage)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (transactions != null)
		{
			for (int i = 0; i < transactions.Count; i++)
			{
				transactions[i]?.InspectUids(action);
			}
		}
		if (smallTransactions != null)
		{
			for (int j = 0; j < smallTransactions.Count; j++)
			{
				smallTransactions[j]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VendingMachineStats : IDisposable, IPooled, IProto<VendingMachineStats>, IProto
{
	[NonSerialized]
	public List<VendingMachinePurchaseHistoryEntryMessage> purchaseHistory;

	[NonSerialized]
	public List<ulong> customers;

	[NonSerialized]
	public List<int> customersVisits;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VendingMachineStats instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.purchaseHistory != null)
		{
			for (int i = 0; i < instance.purchaseHistory.Count; i++)
			{
				if (instance.purchaseHistory[i] != null)
				{
					instance.purchaseHistory[i].ResetToPool();
					instance.purchaseHistory[i] = null;
				}
			}
			List<VendingMachinePurchaseHistoryEntryMessage> list = instance.purchaseHistory;
			Pool.Free<VendingMachinePurchaseHistoryEntryMessage>(ref list, false);
			instance.purchaseHistory = list;
		}
		if (instance.customers != null)
		{
			List<ulong> list2 = instance.customers;
			Pool.FreeUnmanaged<ulong>(ref list2);
			instance.customers = list2;
		}
		if (instance.customersVisits != null)
		{
			List<int> list3 = instance.customersVisits;
			Pool.FreeUnmanaged<int>(ref list3);
			instance.customersVisits = list3;
		}
		Pool.Free<VendingMachineStats>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VendingMachineStats with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VendingMachineStats instance)
	{
		if (purchaseHistory != null)
		{
			instance.purchaseHistory = Pool.Get<List<VendingMachinePurchaseHistoryEntryMessage>>();
			for (int i = 0; i < purchaseHistory.Count; i++)
			{
				VendingMachinePurchaseHistoryEntryMessage item = purchaseHistory[i].Copy();
				instance.purchaseHistory.Add(item);
			}
		}
		else
		{
			instance.purchaseHistory = null;
		}
		if (customers != null)
		{
			instance.customers = Pool.Get<List<ulong>>();
			for (int j = 0; j < customers.Count; j++)
			{
				ulong item2 = customers[j];
				instance.customers.Add(item2);
			}
		}
		else
		{
			instance.customers = null;
		}
		if (customersVisits != null)
		{
			instance.customersVisits = Pool.Get<List<int>>();
			for (int k = 0; k < customersVisits.Count; k++)
			{
				int item3 = customersVisits[k];
				instance.customersVisits.Add(item3);
			}
		}
		else
		{
			instance.customersVisits = null;
		}
	}

	public VendingMachineStats Copy()
	{
		VendingMachineStats vendingMachineStats = Pool.Get<VendingMachineStats>();
		CopyTo(vendingMachineStats);
		return vendingMachineStats;
	}

	public static VendingMachineStats Deserialize(BufferStream stream)
	{
		VendingMachineStats vendingMachineStats = Pool.Get<VendingMachineStats>();
		Deserialize(stream, vendingMachineStats, isDelta: false);
		return vendingMachineStats;
	}

	public static VendingMachineStats DeserializeLengthDelimited(BufferStream stream)
	{
		VendingMachineStats vendingMachineStats = Pool.Get<VendingMachineStats>();
		DeserializeLengthDelimited(stream, vendingMachineStats, isDelta: false);
		return vendingMachineStats;
	}

	public static VendingMachineStats DeserializeLength(BufferStream stream, int length)
	{
		VendingMachineStats vendingMachineStats = Pool.Get<VendingMachineStats>();
		DeserializeLength(stream, length, vendingMachineStats, isDelta: false);
		return vendingMachineStats;
	}

	public static VendingMachineStats Deserialize(byte[] buffer)
	{
		VendingMachineStats vendingMachineStats = Pool.Get<VendingMachineStats>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vendingMachineStats, isDelta: false);
		return vendingMachineStats;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VendingMachineStats previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VendingMachineStats Deserialize(BufferStream stream, VendingMachineStats instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.purchaseHistory == null)
			{
				instance.purchaseHistory = Pool.Get<List<VendingMachinePurchaseHistoryEntryMessage>>();
			}
			if (instance.customers == null)
			{
				instance.customers = Pool.Get<List<ulong>>();
			}
			if (instance.customersVisits == null)
			{
				instance.customersVisits = Pool.Get<List<int>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.purchaseHistory.Add(VendingMachinePurchaseHistoryEntryMessage.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.customers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.customersVisits.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VendingMachineStats DeserializeLengthDelimited(BufferStream stream, VendingMachineStats instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.purchaseHistory == null)
			{
				instance.purchaseHistory = Pool.Get<List<VendingMachinePurchaseHistoryEntryMessage>>();
			}
			if (instance.customers == null)
			{
				instance.customers = Pool.Get<List<ulong>>();
			}
			if (instance.customersVisits == null)
			{
				instance.customersVisits = Pool.Get<List<int>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.purchaseHistory.Add(VendingMachinePurchaseHistoryEntryMessage.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.customers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.customersVisits.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VendingMachineStats DeserializeLength(BufferStream stream, int length, VendingMachineStats instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.purchaseHistory == null)
			{
				instance.purchaseHistory = Pool.Get<List<VendingMachinePurchaseHistoryEntryMessage>>();
			}
			if (instance.customers == null)
			{
				instance.customers = Pool.Get<List<ulong>>();
			}
			if (instance.customersVisits == null)
			{
				instance.customersVisits = Pool.Get<List<int>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.purchaseHistory.Add(VendingMachinePurchaseHistoryEntryMessage.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.customers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.customersVisits.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VendingMachineStats instance, VendingMachineStats previous)
	{
		if (instance.purchaseHistory != null)
		{
			for (int i = 0; i < instance.purchaseHistory.Count; i++)
			{
				VendingMachinePurchaseHistoryEntryMessage vendingMachinePurchaseHistoryEntryMessage = instance.purchaseHistory[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				VendingMachinePurchaseHistoryEntryMessage.SerializeDelta(stream, vendingMachinePurchaseHistoryEntryMessage, vendingMachinePurchaseHistoryEntryMessage);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field purchaseHistory (ProtoBuf.VendingMachinePurchaseHistoryEntryMessage)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.customers != null)
		{
			for (int j = 0; j < instance.customers.Count; j++)
			{
				ulong val = instance.customers[j];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
		if (instance.customersVisits != null)
		{
			for (int k = 0; k < instance.customersVisits.Count; k++)
			{
				int num2 = instance.customersVisits[k];
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)num2);
			}
		}
	}

	public static void Serialize(BufferStream stream, VendingMachineStats instance)
	{
		if (instance.purchaseHistory != null)
		{
			for (int i = 0; i < instance.purchaseHistory.Count; i++)
			{
				VendingMachinePurchaseHistoryEntryMessage instance2 = instance.purchaseHistory[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				VendingMachinePurchaseHistoryEntryMessage.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field purchaseHistory (ProtoBuf.VendingMachinePurchaseHistoryEntryMessage)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.customers != null)
		{
			for (int j = 0; j < instance.customers.Count; j++)
			{
				ulong val = instance.customers[j];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
		if (instance.customersVisits != null)
		{
			for (int k = 0; k < instance.customersVisits.Count; k++)
			{
				int num2 = instance.customersVisits[k];
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)num2);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (purchaseHistory != null)
		{
			for (int i = 0; i < purchaseHistory.Count; i++)
			{
				purchaseHistory[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VineDestination : IDisposable, IPooled, IProto<VineDestination>, IProto
{
	[NonSerialized]
	public NetworkableId targetTree;

	[NonSerialized]
	public int index;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VineDestination instance)
	{
		if (instance.ShouldPool)
		{
			instance.targetTree = default(NetworkableId);
			instance.index = 0;
			Pool.Free<VineDestination>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VineDestination with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VineDestination instance)
	{
		instance.targetTree = targetTree;
		instance.index = index;
	}

	public VineDestination Copy()
	{
		VineDestination vineDestination = Pool.Get<VineDestination>();
		CopyTo(vineDestination);
		return vineDestination;
	}

	public static VineDestination Deserialize(BufferStream stream)
	{
		VineDestination vineDestination = Pool.Get<VineDestination>();
		Deserialize(stream, vineDestination, isDelta: false);
		return vineDestination;
	}

	public static VineDestination DeserializeLengthDelimited(BufferStream stream)
	{
		VineDestination vineDestination = Pool.Get<VineDestination>();
		DeserializeLengthDelimited(stream, vineDestination, isDelta: false);
		return vineDestination;
	}

	public static VineDestination DeserializeLength(BufferStream stream, int length)
	{
		VineDestination vineDestination = Pool.Get<VineDestination>();
		DeserializeLength(stream, length, vineDestination, isDelta: false);
		return vineDestination;
	}

	public static VineDestination Deserialize(byte[] buffer)
	{
		VineDestination vineDestination = Pool.Get<VineDestination>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vineDestination, isDelta: false);
		return vineDestination;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VineDestination previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VineDestination Deserialize(BufferStream stream, VineDestination instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.targetTree = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.index = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VineDestination DeserializeLengthDelimited(BufferStream stream, VineDestination instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetTree = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.index = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VineDestination DeserializeLength(BufferStream stream, int length, VineDestination instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetTree = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.index = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VineDestination instance, VineDestination previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.targetTree.Value);
		if (instance.index != previous.index)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.index);
		}
	}

	public static void Serialize(BufferStream stream, VineDestination instance)
	{
		if (instance.targetTree != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.targetTree.Value);
		}
		if (instance.index != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.index);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref targetTree.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class VineMountable : IDisposable, IPooled, IProto<VineMountable>, IProto
{
	[NonSerialized]
	public Vector3 anchorPoint;

	[NonSerialized]
	public VineDestination originPoint;

	[NonSerialized]
	public List<VineDestination> destinations;

	[NonSerialized]
	public VineDestination currentLocation;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VineMountable instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.anchorPoint = default(Vector3);
		if (instance.originPoint != null)
		{
			instance.originPoint.ResetToPool();
			instance.originPoint = null;
		}
		if (instance.destinations != null)
		{
			for (int i = 0; i < instance.destinations.Count; i++)
			{
				if (instance.destinations[i] != null)
				{
					instance.destinations[i].ResetToPool();
					instance.destinations[i] = null;
				}
			}
			List<VineDestination> list = instance.destinations;
			Pool.Free<VineDestination>(ref list, false);
			instance.destinations = list;
		}
		if (instance.currentLocation != null)
		{
			instance.currentLocation.ResetToPool();
			instance.currentLocation = null;
		}
		Pool.Free<VineMountable>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VineMountable with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VineMountable instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		instance.anchorPoint = anchorPoint;
		if (originPoint != null)
		{
			if (instance.originPoint == null)
			{
				instance.originPoint = originPoint.Copy();
			}
			else
			{
				originPoint.CopyTo(instance.originPoint);
			}
		}
		else
		{
			instance.originPoint = null;
		}
		if (destinations != null)
		{
			instance.destinations = Pool.Get<List<VineDestination>>();
			for (int i = 0; i < destinations.Count; i++)
			{
				VineDestination item = destinations[i].Copy();
				instance.destinations.Add(item);
			}
		}
		else
		{
			instance.destinations = null;
		}
		if (currentLocation != null)
		{
			if (instance.currentLocation == null)
			{
				instance.currentLocation = currentLocation.Copy();
			}
			else
			{
				currentLocation.CopyTo(instance.currentLocation);
			}
		}
		else
		{
			instance.currentLocation = null;
		}
	}

	public VineMountable Copy()
	{
		VineMountable vineMountable = Pool.Get<VineMountable>();
		CopyTo(vineMountable);
		return vineMountable;
	}

	public static VineMountable Deserialize(BufferStream stream)
	{
		VineMountable vineMountable = Pool.Get<VineMountable>();
		Deserialize(stream, vineMountable, isDelta: false);
		return vineMountable;
	}

	public static VineMountable DeserializeLengthDelimited(BufferStream stream)
	{
		VineMountable vineMountable = Pool.Get<VineMountable>();
		DeserializeLengthDelimited(stream, vineMountable, isDelta: false);
		return vineMountable;
	}

	public static VineMountable DeserializeLength(BufferStream stream, int length)
	{
		VineMountable vineMountable = Pool.Get<VineMountable>();
		DeserializeLength(stream, length, vineMountable, isDelta: false);
		return vineMountable;
	}

	public static VineMountable Deserialize(byte[] buffer)
	{
		VineMountable vineMountable = Pool.Get<VineMountable>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vineMountable, isDelta: false);
		return vineMountable;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VineMountable previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VineMountable Deserialize(BufferStream stream, VineMountable instance, bool isDelta)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.destinations == null)
		{
			instance.destinations = Pool.Get<List<VineDestination>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.anchorPoint, isDelta);
				break;
			case 18:
				if (instance.originPoint == null)
				{
					instance.originPoint = VineDestination.DeserializeLengthDelimited(stream);
				}
				else
				{
					VineDestination.DeserializeLengthDelimited(stream, instance.originPoint, isDelta);
				}
				break;
			case 26:
				instance.destinations.Add(VineDestination.DeserializeLengthDelimited(stream));
				break;
			case 34:
				if (instance.currentLocation == null)
				{
					instance.currentLocation = VineDestination.DeserializeLengthDelimited(stream);
				}
				else
				{
					VineDestination.DeserializeLengthDelimited(stream, instance.currentLocation, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static VineMountable DeserializeLengthDelimited(BufferStream stream, VineMountable instance, bool isDelta)
	{
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.destinations == null)
		{
			instance.destinations = Pool.Get<List<VineDestination>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.anchorPoint, isDelta);
				break;
			case 18:
				if (instance.originPoint == null)
				{
					instance.originPoint = VineDestination.DeserializeLengthDelimited(stream);
				}
				else
				{
					VineDestination.DeserializeLengthDelimited(stream, instance.originPoint, isDelta);
				}
				break;
			case 26:
				instance.destinations.Add(VineDestination.DeserializeLengthDelimited(stream));
				break;
			case 34:
				if (instance.currentLocation == null)
				{
					instance.currentLocation = VineDestination.DeserializeLengthDelimited(stream);
				}
				else
				{
					VineDestination.DeserializeLengthDelimited(stream, instance.currentLocation, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VineMountable DeserializeLength(BufferStream stream, int length, VineMountable instance, bool isDelta)
	{
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.destinations == null)
		{
			instance.destinations = Pool.Get<List<VineDestination>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.anchorPoint, isDelta);
				break;
			case 18:
				if (instance.originPoint == null)
				{
					instance.originPoint = VineDestination.DeserializeLengthDelimited(stream);
				}
				else
				{
					VineDestination.DeserializeLengthDelimited(stream, instance.originPoint, isDelta);
				}
				break;
			case 26:
				instance.destinations.Add(VineDestination.DeserializeLengthDelimited(stream));
				break;
			case 34:
				if (instance.currentLocation == null)
				{
					instance.currentLocation = VineDestination.DeserializeLengthDelimited(stream);
				}
				else
				{
					VineDestination.DeserializeLengthDelimited(stream, instance.currentLocation, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VineMountable instance, VineMountable previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.anchorPoint != previous.anchorPoint)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.anchorPoint, previous.anchorPoint);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field anchorPoint (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.originPoint != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			VineDestination.SerializeDelta(stream, instance.originPoint, previous.originPoint);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field originPoint (ProtoBuf.VineDestination)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.destinations != null)
		{
			for (int i = 0; i < instance.destinations.Count; i++)
			{
				VineDestination vineDestination = instance.destinations[i];
				stream.WriteByte(26);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int position3 = stream.Position;
				VineDestination.SerializeDelta(stream, vineDestination, vineDestination);
				int num3 = stream.Position - position3;
				if (num3 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field destinations (ProtoBuf.VineDestination)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			}
		}
		if (instance.currentLocation != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			VineDestination.SerializeDelta(stream, instance.currentLocation, previous.currentLocation);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field currentLocation (ProtoBuf.VineDestination)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
	}

	public static void Serialize(BufferStream stream, VineMountable instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.anchorPoint != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.anchorPoint);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field anchorPoint (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.originPoint != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			VineDestination.Serialize(stream, instance.originPoint);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field originPoint (ProtoBuf.VineDestination)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.destinations != null)
		{
			for (int i = 0; i < instance.destinations.Count; i++)
			{
				VineDestination instance2 = instance.destinations[i];
				stream.WriteByte(26);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int position3 = stream.Position;
				VineDestination.Serialize(stream, instance2);
				int num3 = stream.Position - position3;
				if (num3 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field destinations (ProtoBuf.VineDestination)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			}
		}
		if (instance.currentLocation != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			VineDestination.Serialize(stream, instance.currentLocation);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field currentLocation (ProtoBuf.VineDestination)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		originPoint?.InspectUids(action);
		if (destinations != null)
		{
			for (int i = 0; i < destinations.Count; i++)
			{
				destinations[i]?.InspectUids(action);
			}
		}
		currentLocation?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VineTree : IDisposable, IPooled, IProto<VineTree>, IProto
{
	[NonSerialized]
	public List<NetworkableId> spawnedVines;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VineTree instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.spawnedVines != null)
			{
				List<NetworkableId> list = instance.spawnedVines;
				Pool.FreeUnmanaged<NetworkableId>(ref list);
				instance.spawnedVines = list;
			}
			Pool.Free<VineTree>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VineTree with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VineTree instance)
	{
		if (spawnedVines != null)
		{
			instance.spawnedVines = Pool.Get<List<NetworkableId>>();
			for (int i = 0; i < spawnedVines.Count; i++)
			{
				NetworkableId item = spawnedVines[i];
				instance.spawnedVines.Add(item);
			}
		}
		else
		{
			instance.spawnedVines = null;
		}
	}

	public VineTree Copy()
	{
		VineTree vineTree = Pool.Get<VineTree>();
		CopyTo(vineTree);
		return vineTree;
	}

	public static VineTree Deserialize(BufferStream stream)
	{
		VineTree vineTree = Pool.Get<VineTree>();
		Deserialize(stream, vineTree, isDelta: false);
		return vineTree;
	}

	public static VineTree DeserializeLengthDelimited(BufferStream stream)
	{
		VineTree vineTree = Pool.Get<VineTree>();
		DeserializeLengthDelimited(stream, vineTree, isDelta: false);
		return vineTree;
	}

	public static VineTree DeserializeLength(BufferStream stream, int length)
	{
		VineTree vineTree = Pool.Get<VineTree>();
		DeserializeLength(stream, length, vineTree, isDelta: false);
		return vineTree;
	}

	public static VineTree Deserialize(byte[] buffer)
	{
		VineTree vineTree = Pool.Get<VineTree>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, vineTree, isDelta: false);
		return vineTree;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VineTree previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VineTree Deserialize(BufferStream stream, VineTree instance, bool isDelta)
	{
		if (!isDelta && instance.spawnedVines == null)
		{
			instance.spawnedVines = Pool.Get<List<NetworkableId>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.spawnedVines.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VineTree DeserializeLengthDelimited(BufferStream stream, VineTree instance, bool isDelta)
	{
		if (!isDelta && instance.spawnedVines == null)
		{
			instance.spawnedVines = Pool.Get<List<NetworkableId>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.spawnedVines.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VineTree DeserializeLength(BufferStream stream, int length, VineTree instance, bool isDelta)
	{
		if (!isDelta && instance.spawnedVines == null)
		{
			instance.spawnedVines = Pool.Get<List<NetworkableId>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.spawnedVines.Add(new NetworkableId(ProtocolParser.ReadUInt64(stream)));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VineTree instance, VineTree previous)
	{
		if (instance.spawnedVines != null)
		{
			for (int i = 0; i < instance.spawnedVines.Count; i++)
			{
				NetworkableId networkableId = instance.spawnedVines[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
	}

	public static void Serialize(BufferStream stream, VineTree instance)
	{
		if (instance.spawnedVines != null)
		{
			for (int i = 0; i < instance.spawnedVines.Count; i++)
			{
				NetworkableId networkableId = instance.spawnedVines[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, networkableId.Value);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		for (int i = 0; i < spawnedVines.Count; i++)
		{
			NetworkableId value = spawnedVines[i];
			action(UidType.NetworkableId, ref value.Value);
			spawnedVines[i] = value;
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class VoicemailEntry : IDisposable, IPooled, IProto<VoicemailEntry>, IProto
{
	[NonSerialized]
	public uint audioId;

	[NonSerialized]
	public string userName;

	[NonSerialized]
	public long timestamp;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(VoicemailEntry instance)
	{
		if (instance.ShouldPool)
		{
			instance.audioId = 0u;
			instance.userName = string.Empty;
			instance.timestamp = 0L;
			Pool.Free<VoicemailEntry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose VoicemailEntry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(VoicemailEntry instance)
	{
		instance.audioId = audioId;
		instance.userName = userName;
		instance.timestamp = timestamp;
	}

	public VoicemailEntry Copy()
	{
		VoicemailEntry voicemailEntry = Pool.Get<VoicemailEntry>();
		CopyTo(voicemailEntry);
		return voicemailEntry;
	}

	public static VoicemailEntry Deserialize(BufferStream stream)
	{
		VoicemailEntry voicemailEntry = Pool.Get<VoicemailEntry>();
		Deserialize(stream, voicemailEntry, isDelta: false);
		return voicemailEntry;
	}

	public static VoicemailEntry DeserializeLengthDelimited(BufferStream stream)
	{
		VoicemailEntry voicemailEntry = Pool.Get<VoicemailEntry>();
		DeserializeLengthDelimited(stream, voicemailEntry, isDelta: false);
		return voicemailEntry;
	}

	public static VoicemailEntry DeserializeLength(BufferStream stream, int length)
	{
		VoicemailEntry voicemailEntry = Pool.Get<VoicemailEntry>();
		DeserializeLength(stream, length, voicemailEntry, isDelta: false);
		return voicemailEntry;
	}

	public static VoicemailEntry Deserialize(byte[] buffer)
	{
		VoicemailEntry voicemailEntry = Pool.Get<VoicemailEntry>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, voicemailEntry, isDelta: false);
		return voicemailEntry;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, VoicemailEntry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static VoicemailEntry Deserialize(BufferStream stream, VoicemailEntry instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.audioId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.userName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static VoicemailEntry DeserializeLengthDelimited(BufferStream stream, VoicemailEntry instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.audioId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.userName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static VoicemailEntry DeserializeLength(BufferStream stream, int length, VoicemailEntry instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.audioId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.userName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, VoicemailEntry instance, VoicemailEntry previous)
	{
		if (instance.audioId != previous.audioId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.audioId);
		}
		if (instance.userName != previous.userName)
		{
			if (instance.userName == null)
			{
				throw new ArgumentNullException("userName", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.userName);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
	}

	public static void Serialize(BufferStream stream, VoicemailEntry instance)
	{
		if (instance.audioId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.audioId);
		}
		if (instance.userName == null)
		{
			throw new ArgumentNullException("userName", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.userName);
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class WallpaperTool : IDisposable, IPooled, IProto<WallpaperTool>, IProto
{
	[NonSerialized]
	public ulong wallSkinID;

	[NonSerialized]
	public ulong flooringSkinID;

	[NonSerialized]
	public ulong ceilingSkinID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WallpaperTool instance)
	{
		if (instance.ShouldPool)
		{
			instance.wallSkinID = 0uL;
			instance.flooringSkinID = 0uL;
			instance.ceilingSkinID = 0uL;
			Pool.Free<WallpaperTool>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WallpaperTool with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WallpaperTool instance)
	{
		instance.wallSkinID = wallSkinID;
		instance.flooringSkinID = flooringSkinID;
		instance.ceilingSkinID = ceilingSkinID;
	}

	public WallpaperTool Copy()
	{
		WallpaperTool wallpaperTool = Pool.Get<WallpaperTool>();
		CopyTo(wallpaperTool);
		return wallpaperTool;
	}

	public static WallpaperTool Deserialize(BufferStream stream)
	{
		WallpaperTool wallpaperTool = Pool.Get<WallpaperTool>();
		Deserialize(stream, wallpaperTool, isDelta: false);
		return wallpaperTool;
	}

	public static WallpaperTool DeserializeLengthDelimited(BufferStream stream)
	{
		WallpaperTool wallpaperTool = Pool.Get<WallpaperTool>();
		DeserializeLengthDelimited(stream, wallpaperTool, isDelta: false);
		return wallpaperTool;
	}

	public static WallpaperTool DeserializeLength(BufferStream stream, int length)
	{
		WallpaperTool wallpaperTool = Pool.Get<WallpaperTool>();
		DeserializeLength(stream, length, wallpaperTool, isDelta: false);
		return wallpaperTool;
	}

	public static WallpaperTool Deserialize(byte[] buffer)
	{
		WallpaperTool wallpaperTool = Pool.Get<WallpaperTool>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, wallpaperTool, isDelta: false);
		return wallpaperTool;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WallpaperTool previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WallpaperTool Deserialize(BufferStream stream, WallpaperTool instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.wallSkinID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.flooringSkinID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.ceilingSkinID = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static WallpaperTool DeserializeLengthDelimited(BufferStream stream, WallpaperTool instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.wallSkinID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.flooringSkinID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.ceilingSkinID = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WallpaperTool DeserializeLength(BufferStream stream, int length, WallpaperTool instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.wallSkinID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.flooringSkinID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.ceilingSkinID = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WallpaperTool instance, WallpaperTool previous)
	{
		if (instance.wallSkinID != previous.wallSkinID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.wallSkinID);
		}
		if (instance.flooringSkinID != previous.flooringSkinID)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.flooringSkinID);
		}
		if (instance.ceilingSkinID != previous.ceilingSkinID)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.ceilingSkinID);
		}
	}

	public static void Serialize(BufferStream stream, WallpaperTool instance)
	{
		if (instance.wallSkinID != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.wallSkinID);
		}
		if (instance.flooringSkinID != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.flooringSkinID);
		}
		if (instance.ceilingSkinID != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.ceilingSkinID);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class WantedPoster : IDisposable, IPooled, IProto<WantedPoster>, IProto
{
	[NonSerialized]
	public uint imageCrc;

	[NonSerialized]
	public string playerName;

	[NonSerialized]
	public ulong playerId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WantedPoster instance)
	{
		if (instance.ShouldPool)
		{
			instance.imageCrc = 0u;
			instance.playerName = string.Empty;
			instance.playerId = 0uL;
			Pool.Free<WantedPoster>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WantedPoster with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WantedPoster instance)
	{
		instance.imageCrc = imageCrc;
		instance.playerName = playerName;
		instance.playerId = playerId;
	}

	public WantedPoster Copy()
	{
		WantedPoster wantedPoster = Pool.Get<WantedPoster>();
		CopyTo(wantedPoster);
		return wantedPoster;
	}

	public static WantedPoster Deserialize(BufferStream stream)
	{
		WantedPoster wantedPoster = Pool.Get<WantedPoster>();
		Deserialize(stream, wantedPoster, isDelta: false);
		return wantedPoster;
	}

	public static WantedPoster DeserializeLengthDelimited(BufferStream stream)
	{
		WantedPoster wantedPoster = Pool.Get<WantedPoster>();
		DeserializeLengthDelimited(stream, wantedPoster, isDelta: false);
		return wantedPoster;
	}

	public static WantedPoster DeserializeLength(BufferStream stream, int length)
	{
		WantedPoster wantedPoster = Pool.Get<WantedPoster>();
		DeserializeLength(stream, length, wantedPoster, isDelta: false);
		return wantedPoster;
	}

	public static WantedPoster Deserialize(byte[] buffer)
	{
		WantedPoster wantedPoster = Pool.Get<WantedPoster>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, wantedPoster, isDelta: false);
		return wantedPoster;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WantedPoster previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WantedPoster Deserialize(BufferStream stream, WantedPoster instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.imageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static WantedPoster DeserializeLengthDelimited(BufferStream stream, WantedPoster instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.imageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WantedPoster DeserializeLength(BufferStream stream, int length, WantedPoster instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.imageCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WantedPoster instance, WantedPoster previous)
	{
		if (instance.imageCrc != previous.imageCrc)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.imageCrc);
		}
		if (instance.playerName != null && instance.playerName != previous.playerName)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.playerName);
		}
		if (instance.playerId != previous.playerId)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.playerId);
		}
	}

	public static void Serialize(BufferStream stream, WantedPoster instance)
	{
		if (instance.imageCrc != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.imageCrc);
		}
		if (instance.playerName != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.playerName);
		}
		if (instance.playerId != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.playerId);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class WaterPool : IDisposable, IPooled, IProto<WaterPool>, IProto
{
	[NonSerialized]
	public float fillAmount;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WaterPool instance)
	{
		if (instance.ShouldPool)
		{
			instance.fillAmount = 0f;
			Pool.Free<WaterPool>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WaterPool with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WaterPool instance)
	{
		instance.fillAmount = fillAmount;
	}

	public WaterPool Copy()
	{
		WaterPool waterPool = Pool.Get<WaterPool>();
		CopyTo(waterPool);
		return waterPool;
	}

	public static WaterPool Deserialize(BufferStream stream)
	{
		WaterPool waterPool = Pool.Get<WaterPool>();
		Deserialize(stream, waterPool, isDelta: false);
		return waterPool;
	}

	public static WaterPool DeserializeLengthDelimited(BufferStream stream)
	{
		WaterPool waterPool = Pool.Get<WaterPool>();
		DeserializeLengthDelimited(stream, waterPool, isDelta: false);
		return waterPool;
	}

	public static WaterPool DeserializeLength(BufferStream stream, int length)
	{
		WaterPool waterPool = Pool.Get<WaterPool>();
		DeserializeLength(stream, length, waterPool, isDelta: false);
		return waterPool;
	}

	public static WaterPool Deserialize(byte[] buffer)
	{
		WaterPool waterPool = Pool.Get<WaterPool>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, waterPool, isDelta: false);
		return waterPool;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WaterPool previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WaterPool Deserialize(BufferStream stream, WaterPool instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.fillAmount = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static WaterPool DeserializeLengthDelimited(BufferStream stream, WaterPool instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.fillAmount = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WaterPool DeserializeLength(BufferStream stream, int length, WaterPool instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.fillAmount = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WaterPool instance, WaterPool previous)
	{
		if (instance.fillAmount != previous.fillAmount)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.fillAmount);
		}
	}

	public static void Serialize(BufferStream stream, WaterPool instance)
	{
		if (instance.fillAmount != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.fillAmount);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class WaterWell : IDisposable, IPooled, IProto<WaterWell>, IProto
{
	[NonSerialized]
	public float pressure;

	[NonSerialized]
	public float waterLevel;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WaterWell instance)
	{
		if (instance.ShouldPool)
		{
			instance.pressure = 0f;
			instance.waterLevel = 0f;
			Pool.Free<WaterWell>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WaterWell with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WaterWell instance)
	{
		instance.pressure = pressure;
		instance.waterLevel = waterLevel;
	}

	public WaterWell Copy()
	{
		WaterWell waterWell = Pool.Get<WaterWell>();
		CopyTo(waterWell);
		return waterWell;
	}

	public static WaterWell Deserialize(BufferStream stream)
	{
		WaterWell waterWell = Pool.Get<WaterWell>();
		Deserialize(stream, waterWell, isDelta: false);
		return waterWell;
	}

	public static WaterWell DeserializeLengthDelimited(BufferStream stream)
	{
		WaterWell waterWell = Pool.Get<WaterWell>();
		DeserializeLengthDelimited(stream, waterWell, isDelta: false);
		return waterWell;
	}

	public static WaterWell DeserializeLength(BufferStream stream, int length)
	{
		WaterWell waterWell = Pool.Get<WaterWell>();
		DeserializeLength(stream, length, waterWell, isDelta: false);
		return waterWell;
	}

	public static WaterWell Deserialize(byte[] buffer)
	{
		WaterWell waterWell = Pool.Get<WaterWell>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, waterWell, isDelta: false);
		return waterWell;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WaterWell previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WaterWell Deserialize(BufferStream stream, WaterWell instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.pressure = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.waterLevel = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static WaterWell DeserializeLengthDelimited(BufferStream stream, WaterWell instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.pressure = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.waterLevel = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WaterWell DeserializeLength(BufferStream stream, int length, WaterWell instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.pressure = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.waterLevel = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WaterWell instance, WaterWell previous)
	{
		if (instance.pressure != previous.pressure)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.pressure);
		}
		if (instance.waterLevel != previous.waterLevel)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.waterLevel);
		}
	}

	public static void Serialize(BufferStream stream, WaterWell instance)
	{
		if (instance.pressure != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.pressure);
		}
		if (instance.waterLevel != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.waterLevel);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class WaypointRace : IDisposable, IPooled, IProto<WaypointRace>, IProto
{
	[NonSerialized]
	public List<Vector3> positions;

	[NonSerialized]
	public NetworkableId racingVehicle;

	[NonSerialized]
	public int currentWaypoint;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WaypointRace instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.positions != null)
			{
				List<Vector3> list = instance.positions;
				Pool.FreeUnmanaged<Vector3>(ref list);
				instance.positions = list;
			}
			instance.racingVehicle = default(NetworkableId);
			instance.currentWaypoint = 0;
			Pool.Free<WaypointRace>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WaypointRace with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WaypointRace instance)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (positions != null)
		{
			instance.positions = Pool.Get<List<Vector3>>();
			for (int i = 0; i < positions.Count; i++)
			{
				Vector3 item = positions[i];
				instance.positions.Add(item);
			}
		}
		else
		{
			instance.positions = null;
		}
		instance.racingVehicle = racingVehicle;
		instance.currentWaypoint = currentWaypoint;
	}

	public WaypointRace Copy()
	{
		WaypointRace waypointRace = Pool.Get<WaypointRace>();
		CopyTo(waypointRace);
		return waypointRace;
	}

	public static WaypointRace Deserialize(BufferStream stream)
	{
		WaypointRace waypointRace = Pool.Get<WaypointRace>();
		Deserialize(stream, waypointRace, isDelta: false);
		return waypointRace;
	}

	public static WaypointRace DeserializeLengthDelimited(BufferStream stream)
	{
		WaypointRace waypointRace = Pool.Get<WaypointRace>();
		DeserializeLengthDelimited(stream, waypointRace, isDelta: false);
		return waypointRace;
	}

	public static WaypointRace DeserializeLength(BufferStream stream, int length)
	{
		WaypointRace waypointRace = Pool.Get<WaypointRace>();
		DeserializeLength(stream, length, waypointRace, isDelta: false);
		return waypointRace;
	}

	public static WaypointRace Deserialize(byte[] buffer)
	{
		WaypointRace waypointRace = Pool.Get<WaypointRace>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, waypointRace, isDelta: false);
		return waypointRace;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WaypointRace previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WaypointRace Deserialize(BufferStream stream, WaypointRace instance, bool isDelta)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.positions == null)
		{
			instance.positions = Pool.Get<List<Vector3>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.positions.Add(instance2);
				break;
			}
			case 16:
				instance.racingVehicle = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 24:
				instance.currentWaypoint = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static WaypointRace DeserializeLengthDelimited(BufferStream stream, WaypointRace instance, bool isDelta)
	{
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.positions == null)
		{
			instance.positions = Pool.Get<List<Vector3>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.positions.Add(instance2);
				break;
			}
			case 16:
				instance.racingVehicle = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 24:
				instance.currentWaypoint = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WaypointRace DeserializeLength(BufferStream stream, int length, WaypointRace instance, bool isDelta)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta && instance.positions == null)
		{
			instance.positions = Pool.Get<List<Vector3>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.positions.Add(instance2);
				break;
			}
			case 16:
				instance.racingVehicle = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 24:
				instance.currentWaypoint = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WaypointRace instance, WaypointRace previous)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.positions != null)
		{
			for (int i = 0; i < instance.positions.Count; i++)
			{
				Vector3 val = instance.positions[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.SerializeDelta(stream, val, val);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field positions (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.racingVehicle.Value);
		if (instance.currentWaypoint != previous.currentWaypoint)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentWaypoint);
		}
	}

	public static void Serialize(BufferStream stream, WaypointRace instance)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if (instance.positions != null)
		{
			for (int i = 0; i < instance.positions.Count; i++)
			{
				Vector3 instance2 = instance.positions[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field positions (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.racingVehicle != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.racingVehicle.Value);
		}
		if (instance.currentWaypoint != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currentWaypoint);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref racingVehicle.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class WeaponRack : IDisposable, IPooled, IProto<WeaponRack>, IProto
{
	[NonSerialized]
	public List<WeaponRackItem> items;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WeaponRack instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.items != null)
		{
			for (int i = 0; i < instance.items.Count; i++)
			{
				if (instance.items[i] != null)
				{
					instance.items[i].ResetToPool();
					instance.items[i] = null;
				}
			}
			List<WeaponRackItem> list = instance.items;
			Pool.Free<WeaponRackItem>(ref list, false);
			instance.items = list;
		}
		Pool.Free<WeaponRack>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WeaponRack with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WeaponRack instance)
	{
		if (items != null)
		{
			instance.items = Pool.Get<List<WeaponRackItem>>();
			for (int i = 0; i < items.Count; i++)
			{
				WeaponRackItem item = items[i].Copy();
				instance.items.Add(item);
			}
		}
		else
		{
			instance.items = null;
		}
	}

	public WeaponRack Copy()
	{
		WeaponRack weaponRack = Pool.Get<WeaponRack>();
		CopyTo(weaponRack);
		return weaponRack;
	}

	public static WeaponRack Deserialize(BufferStream stream)
	{
		WeaponRack weaponRack = Pool.Get<WeaponRack>();
		Deserialize(stream, weaponRack, isDelta: false);
		return weaponRack;
	}

	public static WeaponRack DeserializeLengthDelimited(BufferStream stream)
	{
		WeaponRack weaponRack = Pool.Get<WeaponRack>();
		DeserializeLengthDelimited(stream, weaponRack, isDelta: false);
		return weaponRack;
	}

	public static WeaponRack DeserializeLength(BufferStream stream, int length)
	{
		WeaponRack weaponRack = Pool.Get<WeaponRack>();
		DeserializeLength(stream, length, weaponRack, isDelta: false);
		return weaponRack;
	}

	public static WeaponRack Deserialize(byte[] buffer)
	{
		WeaponRack weaponRack = Pool.Get<WeaponRack>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, weaponRack, isDelta: false);
		return weaponRack;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WeaponRack previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WeaponRack Deserialize(BufferStream stream, WeaponRack instance, bool isDelta)
	{
		if (!isDelta && instance.items == null)
		{
			instance.items = Pool.Get<List<WeaponRackItem>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.items.Add(WeaponRackItem.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static WeaponRack DeserializeLengthDelimited(BufferStream stream, WeaponRack instance, bool isDelta)
	{
		if (!isDelta && instance.items == null)
		{
			instance.items = Pool.Get<List<WeaponRackItem>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.items.Add(WeaponRackItem.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WeaponRack DeserializeLength(BufferStream stream, int length, WeaponRack instance, bool isDelta)
	{
		if (!isDelta && instance.items == null)
		{
			instance.items = Pool.Get<List<WeaponRackItem>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.items.Add(WeaponRackItem.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WeaponRack instance, WeaponRack previous)
	{
		if (instance.items == null)
		{
			return;
		}
		for (int i = 0; i < instance.items.Count; i++)
		{
			WeaponRackItem weaponRackItem = instance.items[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			WeaponRackItem.SerializeDelta(stream, weaponRackItem, weaponRackItem);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field items (ProtoBuf.WeaponRackItem)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, WeaponRack instance)
	{
		if (instance.items == null)
		{
			return;
		}
		for (int i = 0; i < instance.items.Count; i++)
		{
			WeaponRackItem instance2 = instance.items[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			WeaponRackItem.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field items (ProtoBuf.WeaponRackItem)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (items != null)
		{
			for (int i = 0; i < items.Count; i++)
			{
				items[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class WeaponRackItem : IDisposable, IPooled, IProto<WeaponRackItem>, IProto
{
	[NonSerialized]
	public int itemID;

	[NonSerialized]
	public ulong skinid;

	[NonSerialized]
	public int gridSlotIndex;

	[NonSerialized]
	public int inventorySlot;

	[NonSerialized]
	public int ammoCount;

	[NonSerialized]
	public int ammoMax;

	[NonSerialized]
	public int ammoID;

	[NonSerialized]
	public float condition;

	[NonSerialized]
	public int rotation;

	[NonSerialized]
	public int ammoTypes;

	[NonSerialized]
	public float reloadTime;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WeaponRackItem instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemID = 0;
			instance.skinid = 0uL;
			instance.gridSlotIndex = 0;
			instance.inventorySlot = 0;
			instance.ammoCount = 0;
			instance.ammoMax = 0;
			instance.ammoID = 0;
			instance.condition = 0f;
			instance.rotation = 0;
			instance.ammoTypes = 0;
			instance.reloadTime = 0f;
			Pool.Free<WeaponRackItem>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WeaponRackItem with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WeaponRackItem instance)
	{
		instance.itemID = itemID;
		instance.skinid = skinid;
		instance.gridSlotIndex = gridSlotIndex;
		instance.inventorySlot = inventorySlot;
		instance.ammoCount = ammoCount;
		instance.ammoMax = ammoMax;
		instance.ammoID = ammoID;
		instance.condition = condition;
		instance.rotation = rotation;
		instance.ammoTypes = ammoTypes;
		instance.reloadTime = reloadTime;
	}

	public WeaponRackItem Copy()
	{
		WeaponRackItem weaponRackItem = Pool.Get<WeaponRackItem>();
		CopyTo(weaponRackItem);
		return weaponRackItem;
	}

	public static WeaponRackItem Deserialize(BufferStream stream)
	{
		WeaponRackItem weaponRackItem = Pool.Get<WeaponRackItem>();
		Deserialize(stream, weaponRackItem, isDelta: false);
		return weaponRackItem;
	}

	public static WeaponRackItem DeserializeLengthDelimited(BufferStream stream)
	{
		WeaponRackItem weaponRackItem = Pool.Get<WeaponRackItem>();
		DeserializeLengthDelimited(stream, weaponRackItem, isDelta: false);
		return weaponRackItem;
	}

	public static WeaponRackItem DeserializeLength(BufferStream stream, int length)
	{
		WeaponRackItem weaponRackItem = Pool.Get<WeaponRackItem>();
		DeserializeLength(stream, length, weaponRackItem, isDelta: false);
		return weaponRackItem;
	}

	public static WeaponRackItem Deserialize(byte[] buffer)
	{
		WeaponRackItem weaponRackItem = Pool.Get<WeaponRackItem>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, weaponRackItem, isDelta: false);
		return weaponRackItem;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WeaponRackItem previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WeaponRackItem Deserialize(BufferStream stream, WeaponRackItem instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.skinid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.gridSlotIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.inventorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.ammoCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.ammoMax = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.ammoID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 69:
				instance.condition = ProtocolParser.ReadSingle(stream);
				continue;
			case 72:
				instance.rotation = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 80:
				instance.ammoTypes = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 93:
				instance.reloadTime = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static WeaponRackItem DeserializeLengthDelimited(BufferStream stream, WeaponRackItem instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.skinid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.gridSlotIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.inventorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.ammoCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.ammoMax = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.ammoID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 69:
				instance.condition = ProtocolParser.ReadSingle(stream);
				continue;
			case 72:
				instance.rotation = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 80:
				instance.ammoTypes = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 93:
				instance.reloadTime = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WeaponRackItem DeserializeLength(BufferStream stream, int length, WeaponRackItem instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.skinid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.gridSlotIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.inventorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.ammoCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.ammoMax = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.ammoID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 69:
				instance.condition = ProtocolParser.ReadSingle(stream);
				continue;
			case 72:
				instance.rotation = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 80:
				instance.ammoTypes = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 93:
				instance.reloadTime = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WeaponRackItem instance, WeaponRackItem previous)
	{
		if (instance.itemID != previous.itemID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.skinid != previous.skinid)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.skinid);
		}
		if (instance.gridSlotIndex != previous.gridSlotIndex)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.gridSlotIndex);
		}
		if (instance.inventorySlot != previous.inventorySlot)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.inventorySlot);
		}
		if (instance.ammoCount != previous.ammoCount)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoCount);
		}
		if (instance.ammoMax != previous.ammoMax)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoMax);
		}
		if (instance.ammoID != previous.ammoID)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoID);
		}
		if (instance.condition != previous.condition)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.condition);
		}
		if (instance.rotation != previous.rotation)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.rotation);
		}
		if (instance.ammoTypes != previous.ammoTypes)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoTypes);
		}
		if (instance.reloadTime != previous.reloadTime)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.reloadTime);
		}
	}

	public static void Serialize(BufferStream stream, WeaponRackItem instance)
	{
		if (instance.itemID != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.skinid != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.skinid);
		}
		if (instance.gridSlotIndex != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.gridSlotIndex);
		}
		if (instance.inventorySlot != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.inventorySlot);
		}
		if (instance.ammoCount != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoCount);
		}
		if (instance.ammoMax != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoMax);
		}
		if (instance.ammoID != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoID);
		}
		if (instance.condition != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.condition);
		}
		if (instance.rotation != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.rotation);
		}
		if (instance.ammoTypes != 0)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoTypes);
		}
		if (instance.reloadTime != 0f)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.reloadTime);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Whitelist : IDisposable, IPooled, IProto<Whitelist>, IProto
{
	[NonSerialized]
	public List<ulong> users;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Whitelist instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.users != null)
			{
				List<ulong> list = instance.users;
				Pool.FreeUnmanaged<ulong>(ref list);
				instance.users = list;
			}
			Pool.Free<Whitelist>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Whitelist with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Whitelist instance)
	{
		if (users != null)
		{
			instance.users = Pool.Get<List<ulong>>();
			for (int i = 0; i < users.Count; i++)
			{
				ulong item = users[i];
				instance.users.Add(item);
			}
		}
		else
		{
			instance.users = null;
		}
	}

	public Whitelist Copy()
	{
		Whitelist whitelist = Pool.Get<Whitelist>();
		CopyTo(whitelist);
		return whitelist;
	}

	public static Whitelist Deserialize(BufferStream stream)
	{
		Whitelist whitelist = Pool.Get<Whitelist>();
		Deserialize(stream, whitelist, isDelta: false);
		return whitelist;
	}

	public static Whitelist DeserializeLengthDelimited(BufferStream stream)
	{
		Whitelist whitelist = Pool.Get<Whitelist>();
		DeserializeLengthDelimited(stream, whitelist, isDelta: false);
		return whitelist;
	}

	public static Whitelist DeserializeLength(BufferStream stream, int length)
	{
		Whitelist whitelist = Pool.Get<Whitelist>();
		DeserializeLength(stream, length, whitelist, isDelta: false);
		return whitelist;
	}

	public static Whitelist Deserialize(byte[] buffer)
	{
		Whitelist whitelist = Pool.Get<Whitelist>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, whitelist, isDelta: false);
		return whitelist;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Whitelist previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Whitelist Deserialize(BufferStream stream, Whitelist instance, bool isDelta)
	{
		if (!isDelta && instance.users == null)
		{
			instance.users = Pool.Get<List<ulong>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.users.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Whitelist DeserializeLengthDelimited(BufferStream stream, Whitelist instance, bool isDelta)
	{
		if (!isDelta && instance.users == null)
		{
			instance.users = Pool.Get<List<ulong>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.users.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Whitelist DeserializeLength(BufferStream stream, int length, Whitelist instance, bool isDelta)
	{
		if (!isDelta && instance.users == null)
		{
			instance.users = Pool.Get<List<ulong>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.users.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Whitelist instance, Whitelist previous)
	{
		if (instance.users != null)
		{
			for (int i = 0; i < instance.users.Count; i++)
			{
				ulong val = instance.users[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
	}

	public static void Serialize(BufferStream stream, Whitelist instance)
	{
		if (instance.users != null)
		{
			for (int i = 0; i < instance.users.Count; i++)
			{
				ulong val = instance.users[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class WipeLaptop : IDisposable, IPooled, IProto<WipeLaptop>, IProto
{
	[NonSerialized]
	public int timeLeft;

	[NonSerialized]
	public float armTime;

	[NonSerialized]
	public float disarmTime;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WipeLaptop instance)
	{
		if (instance.ShouldPool)
		{
			instance.timeLeft = 0;
			instance.armTime = 0f;
			instance.disarmTime = 0f;
			Pool.Free<WipeLaptop>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WipeLaptop with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WipeLaptop instance)
	{
		instance.timeLeft = timeLeft;
		instance.armTime = armTime;
		instance.disarmTime = disarmTime;
	}

	public WipeLaptop Copy()
	{
		WipeLaptop wipeLaptop = Pool.Get<WipeLaptop>();
		CopyTo(wipeLaptop);
		return wipeLaptop;
	}

	public static WipeLaptop Deserialize(BufferStream stream)
	{
		WipeLaptop wipeLaptop = Pool.Get<WipeLaptop>();
		Deserialize(stream, wipeLaptop, isDelta: false);
		return wipeLaptop;
	}

	public static WipeLaptop DeserializeLengthDelimited(BufferStream stream)
	{
		WipeLaptop wipeLaptop = Pool.Get<WipeLaptop>();
		DeserializeLengthDelimited(stream, wipeLaptop, isDelta: false);
		return wipeLaptop;
	}

	public static WipeLaptop DeserializeLength(BufferStream stream, int length)
	{
		WipeLaptop wipeLaptop = Pool.Get<WipeLaptop>();
		DeserializeLength(stream, length, wipeLaptop, isDelta: false);
		return wipeLaptop;
	}

	public static WipeLaptop Deserialize(byte[] buffer)
	{
		WipeLaptop wipeLaptop = Pool.Get<WipeLaptop>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, wipeLaptop, isDelta: false);
		return wipeLaptop;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WipeLaptop previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WipeLaptop Deserialize(BufferStream stream, WipeLaptop instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.timeLeft = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 21:
				instance.armTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.disarmTime = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static WipeLaptop DeserializeLengthDelimited(BufferStream stream, WipeLaptop instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.timeLeft = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 21:
				instance.armTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.disarmTime = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WipeLaptop DeserializeLength(BufferStream stream, int length, WipeLaptop instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.timeLeft = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 21:
				instance.armTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.disarmTime = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WipeLaptop instance, WipeLaptop previous)
	{
		if (instance.timeLeft != previous.timeLeft)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timeLeft);
		}
		if (instance.armTime != previous.armTime)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.armTime);
		}
		if (instance.disarmTime != previous.disarmTime)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.disarmTime);
		}
	}

	public static void Serialize(BufferStream stream, WipeLaptop instance)
	{
		if (instance.timeLeft != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timeLeft);
		}
		if (instance.armTime != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.armTime);
		}
		if (instance.disarmTime != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.disarmTime);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class WireConnectionMessage : IDisposable, IPooled, IProto<WireConnectionMessage>, IProto
{
	[NonSerialized]
	public List<Vector3> linePoints;

	[NonSerialized]
	public List<WireLineAnchorInfo> lineAnchors;

	[NonSerialized]
	public NetworkableId inputID;

	[NonSerialized]
	public int inputIndex;

	[NonSerialized]
	public NetworkableId outputID;

	[NonSerialized]
	public int outputIndex;

	[NonSerialized]
	public int wireColor;

	[NonSerialized]
	public List<float> slackLevels;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WireConnectionMessage instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.linePoints != null)
		{
			List<Vector3> list = instance.linePoints;
			Pool.FreeUnmanaged<Vector3>(ref list);
			instance.linePoints = list;
		}
		if (instance.lineAnchors != null)
		{
			for (int i = 0; i < instance.lineAnchors.Count; i++)
			{
				if (instance.lineAnchors[i] != null)
				{
					instance.lineAnchors[i].ResetToPool();
					instance.lineAnchors[i] = null;
				}
			}
			List<WireLineAnchorInfo> list2 = instance.lineAnchors;
			Pool.Free<WireLineAnchorInfo>(ref list2, false);
			instance.lineAnchors = list2;
		}
		instance.inputID = default(NetworkableId);
		instance.inputIndex = 0;
		instance.outputID = default(NetworkableId);
		instance.outputIndex = 0;
		instance.wireColor = 0;
		if (instance.slackLevels != null)
		{
			List<float> list3 = instance.slackLevels;
			Pool.FreeUnmanaged<float>(ref list3);
			instance.slackLevels = list3;
		}
		Pool.Free<WireConnectionMessage>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WireConnectionMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WireConnectionMessage instance)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (linePoints != null)
		{
			instance.linePoints = Pool.Get<List<Vector3>>();
			for (int i = 0; i < linePoints.Count; i++)
			{
				Vector3 item = linePoints[i];
				instance.linePoints.Add(item);
			}
		}
		else
		{
			instance.linePoints = null;
		}
		if (lineAnchors != null)
		{
			instance.lineAnchors = Pool.Get<List<WireLineAnchorInfo>>();
			for (int j = 0; j < lineAnchors.Count; j++)
			{
				WireLineAnchorInfo item2 = lineAnchors[j].Copy();
				instance.lineAnchors.Add(item2);
			}
		}
		else
		{
			instance.lineAnchors = null;
		}
		instance.inputID = inputID;
		instance.inputIndex = inputIndex;
		instance.outputID = outputID;
		instance.outputIndex = outputIndex;
		instance.wireColor = wireColor;
		if (slackLevels != null)
		{
			instance.slackLevels = Pool.Get<List<float>>();
			for (int k = 0; k < slackLevels.Count; k++)
			{
				float item3 = slackLevels[k];
				instance.slackLevels.Add(item3);
			}
		}
		else
		{
			instance.slackLevels = null;
		}
	}

	public WireConnectionMessage Copy()
	{
		WireConnectionMessage wireConnectionMessage = Pool.Get<WireConnectionMessage>();
		CopyTo(wireConnectionMessage);
		return wireConnectionMessage;
	}

	public static WireConnectionMessage Deserialize(BufferStream stream)
	{
		WireConnectionMessage wireConnectionMessage = Pool.Get<WireConnectionMessage>();
		Deserialize(stream, wireConnectionMessage, isDelta: false);
		return wireConnectionMessage;
	}

	public static WireConnectionMessage DeserializeLengthDelimited(BufferStream stream)
	{
		WireConnectionMessage wireConnectionMessage = Pool.Get<WireConnectionMessage>();
		DeserializeLengthDelimited(stream, wireConnectionMessage, isDelta: false);
		return wireConnectionMessage;
	}

	public static WireConnectionMessage DeserializeLength(BufferStream stream, int length)
	{
		WireConnectionMessage wireConnectionMessage = Pool.Get<WireConnectionMessage>();
		DeserializeLength(stream, length, wireConnectionMessage, isDelta: false);
		return wireConnectionMessage;
	}

	public static WireConnectionMessage Deserialize(byte[] buffer)
	{
		WireConnectionMessage wireConnectionMessage = Pool.Get<WireConnectionMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, wireConnectionMessage, isDelta: false);
		return wireConnectionMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WireConnectionMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WireConnectionMessage Deserialize(BufferStream stream, WireConnectionMessage instance, bool isDelta)
	{
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.linePoints == null)
			{
				instance.linePoints = Pool.Get<List<Vector3>>();
			}
			if (instance.lineAnchors == null)
			{
				instance.lineAnchors = Pool.Get<List<WireLineAnchorInfo>>();
			}
			if (instance.slackLevels == null)
			{
				instance.slackLevels = Pool.Get<List<float>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			case 18:
				instance.lineAnchors.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
				break;
			case 24:
				instance.inputID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 32:
				instance.inputIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 40:
				instance.outputID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 48:
				instance.outputIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 56:
				instance.wireColor = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 69:
				instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static WireConnectionMessage DeserializeLengthDelimited(BufferStream stream, WireConnectionMessage instance, bool isDelta)
	{
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.linePoints == null)
			{
				instance.linePoints = Pool.Get<List<Vector3>>();
			}
			if (instance.lineAnchors == null)
			{
				instance.lineAnchors = Pool.Get<List<WireLineAnchorInfo>>();
			}
			if (instance.slackLevels == null)
			{
				instance.slackLevels = Pool.Get<List<float>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			case 18:
				instance.lineAnchors.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
				break;
			case 24:
				instance.inputID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 32:
				instance.inputIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 40:
				instance.outputID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 48:
				instance.outputIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 56:
				instance.wireColor = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 69:
				instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WireConnectionMessage DeserializeLength(BufferStream stream, int length, WireConnectionMessage instance, bool isDelta)
	{
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.linePoints == null)
			{
				instance.linePoints = Pool.Get<List<Vector3>>();
			}
			if (instance.lineAnchors == null)
			{
				instance.lineAnchors = Pool.Get<List<WireLineAnchorInfo>>();
			}
			if (instance.slackLevels == null)
			{
				instance.slackLevels = Pool.Get<List<float>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			case 18:
				instance.lineAnchors.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
				break;
			case 24:
				instance.inputID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 32:
				instance.inputIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 40:
				instance.outputID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 48:
				instance.outputIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 56:
				instance.wireColor = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 69:
				instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WireConnectionMessage instance, WireConnectionMessage previous)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.linePoints != null)
		{
			for (int i = 0; i < instance.linePoints.Count; i++)
			{
				Vector3 val = instance.linePoints[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.SerializeDelta(stream, val, val);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.lineAnchors != null)
		{
			for (int j = 0; j < instance.lineAnchors.Count; j++)
			{
				WireLineAnchorInfo wireLineAnchorInfo = instance.lineAnchors[j];
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				WireLineAnchorInfo.SerializeDelta(stream, wireLineAnchorInfo, wireLineAnchorInfo);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, instance.inputID.Value);
		if (instance.inputIndex != previous.inputIndex)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.inputIndex);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteUInt64(stream, instance.outputID.Value);
		if (instance.outputIndex != previous.outputIndex)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.outputIndex);
		}
		if (instance.wireColor != previous.wireColor)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.wireColor);
		}
		if (instance.slackLevels != null)
		{
			for (int k = 0; k < instance.slackLevels.Count; k++)
			{
				float f = instance.slackLevels[k];
				stream.WriteByte(69);
				ProtocolParser.WriteSingle(stream, f);
			}
		}
	}

	public static void Serialize(BufferStream stream, WireConnectionMessage instance)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if (instance.linePoints != null)
		{
			for (int i = 0; i < instance.linePoints.Count; i++)
			{
				Vector3 instance2 = instance.linePoints[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.lineAnchors != null)
		{
			for (int j = 0; j < instance.lineAnchors.Count; j++)
			{
				WireLineAnchorInfo instance3 = instance.lineAnchors[j];
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				WireLineAnchorInfo.Serialize(stream, instance3);
				int val = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.inputID != default(NetworkableId))
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.inputID.Value);
		}
		if (instance.inputIndex != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.inputIndex);
		}
		if (instance.outputID != default(NetworkableId))
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.outputID.Value);
		}
		if (instance.outputIndex != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.outputIndex);
		}
		if (instance.wireColor != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.wireColor);
		}
		if (instance.slackLevels != null)
		{
			for (int k = 0; k < instance.slackLevels.Count; k++)
			{
				float f = instance.slackLevels[k];
				stream.WriteByte(69);
				ProtocolParser.WriteSingle(stream, f);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (lineAnchors != null)
		{
			for (int i = 0; i < lineAnchors.Count; i++)
			{
				lineAnchors[i]?.InspectUids(action);
			}
		}
		action(UidType.NetworkableId, ref inputID.Value);
		action(UidType.NetworkableId, ref outputID.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class WireLineAnchorInfo : IDisposable, IPooled, IProto<WireLineAnchorInfo>, IProto
{
	[NonSerialized]
	public NetworkableId parentID;

	[NonSerialized]
	public string boneName;

	[NonSerialized]
	public long index;

	[NonSerialized]
	public Vector3 position;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WireLineAnchorInfo instance)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.parentID = default(NetworkableId);
			instance.boneName = string.Empty;
			instance.index = 0L;
			instance.position = default(Vector3);
			Pool.Free<WireLineAnchorInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WireLineAnchorInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WireLineAnchorInfo instance)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		instance.parentID = parentID;
		instance.boneName = boneName;
		instance.index = index;
		instance.position = position;
	}

	public WireLineAnchorInfo Copy()
	{
		WireLineAnchorInfo wireLineAnchorInfo = Pool.Get<WireLineAnchorInfo>();
		CopyTo(wireLineAnchorInfo);
		return wireLineAnchorInfo;
	}

	public static WireLineAnchorInfo Deserialize(BufferStream stream)
	{
		WireLineAnchorInfo wireLineAnchorInfo = Pool.Get<WireLineAnchorInfo>();
		Deserialize(stream, wireLineAnchorInfo, isDelta: false);
		return wireLineAnchorInfo;
	}

	public static WireLineAnchorInfo DeserializeLengthDelimited(BufferStream stream)
	{
		WireLineAnchorInfo wireLineAnchorInfo = Pool.Get<WireLineAnchorInfo>();
		DeserializeLengthDelimited(stream, wireLineAnchorInfo, isDelta: false);
		return wireLineAnchorInfo;
	}

	public static WireLineAnchorInfo DeserializeLength(BufferStream stream, int length)
	{
		WireLineAnchorInfo wireLineAnchorInfo = Pool.Get<WireLineAnchorInfo>();
		DeserializeLength(stream, length, wireLineAnchorInfo, isDelta: false);
		return wireLineAnchorInfo;
	}

	public static WireLineAnchorInfo Deserialize(byte[] buffer)
	{
		WireLineAnchorInfo wireLineAnchorInfo = Pool.Get<WireLineAnchorInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, wireLineAnchorInfo, isDelta: false);
		return wireLineAnchorInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WireLineAnchorInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WireLineAnchorInfo Deserialize(BufferStream stream, WireLineAnchorInfo instance, bool isDelta)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.parentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.boneName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.index = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static WireLineAnchorInfo DeserializeLengthDelimited(BufferStream stream, WireLineAnchorInfo instance, bool isDelta)
	{
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.parentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.boneName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.index = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WireLineAnchorInfo DeserializeLength(BufferStream stream, int length, WireLineAnchorInfo instance, bool isDelta)
	{
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.parentID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.boneName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.index = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WireLineAnchorInfo instance, WireLineAnchorInfo previous)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.parentID.Value);
		if (instance.boneName != previous.boneName)
		{
			if (instance.boneName == null)
			{
				throw new ArgumentNullException("boneName", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.boneName);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.index);
		if (instance.position != previous.position)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.position, previous.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, WireLineAnchorInfo instance)
	{
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		if (instance.parentID != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.parentID.Value);
		}
		if (instance.boneName == null)
		{
			throw new ArgumentNullException("boneName", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.boneName);
		if (instance.index != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.index);
		}
		if (instance.position != default(Vector3))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector3Serialized.Serialize(stream, instance.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref parentID.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class WireReconnectMessage : IDisposable, IPooled, IProto<WireReconnectMessage>, IProto
{
	[NonSerialized]
	public NetworkableId entityId;

	[NonSerialized]
	public int slotIndex;

	[NonSerialized]
	public bool isInput;

	[NonSerialized]
	public List<Vector3> linePoints;

	[NonSerialized]
	public int wireColor;

	[NonSerialized]
	public List<WireLineAnchorInfo> lineAnchors;

	[NonSerialized]
	public List<float> slackLevels;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WireReconnectMessage instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.entityId = default(NetworkableId);
		instance.slotIndex = 0;
		instance.isInput = false;
		if (instance.linePoints != null)
		{
			List<Vector3> list = instance.linePoints;
			Pool.FreeUnmanaged<Vector3>(ref list);
			instance.linePoints = list;
		}
		instance.wireColor = 0;
		if (instance.lineAnchors != null)
		{
			for (int i = 0; i < instance.lineAnchors.Count; i++)
			{
				if (instance.lineAnchors[i] != null)
				{
					instance.lineAnchors[i].ResetToPool();
					instance.lineAnchors[i] = null;
				}
			}
			List<WireLineAnchorInfo> list2 = instance.lineAnchors;
			Pool.Free<WireLineAnchorInfo>(ref list2, false);
			instance.lineAnchors = list2;
		}
		if (instance.slackLevels != null)
		{
			List<float> list3 = instance.slackLevels;
			Pool.FreeUnmanaged<float>(ref list3);
			instance.slackLevels = list3;
		}
		Pool.Free<WireReconnectMessage>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WireReconnectMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WireReconnectMessage instance)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		instance.entityId = entityId;
		instance.slotIndex = slotIndex;
		instance.isInput = isInput;
		if (linePoints != null)
		{
			instance.linePoints = Pool.Get<List<Vector3>>();
			for (int i = 0; i < linePoints.Count; i++)
			{
				Vector3 item = linePoints[i];
				instance.linePoints.Add(item);
			}
		}
		else
		{
			instance.linePoints = null;
		}
		instance.wireColor = wireColor;
		if (lineAnchors != null)
		{
			instance.lineAnchors = Pool.Get<List<WireLineAnchorInfo>>();
			for (int j = 0; j < lineAnchors.Count; j++)
			{
				WireLineAnchorInfo item2 = lineAnchors[j].Copy();
				instance.lineAnchors.Add(item2);
			}
		}
		else
		{
			instance.lineAnchors = null;
		}
		if (slackLevels != null)
		{
			instance.slackLevels = Pool.Get<List<float>>();
			for (int k = 0; k < slackLevels.Count; k++)
			{
				float item3 = slackLevels[k];
				instance.slackLevels.Add(item3);
			}
		}
		else
		{
			instance.slackLevels = null;
		}
	}

	public WireReconnectMessage Copy()
	{
		WireReconnectMessage wireReconnectMessage = Pool.Get<WireReconnectMessage>();
		CopyTo(wireReconnectMessage);
		return wireReconnectMessage;
	}

	public static WireReconnectMessage Deserialize(BufferStream stream)
	{
		WireReconnectMessage wireReconnectMessage = Pool.Get<WireReconnectMessage>();
		Deserialize(stream, wireReconnectMessage, isDelta: false);
		return wireReconnectMessage;
	}

	public static WireReconnectMessage DeserializeLengthDelimited(BufferStream stream)
	{
		WireReconnectMessage wireReconnectMessage = Pool.Get<WireReconnectMessage>();
		DeserializeLengthDelimited(stream, wireReconnectMessage, isDelta: false);
		return wireReconnectMessage;
	}

	public static WireReconnectMessage DeserializeLength(BufferStream stream, int length)
	{
		WireReconnectMessage wireReconnectMessage = Pool.Get<WireReconnectMessage>();
		DeserializeLength(stream, length, wireReconnectMessage, isDelta: false);
		return wireReconnectMessage;
	}

	public static WireReconnectMessage Deserialize(byte[] buffer)
	{
		WireReconnectMessage wireReconnectMessage = Pool.Get<WireReconnectMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, wireReconnectMessage, isDelta: false);
		return wireReconnectMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WireReconnectMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WireReconnectMessage Deserialize(BufferStream stream, WireReconnectMessage instance, bool isDelta)
	{
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.linePoints == null)
			{
				instance.linePoints = Pool.Get<List<Vector3>>();
			}
			if (instance.lineAnchors == null)
			{
				instance.lineAnchors = Pool.Get<List<WireLineAnchorInfo>>();
			}
			if (instance.slackLevels == null)
			{
				instance.slackLevels = Pool.Get<List<float>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 16:
				instance.slotIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 24:
				instance.isInput = ProtocolParser.ReadBool(stream);
				break;
			case 34:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			case 40:
				instance.wireColor = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 50:
				instance.lineAnchors.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
				break;
			case 61:
				instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static WireReconnectMessage DeserializeLengthDelimited(BufferStream stream, WireReconnectMessage instance, bool isDelta)
	{
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.linePoints == null)
			{
				instance.linePoints = Pool.Get<List<Vector3>>();
			}
			if (instance.lineAnchors == null)
			{
				instance.lineAnchors = Pool.Get<List<WireLineAnchorInfo>>();
			}
			if (instance.slackLevels == null)
			{
				instance.slackLevels = Pool.Get<List<float>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 16:
				instance.slotIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 24:
				instance.isInput = ProtocolParser.ReadBool(stream);
				break;
			case 34:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			case 40:
				instance.wireColor = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 50:
				instance.lineAnchors.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
				break;
			case 61:
				instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WireReconnectMessage DeserializeLength(BufferStream stream, int length, WireReconnectMessage instance, bool isDelta)
	{
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.linePoints == null)
			{
				instance.linePoints = Pool.Get<List<Vector3>>();
			}
			if (instance.lineAnchors == null)
			{
				instance.lineAnchors = Pool.Get<List<WireLineAnchorInfo>>();
			}
			if (instance.slackLevels == null)
			{
				instance.slackLevels = Pool.Get<List<float>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 16:
				instance.slotIndex = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 24:
				instance.isInput = ProtocolParser.ReadBool(stream);
				break;
			case 34:
			{
				Vector3 instance2 = default(Vector3);
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			case 40:
				instance.wireColor = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 50:
				instance.lineAnchors.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
				break;
			case 61:
				instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WireReconnectMessage instance, WireReconnectMessage previous)
	{
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		if (instance.slotIndex != previous.slotIndex)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slotIndex);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.isInput);
		if (instance.linePoints != null)
		{
			for (int i = 0; i < instance.linePoints.Count; i++)
			{
				Vector3 val = instance.linePoints[i];
				stream.WriteByte(34);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.SerializeDelta(stream, val, val);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.wireColor != previous.wireColor)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.wireColor);
		}
		if (instance.lineAnchors != null)
		{
			for (int j = 0; j < instance.lineAnchors.Count; j++)
			{
				WireLineAnchorInfo wireLineAnchorInfo = instance.lineAnchors[j];
				stream.WriteByte(50);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				WireLineAnchorInfo.SerializeDelta(stream, wireLineAnchorInfo, wireLineAnchorInfo);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.slackLevels != null)
		{
			for (int k = 0; k < instance.slackLevels.Count; k++)
			{
				float f = instance.slackLevels[k];
				stream.WriteByte(61);
				ProtocolParser.WriteSingle(stream, f);
			}
		}
	}

	public static void Serialize(BufferStream stream, WireReconnectMessage instance)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		if (instance.entityId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		}
		if (instance.slotIndex != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slotIndex);
		}
		if (instance.isInput)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.isInput);
		}
		if (instance.linePoints != null)
		{
			for (int i = 0; i < instance.linePoints.Count; i++)
			{
				Vector3 instance2 = instance.linePoints[i];
				stream.WriteByte(34);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector3Serialized.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.wireColor != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.wireColor);
		}
		if (instance.lineAnchors != null)
		{
			for (int j = 0; j < instance.lineAnchors.Count; j++)
			{
				WireLineAnchorInfo instance3 = instance.lineAnchors[j];
				stream.WriteByte(50);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				WireLineAnchorInfo.Serialize(stream, instance3);
				int val = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.slackLevels != null)
		{
			for (int k = 0; k < instance.slackLevels.Count; k++)
			{
				float f = instance.slackLevels[k];
				stream.WriteByte(61);
				ProtocolParser.WriteSingle(stream, f);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entityId.Value);
		if (lineAnchors != null)
		{
			for (int i = 0; i < lineAnchors.Count; i++)
			{
				lineAnchors[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class WorldData : IDisposable, IPooled, IProto<WorldData>, IProto
{
	[NonSerialized]
	public uint size;

	[NonSerialized]
	public List<MapData> maps;

	[NonSerialized]
	public List<PrefabData> prefabs;

	[NonSerialized]
	public List<PathData> paths;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WorldData instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.size = 0u;
		if (instance.maps != null)
		{
			for (int i = 0; i < instance.maps.Count; i++)
			{
				if (instance.maps[i] != null)
				{
					instance.maps[i].ResetToPool();
					instance.maps[i] = null;
				}
			}
			List<MapData> list = instance.maps;
			Pool.Free<MapData>(ref list, false);
			instance.maps = list;
		}
		if (instance.prefabs != null)
		{
			for (int j = 0; j < instance.prefabs.Count; j++)
			{
				if (instance.prefabs[j] != null)
				{
					instance.prefabs[j].ResetToPool();
					instance.prefabs[j] = null;
				}
			}
			List<PrefabData> list2 = instance.prefabs;
			Pool.Free<PrefabData>(ref list2, false);
			instance.prefabs = list2;
		}
		if (instance.paths != null)
		{
			for (int k = 0; k < instance.paths.Count; k++)
			{
				if (instance.paths[k] != null)
				{
					instance.paths[k].ResetToPool();
					instance.paths[k] = null;
				}
			}
			List<PathData> list3 = instance.paths;
			Pool.Free<PathData>(ref list3, false);
			instance.paths = list3;
		}
		Pool.Free<WorldData>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WorldData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WorldData instance)
	{
		instance.size = size;
		if (maps != null)
		{
			instance.maps = Pool.Get<List<MapData>>();
			for (int i = 0; i < maps.Count; i++)
			{
				MapData item = maps[i].Copy();
				instance.maps.Add(item);
			}
		}
		else
		{
			instance.maps = null;
		}
		if (prefabs != null)
		{
			instance.prefabs = Pool.Get<List<PrefabData>>();
			for (int j = 0; j < prefabs.Count; j++)
			{
				PrefabData item2 = prefabs[j].Copy();
				instance.prefabs.Add(item2);
			}
		}
		else
		{
			instance.prefabs = null;
		}
		if (paths != null)
		{
			instance.paths = Pool.Get<List<PathData>>();
			for (int k = 0; k < paths.Count; k++)
			{
				PathData item3 = paths[k].Copy();
				instance.paths.Add(item3);
			}
		}
		else
		{
			instance.paths = null;
		}
	}

	public WorldData Copy()
	{
		WorldData worldData = Pool.Get<WorldData>();
		CopyTo(worldData);
		return worldData;
	}

	public static WorldData Deserialize(BufferStream stream)
	{
		WorldData worldData = Pool.Get<WorldData>();
		Deserialize(stream, worldData, isDelta: false);
		return worldData;
	}

	public static WorldData DeserializeLengthDelimited(BufferStream stream)
	{
		WorldData worldData = Pool.Get<WorldData>();
		DeserializeLengthDelimited(stream, worldData, isDelta: false);
		return worldData;
	}

	public static WorldData DeserializeLength(BufferStream stream, int length)
	{
		WorldData worldData = Pool.Get<WorldData>();
		DeserializeLength(stream, length, worldData, isDelta: false);
		return worldData;
	}

	public static WorldData Deserialize(byte[] buffer)
	{
		WorldData worldData = Pool.Get<WorldData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, worldData, isDelta: false);
		return worldData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WorldData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WorldData Deserialize(BufferStream stream, WorldData instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.maps == null)
			{
				instance.maps = Pool.Get<List<MapData>>();
			}
			if (instance.prefabs == null)
			{
				instance.prefabs = Pool.Get<List<PrefabData>>();
			}
			if (instance.paths == null)
			{
				instance.paths = Pool.Get<List<PathData>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.size = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.maps.Add(MapData.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.prefabs.Add(PrefabData.DeserializeLengthDelimited(stream));
				continue;
			case 34:
				instance.paths.Add(PathData.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static WorldData DeserializeLengthDelimited(BufferStream stream, WorldData instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.maps == null)
			{
				instance.maps = Pool.Get<List<MapData>>();
			}
			if (instance.prefabs == null)
			{
				instance.prefabs = Pool.Get<List<PrefabData>>();
			}
			if (instance.paths == null)
			{
				instance.paths = Pool.Get<List<PathData>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.size = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.maps.Add(MapData.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.prefabs.Add(PrefabData.DeserializeLengthDelimited(stream));
				continue;
			case 34:
				instance.paths.Add(PathData.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WorldData DeserializeLength(BufferStream stream, int length, WorldData instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.maps == null)
			{
				instance.maps = Pool.Get<List<MapData>>();
			}
			if (instance.prefabs == null)
			{
				instance.prefabs = Pool.Get<List<PrefabData>>();
			}
			if (instance.paths == null)
			{
				instance.paths = Pool.Get<List<PathData>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.size = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.maps.Add(MapData.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.prefabs.Add(PrefabData.DeserializeLengthDelimited(stream));
				continue;
			case 34:
				instance.paths.Add(PathData.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WorldData instance, WorldData previous)
	{
		if (instance.size != previous.size)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.size);
		}
		if (instance.maps != null)
		{
			for (int i = 0; i < instance.maps.Count; i++)
			{
				MapData mapData = instance.maps[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				MapData.SerializeDelta(stream, mapData, mapData);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.prefabs != null)
		{
			for (int j = 0; j < instance.prefabs.Count; j++)
			{
				PrefabData prefabData = instance.prefabs[j];
				stream.WriteByte(26);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				PrefabData.SerializeDelta(stream, prefabData, prefabData);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.paths == null)
		{
			return;
		}
		for (int k = 0; k < instance.paths.Count; k++)
		{
			PathData pathData = instance.paths[k];
			stream.WriteByte(34);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			PathData.SerializeDelta(stream, pathData, pathData);
			int val3 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, WorldData instance)
	{
		if (instance.size != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.size);
		}
		if (instance.maps != null)
		{
			for (int i = 0; i < instance.maps.Count; i++)
			{
				MapData instance2 = instance.maps[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				MapData.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.prefabs != null)
		{
			for (int j = 0; j < instance.prefabs.Count; j++)
			{
				PrefabData instance3 = instance.prefabs[j];
				stream.WriteByte(26);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				PrefabData.Serialize(stream, instance3);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.paths == null)
		{
			return;
		}
		for (int k = 0; k < instance.paths.Count; k++)
		{
			PathData instance4 = instance.paths[k];
			stream.WriteByte(34);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			PathData.Serialize(stream, instance4);
			int val3 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (maps != null)
		{
			for (int i = 0; i < maps.Count; i++)
			{
				maps[i]?.InspectUids(action);
			}
		}
		if (prefabs != null)
		{
			for (int j = 0; j < prefabs.Count; j++)
			{
				prefabs[j]?.InspectUids(action);
			}
		}
		if (paths != null)
		{
			for (int k = 0; k < paths.Count; k++)
			{
				paths[k]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class WorldItem : IDisposable, IPooled, IProto<WorldItem>, IProto
{
	[NonSerialized]
	public Item item;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WorldItem instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.item != null)
			{
				instance.item.ResetToPool();
				instance.item = null;
			}
			Pool.Free<WorldItem>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WorldItem with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WorldItem instance)
	{
		if (item != null)
		{
			if (instance.item == null)
			{
				instance.item = item.Copy();
			}
			else
			{
				item.CopyTo(instance.item);
			}
		}
		else
		{
			instance.item = null;
		}
	}

	public WorldItem Copy()
	{
		WorldItem worldItem = Pool.Get<WorldItem>();
		CopyTo(worldItem);
		return worldItem;
	}

	public static WorldItem Deserialize(BufferStream stream)
	{
		WorldItem worldItem = Pool.Get<WorldItem>();
		Deserialize(stream, worldItem, isDelta: false);
		return worldItem;
	}

	public static WorldItem DeserializeLengthDelimited(BufferStream stream)
	{
		WorldItem worldItem = Pool.Get<WorldItem>();
		DeserializeLengthDelimited(stream, worldItem, isDelta: false);
		return worldItem;
	}

	public static WorldItem DeserializeLength(BufferStream stream, int length)
	{
		WorldItem worldItem = Pool.Get<WorldItem>();
		DeserializeLength(stream, length, worldItem, isDelta: false);
		return worldItem;
	}

	public static WorldItem Deserialize(byte[] buffer)
	{
		WorldItem worldItem = Pool.Get<WorldItem>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, worldItem, isDelta: false);
		return worldItem;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WorldItem previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WorldItem Deserialize(BufferStream stream, WorldItem instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.item == null)
				{
					instance.item = Item.DeserializeLengthDelimited(stream);
				}
				else
				{
					Item.DeserializeLengthDelimited(stream, instance.item, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static WorldItem DeserializeLengthDelimited(BufferStream stream, WorldItem instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.item == null)
				{
					instance.item = Item.DeserializeLengthDelimited(stream);
				}
				else
				{
					Item.DeserializeLengthDelimited(stream, instance.item, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WorldItem DeserializeLength(BufferStream stream, int length, WorldItem instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.item == null)
				{
					instance.item = Item.DeserializeLengthDelimited(stream);
				}
				else
				{
					Item.DeserializeLengthDelimited(stream, instance.item, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WorldItem instance, WorldItem previous)
	{
		if (instance.item == null)
		{
			return;
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		Item.SerializeDelta(stream, instance.item, previous.item);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, WorldItem instance)
	{
		if (instance.item == null)
		{
			return;
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		Item.Serialize(stream, instance.item);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		item?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class WorldMessage : IDisposable, IPooled, IProto<WorldMessage>, IProto
{
	public enum MessageType
	{
		Request = 1,
		Receive,
		Done
	}

	[NonSerialized]
	public MessageType status;

	[NonSerialized]
	public List<PrefabData> prefabs;

	[NonSerialized]
	public List<PathData> paths;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WorldMessage instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.status = (MessageType)0;
		if (instance.prefabs != null)
		{
			for (int i = 0; i < instance.prefabs.Count; i++)
			{
				if (instance.prefabs[i] != null)
				{
					instance.prefabs[i].ResetToPool();
					instance.prefabs[i] = null;
				}
			}
			List<PrefabData> list = instance.prefabs;
			Pool.Free<PrefabData>(ref list, false);
			instance.prefabs = list;
		}
		if (instance.paths != null)
		{
			for (int j = 0; j < instance.paths.Count; j++)
			{
				if (instance.paths[j] != null)
				{
					instance.paths[j].ResetToPool();
					instance.paths[j] = null;
				}
			}
			List<PathData> list2 = instance.paths;
			Pool.Free<PathData>(ref list2, false);
			instance.paths = list2;
		}
		Pool.Free<WorldMessage>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WorldMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WorldMessage instance)
	{
		instance.status = status;
		if (prefabs != null)
		{
			instance.prefabs = Pool.Get<List<PrefabData>>();
			for (int i = 0; i < prefabs.Count; i++)
			{
				PrefabData item = prefabs[i].Copy();
				instance.prefabs.Add(item);
			}
		}
		else
		{
			instance.prefabs = null;
		}
		if (paths != null)
		{
			instance.paths = Pool.Get<List<PathData>>();
			for (int j = 0; j < paths.Count; j++)
			{
				PathData item2 = paths[j].Copy();
				instance.paths.Add(item2);
			}
		}
		else
		{
			instance.paths = null;
		}
	}

	public WorldMessage Copy()
	{
		WorldMessage worldMessage = Pool.Get<WorldMessage>();
		CopyTo(worldMessage);
		return worldMessage;
	}

	public static WorldMessage Deserialize(BufferStream stream)
	{
		WorldMessage worldMessage = Pool.Get<WorldMessage>();
		Deserialize(stream, worldMessage, isDelta: false);
		return worldMessage;
	}

	public static WorldMessage DeserializeLengthDelimited(BufferStream stream)
	{
		WorldMessage worldMessage = Pool.Get<WorldMessage>();
		DeserializeLengthDelimited(stream, worldMessage, isDelta: false);
		return worldMessage;
	}

	public static WorldMessage DeserializeLength(BufferStream stream, int length)
	{
		WorldMessage worldMessage = Pool.Get<WorldMessage>();
		DeserializeLength(stream, length, worldMessage, isDelta: false);
		return worldMessage;
	}

	public static WorldMessage Deserialize(byte[] buffer)
	{
		WorldMessage worldMessage = Pool.Get<WorldMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, worldMessage, isDelta: false);
		return worldMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, WorldMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WorldMessage Deserialize(BufferStream stream, WorldMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.prefabs == null)
			{
				instance.prefabs = Pool.Get<List<PrefabData>>();
			}
			if (instance.paths == null)
			{
				instance.paths = Pool.Get<List<PathData>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.status = (MessageType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.prefabs.Add(PrefabData.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.paths.Add(PathData.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static WorldMessage DeserializeLengthDelimited(BufferStream stream, WorldMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.prefabs == null)
			{
				instance.prefabs = Pool.Get<List<PrefabData>>();
			}
			if (instance.paths == null)
			{
				instance.paths = Pool.Get<List<PathData>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.status = (MessageType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.prefabs.Add(PrefabData.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.paths.Add(PathData.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WorldMessage DeserializeLength(BufferStream stream, int length, WorldMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.prefabs == null)
			{
				instance.prefabs = Pool.Get<List<PrefabData>>();
			}
			if (instance.paths == null)
			{
				instance.paths = Pool.Get<List<PathData>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.status = (MessageType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.prefabs.Add(PrefabData.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.paths.Add(PathData.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, WorldMessage instance, WorldMessage previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.status);
		if (instance.prefabs != null)
		{
			for (int i = 0; i < instance.prefabs.Count; i++)
			{
				PrefabData prefabData = instance.prefabs[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PrefabData.SerializeDelta(stream, prefabData, prefabData);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.paths == null)
		{
			return;
		}
		for (int j = 0; j < instance.paths.Count; j++)
		{
			PathData pathData = instance.paths[j];
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			PathData.SerializeDelta(stream, pathData, pathData);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, WorldMessage instance)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.status);
		if (instance.prefabs != null)
		{
			for (int i = 0; i < instance.prefabs.Count; i++)
			{
				PrefabData instance2 = instance.prefabs[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				PrefabData.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.paths == null)
		{
			return;
		}
		for (int j = 0; j < instance.paths.Count; j++)
		{
			PathData instance3 = instance.paths[j];
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			PathData.Serialize(stream, instance3);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (prefabs != null)
		{
			for (int i = 0; i < prefabs.Count; i++)
			{
				prefabs[i]?.InspectUids(action);
			}
		}
		if (paths != null)
		{
			for (int j = 0; j < paths.Count; j++)
			{
				paths[j]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Zipline : IDisposable, IPooled, IProto<Zipline>, IProto
{
	[NonSerialized]
	public List<VectorData> destinationPoints;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Zipline instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.destinationPoints != null)
			{
				List<VectorData> list = instance.destinationPoints;
				Pool.FreeUnmanaged<VectorData>(ref list);
				instance.destinationPoints = list;
			}
			Pool.Free<Zipline>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Zipline with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Zipline instance)
	{
		if (destinationPoints != null)
		{
			instance.destinationPoints = Pool.Get<List<VectorData>>();
			for (int i = 0; i < destinationPoints.Count; i++)
			{
				VectorData item = destinationPoints[i];
				instance.destinationPoints.Add(item);
			}
		}
		else
		{
			instance.destinationPoints = null;
		}
	}

	public Zipline Copy()
	{
		Zipline zipline = Pool.Get<Zipline>();
		CopyTo(zipline);
		return zipline;
	}

	public static Zipline Deserialize(BufferStream stream)
	{
		Zipline zipline = Pool.Get<Zipline>();
		Deserialize(stream, zipline, isDelta: false);
		return zipline;
	}

	public static Zipline DeserializeLengthDelimited(BufferStream stream)
	{
		Zipline zipline = Pool.Get<Zipline>();
		DeserializeLengthDelimited(stream, zipline, isDelta: false);
		return zipline;
	}

	public static Zipline DeserializeLength(BufferStream stream, int length)
	{
		Zipline zipline = Pool.Get<Zipline>();
		DeserializeLength(stream, length, zipline, isDelta: false);
		return zipline;
	}

	public static Zipline Deserialize(byte[] buffer)
	{
		Zipline zipline = Pool.Get<Zipline>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, zipline, isDelta: false);
		return zipline;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Zipline previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Zipline Deserialize(BufferStream stream, Zipline instance, bool isDelta)
	{
		if (!isDelta && instance.destinationPoints == null)
		{
			instance.destinationPoints = Pool.Get<List<VectorData>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.destinationPoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static Zipline DeserializeLengthDelimited(BufferStream stream, Zipline instance, bool isDelta)
	{
		if (!isDelta && instance.destinationPoints == null)
		{
			instance.destinationPoints = Pool.Get<List<VectorData>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.destinationPoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Zipline DeserializeLength(BufferStream stream, int length, Zipline instance, bool isDelta)
	{
		if (!isDelta && instance.destinationPoints == null)
		{
			instance.destinationPoints = Pool.Get<List<VectorData>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.destinationPoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Zipline instance, Zipline previous)
	{
		if (instance.destinationPoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.destinationPoints.Count; i++)
		{
			VectorData vectorData = instance.destinationPoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			VectorData.SerializeDelta(stream, vectorData, vectorData);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field destinationPoints (ProtoBuf.VectorData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, Zipline instance)
	{
		if (instance.destinationPoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.destinationPoints.Count; i++)
		{
			VectorData instance2 = instance.destinationPoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			VectorData.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field destinationPoints (ProtoBuf.VectorData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (destinationPoints != null)
		{
			for (int i = 0; i < destinationPoints.Count; i++)
			{
				destinationPoints[i].InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ZiplineArrivalPoint : IDisposable, IPooled, IProto<ZiplineArrivalPoint>, IProto
{
	[NonSerialized]
	public List<VectorData> linePoints;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ZiplineArrivalPoint instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.linePoints != null)
			{
				List<VectorData> list = instance.linePoints;
				Pool.FreeUnmanaged<VectorData>(ref list);
				instance.linePoints = list;
			}
			Pool.Free<ZiplineArrivalPoint>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ZiplineArrivalPoint with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ZiplineArrivalPoint instance)
	{
		if (linePoints != null)
		{
			instance.linePoints = Pool.Get<List<VectorData>>();
			for (int i = 0; i < linePoints.Count; i++)
			{
				VectorData item = linePoints[i];
				instance.linePoints.Add(item);
			}
		}
		else
		{
			instance.linePoints = null;
		}
	}

	public ZiplineArrivalPoint Copy()
	{
		ZiplineArrivalPoint ziplineArrivalPoint = Pool.Get<ZiplineArrivalPoint>();
		CopyTo(ziplineArrivalPoint);
		return ziplineArrivalPoint;
	}

	public static ZiplineArrivalPoint Deserialize(BufferStream stream)
	{
		ZiplineArrivalPoint ziplineArrivalPoint = Pool.Get<ZiplineArrivalPoint>();
		Deserialize(stream, ziplineArrivalPoint, isDelta: false);
		return ziplineArrivalPoint;
	}

	public static ZiplineArrivalPoint DeserializeLengthDelimited(BufferStream stream)
	{
		ZiplineArrivalPoint ziplineArrivalPoint = Pool.Get<ZiplineArrivalPoint>();
		DeserializeLengthDelimited(stream, ziplineArrivalPoint, isDelta: false);
		return ziplineArrivalPoint;
	}

	public static ZiplineArrivalPoint DeserializeLength(BufferStream stream, int length)
	{
		ZiplineArrivalPoint ziplineArrivalPoint = Pool.Get<ZiplineArrivalPoint>();
		DeserializeLength(stream, length, ziplineArrivalPoint, isDelta: false);
		return ziplineArrivalPoint;
	}

	public static ZiplineArrivalPoint Deserialize(byte[] buffer)
	{
		ZiplineArrivalPoint ziplineArrivalPoint = Pool.Get<ZiplineArrivalPoint>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ziplineArrivalPoint, isDelta: false);
		return ziplineArrivalPoint;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ZiplineArrivalPoint previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ZiplineArrivalPoint Deserialize(BufferStream stream, ZiplineArrivalPoint instance, bool isDelta)
	{
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<VectorData>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static ZiplineArrivalPoint DeserializeLengthDelimited(BufferStream stream, ZiplineArrivalPoint instance, bool isDelta)
	{
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<VectorData>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ZiplineArrivalPoint DeserializeLength(BufferStream stream, int length, ZiplineArrivalPoint instance, bool isDelta)
	{
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<VectorData>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ZiplineArrivalPoint instance, ZiplineArrivalPoint previous)
	{
		if (instance.linePoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.linePoints.Count; i++)
		{
			VectorData vectorData = instance.linePoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			VectorData.SerializeDelta(stream, vectorData, vectorData);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (ProtoBuf.VectorData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, ZiplineArrivalPoint instance)
	{
		if (instance.linePoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.linePoints.Count; i++)
		{
			VectorData instance2 = instance.linePoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			VectorData.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (ProtoBuf.VectorData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (linePoints != null)
		{
			for (int i = 0; i < linePoints.Count; i++)
			{
				linePoints[i].InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ZiplineMountable : IDisposable, IPooled, IProto<ZiplineMountable>, IProto
{
	[NonSerialized]
	public List<VectorData> linePoints;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ZiplineMountable instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.linePoints != null)
			{
				List<VectorData> list = instance.linePoints;
				Pool.FreeUnmanaged<VectorData>(ref list);
				instance.linePoints = list;
			}
			Pool.Free<ZiplineMountable>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ZiplineMountable with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ZiplineMountable instance)
	{
		if (linePoints != null)
		{
			instance.linePoints = Pool.Get<List<VectorData>>();
			for (int i = 0; i < linePoints.Count; i++)
			{
				VectorData item = linePoints[i];
				instance.linePoints.Add(item);
			}
		}
		else
		{
			instance.linePoints = null;
		}
	}

	public ZiplineMountable Copy()
	{
		ZiplineMountable ziplineMountable = Pool.Get<ZiplineMountable>();
		CopyTo(ziplineMountable);
		return ziplineMountable;
	}

	public static ZiplineMountable Deserialize(BufferStream stream)
	{
		ZiplineMountable ziplineMountable = Pool.Get<ZiplineMountable>();
		Deserialize(stream, ziplineMountable, isDelta: false);
		return ziplineMountable;
	}

	public static ZiplineMountable DeserializeLengthDelimited(BufferStream stream)
	{
		ZiplineMountable ziplineMountable = Pool.Get<ZiplineMountable>();
		DeserializeLengthDelimited(stream, ziplineMountable, isDelta: false);
		return ziplineMountable;
	}

	public static ZiplineMountable DeserializeLength(BufferStream stream, int length)
	{
		ZiplineMountable ziplineMountable = Pool.Get<ZiplineMountable>();
		DeserializeLength(stream, length, ziplineMountable, isDelta: false);
		return ziplineMountable;
	}

	public static ZiplineMountable Deserialize(byte[] buffer)
	{
		ZiplineMountable ziplineMountable = Pool.Get<ZiplineMountable>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ziplineMountable, isDelta: false);
		return ziplineMountable;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ZiplineMountable previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ZiplineMountable Deserialize(BufferStream stream, ZiplineMountable instance, bool isDelta)
	{
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<VectorData>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static ZiplineMountable DeserializeLengthDelimited(BufferStream stream, ZiplineMountable instance, bool isDelta)
	{
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<VectorData>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ZiplineMountable DeserializeLength(BufferStream stream, int length, ZiplineMountable instance, bool isDelta)
	{
		if (!isDelta && instance.linePoints == null)
		{
			instance.linePoints = Pool.Get<List<VectorData>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
			{
				VectorData instance2 = default(VectorData);
				VectorData.DeserializeLengthDelimited(stream, ref instance2, isDelta);
				instance.linePoints.Add(instance2);
				break;
			}
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ZiplineMountable instance, ZiplineMountable previous)
	{
		if (instance.linePoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.linePoints.Count; i++)
		{
			VectorData vectorData = instance.linePoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			VectorData.SerializeDelta(stream, vectorData, vectorData);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (ProtoBuf.VectorData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, ZiplineMountable instance)
	{
		if (instance.linePoints == null)
		{
			return;
		}
		for (int i = 0; i < instance.linePoints.Count; i++)
		{
			VectorData instance2 = instance.linePoints[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			VectorData.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePoints (ProtoBuf.VectorData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (linePoints != null)
		{
			for (int i = 0; i < linePoints.Count; i++)
			{
				linePoints[i].InspectUids(action);
			}
		}
	}
}


public enum AppEntityType
{
	Switch = 1,
	Alarm,
	StorageMonitor
}


public enum AppMarkerType
{
	Undefined,
	Player,
	Explosion,
	VendingMachine,
	CH47,
	CargoShip,
	Crate,
	GenericRadius,
	PatrolHelicopter,
	TravellingVendor
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class ClanChatBatchRequest : IDisposable, IPooled, IProto<ClanChatBatchRequest>, IProto
{
	public class Message : IDisposable, IPooled, IProto<Message>, IProto
	{
		[NonSerialized]
		public long clanId;

		[NonSerialized]
		public ulong userId;

		[NonSerialized]
		public string text;

		[NonSerialized]
		public string name;

		[NonSerialized]
		public long timestamp;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Message instance)
		{
			if (instance.ShouldPool)
			{
				instance.clanId = 0L;
				instance.userId = 0uL;
				instance.text = string.Empty;
				instance.name = string.Empty;
				instance.timestamp = 0L;
				Pool.Free<Message>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Message with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Message instance)
		{
			instance.clanId = clanId;
			instance.userId = userId;
			instance.text = text;
			instance.name = name;
			instance.timestamp = timestamp;
		}

		public Message Copy()
		{
			Message message = Pool.Get<Message>();
			CopyTo(message);
			return message;
		}

		public static Message Deserialize(BufferStream stream)
		{
			Message message = Pool.Get<Message>();
			Deserialize(stream, message, isDelta: false);
			return message;
		}

		public static Message DeserializeLengthDelimited(BufferStream stream)
		{
			Message message = Pool.Get<Message>();
			DeserializeLengthDelimited(stream, message, isDelta: false);
			return message;
		}

		public static Message DeserializeLength(BufferStream stream, int length)
		{
			Message message = Pool.Get<Message>();
			DeserializeLength(stream, length, message, isDelta: false);
			return message;
		}

		public static Message Deserialize(byte[] buffer)
		{
			Message message = Pool.Get<Message>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, message, isDelta: false);
			return message;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Message previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Message Deserialize(BufferStream stream, Message instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.userId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					instance.text = ProtocolParser.ReadString(stream);
					continue;
				case 34:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 40:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
				case 0:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Message DeserializeLengthDelimited(BufferStream stream, Message instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.userId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					instance.text = ProtocolParser.ReadString(stream);
					continue;
				case 34:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 40:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Message DeserializeLength(BufferStream stream, int length, Message instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.userId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					instance.text = ProtocolParser.ReadString(stream);
					continue;
				case 34:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 40:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Message instance, Message previous)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
			if (instance.userId != previous.userId)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.userId);
			}
			if (instance.text != previous.text)
			{
				if (instance.text == null)
				{
					throw new ArgumentNullException("text", "Required by proto specification.");
				}
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, instance.text);
			}
			if (instance.name != previous.name)
			{
				if (instance.name == null)
				{
					throw new ArgumentNullException("name", "Required by proto specification.");
				}
				stream.WriteByte(34);
				ProtocolParser.WriteString(stream, instance.name);
			}
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}

		public static void Serialize(BufferStream stream, Message instance)
		{
			if (instance.clanId != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
			}
			if (instance.userId != 0L)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.userId);
			}
			if (instance.text == null)
			{
				throw new ArgumentNullException("text", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.text);
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.name);
			if (instance.timestamp != 0L)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<Message> messages;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClanChatBatchRequest instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.messages != null)
		{
			for (int i = 0; i < instance.messages.Count; i++)
			{
				if (instance.messages[i] != null)
				{
					instance.messages[i].ResetToPool();
					instance.messages[i] = null;
				}
			}
			List<Message> list = instance.messages;
			Pool.Free<Message>(ref list, false);
			instance.messages = list;
		}
		Pool.Free<ClanChatBatchRequest>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClanChatBatchRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClanChatBatchRequest instance)
	{
		if (messages != null)
		{
			instance.messages = Pool.Get<List<Message>>();
			for (int i = 0; i < messages.Count; i++)
			{
				Message item = messages[i].Copy();
				instance.messages.Add(item);
			}
		}
		else
		{
			instance.messages = null;
		}
	}

	public ClanChatBatchRequest Copy()
	{
		ClanChatBatchRequest clanChatBatchRequest = Pool.Get<ClanChatBatchRequest>();
		CopyTo(clanChatBatchRequest);
		return clanChatBatchRequest;
	}

	public static ClanChatBatchRequest Deserialize(BufferStream stream)
	{
		ClanChatBatchRequest clanChatBatchRequest = Pool.Get<ClanChatBatchRequest>();
		Deserialize(stream, clanChatBatchRequest, isDelta: false);
		return clanChatBatchRequest;
	}

	public static ClanChatBatchRequest DeserializeLengthDelimited(BufferStream stream)
	{
		ClanChatBatchRequest clanChatBatchRequest = Pool.Get<ClanChatBatchRequest>();
		DeserializeLengthDelimited(stream, clanChatBatchRequest, isDelta: false);
		return clanChatBatchRequest;
	}

	public static ClanChatBatchRequest DeserializeLength(BufferStream stream, int length)
	{
		ClanChatBatchRequest clanChatBatchRequest = Pool.Get<ClanChatBatchRequest>();
		DeserializeLength(stream, length, clanChatBatchRequest, isDelta: false);
		return clanChatBatchRequest;
	}

	public static ClanChatBatchRequest Deserialize(byte[] buffer)
	{
		ClanChatBatchRequest clanChatBatchRequest = Pool.Get<ClanChatBatchRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, clanChatBatchRequest, isDelta: false);
		return clanChatBatchRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClanChatBatchRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClanChatBatchRequest Deserialize(BufferStream stream, ClanChatBatchRequest instance, bool isDelta)
	{
		if (!isDelta && instance.messages == null)
		{
			instance.messages = Pool.Get<List<Message>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.messages.Add(Message.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ClanChatBatchRequest DeserializeLengthDelimited(BufferStream stream, ClanChatBatchRequest instance, bool isDelta)
	{
		if (!isDelta && instance.messages == null)
		{
			instance.messages = Pool.Get<List<Message>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.messages.Add(Message.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClanChatBatchRequest DeserializeLength(BufferStream stream, int length, ClanChatBatchRequest instance, bool isDelta)
	{
		if (!isDelta && instance.messages == null)
		{
			instance.messages = Pool.Get<List<Message>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.messages.Add(Message.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClanChatBatchRequest instance, ClanChatBatchRequest previous)
	{
		if (instance.messages == null)
		{
			return;
		}
		for (int i = 0; i < instance.messages.Count; i++)
		{
			Message message = instance.messages[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Message.SerializeDelta(stream, message, message);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, ClanChatBatchRequest instance)
	{
		if (instance.messages == null)
		{
			return;
		}
		for (int i = 0; i < instance.messages.Count; i++)
		{
			Message instance2 = instance.messages[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Message.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (messages != null)
		{
			for (int i = 0; i < messages.Count; i++)
			{
				messages[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class FerryRetireRequest : IDisposable, IPooled, IProto<FerryRetireRequest>, IProto
{
	[NonSerialized]
	public NetworkableId entityId;

	[NonSerialized]
	public long timestamp;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(FerryRetireRequest instance)
	{
		if (instance.ShouldPool)
		{
			instance.entityId = default(NetworkableId);
			instance.timestamp = 0L;
			Pool.Free<FerryRetireRequest>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose FerryRetireRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(FerryRetireRequest instance)
	{
		instance.entityId = entityId;
		instance.timestamp = timestamp;
	}

	public FerryRetireRequest Copy()
	{
		FerryRetireRequest ferryRetireRequest = Pool.Get<FerryRetireRequest>();
		CopyTo(ferryRetireRequest);
		return ferryRetireRequest;
	}

	public static FerryRetireRequest Deserialize(BufferStream stream)
	{
		FerryRetireRequest ferryRetireRequest = Pool.Get<FerryRetireRequest>();
		Deserialize(stream, ferryRetireRequest, isDelta: false);
		return ferryRetireRequest;
	}

	public static FerryRetireRequest DeserializeLengthDelimited(BufferStream stream)
	{
		FerryRetireRequest ferryRetireRequest = Pool.Get<FerryRetireRequest>();
		DeserializeLengthDelimited(stream, ferryRetireRequest, isDelta: false);
		return ferryRetireRequest;
	}

	public static FerryRetireRequest DeserializeLength(BufferStream stream, int length)
	{
		FerryRetireRequest ferryRetireRequest = Pool.Get<FerryRetireRequest>();
		DeserializeLength(stream, length, ferryRetireRequest, isDelta: false);
		return ferryRetireRequest;
	}

	public static FerryRetireRequest Deserialize(byte[] buffer)
	{
		FerryRetireRequest ferryRetireRequest = Pool.Get<FerryRetireRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ferryRetireRequest, isDelta: false);
		return ferryRetireRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, FerryRetireRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static FerryRetireRequest Deserialize(BufferStream stream, FerryRetireRequest instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static FerryRetireRequest DeserializeLengthDelimited(BufferStream stream, FerryRetireRequest instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static FerryRetireRequest DeserializeLength(BufferStream stream, int length, FerryRetireRequest instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, FerryRetireRequest instance, FerryRetireRequest previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
	}

	public static void Serialize(BufferStream stream, FerryRetireRequest instance)
	{
		if (instance.entityId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		}
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entityId.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class FerryStatus : IDisposable, IPooled, IProto<FerryStatus>, IProto
{
	[NonSerialized]
	public NetworkableId entityId;

	[NonSerialized]
	public long timestamp;

	[NonSerialized]
	public string ownerZone;

	[NonSerialized]
	public List<string> schedule;

	[NonSerialized]
	public int scheduleIndex;

	[NonSerialized]
	public int state;

	[NonSerialized]
	public bool isRetiring;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(FerryStatus instance)
	{
		if (instance.ShouldPool)
		{
			instance.entityId = default(NetworkableId);
			instance.timestamp = 0L;
			instance.ownerZone = string.Empty;
			if (instance.schedule != null)
			{
				List<string> list = instance.schedule;
				Pool.FreeUnmanaged<string>(ref list);
				instance.schedule = list;
			}
			instance.scheduleIndex = 0;
			instance.state = 0;
			instance.isRetiring = false;
			Pool.Free<FerryStatus>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose FerryStatus with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(FerryStatus instance)
	{
		instance.entityId = entityId;
		instance.timestamp = timestamp;
		instance.ownerZone = ownerZone;
		if (schedule != null)
		{
			instance.schedule = Pool.Get<List<string>>();
			for (int i = 0; i < schedule.Count; i++)
			{
				string item = schedule[i];
				instance.schedule.Add(item);
			}
		}
		else
		{
			instance.schedule = null;
		}
		instance.scheduleIndex = scheduleIndex;
		instance.state = state;
		instance.isRetiring = isRetiring;
	}

	public FerryStatus Copy()
	{
		FerryStatus ferryStatus = Pool.Get<FerryStatus>();
		CopyTo(ferryStatus);
		return ferryStatus;
	}

	public static FerryStatus Deserialize(BufferStream stream)
	{
		FerryStatus ferryStatus = Pool.Get<FerryStatus>();
		Deserialize(stream, ferryStatus, isDelta: false);
		return ferryStatus;
	}

	public static FerryStatus DeserializeLengthDelimited(BufferStream stream)
	{
		FerryStatus ferryStatus = Pool.Get<FerryStatus>();
		DeserializeLengthDelimited(stream, ferryStatus, isDelta: false);
		return ferryStatus;
	}

	public static FerryStatus DeserializeLength(BufferStream stream, int length)
	{
		FerryStatus ferryStatus = Pool.Get<FerryStatus>();
		DeserializeLength(stream, length, ferryStatus, isDelta: false);
		return ferryStatus;
	}

	public static FerryStatus Deserialize(byte[] buffer)
	{
		FerryStatus ferryStatus = Pool.Get<FerryStatus>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ferryStatus, isDelta: false);
		return ferryStatus;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, FerryStatus previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static FerryStatus Deserialize(BufferStream stream, FerryStatus instance, bool isDelta)
	{
		if (!isDelta && instance.schedule == null)
		{
			instance.schedule = Pool.Get<List<string>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.ownerZone = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			case 40:
				instance.scheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.isRetiring = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static FerryStatus DeserializeLengthDelimited(BufferStream stream, FerryStatus instance, bool isDelta)
	{
		if (!isDelta && instance.schedule == null)
		{
			instance.schedule = Pool.Get<List<string>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.ownerZone = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			case 40:
				instance.scheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.isRetiring = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static FerryStatus DeserializeLength(BufferStream stream, int length, FerryStatus instance, bool isDelta)
	{
		if (!isDelta && instance.schedule == null)
		{
			instance.schedule = Pool.Get<List<string>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.ownerZone = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			case 40:
				instance.scheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.isRetiring = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, FerryStatus instance, FerryStatus previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		if (instance.ownerZone != previous.ownerZone)
		{
			if (instance.ownerZone == null)
			{
				throw new ArgumentNullException("ownerZone", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.ownerZone);
		}
		if (instance.schedule != null)
		{
			for (int i = 0; i < instance.schedule.Count; i++)
			{
				string val = instance.schedule[i];
				stream.WriteByte(34);
				ProtocolParser.WriteString(stream, val);
			}
		}
		if (instance.scheduleIndex != previous.scheduleIndex)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.scheduleIndex);
		}
		if (instance.state != previous.state)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.isRetiring);
	}

	public static void Serialize(BufferStream stream, FerryStatus instance)
	{
		if (instance.entityId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		}
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
		if (instance.ownerZone == null)
		{
			throw new ArgumentNullException("ownerZone", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.ownerZone);
		if (instance.schedule != null)
		{
			for (int i = 0; i < instance.schedule.Count; i++)
			{
				string val = instance.schedule[i];
				stream.WriteByte(34);
				ProtocolParser.WriteString(stream, val);
			}
		}
		if (instance.scheduleIndex != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.scheduleIndex);
		}
		if (instance.state != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		if (instance.isRetiring)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.isRetiring);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entityId.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class FerryStatusRequest : IDisposable, IPooled, IProto<FerryStatusRequest>, IProto
{
	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(FerryStatusRequest instance)
	{
		if (instance.ShouldPool)
		{
			Pool.Free<FerryStatusRequest>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose FerryStatusRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(FerryStatusRequest instance)
	{
	}

	public FerryStatusRequest Copy()
	{
		FerryStatusRequest ferryStatusRequest = Pool.Get<FerryStatusRequest>();
		CopyTo(ferryStatusRequest);
		return ferryStatusRequest;
	}

	public static FerryStatusRequest Deserialize(BufferStream stream)
	{
		FerryStatusRequest ferryStatusRequest = Pool.Get<FerryStatusRequest>();
		Deserialize(stream, ferryStatusRequest, isDelta: false);
		return ferryStatusRequest;
	}

	public static FerryStatusRequest DeserializeLengthDelimited(BufferStream stream)
	{
		FerryStatusRequest ferryStatusRequest = Pool.Get<FerryStatusRequest>();
		DeserializeLengthDelimited(stream, ferryStatusRequest, isDelta: false);
		return ferryStatusRequest;
	}

	public static FerryStatusRequest DeserializeLength(BufferStream stream, int length)
	{
		FerryStatusRequest ferryStatusRequest = Pool.Get<FerryStatusRequest>();
		DeserializeLength(stream, length, ferryStatusRequest, isDelta: false);
		return ferryStatusRequest;
	}

	public static FerryStatusRequest Deserialize(byte[] buffer)
	{
		FerryStatusRequest ferryStatusRequest = Pool.Get<FerryStatusRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ferryStatusRequest, isDelta: false);
		return ferryStatusRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, FerryStatusRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static FerryStatusRequest Deserialize(BufferStream stream, FerryStatusRequest instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			if (num == -1 || num == 0)
			{
				break;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static FerryStatusRequest DeserializeLengthDelimited(BufferStream stream, FerryStatusRequest instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static FerryStatusRequest DeserializeLength(BufferStream stream, int length, FerryStatusRequest instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, FerryStatusRequest instance, FerryStatusRequest previous)
	{
	}

	public static void Serialize(BufferStream stream, FerryStatusRequest instance)
	{
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class FerryStatusResponse : IDisposable, IPooled, IProto<FerryStatusResponse>, IProto
{
	[NonSerialized]
	public List<FerryStatus> statuses;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(FerryStatusResponse instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.statuses != null)
		{
			for (int i = 0; i < instance.statuses.Count; i++)
			{
				if (instance.statuses[i] != null)
				{
					instance.statuses[i].ResetToPool();
					instance.statuses[i] = null;
				}
			}
			List<FerryStatus> list = instance.statuses;
			Pool.Free<FerryStatus>(ref list, false);
			instance.statuses = list;
		}
		Pool.Free<FerryStatusResponse>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose FerryStatusResponse with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(FerryStatusResponse instance)
	{
		if (statuses != null)
		{
			instance.statuses = Pool.Get<List<FerryStatus>>();
			for (int i = 0; i < statuses.Count; i++)
			{
				FerryStatus item = statuses[i].Copy();
				instance.statuses.Add(item);
			}
		}
		else
		{
			instance.statuses = null;
		}
	}

	public FerryStatusResponse Copy()
	{
		FerryStatusResponse ferryStatusResponse = Pool.Get<FerryStatusResponse>();
		CopyTo(ferryStatusResponse);
		return ferryStatusResponse;
	}

	public static FerryStatusResponse Deserialize(BufferStream stream)
	{
		FerryStatusResponse ferryStatusResponse = Pool.Get<FerryStatusResponse>();
		Deserialize(stream, ferryStatusResponse, isDelta: false);
		return ferryStatusResponse;
	}

	public static FerryStatusResponse DeserializeLengthDelimited(BufferStream stream)
	{
		FerryStatusResponse ferryStatusResponse = Pool.Get<FerryStatusResponse>();
		DeserializeLengthDelimited(stream, ferryStatusResponse, isDelta: false);
		return ferryStatusResponse;
	}

	public static FerryStatusResponse DeserializeLength(BufferStream stream, int length)
	{
		FerryStatusResponse ferryStatusResponse = Pool.Get<FerryStatusResponse>();
		DeserializeLength(stream, length, ferryStatusResponse, isDelta: false);
		return ferryStatusResponse;
	}

	public static FerryStatusResponse Deserialize(byte[] buffer)
	{
		FerryStatusResponse ferryStatusResponse = Pool.Get<FerryStatusResponse>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ferryStatusResponse, isDelta: false);
		return ferryStatusResponse;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, FerryStatusResponse previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static FerryStatusResponse Deserialize(BufferStream stream, FerryStatusResponse instance, bool isDelta)
	{
		if (!isDelta && instance.statuses == null)
		{
			instance.statuses = Pool.Get<List<FerryStatus>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.statuses.Add(FerryStatus.DeserializeLengthDelimited(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static FerryStatusResponse DeserializeLengthDelimited(BufferStream stream, FerryStatusResponse instance, bool isDelta)
	{
		if (!isDelta && instance.statuses == null)
		{
			instance.statuses = Pool.Get<List<FerryStatus>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.statuses.Add(FerryStatus.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static FerryStatusResponse DeserializeLength(BufferStream stream, int length, FerryStatusResponse instance, bool isDelta)
	{
		if (!isDelta && instance.statuses == null)
		{
			instance.statuses = Pool.Get<List<FerryStatus>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.statuses.Add(FerryStatus.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, FerryStatusResponse instance, FerryStatusResponse previous)
	{
		if (instance.statuses == null)
		{
			return;
		}
		for (int i = 0; i < instance.statuses.Count; i++)
		{
			FerryStatus ferryStatus = instance.statuses[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			FerryStatus.SerializeDelta(stream, ferryStatus, ferryStatus);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, FerryStatusResponse instance)
	{
		if (instance.statuses == null)
		{
			return;
		}
		for (int i = 0; i < instance.statuses.Count; i++)
		{
			FerryStatus instance2 = instance.statuses[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			FerryStatus.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (statuses != null)
		{
			for (int i = 0; i < statuses.Count; i++)
			{
				statuses[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class FerryUpdateScheduleRequest : IDisposable, IPooled, IProto<FerryUpdateScheduleRequest>, IProto
{
	[NonSerialized]
	public NetworkableId entityId;

	[NonSerialized]
	public long timestamp;

	[NonSerialized]
	public List<string> schedule;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(FerryUpdateScheduleRequest instance)
	{
		if (instance.ShouldPool)
		{
			instance.entityId = default(NetworkableId);
			instance.timestamp = 0L;
			if (instance.schedule != null)
			{
				List<string> list = instance.schedule;
				Pool.FreeUnmanaged<string>(ref list);
				instance.schedule = list;
			}
			Pool.Free<FerryUpdateScheduleRequest>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose FerryUpdateScheduleRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(FerryUpdateScheduleRequest instance)
	{
		instance.entityId = entityId;
		instance.timestamp = timestamp;
		if (schedule != null)
		{
			instance.schedule = Pool.Get<List<string>>();
			for (int i = 0; i < schedule.Count; i++)
			{
				string item = schedule[i];
				instance.schedule.Add(item);
			}
		}
		else
		{
			instance.schedule = null;
		}
	}

	public FerryUpdateScheduleRequest Copy()
	{
		FerryUpdateScheduleRequest ferryUpdateScheduleRequest = Pool.Get<FerryUpdateScheduleRequest>();
		CopyTo(ferryUpdateScheduleRequest);
		return ferryUpdateScheduleRequest;
	}

	public static FerryUpdateScheduleRequest Deserialize(BufferStream stream)
	{
		FerryUpdateScheduleRequest ferryUpdateScheduleRequest = Pool.Get<FerryUpdateScheduleRequest>();
		Deserialize(stream, ferryUpdateScheduleRequest, isDelta: false);
		return ferryUpdateScheduleRequest;
	}

	public static FerryUpdateScheduleRequest DeserializeLengthDelimited(BufferStream stream)
	{
		FerryUpdateScheduleRequest ferryUpdateScheduleRequest = Pool.Get<FerryUpdateScheduleRequest>();
		DeserializeLengthDelimited(stream, ferryUpdateScheduleRequest, isDelta: false);
		return ferryUpdateScheduleRequest;
	}

	public static FerryUpdateScheduleRequest DeserializeLength(BufferStream stream, int length)
	{
		FerryUpdateScheduleRequest ferryUpdateScheduleRequest = Pool.Get<FerryUpdateScheduleRequest>();
		DeserializeLength(stream, length, ferryUpdateScheduleRequest, isDelta: false);
		return ferryUpdateScheduleRequest;
	}

	public static FerryUpdateScheduleRequest Deserialize(byte[] buffer)
	{
		FerryUpdateScheduleRequest ferryUpdateScheduleRequest = Pool.Get<FerryUpdateScheduleRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ferryUpdateScheduleRequest, isDelta: false);
		return ferryUpdateScheduleRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, FerryUpdateScheduleRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static FerryUpdateScheduleRequest Deserialize(BufferStream stream, FerryUpdateScheduleRequest instance, bool isDelta)
	{
		if (!isDelta && instance.schedule == null)
		{
			instance.schedule = Pool.Get<List<string>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static FerryUpdateScheduleRequest DeserializeLengthDelimited(BufferStream stream, FerryUpdateScheduleRequest instance, bool isDelta)
	{
		if (!isDelta && instance.schedule == null)
		{
			instance.schedule = Pool.Get<List<string>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static FerryUpdateScheduleRequest DeserializeLength(BufferStream stream, int length, FerryUpdateScheduleRequest instance, bool isDelta)
	{
		if (!isDelta && instance.schedule == null)
		{
			instance.schedule = Pool.Get<List<string>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, FerryUpdateScheduleRequest instance, FerryUpdateScheduleRequest previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		if (instance.schedule != null)
		{
			for (int i = 0; i < instance.schedule.Count; i++)
			{
				string val = instance.schedule[i];
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, val);
			}
		}
	}

	public static void Serialize(BufferStream stream, FerryUpdateScheduleRequest instance)
	{
		if (instance.entityId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		}
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
		if (instance.schedule != null)
		{
			for (int i = 0; i < instance.schedule.Count; i++)
			{
				string val = instance.schedule[i];
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, val);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entityId.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class Packet : IDisposable, IPooled, IProto<Packet>, IProto
{
	[NonSerialized]
	public uint protocol;

	[NonSerialized]
	public int sourceZone;

	[NonSerialized]
	public Request request;

	[NonSerialized]
	public Response response;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Packet instance)
	{
		if (instance.ShouldPool)
		{
			instance.protocol = 0u;
			instance.sourceZone = 0;
			if (instance.request != null)
			{
				instance.request.ResetToPool();
				instance.request = null;
			}
			if (instance.response != null)
			{
				instance.response.ResetToPool();
				instance.response = null;
			}
			Pool.Free<Packet>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Packet with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Packet instance)
	{
		instance.protocol = protocol;
		instance.sourceZone = sourceZone;
		if (request != null)
		{
			if (instance.request == null)
			{
				instance.request = request.Copy();
			}
			else
			{
				request.CopyTo(instance.request);
			}
		}
		else
		{
			instance.request = null;
		}
		if (response != null)
		{
			if (instance.response == null)
			{
				instance.response = response.Copy();
			}
			else
			{
				response.CopyTo(instance.response);
			}
		}
		else
		{
			instance.response = null;
		}
	}

	public Packet Copy()
	{
		Packet packet = Pool.Get<Packet>();
		CopyTo(packet);
		return packet;
	}

	public static Packet Deserialize(BufferStream stream)
	{
		Packet packet = Pool.Get<Packet>();
		Deserialize(stream, packet, isDelta: false);
		return packet;
	}

	public static Packet DeserializeLengthDelimited(BufferStream stream)
	{
		Packet packet = Pool.Get<Packet>();
		DeserializeLengthDelimited(stream, packet, isDelta: false);
		return packet;
	}

	public static Packet DeserializeLength(BufferStream stream, int length)
	{
		Packet packet = Pool.Get<Packet>();
		DeserializeLength(stream, length, packet, isDelta: false);
		return packet;
	}

	public static Packet Deserialize(byte[] buffer)
	{
		Packet packet = Pool.Get<Packet>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, packet, isDelta: false);
		return packet;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Packet previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Packet Deserialize(BufferStream stream, Packet instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.protocol = ProtocolParser.ReadUInt32(stream);
				break;
			case 16:
				instance.sourceZone = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 26:
				if (instance.request == null)
				{
					instance.request = Request.DeserializeLengthDelimited(stream);
				}
				else
				{
					Request.DeserializeLengthDelimited(stream, instance.request, isDelta);
				}
				break;
			case 34:
				if (instance.response == null)
				{
					instance.response = Response.DeserializeLengthDelimited(stream);
				}
				else
				{
					Response.DeserializeLengthDelimited(stream, instance.response, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static Packet DeserializeLengthDelimited(BufferStream stream, Packet instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.protocol = ProtocolParser.ReadUInt32(stream);
				break;
			case 16:
				instance.sourceZone = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 26:
				if (instance.request == null)
				{
					instance.request = Request.DeserializeLengthDelimited(stream);
				}
				else
				{
					Request.DeserializeLengthDelimited(stream, instance.request, isDelta);
				}
				break;
			case 34:
				if (instance.response == null)
				{
					instance.response = Response.DeserializeLengthDelimited(stream);
				}
				else
				{
					Response.DeserializeLengthDelimited(stream, instance.response, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Packet DeserializeLength(BufferStream stream, int length, Packet instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.protocol = ProtocolParser.ReadUInt32(stream);
				break;
			case 16:
				instance.sourceZone = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 26:
				if (instance.request == null)
				{
					instance.request = Request.DeserializeLengthDelimited(stream);
				}
				else
				{
					Request.DeserializeLengthDelimited(stream, instance.request, isDelta);
				}
				break;
			case 34:
				if (instance.response == null)
				{
					instance.response = Response.DeserializeLengthDelimited(stream);
				}
				else
				{
					Response.DeserializeLengthDelimited(stream, instance.response, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Packet instance, Packet previous)
	{
		if (instance.protocol != previous.protocol)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.protocol);
		}
		if (instance.sourceZone != previous.sourceZone)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.sourceZone);
		}
		if (instance.request != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Request.SerializeDelta(stream, instance.request, previous.request);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.response == null)
		{
			return;
		}
		stream.WriteByte(34);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		Response.SerializeDelta(stream, instance.response, previous.response);
		int val2 = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, Packet instance)
	{
		if (instance.protocol != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.protocol);
		}
		if (instance.sourceZone != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.sourceZone);
		}
		if (instance.request != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Request.Serialize(stream, instance.request);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.response == null)
		{
			return;
		}
		stream.WriteByte(34);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		Response.Serialize(stream, instance.response);
		int val2 = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		request?.InspectUids(action);
		response?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class PingRequest : IDisposable, IPooled, IProto<PingRequest>, IProto
{
	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PingRequest instance)
	{
		if (instance.ShouldPool)
		{
			Pool.Free<PingRequest>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PingRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PingRequest instance)
	{
	}

	public PingRequest Copy()
	{
		PingRequest pingRequest = Pool.Get<PingRequest>();
		CopyTo(pingRequest);
		return pingRequest;
	}

	public static PingRequest Deserialize(BufferStream stream)
	{
		PingRequest pingRequest = Pool.Get<PingRequest>();
		Deserialize(stream, pingRequest, isDelta: false);
		return pingRequest;
	}

	public static PingRequest DeserializeLengthDelimited(BufferStream stream)
	{
		PingRequest pingRequest = Pool.Get<PingRequest>();
		DeserializeLengthDelimited(stream, pingRequest, isDelta: false);
		return pingRequest;
	}

	public static PingRequest DeserializeLength(BufferStream stream, int length)
	{
		PingRequest pingRequest = Pool.Get<PingRequest>();
		DeserializeLength(stream, length, pingRequest, isDelta: false);
		return pingRequest;
	}

	public static PingRequest Deserialize(byte[] buffer)
	{
		PingRequest pingRequest = Pool.Get<PingRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, pingRequest, isDelta: false);
		return pingRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PingRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PingRequest Deserialize(BufferStream stream, PingRequest instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			if (num == -1 || num == 0)
			{
				break;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static PingRequest DeserializeLengthDelimited(BufferStream stream, PingRequest instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static PingRequest DeserializeLength(BufferStream stream, int length, PingRequest instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PingRequest instance, PingRequest previous)
	{
	}

	public static void Serialize(BufferStream stream, PingRequest instance)
	{
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class PingResponse : IDisposable, IPooled, IProto<PingResponse>, IProto
{
	[NonSerialized]
	public int players;

	[NonSerialized]
	public int maxPlayers;

	[NonSerialized]
	public int queuedPlayers;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PingResponse instance)
	{
		if (instance.ShouldPool)
		{
			instance.players = 0;
			instance.maxPlayers = 0;
			instance.queuedPlayers = 0;
			Pool.Free<PingResponse>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PingResponse with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PingResponse instance)
	{
		instance.players = players;
		instance.maxPlayers = maxPlayers;
		instance.queuedPlayers = queuedPlayers;
	}

	public PingResponse Copy()
	{
		PingResponse pingResponse = Pool.Get<PingResponse>();
		CopyTo(pingResponse);
		return pingResponse;
	}

	public static PingResponse Deserialize(BufferStream stream)
	{
		PingResponse pingResponse = Pool.Get<PingResponse>();
		Deserialize(stream, pingResponse, isDelta: false);
		return pingResponse;
	}

	public static PingResponse DeserializeLengthDelimited(BufferStream stream)
	{
		PingResponse pingResponse = Pool.Get<PingResponse>();
		DeserializeLengthDelimited(stream, pingResponse, isDelta: false);
		return pingResponse;
	}

	public static PingResponse DeserializeLength(BufferStream stream, int length)
	{
		PingResponse pingResponse = Pool.Get<PingResponse>();
		DeserializeLength(stream, length, pingResponse, isDelta: false);
		return pingResponse;
	}

	public static PingResponse Deserialize(byte[] buffer)
	{
		PingResponse pingResponse = Pool.Get<PingResponse>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, pingResponse, isDelta: false);
		return pingResponse;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PingResponse previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PingResponse Deserialize(BufferStream stream, PingResponse instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.players = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.maxPlayers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.queuedPlayers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PingResponse DeserializeLengthDelimited(BufferStream stream, PingResponse instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.players = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.maxPlayers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.queuedPlayers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PingResponse DeserializeLength(BufferStream stream, int length, PingResponse instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.players = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.maxPlayers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.queuedPlayers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PingResponse instance, PingResponse previous)
	{
		if (instance.players != previous.players)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.players);
		}
		if (instance.maxPlayers != previous.maxPlayers)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxPlayers);
		}
		if (instance.queuedPlayers != previous.queuedPlayers)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.queuedPlayers);
		}
	}

	public static void Serialize(BufferStream stream, PingResponse instance)
	{
		if (instance.players != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.players);
		}
		if (instance.maxPlayers != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxPlayers);
		}
		if (instance.queuedPlayers != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.queuedPlayers);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class PlayerManifestRequest : IDisposable, IPooled, IProto<PlayerManifestRequest>, IProto
{
	[NonSerialized]
	public List<ulong> userIds;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerManifestRequest instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.userIds != null)
			{
				List<ulong> list = instance.userIds;
				Pool.FreeUnmanaged<ulong>(ref list);
				instance.userIds = list;
			}
			Pool.Free<PlayerManifestRequest>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerManifestRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerManifestRequest instance)
	{
		if (userIds != null)
		{
			instance.userIds = Pool.Get<List<ulong>>();
			for (int i = 0; i < userIds.Count; i++)
			{
				ulong item = userIds[i];
				instance.userIds.Add(item);
			}
		}
		else
		{
			instance.userIds = null;
		}
	}

	public PlayerManifestRequest Copy()
	{
		PlayerManifestRequest playerManifestRequest = Pool.Get<PlayerManifestRequest>();
		CopyTo(playerManifestRequest);
		return playerManifestRequest;
	}

	public static PlayerManifestRequest Deserialize(BufferStream stream)
	{
		PlayerManifestRequest playerManifestRequest = Pool.Get<PlayerManifestRequest>();
		Deserialize(stream, playerManifestRequest, isDelta: false);
		return playerManifestRequest;
	}

	public static PlayerManifestRequest DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerManifestRequest playerManifestRequest = Pool.Get<PlayerManifestRequest>();
		DeserializeLengthDelimited(stream, playerManifestRequest, isDelta: false);
		return playerManifestRequest;
	}

	public static PlayerManifestRequest DeserializeLength(BufferStream stream, int length)
	{
		PlayerManifestRequest playerManifestRequest = Pool.Get<PlayerManifestRequest>();
		DeserializeLength(stream, length, playerManifestRequest, isDelta: false);
		return playerManifestRequest;
	}

	public static PlayerManifestRequest Deserialize(byte[] buffer)
	{
		PlayerManifestRequest playerManifestRequest = Pool.Get<PlayerManifestRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerManifestRequest, isDelta: false);
		return playerManifestRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerManifestRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerManifestRequest Deserialize(BufferStream stream, PlayerManifestRequest instance, bool isDelta)
	{
		if (!isDelta && instance.userIds == null)
		{
			instance.userIds = Pool.Get<List<ulong>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.userIds.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
			case 0:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerManifestRequest DeserializeLengthDelimited(BufferStream stream, PlayerManifestRequest instance, bool isDelta)
	{
		if (!isDelta && instance.userIds == null)
		{
			instance.userIds = Pool.Get<List<ulong>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userIds.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerManifestRequest DeserializeLength(BufferStream stream, int length, PlayerManifestRequest instance, bool isDelta)
	{
		if (!isDelta && instance.userIds == null)
		{
			instance.userIds = Pool.Get<List<ulong>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userIds.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerManifestRequest instance, PlayerManifestRequest previous)
	{
		if (instance.userIds != null)
		{
			for (int i = 0; i < instance.userIds.Count; i++)
			{
				ulong val = instance.userIds[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
	}

	public static void Serialize(BufferStream stream, PlayerManifestRequest instance)
	{
		if (instance.userIds != null)
		{
			for (int i = 0; i < instance.userIds.Count; i++)
			{
				ulong val = instance.userIds[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class PlayerSecondaryData : IDisposable, IPooled, IProto<PlayerSecondaryData>, IProto
{
	public class RelationshipData : IDisposable, IPooled, IProto<RelationshipData>, IProto
	{
		[NonSerialized]
		public RelationshipManager.PlayerRelationshipInfo info;

		[NonSerialized]
		public ArraySegment<byte> mugshotData;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(RelationshipData instance)
		{
			if (instance.ShouldPool)
			{
				if (instance.info != null)
				{
					instance.info.ResetToPool();
					instance.info = null;
				}
				if (instance.mugshotData.Array != null)
				{
					BufferStream.Shared.ArrayPool.Return(instance.mugshotData.Array);
				}
				instance.mugshotData = default(ArraySegment<byte>);
				Pool.Free<RelationshipData>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose RelationshipData with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(RelationshipData instance)
		{
			if (info != null)
			{
				if (instance.info == null)
				{
					instance.info = info.Copy();
				}
				else
				{
					info.CopyTo(instance.info);
				}
			}
			else
			{
				instance.info = null;
			}
			if (mugshotData.Array == null)
			{
				instance.mugshotData = default(ArraySegment<byte>);
				return;
			}
			byte[] array = BufferStream.Shared.ArrayPool.Rent(mugshotData.Count);
			Array.Copy(mugshotData.Array, 0, array, 0, mugshotData.Count);
			instance.mugshotData = new ArraySegment<byte>(array, 0, mugshotData.Count);
		}

		public RelationshipData Copy()
		{
			RelationshipData relationshipData = Pool.Get<RelationshipData>();
			CopyTo(relationshipData);
			return relationshipData;
		}

		public static RelationshipData Deserialize(BufferStream stream)
		{
			RelationshipData relationshipData = Pool.Get<RelationshipData>();
			Deserialize(stream, relationshipData, isDelta: false);
			return relationshipData;
		}

		public static RelationshipData DeserializeLengthDelimited(BufferStream stream)
		{
			RelationshipData relationshipData = Pool.Get<RelationshipData>();
			DeserializeLengthDelimited(stream, relationshipData, isDelta: false);
			return relationshipData;
		}

		public static RelationshipData DeserializeLength(BufferStream stream, int length)
		{
			RelationshipData relationshipData = Pool.Get<RelationshipData>();
			DeserializeLength(stream, length, relationshipData, isDelta: false);
			return relationshipData;
		}

		public static RelationshipData Deserialize(byte[] buffer)
		{
			RelationshipData relationshipData = Pool.Get<RelationshipData>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, relationshipData, isDelta: false);
			return relationshipData;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, RelationshipData previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static RelationshipData Deserialize(BufferStream stream, RelationshipData instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					if (instance.info == null)
					{
						instance.info = RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream);
					}
					else
					{
						RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
					}
					break;
				case 18:
					instance.mugshotData = ProtocolParser.ReadPooledBytes(stream);
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				case -1:
				case 0:
					return instance;
				}
			}
		}

		public static RelationshipData DeserializeLengthDelimited(BufferStream stream, RelationshipData instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					if (instance.info == null)
					{
						instance.info = RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream);
					}
					else
					{
						RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
					}
					break;
				case 18:
					instance.mugshotData = ProtocolParser.ReadPooledBytes(stream);
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static RelationshipData DeserializeLength(BufferStream stream, int length, RelationshipData instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					if (instance.info == null)
					{
						instance.info = RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream);
					}
					else
					{
						RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
					}
					break;
				case 18:
					instance.mugshotData = ProtocolParser.ReadPooledBytes(stream);
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, RelationshipData instance, RelationshipData previous)
		{
			if (instance.info == null)
			{
				throw new ArgumentNullException("info", "Required by proto specification.");
			}
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			RelationshipManager.PlayerRelationshipInfo.SerializeDelta(stream, instance.info, previous.info);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
			if (instance.mugshotData.Array != null)
			{
				stream.WriteByte(18);
				ProtocolParser.WritePooledBytes(stream, instance.mugshotData);
			}
		}

		public static void Serialize(BufferStream stream, RelationshipData instance)
		{
			if (instance.info == null)
			{
				throw new ArgumentNullException("info", "Required by proto specification.");
			}
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			RelationshipManager.PlayerRelationshipInfo.Serialize(stream, instance.info);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
			if (instance.mugshotData.Array != null)
			{
				stream.WriteByte(18);
				ProtocolParser.WritePooledBytes(stream, instance.mugshotData);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			info?.InspectUids(action);
		}
	}

	[NonSerialized]
	public ulong userId;

	[NonSerialized]
	public PlayerState playerState;

	[NonSerialized]
	public List<RelationshipData> relationships;

	[NonSerialized]
	public ulong teamId;

	[NonSerialized]
	public bool isTeamLeader;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerSecondaryData instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.userId = 0uL;
		if (instance.playerState != null)
		{
			instance.playerState.ResetToPool();
			instance.playerState = null;
		}
		if (instance.relationships != null)
		{
			for (int i = 0; i < instance.relationships.Count; i++)
			{
				if (instance.relationships[i] != null)
				{
					instance.relationships[i].ResetToPool();
					instance.relationships[i] = null;
				}
			}
			List<RelationshipData> list = instance.relationships;
			Pool.Free<RelationshipData>(ref list, false);
			instance.relationships = list;
		}
		instance.teamId = 0uL;
		instance.isTeamLeader = false;
		Pool.Free<PlayerSecondaryData>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerSecondaryData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerSecondaryData instance)
	{
		instance.userId = userId;
		if (playerState != null)
		{
			if (instance.playerState == null)
			{
				instance.playerState = playerState.Copy();
			}
			else
			{
				playerState.CopyTo(instance.playerState);
			}
		}
		else
		{
			instance.playerState = null;
		}
		if (relationships != null)
		{
			instance.relationships = Pool.Get<List<RelationshipData>>();
			for (int i = 0; i < relationships.Count; i++)
			{
				RelationshipData item = relationships[i].Copy();
				instance.relationships.Add(item);
			}
		}
		else
		{
			instance.relationships = null;
		}
		instance.teamId = teamId;
		instance.isTeamLeader = isTeamLeader;
	}

	public PlayerSecondaryData Copy()
	{
		PlayerSecondaryData playerSecondaryData = Pool.Get<PlayerSecondaryData>();
		CopyTo(playerSecondaryData);
		return playerSecondaryData;
	}

	public static PlayerSecondaryData Deserialize(BufferStream stream)
	{
		PlayerSecondaryData playerSecondaryData = Pool.Get<PlayerSecondaryData>();
		Deserialize(stream, playerSecondaryData, isDelta: false);
		return playerSecondaryData;
	}

	public static PlayerSecondaryData DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerSecondaryData playerSecondaryData = Pool.Get<PlayerSecondaryData>();
		DeserializeLengthDelimited(stream, playerSecondaryData, isDelta: false);
		return playerSecondaryData;
	}

	public static PlayerSecondaryData DeserializeLength(BufferStream stream, int length)
	{
		PlayerSecondaryData playerSecondaryData = Pool.Get<PlayerSecondaryData>();
		DeserializeLength(stream, length, playerSecondaryData, isDelta: false);
		return playerSecondaryData;
	}

	public static PlayerSecondaryData Deserialize(byte[] buffer)
	{
		PlayerSecondaryData playerSecondaryData = Pool.Get<PlayerSecondaryData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerSecondaryData, isDelta: false);
		return playerSecondaryData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerSecondaryData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerSecondaryData Deserialize(BufferStream stream, PlayerSecondaryData instance, bool isDelta)
	{
		if (!isDelta && instance.relationships == null)
		{
			instance.relationships = Pool.Get<List<RelationshipData>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.playerState == null)
				{
					instance.playerState = PlayerState.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerState.DeserializeLengthDelimited(stream, instance.playerState, isDelta);
				}
				break;
			case 26:
				instance.relationships.Add(RelationshipData.DeserializeLengthDelimited(stream));
				break;
			case 32:
				instance.teamId = ProtocolParser.ReadUInt64(stream);
				break;
			case 40:
				instance.isTeamLeader = ProtocolParser.ReadBool(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static PlayerSecondaryData DeserializeLengthDelimited(BufferStream stream, PlayerSecondaryData instance, bool isDelta)
	{
		if (!isDelta && instance.relationships == null)
		{
			instance.relationships = Pool.Get<List<RelationshipData>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.playerState == null)
				{
					instance.playerState = PlayerState.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerState.DeserializeLengthDelimited(stream, instance.playerState, isDelta);
				}
				break;
			case 26:
				instance.relationships.Add(RelationshipData.DeserializeLengthDelimited(stream));
				break;
			case 32:
				instance.teamId = ProtocolParser.ReadUInt64(stream);
				break;
			case 40:
				instance.isTeamLeader = ProtocolParser.ReadBool(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerSecondaryData DeserializeLength(BufferStream stream, int length, PlayerSecondaryData instance, bool isDelta)
	{
		if (!isDelta && instance.relationships == null)
		{
			instance.relationships = Pool.Get<List<RelationshipData>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.playerState == null)
				{
					instance.playerState = PlayerState.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerState.DeserializeLengthDelimited(stream, instance.playerState, isDelta);
				}
				break;
			case 26:
				instance.relationships.Add(RelationshipData.DeserializeLengthDelimited(stream));
				break;
			case 32:
				instance.teamId = ProtocolParser.ReadUInt64(stream);
				break;
			case 40:
				instance.isTeamLeader = ProtocolParser.ReadBool(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerSecondaryData instance, PlayerSecondaryData previous)
	{
		if (instance.userId != previous.userId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.userId);
		}
		if (instance.playerState != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PlayerState.SerializeDelta(stream, instance.playerState, previous.playerState);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.relationships != null)
		{
			for (int i = 0; i < instance.relationships.Count; i++)
			{
				RelationshipData relationshipData = instance.relationships[i];
				stream.WriteByte(26);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				RelationshipData.SerializeDelta(stream, relationshipData, relationshipData);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.teamId != previous.teamId)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.teamId);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.isTeamLeader);
	}

	public static void Serialize(BufferStream stream, PlayerSecondaryData instance)
	{
		if (instance.userId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.userId);
		}
		if (instance.playerState != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PlayerState.Serialize(stream, instance.playerState);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.relationships != null)
		{
			for (int i = 0; i < instance.relationships.Count; i++)
			{
				RelationshipData instance2 = instance.relationships[i];
				stream.WriteByte(26);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				RelationshipData.Serialize(stream, instance2);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.teamId != 0L)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.teamId);
		}
		if (instance.isTeamLeader)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.isTeamLeader);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		playerState?.InspectUids(action);
		if (relationships != null)
		{
			for (int i = 0; i < relationships.Count; i++)
			{
				relationships[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class Request : IDisposable, IPooled, IProto<Request>, IProto
{
	[NonSerialized]
	public bool isFireAndForget;

	[NonSerialized]
	public TransferRequest transfer;

	[NonSerialized]
	public PingRequest ping;

	[NonSerialized]
	public SpawnOptionsRequest spawnOptions;

	[NonSerialized]
	public SleepingBagRespawnRequest respawnAtBag;

	[NonSerialized]
	public SleepingBagDestroyRequest destroyBag;

	[NonSerialized]
	public FerryStatusRequest ferryStatus;

	[NonSerialized]
	public FerryRetireRequest ferryRetire;

	[NonSerialized]
	public FerryUpdateScheduleRequest ferryUpdateSchedule;

	[NonSerialized]
	public ClanChatBatchRequest clanChatBatch;

	[NonSerialized]
	public PlayerManifestRequest playerManifest;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Request instance)
	{
		if (instance.ShouldPool)
		{
			instance.isFireAndForget = false;
			if (instance.transfer != null)
			{
				instance.transfer.ResetToPool();
				instance.transfer = null;
			}
			if (instance.ping != null)
			{
				instance.ping.ResetToPool();
				instance.ping = null;
			}
			if (instance.spawnOptions != null)
			{
				instance.spawnOptions.ResetToPool();
				instance.spawnOptions = null;
			}
			if (instance.respawnAtBag != null)
			{
				instance.respawnAtBag.ResetToPool();
				instance.respawnAtBag = null;
			}
			if (instance.destroyBag != null)
			{
				instance.destroyBag.ResetToPool();
				instance.destroyBag = null;
			}
			if (instance.ferryStatus != null)
			{
				instance.ferryStatus.ResetToPool();
				instance.ferryStatus = null;
			}
			if (instance.ferryRetire != null)
			{
				instance.ferryRetire.ResetToPool();
				instance.ferryRetire = null;
			}
			if (instance.ferryUpdateSchedule != null)
			{
				instance.ferryUpdateSchedule.ResetToPool();
				instance.ferryUpdateSchedule = null;
			}
			if (instance.clanChatBatch != null)
			{
				instance.clanChatBatch.ResetToPool();
				instance.clanChatBatch = null;
			}
			if (instance.playerManifest != null)
			{
				instance.playerManifest.ResetToPool();
				instance.playerManifest = null;
			}
			Pool.Free<Request>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Request with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Request instance)
	{
		instance.isFireAndForget = isFireAndForget;
		if (transfer != null)
		{
			if (instance.transfer == null)
			{
				instance.transfer = transfer.Copy();
			}
			else
			{
				transfer.CopyTo(instance.transfer);
			}
		}
		else
		{
			instance.transfer = null;
		}
		if (ping != null)
		{
			if (instance.ping == null)
			{
				instance.ping = ping.Copy();
			}
			else
			{
				ping.CopyTo(instance.ping);
			}
		}
		else
		{
			instance.ping = null;
		}
		if (spawnOptions != null)
		{
			if (instance.spawnOptions == null)
			{
				instance.spawnOptions = spawnOptions.Copy();
			}
			else
			{
				spawnOptions.CopyTo(instance.spawnOptions);
			}
		}
		else
		{
			instance.spawnOptions = null;
		}
		if (respawnAtBag != null)
		{
			if (instance.respawnAtBag == null)
			{
				instance.respawnAtBag = respawnAtBag.Copy();
			}
			else
			{
				respawnAtBag.CopyTo(instance.respawnAtBag);
			}
		}
		else
		{
			instance.respawnAtBag = null;
		}
		if (destroyBag != null)
		{
			if (instance.destroyBag == null)
			{
				instance.destroyBag = destroyBag.Copy();
			}
			else
			{
				destroyBag.CopyTo(instance.destroyBag);
			}
		}
		else
		{
			instance.destroyBag = null;
		}
		if (ferryStatus != null)
		{
			if (instance.ferryStatus == null)
			{
				instance.ferryStatus = ferryStatus.Copy();
			}
			else
			{
				ferryStatus.CopyTo(instance.ferryStatus);
			}
		}
		else
		{
			instance.ferryStatus = null;
		}
		if (ferryRetire != null)
		{
			if (instance.ferryRetire == null)
			{
				instance.ferryRetire = ferryRetire.Copy();
			}
			else
			{
				ferryRetire.CopyTo(instance.ferryRetire);
			}
		}
		else
		{
			instance.ferryRetire = null;
		}
		if (ferryUpdateSchedule != null)
		{
			if (instance.ferryUpdateSchedule == null)
			{
				instance.ferryUpdateSchedule = ferryUpdateSchedule.Copy();
			}
			else
			{
				ferryUpdateSchedule.CopyTo(instance.ferryUpdateSchedule);
			}
		}
		else
		{
			instance.ferryUpdateSchedule = null;
		}
		if (clanChatBatch != null)
		{
			if (instance.clanChatBatch == null)
			{
				instance.clanChatBatch = clanChatBatch.Copy();
			}
			else
			{
				clanChatBatch.CopyTo(instance.clanChatBatch);
			}
		}
		else
		{
			instance.clanChatBatch = null;
		}
		if (playerManifest != null)
		{
			if (instance.playerManifest == null)
			{
				instance.playerManifest = playerManifest.Copy();
			}
			else
			{
				playerManifest.CopyTo(instance.playerManifest);
			}
		}
		else
		{
			instance.playerManifest = null;
		}
	}

	public Request Copy()
	{
		Request request = Pool.Get<Request>();
		CopyTo(request);
		return request;
	}

	public static Request Deserialize(BufferStream stream)
	{
		Request request = Pool.Get<Request>();
		Deserialize(stream, request, isDelta: false);
		return request;
	}

	public static Request DeserializeLengthDelimited(BufferStream stream)
	{
		Request request = Pool.Get<Request>();
		DeserializeLengthDelimited(stream, request, isDelta: false);
		return request;
	}

	public static Request DeserializeLength(BufferStream stream, int length)
	{
		Request request = Pool.Get<Request>();
		DeserializeLength(stream, length, request, isDelta: false);
		return request;
	}

	public static Request Deserialize(byte[] buffer)
	{
		Request request = Pool.Get<Request>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, request, isDelta: false);
		return request;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Request previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Request Deserialize(BufferStream stream, Request instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.isFireAndForget = ProtocolParser.ReadBool(stream);
				break;
			case 18:
				if (instance.transfer == null)
				{
					instance.transfer = TransferRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					TransferRequest.DeserializeLengthDelimited(stream, instance.transfer, isDelta);
				}
				break;
			case 26:
				if (instance.ping == null)
				{
					instance.ping = PingRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					PingRequest.DeserializeLengthDelimited(stream, instance.ping, isDelta);
				}
				break;
			case 34:
				if (instance.spawnOptions == null)
				{
					instance.spawnOptions = SpawnOptionsRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					SpawnOptionsRequest.DeserializeLengthDelimited(stream, instance.spawnOptions, isDelta);
				}
				break;
			case 42:
				if (instance.respawnAtBag == null)
				{
					instance.respawnAtBag = SleepingBagRespawnRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					SleepingBagRespawnRequest.DeserializeLengthDelimited(stream, instance.respawnAtBag, isDelta);
				}
				break;
			case 50:
				if (instance.destroyBag == null)
				{
					instance.destroyBag = SleepingBagDestroyRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					SleepingBagDestroyRequest.DeserializeLengthDelimited(stream, instance.destroyBag, isDelta);
				}
				break;
			case 58:
				if (instance.ferryStatus == null)
				{
					instance.ferryStatus = FerryStatusRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryStatusRequest.DeserializeLengthDelimited(stream, instance.ferryStatus, isDelta);
				}
				break;
			case 66:
				if (instance.ferryRetire == null)
				{
					instance.ferryRetire = FerryRetireRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryRetireRequest.DeserializeLengthDelimited(stream, instance.ferryRetire, isDelta);
				}
				break;
			case 74:
				if (instance.ferryUpdateSchedule == null)
				{
					instance.ferryUpdateSchedule = FerryUpdateScheduleRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryUpdateScheduleRequest.DeserializeLengthDelimited(stream, instance.ferryUpdateSchedule, isDelta);
				}
				break;
			case 82:
				if (instance.clanChatBatch == null)
				{
					instance.clanChatBatch = ClanChatBatchRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanChatBatchRequest.DeserializeLengthDelimited(stream, instance.clanChatBatch, isDelta);
				}
				break;
			case 90:
				if (instance.playerManifest == null)
				{
					instance.playerManifest = PlayerManifestRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerManifestRequest.DeserializeLengthDelimited(stream, instance.playerManifest, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static Request DeserializeLengthDelimited(BufferStream stream, Request instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.isFireAndForget = ProtocolParser.ReadBool(stream);
				break;
			case 18:
				if (instance.transfer == null)
				{
					instance.transfer = TransferRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					TransferRequest.DeserializeLengthDelimited(stream, instance.transfer, isDelta);
				}
				break;
			case 26:
				if (instance.ping == null)
				{
					instance.ping = PingRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					PingRequest.DeserializeLengthDelimited(stream, instance.ping, isDelta);
				}
				break;
			case 34:
				if (instance.spawnOptions == null)
				{
					instance.spawnOptions = SpawnOptionsRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					SpawnOptionsRequest.DeserializeLengthDelimited(stream, instance.spawnOptions, isDelta);
				}
				break;
			case 42:
				if (instance.respawnAtBag == null)
				{
					instance.respawnAtBag = SleepingBagRespawnRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					SleepingBagRespawnRequest.DeserializeLengthDelimited(stream, instance.respawnAtBag, isDelta);
				}
				break;
			case 50:
				if (instance.destroyBag == null)
				{
					instance.destroyBag = SleepingBagDestroyRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					SleepingBagDestroyRequest.DeserializeLengthDelimited(stream, instance.destroyBag, isDelta);
				}
				break;
			case 58:
				if (instance.ferryStatus == null)
				{
					instance.ferryStatus = FerryStatusRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryStatusRequest.DeserializeLengthDelimited(stream, instance.ferryStatus, isDelta);
				}
				break;
			case 66:
				if (instance.ferryRetire == null)
				{
					instance.ferryRetire = FerryRetireRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryRetireRequest.DeserializeLengthDelimited(stream, instance.ferryRetire, isDelta);
				}
				break;
			case 74:
				if (instance.ferryUpdateSchedule == null)
				{
					instance.ferryUpdateSchedule = FerryUpdateScheduleRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryUpdateScheduleRequest.DeserializeLengthDelimited(stream, instance.ferryUpdateSchedule, isDelta);
				}
				break;
			case 82:
				if (instance.clanChatBatch == null)
				{
					instance.clanChatBatch = ClanChatBatchRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanChatBatchRequest.DeserializeLengthDelimited(stream, instance.clanChatBatch, isDelta);
				}
				break;
			case 90:
				if (instance.playerManifest == null)
				{
					instance.playerManifest = PlayerManifestRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerManifestRequest.DeserializeLengthDelimited(stream, instance.playerManifest, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Request DeserializeLength(BufferStream stream, int length, Request instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.isFireAndForget = ProtocolParser.ReadBool(stream);
				break;
			case 18:
				if (instance.transfer == null)
				{
					instance.transfer = TransferRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					TransferRequest.DeserializeLengthDelimited(stream, instance.transfer, isDelta);
				}
				break;
			case 26:
				if (instance.ping == null)
				{
					instance.ping = PingRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					PingRequest.DeserializeLengthDelimited(stream, instance.ping, isDelta);
				}
				break;
			case 34:
				if (instance.spawnOptions == null)
				{
					instance.spawnOptions = SpawnOptionsRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					SpawnOptionsRequest.DeserializeLengthDelimited(stream, instance.spawnOptions, isDelta);
				}
				break;
			case 42:
				if (instance.respawnAtBag == null)
				{
					instance.respawnAtBag = SleepingBagRespawnRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					SleepingBagRespawnRequest.DeserializeLengthDelimited(stream, instance.respawnAtBag, isDelta);
				}
				break;
			case 50:
				if (instance.destroyBag == null)
				{
					instance.destroyBag = SleepingBagDestroyRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					SleepingBagDestroyRequest.DeserializeLengthDelimited(stream, instance.destroyBag, isDelta);
				}
				break;
			case 58:
				if (instance.ferryStatus == null)
				{
					instance.ferryStatus = FerryStatusRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryStatusRequest.DeserializeLengthDelimited(stream, instance.ferryStatus, isDelta);
				}
				break;
			case 66:
				if (instance.ferryRetire == null)
				{
					instance.ferryRetire = FerryRetireRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryRetireRequest.DeserializeLengthDelimited(stream, instance.ferryRetire, isDelta);
				}
				break;
			case 74:
				if (instance.ferryUpdateSchedule == null)
				{
					instance.ferryUpdateSchedule = FerryUpdateScheduleRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryUpdateScheduleRequest.DeserializeLengthDelimited(stream, instance.ferryUpdateSchedule, isDelta);
				}
				break;
			case 82:
				if (instance.clanChatBatch == null)
				{
					instance.clanChatBatch = ClanChatBatchRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanChatBatchRequest.DeserializeLengthDelimited(stream, instance.clanChatBatch, isDelta);
				}
				break;
			case 90:
				if (instance.playerManifest == null)
				{
					instance.playerManifest = PlayerManifestRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerManifestRequest.DeserializeLengthDelimited(stream, instance.playerManifest, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Request instance, Request previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.isFireAndForget);
		if (instance.transfer != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			TransferRequest.SerializeDelta(stream, instance.transfer, previous.transfer);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.ping != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			PingRequest.SerializeDelta(stream, instance.ping, previous.ping);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ping (ProtoBuf.Nexus.PingRequest)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.spawnOptions != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			SpawnOptionsRequest.SerializeDelta(stream, instance.spawnOptions, previous.spawnOptions);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field spawnOptions (ProtoBuf.Nexus.SpawnOptionsRequest)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.respawnAtBag != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range4 = stream.GetRange(5);
			int position4 = stream.Position;
			SleepingBagRespawnRequest.SerializeDelta(stream, instance.respawnAtBag, previous.respawnAtBag);
			int val2 = stream.Position - position4;
			Span<byte> span4 = range4.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)val2, span4, 0);
			if (num4 < 5)
			{
				span4[num4 - 1] |= 128;
				while (num4 < 4)
				{
					span4[num4++] = 128;
				}
				span4[4] = 0;
			}
		}
		if (instance.destroyBag != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			SleepingBagDestroyRequest.SerializeDelta(stream, instance.destroyBag, previous.destroyBag);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field destroyBag (ProtoBuf.Nexus.SleepingBagDestroyRequest)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.ferryStatus != null)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			FerryStatusRequest.SerializeDelta(stream, instance.ferryStatus, previous.ferryStatus);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ferryStatus (ProtoBuf.Nexus.FerryStatusRequest)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
		if (instance.ferryRetire != null)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range7 = stream.GetRange(1);
			int position7 = stream.Position;
			FerryRetireRequest.SerializeDelta(stream, instance.ferryRetire, previous.ferryRetire);
			int num7 = stream.Position - position7;
			if (num7 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ferryRetire (ProtoBuf.Nexus.FerryRetireRequest)");
			}
			Span<byte> span7 = range7.GetSpan();
			ProtocolParser.WriteUInt32((uint)num7, span7, 0);
		}
		if (instance.ferryUpdateSchedule != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range8 = stream.GetRange(5);
			int position8 = stream.Position;
			FerryUpdateScheduleRequest.SerializeDelta(stream, instance.ferryUpdateSchedule, previous.ferryUpdateSchedule);
			int val3 = stream.Position - position8;
			Span<byte> span8 = range8.GetSpan();
			int num8 = ProtocolParser.WriteUInt32((uint)val3, span8, 0);
			if (num8 < 5)
			{
				span8[num8 - 1] |= 128;
				while (num8 < 4)
				{
					span8[num8++] = 128;
				}
				span8[4] = 0;
			}
		}
		if (instance.clanChatBatch != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range9 = stream.GetRange(5);
			int position9 = stream.Position;
			ClanChatBatchRequest.SerializeDelta(stream, instance.clanChatBatch, previous.clanChatBatch);
			int val4 = stream.Position - position9;
			Span<byte> span9 = range9.GetSpan();
			int num9 = ProtocolParser.WriteUInt32((uint)val4, span9, 0);
			if (num9 < 5)
			{
				span9[num9 - 1] |= 128;
				while (num9 < 4)
				{
					span9[num9++] = 128;
				}
				span9[4] = 0;
			}
		}
		if (instance.playerManifest == null)
		{
			return;
		}
		stream.WriteByte(90);
		BufferStream.RangeHandle range10 = stream.GetRange(3);
		int position10 = stream.Position;
		PlayerManifestRequest.SerializeDelta(stream, instance.playerManifest, previous.playerManifest);
		int num10 = stream.Position - position10;
		if (num10 > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerManifest (ProtoBuf.Nexus.PlayerManifestRequest)");
		}
		Span<byte> span10 = range10.GetSpan();
		int num11 = ProtocolParser.WriteUInt32((uint)num10, span10, 0);
		if (num11 < 3)
		{
			span10[num11 - 1] |= 128;
			while (num11 < 2)
			{
				span10[num11++] = 128;
			}
			span10[2] = 0;
		}
	}

	public static void Serialize(BufferStream stream, Request instance)
	{
		if (instance.isFireAndForget)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.isFireAndForget);
		}
		if (instance.transfer != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			TransferRequest.Serialize(stream, instance.transfer);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.ping != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			PingRequest.Serialize(stream, instance.ping);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ping (ProtoBuf.Nexus.PingRequest)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.spawnOptions != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			SpawnOptionsRequest.Serialize(stream, instance.spawnOptions);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field spawnOptions (ProtoBuf.Nexus.SpawnOptionsRequest)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.respawnAtBag != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range4 = stream.GetRange(5);
			int position4 = stream.Position;
			SleepingBagRespawnRequest.Serialize(stream, instance.respawnAtBag);
			int val2 = stream.Position - position4;
			Span<byte> span4 = range4.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)val2, span4, 0);
			if (num4 < 5)
			{
				span4[num4 - 1] |= 128;
				while (num4 < 4)
				{
					span4[num4++] = 128;
				}
				span4[4] = 0;
			}
		}
		if (instance.destroyBag != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			SleepingBagDestroyRequest.Serialize(stream, instance.destroyBag);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field destroyBag (ProtoBuf.Nexus.SleepingBagDestroyRequest)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.ferryStatus != null)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			FerryStatusRequest.Serialize(stream, instance.ferryStatus);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ferryStatus (ProtoBuf.Nexus.FerryStatusRequest)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
		if (instance.ferryRetire != null)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range7 = stream.GetRange(1);
			int position7 = stream.Position;
			FerryRetireRequest.Serialize(stream, instance.ferryRetire);
			int num7 = stream.Position - position7;
			if (num7 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ferryRetire (ProtoBuf.Nexus.FerryRetireRequest)");
			}
			Span<byte> span7 = range7.GetSpan();
			ProtocolParser.WriteUInt32((uint)num7, span7, 0);
		}
		if (instance.ferryUpdateSchedule != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range8 = stream.GetRange(5);
			int position8 = stream.Position;
			FerryUpdateScheduleRequest.Serialize(stream, instance.ferryUpdateSchedule);
			int val3 = stream.Position - position8;
			Span<byte> span8 = range8.GetSpan();
			int num8 = ProtocolParser.WriteUInt32((uint)val3, span8, 0);
			if (num8 < 5)
			{
				span8[num8 - 1] |= 128;
				while (num8 < 4)
				{
					span8[num8++] = 128;
				}
				span8[4] = 0;
			}
		}
		if (instance.clanChatBatch != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range9 = stream.GetRange(5);
			int position9 = stream.Position;
			ClanChatBatchRequest.Serialize(stream, instance.clanChatBatch);
			int val4 = stream.Position - position9;
			Span<byte> span9 = range9.GetSpan();
			int num9 = ProtocolParser.WriteUInt32((uint)val4, span9, 0);
			if (num9 < 5)
			{
				span9[num9 - 1] |= 128;
				while (num9 < 4)
				{
					span9[num9++] = 128;
				}
				span9[4] = 0;
			}
		}
		if (instance.playerManifest == null)
		{
			return;
		}
		stream.WriteByte(90);
		BufferStream.RangeHandle range10 = stream.GetRange(3);
		int position10 = stream.Position;
		PlayerManifestRequest.Serialize(stream, instance.playerManifest);
		int num10 = stream.Position - position10;
		if (num10 > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerManifest (ProtoBuf.Nexus.PlayerManifestRequest)");
		}
		Span<byte> span10 = range10.GetSpan();
		int num11 = ProtocolParser.WriteUInt32((uint)num10, span10, 0);
		if (num11 < 3)
		{
			span10[num11 - 1] |= 128;
			while (num11 < 2)
			{
				span10[num11++] = 128;
			}
			span10[2] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		transfer?.InspectUids(action);
		ping?.InspectUids(action);
		spawnOptions?.InspectUids(action);
		respawnAtBag?.InspectUids(action);
		destroyBag?.InspectUids(action);
		ferryStatus?.InspectUids(action);
		ferryRetire?.InspectUids(action);
		ferryUpdateSchedule?.InspectUids(action);
		clanChatBatch?.InspectUids(action);
		playerManifest?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using Facepunch.Nexus;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class Response : IDisposable, IPooled, IProto<Response>, IProto
{
	[NonSerialized]
	public Uuid id;

	[NonSerialized]
	public Status status;

	[NonSerialized]
	public PingResponse ping;

	[NonSerialized]
	public SpawnOptionsResponse spawnOptions;

	[NonSerialized]
	public FerryStatusResponse ferryStatus;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Response instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.id = default(Uuid);
			if (instance.status != null)
			{
				instance.status.ResetToPool();
				instance.status = null;
			}
			if (instance.ping != null)
			{
				instance.ping.ResetToPool();
				instance.ping = null;
			}
			if (instance.spawnOptions != null)
			{
				instance.spawnOptions.ResetToPool();
				instance.spawnOptions = null;
			}
			if (instance.ferryStatus != null)
			{
				instance.ferryStatus.ResetToPool();
				instance.ferryStatus = null;
			}
			Pool.Free<Response>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Response with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Response instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		instance.id = id;
		if (status != null)
		{
			if (instance.status == null)
			{
				instance.status = status.Copy();
			}
			else
			{
				status.CopyTo(instance.status);
			}
		}
		else
		{
			instance.status = null;
		}
		if (ping != null)
		{
			if (instance.ping == null)
			{
				instance.ping = ping.Copy();
			}
			else
			{
				ping.CopyTo(instance.ping);
			}
		}
		else
		{
			instance.ping = null;
		}
		if (spawnOptions != null)
		{
			if (instance.spawnOptions == null)
			{
				instance.spawnOptions = spawnOptions.Copy();
			}
			else
			{
				spawnOptions.CopyTo(instance.spawnOptions);
			}
		}
		else
		{
			instance.spawnOptions = null;
		}
		if (ferryStatus != null)
		{
			if (instance.ferryStatus == null)
			{
				instance.ferryStatus = ferryStatus.Copy();
			}
			else
			{
				ferryStatus.CopyTo(instance.ferryStatus);
			}
		}
		else
		{
			instance.ferryStatus = null;
		}
	}

	public Response Copy()
	{
		Response response = Pool.Get<Response>();
		CopyTo(response);
		return response;
	}

	public static Response Deserialize(BufferStream stream)
	{
		Response response = Pool.Get<Response>();
		Deserialize(stream, response, isDelta: false);
		return response;
	}

	public static Response DeserializeLengthDelimited(BufferStream stream)
	{
		Response response = Pool.Get<Response>();
		DeserializeLengthDelimited(stream, response, isDelta: false);
		return response;
	}

	public static Response DeserializeLength(BufferStream stream, int length)
	{
		Response response = Pool.Get<Response>();
		DeserializeLength(stream, length, response, isDelta: false);
		return response;
	}

	public static Response Deserialize(byte[] buffer)
	{
		Response response = Pool.Get<Response>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, response, isDelta: false);
		return response;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Response previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Response Deserialize(BufferStream stream, Response instance, bool isDelta)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				UuidSerialized.DeserializeLengthDelimited(stream, ref instance.id, isDelta);
				break;
			case 18:
				if (instance.status == null)
				{
					instance.status = Status.DeserializeLengthDelimited(stream);
				}
				else
				{
					Status.DeserializeLengthDelimited(stream, instance.status, isDelta);
				}
				break;
			case 26:
				if (instance.ping == null)
				{
					instance.ping = PingResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					PingResponse.DeserializeLengthDelimited(stream, instance.ping, isDelta);
				}
				break;
			case 34:
				if (instance.spawnOptions == null)
				{
					instance.spawnOptions = SpawnOptionsResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					SpawnOptionsResponse.DeserializeLengthDelimited(stream, instance.spawnOptions, isDelta);
				}
				break;
			case 42:
				if (instance.ferryStatus == null)
				{
					instance.ferryStatus = FerryStatusResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryStatusResponse.DeserializeLengthDelimited(stream, instance.ferryStatus, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
			case 0:
				return instance;
			}
		}
	}

	public static Response DeserializeLengthDelimited(BufferStream stream, Response instance, bool isDelta)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				UuidSerialized.DeserializeLengthDelimited(stream, ref instance.id, isDelta);
				break;
			case 18:
				if (instance.status == null)
				{
					instance.status = Status.DeserializeLengthDelimited(stream);
				}
				else
				{
					Status.DeserializeLengthDelimited(stream, instance.status, isDelta);
				}
				break;
			case 26:
				if (instance.ping == null)
				{
					instance.ping = PingResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					PingResponse.DeserializeLengthDelimited(stream, instance.ping, isDelta);
				}
				break;
			case 34:
				if (instance.spawnOptions == null)
				{
					instance.spawnOptions = SpawnOptionsResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					SpawnOptionsResponse.DeserializeLengthDelimited(stream, instance.spawnOptions, isDelta);
				}
				break;
			case 42:
				if (instance.ferryStatus == null)
				{
					instance.ferryStatus = FerryStatusResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryStatusResponse.DeserializeLengthDelimited(stream, instance.ferryStatus, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Response DeserializeLength(BufferStream stream, int length, Response instance, bool isDelta)
	{
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				UuidSerialized.DeserializeLengthDelimited(stream, ref instance.id, isDelta);
				break;
			case 18:
				if (instance.status == null)
				{
					instance.status = Status.DeserializeLengthDelimited(stream);
				}
				else
				{
					Status.DeserializeLengthDelimited(stream, instance.status, isDelta);
				}
				break;
			case 26:
				if (instance.ping == null)
				{
					instance.ping = PingResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					PingResponse.DeserializeLengthDelimited(stream, instance.ping, isDelta);
				}
				break;
			case 34:
				if (instance.spawnOptions == null)
				{
					instance.spawnOptions = SpawnOptionsResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					SpawnOptionsResponse.DeserializeLengthDelimited(stream, instance.spawnOptions, isDelta);
				}
				break;
			case 42:
				if (instance.ferryStatus == null)
				{
					instance.ferryStatus = FerryStatusResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryStatusResponse.DeserializeLengthDelimited(stream, instance.ferryStatus, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Response instance, Response previous)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(1);
		int position = stream.Position;
		UuidSerialized.SerializeDelta(stream, instance.id, previous.id);
		int num = stream.Position - position;
		if (num > 127)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field id (Facepunch.Nexus.Uuid)");
		}
		Span<byte> span = range.GetSpan();
		ProtocolParser.WriteUInt32((uint)num, span, 0);
		if (instance.status == null)
		{
			throw new ArgumentNullException("status", "Required by proto specification.");
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		Status.SerializeDelta(stream, instance.status, previous.status);
		int val = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
		if (instance.ping != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			PingResponse.SerializeDelta(stream, instance.ping, previous.ping);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ping (ProtoBuf.Nexus.PingResponse)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.spawnOptions != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(5);
			int position4 = stream.Position;
			SpawnOptionsResponse.SerializeDelta(stream, instance.spawnOptions, previous.spawnOptions);
			int val2 = stream.Position - position4;
			Span<byte> span4 = range4.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)val2, span4, 0);
			if (num4 < 5)
			{
				span4[num4 - 1] |= 128;
				while (num4 < 4)
				{
					span4[num4++] = 128;
				}
				span4[4] = 0;
			}
		}
		if (instance.ferryStatus == null)
		{
			return;
		}
		stream.WriteByte(42);
		BufferStream.RangeHandle range5 = stream.GetRange(5);
		int position5 = stream.Position;
		FerryStatusResponse.SerializeDelta(stream, instance.ferryStatus, previous.ferryStatus);
		int val3 = stream.Position - position5;
		Span<byte> span5 = range5.GetSpan();
		int num5 = ProtocolParser.WriteUInt32((uint)val3, span5, 0);
		if (num5 < 5)
		{
			span5[num5 - 1] |= 128;
			while (num5 < 4)
			{
				span5[num5++] = 128;
			}
			span5[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, Response instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.id != default(Uuid))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			UuidSerialized.Serialize(stream, instance.id);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field id (Facepunch.Nexus.Uuid)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.status == null)
		{
			throw new ArgumentNullException("status", "Required by proto specification.");
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		Status.Serialize(stream, instance.status);
		int val = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
		if (instance.ping != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			PingResponse.Serialize(stream, instance.ping);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ping (ProtoBuf.Nexus.PingResponse)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.spawnOptions != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(5);
			int position4 = stream.Position;
			SpawnOptionsResponse.Serialize(stream, instance.spawnOptions);
			int val2 = stream.Position - position4;
			Span<byte> span4 = range4.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)val2, span4, 0);
			if (num4 < 5)
			{
				span4[num4 - 1] |= 128;
				while (num4 < 4)
				{
					span4[num4++] = 128;
				}
				span4[4] = 0;
			}
		}
		if (instance.ferryStatus == null)
		{
			return;
		}
		stream.WriteByte(42);
		BufferStream.RangeHandle range5 = stream.GetRange(5);
		int position5 = stream.Position;
		FerryStatusResponse.Serialize(stream, instance.ferryStatus);
		int val3 = stream.Position - position5;
		Span<byte> span5 = range5.GetSpan();
		int num5 = ProtocolParser.WriteUInt32((uint)val3, span5, 0);
		if (num5 < 5)
		{
			span5[num5 - 1] |= 128;
			while (num5 < 4)
			{
				span5[num5++] = 128;
			}
			span5[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		status?.InspectUids(action);
		ping?.InspectUids(action);
		spawnOptions?.InspectUids(action);
		ferryStatus?.InspectUids(action);
	}
}


