// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ChatGuard.cs ---
// --- Original Local Path: ChatGuard.cs ---

using System.Collections.Generic;
using System.Linq;
using System;

namespace Oxide.Plugins
{
    [Info("Chat Guard", "LaserHydra", "2.1.0", ResourceId = 1486)]
    [Description("Allows you to censor unwanted words and symbols in the chat.")]
    class ChatGuard : RustPlugin
    {
        #region Plugin General

        ////////////////////////////////////////
        ///     Plugin Related Hooks
        ////////////////////////////////////////

        void Loaded()
        {
#if !RUST
            throw new NotSupportedException("This plugin or the version of this plugin does not support this game!");
#endif

            LoadConfig();
        }

        ////////////////////////////////////////
        ///     Config & Message Loading
        ////////////////////////////////////////

        void LoadConfig()
        {
            SetConfig("Banned Words", new List<string>
            {
                "bitch",
                "faggot",
                "fuck"
            });

            SetConfig("Settings", "Replacement", "*");
            SetConfig("Settings", "Use Custom Replacement", false);
            SetConfig("Settings", "Custom Replacement", "Unicorn");

            SaveConfig();
        }

        protected override void LoadDefaultConfig() => PrintWarning("Generating new config file...");
        #endregion

        #region Subject Related

        object OnPlayerChat(ConsoleSystem.Arg arg)
        {
            BasePlayer player = (BasePlayer) arg.connection.player;
            string message = arg.GetString(0, "");
            
            if (FilterText(message) != message)
            {
                Puts(@"Filtered ""{0}""", message);

                message = FilterText(message);
                player.SendConsoleCommand("chat.say", message);

                return false;
            }

            return null;
        }

        string FilterText(string original)
        {
            string filtered = original;

            foreach (string word in original.Split(' '))
                foreach (string bannedword in GetConfig(new List<object> { "bitch", "faggot", "fuck" }, "Banned Words"))
                    if (TranslateLeet(word).ToLower().Contains(bannedword.ToLower()))
                        filtered = filtered.Replace(word, Replace(word));

            /*
            foreach (string word in GetConfig(new List<object> { "bitch", "faggot", "fuck" }, "Banned Words"))
                filtered = new Regex(@"((?:[\S]?)+" + word + @"(?:[\S]?)+)", RegexOptions.IgnoreCase).Replace(filtered, (a) => Replace(a));*/

            return filtered;
        }

        string Replace(string original)
        {
            string filtered = string.Empty;

            if (!GetConfig(false, "Settings", "Use Custom Replacement"))
                for (; filtered.Count() < original.Count() ;)
                    filtered += GetConfig("*", "Settings", "Replacement");
            else
                filtered = GetConfig("Unicorn", "Settings", "Custom Replacement");

            return filtered;
        }

        string TranslateLeet(string original)
        {
            string translated = original;

            Dictionary<string, string> leetTable = new Dictionary<string, string>
            {
                { "}{", "h" },
                { "|-|", "h" },
                { "]-[", "h" },
                { "/-/", "h" },
                { "|{", "k" },
                { "/\\/\\", "m" },
                { "|\\|", "n" },
                { "/\\/", "n" },
                { "()", "o" },
                { "[]", "o" },
                { "vv", "w" },
                { "\\/\\/", "w" },
                { "><", "x" },
                { "2", "z" },
                { "4", "a" },
                { "@", "a" },
                { "8", "b" },
                { "Ã", "b" },
                { "(", "c" },
                { "<", "c" },
                { "{", "c" },
                { "3", "e" },
                { "â¬", "e" },
                { "6", "g" },
                { "9", "g" },
                { "&", "g" },
                { "#", "h" },
                { "$", "s" },
                { "7", "t" },
                { "|", "l" },
                { "1", "i" },
                { "!", "i" },
                { "0", "o" },
            };

            foreach (var leet in leetTable)
                translated = translated.Replace(leet.Key, leet.Value);

            return translated;
        }

        #endregion

        #region General Methods

        ////////////////////////////////////////
        ///     Converting
        ////////////////////////////////////////

        string ListToString<T>(List<T> list, int first, string seperator) => string.Join(seperator, (from item in list select item.ToString()).Skip(first).ToArray());

        ////////////////////////////////////////
        ///     Config Related
        ////////////////////////////////////////

        void SetConfig(params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList();
            stringArgs.RemoveAt(args.Length - 1);

            if (Config.Get(stringArgs.ToArray()) == null) Config.Set(args);
        }

        T GetConfig<T>(T defaultVal, params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList();
            if (Config.Get(stringArgs.ToArray()) == null)
            {
                PrintError($"The plugin failed to read something from the config: {ListToString(stringArgs, 0, "/")}{Environment.NewLine}Please reload the plugin and see if this message is still showing. If so, please post this into the support thread of this plugin.");
                return defaultVal;
            }

            return (T)Convert.ChangeType(Config.Get(stringArgs.ToArray()), typeof(T));
        }

        ////////////////////////////////////////
        ///     Chat Related
        ////////////////////////////////////////

        void BroadcastChat(string prefix, string msg = null) => rust.BroadcastChat(msg == null ? prefix : "<color=#C4FF00>" + prefix + "</color>: " + msg);

        void SendChatMessage(BasePlayer player, string prefix, string msg = null) => rust.SendChatMessage(player, msg == null ? prefix : "<color=#C4FF00>" + prefix + "</color>: " + msg);

        #endregion
    }
}


// --- End of file: ChatGuard.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/MLRSDamage.cs ---
// --- Original Local Path: MLRSDamage.cs ---

﻿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using System.Linq;
using Oxide.Core.Plugins;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("MLRS Damage", "iLakSkiL", "1.5.1")]
    [Description("Edits the damage down by the MLRS.")]
    public class MLRSDamage : RustPlugin
    {

        int rocketsFired = 0;

        #region Configuration
        private Configuration _config;
        public class Configuration
        {
            [JsonProperty(PropertyName = "MLRS Settings")]
            public DefSettings defsettings = new DefSettings();

            public class DefSettings
            {
                [JsonProperty(PropertyName = "MLRS Damage Modifier")]
                public double damageMod = 1.0;

                [JsonProperty(PropertyName = "Allow Damage to Player Built Bases")]
                public bool pvBase = true;

                [JsonProperty(PropertyName = "Allow Damage to Players")]
                public bool pvPlayer = true;

                [JsonProperty(PropertyName = "Allow Damage to Raidable and Abandoned Bases")]
                public bool raidable = true;

                [JsonProperty(PropertyName = "Allow Damage to NPCs")]
                public bool npc = true;

                [JsonProperty(PropertyName = "MLRS Cooldown time (in minutes)")]
                public double broken = 10;

                [JsonProperty(PropertyName = "Total Rockets for MLRS to fire")]
                public int rocketAmount = 12;

                [JsonProperty(PropertyName = "Rocket Launch Interval (in seconds)")]
                public float launchTime = 0.5f;

                [JsonProperty(PropertyName = "Requires Aiming Module")]
                public bool needModule = true;

            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                SaveConfig();
            }
            catch
            {
                PrintError("Error reading config, please check!");
                Unsubscribe(nameof(OnEntityTakeDamage));
            }
        }

        protected override void LoadDefaultConfig()
        {
            _config = new Configuration();
            Puts("Loading Default Config");
            SaveConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(_config);
        #endregion

        #region Hooks
        private void Unload()
        {
            ConsoleSystem.Run(ConsoleSystem.Option.Server, "MLRS.brokenDownMinutes 10");
            Puts("MLRS cooldown time reset to 10 minutes");
            SetRocketAmount(12);
            UpdateMLRSContainers(12);
            Puts("MLRS total rockets to fire reset to 12");
            foreach (var entity in UnityEngine.Object.FindObjectsOfType<MLRS>())
            {
                StorageContainer dashboardContainer = entity.GetDashboardContainer();
                dashboardContainer.inventory.SetFlag(ItemContainer.Flag.IsLocked, false);
            }
            Puts("Aiming Modules now required to operate MLRS");
        }

        private void Loaded()
        {
            ConsoleSystem.Run(ConsoleSystem.Option.Server, $"MLRS.brokenDownMinutes {_config.defsettings.broken}"); //Sets MLRS cooldown timer

            SetRocketAmount(_config.defsettings.rocketAmount);
            foreach (var entity in UnityEngine.Object.FindObjectsOfType<MLRS>())
            {
                if (entity == null || !(entity is MLRS)) return;
                if (!_config.defsettings.needModule) ResetModule(entity);
                NextTick(() =>
                {
                    UpdateMLRSContainers(_config.defsettings.rocketAmount);
                });
            }
        }

        private void OnEntitySpawned(BaseEntity entity)
        {
            if (entity == null || !(entity is MLRS)) return;
            MLRS mlrs = entity as MLRS;
            if (!_config.defsettings.needModule) ResetModule(mlrs);
            NextTick(() =>
            {
                UpdateMLRSContainer(mlrs, _config.defsettings.rocketAmount);
            });

        }

        private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            float newDam = (float)_config.defsettings.damageMod;
            var victim = entity as BasePlayer;

            if (entity == null || info == null || info.WeaponPrefab == null) return null; //null checks
            if (info.WeaponPrefab.ShortPrefabName.Equals("rocket_mlrs"))
            {
                if (newDam == null || newDam <= 0) return true; //disables all MLRS damage when modifier is 0 or below

                //Checks Player Damage
                if (victim is BasePlayer && !victim.IsNpc && _config.defsettings.pvPlayer) 
                {
                    info.damageTypes.ScaleAll(newDam);
                    return null;
                }
                if (victim is BasePlayer && !victim.IsNpc && !_config.defsettings.pvPlayer) return true;


                //Checks for NPC Players
                if (_config.defsettings.npc && (victim is NPCPlayer || entity is BaseNpc || entity is BaseAnimalNPC))
                {
                    info.damageTypes.ScaleAll(newDam);
                    return null;
                }
                if (!_config.defsettings.npc && (victim is NPCPlayer || entity is BaseNpc || entity is BaseAnimalNPC)) return true;

                //Checks for Raidable Bases and Abandoned Bases (bases with 0 ownership)
                if (entity.OwnerID.Equals((ulong)0) && _config.defsettings.raidable) 
                {
                    info.damageTypes.ScaleAll(newDam);
                    return null;
                }
                if (entity.OwnerID.Equals((ulong)0) && !_config.defsettings.raidable) return true;


                //Checks for Base entities owned by players
                if (!entity.OwnerID.Equals((ulong)0) && _config.defsettings.pvBase) 
                {
                    info.damageTypes.ScaleAll(newDam);
                    return null;
                }
                if (!entity.OwnerID.Equals((ulong)0) && !_config.defsettings.pvBase) return true;

            }
            return null;
        }

        private void OnMlrsRocketFired(MLRS ent, ServerProjectile serverProjectile) 
        {
            if ((ent.RocketAmmoCount + rocketsFired) > _config.defsettings.rocketAmount)
            {
                ent.RocketAmmoCount = (_config.defsettings.rocketAmount - rocketsFired);
            }
            if (ent.RocketAmmoCount > 12)
            {
                ent.nextRocketIndex = (int)((ent.RocketAmmoCount % 11) + 1);
                rocketsFired++;
                return;
            }
            else
            {
                ent.nextRocketIndex = ent.RocketAmmoCount - 1;
                rocketsFired++;
                return;
            }
        }

        private object OnMlrsFire(MLRS ent, BasePlayer owner)
        {
            ent.SetFlag(BaseEntity.Flags.Reserved6, true, false, true);
            ent.radiusModIndex = 0;
            if (ent.RocketAmmoCount > 12)
            {
                ent.nextRocketIndex = (int)((ent.RocketAmmoCount % 11) + 1);
            }
            else ent.nextRocketIndex = ent.RocketAmmoCount - 1;
            ent.rocketOwnerRef.Set(owner);
            ent.InvokeRepeating(new Action(ent.FireNextRocket), 0f, _config.defsettings.launchTime);
            Interface.CallHook("OnMlrsFired", ent, owner);
            return true;
        }
        
        private void OnMlrsFiringEnded(MLRS entity)
        {
            if (!_config.defsettings.needModule) ResetModule(entity);
            rocketsFired = 0;
        }

        #endregion

        #region Helpers

        public void SetRocketAmount(int amount)
        {
            _config.defsettings.rocketAmount = amount;
            Puts($"Total MLRS Rocket Capacity set to: {_config.defsettings.rocketAmount} rockets");
        }

        private void UpdateMLRSContainers(int amount)
        {
            foreach (var entity in UnityEngine.Object.FindObjectsOfType<MLRS>())
            {
                if (entity == null || !(entity is MLRS)) return;
                NextTick(() =>
                {
                    var mlrsVeh = entity as MLRS;
                    StorageContainer rocketContainer = mlrsVeh.GetRocketContainer();
                    rocketContainer.inventory.maxStackSize = (amount / 2);
                });
            }
        }

        private void UpdateMLRSContainer(MLRS entity, int amount)
        {
            if (entity == null || !(entity is MLRS)) return;
            NextTick(() =>
            {
                var mlrsVeh = entity as MLRS;
                StorageContainer rocketContainer = mlrsVeh.GetRocketContainer();
                rocketContainer.inventory.maxStackSize = (amount / 2);
            });
        }

        private void ResetModule(MLRS entity)
        {
            timer.Once(2f, () =>
                {
                entity.VehicleFixedUpdate();
                StorageContainer dashboardContainer = entity.GetDashboardContainer();
                if (dashboardContainer.inventory.IsEmpty())
                {
                    dashboardContainer.inventory.AddItem(ItemManager.FindItemDefinition("aiming.module.mlrs"), 1, (ulong)0, ItemContainer.LimitStack.Existing);
                }
                dashboardContainer.inventory.SetFlag(ItemContainer.Flag.IsLocked, true);
            });
        }

        #endregion

        #region Commands
        [ConsoleCommand("mlrsdamage.damage")]
        private void Damage(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            double newDamage;
            if (arg.Args == null || !(double.TryParse(arg.Args[0], out newDamage)))
            {
                Puts("Error: Must enter a number!");
                return;
            }
            else
            {
                double.TryParse(arg.Args[0], out newDamage);
                _config.defsettings.damageMod = newDamage;
                SaveConfig();
                Puts($"MLRS damage was successfully changed to: {_config.defsettings.damageMod}");
            }
        }

        [ConsoleCommand("mlrsdamage.cooldown")]
        private void Cooldown(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            double newCooldown;
            if (arg.Args == null || !(double.TryParse(arg.Args[0], out newCooldown)))
            {
                Puts("Error: Must enter a number!");
                return;
            }
            else
            {
                double.TryParse(arg.Args[0], out newCooldown);
                _config.defsettings.broken = newCooldown;
                SaveConfig();
                ConsoleSystem.Run(ConsoleSystem.Option.Server, $"MLRS.brokenDownMinutes {_config.defsettings.broken}");
                Puts($"MLRS cooldown was successfully changed to: {_config.defsettings.broken} minutes");
            }
        }

        [ConsoleCommand("mlrsdamage.pvp")]
        private void PvpEnable(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            bool pvpEnable;
            if (arg.Args == null || !(bool.TryParse(arg.Args[0], out pvpEnable)))
            {
                Puts("Error: Enter either true of false!");
                return;
            }
            else
            {
                bool.TryParse(arg.Args[0], out pvpEnable);
                _config.defsettings.pvPlayer = pvpEnable;
                SaveConfig();
                if (_config.defsettings.pvPlayer) Puts("MLRS Player Damage is Enabled!");
                if (!_config.defsettings.pvPlayer) Puts("MLRS Player Damage is Disabled!");
            }
        }

        [ConsoleCommand("mlrsdamage.pvpbase")]
        private void PvpBaseEnable(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            bool pvpBaseEnable;
            if (arg.Args == null || !(bool.TryParse(arg.Args[0], out pvpBaseEnable)))
            {
                Puts("Error: Enter either true of false!");
                return;
            }
            else
            {
                bool.TryParse(arg.Args[0], out pvpBaseEnable);
                _config.defsettings.pvBase = pvpBaseEnable;
                SaveConfig();
                if (_config.defsettings.pvBase) Puts("MLRS Player Base Damage is Enabled!");
                if (!_config.defsettings.pvBase) Puts("MLRS Player Base Damage is Disabled!");
            }
        }

        [ConsoleCommand("mlrsdamage.raidable")]
        private void RaidableEnable(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            bool raidableEnable;
            if (arg.Args == null || !(bool.TryParse(arg.Args[0], out raidableEnable)))
            {
                Puts("Error: Enter either true of false!");
                return;
            }
            else
            {
                bool.TryParse(arg.Args[0], out raidableEnable);
                _config.defsettings.raidable = raidableEnable;
                SaveConfig();
                if (_config.defsettings.raidable) Puts("MLRS Raidable/Abandoned Base Damage is Enabled!");
                if (!_config.defsettings.raidable) Puts("MLRS Raidable/Abandoned Base Damage is Disabled!");
            }
        }

        [ConsoleCommand("mlrsdamage.npc")]
        private void NpcEnable(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            bool npcEnable;
            if (arg.Args == null || !(bool.TryParse(arg.Args[0], out npcEnable)))
            {
                Puts("Error: Enter either true of false!");
                return;
            }
            else
            {
                bool.TryParse(arg.Args[0], out npcEnable);
                _config.defsettings.npc = npcEnable;
                SaveConfig();
                if (_config.defsettings.npc) Puts("MLRS NPC Damage is Enabled!");
                if (!_config.defsettings.npc) Puts("MLRS NPC Damage is Disabled!");
            }
        }

        [ConsoleCommand("mlrsdamage.rockets")]
        private void RocketsNum(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            int rocketsNum;
            if (arg.Args == null || !(int.TryParse(arg.Args[0], out rocketsNum)))
            {
                Puts("Error: Must enter a whole number!");
                return;
            }
            else
            {
                int.TryParse(arg.Args[0], out rocketsNum);
                _config.defsettings.rocketAmount = rocketsNum;
                SetRocketAmount(rocketsNum);
                UpdateMLRSContainers(rocketsNum);
                SaveConfig();
            }
        }

        [ConsoleCommand("mlrsdamage.module")]
        private void NeedModule(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            bool module;
            if (arg.Args == null || !(bool.TryParse(arg.Args[0], out module)))
            {
                Puts("Error: Enter either true of false!");
                return;
            }
            else
            {
                bool.TryParse(arg.Args[0], out module);
                _config.defsettings.needModule = module;
                SaveConfig();
                foreach (var entity in UnityEngine.Object.FindObjectsOfType<MLRS>())
                {
                    if (entity == null || !(entity is MLRS)) return;
                    if (!_config.defsettings.needModule) ResetModule(entity);
                }
                if (_config.defsettings.needModule) Puts("An Aiming Module will be needed needed to activate the MLRS!");
                if (!_config.defsettings.needModule) Puts("An Aiming Module is no longer needed to activate the MLRS!");
            }
        }

        [ConsoleCommand("mlrsdamage.interval")]
        private void LaunchInterval(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            float speed;
            if (arg.Args == null || !(float.TryParse(arg.Args[0], out speed)))
            {

                Puts("Error: Must enter a number!");
                return;
            }
            if (speed < 0)
            {
                Puts("Error: Missile interval cannot be a negative number");
                return;
            }
            if (speed == 0 || (speed > 0 && speed < 0.1))
            {
                Puts("CAUTION: It is not advisable to have such a short interval on missile launches. You may encounter server issues.");
                float.TryParse(arg.Args[0], out speed);
                _config.defsettings.launchTime = speed;
                SaveConfig();
                Puts($"MLRS missile launch interval is now set for {_config.defsettings.launchTime} seconds!");
            }
            else
            {
                float.TryParse(arg.Args[0], out speed);
                _config.defsettings.launchTime = speed;
                SaveConfig();
                Puts($"MLRS missile launch interval is now set for {_config.defsettings.launchTime} seconds!");
            }
        }
        #endregion
    }
}


// --- End of file: MLRSDamage.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/FireSword.cs ---
// --- Original Local Path: FireSword.cs ---

using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("FireSword", "ColonBlow", "1.1.8")]
    public class FireSword : RustPlugin
    {
        //fix for sword skin id not working from config

        #region Load and Data

        void Loaded()
        {
            permission.RegisterPermission("firesword.blacksmith", this);
            lang.RegisterMessages(messagesFA, this);
            LoadVariables();
            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyFireOnData(player);
            }
        }

        bool Changed;
        bool isAllowed(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);

        //This allows tracking Melee Weapons that are on fire when thrown to toggle fire effects on impact
        static Dictionary<ulong, ToggleFireData> FireOn = new Dictionary<ulong, ToggleFireData>();

        class ToggleFireData
        {
            public BasePlayer player;
        }

        #endregion

        #region Commands

        [ChatCommand("firesword")]
        void chatFireSword(BasePlayer player, string command)
        {
            AddFireSword(player);
        }

        [ConsoleCommand("firesword")]
        void cmdConsoleFireSword(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            AddFireSword(player);
        }

        #endregion

        #region Configuration

        static float FSChance = 50f;
        static float FSHeatDamage = 25f;
        static float FSExplosionDamage = 100f;
        static float DamageRadius = 1f;
        static bool UseProt = true;
        static bool LootAndUse = true;
        static bool DamageConditionOnThrow = true;
        static ulong CustomSkinID = 813766930;

        static bool MatsToBuild = true;
        static int AmountToBuild = 100;
        static int ReqBuildItemID = -946369541;

        static bool UseMats = true;
        static int AmountReq1 = 5;
        static int Req1ItemID = -946369541;  //Default ID is low grade fuel
        static int AmountReq2 = 20;
        static int Req2ItemID = -265876753; //Default ID is gunpowder

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        void LoadDefaultConfig()
        {
            Puts("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }

        private void LoadConfigVariables()
        {
            CheckCfgFloat("Damage - Chance - Likelyhood of Fireball spawn on Melee Fire Weapon Strike : (percentage) : ", ref FSChance);
            CheckCfgFloat("Damage - Heat - Amount of Heat Damage added with Melee/Throw attacks : ", ref FSHeatDamage);
            CheckCfgFloat("Damage - Explosive - Amount added when Fire Weapon is Thrown : ", ref FSExplosionDamage);
            CheckCfgFloat("Damage - Radius - Strike/Throw damage radius : ", ref DamageRadius);
            CheckCfg("Damage - Reduction - Use Victims Protection Values when damaging : ", ref UseProt);

            CheckCfg("Materials - Make Sword - Require Materials to Make Fire Sword : ", ref MatsToBuild);
            CheckCfg("Materials - Make Sword - ID of item needed to make Fire Sword : ", ref ReqBuildItemID);
            CheckCfg("Materials - Make Sword - Amount of Materials needed to Make Fire Sword : ", ref AmountToBuild);

            CheckCfg("Usage - Found/Looted Fire Weapons can be used by Anyone : (no perms needed) : ", ref LootAndUse);
            CheckCfg("Durability - Deal random condition loss when Fire Weapon is Thrown : ", ref DamageConditionOnThrow);
            CheckCfgUlong("Skin - Fire Weapon custom steam skin ID : (Set to 0 for default) : ", ref CustomSkinID);

            CheckCfg("Materials - Require materials to use Fire Sword : ", ref UseMats);
            CheckCfg("Materials - Flame - Material ID needed to fuel flames", ref Req1ItemID);
            CheckCfg("Materials - Flame - Amount PER TICK needed for flames : ", ref AmountReq1);
            CheckCfg("Materials - Explosion - Material ID needed for Explosion on Weapon Throw : ", ref Req2ItemID);
            CheckCfg("Materials - Explosion - Amount needed for Explosion : ", ref AmountReq2);
        }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        private void CheckCfgFloat(string Key, ref float var)
        {

            if (Config[Key] != null)
                var = Convert.ToSingle(Config[Key]);
            else
                Config[Key] = var;
        }

        void CheckCfgUlong(string Key, ref ulong var)
        {

            if (Config[Key] != null)
                var = Convert.ToUInt64(Config[Key]);
            else
                Config[Key] = var;
        }

        #endregion

        #region Localization

        Dictionary<string, string> messagesFA = new Dictionary<string, string>()
                {
                    {"fireweapondenied", "You are not worthy of this yet !!"},
                    {"fireweapondestroyed", "You have destroyed your Fire Weapon !!"},
                    {"fireweaponcreationerror", "No room in your inventory for Fire Weapon !!"},
                    {"fireweaponnomats1", "You need Low Grade Fuel (" + AmountReq1 + ") to Toggle Fire Weapon !!"},
                    {"fireweaponnomats2", "You need Low Grade Fuel (" + AmountReq1 + ") and Explosives (" + AmountReq2 + ") to have Fire Weapon Throw Explosion !!"},
            {"fireweaponcreated", "You have created a Fire Weapon !!"}
                };

        #endregion

        #region Flame Weapon

        class FlameWeapon : MonoBehaviour
        {
            BasePlayer player;
            BaseEntity flame;
            BaseEntity playerweapon;
            FireBall fireball;
            Vector3 pos;
            Quaternion rot;
            string prefab;

            void Awake()
            {
                player = GetComponent<BasePlayer>();
                playerweapon = player.GetHeldEntity();
                pos = new Vector3(-0.1f, -0.1f, -0.6f);
                rot = Quaternion.identity;
                prefab = "assets/bundled/prefabs/fireball_small.prefab";
            }

            void FixedUpdate()
            {
                if (!UsingFireWeapon(player))
                {
                    if (fireball == null) return;
                    fireball.Kill(BaseNetworkable.DestroyMode.None);
                    return;
                }
                if (fireball != null)
                {
                    fireball.transform.localPosition = new Vector3(-0.1f, -0.1f, -0.6f);
                    fireball.transform.hasChanged = true;
                    fireball.SendNetworkUpdateImmediate();
                    return;

                }
                if (fireball == null)
                {
                    SpawnFireEffects();
                }
            }
            void SpawnFireEffects()
            {
                if (UseMats)
                {
                    if (!HasItem1Mats(player))
                    {
                        GameObject.Destroy(this);
                        return;
                    }
                    else
                    if (TakeItem1Mats(player)) ;
                }

                flame = GameManager.server.CreateEntity(prefab, pos, rot, true);
                fireball = flame.GetComponent<FireBall>();
                fireball.generation = 0.1f;
                fireball.radius = 0.1f;
                fireball.tickRate = 0.1f;
                fireball.SetParent(playerweapon, 0);
                flame?.Spawn();
            }

            bool HasItem1Mats(BasePlayer player)
            {
                int HasReq1 = player.inventory.GetAmount(Req1ItemID);

                if (HasReq1 >= AmountReq1) return true;
                return false;
            }


            bool TakeItem1Mats(BasePlayer player)
            {
                int HasReq1 = player.inventory.GetAmount(Req1ItemID);

                if (HasReq1 >= AmountReq1)
                {
                    player.inventory.Take(null, Req1ItemID, AmountReq1);
                    player.Command("note.inv", Req1ItemID, -AmountReq1);
                    return true;
                }
                return false;
            }

            void OnDestroy()
            {
                if (fireball == null) return;
                fireball.Kill(BaseNetworkable.DestroyMode.None);
            }
        }

        #endregion

        #region Hooks

        void AddFireOn(BasePlayer player)
        {
            if (ThrowWeaponHasFireOn(player)) return;
            FireOn.Add(player.userID, new ToggleFireData { player = player, });
        }

        void RemoveFireOn(BasePlayer player)
        {
            if (!ThrowWeaponHasFireOn(player)) return;
            FireOn.Remove(player.userID);
        }

        bool ThrowWeaponHasFireOn(BasePlayer player)
        {
            if (FireOn.ContainsKey(player.userID)) return true;
            return false;
        }

        public void SpawnFireSword(ItemContainer itemContainer)
        {
            int roll = UnityEngine.Random.Range(0, 100);
            if (roll >= 75) return;
            Item sword = ItemManager.CreateByItemID(-388967316, 1, 813766930);
            sword.MoveToContainer(itemContainer, -1, false);
            sword.SetFlag(global::Item.Flag.OnFire, true);
            sword.MarkDirty();
        }

        void OnMeleeThrown(BasePlayer player, Item item)
        {
            if (item == null) return;
            if (player == null) return;
            if (!item.HasFlag(global::Item.Flag.OnFire)) { RemoveFireOn(player); return; }
            if (item.HasFlag(global::Item.Flag.OnFire))
            {
                var flameweapon = player.GetComponent<FlameWeapon>();
                if (flameweapon == null) return;
                AddFireOn(player);
                ThrowWeaponCondition(player, item);
            }
        }

        void OnPlayerAttack(BasePlayer player, HitInfo hitInfo)
        {
            if (hitInfo == null) return;
            if (player == null) return;

            //Checks to make sure weapon has Fire toggled on or off
            var flameweapon = player.GetComponent<FlameWeapon>() ?? null;
            if (flameweapon == null) return;

            Vector3 pos = hitInfo.HitPositionWorld;

            //OnMeleeThrown check to make sure weapon thrown is a fire weapon
            if ((ThrowWeaponHasFireOn(player)) && (flameweapon != null))
            {
                WeaponStrikeFX(player, pos, hitInfo);
                WeaponThrowFX(player, pos, hitInfo);
                RemoveFireOn(player);
                GameObject.Destroy(flameweapon);
                return;
            }

            //Check melee attack to make sure using fire weapon
            if (!UsingFireWeapon(player)) return;
            if ((UsingFireWeapon(player)) && (flameweapon != null))
            {
                WeaponStrikeFX(player, pos, hitInfo);
                RemoveFireOn(player);
                return;
            }
        }

        bool UsingSwordWeapon(BasePlayer player)
        {
            Item activeItem = player.GetActiveItem();
            if (activeItem != null && activeItem.info.shortname == "salvaged.sword") return true;
            return false;
        }
        static bool UsingFireWeapon(BasePlayer player)
        {
            Item activeItem = player.GetActiveItem();
            if (activeItem != null && activeItem.HasFlag(global::Item.Flag.OnFire)) return true;
            return false;
        }

        void WeaponThrowFX(BasePlayer player, Vector3 pos, HitInfo hitInfo)
        {
            if (UseMats)
            {
                if (HasItem2Mats(player))
                {
                    Effect.server.Run("assets/bundled/prefabs/fx/explosions/explosion_01.prefab", pos);
                    AddSwordDamage(player, FSExplosionDamage, Rust.DamageType.Explosion, hitInfo);
                    AddSwordDamage(player, FSHeatDamage, Rust.DamageType.Heat, hitInfo);
                    return;
                }
                else
                    SendReply(player, lang.GetMessage("fireweaponnomats2", this));
                return;

            }
            else
                Effect.server.Run("assets/bundled/prefabs/fx/explosions/explosion_01.prefab", pos);
            AddSwordDamage(player, FSExplosionDamage, Rust.DamageType.Explosion, hitInfo);
            AddSwordDamage(player, FSHeatDamage, Rust.DamageType.Heat, hitInfo);
            return;
        }

        void WeaponStrikeFX(BasePlayer player, Vector3 pos, HitInfo hitInfo)
        {
            AddSwordDamage(player, FSHeatDamage, Rust.DamageType.Heat, hitInfo);
            float chanceforstrike = UnityEngine.Random.Range(0f, 99f);
            if (chanceforstrike <= FSChance)
            {
                Quaternion rot = new Quaternion();
                string prefab = "assets/bundled/prefabs/fireball.prefab";
                BaseEntity flame = GameManager.server.CreateEntity(prefab, pos, rot, true);
                FireBall fireball = flame.GetComponent<FireBall>();
                fireball.damagePerSecond = 1f;
                fireball.radius = 1f;
                fireball.lifeTimeMin = 5f;
                fireball.lifeTimeMin = 5f;
                fireball.generation = 10f;
                fireball.Spawn();
                return;
            }
        }

        void AddSwordDamage(BasePlayer player, float damageamount, Rust.DamageType damagetype, HitInfo hitInfo)
        {
            List<BaseCombatEntity> entitylist = new List<BaseCombatEntity>();
            Vis.Entities<BaseCombatEntity>(hitInfo.HitPositionWorld, DamageRadius, entitylist);

            foreach (BaseCombatEntity entity in entitylist)
            {
                if (!(entity is BuildingPrivlidge))
                {
                    if (entity is BasePlayer)
                    {
                        var attacker = (BasePlayer)entity;
                        if (attacker.userID == player.userID) return;
                    }
                    entity.Hurt(damageamount, damagetype, player, UseProt);
                }
            }
        }

        void ThrowWeaponCondition(BasePlayer player, Item item)
        {
            if (DamageConditionOnThrow)
            {
                float currentcond = item.condition;
                float randomcond = UnityEngine.Random.Range(10f, currentcond + 10f);
                item.condition = item.condition - randomcond;
                if (item.condition <= 0)
                {
                    SendReply(player, lang.GetMessage("fireweapondestroyed", this));
                }
                return;
            }
            else
                return;
        }

        bool HasItem1Mats(BasePlayer player)
        {
            int HasReq1 = player.inventory.GetAmount(Req1ItemID);

            if (HasReq1 >= AmountReq1) return true;
            return false;
        }

        bool HasItem2Mats(BasePlayer player)
        {
            int HasReq2 = player.inventory.GetAmount(Req2ItemID);

            if (HasReq2 >= AmountReq2)
            {
                player.inventory.Take(null, Req2ItemID, AmountReq2);
                player.Command("note.inv", Req2ItemID, -AmountReq2);
                return true;
            }
            return false;
        }

        void AddFireSword(BasePlayer player)
        {
            if (!UsingSwordWeapon(player)) return;
            var flameweapon = player.GetComponent<FlameWeapon>();

            //toggles fire off if already on
            if (flameweapon != null)
            {
                GameObject.Destroy(flameweapon);
                RemoveFireOn(player);
                return;
            }

            //toggles fire on if player is holding fire weapon and LootAndUse is turned on. or has permission to make a fire sword.
            if (flameweapon == null)
            {
                if ((UsingFireWeapon(player)) && (LootAndUse))
                {
                    if (UseMats)
                    {
                        if (!HasItem1Mats(player))
                        {
                            SendReply(player, lang.GetMessage("fireweaponnomats1", this));
                            return;
                        }
                    }
                    player.gameObject.AddComponent<FlameWeapon>();
                    return;
                }
                if (!UsingFireWeapon(player))
                {
                    if (isAllowed(player, "firesword.blacksmith"))
                    {
                        ActivateWeapon(player);
                        return;
                    }
                    SendReply(player, lang.GetMessage("fireweapondenied", this));
                    return;
                }
            }
        }

        void ActivateWeapon(BasePlayer player)
        {
            Item playerweaponitem = player.GetActiveItem();
            if (playerweaponitem.skin != CustomSkinID)
            {
                ReplaceWithFireSword(player, playerweaponitem);
                return;
            }
            if (playerweaponitem.skin == CustomSkinID)
            {
                ActivateFireSword(player, playerweaponitem);
                return;
            }
        }

        void ReplaceWithFireSword(BasePlayer player, Item playerweaponitem)
        {
            if (MatsToBuild)
            {
                if (!CheckUpgradeMats(player, ReqBuildItemID, AmountToBuild, "Fire Sword")) return;
            }
            playerweaponitem.Remove(0f);

            Item sword = ItemManager.CreateByItemID(1326180354, 1, CustomSkinID);
            if (!player.inventory.GiveItem(sword, null))
            {
                sword.Remove(0f);
                SendReply(player, lang.GetMessage("fireweaponcreationerror", this));
                return;
            }
            SendReply(player, lang.GetMessage("fireweaponcreated", this));
            ActivateFireSword(player, sword);
        }

        bool CheckUpgradeMats(BasePlayer player, int itemID, int amount, string str)
        {
            int HasReq = player.inventory.GetAmount(itemID);
            if (HasReq >= amount)
            {
                player.inventory.Take(null, itemID, amount);
                player.Command("note.inv", itemID, -amount);
                return true;
            }
            ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemID);

            SendReply(player, "You need " + amount + " " + itemDefinition.shortname + " to build " + str);
            return false;
        }

        void ActivateFireSword(BasePlayer player, Item playerweaponitem)
        {
            playerweaponitem.SetFlag(global::Item.Flag.OnFire, true);
            playerweaponitem.MarkDirty();
        }

        void Unload()
        {
            DestroyAll<FlameWeapon>();
        }

        void DestroyFireOnData(BasePlayer player)
        {
            if (FireOn.ContainsKey(player.userID))
            {
                FireOn.Remove(player.userID);
            }
            else
                return;
        }

        static void DestroyAll<T>()
        {
            var objects = GameObject.FindObjectsOfType(typeof(T));
            if (objects != null)
                foreach (var gameObj in objects)
                    GameObject.Destroy(gameObj);
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            var flameweapon = player.GetComponent<FlameWeapon>();
            if (flameweapon == null) return;
            if (flameweapon != null)
            {
                GameObject.Destroy(flameweapon);
            }
            DestroyFireOnData(player);
            return;
        }

        void OnPlayerRespawned(BasePlayer player)
        {
            var flameweapon = player.GetComponent<FlameWeapon>();
            if (flameweapon == null) return;
            if (flameweapon != null)
            {
                GameObject.Destroy(flameweapon);
            }
            DestroyFireOnData(player);
            return;
        }

        #endregion
    }
}


// --- End of file: FireSword.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrollTax.cs ---
// --- Original Local Path: TrollTax.cs ---

using System.Collections.Generic;
using System;
using System.Linq;
using UnityEngine;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using Oxide.Core;
using System.Reflection;

namespace Oxide.Plugins
{
    [Info("TrollTax", "Absolut", "1.0.0", ResourceId = 000000)]

    class TrollTax : RustPlugin
    {
        #region Fields

        [PluginReference]
        Plugin LustyMap;

        string TitleColor = "<color=orange>";
        string MsgColor = "<color=#A9A9A9>";

        TrollTaxData ttData;
        private DynamicConfigFile TTData;

        private Dictionary<string, Timer> timers = new Dictionary<string, Timer>();
        private Dictionary<ulong, Coords> BoxPrep = new Dictionary<ulong, Coords>();

        #endregion

        #region Server Hooks

        void Loaded()
        {
            TTData = Interface.Oxide.DataFileSystem.GetFile("TrollTax_Data");
            lang.RegisterMessages(messages, this);
        }

        void Unload()
        {
            BoxPrep.Clear();
            foreach (var entry in timers)
                entry.Value.Destroy();
            timers.Clear();
            SaveData();
        }

        void OnServerInitialized()
        {
            LoadVariables();
            LoadData();
            timers.Add("info", timer.Once(900, () => InfoLoop()));
            timers.Add("save", timer.Once(600, () => SaveLoop()));
            SaveData();
        }

        #endregion

        #region Player Hooks

        void OnEntityBuilt(Planner planner, GameObject gameobject)
        {
            if (planner == null) return;
            if (gameobject.GetComponent<BaseEntity>() != null)
            {
                BaseEntity container = gameobject.GetComponent<BaseEntity>();
                var entityowner = gameobject.GetComponent<BaseEntity>().OwnerID;
                if (container.PrefabName == "assets/prefabs/deployable/large wood storage/box.wooden.large.prefab" || container.PrefabName == "assets/prefabs/deployable/woodenbox/woodbox_deployed.prefab")
                {
                    if (BoxPrep.ContainsKey(entityowner)) BoxPrep.Remove(entityowner);
                    BoxPrep.Add(entityowner, new Coords { x = gameobject.transform.position.x, y = gameobject.transform.position.y, z = gameobject.transform.position.z });
                    BasePlayer player = BasePlayer.FindByID(entityowner);
                    TaxBoxConfirmation(player);
                }
            }
        }

        private void OnEntityDeath(BaseEntity entity, HitInfo hitInfo)
        {
            if (entity is StorageContainer)
            {
                Vector3 ContPosition = entity.transform.position;
                if (ttData.TaxBox.ContainsKey(entity.OwnerID))
                {
                    if (ContPosition == new Vector3 ( ttData.TaxBox[entity.OwnerID].x, ttData.TaxBox[entity.OwnerID].y, ttData.TaxBox[entity.OwnerID].z))
                    {
                        ttData.TaxBox.Remove(entity.OwnerID);
                        BasePlayer owner = BasePlayer.FindByID(entity.OwnerID);
                        if (BasePlayer.activePlayerList.Contains(owner))
                            GetSendMSG(owner, "TaxBoxDestroyed");
                    }
                    SaveData();
                }
                return;
            }
            if (entity is BasePlayer)
            {
                var victim = entity.ToPlayer();
                if (ttData.TaxCollector.ContainsKey(victim.userID))
                {
                    ttData.TaxCollector.Remove(victim.userID);
                    SaveData();
                }
                if (entity is BasePlayer && hitInfo.Initiator is BasePlayer)
                {
                    var attacker = hitInfo.Initiator.ToPlayer() as BasePlayer;
                    if (entity as BasePlayer == null || hitInfo == null) return;
                    if (victim.userID != attacker.userID)
                    {
                        if (!ttData.TaxCollector.ContainsKey(attacker.userID))
                            ttData.TaxCollector.Add(attacker.userID, new List<ulong>());
                        ttData.TaxCollector[attacker.userID].Add(victim.userID);
                        SaveData();
                    }
                }
            }
        }

        void OnPlantGather(PlantEntity Plant, Item item, BasePlayer player)
        {
            if (!isPayor(player.userID)) return;
            var taxrate = configData.TaxRate;
            List<StorageContainer> TaxContainers = GetTaxContainer(player.userID);
            if (TaxContainers == null) return;
            int taxcollectors = 0;
            foreach (var entry in ttData.TaxCollector.Where(kvp => kvp.Value.Contains(player.userID)))
                taxcollectors++;
            var maxtaxors = Math.Floor(100 / taxrate);
            if (maxtaxors < taxcollectors)
                taxrate = 90 / taxcollectors;

            int Tax = Convert.ToInt32(Math.Ceiling((item.amount * taxrate) / 100));
            item.amount = item.amount - (Tax * taxcollectors);
            foreach (StorageContainer cont in TaxContainers)
            {
                if (!cont.inventory.IsFull())
                {
                    ItemDefinition ToAdd = ItemManager.FindItemDefinition(item.info.itemid);
                    if (ToAdd != null)
                    {
                        cont.inventory.AddItem(ToAdd, Tax);
                    }
                }
                else if (BasePlayer.activePlayerList.Contains(BasePlayer.FindByID(cont.OwnerID)))
                    if (timers.ContainsKey(cont.OwnerID.ToString()))
                    {
                        GetSendMSG(player, "TaxBoxFull");
                        SetBoxFullNotification(cont.OwnerID.ToString());
                        return;
                    }
            }
        }


        void OnCollectiblePickup(Item item, BasePlayer player)
        {
            if (!isPayor(player.userID)) return;
            var taxrate = configData.TaxRate;
            List<StorageContainer> TaxContainers = GetTaxContainer(player.userID);
            if (TaxContainers == null) return;
            int taxcollectors = 0;
            foreach (var entry in ttData.TaxCollector.Where(kvp => kvp.Value.Contains(player.userID)))
                taxcollectors++;
            var maxtaxors = Math.Floor(100 / taxrate);
            if (maxtaxors < taxcollectors)
                taxrate = 90 / taxcollectors;

            int Tax = Convert.ToInt32(Math.Ceiling((item.amount * taxrate) / 100));
            item.amount = item.amount - (Tax * taxcollectors);
            foreach (StorageContainer cont in TaxContainers)
            {
                if (!cont.inventory.IsFull())
                {
                    ItemDefinition ToAdd = ItemManager.FindItemDefinition(item.info.itemid);
                    if (ToAdd != null)
                    {
                        cont.inventory.AddItem(ToAdd, Tax);
                    }
                }
                else if (BasePlayer.activePlayerList.Contains(BasePlayer.FindByID(cont.OwnerID)))
                    if (timers.ContainsKey(cont.OwnerID.ToString()))
                    {
                        GetSendMSG(player, "TaxBoxFull");
                        SetBoxFullNotification(cont.OwnerID.ToString());
                        return;
                    }
            }
        }

        void OnDispenserGather(ResourceDispenser Dispenser, BaseEntity entity, Item item)
        {
            BasePlayer player = entity.ToPlayer();
            if (!isPayor(entity.ToPlayer().userID)) return;
            var taxrate = configData.TaxRate;
            List<StorageContainer> TaxContainers = GetTaxContainer(player.userID);
            if (TaxContainers == null) return;
            int taxcollectors = 0;
            foreach (var entry in ttData.TaxCollector.Where(kvp => kvp.Value.Contains(player.userID)))
                taxcollectors++; 
            var maxtaxors = Math.Floor(100 / taxrate);
            if (maxtaxors < taxcollectors)
                taxrate = 90 / taxcollectors;
            int Tax = Convert.ToInt32(Math.Ceiling((item.amount * taxrate) / 100));
            item.amount = item.amount - (Tax * taxcollectors);
            foreach (StorageContainer cont in TaxContainers)
            {
                if (!cont.inventory.IsFull())
                {
                    ItemDefinition ToAdd = ItemManager.FindItemDefinition(item.info.itemid);
                    if (ToAdd != null)
                    {
                        cont.inventory.AddItem(ToAdd, Tax);
                    }
                }
                else if (BasePlayer.activePlayerList.Contains(BasePlayer.FindByID(cont.OwnerID)))
                    if (timers.ContainsKey(cont.OwnerID.ToString()))
                    {
                        GetSendMSG(player, "TaxBoxFull");
                        SetBoxFullNotification(cont.OwnerID.ToString());
                        return;
                    }
            }
        }


        #endregion

        #region Functions
        public bool isPayor(ulong ID)
        {
            foreach (var entry in ttData.TaxCollector)
            {
                if (entry.Value.Contains(ID))
                {
                    return true;
                }
                else continue;
            }
            return false;
        }

        private List<StorageContainer> GetTaxContainer(ulong Payor)
        {
            List<StorageContainer> Containers = new List<StorageContainer>();
            foreach (var entry in ttData.TaxCollector.Where(kvp => kvp.Value.Contains(Payor)))
            {
                if (ttData.TaxBox.ContainsKey(entry.Key))
                {
                    Vector3 containerPos = new Vector3 (ttData.TaxBox[entry.Key].x, ttData.TaxBox[entry.Key].y, ttData.TaxBox[entry.Key].z );
                    foreach (StorageContainer Cont in StorageContainer.FindObjectsOfType<StorageContainer>())
                    {
                        Vector3 ContPosition = Cont.transform.position;
                        if (ContPosition == containerPos)
                            Containers.Add(Cont);
                    }
                }
            }
            if (Containers.Count > 0)
                return Containers;
            else return null;
        }

        private string GetLang(string msg)
        {
            if (messages.ContainsKey(msg))
                return lang.GetMessage(msg, this);
            else return msg;
        }

        private void GetSendMSG(BasePlayer player, string message, string arg1 = "", string arg2 = "", string arg3 = "")
        {
            string msg = string.Format(lang.GetMessage(message, this), arg1, arg2, arg3);
            SendReply(player, TitleColor + lang.GetMessage("title", this, player.UserIDString) + "</color>" + MsgColor + msg + "</color>");
        }

        private string GetMSG(string message, string arg1 = "", string arg2 = "", string arg3 = "")
        {
            string msg = string.Format(lang.GetMessage(message, this), arg1, arg2, arg3);
            return msg;
        }

        public void DestroyTaxPanel(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelTax);
        }
        #endregion

        #region UI Creation

        private string PanelTax = "Tax";

        public class UI
        {
            static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor = false)
            {
                var NewElement = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = color},
                        RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                        CursorEnabled = cursor
                    },
                    new CuiElement().Parent,
                    panelName
                }
            };
                return NewElement;
            }
            static public void CreatePanel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel);
            }
            static public void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = 1.0f, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);
            }

            static public void CreateButton(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 1.0f },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel);
            }

            static public void LoadImage(ref CuiElementContainer container, string panel, string png, string aMin, string aMax)
            {
                container.Add(new CuiElement
                {
                    Parent = panel,
                    Components =
                    {
                        new CuiRawImageComponent {Png = png },
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax }
                    }
                });
            }
            static public void CreateTextOverlay(ref CuiElementContainer container, string panel, string text, string color, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter, float fadein = 1.0f)
            {
                //if (configdata.DisableUI_FadeIn)
                //    fadein = 0;
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = fadein, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);

            }
        }

        private Dictionary<string, string> UIColors = new Dictionary<string, string>
        {
            {"black", "0 0 0 1.0" },
            {"dark", "0.1 0.1 0.1 0.98" },
            {"header", "1 1 1 0.3" },
            {"light", ".564 .564 .564 1.0" },
            {"grey1", "0.6 0.6 0.6 1.0" },
            {"brown", "0.3 0.16 0.0 1.0" },
            {"yellow", "0.9 0.9 0.0 1.0" },
            {"orange", "1.0 0.65 0.0 1.0" },
            {"blue", "0.2 0.6 1.0 1.0" },
            {"red", "1.0 0.1 0.1 1.0" },
            {"white", "1 1 1 1" },
            {"green", "0.28 0.82 0.28 1.0" },
            {"grey", "0.85 0.85 0.85 1.0" },
            {"lightblue", "0.6 0.86 1.0 1.0" },
            {"buttonbg", "0.2 0.2 0.2 0.7" },
            {"buttongreen", "0.133 0.965 0.133 0.9" },
            {"buttonred", "0.964 0.133 0.133 0.9" },
            {"buttongrey", "0.8 0.8 0.8 0.9" },
            {"CSorange", "1.0 0.64 0.10 1.0" }
        };
        #endregion

        #region UI Panels

        private void TaxBoxConfirmation(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelTax);
            var element = UI.CreateElementContainer(PanelTax, UIColors["dark"], "0.425 0.45", "0.575 0.55", true);
            UI.CreatePanel(ref element, PanelTax, UIColors["light"], "0.01 0.02", "0.99 0.98");
            UI.CreateLabel(ref element, PanelTax, MsgColor, GetLang("TaxBoxCreation"), 14, "0.05 0.5", "0.95 0.9");
            UI.CreateButton(ref element, PanelTax, UIColors["buttongreen"], GetLang("Yes"), 14, "0.05 0.1", "0.475 0.4", $"UI_SaveTaxBox");
            UI.CreateButton(ref element, PanelTax, UIColors["buttonred"], GetLang("No"), 14, "0.525 0.1", "0.95 0.4", $"UI_DestroyTaxPanel");
            CuiHelper.AddUi(player, element);
        }
        #endregion

        #region UI Commands

        [ConsoleCommand("UI_SaveTaxBox")]
        private void cmdUI_SaveTaxBox(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyTaxPanel(player);
            if (BoxPrep.ContainsKey(player.userID))
            {
                if (ttData.TaxBox.ContainsKey(player.userID)) ttData.TaxBox.Remove(player.userID);
                ttData.TaxBox.Add(player.userID, new Coords { x = BoxPrep[player.userID].x, y = BoxPrep[player.userID].y, z = BoxPrep[player.userID].z });
            }
            else GetSendMSG(player, "NoBoxPrepped");
            SaveData();
        }

        [ConsoleCommand("UI_DestroyTaxPanel")]
        private void cmdUI_DestroyTaxPanel(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyTaxPanel(player);
        }
        #endregion

        #region Timers

        private void SaveLoop()
        {
            if (timers.ContainsKey("save"))
            {
                timers["save"].Destroy();
                timers.Remove("save");
            }
            SaveData();
            timers.Add("save", timer.Once(600, () => SaveLoop()));
        }

        private void InfoLoop()
        {
            if (timers.ContainsKey("info"))
            {
                timers["info"].Destroy();
                timers.Remove("info");
            }
            foreach (BasePlayer p in BasePlayer.activePlayerList)
            {
                GetSendMSG(p, "TrollTaxInfo");
            }
            timers.Add("info", timer.Once(900, () => InfoLoop()));
        }

        private void SetBoxFullNotification(string ID)
        {
            timers.Add(ID, timer.Once(5 * 60, () => timers.Remove(ID)));
        }

        #endregion

        #region Classes
        class TrollTaxData
        {
            public Dictionary<ulong, List<ulong>> TaxCollector = new Dictionary<ulong, List<ulong>>();
            public Dictionary<ulong, Coords> TaxBox = new Dictionary<ulong, Coords>();
        }

        class Coords
        {
            public float x;
            public float y;
            public float z;
        }
        #endregion

        #region Data Management

        void SaveData()
        {
            TTData.WriteObject(ttData);
        }

        void LoadData()
        {
            try
            {
                ttData = TTData.ReadObject<TrollTaxData>();
            }
            catch
            {
                Puts("Couldn't load TrollTax data, creating new datafile");
                ttData = new TrollTaxData();
            }
        }
        #endregion

        #region Config        
        private ConfigData configData;
        class ConfigData
        {
            //--------//General Settings//--------//
            public double TaxRate { get; set; }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                TaxRate = 5,
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Messages
        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"title", "TrollTax: " },
            {"TrollTaxInfo", "This server is running TrollTax. You will become a tax collector for each player you kill until you die. To create a tax box simply place a box on the ground."},
            {"NoBoxPrepped", "Error finding target tax box!" },
            {"TaxBoxDestroyed", "Your tax box has been destroyed!" },
            {"TaxBoxFull", "Your tax box is full! Clear room to generate taxes." },
            {"TaxBoxCreation", "Would like to make this your tax box?" },
            {"Yes", "Yes?" },
            {"No", "No?" }
        };
        #endregion
    }
}


// --- End of file: TrollTax.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BuildingRestriction.cs ---
// --- Original Local Path: BuildingRestriction.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("BuildingRestriction", "Jakkee", "1.1.3", ResourceId = 2124)]
    class BuildingRestriction : RustPlugin
    {

        #region Variables

        private List<string> AllowedBuildingBlocks = new List<string> { "assets/prefabs/building core/wall.low/wall.low.prefab",
            "assets/prefabs/building core/floor/floor.prefab",
            "assets/prefabs/building core/floor.triangle/floor.triangle.prefab",
            "assets/prefabs/building core/floor.frame/floor.frame.prefab",
            "assets/prefabs/building core/roof/roof.prefab" };
        private float MaxHeight = 15;
        private int MaxTFoundations = 24;
        private int MaxFoundations = 16;
        private string PermBypass = "buildingrestriction.bypass";
        private string TriangleFoundation = "assets/prefabs/building core/foundation.triangle/foundation.triangle.prefab";
        private string Foundation = "assets/prefabs/building core/foundation/foundation.prefab";
        Dictionary<uint, List<BuildingBlock>> buildingids = new Dictionary<uint, List<BuildingBlock>>();

        #endregion

        #region Initialization

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            Config["Max build height"] = 5;
            Config["Max triangle foundations"] = 24;
            Config["Max foundations"] = 16;
            Config.Save();
        }

        void Loaded()
        {
            CheckConfig();
            MaxTFoundations = GetConfig("Max triangle foundations", 24);
            MaxFoundations = GetConfig("Max foundations", 16);
            MaxHeight = GetConfig("Max build height", 5) * 3;
            permission.RegisterPermission(PermBypass, this);
            lang.RegisterMessages(messages, this);
        }

        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"Limit: Height", "You have reached the max building height! ({0} BuildingBlocks)"},
            {"Limit: Foundations", "You have reached the max foundations allowed! ({0} Foundations)"},
            {"Limit: Triangle Foundations", "You have reached the max triangle foundations allowed! ({0} Foundations)"},
        };

        void CheckConfig()
        {
            if (Config["VERSION"] == null)
            {
                ReloadConfig();
            }
            else if (GetConfig<string>("VERSION", "") != Version.ToString())
            {
                ReloadConfig();
            }
        }

        void OnServerInitialized()
        {
            UpdateDictionary();
        }

        protected void ReloadConfig()
        {
            Config["VERSION"] = Version.ToString();
            SaveConfig();
        }

        void UpdateDictionary()
        {
            Puts("Searching for structures, This may awhile...");
            buildingids.Clear();
            var FoundationBlocks = Resources.FindObjectsOfTypeAll<BuildingBlock>().Where(x => x.name == Foundation || x.name == TriangleFoundation).ToList();
            foreach (BuildingBlock Block in FoundationBlocks)
            {
                if (!buildingids.ContainsKey(Block.buildingID))
                {
                    var structure = UnityEngine.GameObject.FindObjectsOfType<BuildingBlock>().Where(x => x.buildingID == Block.buildingID && x.name == Foundation || x.name == TriangleFoundation).ToList();
                    buildingids[Block.buildingID] = structure;
                }
            }
            Puts("Completed! Found " + buildingids.Count.ToString() + " structures");
        }

        #endregion

        #region Oxide Hooks / Core

        void OnEntityBuilt(Planner planner, GameObject gameobject)
        {
            BasePlayer player = planner.GetOwnerPlayer();
            var hasperm = HasPermission(player.UserIDString, PermBypass);
            BaseEntity entity = UnityEngine.GameObjectEx.ToBaseEntity(gameobject);
            var buildingBlock = entity?.GetComponent<BuildingBlock>()?? null;
            if(buildingBlock != null || !buildingBlock.Equals(null))
            {
                var buildingId = buildingBlock.buildingID;
                if (buildingids.ContainsKey(buildingId))
                {
                    var ConnectingStructure = buildingids[buildingBlock.buildingID];
                    if (buildingBlock.name == Foundation || buildingBlock.name == TriangleFoundation)
                    {
                        var trifcount = GetCountOf(ConnectingStructure, TriangleFoundation);
                        var fcount = GetCountOf(ConnectingStructure, Foundation);
                        if (buildingBlock.name == Foundation && fcount >= MaxFoundations)
                        {
                            if (!hasperm)
                            {
                                buildingBlock.Kill(BaseNetworkable.DestroyMode.Gib);
                                SendReply(player, Lang("Limit: Foundations", player.UserIDString, MaxFoundations.ToString()), player);
                            }
                        }
                        else if (buildingBlock.name == TriangleFoundation && trifcount >= MaxTFoundations)
                        {
                            if (!hasperm)
                            {
                                buildingBlock.Kill(BaseNetworkable.DestroyMode.Gib);
                                SendReply(player, Lang("Limit: Triangle Foundations", player.UserIDString, MaxTFoundations.ToString()), player);
                            }
                        }
                        else
                        {
                            var structure = new List<BuildingBlock>(ConnectingStructure);
                            structure.Add(buildingBlock);
                            buildingids[buildingId] = structure;
                        }
                    }
                    else
                    {
                        if (!AllowedBuildingBlocks.Contains(buildingBlock.name))
                        {
                            BuildingBlock firstfoundation = null;
                            foreach (BuildingBlock block in ConnectingStructure)
                            {
                                if (block.name.Contains(TriangleFoundation) || block.name.Contains(Foundation))
                                {
                                    firstfoundation = block;
                                    break;
                                }
                            }
                            if (firstfoundation != null)
                            {
                                float height = (float)Math.Round(buildingBlock.transform.position.y - firstfoundation.transform.position.y, 0, MidpointRounding.AwayFromZero);
                                if (MaxHeight <= height)
                                {
                                    if (!hasperm)
                                    {
                                        buildingBlock.Kill(BaseNetworkable.DestroyMode.Gib);
                                        SendReply(player, Lang("Limit: Height", player.UserIDString, (MaxHeight / 3).ToString()), player);
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    var structure = new List<BuildingBlock>();
                    structure.Add(buildingBlock);
                    buildingids[buildingId] = structure;
                }
            }
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            var buildingBlock = entity?.GetComponent<BuildingBlock>()?? null;
            if (buildingBlock == null || buildingBlock.Equals(null))
            {
                return;
            } 
            else
            {
                if (buildingBlock.name == Foundation || buildingBlock.name == TriangleFoundation)
                {
                    if (buildingids.ContainsKey(buildingBlock.buildingID))
                    {
                        foreach (BuildingBlock Block in buildingids[buildingBlock.buildingID])
                        {
                            if (buildingBlock == Block)
                            {
                                buildingids[buildingBlock.buildingID].Remove(buildingBlock);
                                break;
                            }
                        }
                    }
                }
            }
        }

        void OnStructureDemolish(BaseCombatEntity entity, BasePlayer player)
        {
            var buildingBlock = entity?.GetComponent<BuildingBlock>() ?? null;
            if (buildingBlock == null || buildingBlock.Equals(null))
            {
                return;
            }
            else
            {
                if (buildingBlock.name == Foundation || buildingBlock.name == TriangleFoundation)
                {
                    if (buildingids.ContainsKey(buildingBlock.buildingID))
                    {
                        foreach (BuildingBlock Block in buildingids[buildingBlock.buildingID])
                        {
                            if (buildingBlock == Block)
                            {
                                buildingids[buildingBlock.buildingID].Remove(buildingBlock);
                                break;
                            }
                        }
                    }
                }
            }
        }

        #endregion

        #region Helper Methods

        private int GetCountOf(List<BuildingBlock> ConnectingStructure, string buildingobject)
        {
            int count = 0;
            var templist = ConnectingStructure.ToList();
            foreach (BuildingBlock block in templist)
            {
                if (block == null || block.Equals(null))
                {
                    ConnectingStructure.Remove(block);
                }
                else
                {
                    if (block.name == buildingobject)
                    {
                        count++;
                    }
                }
            }
            return count;
        }

        private T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null)
            {
                Config[name] = defaultValue;
                Config.Save();
                return defaultValue;
            }

            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        bool HasPermission(string id, string perm) => permission.UserHasPermission(id, perm);

        #endregion
    }
}


// --- End of file: BuildingRestriction.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CovertAdmin.cs ---
// --- Original Local Path: CovertAdmin.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using UnityEngine;
using Random = UnityEngine.Random;
using System.Text;

namespace Oxide.Plugins
{
    [Info("CovertAdmin", "redBDGR", "1.0.9")]
    [Description("Go fully undercover and disguise yourself as another player")]
    internal class CovertAdmin : RustPlugin
    {

        // Maintained by Colon Blow

        #region Load

        [PluginReference] private Plugin BetterChat;

        private bool Changed;

        private Dictionary<string, __CovertInfo> covertPlayerList = new Dictionary<string, __CovertInfo>();

        private class __CovertInfo
        {
            public ulong __covertID;
            public string __covertName;
            public BasePlayer __player;
            public string __restoreName;
            public ulong __restoreID;
        }

        private string covertNameColor = "#54A7FB";
        private const string __permissionName = "covertadmin.use";

        private Dictionary<string, object> covertNameList = new Dictionary<string, object>();

        private void Init()
        {
            LoadVariables();
            permission.RegisterPermission(__permissionName, this);
        }

        #endregion

        #region Configuration

        private string covertTags = "";
        private string covertTextSize = "15";
        private bool disableOnLogoff = true;
        private bool disableAdminAbilities = false;

        private static Dictionary<string, object> __RandomPlayerNames()
        {
            var __x = new Dictionary<string, object> { { "RandomPlayerName1", "76561198381967577" }, { "RandomPlayerName2", "76561198381967577" } };
            return __x;
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var __data = Config[menu] as Dictionary<string, object>;
            if (__data == null)
            {
                __data = new Dictionary<string, object>();
                Config[menu] = __data;
                Changed = true;
            }
            object __value;
            if (__data.TryGetValue(datavalue, out __value)) return __value;
            __value = defaultValue;
            __data[datavalue] = __value;
            Changed = true;
            return __value;
        }

        private void LoadVariables()
        {
            covertNameList = (Dictionary<string, object>)GetConfig("Settings", "Covert Name and SteamID(for profile pic)", __RandomPlayerNames());
            covertTags = Convert.ToString(GetConfig("Settings", "Tags", ""));
            covertNameColor = Convert.ToString(GetConfig("Settings", "Covert Name Colour", "#54A7FB"));
            covertTextSize = Convert.ToString(GetConfig("Settings", "Message Size", "15"));
            disableOnLogoff = Convert.ToBoolean(GetConfig("Settings", "Disable On Logout", true));
            disableAdminAbilities = Convert.ToBoolean(GetConfig("Settings", "Disable Admin Abilities", false));

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                // chat
                ["format"] = "<size={0}>{1} <color={2}>{3}</color>: {4}</size>",
                ["No Permission"] = "You cannot use this command",
                ["configerror"] = "Error in config, cannot read SteamID, Please check config for errors.",
                ["inputerror"] = "Error processing SteamID, please try again.",
                ["Covert Disabled"] = "Covert mode disabled",
                ["Covert Enabled"] = "Covert mode enabled! You will now appear under the name of \"{0}\"",
                ["Already In Covert"] = "You are already in covert mode",
                ["Login Warning"] = "Your covert mode is still activated! type /covert to disable it"
                // [0] = size
                // [1] = tags
                // [2] = colour
                // [3] = name
                // [4] = text
            }, this);
        }

        #endregion

        #region Commands

        [ChatCommand("covertstatus")]
        private void CovertStatusCMD(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, __permissionName))
            {
                player.ChatMessage(msg("No Permission", player.UserIDString));
                return;
            }
            if (covertPlayerList.ContainsKey(player.UserIDString))
            {
                StringBuilder __sb = new StringBuilder();
                __sb.AppendLine("Current covert status:");
                __sb.AppendLine($"Display Name: {covertPlayerList[player.UserIDString].__covertName}");
                __sb.AppendLine($"Covert ID: {covertPlayerList[player.UserIDString].__covertID}");
                player.ChatMessage(__sb.ToString().TrimEnd());
            }
            else
                player.ChatMessage("Covert mode is currently disabled");
        }

        [ChatCommand("covert")]
        private void CovertCMD(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, __permissionName)) { player.ChatMessage(msg("No Permission", player.UserIDString)); return; }

            switch (args.Length)
            {
                case 0:
                    if (covertPlayerList.ContainsKey(player.UserIDString))
                    {
                        __RenamePlayer(player, covertPlayerList[player.UserIDString].__restoreName, false);
                        covertPlayerList.Remove(player.UserIDString);
                        player.ChatMessage(msg("Covert Disabled", player.UserIDString));
                    }
                    else
                    {
                        var nameList = covertNameList.Keys.ToList();
                        var newCovertName = nameList[Convert.ToInt16(Mathf.Round(Random.Range(0f, Convert.ToSingle(covertNameList.Count) - 1f)))];
                        var newCovertID = new ulong();
                        if (UInt64.TryParse(covertNameList[newCovertName].ToString(), out newCovertID))
                        {
                            covertPlayerList.Add(player.UserIDString, new __CovertInfo { __covertName = newCovertName, __restoreName = player.displayName, __covertID = newCovertID, __player = player, __restoreID = player.userID });
                            __RenamePlayer(player, newCovertName, true);
                            player.ChatMessage(string.Format(msg("Covert Enabled", player.UserIDString), newCovertName));
                            return;
                        }
                        player.ChatMessage(msg("configerror", player.UserIDString));
                    }
                    break;
                case 1:
                    if (covertPlayerList.ContainsKey(player.UserIDString))
                    {
                        player.ChatMessage(msg("Already In Covert", player.UserIDString));
                        return;
                    }
                    covertPlayerList.Add(player.UserIDString, new __CovertInfo { __covertName = args[0], __restoreName = player.displayName, __covertID = 76561198136204161, __player = player, __restoreID = player.userID });
                    __RenamePlayer(player, args[0], true);
                    player.ChatMessage(string.Format(msg("Covert Enabled", player.UserIDString), args[0]));
                    break;
                case 2:
                    if (covertPlayerList.ContainsKey(player.UserIDString))
                    {
                        player.ChatMessage(msg("Already In Covert", player.UserIDString));
                        return;
                    }
                    var typedCovertID = new UInt64();
                    if (UInt64.TryParse(args[1].ToString(), out typedCovertID))
                    {
                        covertPlayerList.Add(player.UserIDString, new __CovertInfo { __covertName = args[0], __restoreName = player.displayName, __covertID = typedCovertID, __player = player, __restoreID = player.userID });
                        __RenamePlayer(player, args[0], true);
                        player.ChatMessage(string.Format(msg("Covert Enabled", player.UserIDString), args[0]));
                        return;
                    }
                    player.ChatMessage(msg("inputerror", player.UserIDString));
                    break;
            }
        }

        #endregion

        #region Hooks

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (!covertPlayerList.ContainsKey(player.UserIDString))
                return;
            if (disableOnLogoff)
            {
                __RenamePlayer(player, covertPlayerList[player.UserIDString].__restoreName, false);
                covertPlayerList.Remove(player.UserIDString);
            }
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (disableOnLogoff)
                return;
            if (!covertPlayerList.ContainsKey(player.UserIDString))
                return;
            __RenamePlayer(player, covertPlayerList[player.UserIDString].__covertName, true);
            player.ChatMessage(msg("Login Warning", player.UserIDString));
        }

        private void OnPlayerDeath(BasePlayer player, HitInfo hitInfo)
        {
            if (hitInfo == null || hitInfo.Initiator == null) return;
            BasePlayer __attacker = hitInfo.Initiator.GetComponent<BasePlayer>();
            if (!__attacker) return;
            if (covertPlayerList.ContainsKey(__attacker.UserIDString))
            {
                __attacker.userID = covertPlayerList[__attacker.UserIDString].__covertID;
                timer.Once(0.2f, () => { if (__attacker != null) __attacker.userID = covertPlayerList[__attacker.UserIDString].__restoreID; });
            }
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            if (covertPlayerList.ContainsKey(player.UserIDString))
                __RenamePlayer(player, covertPlayerList[player.UserIDString].__covertName, true);
        }

        private void __RenamePlayer(BasePlayer player, string __name, bool __startingCovert)
        {
            player.displayName = __name;
            IPlayer _player = covalence.Players.FindPlayerById(player.UserIDString);
            _player.Rename(__name);
            if (disableAdminAbilities)
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, !__startingCovert);
            player.SendNetworkUpdateImmediate();
        }

        private object OnBetterChat(Dictionary<string, object> __data)
        {
            var player = __data["Player"] as IPlayer;
            if (player == null)
                return null;
            if (!covertPlayerList.ContainsKey(player.Id))
                return null;
            rust.BroadcastChat(null, string.Format(msg("format"), covertTextSize, covertTags, covertNameColor, player.Name, __data["Message"]), covertPlayerList[player.Id].__covertID.ToString()); /*  76561198136204161 */
            return false;
        }

        private object OnPlayerChat(ConsoleSystem.Arg arg)
        {
            var __player = arg.Player();
            if (__player == null)
                return null;
            if (!covertPlayerList.ContainsKey(__player.UserIDString)) return null;
            __player.userID = covertPlayerList[__player.UserIDString].__covertID;
            timer.Once(0.2f, () =>
            {
                if (!__player) return;
                if (covertPlayerList.ContainsKey(__player.UserIDString))
                    __player.userID = covertPlayerList[__player.UserIDString].__restoreID;
            });
            return true;
        }

        private object OnUserChat(IPlayer __player, string __message)
        {
            if (covertPlayerList.ContainsKey(__player.Id))
            {
                if (!BetterChat)
                    rust.BroadcastChat(null, string.Format(msg("format"), covertTextSize, covertTags, covertNameColor, __player.Name, __message, covertPlayerList[__player.Id].__covertID.ToString()));
                return true;
            }
            return null;
        }

        private void Unload()
        {
            foreach (var entry in covertPlayerList)
                if (entry.Value.__player.IsConnected)
                    __RenamePlayer(entry.Value.__player, entry.Value.__restoreName, false);
        }

        private string msg(string key, string id = null) => lang.GetMessage(key, this, id);

        #endregion
    }
}

// --- End of file: CovertAdmin.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SkinChanger.cs ---
// --- Original Local Path: SkinChanger.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins {
	[Info("SkinChanger", "rever", "1.0.0")]
	[Description("Меняет скины и имена предметов по их shortname")]
	class SkinChanger : RustPlugin {
		public class ItemRecord {
			[JsonProperty(PropertyName = "Shortname")]
			public string target;

			[JsonProperty(PropertyName = "Новое имя")]
			public string name;

			[JsonProperty(PropertyName = "Новый id скина")]
			public ulong skinid;
		}

		public class Configurarion {
			[JsonProperty(PropertyName = "Список предметов для замены скинов и имени")]
			public List<ItemRecord> items;
		}

		public Configurarion config;

		protected override void LoadDefaultConfig() {
			config = new Configurarion {
				items = new List<ItemRecord> {
					new ItemRecord {
						target = "sticks",
						name   = "Ёлочка",
						skinid = 1351406603
					}
				}
			};
			SaveConfig();
		}

		protected override void SaveConfig() => Config.WriteObject(config);

		private void Loaded() {
			try {
				config = Config.ReadObject<Configurarion>();
			} catch {
				LoadDefaultConfig();
			}
		}

		void OnItemAddedToContainer(ItemContainer container, Item item) {
			if (item == null || item.info == null) return;

			var name = item.info.shortname.ToLower();

			foreach (var configRow in config.items) {
				if (configRow.target.ToLower() != name || configRow.skinid == item.skin) continue;

				item.name = configRow.name;
				item.skin = configRow.skinid;
			}
		}

		void OnItemDropped(Item item, BaseEntity entity) { }
	}
}


// --- End of file: SkinChanger.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HumanitySystem.cs ---
// --- Original Local Path: HumanitySystem.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using UnityEngine;
using System.Linq;
using System.Reflection;

namespace Oxide.Plugins
{
    [Info("Humanity System", "DylanSMR", "1.1.5", ResourceId = 1999)]
    [Description("A humanity system based off of DayZ mod.")]
    public class HumanitySystem : RustPlugin
    {  
        [PluginReference] Plugin BetterChat;

        // / // / // / //
        //Configuration//
        // / // / // / //

        void LoadDefaultConfig()
        {
            PrintWarning("Creating default configuration");
            Config.Clear();
                Config["HumanityLossGainOnKill"] = 50;
                Config["HudPosition"] = 1;
                Config["HeadText"] = false;
            Config.Save();
        }

        // / // / // / //
        //Data System  //
        // / // / // / //

        static HumanityData humanityData;
        public List<ulong> inUI = new List<ulong>();

        class HumanityData
        {
            public Dictionary<ulong, players> playerH = new Dictionary<ulong, players>();
            public HumanityData() { }
        }

        class players
        {
            public ulong playerID;
            public int Humanity;
            public int Rank;
            public int Kills;
            public int Deaths;
            public players() { }

            internal static players Find(BasePlayer player)
            {
                return humanityData.playerH.Values.ToList().Find((d) => d.playerID == player.userID);
            }
        }

        // / // / // / //
        //Public Hooks //
        // / // / // / //

        public string GetMin()
        {
            var quad = Convert.ToInt32(Config["HudPosition"]);
            if(quad == 1) return "0.84 0.98";
            else if(quad == 2) return "0.01 0.98";
            else if(quad == 3) return "0.012 0.38";
            else if(quad == 4) return "0.841 0.42";
            else return "0.84 0.98";
        }

        public string GetMax()
        {
            var quad = Convert.ToInt32(Config["HudPosition"]);
            if(quad == 1) return "0.99 0.700";
            else if(quad == 2) return "0.15 0.700";
            else if(quad == 3) return "0.157 0.10";
            else if(quad == 4) return "0.987 0.14";
            else return "0.99 0.700";
        }

        public object GetRank(BasePlayer player)
        {
            if (players.Find(player) == null) OnPlayerInit(player);
            players playerData = players.Find(player);
            if(playerData.Rank == 0) return "Neutral";
            else if(playerData.Rank == 1) return "Hero";
            else if(playerData.Rank == 2) return "Bandit"; 
            return null;
        }

        public object GetStat(BasePlayer player, string Stat)
        {
            if (players.Find(player) == null) OnPlayerInit(player);
            players playerData = players.Find(player);
            if(Stat == "Kills") return playerData.Kills;
            if(Stat == "Deaths") return playerData.Deaths;
            if(Stat == "Rank") return playerData.Rank;
            if(Stat == "Humanity") return playerData.Humanity;
            return null;
        }

        public object RankAlgorithm(BasePlayer player)
        {
            if(players.Find(player) == null) OnPlayerInit(player);
            players playerData = players.Find(player);
            if(playerData.Humanity <= -2500){
                if(Convert.ToBoolean(BetterChat?.Call("API_IsUserInGroup", player.UserIDString, "Hero")) == true) BetterChat?.Call("API_RemoveUserFromGroup", player.UserIDString, "Hero");
                if(Convert.ToBoolean(BetterChat?.Call("API_IsUserInGroup", player.UserIDString, "Neutral")) == true) BetterChat?.Call("API_RemoveUserFromGroup", player.UserIDString, "Neutral");
                if(Convert.ToBoolean(BetterChat?.Call("API_IsUserInGroup", player.UserIDString, "Bandit")) == true || playerData.Rank == 2) return "Bandit";
                BetterChat?.Call("API_AddUserToGroup", player.UserIDString, "Bandit");             
                humanityData.playerH[player.userID].Rank = 2;
                SendReply(player, lang.GetMessage("NowA", this), "Bandit");     
            }
            else if(playerData.Humanity >= 2500){
                if(Convert.ToBoolean(BetterChat?.Call("API_IsUserInGroup", player.UserIDString, "Bandit"))) BetterChat?.Call("API_RemoveUserFromGroup", player.UserIDString, "Bandit");
                if(Convert.ToBoolean(BetterChat?.Call("API_IsUserInGroup", player.UserIDString, "Neutral"))) BetterChat?.Call("API_RemoveUserFromGroup", player.UserIDString, "Neutral");
                if(Convert.ToBoolean(BetterChat?.Call("API_IsUserInGroup", player.UserIDString, "Hero")) || playerData.Rank == 1) return "Hero";
                BetterChat?.Call("API_AddUserToGroup", player.UserIDString, "Hero");             
                humanityData.playerH[player.userID].Rank = 1;
                SendReply(player, lang.GetMessage("NowA", this), "Hero");     
            }else{
                if(Convert.ToBoolean(BetterChat?.Call("API_IsUserInGroup", player.UserIDString, "Bandit"))) BetterChat?.Call("API_RemoveUserFromGroup", player.UserIDString, "Bandit");
                if(Convert.ToBoolean(BetterChat?.Call("API_IsUserInGroup", player.UserIDString, "Hero"))) BetterChat?.Call("API_RemoveUserFromGroup", player.UserIDString, "Hero");
                if(Convert.ToBoolean(BetterChat?.Call("API_IsUserInGroup", player.UserIDString, "Neutral")) || playerData.Rank == 0) return "Neutral";
                BetterChat?.Call("API_AddUserToGroup", player.UserIDString, "Neutral");             
                humanityData.playerH[player.userID].Rank = 0;
                SendReply(player, lang.GetMessage("NowA", this), "Neutral");     
            }
            SaveData();
            return true;
        }


        public void CreateGroup(string groupName)
        {
            if(Convert.ToBoolean(BetterChat?.Call($"API_GroupExists", groupName))) return; 
            if(Convert.ToBoolean(BetterChat?.Call($"API_AddGroup", groupName))){
                Puts($"Created betterchat group - {groupName}");
                BetterChat?.Call($"API_SetGroupSetting", groupName, "priority", "500");
            }else Puts($"Failed to create group - {groupName}");
        }

        // / // / // / //
        //Save/Load Dat//
        // / // / // / //

        void Unload()
        {
            foreach(var entry in inUI)
            {
                BasePlayer player = BasePlayer.FindByID(entry);
                CuiHelper.DestroyUi(player, "HumanUI");
            }
        }
        
        void Loaded()
        {
            if(Convert.ToBoolean(Config["HeadText"])) CheckDis();
            if(BetterChat){
                Puts("Betterchat function loaded - Attempting to create groups...");
                if(Convert.ToBoolean(BetterChat?.Call($"API_GroupExists", "Hero"))) Puts("Betterchat groups already created...");
                else{
                    Puts("Creating betterchat groups...");
                    CreateGroup("Hero");
                    CreateGroup("Bandit");
                    CreateGroup("Neutral");}    
            }else Puts("Betterchat does not exist in plugins - Betterchat function disabled!");        
            humanityData = Interface.GetMod().DataFileSystem.ReadObject<HumanityData>(this.Title);
            lang.RegisterMessages(messages, this);
        }

        void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(this.Title, humanityData);

        // / // / // / //
        //Language File//
        // / // / // / //

        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"Humanity", "{0}'s Stats: \n Humanity Rank: {1} \n Current Humanity: {2}"},
            {"NowA", "Congratulations! You now have the rank of: {0}"},
            {"Information", "HumanitySystem is the system based off of the DayZ mod humanity. DayZ's humanity system was a way to rank a player based on how they kill and how they interact with other players. \nRanks: \n *Hero(2500+ humanity) \n *Bandit(2500 and less humanity) \n *Neutral(Anything between hero and bandit)"},
        };

        // / // / // / //
        //OnPlayerInit //
        // / // / // / //
        
        void OnPlayerInit(BasePlayer player)
        {
            if(!humanityData.playerH.ContainsKey(player.userID))
            {
                var info = new players()
                {
                    playerID = player.userID,
                    Humanity = 0,
                    Rank = 0
                };
                humanityData.playerH.Add(player.userID, info);
                SaveData();
            }
            RankAlgorithm(player);
        }

        // / // / // / //
        //Chat Commands//
        // / // / // / //

        [ChatCommand("HStatus")] void HumanStat(BasePlayer player) => SendReply(player, lang.GetMessage("Humanity", this), player.displayName, GetRank(player), GetStat(player, "Humanity"));
        [ChatCommand("HInfo")] void HumanInfo(BasePlayer player) => SendReply(player, lang.GetMessage("Information", this));

        // / // / // / //
        //Death Handler//
        // / // / // / //   

        void OnEntityDeath(BaseCombatEntity victimEntity, HitInfo info)
        {
            if (info?.Initiator?.ToPlayer() != null && victimEntity?.ToPlayer() != null)
            {
                BasePlayer victim = victimEntity.ToPlayer();
                BasePlayer attacker = info.Initiator.ToPlayer();
                CuiHelper.DestroyUi(victim, "HumanUI");
                if(victim.userID == attacker.userID) return;

                if (players.Find(victim) == null)
                    OnPlayerInit(victim);

                if (players.Find(attacker) == null)
                    OnPlayerInit(attacker);

                players victimData = players.Find(victim);
                players attackerData = players.Find(attacker);

                victimData.Deaths++;
                attackerData.Kills++;

                if (victimData.Rank == 0 || victimData.Rank == 1)
                {
                    attackerData.Humanity -= Convert.ToInt32(Config["HumanityLossGainOnKill"]);
                    RankAlgorithm(attacker);
                }
                else if (victimData.Rank == 2)
                {
                    attackerData.Humanity += Convert.ToInt32(Config["HumanityLossGainOnKill"]);
                    RankAlgorithm(attacker);
                }
                SaveData();
            }
        }
        // / // / // / //
        //Rank Popup He//
        // / // / // / //

        void CheckDis()
        {
            try 
            {
                foreach(var player in BasePlayer.activePlayerList)
                {
                    BasePlayer nearbyP = null;
                        List<BaseEntity> nearby = new List<BaseEntity>();
                        Vis.Entities(player.transform.position, 20, nearby);
                        foreach (var ent in nearby)               
                            if (ent is BasePlayer)
                                nearbyP = ent.ToPlayer();
                                DrawChatMessage(player, nearbyP);
                }
                timer.Once(1, () => CheckDis());
            }
            catch(System.Exception) { return; }
        }
		void DrawChatMessage(BasePlayer player, BasePlayer nearby)
		{
            try 
            {
                    
                var rank = (string)("["+GetRank(nearby)+"]");
                Color messageColor = new Color(32,32,32,1);
                    
                if(!nearby.IsVisible(player.transform.position)) return;
                nearby.SendConsoleCommand("ddraw.text", 0.1f, messageColor, player.transform.position + new Vector3(0, 1.9f, 0),"<size=25>" + rank + "</size>");
                timer.Repeat(0.3f, 50, () =>
                {
                    nearby.SendConsoleCommand("ddraw.text", 0.1f, messageColor, player.transform.position + new Vector3(0, 1.9f, 0),"<size=25>" + rank + "</size>");
                });
            }
            catch(System.Exception) { return; }
		}

        // / // / // / //
        //CUI Elements //
        // / // / // / // 

        [ChatCommand("hmt")]
        private void RenderUI(BasePlayer player)
        {
            if(inUI.Contains(player.userID))
            {
                CuiHelper.DestroyUi(player, "HumanUI");
                inUI.Remove(player.userID);
                return;
            }
            inUI.Add(player.userID);
            var elements = new CuiElementContainer();
            var mainName = elements.Add(new CuiPanel
            {
                Image =
                {
                    Color = "0 0 0 0.0"
                },
                RectTransform =
                {
                    AnchorMin = GetMin(),
                    AnchorMax = GetMax()
                }
            }, "Hud", "HumanUI");

            FillElements(ref elements, mainName, Convert.ToInt32(GetStat(player, "Humanity")), GetRank(player).ToString(), Convert.ToInt32(GetStat(player, "Kills")), Convert.ToInt32(GetStat(player, "Deaths")));

            CuiHelper.AddUi(player, elements);
        }  

        private void FillElements(ref CuiElementContainer elements, string mainPanel, int humanity, string rank, int kills, int deaths)
        {
            //Color correction//
            var colorCorrection = new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = mainPanel,
                Components =
                        {
                            new CuiImageComponent { Color = "102 102 102 0.1" },
                            new CuiRectTransformComponent{ AnchorMin = "0 1" , AnchorMax = $"1 0"}
                        }
            };
            elements.Add(colorCorrection);
            //Side bars//
            var sideBar1 = new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = mainPanel,
                Components =
                        {
                            new CuiImageComponent { Color = "0.1 0.1 0.1 0.98" },
                            new CuiRectTransformComponent{ AnchorMin = "0 1" , AnchorMax = $"0.03 0"}
                        }
            };
            elements.Add(sideBar1);
            var sideBar2 = new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = mainPanel,
                Components =
                        {
                            new CuiImageComponent { Color = "0.1 0.1 0.1 0.98" },
                            new CuiRectTransformComponent{ AnchorMin = "0.97 1" , AnchorMax = $"1 0"}
                        }
            };
            elements.Add(sideBar2);
            //Top-Bottom bar//
            var topBar1 = new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = mainPanel,
                Components =
                        {
                            new CuiImageComponent { Color = "0.1 0.1 0.1 0.98" },
                            new CuiRectTransformComponent{ AnchorMin = "0 0.03" , AnchorMax = $"1 0"}
                        }
            };
            elements.Add(topBar1);
            var topBar2 = new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = mainPanel,
                Components =
                        {
                            new CuiImageComponent { Color = "0.1 0.1 0.1 0.98" },
                            new CuiRectTransformComponent{ AnchorMin = "0 1" , AnchorMax = $"1 0.97"}
                        }
            };
            elements.Add(topBar2);    
            //Text//
            var humanityText = new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = colorCorrection.Name,
                Components =
                        {
                            new CuiTextComponent { Text = "Humanity Status:", FontSize = 18, Align = TextAnchor.MiddleLeft, Color = "0 0 0" },
                            new CuiRectTransformComponent{ AnchorMin = "0.17 0.73", AnchorMax = $"1 0.95" }
                        }
            };
            elements.Add(humanityText);
            var humanityTText = new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = colorCorrection.Name,
                Components =
                        {
                            new CuiTextComponent { Text = $"Humanity: {humanity}", FontSize = 15, Align = TextAnchor.MiddleLeft, Color = "0 0 0" },
                            new CuiRectTransformComponent{ AnchorMin = "0.05 0.57", AnchorMax = $"1 0.74" }
                        }
            };
            elements.Add(humanityTText);
            var humanityRank = new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = colorCorrection.Name,
                Components =
                        {
                            new CuiTextComponent { Text = $"Rank: {rank}", FontSize = 15, Align = TextAnchor.MiddleLeft, Color = "0 0 0" },
                            new CuiRectTransformComponent{ AnchorMin = "0.05 0.49", AnchorMax = $"1 0.68" }
                        }
            };
            elements.Add(humanityRank);
            var humanityKills = new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = colorCorrection.Name,
                Components =
                        {
                            new CuiTextComponent { Text = $"Kills: {kills}", FontSize = 15, Align = TextAnchor.MiddleLeft, Color = "0 0 0" },
                            new CuiRectTransformComponent{ AnchorMin = "0.05 0.41", AnchorMax = $"1 0.61" }
                        }
            };
            elements.Add(humanityKills);
            var humanityDeaths = new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = colorCorrection.Name,
                Components =
                        {
                            new CuiTextComponent { Text = $"Deaths: {deaths}", FontSize = 15, Align = TextAnchor.MiddleLeft, Color = "0 0 0" },
                            new CuiRectTransformComponent{ AnchorMin = "0.05 0.31", AnchorMax = $"1 0.56" }
                        }
            };
            elements.Add(humanityDeaths);
        }        
    }
}

// --- End of file: HumanitySystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AutoMute.cs ---
// --- Original Local Path: AutoMute.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Oxide.Core;
using Oxide.Core.Configuration;
using UnityEngine;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("AutoMute", "Oxide Россия - oxide-russia.ru", "2.1.11")]
    class AutoMute : CovalencePlugin
    {
        Dictionary<string, int> mutes = new Dictionary<string, int>();
        DynamicConfigFile saveFile = Interface.Oxide.DataFileSystem.GetFile("ChatMutes");

        void OnServerInitialized()
        {
            timer.Every(1f, () =>
            {
                List<string> toRemove = mutes.Keys.ToList().Where(uid => --mutes[uid] < 0).ToList();
                toRemove.ForEach(p => mutes.Remove(p));
            });
            mutes = saveFile.ReadObject<Dictionary<string, int>>();
        }

        private MuteList Chat;
        private class MuteList
        {
            public MuteList(string[] Say, string[] Exclusion, int MuteTime, int AuthLevel, bool AdminBlock)
            {
                this.Слова = Say;
                this.Исключения = Exclusion;
                this.MuteTime = MuteTime;
                this.AdminBlock = AdminBlock;
            }
            [JsonProperty("3. Запрещенные фразы")]
            public string[] Слова { get; set; }
            [JsonProperty("4. Слова-исключения")]
            public string[] Исключения { get; set; }
            [JsonProperty("2. Настройки: Время блокировки чата (сек)")]
            public int MuteTime;
            [JsonProperty("1. Настройки: Блокировать ли администраторов?")]
            public bool AdminBlock;
        }

        void Loaded()
        {
            Chat = Config.ReadObject<MuteList>();
        }
        void Unload()
        {
            saveFile.WriteObject(mutes);
        }
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Благодарим за приобритение плагина на сайте RustPlugin.ru. Если вы приобрели этот плагин на другом ресурсе знайте - это лишает вас гарантированных обновлений!");
            PrintError("Маты и исключения добавлять в /config/AutoMute.json");

            Config.WriteObject(DefaultConfig(), true);
        }
        object OnBetterChat(Dictionary<string, object> data)
        {
            var player = (IPlayer)data["Player"];
            if (mutes.ContainsKey(player.Id))
            {
                return false;
            }
            return null;
        }
        object OnUserChat(IPlayer player, string message)
        {
            bool exclud = true;
            string SteamID = player.Id;
            string Nickname = player.Name;
            BasePlayer bplayer = BasePlayer.FindByID(ulong.Parse(player.Id));
            if (player == null || message == null) return null;
            if (!Chat.AdminBlock)
            {
                if (player.IsAdmin)
                {
                    return null;
                }
            }
            if (mutes.ContainsKey(player.Id))
            {
                player.Command("chat.add", new object[] { "0", $"<color=RED>Чат заблокирован!</color> До окончания: <color=green>{mutes[player.Id]} сек.</color>" });
                return false;
            }
            foreach (var word in Chat.Слова)
            {
                if (message.ToLower().Contains(word))
                {
                    foreach (var exc in Chat.Исключения)
                    {
                        if (message.ToLower().Contains(exc)) { exclud = false; break; }
                    }
                    if (exclud)
                    {
                        Mute(bplayer);
                        ConsoleNetwork.BroadcastToAllClients("chat.add", new object[] { 0, $"Игроку <color=#47ff47>{Nickname}</color> отключен чат! \nДлительность: <color=#47ff47>{Chat.MuteTime} сек.</color>  \nПричина: <color=#47ff47>Нецензурная лексика!</color>" });
                        PrintWarning("Auto mute " + Nickname + "(" + SteamID + $") {mutes[player.Id]}с. Причина: (" + message + ")");
                        LogToFile("log", $"({DateTime.Now.ToShortDateString()}) ({DateTime.Now.ToShortTimeString()}) Игроку {Nickname} ({SteamID}) был отключен чат на {Chat.MuteTime} сек. Сообщение: ({message})", this, false);
                        return false;
                    }
                }
            }
            return null;
        }
        void Mute(BasePlayer player)
        {
            mutes.Add(player.UserIDString, Chat.MuteTime);
        }

        #region DefaultConfig
        private MuteList DefaultConfig()
        {
            string[] Say =
            {
                "бля",
                "еба",
                "аху",
                "впиз",
                "въеб",
                "выбля",
                "выеб",
                "выёб",
                "гнид",
                "гонд",
                "доеб",
                "долбо",
                "дроч",
                "ёб",
                "елд",
                "заеб",
                "заёб",
                "залуп",
                "захуя",
                "заяб",
                "злоеб",
                "ипа",
                "лох",
                "лошар",
                "манд",
                "мля",
                "мраз",
                "муд",
                "наеб",
                "наёб",
                "напизд",
                "нах",
                "нех",
                "нии",
                "обоср",
                "отпиз",
                "отъеб",
                "оху",
                "падл",
                "падон",
                "педр",
                "пез",
                "перд",
                "пид",
                "пиз",
                "подъеб",
                "поеб",
                "поёб",
                "похе",
                "похр",
                "поху",
                "придур",
                "приеб",
                "проеб",
                "разху",
                "разъеб",
                "распиз",
                "соси",
                "спиз",
                "сук",
                "суч",
                "трах",
                "ублю",
                "уеб",
                "уёб",
                "ху",
                "целка",
                "чмо",
                "шалав",
                "шлюх",
                "ска"
            };
            string[] Ex =
            {
                  "мандар",
                  "мудр",
                  "наха",
                  "нахо",
                  "нахл",
                  "нехо",
                  "нехв",
                  "неха",
                  "пидж",
                  "похуд",
                  "сосиск",
                  "худ",
                  "хуж",
                  "хут",
                  "хур",
                  "хулиг",
                  "Команда",
                  "команда",
                  "команду",
                  "тебе",
                  "тебя",
                  "скайп",
                  "скайпу",
                  "скайпе",
                  "сказано",
                  "стёб",
                  "стеб"
            };

            return new MuteList(Say, Ex, 120, 2, true);
        }
        #endregion

    }
}


// --- End of file: AutoMute.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NukeWeapons.cs ---
// --- Original Local Path: NukeWeapons.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using UnityEngine;
using System.Linq;
using System.Reflection;
using System.Collections;
using System.IO;
using Rust;

namespace Oxide.Plugins
{
    [Info("NukeWeapons", "k1lly0u", "0.1.5", ResourceId = 2044)]
    class NukeWeapons : RustPlugin
    {
        #region Fields
        [PluginReference] Plugin LustyMap;

        NukeData nukeData;
        ItemNames itemNames;
        private DynamicConfigFile data;        
        private DynamicConfigFile Item_Names;

        static GameObject webObject;
        static UnityWeb uWeb;
        static MethodInfo getFileData = typeof(FileStorage).GetMethod("StorageGet", (BindingFlags.Instance | BindingFlags.NonPublic));

        private static readonly int playerLayer = LayerMask.GetMask("Player (Server)");
        private static readonly Collider[] colBuffer = (Collider[])typeof(Vis).GetField("colBuffer", (BindingFlags.Static | BindingFlags.NonPublic))?.GetValue(null);

        private List<ZoneList> RadiationZones = new List<ZoneList>();

        private Dictionary<ulong, NukeType> activeUsers = new Dictionary<ulong, NukeType>();
        private Dictionary<ulong, Dictionary<NukeType, int>> cachedAmmo = new Dictionary<ulong, Dictionary<NukeType, int>>();
        private Dictionary<ulong, Dictionary<NukeType, double>> craftingTimers = new Dictionary<ulong, Dictionary<NukeType, double>>();

        private List<Timer> nwTimers = new List<Timer>();

        private Dictionary<string, ItemDefinition> ItemDefs;
        private Dictionary<string, string> DisplayNames = new Dictionary<string, string>();

        #endregion

        #region Oxide Hooks
        void Loaded()
        {
            data = Interface.Oxide.DataFileSystem.GetFile("NukeWeapons/nukeweapon_data");
            Item_Names = Interface.Oxide.DataFileSystem.GetFile("NukeWeapons/itemnames");
            Interface.Oxide.DataFileSystem.SaveDatafile("NukeWeapons/Icons/foldercreator");
            lang.RegisterMessages(Messages, this);
            webObject = new GameObject("WebObject");
            uWeb = webObject.AddComponent<UnityWeb>();
            InitializePlugin();
        }
        void OnServerInitialized()
        {
            LoadVariables();
            LoadData();
            ItemDefs = ItemManager.itemList.ToDictionary(i => i.shortname);
            if (itemNames.DisplayNames == null || itemNames.DisplayNames.Count < 1)
            {
                foreach (var item in ItemDefs)
                {
                    if (!DisplayNames.ContainsKey(item.Key))
                        DisplayNames.Add(item.Key, item.Value.displayName.translated);
                }
                SaveDisplayNames();
            }
            else DisplayNames = itemNames.DisplayNames;
            
            FindAllMines();
        }
        void Unload()
        {
            for (int i = 0; i < RadiationZones.Count; i++)
            {
                RadiationZones[i].time.Destroy();
                UnityEngine.Object.Destroy(RadiationZones[i].zone);
            }
            RadiationZones.Clear();
            foreach(var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, UIMain);
                CuiHelper.DestroyUi(player, UIPanel);
                DestroyIconUI(player);
                DestroyCraftUI(player);
            }
            foreach (var time in nwTimers)
                time.Destroy();
            SaveData();         
        }
        void OnPlayerDisconnected(BasePlayer player)
        {
            if (activeUsers.ContainsKey(player.userID))
                activeUsers.Remove(player.userID);
            CuiHelper.DestroyUi(player, UIMain);
            CuiHelper.DestroyUi(player, UIPanel);
            DestroyIconUI(player);
            DestroyCraftUI(player);
        }
        void OnEntityDeath(BaseEntity entity, HitInfo hitinfo)
        {
            if (entity is BasePlayer)
            {
                var player = entity.ToPlayer();
                if (activeUsers.ContainsKey(player.userID))
                    activeUsers.Remove(player.userID);
                CuiHelper.DestroyUi(player, UIMain);
                CuiHelper.DestroyUi(player, UIPanel);
                DestroyIconUI(player);
                //DestroyCraftUI(player);
            }            
        }
        void OnRocketLaunched(BasePlayer player, BaseEntity entity)
        {
            if (activeUsers.ContainsKey(player.userID) && activeUsers[player.userID] == NukeType.Rocket)
            {
                if (hasUnlimited(player) || HasAmmo(player.userID, NukeType.Rocket))
                {
                    if (!hasUnlimited(player))
                    {
                        string itemname = "ammo.rocket.basic";
                        switch (entity.ShortPrefabName)
                        {
                            case "calledrocket_hv":
                                itemname = "ammo.rocket.hv";
                                break;
                            case "calledrocket_fire":
                                itemname = "ammo.rocket.fire";
                                break;
                            default:
                                break;
                        }
                        player.inventory.containerMain.AddItem(ItemDefs[itemname], 1);
                        cachedAmmo[player.userID][NukeType.Rocket]--;
                    }
                    entity.gameObject.AddComponent<Nuke>().InitializeComponent(this, NukeType.Rocket, configData.Rockets.RadiationProperties);
                }
                else
                {
                    activeUsers.Remove(player.userID);
                    SendMSG(player, $"{MSG("OOA", player.UserIDString)} {MSG("Rockets", player.UserIDString)}");
                }
                CreateAmmoIcons(player);
            }
        }
        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity is Landmine)
            {
                var mine = entity as Landmine;
                if (activeUsers.ContainsKey(mine.OwnerID) && activeUsers[mine.OwnerID] == NukeType.Mine)
                {
                    var player = BasePlayer.FindByID(mine.OwnerID);
                    if (player != null)
                    {
                        if (hasUnlimited(player) || HasAmmo(player.userID, NukeType.Mine))
                        {
                            if (!hasUnlimited(player))
                            {
                                player.inventory.containerMain.AddItem(ItemDefs["trap.landmine"], 1);
                                cachedAmmo[player.userID][NukeType.Mine]--;
                            }
                            mine.gameObject.AddComponent<Nuke>().InitializeComponent(this, NukeType.Mine, configData.Mines.RadiationProperties);
                            nukeData.Mines.Add(entity.net.ID);
                        }
                        else
                        {
                            activeUsers.Remove(player.userID);
                            SendMSG(player, $"{MSG("OOA", player.UserIDString)} {MSG("Mines", player.UserIDString)}");
                        }
                        CreateAmmoIcons(player);
                    }                 
                }
            }
        }
        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity is Landmine)
            {                
                if (nukeData.Mines.Contains(entity.net.ID))
                {
                    nukeData.Mines.Remove(entity.net.ID);
                }
            }
        }
        void OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            if (activeUsers.ContainsKey(attacker.userID) && activeUsers[attacker.userID] == NukeType.Bullet)
            {
                if (!string.IsNullOrEmpty(info?.Weapon?.GetEntity()?.GetComponent<BaseProjectile>()?.primaryMagazine?.ammoType?.shortname))
                {
                    var ammo = info?.Weapon?.GetEntity()?.GetComponent<BaseProjectile>()?.primaryMagazine?.ammoType?.shortname;
                    if (!string.IsNullOrEmpty(ammo) && ammo.Contains("ammo.rifle"))
                    {
                        var hitPos = info.HitPositionWorld;
                        if (hitPos != null)
                        {
                            var radVar = configData.Bullets.RadiationProperties;
                            if (hasUnlimited(attacker) || HasAmmo(attacker.userID, NukeType.Bullet))
                            {
                                if (!hasUnlimited(attacker))
                                {
                                    attacker.inventory.containerMain.AddItem(ItemDefs[ammo], 1);
                                    cachedAmmo[attacker.userID][NukeType.Bullet]--;
                                }
                                InitializeZone(hitPos, radVar.Intensity, radVar.Duration, radVar.Radius, false);
                            }
                            else
                            {
                                activeUsers.Remove(attacker.userID);
                                SendMSG(attacker, $"{MSG("OOA", attacker.UserIDString)} {MSG("Bullets", attacker.UserIDString)}");
                            }
                            CreateAmmoIcons(attacker);
                        }
                    }
                }                
            }
        }
        void OnExplosiveThrown(BasePlayer player, BaseEntity entity)
        {
            if (entity.ShortPrefabName.Contains("explosive.timed"))
            {
                if (activeUsers.ContainsKey(player.userID) && activeUsers[player.userID] == NukeType.Explosive)
                {
                    if (hasUnlimited(player) || HasAmmo(player.userID, NukeType.Explosive))
                    {
                        if (!hasUnlimited(player))
                        {
                            player.inventory.containerMain.AddItem(ItemDefs["explosive.timed"], 1);
                            cachedAmmo[player.userID][NukeType.Explosive]--;
                        }
                        entity.gameObject.AddComponent<Nuke>().InitializeComponent(this, NukeType.Explosive, configData.Explosives.RadiationProperties);                        
                    }
                    else
                    {
                        activeUsers.Remove(player.userID);
                        SendMSG(player, $"{MSG("OOA", player.UserIDString)} {MSG("Explosives", player.UserIDString)}");
                    }
                    CreateAmmoIcons(player);
                }
            }
            if (entity.ShortPrefabName.Contains("grenade.f1"))
            {
                if (activeUsers.ContainsKey(player.userID) && activeUsers[player.userID] == NukeType.Grenade)
                {
                    if (hasUnlimited(player) || HasAmmo(player.userID, NukeType.Grenade))
                    {
                        if (!hasUnlimited(player))
                        {
                            player.inventory.containerMain.AddItem(ItemDefs["grenade.f1"], 1);
                            cachedAmmo[player.userID][NukeType.Grenade]--;
                        }
                        entity.gameObject.AddComponent<Nuke>().InitializeComponent(this, NukeType.Explosive, configData.Grenades.RadiationProperties);                        
                    }
                    else
                    {
                        activeUsers.Remove(player.userID);
                        SendMSG(player, $"{MSG("OOA", player.UserIDString)} {MSG("Grenades", player.UserIDString)}");
                    }
                    CreateAmmoIcons(player);
                }
            }
        }
        #endregion

        #region Helpers
        private bool HasEnoughRes(BasePlayer player, int itemid, int amount) => player.inventory.GetAmount(itemid) >= amount;
        private void TakeResources(BasePlayer player, int itemid, int amount) => player.inventory.Take(null, itemid, amount);
        static double GrabCurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;
        private bool IsType(BasePlayer player, NukeType type) => activeUsers.ContainsKey(player.userID) && activeUsers[player.userID] == type;
        #endregion

        #region Functions
        private void FindAllMines()
        {
            var mineList = new Dictionary<uint, Landmine>();
            var allobjects = UnityEngine.Object.FindObjectsOfType<GameObject>();
            foreach (var gobject in allobjects)
            {
                if (gobject.GetComponent<Landmine>())
                {
                    var mine = gobject.GetComponent<Landmine>();
                    if (!mineList.ContainsKey(mine.net.ID))
                        mineList.Add(mine.net.ID, mine);
                }
            }
            foreach (var entry in nukeData.Mines)
            {                
                if (mineList.ContainsKey(entry))
                {
                    mineList[entry].gameObject.AddComponent<Nuke>().InitializeComponent(this, NukeType.Mine, configData.Mines.RadiationProperties);
                }                
            }            
        }
        private bool CanCraft(BasePlayer player, NukeType type)
        {
            var ingredients = GetCraftingComponents(type);
            foreach (var item in ingredients)
            {
                if (HasEnoughRes(player, ItemDefs[item.Key].itemid, item.Value))
                    continue;
                else return false;
            }
            return true;
        }
        private bool AlreadyCrafting(BasePlayer player, NukeType type)
        {
            if (craftingTimers.ContainsKey(player.userID))
            {
                if (craftingTimers[player.userID].ContainsKey(type))
                {
                    if (craftingTimers[player.userID][type] > GrabCurrentTime())
                        return true;
                }
            }
            return false;
        }
        private string CraftTimeClock(BasePlayer player, NukeType type)
        {
            if (player == null) return null;
            TimeSpan dateDifference = TimeSpan.FromSeconds(craftingTimers[player.userID][type] - GrabCurrentTime());            
            var mins = dateDifference.Minutes;
            var secs = dateDifference.Seconds;
            return string.Format("{0:00}:{1:00}", mins, secs);
        }
        private void StartCrafting(BasePlayer player, NukeType type)
        {
            var config = GetConfigFromType(type);
            var ingredients = GetCraftingComponents(type);
            foreach (var ing in ingredients)            
                TakeResources(player, ItemDefs[ing.Key].itemid, ing.Value);

            bool finished = FinishedCrafting(player);
            craftingTimers[player.userID][type] = GrabCurrentTime() + config.CraftTime;            
            CraftingElement(player, type);
            if (finished)
                CreateCraftTimer(player);
        }
        private void FinishCraftingItems(BasePlayer player, NukeType type)
        {
             var config = GetConfigFromType(type);  
                     
            cachedAmmo[player.userID][type] += config.CraftAmount;

            if (activeUsers.ContainsKey(player.userID))
                CreateAmmoIcons(player);
        }
        private bool FinishedCrafting(BasePlayer player)
        {
            if (!craftingTimers.ContainsKey(player.userID))
            {
                CheckPlayerEntry(player);
                return true;
            }
            bool finished = true;
            foreach (var craft in craftingTimers[player.userID])
            {
                if (craft.Value != -1)
                {
                    finished = false;
                    break;
                }
            }
            return finished;
        }
        #endregion

        #region External Calls        
        private void CloseMap(BasePlayer player)
        {
            if (LustyMap)
            {
                LustyMap.Call("DisableMaps", player);
            }
        }
        private void OpenMap(BasePlayer player)
        {
            if (LustyMap)
            {
                LustyMap.Call("EnableMaps", player);
            }
        }        
        #endregion

        #region UI Creation
        class NWUI
        {
            static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor = false, string parent = "Overlay")
            {
                var NewElement = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = color},
                        RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                        CursorEnabled = cursor
                    },
                    new CuiElement().Parent = parent,
                    panelName
                }
            };
                return NewElement;
            }
            static public void CreatePanel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel);
            }
            static public void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter, float fadein = 0f)
            {
                
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = fadein, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);

            }
            static public void CreateButton(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter, float fadein = 0f)
            {
               
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = fadein },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel);
            }
            static public void LoadImage(ref CuiElementContainer container, string panel, string png, string aMin, string aMax)
            {
                container.Add(new CuiElement
                {
                    Parent = panel,
                    Components =
                    {
                        new CuiRawImageComponent {Png = png, Sprite = "assets/content/textures/generic/fulltransparent.tga" },
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax }
                    }
                });
            }            
            public static string CreateTextOverlay(ref CuiElementContainer container, string panelName, string textcolor, string text, int size, string distance, string olcolor, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                string name = CuiHelper.GetGuid();
                container.Add(new CuiElement
                {
                    Name = name,
                    Parent = panelName,
                    Components =
                        {
                            new CuiTextComponent { Color = textcolor, Text = text, FontSize = size, Align = align},
                            new CuiOutlineComponent { Distance = distance, Color = olcolor },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = aMin,
                                AnchorMax = aMax
                            }
                        }
                });
                return name;
            }
        }

        #region Colors
        private Dictionary<string, string> UIColors = new Dictionary<string, string>
        {
            {"dark", "0.1 0.1 0.1 0.98" },
            {"light", "0.7 0.7 0.7 0.3" },
            {"grey1", "0.6 0.6 0.6 1.0" },
            {"buttonbg", "0.2 0.2 0.2 0.7" },
            {"buttonopen", "0.2 0.8 0.2 0.9" },
            {"buttoncompleted", "0 0.5 0.1 0.9" },
            {"buttonred", "0.85 0 0.35 0.9" },
            {"buttongrey", "0.8 0.8 0.8 0.9" },
            {"grey8", "0.8 0.8 0.8 1.0" }
        };
        #endregion
        #endregion

        #region NW UI
        static string UIMain = "NWUIMain";
        static string UIPanel = "NWUIPanel";
        static string UIEntry = "NWUIEntry";
        static string UIIcon = "NWUIIcon";
        
        private void OpenCraftingMenu(BasePlayer player)
        {
            CloseMap(player);
            var Selector = NWUI.CreateElementContainer(UIMain, UIColors["dark"], "0 0.92", "1 1");
            NWUI.CreatePanel(ref Selector, UIMain, UIColors["light"], "0.01 0.05", "0.99 0.95", true);
            NWUI.CreateLabel(ref Selector, UIMain, "", $"{configData.Options.MSG_MainColor}{Title}</color>", 30, "0.05 0", "0.2 1");

            int number = 0;
            if (configData.Bullets.Enabled && canBullet(player)) { CreateMenuButton(ref Selector, UIMain, MSG("Bullets", player.UserIDString), "NWUI_ChangeElement bullets", number); number++; }
            if (configData.Explosives.Enabled && canExplosive(player)) { CreateMenuButton(ref Selector, UIMain, MSG("Explosives", player.UserIDString), "NWUI_ChangeElement explosives", number); number++; }
            if (configData.Grenades.Enabled && canGrenade(player)) { CreateMenuButton(ref Selector, UIMain, MSG("Grenades", player.UserIDString), "NWUI_ChangeElement grenades", number); number++; }
            if (configData.Mines.Enabled && canMine(player)) { CreateMenuButton(ref Selector, UIMain, MSG("Mines", player.UserIDString), "NWUI_ChangeElement mines", number); number++; }
            if (configData.Rockets.Enabled && canRocket(player)) { CreateMenuButton(ref Selector, UIMain, MSG("Rockets", player.UserIDString), "NWUI_ChangeElement rockets", number); number++; }
            CreateMenuButton(ref Selector, UIMain, MSG("Close", player.UserIDString), "NWUI_DestroyAll", number);
            CuiHelper.AddUi(player, Selector);
        }
        private void CraftingElement(BasePlayer player, NukeType type)
        {            
            var Main = NWUI.CreateElementContainer(UIPanel, UIColors["dark"], "0 0", "1 0.92");
            NWUI.CreatePanel(ref Main, UIPanel, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            if (nukeData.ImageIDs.ContainsKey("Background"))
            NWUI.LoadImage(ref Main, UIPanel, nukeData.ImageIDs["Background"].ToString(), "0.01 0.02", "0.99 0.98");         

            NWUI.CreateLabel(ref Main, UIPanel, "", $"{configData.Options.MSG_MainColor}{MSG("Required Ingredients", player.UserIDString)}</color>", 20, "0.1 0.85", "0.55 0.95");
            NWUI.CreateLabel(ref Main, UIPanel, "", MSG("Item Name", player.UserIDString), 16, "0.1 0.75", "0.3 0.85", TextAnchor.MiddleLeft);
            NWUI.CreateLabel(ref Main, UIPanel, "", MSG("Required Amount", player.UserIDString), 16, "0.3 0.75", "0.42 0.85");
            NWUI.CreateLabel(ref Main, UIPanel, "", MSG("Your Supply", player.UserIDString), 16, "0.42 0.75", "0.54 0.85");

            
            var ingredients = GetCraftingComponents(type);
            int i = 0;
            foreach(var item in ingredients)
            {
                var itemInfo = ItemDefs[item.Key];
                var plyrAmount = player.inventory.GetAmount(itemInfo.itemid);                
                CreateIngredientEntry(ref Main, UIPanel, DisplayNames[itemInfo.shortname], item.Value, plyrAmount, i);
                i++;
            }
            var config = GetConfigFromType(type);
            string command = null;            
            string text = $"{MSG("Craft", player.UserIDString)} {config.CraftAmount}x";
            if (CanCraft(player, type)) command = $"NWUI_Craft {type.ToString()}";
            if (cachedAmmo[player.userID][type] >= config.MaxAllowed)
            {
                text = MSG("Limit Reached", player.UserIDString);
                command = null;
            }
            if (AlreadyCrafting(player, type))
            {
                text = MSG("Crafting...", player.UserIDString);
                command = null;                
            }
            if (hasUnlimited(player))
            {
                text = MSG("Unlimited", player.UserIDString);
                command = null;
            }

            NWUI.CreateLabel(ref Main, UIPanel, "", $"{configData.Options.MSG_MainColor}{MSG("Inventory Amount", player.UserIDString)}</color>", 20, "0.6 0.85", "0.9 0.95");
            if (hasUnlimited(player))
                NWUI.CreateLabel(ref Main, UIPanel, "", $"~ / {config.MaxAllowed}", 16, "0.6 0.75", "0.9 0.85");
            else NWUI.CreateLabel(ref Main, UIPanel, "", $"{cachedAmmo[player.userID][type]} / {config.MaxAllowed}", 16, "0.6 0.75", "0.9 0.85");
            NWUI.CreateButton(ref Main, UIPanel, UIColors["buttonbg"], text, 16, $"0.6 0.65", $"0.74 0.72", command);
            if (cachedAmmo[player.userID][type] > 0 || hasUnlimited(player))
            {
                if (IsType(player, type))
                    NWUI.CreateButton(ref Main, UIPanel, UIColors["buttonbg"], MSG("Disarm", player.UserIDString), 16, $"0.76 0.65", $"0.9 0.72", $"NWUI_DeactivateMenu {type.ToString()}");
                else NWUI.CreateButton(ref Main, UIPanel, UIColors["buttonbg"], MSG("Arm", player.UserIDString), 16, $"0.76 0.65", $"0.9 0.72", $"NWUI_Activate {type.ToString()}");
            }
            CuiHelper.DestroyUi(player, UIPanel);
            CuiHelper.AddUi(player, Main);
        }
        private void CreateCraftTimer(BasePlayer player)
        {               
            var Main = NWUI.CreateElementContainer(UIEntry, "0 0 0 0", "0.2 0.11", "0.8 0.15");
            var CraftingMessage = "";
            var FinishedTypes = new List<NukeType>();

            foreach(var craft in craftingTimers[player.userID])
            {
                if (craft.Value == -1)
                    continue;                
                else if (craft.Value <= GrabCurrentTime())                
                    FinishedTypes.Add(craft.Key); 
                else                
                    CraftingMessage += $"{craft.Key.ToString()}: {configData.Options.MSG_MainColor}{CraftTimeClock(player, craft.Key)}</color>     ";                              
            }

            foreach(var type in FinishedTypes)
            {
                craftingTimers[player.userID][type] = -1;
                FinishCraftingItems(player, type);
            }

            if (string.IsNullOrEmpty(CraftingMessage))
            {
                DestroyCraftUI(player);
                return;
            }
            else CraftingMessage = $"{configData.Options.MSG_MainColor}{MSG("Crafting", player.UserIDString)} ::: </color> " + CraftingMessage;

            NWUI.CreateLabel(ref Main, UIEntry, "", CraftingMessage, 16, $"0 0", $"1 1", TextAnchor.MiddleRight, 0f);
            CuiHelper.DestroyUi(player, UIEntry);
            CuiHelper.AddUi(player, Main);
            timer.Once(1, () => CreateCraftTimer(player));
        }
        private void CreateIngredientEntry(ref CuiElementContainer container, string panel, string name, int amountreq, int plyrhas, int number)
        {
            Vector2 position = new Vector2(0.1f, 0.68f);
            Vector2 dimensions = new Vector2(0.4f, 0.06f);
            float offsetY = (0.004f + dimensions.y) * number;
            Vector2 offset = new Vector2(0, offsetY);
            Vector2 posMin = position - offset;
            Vector2 posMax = posMin + dimensions;
            string color;
            if (amountreq > plyrhas)
                color = "<color=red>";
            else color = configData.Options.MSG_MainColor;

            NWUI.CreateLabel(ref container, panel, "", $"{configData.Options.MSG_MainColor}{name}</color>", 16, $"{posMin.x} {posMin.y}", $"{posMin.x + 0.2f} {posMax.y}", TextAnchor.MiddleLeft);
            NWUI.CreateLabel(ref container, panel, "", $"{amountreq}", 16, $"{posMin.x + 0.2f} {posMin.y}", $"{posMin.x + 0.32f} {posMax.y}");
            NWUI.CreateLabel(ref container, panel, "", $"{color}{plyrhas}</color>", 16, $"{posMin.x + 0.32f} {posMin.y}", $"{posMin.x + 0.44f} {posMax.y}");
                       
        }
        private void CreateAmmoIcons(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, UIMain);
            CuiHelper.DestroyUi(player, UIPanel);

            if (cachedAmmo.ContainsKey(player.userID))
            {
                DestroyIconUI(player);
                int i = 0;
                if (canBullet(player))
                {
                    if (cachedAmmo[player.userID][NukeType.Bullet] > 0 || hasUnlimited(player))
                    {
                        AmmoIcon(player, NukeType.Bullet, i); i++;
                    }
                }
                if (canExplosive(player))
                {
                    if (cachedAmmo[player.userID][NukeType.Explosive] > 0 || hasUnlimited(player))
                    {
                        AmmoIcon(player, NukeType.Explosive, i); i++;
                    }
                }
                if (canGrenade(player))
                {
                    if (cachedAmmo[player.userID][NukeType.Grenade] > 0 || hasUnlimited(player))
                    {
                        AmmoIcon(player, NukeType.Grenade, i); i++;
                    }
                }
                if (canMine(player))
                {
                    if (cachedAmmo[player.userID][NukeType.Mine] > 0 || hasUnlimited(player))
                    {
                        AmmoIcon(player, NukeType.Mine, i); i++;
                    }
                }
                if (canRocket(player))
                {
                    if (cachedAmmo[player.userID][NukeType.Rocket] > 0 || hasUnlimited(player))
                    {
                        AmmoIcon(player, NukeType.Rocket, i); i++;
                    }
                }
                AddButtons(player, i);
            }
        }
        private void AmmoIcon(BasePlayer player, NukeType type, int number)
        {      
            Vector2 position = new Vector2(0.92f, 0.2f);
            Vector2 dimensions = new Vector2(0.07f, 0.12f);
            Vector2 offset = new Vector2(0, (0.01f + dimensions.y) * number);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;

            string panelName = UIIcon + type.ToString();
            
            var Main = NWUI.CreateElementContainer(panelName, "0 0 0 0", $"{posMin.x} {posMin.y}", $"{posMax.x} {posMax.y}", false, "Hud");

            var image = nukeData.ImageIDs[$"{type.ToString()}"].ToString();
            if (IsType(player, type))
                image = nukeData.ImageIDs[$"{type.ToString()}Active"].ToString();
            NWUI.LoadImage(ref Main, panelName, image, "0 0", "1 1");

            string amount;
            if (hasUnlimited(player))
                amount = "~";
            else amount = cachedAmmo[player.userID][type].ToString();
            NWUI.CreateTextOverlay(ref Main, panelName, "", $"{amount}", 30, "2 2", "0 0 0 1", "0 0", "1 1", TextAnchor.LowerCenter);

            if (IsType(player, type))
                NWUI.CreateButton(ref Main, panelName, "0 0 0 0", "", 20, "0 0", "1 1", "NWUI_DeactivateButton");
            else NWUI.CreateButton(ref Main, panelName, "0 0 0 0", "", 20, "0 0", "1 1", $"NWUI_Activate {type.ToString()}");
            
            CuiHelper.AddUi(player, Main);
        }  
        
        private void AddButtons(BasePlayer player, int number)
        {
            Vector2 position = new Vector2(0.92f, 0.2f);
            Vector2 dimensions = new Vector2(0.07f, 0.12f);
            Vector2 offset = new Vector2(0, (0.01f + dimensions.y) * number);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            var Main = NWUI.CreateElementContainer(UIIcon, "0 0 0 0", $"{posMin.x} {posMin.y}", $"{posMax.x} {posMin.y + 0.1}", false, "Hud");
            NWUI.CreateButton(ref Main, UIIcon, UIColors["buttonbg"], MSG("Menu",player.UserIDString), 16, "0 0.55", "1 1", "NWUI_OpenMenu");
            NWUI.CreateButton(ref Main, UIIcon, UIColors["buttonbg"], MSG("Deactivate", player.UserIDString), 16, "0 0", "1 0.45", "NWUI_DeactivateIcons");
            CuiHelper.DestroyUi(player, UIIcon);
            CuiHelper.AddUi(player, Main);
        }   
        
        #region UI Functions
        private void CreateMenuButton(ref CuiElementContainer container, string panelName, string buttonname, string command, int number)
        {
            Vector2 dimensions = new Vector2(0.1f, 0.6f);
            Vector2 origin = new Vector2(0.25f, 0.2f);
            Vector2 offset = new Vector2((0.01f + dimensions.x) * number, 0);

            Vector2 posMin = origin + offset;
            Vector2 posMax = posMin + dimensions;

            NWUI.CreateButton(ref container, panelName, UIColors["buttonbg"], buttonname, 16, $"{posMin.x} {posMin.y}", $"{posMax.x} {posMax.y}", command);
        }                
        #endregion
        #region UI Commands
        [ConsoleCommand("NWUI_Craft")]
        private void cmdNWCraft(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            var nukeType = arg.GetString(0);            
            switch (nukeType.ToLower())
            {
                case "bullet":
                    StartCrafting(player, NukeType.Bullet);
                    return;
                case "explosive":
                    StartCrafting(player, NukeType.Explosive);
                    return;
                case "grenade":
                    StartCrafting(player, NukeType.Grenade);
                    return;
                case "mine":
                    StartCrafting(player, NukeType.Mine);
                    return;
                case "rocket":
                    StartCrafting(player, NukeType.Rocket);
                    return;
            }
        }
        [ConsoleCommand("NWUI_DeactivateMenu")]
        private void cmdNWDeActivate(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            activeUsers.Remove(player.userID);
            var nukeType = arg.GetString(0);            
            switch (nukeType.ToLower())
            {
                case "bullet":
                    CraftingElement(player, NukeType.Bullet);
                    return;
                case "explosive":
                    CraftingElement(player, NukeType.Explosive);
                    return;
                case "grenade":
                    CraftingElement(player, NukeType.Grenade);
                    return;
                case "mine":
                    CraftingElement(player, NukeType.Mine);
                    return;
                case "rocket":
                    CraftingElement(player, NukeType.Rocket);
                    return;
            }
        }
        [ConsoleCommand("NWUI_DeactivateButton")]
        private void cmdNWDeActivateButton(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            activeUsers.Remove(player.userID);
            CreateAmmoIcons(player);       
        }
        [ConsoleCommand("NWUI_DeactivateIcons")]
        private void cmdNWDeactivateIcons(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            activeUsers.Remove(player.userID);
            DestroyIconUI(player);
        }
        [ConsoleCommand("NWUI_OpenMenu")]
        private void cmdNWOpenMenu(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;           
            
            if (canRocket(player) || canBullet(player) || canMine(player) || canGrenade(player) || canExplosive(player) || canAll(player))
            {
                CloseMap(player);
                CheckPlayerEntry(player);
                OpenCraftingMenu(player);
            }
        }
        [ConsoleCommand("NWUI_Activate")]
        private void cmdNWActivate(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            var nukeType = arg.GetString(0);
            if (!activeUsers.ContainsKey(player.userID))
                activeUsers.Add(player.userID, NukeType.Bullet);
            SendMSG(player, MSG("activated", player.UserIDString).Replace("<type>", nukeType.ToString()));
            switch (nukeType.ToLower())
            {
                case "bullet":
                    activeUsers[player.userID] = NukeType.Bullet;
                    break;
                case "explosive":
                    activeUsers[player.userID] = NukeType.Explosive;
                    break;
                case "grenade":
                    activeUsers[player.userID] = NukeType.Grenade;
                    break;
                case "mine":
                    activeUsers[player.userID] = NukeType.Mine;
                    break;
                case "rocket":
                    activeUsers[player.userID] = NukeType.Rocket;
                    break;
            }
            CreateAmmoIcons(player);
        }
        [ConsoleCommand("NWUI_ChangeElement")]
        private void cmdNWChangeElement(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            var panelName = arg.GetString(0);
            switch (panelName)
            {
                case "bullets":
                    CraftingElement(player, NukeType.Bullet);
                    return;
                case "explosives":
                    CraftingElement(player, NukeType.Explosive);
                    return;
                case "grenades":
                    CraftingElement(player, NukeType.Grenade);
                    return;
                case "mines":
                    CraftingElement(player, NukeType.Mine);
                    return;
                case "rockets":
                    CraftingElement(player, NukeType.Rocket);
                    return;
            }
        }

        [ConsoleCommand("NWUI_DestroyAll")]
        private void cmdNWDestroyAll(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            OpenMap(player);
            CuiHelper.DestroyUi(player, UIMain);
            CuiHelper.DestroyUi(player, UIPanel);            
        }
        void DestroyCraftUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, UIEntry);            
        }
        void DestroyIconUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, UIIcon + "Bullet");
            CuiHelper.DestroyUi(player, UIIcon + "Rocket");
            CuiHelper.DestroyUi(player, UIIcon + "Explosive");
            CuiHelper.DestroyUi(player, UIIcon + "Grenade");
            CuiHelper.DestroyUi(player, UIIcon + "Mine");
            CuiHelper.DestroyUi(player, UIIcon);
        }
        #endregion
        #endregion

        #region Functions
        private void InitializePlugin()
        {
            lang.RegisterMessages(Messages, this);
            permission.RegisterPermission("nukeweapons.rocket", this);
            permission.RegisterPermission("nukeweapons.bullet", this);
            permission.RegisterPermission("nukeweapons.mine", this);
            permission.RegisterPermission("nukeweapons.explosive", this);
            permission.RegisterPermission("nukeweapons.grenade", this);
            permission.RegisterPermission("nukeweapons.all", this);
            permission.RegisterPermission("nukeweapons.unlimited", this);
        }
        private bool HasAmmo(ulong player, NukeType type)
        {            
            if (cachedAmmo.ContainsKey(player))
            {
                if (cachedAmmo[player][type] > 0)
                    return true;
            }
            return false;
        }
        private Dictionary<string, int> GetCraftingComponents(NukeType type)
        {
            switch (type)
            {
                case NukeType.Mine:
                    return configData.Mines.CraftingCosts;
                case NukeType.Rocket:
                    return configData.Rockets.CraftingCosts;
                case NukeType.Bullet:
                    return configData.Bullets.CraftingCosts;
                case NukeType.Explosive:
                    return configData.Explosives.CraftingCosts;
                case NukeType.Grenade:
                    return configData.Grenades.CraftingCosts;
                default:
                    return null;
            }
        }
        private NWType GetConfigFromType(NukeType type)
        {
            switch (type)
            {
                case NukeType.Mine:
                    return configData.Mines;
                case NukeType.Rocket:
                    return configData.Rockets;
                case NukeType.Bullet:
                    return configData.Bullets;
                case NukeType.Explosive:
                    return configData.Explosives;
                case NukeType.Grenade:
                    return configData.Grenades;
                default:
                    return null;
            }
        }
        private void CheckPlayerEntry(BasePlayer player)
        {
            if (!cachedAmmo.ContainsKey(player.userID))
            {
                cachedAmmo.Add(player.userID, new Dictionary<NukeType, int>
                {
                    {NukeType.Bullet, 0 },
                    {NukeType.Explosive, 0 },
                    {NukeType.Grenade, 0 },
                    {NukeType.Mine, 0 },
                    {NukeType.Rocket, 0 },
                });
            }
            if (!craftingTimers.ContainsKey(player.userID))
                craftingTimers.Add(player.userID, new Dictionary<NukeType, double>
                {
                    {NukeType.Bullet, -1 },
                    {NukeType.Explosive, -1 },
                    {NukeType.Grenade, -1 },
                    {NukeType.Mine, -1 },
                    {NukeType.Rocket, -1 },
                });
        }
        #endregion

        #region Radiation Control
        private void InitializeZone(Vector3 Location, float intensity, float duration, float radius, bool explosionType = false)
        {
            if (!ConVar.Server.radiation)
                ConVar.Server.radiation = true;
            if (explosionType) Effect.server.Run("assets/prefabs/tools/c4/effects/c4_explosion.prefab", Location);
            else Effect.server.Run("assets/prefabs/npc/patrol helicopter/effects/rocket_explosion.prefab", Location);

            var newZone = new GameObject().AddComponent<RadZones>();
            newZone.Activate(Location, radius, intensity);

            var listEntry = new ZoneList { zone = newZone };
            listEntry.time = timer.Once(duration, () => DestroyZone(listEntry));

            RadiationZones.Add(listEntry);
        }
        private void DestroyZone(ZoneList zone)
        {
            if (RadiationZones.Contains(zone))
            {
                var index = RadiationZones.FindIndex(a => a.zone == zone.zone);
                RadiationZones[index].time.Destroy();
                UnityEngine.Object.Destroy(RadiationZones[index].zone);
                RadiationZones.Remove(zone);
            }            
        }
        class Nuke : MonoBehaviour
        {
            public NukeWeapons instance;
            public NukeType type;
            public RadiationStats stats;

            private void OnDestroy()
            {
                bool useExplosion = false;
                switch (type)
                {
                    case NukeType.Mine:
                        useExplosion = true;
                        break;
                    case NukeType.Rocket:
                        break;
                    case NukeType.Bullet:
                        break;
                    case NukeType.Explosive:
                        useExplosion = true;
                        break;
                    case NukeType.Grenade:
                        break;
                    default:
                        break;
                }
                instance.InitializeZone(transform.position, 30, 10, 20, useExplosion);
            }
            public void InitializeComponent(NukeWeapons ins, NukeType typ, RadiationStats sta)
            {
                instance = ins;
                type = typ;
                stats = sta;
            }
        }
        public class ZoneList
        {
            public RadZones zone;
            public Timer time;
        }
        public class RadZones : MonoBehaviour
        {
            private int ID;
            private Vector3 Position;
            private float ZoneRadius;
            private float RadiationAmount;

            private List<BasePlayer> InZone;

            private void Awake()
            {
                gameObject.layer = (int)Layer.Reserved1;
                gameObject.name = "NukeZone";

                var rigidbody = gameObject.AddComponent<Rigidbody>();
                rigidbody.useGravity = false;
                rigidbody.isKinematic = true;
            }
            public void Activate(Vector3 pos, float radius, float amount)
            {
                ID = UnityEngine.Random.Range(0, 999999999);
                Position = pos;
                ZoneRadius = radius;
                RadiationAmount = amount;

                gameObject.name = $"RadZone {ID}";
                transform.position = Position;
                transform.rotation = new Quaternion();
                UpdateCollider();
                gameObject.SetActive(true);
                enabled = true;

                var Rads = gameObject.GetComponent<TriggerRadiation>();
                Rads = Rads ?? gameObject.AddComponent<TriggerRadiation>();
                Rads.RadiationAmountOverride = RadiationAmount;
                Rads.radiationSize = ZoneRadius;
                Rads.interestLayers = playerLayer;
                Rads.enabled = true;

                if (IsInvoking("UpdateTrigger")) CancelInvoke("UpdateTrigger");
                InvokeRepeating("UpdateTrigger", 5f, 5f);
            }
            private void OnDestroy()
            {
                CancelInvoke("UpdateTrigger");
                Destroy(gameObject);
            }
            private void UpdateCollider()
            {
                var sphereCollider = gameObject.GetComponent<SphereCollider>();
                {
                    if (sphereCollider == null)
                    {
                        sphereCollider = gameObject.AddComponent<SphereCollider>();
                        sphereCollider.isTrigger = true;
                    }
                    sphereCollider.radius = ZoneRadius;
                }
            }
            private void UpdateTrigger()
            {
                InZone = new List<BasePlayer>();
                int entities = Physics.OverlapSphereNonAlloc(Position, ZoneRadius, colBuffer, playerLayer);
                for (var i = 0; i < entities; i++)
                {
                    var player = colBuffer[i].GetComponentInParent<BasePlayer>();
                    if (player != null)
                        InZone.Add(player);
                }
            }
        }

        #endregion
       
        #region Chat Commands
        [ChatCommand("nw")]
        private void cmdNukes(BasePlayer player, string command, string[] args)
        {
            if (canRocket(player) || canBullet(player) || canMine(player) || canGrenade(player) || canExplosive(player) || canAll(player))
            {
                CheckPlayerEntry(player);
                OpenCraftingMenu(player);
            }       
        }
        #endregion

        #region Permissions
        private bool canRocket(BasePlayer player) => permission.UserHasPermission(player.UserIDString, "nukeweapons.rocket") || canAll(player);
        private bool canBullet(BasePlayer player) => permission.UserHasPermission(player.UserIDString, "nukeweapons.bullet") || canAll(player);
        private bool canMine(BasePlayer player) => permission.UserHasPermission(player.UserIDString, "nukeweapons.mine") || canAll(player);
        private bool canExplosive(BasePlayer player) => permission.UserHasPermission(player.UserIDString, "nukeweapons.explosive") || canAll(player);
        private bool canGrenade(BasePlayer player) => permission.UserHasPermission(player.UserIDString, "nukeweapons.grenade") || canAll(player);
        private bool canAll(BasePlayer player) => permission.UserHasPermission(player.UserIDString, "nukeweapons.all") || player.IsAdmin();
        private bool hasUnlimited(BasePlayer player) => permission.UserHasPermission(player.UserIDString, "nukeweapons.unlimited");
        #endregion

        #region Config        
        private ConfigData configData;
        
        class NWType
        {
            public bool Enabled { get; set; }
            public int MaxAllowed { get; set; }
            public int CraftTime { get; set; }
            public int CraftAmount { get; set; }
            public Dictionary<string, int> CraftingCosts { get; set; }
            public RadiationStats RadiationProperties { get; set; }
        }
        class RadiationStats
        {
            public float Intensity { get; set; }
            public float Duration { get; set; }
            public float Radius { get; set; }
        }
        
        class Options
        {
            public string MSG_MainColor { get; set; }
            public string MSG_SecondaryColor { get; set; }
        }
        class ConfigData
        {            
            public NWType Mines { get; set; }
            public NWType Rockets { get; set; }
            public NWType Bullets { get; set; }
            public NWType Grenades { get; set; }
            public NWType Explosives { get; set; }
            public Options Options { get; set; }
            public Dictionary<string, string> URL_IconList { get; set; }
        }        
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                Bullets = new NWType
                {
                    CraftAmount = 5,
                    CraftTime = 30,
                    CraftingCosts = new Dictionary<string, int>
                    {
                        {"ammo.rifle.explosive", 5 },
                        {"sulfur", 10 },
                        {"lowgradefuel", 10 }
                    },
                    Enabled = true,
                    MaxAllowed = 100,
                    RadiationProperties = new RadiationStats
                    {
                        Intensity = 15,
                        Duration = 3,
                        Radius = 5
                    }
                },
                Explosives = new NWType
                {
                    CraftAmount = 1,
                    CraftTime = 90,
                    CraftingCosts = new Dictionary<string, int>
                    {
                        {"explosive.timed", 1 },
                        {"sulfur", 150 },
                        {"lowgradefuel", 200 }
                    },
                    Enabled = true,
                    MaxAllowed = 3,
                    RadiationProperties = new RadiationStats
                    {
                        Intensity = 60,
                        Duration = 30,
                        Radius = 25
                    }
                },
                Grenades = new NWType
                {
                    CraftAmount = 1,
                    CraftTime = 45,
                    CraftingCosts = new Dictionary<string, int>
                    {
                        {"grenade.f1", 1 },
                        {"sulfur", 100 },
                        {"lowgradefuel", 100 }
                    },
                    Enabled = true,
                    MaxAllowed = 3,
                    RadiationProperties = new RadiationStats
                    {
                        Intensity = 35,
                        Duration = 15,
                        Radius = 15
                    }
                },
                Mines = new NWType
                {
                    CraftAmount = 1,
                    CraftTime = 60,
                    CraftingCosts = new Dictionary<string, int>
                    {
                        {"trap.landmine", 1 },
                        {"sulfur", 100 },
                        {"lowgradefuel", 150 }
                    },
                    Enabled = true,
                    MaxAllowed = 5,
                    RadiationProperties = new RadiationStats
                    {
                        Intensity = 70,
                        Duration = 25,
                        Radius = 20
                    }
                },
                Rockets = new NWType
                {
                    CraftAmount = 1,
                    CraftTime = 60,
                    CraftingCosts = new Dictionary<string, int>
                    {
                        {"ammo.rocket.basic", 1 },
                        {"sulfur", 150 },
                        {"lowgradefuel", 150 }
                    },
                    Enabled = true,
                    MaxAllowed = 3,
                    RadiationProperties = new RadiationStats
                    {
                        Intensity = 45,
                        Duration = 15,
                        Radius = 10
                    }
                },
                Options = new Options
                {
                    MSG_MainColor = "<color=#00CC00>",
                    MSG_SecondaryColor = "<color=#939393>"                    
                },
                URL_IconList = new Dictionary<string, string>
                {
                    {"BulletActive", "bulletactive.png" },
                    {"ExplosiveActive", "explosiveactive.png" },
                    {"GrenadeActive", "grenadeactive.png" },
                    {"MineActive", "landmineactive.png" },
                    {"RocketActive", "rocketactive.png" },
                    {"Bullet", "bullet.png" },
                    {"Explosive", "explosive.png" },
                    {"Grenade", "grenade.png" },
                    {"Mine", "landmine.png" },
                    {"Rocket", "rocket.png" },
                    {"Background", "background.png" }
                }
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Data Management
        void SaveData()
        {
            nukeData.ammo = cachedAmmo;
            data.WriteObject(nukeData);
        }
        void SaveDisplayNames()
        {
            itemNames.DisplayNames = DisplayNames;
            Item_Names.WriteObject(itemNames);
        }
        void LoadData()
        {
            try
            {
                nukeData = data.ReadObject<NukeData>();
                cachedAmmo = nukeData.ammo;
            }
            catch
            {
                nukeData = new NukeData();
            }
            try
            {
                itemNames = Item_Names.ReadObject<ItemNames>();
            }
            catch
            {
                Puts("Couldn't load item display name data, creating new datafile");
                itemNames = new ItemNames();
            }
        }
        class NukeData
        {
            public Dictionary<ulong, Dictionary<NukeType, int>> ammo = new Dictionary<ulong, Dictionary<NukeType, int>>();
            public List<uint> Mines = new List<uint>();
            public Dictionary<string, uint> ImageIDs = new Dictionary<string, uint>();
        }
        class ItemNames
        {
            public Dictionary<string, string> DisplayNames = new Dictionary<string, string>();
        }
        class PlayerAmmo
        {
            public int Rockets;
            public int Mines;
            public int Bullets;
            public int Explosives;
            public int Grenades;
        }
        enum NukeType
        {
            Mine,
            Rocket,
            Bullet,
            Explosive,
            Grenade
        }
        #endregion

        #region Unity WWW
        class QueueItem
        {
            public string url;
            public string imagename;

            public QueueItem(string ur, string na)
            {
                url = ur;
                imagename = na;               
            }
        }
        class UnityWeb : MonoBehaviour
        {
            NukeWeapons filehandler;
            const int MaxActiveLoads = 3;
            private Queue<QueueItem> QueueList = new Queue<QueueItem>();
            static byte activeLoads;
            private MemoryStream stream = new MemoryStream();

            private void Awake()
            {
                filehandler = (NukeWeapons)Interface.Oxide.RootPluginManager.GetPlugin(nameof(NukeWeapons));
            }
            private void OnDestroy()
            {
                QueueList.Clear();
                filehandler = null;
            }
            public void Add(string url, string imagename)
            {
                QueueList.Enqueue(new QueueItem(url, imagename));
                if (activeLoads < MaxActiveLoads) Next();
            }

            void Next()
            {
                if (QueueList.Count <= 0) return;
                activeLoads++;
                StartCoroutine(WaitForRequest(QueueList.Dequeue()));
            }
            private void ClearStream()
            {
                stream.Position = 0;
                stream.SetLength(0);
            }

            IEnumerator WaitForRequest(QueueItem info)
            {
                using (var www = new WWW(info.url))
                {
                    yield return www;
                    if (filehandler == null) yield break;
                    if (www.error != null)
                    {
                        print(string.Format("Image loading fail! Error: {0}", www.error));
                    }
                    else
                    {
                        if (!filehandler.nukeData.ImageIDs.ContainsKey(info.imagename))
                            filehandler.nukeData.ImageIDs.Add(info.imagename, 0);            
                        ClearStream();
                        stream.Write(www.bytes, 0, www.bytes.Length);
                        uint textureID = FileStorage.server.Store(stream, FileStorage.Type.png, uint.MaxValue);
                        ClearStream();
                        filehandler.nukeData.ImageIDs[info.imagename] = textureID;
                    }
                    activeLoads--;
                    if (QueueList.Count > 0) Next();
                    else filehandler.SaveData();
                }
            }
        }
        [ConsoleCommand("nukeicons")]
        private void cmdNukeIcons(ConsoleSystem.Arg arg)
        {
            if (arg.connection == null)
            {
                string dir = "file://" + Interface.Oxide.DataDirectory + Path.DirectorySeparatorChar + "NukeWeapons" + Path.DirectorySeparatorChar + "Icons" + Path.DirectorySeparatorChar;
                foreach (var image in configData.URL_IconList)
                    uWeb.Add(dir + image.Value, image.Key);
            }
        }
        
        
        #endregion

        #region Messaging
        private void SendMSG(BasePlayer player, string message, string message2 = "") => SendReply(player, $"{configData.Options.MSG_MainColor}{message}</color>{configData.Options.MSG_SecondaryColor}{message2}</color>");
        private string MSG(string key, string playerid = null) => lang.GetMessage(key, this, playerid);

        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            {"Bullet", "Bullet" },
            {"Explosive", "Explosive" },
            {"Grenade", "Grenade" },
            {"Rocket", "Rocket" },
            {"Mine", "Mine" },
            {"Bullets", "Bullets" },
            {"Explosives", "Explosives" },
            {"Grenades", "Grenades" },
            {"Rockets", "Rockets" },
            {"Mines", "Mines" },
            {"activated", "You have activated Nuke <type>s" },
            {"Menu", "Menu" },
            {"Deactivate", "Deactivate" },
            {"Disarm", "Disarm" },
            {"Arm", "Arm" },
            {"Inventory Amount", "Inventory Amount" },
            {"Unlimited", "Unlimited" },
            {"Crafting...", "Crafting..." },
            {"Limit Reached", "Limit Reached" },
            {"Craft", "Craft" },
            {"Item Name", "Item Name" },
            {"Required Amount", "Required Amount" },
            {"Your Supply", "Your Supply" },
            {"Required Ingredients", "Required Ingredients" },
            {"Close", "Close" },
            {"OOA", "You have run out of Nuke" },
            {"Crafting", "Crafting" }
        };
        #endregion
    }
}


// --- End of file: NukeWeapons.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Trade.cs ---
// --- Original Local Path: Trade.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Facepunch;
using Network;
using Network.Visibility;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("TradeBox", "OxideBro", "1.1.31")]

    public class Trade : RustPlugin
    {
        #region FIELDS
        [PluginReference]
        Plugin Duel;
        public static readonly List<int> sizes = new List<int>() { 6 };
        public Timer mytimer;
        private Dictionary<BasePlayer, DateTime> Cooldowns = new Dictionary<BasePlayer, DateTime>();


        private static Trade m_Instance;

        private Dictionary<string, TradeController> m_Boxes = new Dictionary<string, TradeController>();
        private static Dictionary<string, ShopFront> boxes = new Dictionary<string, ShopFront>();
        private static Dictionary<string, List<BasePlayer>> players = new Dictionary<string, List<BasePlayer>>();

        private List<ulong> tradingPlayers = new List<ulong>();

        private Dictionary<BasePlayer, BasePlayer> pendings = new Dictionary<BasePlayer, BasePlayer>();
        #endregion

        #region Configuration
        bool getCupAuth = true;
        bool getCupSend = true;
        bool getFly = true;
        bool getSwim = true;
        bool getWound = true;
        int getTime = 15;
        private double CooldownTrade = 60f;
        public int getInt = 8;
        private void LoadDefaultConfig()
        {
            GetConfig("Основное", "Запретить отправлять запрос в BuildingBlock", ref getCupSend);
            GetConfig("Основное", "Запретить принимать запрос в BuildingBlock", ref getCupAuth);
            GetConfig("Основное", "Запретить отправлять запрос в BuildingBlock", ref getCupSend);
            GetConfig("Основное", "Запретить использовать трейд в полёте", ref getFly);
            GetConfig("Основное", "Запретить использовать трейд в воде", ref getSwim);
            GetConfig("Основное", "Запретить использовать трейд в предсмертном состоянии", ref getWound);
            GetConfig("Основное", "Время ответа на предложения обмена (секунд)", ref getTime);
            GetConfig("Основное", "Задержка использования трейда (Cooldown - секунд)", ref CooldownTrade);
            GetConfig("Основное", "Количество активных слотов при обмене", ref getInt);
            SaveConfig();
        }

        private void GetConfig<T>(string menu, string Key, ref T var)
        {
            if (Config[menu, Key] != null)
            {
                var = (T)Convert.ChangeType(Config[menu, Key], typeof(T));
            }

            Config[menu, Key] = var;
        }
        #endregion

        #region OxideHooks

        private void Loaded()
        {
            m_Instance = this;
            lang.RegisterMessages(Messages, this);
            Messages = lang.GetMessages("en", this);
            LoadDefaultConfig();
        }

        void Unload()
        {
            foreach (var trade in m_Boxes)
            {
                Destroy(trade.Key);
                UnityEngine.Object.Destroy(trade.Value, 0.1f);
            }
        }

        private void OnShopCompleteTrade(ShopFront shop)
        {
            var trade = m_Boxes.Select(p => p.Value).FirstOrDefault(p => p.shop == shop);
            if (trade != null)
            {
                Reply(trade.player1, "TRADE.SUCCESS");
                Reply(trade.player2, "TRADE.SUCCESS");

                foreach (var itemМVen in shop.vendorInventory.itemList.Where(p => p != null).ToList())
                {
                    foreach (var item in shop.customerInventory.itemList.Where(p => p != null).ToList())
                    {
                        var spisok = (item.info.shortname + " " + item.amount);
                        // LogToFile("log", $"Успешный трейд. Дата: {DateTime.Now.ToShortDateString()} Время: {DateTime.Now.ToShortTimeString()})\nОбмен между {shop.customerPlayer} и {shop.vendorPlayer}\nВещи игрока {shop.customerPlayer}:\n {string.Join("\n", item.info.shortname, item.amount.ToArray())}\nВещи игрока {shop.vendorPlayer} :\n {itemМVen.info.shortname + " " + itemМVen.amount}\n", this);
                    }
                }
                Cooldowns[trade.player1] = DateTime.Now.AddSeconds(CooldownTrade);
                Cooldowns[trade.player2] = DateTime.Now.AddSeconds(CooldownTrade);
                timer.Once(1.0f, () =>
                {
                    trade.player1.EndLooting();
                    trade.player2.EndLooting();
                    DrawUIPlayer(trade.player1);
                    DrawUIPlayer(trade.player2);
                    timer.Once(4f, () =>
                    {
                        DestroyUIPlayer(trade.player1);
                        DestroyUIPlayer(trade.player2);
                    });
                });
            }
        }
        #endregion

        #region Commands

        [ConsoleCommand("trade")]
        void cmdTrade(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null || arg.Args.Length == 0) return;
            var name = arg.Args[0];
            CmdChatTrade(player, string.Empty, new string[] { name });
        }

        public BasePlayer FindOnline(string nameOrUserId)
        {
            nameOrUserId = nameOrUserId.ToLower();
            foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
            {
                if (activePlayer.displayName.ToLower().Contains(nameOrUserId) || activePlayer.UserIDString == nameOrUserId)
                    return activePlayer;
            }
            return (BasePlayer)null;
        }


        [ChatCommand("trade")]
        void CmdChatTrade(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;

            if (args.Length == 0 || args.Length == null)
            {
                Reply(player, "TRADE.HELP");
                return;
            }
            if (Cooldowns.ContainsKey(player))
            {
                double seconds = Cooldowns[player].Subtract(DateTime.Now).TotalSeconds;
                if (seconds >= 0)
                {
                    Reply(player, "COOLDOWN", seconds);
                    return;
                }
            }
            switch (args[0])
            {
                default:
                    if (!CanPlayerTrade(player))
                    {
                        return;
                    }
                    if (IsDuelPlayer(player))
                    {
                        Reply(player, "DENIED.DUEL");
                        return;
                    }
                    var name = args[0];
                    var target = FindOnline(name);
                    if (target == null)
                    {
                        Reply(player, "PLAYER.NOT.FOUND", name);
                        return;
                    }
                    if (target == player)
                    {
                        Reply(player, "TRADE.TOYOU");
                        return;
                    }
                    if (getCupSend)
                    {
                        if (!player.CanBuild())
                        {
                            Reply(player, "DENIED.PRIVILEGE");
                            return;
                        }
                    }
                    BasePlayer anotherTarget;
                    if (pendings.TryGetValue(player, out anotherTarget))
                    {
                        Reply(player, "TRADE.ALREADY.PENDING.ANOTHER.PLAYER", anotherTarget.displayName);
                        return;
                    }
                    pendings[target] = player;
                    Reply(player, "PENDING.SENDER.FORMAT", target.displayName);
                    Reply(target, "PENDING.RECIEVER.FORMAT", player.displayName);
                    mytimer = timer.Once(getTime, () =>
                    {
                        if (target != null && player != null
                            && player.IsConnected && target.IsConnected
                            && pendings.ContainsKey(target))
                        {
                            pendings.Remove(target);
                            pendings.Remove(player);
                            Reply(player, "PENDING.TIMEOUT.SENDER");
                            Reply(target, "PENDING.TIMEOUT.RECIEVER");
                        }
                    });
                    return;
                case "accept":
                    if (player == null) return;
                    if (getCupAuth)
                    {
                        if (!player.CanBuild())
                        {
                            Reply(player, "DENIED.PRIVILEGE");
                            return;
                        }
                    }
                    BasePlayer player2;
                    if (!pendings.TryGetValue(player, out player2))
                    {
                        Reply(player, "TRADE.ACCEPT.PENDING.EMPTY");
                        return;
                    }
                    if (IsDuelPlayer(player))
                    {
                        pendings.Remove(player2);
                        pendings.Remove(player);
                        Reply(player, "DENIED.DUEL");
                        Reply(player2, "DENIED.DUEL");
                        return;
                    }
                    if (IsDuelPlayer(player2))
                    {
                        pendings.Remove(player2);
                        pendings.Remove(player);
                        Reply(player2, "DENIED.DUEL");
                        Reply(player, "DENIED.DUEL");
                        return;
                    }
                    if (!CanPlayerTrade(player)) return;
                    pendings.Remove(player);
                    timer.Once(0.2f, () => OpenBox(player2, player));
                    return;
                case "yes":
                    if (player == null) return;
                    if (getCupAuth)
                    {
                        if (!player.CanBuild())
                        {
                            Reply(player, "DENIED.PRIVILEGE");
                            return;
                        }
                    }
                    BasePlayer player3;
                    if (!pendings.TryGetValue(player, out player2))
                    {
                        Reply(player, "TRADE.ACCEPT.PENDING.EMPTY");
                        return;
                    }
                    if (IsDuelPlayer(player))
                    {
                        Reply(player, "DENIED.DUEL");
                        Reply(player2, "DENIED.DUEL");
                        return;
                    }
                    if (IsDuelPlayer(player2))
                    {
                        Reply(player2, "DENIED.DUEL");
                        Reply(player, "DENIED.DUEL");
                        return;
                    }

                    if (!CanPlayerTrade(player)) return;
                    pendings.Remove(player);
                    timer.Once(0.2f, () => OpenBox(player2, player));
                    return;
                case "cancel":
                    if (player == null) return;
                    if (!pendings.TryGetValue(player, out player2))
                    {
                        Reply(player, "TRADE.ACCEPT.PENDING.EMPTY");
                        return;
                    }
                    pendings.Remove(player);
                    if (player2?.IsConnected == true) Reply(player2, "PENDING.CANCEL.SENDER", player.displayName);
                    Reply(player2, "TRADE.CANCELED");
                    return;
                case "no":
                    if (player == null) return;
                    if (!pendings.TryGetValue(player, out player2))
                    {
                        Reply(player, "TRADE.ACCEPT.PENDING.EMPTY");
                        return;
                    }
                    pendings.Remove(player);
                    if (player2?.IsConnected == true) Reply(player2, "PENDING.CANCEL.SENDER", player.displayName);
                    Reply(player2, "TRADE.CANCELED");
                    return;

            }
        }

        private void RemovePending(BasePlayer player)
        {
            BasePlayer player2;
            if (!pendings.TryGetValue(player, out player2)) return;
            pendings.Remove(player);
            pendings.Remove(player2);
        }

        private bool IsDuelPlayer(BasePlayer player)
        {
            if (Duel == null)
                return false;
            var dueler = Duel.Call("IsPlayerOnActiveDuel", player);
            if (dueler is bool)
                return (bool)dueler;
            return false;
        }

        void OnPlayerLootEnd(PlayerLoot inventory)
        {
            var player = inventory.gameObject.ToBaseEntity();
            if (player == null) return;
            var box = m_Boxes.Select(p => p.Value).FirstOrDefault(p => p.player1 == player || p.player2 == player);
            if (box != null)
            {
                OnTradeCanceled(box.guid);
            }
        }
        #endregion

        #region Core
        private static void DrawUI(BasePlayer a)
        {
            CuiHelper.AddUi(a, @"[{""name"":""TradeBox_Button"",""parent"":""Overlay"",""components"":[{""type"":""UnityEngine.UI.Button"",""command"":""tradebox.button"",""color"":""1 1 1 0""},{""type"":""RectTransform"",""anchormin"":""0.65 0.1504"",""anchormax"":""0.9464 0.2455"",""offsetmin"":""0 0"",""offsetmax"":""1 1""}]},{""name"":""CuiElement"",""parent"":""Overlay"",""components"":[{""type"":""RectTransform"",""anchormin"":""0.05208334 0.09259259"",""anchormax"":""0.1041667 0.1851852"",""offsetmin"":""0 0"",""offsetmax"":""1 1""}]},{""name"":""CuiElement"",""parent"":""Overlay"",""components"":[{""type"":""RectTransform"",""anchormin"":""0.05208334 0.09259259"",""anchormax"":""0.1041667 0.1851852"",""offsetmin"":""0 0"",""offsetmax"":""1 1""}]}]");
        }
        private static void DestroyUI(BasePlayer a)
        {
            CuiHelper.DestroyUi(a, "TradeBox_Button");
        }

        void DrawUIPlayer(BasePlayer player)
        {
            CuiElementContainer Container = new CuiElementContainer();
            CuiElement ContainerUI = new CuiElement
            {
                Name = "ContainerUI",
                Parent = "Overlay",
                Components = {
                        new CuiImageComponent {
                            Color = "0 0 0 0"
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1"
                        }
                    }
            };

            CuiElement PlayerName = new CuiElement
            {
                Name = "PlayerName",
                Parent = "ContainerUI",
                Components = {
                        new CuiTextComponent {
                            Text = $"<size=18>Trade успешно завершён!</size>",
                            Align = TextAnchor.UpperCenter,
                            FadeIn = 0.5f
                        },
                        new CuiRectTransformComponent {
                             AnchorMin = "0.343 0.550",
                            AnchorMax = "0.635 0.620"
                        },
                        new CuiOutlineComponent {
                            Color = "0 0 0 0.5", Distance = "1.0 -0.5"
                        }

                    },
                FadeOut = 0.53f
            };
            Container.Add(ContainerUI);
            Container.Add(PlayerName);
            CuiHelper.AddUi(player, Container);
        }

        void DestroyUIPlayer(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "ContainerUI");
        }

        private static void cmdTradeButton(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            var shop = boxes.Select(p => p.Value).FirstOrDefault(p => p.customerPlayer == player || p.vendorPlayer == player);
            if (shop == null) return;

            if (shop.HasFlag(BaseEntity.Flags.Reserved3)) return;
            if (!shop.IsTradingPlayer(player))
            {
                return;
            }
            if (shop.vendorPlayer == null || shop.customerPlayer == null)
            {
                return;
            }
            if (shop.IsPlayerVendor(player))
            {
                if (shop.HasFlag(BaseEntity.Flags.Reserved1))
                {
                    shop.ResetTrade();
                }
                else
                {
                    shop.SetFlag(BaseEntity.Flags.Reserved1, true);
                    shop.vendorInventory.SetLocked(true);
                }
            }
            else if (shop.IsPlayerCustomer(player))
            {
                if (shop.HasFlag(BaseEntity.Flags.Reserved2))
                {
                    shop.ResetTrade();
                }
                else
                {
                    shop.SetFlag(BaseEntity.Flags.Reserved2, true);
                    shop.customerInventory.SetLocked(true);
                }
            }
            if (shop.HasFlag(BaseEntity.Flags.Reserved1) && shop.HasFlag(BaseEntity.Flags.Reserved2))
            {
                shop.SetFlag(BaseEntity.Flags.Reserved3, true);
                shop.Invoke(shop.CompleteTrade, 2f);
            }
        }

        [ConsoleCommand("tradebox.button")]
        void cmdTradeButton1(ConsoleSystem.Arg a)
        {
            cmdTradeButton(a);
        }

        public static PluginTimers GetTimer()
        {
            return m_Instance.timer;
        }

        public static string Create(BasePlayer player1, BasePlayer player2, int getInt)
        {
            BaseEntity entity = GameManager.server.CreateEntity("assets/prefabs/building/wall.frame.shopfront/wall.frame.shopfront.metal.prefab", new Vector3(), new Quaternion(), true);
            entity.transform.position = Vector3.zero;
            entity.Spawn();
            ShopFront shopFront = (ShopFront)entity;
            shopFront.vendorInventory.capacity = getInt;
            shopFront.customerInventory.capacity = getInt;
            string guid = CuiHelper.GetGuid();
            boxes.Add(guid, shopFront);
            var reply = 79;
            players[guid] = new List<BasePlayer>()
                  {
                    player1,
                    player2
                  };
            if (!player1.net.subscriber.IsSubscribed(shopFront.net.group))
                player1.net.subscriber.Subscribe(shopFront.net.group);
            if (!player2.net.subscriber.IsSubscribed(shopFront.net.group))
                player2.net.subscriber.Subscribe(shopFront.net.group);
            SendEntity(player1, (BaseEntity)shopFront);
            SendEntity(player2, (BaseEntity)shopFront);
            SendEntity(player1, (BaseEntity)player2);
            SendEntity(player2, (BaseEntity)player1);
            player1.EndLooting();
            player2.EndLooting();
            GetTimer().Once(0.1f, (Action)(() => StartLooting(guid, player1)));
            GetTimer().Once(0.5f, (Action)(() => StartLooting(guid, player2)));
            return guid;
        }

        static void SendEntity(BasePlayer a, BaseEntity b)
        {
            if (Net.sv.write.Start())
            {
                a.net.connection.validate.entityUpdates++; BaseNetworkable.SaveInfo c = new BaseNetworkable.SaveInfo
                {
                    forConnection = a.net.connection,
                    forDisk = false
                };
                Net.sv.write.PacketID(Message.Type.Entities);
                Net.sv.write.UInt32(a.net.connection.validate.entityUpdates);
                b.ToStreamForNetwork(Net.sv.write, c);
                Net.sv.write.Send(new SendInfo(a.net.connection));
            }
        }

        public static T AddComponent<T>(string a) where T : Component
        {
            ShopFront b;
            if (!boxes.TryGetValue(a, out b))
            {
                throw new InvalidOperationException("AddBehaviour: TradeBox for {guid} not Found");
            }
            return b.gameObject.AddComponent<T>();
        }

        public static void Destroy(string a)
        {
            ShopFront b;
            if (boxes.TryGetValue(a, out b))
            {
                if (players.ContainsKey(a))
                {
                    players[a].ForEach(DestroyUI); players.Remove(a);
                }
                boxes.Remove(a); b.Kill();
            }
        }


        private void DropTrade(TradeController trade)
        {
            m_Boxes.Remove(trade.guid);
            tradingPlayers.Remove(trade.player1.userID);
            tradingPlayers.Remove(trade.player2.userID);
            Destroy(trade.guid);
            UnityEngine.Object.DestroyImmediate(trade);
        }

        private void OpenBox(BasePlayer player1, BasePlayer player2)
        {
            var guid = Create(player1, player2, getInt);
            var trade = AddComponent<TradeController>(guid);
            trade.Init(guid, player1, player2);
            m_Boxes.Add(guid, trade);

            tradingPlayers.Add(player1.userID);
            tradingPlayers.Add(player2.userID);
        }

        private void OnTradeCanceled(string guid)
        {
            TradeController trade;
            if (m_Boxes.TryGetValue(guid, out trade))
            {
                if (trade.shop.customerInventory != null)
                {
                    for (int i = trade.shop.customerInventory.itemList.Count - 1; i >= 0; i--)
                    {
                        trade.player1.GiveItem(trade.shop.customerInventory.itemList[i], BaseEntity.GiveItemReason.Generic);
                    }
                }
                if (trade.shop.vendorInventory != null)
                {
                    for (int i = trade.shop.vendorInventory.itemList.Count - 1; i >= 0; i--)
                    {
                        trade.player2.GiveItem(trade.shop.vendorInventory.itemList[i], BaseEntity.GiveItemReason.Generic);
                    }
                }
                DropTrade(trade);
            }
        }

        object CanMoveItem(Item item, PlayerInventory playerLoot, uint targetContainer)
        {
            if (playerLoot == null) return null;
            var cont1 = playerLoot.FindContainer(targetContainer);
            if (cont1 == null) return null;
            var player = playerLoot.containerMain.playerOwner;
            if (player == null) return null;
            if (cont1.entityOwner != null && cont1.entityOwner is ShopFront)
            {
                var shopfront = cont1.entityOwner.GetComponent<ShopFront>();
                if (shopfront.IsPlayerCustomer(player) && shopfront.customerInventory.uid != targetContainer)
                    return false;
                else if (shopfront.IsPlayerVendor(player) && shopfront.vendorInventory.uid != targetContainer)
                    return false;
            }
            return null;
        }

        public static void StartLooting(string guid, BasePlayer player)
        {
            ShopFront shopFront;
            if (!boxes.TryGetValue(guid, out shopFront))
                return;
            player.inventory.loot.StartLootingEntity((BaseEntity)shopFront, false);
            player.inventory.loot.AddContainer(shopFront.vendorInventory);

            player.inventory.loot.SendImmediate();
            player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", "shopfront");
            shopFront.DecayTouch();
            shopFront.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            player.inventory.loot.AddContainer(shopFront.customerInventory);
            player.inventory.loot.SendImmediate();
            if ((UnityEngine.Object)shopFront.customerPlayer == (UnityEngine.Object)null)
                shopFront.customerPlayer = player;
            else
                shopFront.vendorPlayer = player;
            DrawUI(player);
            shopFront.ResetTrade();
            shopFront.UpdatePlayers();
        }

        void Reply(BasePlayer player, string langKey, params object[] args) => SendReply(player, Messages[langKey],
            args);


        bool CanPlayerTrade(BasePlayer player)
        {

            if (getSwim)
            {
                if (player.IsSwimming())
                {
                    Reply(player, "DENIED.SWIMMING");
                    return false;
                }
            }
            if (getCupSend && getCupAuth)
            {
                if (!player.CanBuild())
                {
                    Reply(player, "DENIED.PRIVILEGE");
                    return false;
                }
            }
            if (getFly)
            {
                if (!player.IsOnGround() || player.IsFlying)
                {
                    Reply(player, "DENIED.FALLING");
                    return false;
                }
            }
            if (getWound)
            {
                if (player.IsWounded())
                {
                    Reply(player, "DENIED.WOUNDED");
                    return false;
                }
            }

            if (Cooldowns.ContainsKey(player))
            {
                double seconds = Cooldowns[player].Subtract(DateTime.Now).TotalSeconds;
                if (seconds >= 0)
                {
                    Reply(player, "COOLDOWN", seconds);
                    return false;
                }
            }
            if (IsDuelPlayer(player)) return false;
            var canTrade = Interface.Call("CanTrade", player);
            if (canTrade != null)
            {
                if (canTrade is string)
                {
                    SendReply(player, Convert.ToString(canTrade));
                    return false;
                }
                Reply(player, "DENIED.GENERIC");
                return false;
            }

            return true;
        }

        #endregion

        #region Nested type: TradeController

        class TradeController : MonoBehaviour
        {
            public string guid;
            public ShopFront shop;
            public BasePlayer player1, player2;

            public void Init(string guid, BasePlayer player1, BasePlayer player2)
            {
                this.guid = guid;
                this.player1 = player1;
                this.player2 = player2;
            }


            private void Awake()
            {
                shop = GetComponent<ShopFront>();
            }
        }
        #endregion

        #region Localization

        Dictionary<string, string> Messages = new Dictionary<string, string>()
        {
            { "DENIED.SWIMMING", "Недоступно, вы плаваете!" },
            { "DENIED.DUEL", "Недоступно, один из игроков на Duel!" },
            { "DENIED.FALLING", "Недоступно, вы левитируете!" },
            { "DENIED.WOUNDED", "Недоступно, вы в предсмертном состоянии!" },
            { "DENIED.GENERIC", "Недоступно, заблокировано другим плагином!" },
            { "DENIED.PRIVILEGE", "Недоступно, вы в зоне Building Blocked!" },
            { "DENIED.PERMISSION", "Недоступно, вы в зоне Building Blocked!" },
            { "TRADE.HELP", "Trade by RustPlugin.ru\nИспользуйте комманду <color=orange>/trade \"НИК\"</color> для обмена\nЧто бы принять обмен, введите: <color=orange>/trade yes</color> (или /trade accept)\nЧто бы отказаться от обмена введите: <color=orange>/trade no </color> (или /trade cancel)" },
            { "PLAYER.NOT.FOUND", "Игрок '{0}' не найден!" },
            { "TRADE.ALREADY.PENDING.ANOTHER.PLAYER", "Невозможно! Игрок '{0}' уже отправил вам предложение обмена!" },
            { "TRADE.ACCEPT.PENDING.EMPTY", "У вас нет входящих предложний обмена!" },
            { "TRADE.CANCELED", "Trade отменен!" },
            { "TRADE.TOYOU", "Нельзя отправлять запрос самому себе!" },
            { "TRADE.SUCCESS", "Trade успешно завершён!" },
            { "PENDING.RECIEVER.FORMAT", "Игрок '{0}' отправил вам предложние обмена\nДля принятия обмена используйте команду <color=orange>/trade yes</color>\nЧто бы отказаться введите <color=orange>/trade no</color>" },
            { "PENDING.SENDER.FORMAT", "Предложение обмена игроку '{0}' успешно отправлено, ожидайте..." },
            { "PENDING.TIMEOUT.SENDER", "Trade отменён! Причина: время истекло." },
            { "PENDING.TIMEOUT.RECIEVER", "Trade отменён! Причина: вы вовремя не приняли запрос." },
            { "PENDING.CANCEL.SENDER", "Trade отменён! Причина: игрок '{0}' отказался" },
            { "COOLDOWN", "Вы только недавно обменивались, подождите - {0:0} сек." },
        };

        #endregion
    }
}
                      

// --- End of file: Trade.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/EasyFurnace.cs ---
// --- Original Local Path: EasyFurnace.cs ---

using System.Collections.Generic;
using System.Linq;
using System;

namespace Oxide.Plugins
{
    [Info("EasyFurnace", "oskar3123", "1.1.4", ResourceId = 1191)]
    class EasyFurnace : RustPlugin
    {
        class Cfg
        {
            public static double
                burntime_wood,
                cooktime_hqmetal,
                cooktime_metal,
                cooktime_sulfur;
            public static int
                furnaceMetalOres,
                furnaceMetalWood,
                furnaceMetalOutput,
                furnaceSulfurOres,
                furnaceSulfurWood,
                furnaceSulfurOutput,
                furnaceHQMetalOres,
                furnaceHQMetalWood,
                furnaceHQMetalOutput,
                largeFurnaceMetalOres,
                largeFurnaceMetalWood,
                largeFurnaceMetalOutput,
                largeFurnaceSulfurOres,
                largeFurnaceSulfurWood,
                largeFurnaceSulfurOutput,
                largeFurnaceHQMetalOres,
                largeFurnaceHQMetalWood,
                largeFurnaceHQMetalOutput;
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            Config.Clear();
            Config["Furnace", "Metal", "Ores"] = 4;
            Config["Furnace", "Metal", "Wood"] = 1;
            Config["Furnace", "Metal", "Output"] = 1;
            Config["Furnace", "Sulfur", "Ores"] = 4;
            Config["Furnace", "Sulfur", "Wood"] = 1;
            Config["Furnace", "Sulfur", "Output"] = 1;
            Config["Furnace", "HQMetal", "Ores"] = 3;
            Config["Furnace", "HQMetal", "Wood"] = 2;
            Config["Furnace", "HQMetal", "Output"] = 1;
            Config["LargeFurnace", "Metal", "Ores"] = 12;
            Config["LargeFurnace", "Metal", "Wood"] = 5;
            Config["LargeFurnace", "Metal", "Output"] = 1;
            Config["LargeFurnace", "Sulfur", "Ores"] = 12;
            Config["LargeFurnace", "Sulfur", "Wood"] = 3;
            Config["LargeFurnace", "Sulfur", "Output"] = 3;
            Config["LargeFurnace", "HQMetal", "Ores"] = 7;
            Config["LargeFurnace", "HQMetal", "Wood"] = 10;
            Config["LargeFurnace", "HQMetal", "Output"] = 1;
            SaveConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Cfg.furnaceMetalOres = (int)Config["Furnace", "Metal", "Ores"];
            Cfg.furnaceMetalWood = (int)Config["Furnace", "Metal", "Wood"];
            Cfg.furnaceMetalOutput = (int)Config["Furnace", "Metal", "Output"];
            Cfg.furnaceSulfurOres = (int)Config["Furnace", "Sulfur", "Ores"];
            Cfg.furnaceSulfurWood = (int)Config["Furnace", "Sulfur", "Wood"];
            Cfg.furnaceSulfurOutput = (int)Config["Furnace", "Sulfur", "Output"];
            Cfg.furnaceHQMetalOres = (int)Config["Furnace", "HQMetal", "Ores"];
            Cfg.furnaceHQMetalWood = (int)Config["Furnace", "HQMetal", "Wood"];
            Cfg.furnaceHQMetalOutput = (int)Config["Furnace", "HQMetal", "Output"];
            Cfg.largeFurnaceMetalOres = (int)Config["LargeFurnace", "Metal", "Ores"];
            Cfg.largeFurnaceMetalWood = (int)Config["LargeFurnace", "Metal", "Wood"];
            Cfg.largeFurnaceMetalOutput = (int)Config["LargeFurnace", "Metal", "Output"];
            Cfg.largeFurnaceSulfurOres = (int)Config["LargeFurnace", "Sulfur", "Ores"];
            Cfg.largeFurnaceSulfurWood = (int)Config["LargeFurnace", "Sulfur", "Wood"];
            Cfg.largeFurnaceSulfurOutput = (int)Config["LargeFurnace", "Sulfur", "Output"];
            Cfg.largeFurnaceHQMetalOres = (int)Config["LargeFurnace", "HQMetal", "Ores"];
            Cfg.largeFurnaceHQMetalWood = (int)Config["LargeFurnace", "HQMetal", "Wood"];
            Cfg.largeFurnaceHQMetalOutput = (int)Config["LargeFurnace", "HQMetal", "Output"];

            Cfg.burntime_wood = GetBurntime("wood");
            Cfg.cooktime_hqmetal = GetCooktime("hq.metal.ore");
            Cfg.cooktime_metal = GetCooktime("metal.ore");
            Cfg.cooktime_sulfur = GetCooktime("sulfur.ore");
        }

        double GetBurntime(ItemDefinition item)
        {
            foreach (ItemMod mod in item.itemMods)
            {
                if (!(mod is ItemModBurnable)) continue;
                ItemModBurnable burnable = mod as ItemModBurnable;
                return burnable.fuelAmount / 5;
            }
            return 0D;
        }
        double GetBurntime(string shortname)
        {
            return GetBurntime(ItemManager.FindItemDefinition(shortname));
        }

        double GetCooktime(ItemDefinition item)
        {
            foreach (ItemMod mod in item.itemMods)
            {
                if (!(mod is ItemModCookable)) continue;
                ItemModCookable cookable = mod as ItemModCookable;
                return cookable.cookTime;
            }
            return 0D;
        }
        double GetCooktime(string shortname)
        {
            return GetCooktime(ItemManager.FindItemDefinition(shortname));
        }

        int GetStackSize(string shortname) { return ItemManager.FindItemDefinition(shortname).stackable; }
        int GetStackSize(ItemDefinition item) { return item.stackable; }
        
        Dictionary<BaseOven, BasePlayer> furnaceCache = new Dictionary<BaseOven, BasePlayer>();

        void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            BaseOven furnace = entity as BaseOven;
            if (!furnace) return;

            furnaceCache[furnace] = player;
        }

        int RemoveItemsFromInventory(BasePlayer player, ItemDefinition itemToRemove, int amount)
        {
            List<Item> foundItems = player.inventory.FindItemIDs(itemToRemove.itemid);
            int numberFound = foundItems == null ? 0 : foundItems.Sum(item => item.amount);
            if (numberFound < amount) amount = numberFound;
            int numberRemoved = player.inventory.Take(foundItems, itemToRemove.itemid, amount);
            return numberRemoved;
        }
        int RemoveItemsFromInventory(BasePlayer player, string shortname, int amount)
        {
            return RemoveItemsFromInventory(player, ItemManager.FindItemDefinition(shortname), amount);
        }

        void GivePlayerItems(BasePlayer player, ItemDefinition item, int amount)
        {
            int stacksize = GetStackSize(item);
            int fullstacks = (int)Math.Floor((double)amount / stacksize);
            int remainder = amount - fullstacks * stacksize;
            for (int i = 0; i < fullstacks; i++)
                ItemManager.Create(item, stacksize).MoveToContainer(player.inventory.containerMain);
            if (remainder != 0)
                ItemManager.Create(item, remainder).MoveToContainer(player.inventory.containerMain);
        }
        void GivePlayerItems(BasePlayer player, string shortname, int amount)
        {
            GivePlayerItems(player, ItemManager.FindItemDefinition(shortname), amount);
        }

        void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            if (item.info.shortname != "metal.ore" && item.info.shortname != "sulfur.ore" && item.info.shortname != "hq.metal.ore") return;
            
            if (container.itemList.Count() > 1) return;

            int cap = container.capacity;
            if (cap != 6 && cap != 18) return;
            
            if (item.amount < cap) return;

            int oresize, woodsize, outputsize;
            if (cap == 6)
            {
                oresize = Cfg.furnaceHQMetalOres;
                woodsize = Cfg.furnaceHQMetalWood;
                outputsize = Cfg.furnaceHQMetalOutput;
                if (item.info.shortname == "metal.ore")
                {
                    oresize = Cfg.furnaceMetalOres;
                    woodsize = Cfg.furnaceMetalWood;
                    outputsize = Cfg.furnaceMetalOutput;
                }
                else if (item.info.shortname == "sulfur.ore")
                {
                    oresize = Cfg.furnaceSulfurOres;
                    woodsize = Cfg.furnaceSulfurWood;
                    outputsize = Cfg.furnaceSulfurOutput;
                }
            }
            else
            {
                oresize = Cfg.largeFurnaceHQMetalOres;
                woodsize = Cfg.largeFurnaceHQMetalWood;
                outputsize = Cfg.largeFurnaceHQMetalOutput;
                if (item.info.shortname == "metal.ore")
                {
                    oresize = Cfg.largeFurnaceMetalOres;
                    woodsize = Cfg.largeFurnaceMetalWood;
                    outputsize = Cfg.largeFurnaceMetalOutput;
                }
                else if (item.info.shortname == "sulfur.ore")
                {
                    oresize = Cfg.largeFurnaceSulfurOres;
                    woodsize = Cfg.largeFurnaceSulfurWood;
                    outputsize = Cfg.largeFurnaceSulfurOutput;
                }
            }
            double woodfactor = Cfg.cooktime_hqmetal / Cfg.burntime_wood;
            string outputname = "metal.refined";
            if (item.info.shortname == "metal.ore")
            {
                woodfactor = Cfg.cooktime_metal / Cfg.burntime_wood;
                outputname = "metal.fragments";
            }
            else if (item.info.shortname == "sulfur.ore")
            {
                woodfactor = Cfg.cooktime_sulfur / Cfg.burntime_wood;
                outputname = "sulfur";
            }
            
            if (oresize + woodsize + outputsize > cap) return;

            BaseOven furnace = null;
            foreach (BaseOven key in furnaceCache.Keys)
                if (key.inventory == container)
                {
                    furnace = key;
                    break;
                }
            if (!furnace) return;

            BasePlayer player;
            if (!furnaceCache.TryGetValue(furnace, out player) || !player) return;

            int orecount = 0;
            Item[] items = player.inventory.AllItems();
            foreach (Item itm in items)
                if (itm.info.shortname == item.info.shortname)
                    orecount += itm.amount;
            orecount += item.amount;
            if (orecount > oresize * GetStackSize(outputname))
                orecount = oresize * GetStackSize(outputname);


            ItemDefinition wooddefinition = ItemManager.FindItemDefinition("wood");
            int woodToRetain = (int)(Math.Ceiling((double)orecount / oresize) * woodfactor);
            //Puts(woodToRetain.ToString());
            int woodMaxStack = GetStackSize(wooddefinition);
            if (woodToRetain > woodMaxStack * woodsize)
                woodToRetain = woodMaxStack * woodsize;
            //Puts(woodToRetain.ToString());

            int retainedWood = RemoveItemsFromInventory(player, wooddefinition, woodToRetain);
            if (retainedWood < woodsize)
            {
                GivePlayerItems(player, wooddefinition, retainedWood);
                return;
            }

            if (woodToRetain > retainedWood)
            {
                orecount = (int)(Math.Floor(retainedWood / woodfactor) * oresize);
                int oldretained = retainedWood;
                retainedWood = (int)(orecount / oresize * woodfactor);
                GivePlayerItems(player, wooddefinition, oldretained - retainedWood);
            }

            int retainedAmount;
            retainedAmount = RemoveItemsFromInventory(player, outputname, outputsize);
            if (retainedAmount < outputsize)
            {
                GivePlayerItems(player, wooddefinition, retainedWood);
                return;
            }

            item.MoveToContainer(player.inventory.containerMain, -1, false);

            int extraWood = retainedWood % woodsize;
            //Puts(extraWood.ToString());
            int perstack = (int)Math.Floor((double)retainedWood / woodsize);
            //Puts(perstack.ToString());
            for (int i = 0; i < woodsize; i++)
            {
                ItemManager.Create(wooddefinition, perstack + (extraWood > 0 ? 1 : 0)).MoveToContainer(container, -1, false);
                extraWood--;
            }

            for (int i = 0; i < outputsize; i++)
                ItemManager.Create(ItemManager.FindItemDefinition(outputname), 1).MoveToContainer(container, -1, false);

            RemoveItemsFromInventory(player, item.info.shortname, orecount);

            int amountPerStack = orecount / oresize;
            Item[] oresToAdd = new Item[oresize];
            int extras = orecount % oresize;
            for (int i = 0; i < oresize; i++)
            {
                int tmpCnt = 0;
                if (extras > 0)
                    tmpCnt++;
                tmpCnt += amountPerStack;
                extras--;
                oresToAdd[i] = ItemManager.Create(ItemManager.FindItemDefinition(item.info.shortname), tmpCnt);
            }

            foreach (Item oreToAdd in oresToAdd)
                oreToAdd.MoveToContainer(container, -1, false);

            furnace.Invoke("StartCooking", 0);
        }
    }
}

// --- End of file: EasyFurnace.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/DropCars.cs ---
// --- Original Local Path: DropCars.cs ---

﻿﻿using System.Collections.Generic;
using Facepunch.Extend;
using Newtonsoft.Json;
 using Oxide.Core.Plugins;
 using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("DropCars", "TopPlugin.ru", "1.0.4")]
    public class DropCars : RustPlugin
    {
        #region CFG
        private ConfigData cfg { get; set; }

        private class ConfigData
        {
            [JsonProperty("Список флаеров призыва")] public List<FlareList> listFlare = new List<FlareList>();
            [JsonProperty("Высота полёта")] public float height = 150;
            [JsonProperty("Скорость самолета")] public float speed = 250;
            [JsonProperty("Заменить дефолтный вызов на вызов с самолета(Будут работать ток те которые есть во флаерах)")] public bool defaultSpawn = false; 
            public static ConfigData GetNewConf() 
            {
                var newConfig = new ConfigData();
                newConfig.listFlare = new List<FlareList>()
                {
                    new FlareList()
                    {
                        SkinId = 2112250209,
                        DisplayName = "Вызов миникоптера",
                        PrefabName = "assets/content/vehicles/minicopter/minicopter.entity.prefab",
                        _crateList = new Dictionary<string, float>()
                        {
                            ["crate_normal"] = 30,
                            ["crate_elite"] = 70,
                        }
                    },
                    new FlareList()
                    {
                        SkinId = 2112252048,
                        DisplayName = "Вызов большого коптера",
                        PrefabName = "assets/content/vehicles/scrap heli carrier/scraptransporthelicopter.prefab",
                        _crateList = new Dictionary<string, float>()
                        {
                            ["crate_normal"] = 30,
                            ["crate_elite"] = 70,
                        }
                    },
                    new FlareList()
                    {
                        SkinId = 2112251924,
                        DisplayName = "Вызов rhib",
                        PrefabName = "assets/content/vehicles/boats/rhib/rhib.prefab",
                        _crateList = new Dictionary<string, float>()
                        {
                            ["crate_normal"] = 30,
                            ["crate_elite"] = 70,
                        }
                    }
                };
                return newConfig; 
            }
        }
         
        protected override void LoadDefaultConfig() => cfg = ConfigData.GetNewConf();
        protected override void SaveConfig() => Config.WriteObject(cfg);

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                cfg = Config.ReadObject<ConfigData>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }
        #endregion
        #region Command
        [ConsoleCommand("give.flare")]
        void ConsCommad(ConsoleSystem.Arg arg)
        {
            if(arg?.Args == null || arg.Args.Length < 3) return;
            if(arg.Player() != null && !arg.Player().IsAdmin) return;
            var player = BasePlayer.FindByID(ulong.Parse(arg.Args[0]));
            if(player == null) return;
            var findPrefab = cfg.listFlare.FindLast(p => p.SkinId == ulong.Parse(arg.Args[1]));
            if(findPrefab == null) return;
            var item = ItemManager.CreateByName("flare", arg.Args[2].ToInt(), findPrefab.SkinId);
            item.name = findPrefab.DisplayName;
            if (!player.inventory.GiveItem(item))
                item.Drop(player.inventory.containerMain.dropPosition, player.inventory.containerMain.dropVelocity);
        }

        #endregion
        #region Class
        class FlareList
        {
            [JsonProperty("СкинАйди")]
            public ulong SkinId = 0;
            [JsonProperty("Название в инвентаре")]
            public string DisplayName= "";
            [JsonProperty("Префаб")]
            public string PrefabName = "";
            [JsonProperty("Ящики в который будет появляться(Ящик и шанс)")]
            public Dictionary<string, float> _crateList = new Dictionary<string, float>();
            [JsonProperty("Минимум выпадает")]
            public int Min = 1;
            [JsonProperty("Максимум выпадает")]
            public int Max = 2;
        }
        public static DropCars ins;
        #endregion
        #region Hooks
        void Init()
        {
            ins = this;
        } 
        [PluginReference] private Plugin CustomSkinsStacksFix;
        private Item OnItemSplit(Item item, int amount)
        {
            if (CustomSkinsStacksFix != null) return null;
            if (amount <= 0) return null;
            if (cfg.listFlare.Find(p => p.SkinId == item.skin) == null) return null;
            item.amount -= amount;
            var newItem = ItemManager.Create(item.info, amount, item.skin);
            newItem.name = item.name;
            newItem.skin = item.skin;
            newItem.amount = amount;
            return newItem;
        } 
        private object CanCombineDroppedItem(WorldItem first, WorldItem second)
        {
            return CanStackItem(first.item, second.item);
        } 
        object CanStackItem(Item item, Item targetItem)
        {
            var findSkin = cfg.listFlare.Find(p => p.SkinId == item.skin);
            if (findSkin == null) return null;
            if (item.skin == findSkin.SkinId && targetItem.skin == findSkin.SkinId) return true;
            return null;
        }
        object OnLootSpawn(LootContainer container)
        {
            if (container == null) return null;
            NextTick((() =>
            {
                var f = cfg.listFlare.FindAll(p => p._crateList.ContainsKey(container.ShortPrefabName));
                foreach (var flareList in f)
                {
                    if(flareList._crateList[container.ShortPrefabName] < Core.Random.Range(0f, 100f)) return;
                    container.GetComponent<StorageContainer>().inventory.capacity += 1;
                    var item = ItemManager.CreateByName("flare", Random.Range(flareList.Min, flareList.Max), flareList.SkinId);
                    item.name = flareList.DisplayName;
                    ItemContainer component1 = container.GetComponent<StorageContainer>().inventory;
                    item.MoveToContainer(component1);
                }
            }));
            
            return null;
        }
        object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (arg.cmd.Name != "spawn" || !cfg.defaultSpawn) return null;
            var findPrefab = cfg.listFlare.FindLast(p => p.PrefabName.Contains(arg.Args[0]));
            if(findPrefab == null) return null;
            GameObject entity  = new GameObject();
            entity.AddComponent<BaseEntity>();
            entity.transform.position = arg.Player().transform.position;
            entity.gameObject.AddComponent<DropCar>().PrefabName = findPrefab.PrefabName;
            return false;  
        }
        void OnExplosiveThrown(BasePlayer player, BaseEntity entity, ThrownWeapon item)
        {
            if(player == null || entity == null || item == null) return;
            var findPrefab = cfg.listFlare.FindLast(p => p.SkinId == item.skinID);
            if(findPrefab == null) return;
            entity.gameObject.AddComponent<DropCar>().PrefabName = findPrefab.PrefabName;
        }

        void OnExplosiveDropped(BasePlayer player, BaseEntity entity, ThrownWeapon item) =>
            OnExplosiveThrown(player, entity, item);
        #endregion
        #region ElseClass 
        
        class Parachute : BaseEntity
        {   
            private BaseEntity _entity;
            private BaseEntity parachute;

            private void Awake() 
            {
                _entity = GetComponent<BaseEntity>();
                parachute = GameManager.server.CreateEntity("assets/prefabs/misc/parachute/parachute.prefab", new Vector3(), new Quaternion(), true);
                parachute.SetParent(_entity, "parachute_attach");
                parachute.Spawn();
                var bodyRHIB = _entity.GetComponent<RHIB>();
                var bodyRow = _entity.GetComponent<MotorRowboat>();
                if (bodyRHIB != null) bodyRHIB.landDrag = 1.5f;
                else if (bodyRow != null) bodyRow.landDrag = 1.5f;
                else _entity.GetComponent<Rigidbody>().drag = 1.5f;

                var collider = parachute.gameObject.AddComponent<SphereCollider>();
                collider.gameObject.layer = (int) Layer.Reserved1;
                collider.radius = 0.25f;
                collider.isTrigger = true; 
            } 

            public void RemoveParachute() 
            {
                if (!parachute)
                    return;
                parachute.Kill();
                parachute =null;
                Destroy(this);
                return;
            }

            private void OnTriggerEnter(Collider other)
            {
                if (other.gameObject.GetComponent<Terrain>() == null&& !other.gameObject.name.Contains("building core") && !other.name.Contains("rock_cliff") && other.gameObject.GetComponent<BaseEntity>() == null && other.gameObject.GetComponent<BuildingPrivlidge>() == null && !other.gameObject.name.Contains("flare")) return;
                var bodyRHIB = _entity.GetComponent<RHIB>();
                var bodyRow = _entity.GetComponent<MotorRowboat>();
                if (bodyRHIB != null)
                {
                    bodyRHIB.landDrag = 0.2f; 
                }
                else if (bodyRow != null)
                {
                    bodyRow.landDrag = 0.2f;
                }
                else 
                {
                    _entity.GetComponent<Rigidbody>().drag = 0.3f;   
                }
                RemoveParachute();
            } 
        }
        class DropCar : MonoBehaviour
        {
            public string PrefabName;
            private CargoPlane _cargoPlane;
            private BaseEntity parachute;
            private BaseEntity _entity;
            private void Awake() 
            {
                _entity = GetComponent<BaseEntity>();
                if(_entity.ShortPrefabName !=null && _entity.ShortPrefabName.Contains("flare")) _entity.GetComponent<Rigidbody>().freezeRotation = true;
                _cargoPlane = GameManager.server.CreateEntity("assets/prefabs/npc/cargo plane/cargo_plane.prefab", Vector3.up) as CargoPlane;
                _cargoPlane.Spawn();
                _cargoPlane.UpdateDropPosition(_entity.transform.position);
                _cargoPlane.startPos.y = TerrainMeta.HighestPoint.y + ins.cfg.height;
                _cargoPlane.endPos.y = _cargoPlane.startPos.y;
                _cargoPlane.secondsToTake = Vector3.Distance(_cargoPlane.startPos, _cargoPlane.endPos) / (int) ins.cfg.speed;
                _cargoPlane.SendNetworkUpdateImmediate(true);
                _cargoPlane.dropped = true;
            }

            private void OnDestroy()
            {
                if(_entity == null)_cargoPlane.Kill();
                Destroy(this);
            }

            private void Update()
            {
                if(_entity != null) _cargoPlane.dropPosition = _entity.transform.position;
                float t = Mathf.InverseLerp(0.0f, _cargoPlane.secondsToTake, _cargoPlane.secondsTaken);
                
                if (_cargoPlane.dropped && (double) t >= 0.5)
                {
                    BaseEntity entity = GameManager.server.CreateEntity(PrefabName, new Vector3(_cargoPlane.dropPosition.x, _cargoPlane.startPos.y, _cargoPlane.dropPosition.z), new Quaternion(), true);
                    if (entity)
                    {
                        entity.Spawn();
                        entity.gameObject.AddComponent<Parachute>();
                    }
                    Destroy(this);
                }
            }
        }

        #endregion 
    }
}


// --- End of file: DropCars.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/StacksExtended.cs ---
// --- Original Local Path: StacksExtended.cs ---

using System; 
using System.Text; 
using System.Collections.Generic; 
using System.Linq; 
using UnityEngine;  

namespace Oxide.Plugins 
{ 
    [Info("StacksExtended", "Fujikura", "1.0.2", ResourceId = 35)] 
	
	class StacksExtended : RustPlugin 
	{ 
	
		bool Changed = false; 
		bool _loaded = false;  
	
		List<string> itemCategories = new List<string> (); 
		List<object> itemStackExcludes = new List<object>(); 
		Dictionary<string, List<string>> registeredPermissions = new Dictionary<string, List<string>> (); 
		Dictionary<string,object> containerStacks = new Dictionary<string,object>(); 
		Dictionary<string,object> containerVIP = new Dictionary<string,object>(); 
	
		bool clearOnReboot; 
		int commandsAuthLevel; 
		bool limitPlayerInventory;
		int playerInventoryStacklimit;  
		
		static List<object> defaultItemExcludes() 
		{
			var dp = new List<object>(); 
				dp.Add("water"); 
				dp.Add("water.salt"); 
				dp.Add("blood"); 
				dp.Add("blueprintbase"); 
				dp.Add("coal"); 
				dp.Add("flare"); 
				dp.Add("ammo.rocket.smoke"); 
				dp.Add("generator.wind.scrap"); 
				dp.Add("battery.small"); 
				dp.Add("mining.pumpjack"); 
				dp.Add("building.planner"); 
				dp.Add("door.key"); 
				dp.Add("map"); 
				dp.Add("note"); 
			return dp; 
		}  
		
		object GetConfig(string menu, string datavalue, object defaultValue) 
		{
			var data = Config[menu] as Dictionary<string, object>; 
			
			if (data == null) 
			{
				data = new Dictionary<string, object>(); 
				Config[menu] = data; 
				Changed = true; 
			} 
			
			object value; 
			
			if (!data.TryGetValue(datavalue, out value)) 
			{
				value = defaultValue; 
				data[datavalue] = value; 
				Changed = true; 
			} 
			return value; 
		}  
		void LoadVariables() 
		{
			itemStackExcludes = (List<object>)GetConfig("Settings", "ExcludedItems", defaultItemExcludes()); 
			
			containerStacks = (Dictionary<string, object>)GetConfig("Storages", "Stack", new Dictionary<string, object>()); 
			containerVIP = (Dictionary<string, object>)GetConfig("Storages", "VIP", new Dictionary<string, object>()); 
			clearOnReboot = Convert.ToBoolean(GetConfig("Settings", "clearOnReboot", false)); 
			commandsAuthLevel = Convert.ToInt32(GetConfig("Settings", "commandsAuthLevel", 2)); 
			limitPlayerInventory = Convert.ToBoolean(GetConfig("Settings", "limitPlayerInventory", false)); playerInventoryStacklimit =  Convert.ToInt32(GetConfig("Settings", "playerInventoryStacklimit", 0));  
			
			if (!Changed) 
				return; 
				
			SaveConfig(); 
			Changed = false; 
		}  
		protected override void LoadDefaultConfig() 
		{
			Config.Clear(); 
			LoadVariables(); 
		}  
		void Init() 
		{ 
			LoadVariables(); 
		}  
		void OnTerrainInitialized() 
		{
			_loaded = true; 
		}  
		void OnServerInitialized() 
		{
			var storages = Resources.FindObjectsOfTypeAll<StorageContainer>().Where(c => !c.isActiveAndEnabled && !c.GetComponent<LootContainer>()).Cast<BaseEntity>().Where(b => !b.ShortPrefabName.Contains("_static")).ToList(); 
			
			if (containerVIP == null || containerVIP.Count == 0) 
				CreateContainerVIP(storages); 
			if (containerStacks == null || containerStacks.Count == 0) 
				CreateContainerStacks(storages); 
			if(Config.Get("StackLimits") != null) 
			{
				if (clearOnReboot && _loaded) 
				{
					CreateContainerStacks(storages); 
					Config["Storages", "Stack"] = containerStacks; 
					StackDefaults(); 
				} 
				else StackLoad(); 
			} 
			else 
			{
				StackDefaults(); 
			} 
			
			CreatePermissions(); 
			UpdateContainerStacks(); 
			UpdateQuarryVIP(); 
			
			if (limitPlayerInventory && playerInventoryStacklimit >= 0) 
			{
				foreach(var player in BasePlayer.activePlayerList) UpdatePlayer(player); 
				foreach(var player in BasePlayer.sleepingPlayerList) UpdatePlayer(player); 
			} 
			
			storages.Clear();
		}  
		void OnEntityBuilt(Planner planner, GameObject obj) 
		{
			if (planner == null || planner.GetOwnerPlayer() == null || obj.GetComponent<BaseEntity>() == null || obj.GetComponent<BaseEntity>().OwnerID == 0) 
				return; 
			if (obj.GetComponent<BaseEntity>() is MiningQuarry) 
			{
				OnQuarryBuilt(planner, obj); 
				return; 
			} 
			
			BaseEntity entity = obj.GetComponent<BaseEntity>(); 
			BasePlayer player = planner.GetOwnerPlayer(); 
			
			if (player == null) 
				return; 
				
			var name = entity.ShortPrefabName.Replace(".deployed","").Replace("_deployed",""); 
			
			object containerLimit; 
			
			if (containerStacks.TryGetValue(name, out containerLimit)) 
			{
				if (entity.GetComponent<StorageContainer>().inventory.maxStackSize != (int)containerLimit) 
				{
					entity.GetComponent<StorageContainer>().inventory.maxStackSize = (int)containerLimit; 
					entity.SendNetworkUpdate(); 
				} 
				if (entity.OwnerID != 0) 
				{
					object containerPerms; 
				
					if (containerVIP.TryGetValue(name, out containerPerms)) 
					{
						var perms = (Dictionary<string, object>)containerPerms; 
						
						if (!(bool)perms["Enabled"]) 
							return; 
							
						foreach (var perm in ((Dictionary<string, object>)perms["Permissions"]).Reverse()) 
						{
							if ((int)containerLimit > 0 && (int)perm.Value >= 0 && (int)perm.Value > (int)containerLimit && permission.UserHasPermission(entity.OwnerID.ToString(), this.Title.ToLower()+"."+perm.Key)) 
							{
								entity.GetComponent<StorageContainer>().inventory.maxStackSize = (int)perm.Value; 
								entity.SendNetworkUpdate(); 		
							} 		
						} 		
					} 
				} 
			} 
		}  
		void OnQuarryBuilt(Planner planner, GameObject obj) 
		{
			BaseEntity entity = obj.GetComponent<BaseEntity>(); 
			BasePlayer player = planner.GetOwnerPlayer(); 
			
			if (player == null) 
				return; 
				
			var hopper = (entity as MiningQuarry).hopperPrefab.instance; 
			
			object hopperLimit; 
			
			if (containerStacks.TryGetValue(hopper.ShortPrefabName, out hopperLimit)) 
			{
				if (hopper.GetComponent<StorageContainer>().inventory.maxStackSize != (int)hopperLimit) 
				{
					hopper.GetComponent<StorageContainer>().inventory.maxStackSize = (int)hopperLimit; 
					hopper.SendNetworkUpdate(); 
				} 
			} 
			
			object hopperPerms; 
			
			if (containerVIP.TryGetValue(hopper.ShortPrefabName, out hopperPerms)) 
			{
				var perms = (Dictionary<string, object>)hopperPerms; 
				
				if (!(bool)perms["Enabled"]) 
					return; 
					
				foreach (var perm in ((Dictionary<string, object>)perms["Permissions"]).Reverse()) 
				{
					if ((int)hopperLimit > 0 && (int)perm.Value >= 0 && (int)perm.Value > (int)hopperLimit && permission.UserHasPermission(entity.OwnerID.ToString(), this.Title.ToLower()+"."+perm.Key)) 
					{
						hopper.GetComponent<StorageContainer>().inventory.maxStackSize = (int)perm.Value; 
						hopper.SendNetworkUpdate(); 
					} 
				} 
			} 
			
			var fuelstorage = (entity as MiningQuarry).fuelStoragePrefab.instance; 
			
			object fuelstorageLimit; 
			
			if (containerStacks.TryGetValue(fuelstorage.ShortPrefabName, out fuelstorageLimit)) 
			{
				if (fuelstorage.GetComponent<StorageContainer>().inventory.maxStackSize != (int)fuelstorageLimit) 
				{
					fuelstorage.GetComponent<StorageContainer>().inventory.maxStackSize = (int)fuelstorageLimit; 
					fuelstorage.SendNetworkUpdate(); 
				} 
			} 
			
			object fuelstoragePerms; 
			
			if (containerVIP.TryGetValue(fuelstorage.ShortPrefabName, out fuelstoragePerms)) 
			{
				var perms = (Dictionary<string, object>)fuelstoragePerms; 
				
				if (!(bool)perms["Enabled"]) 
					return; 
					
				foreach (var perm in ((Dictionary<string, object>)perms["Permissions"]).Reverse()) 
				{
					if ((int)fuelstorageLimit > 0 && (int)perm.Value >= 0 && (int)perm.Value > (int)fuelstorageLimit && permission.UserHasPermission(entity.OwnerID.ToString(), this.Title.ToLower()+"."+perm.Key)) 
					{
						fuelstorage.GetComponent<StorageContainer>().inventory.maxStackSize = (int)perm.Value; 
						fuelstorage.SendNetworkUpdate(); 		
					}
				} 		
			} 
		} 
		void UpdatePlayer(BasePlayer player) 
		{
			player.inventory.containerMain.maxStackSize = (int)playerInventoryStacklimit; 
			player.inventory.containerBelt.maxStackSize = (int)playerInventoryStacklimit; 
			player.inventory.SendSnapshot();
		}  
		void OnPlayerRespawned(BasePlayer player) 
		{
			if (player != null && limitPlayerInventory && playerInventoryStacklimit >= 0) 
				UpdatePlayer(player); 
		}  
		void OnPlayerInit(BasePlayer player) 
		{
			if (player != null && limitPlayerInventory && playerInventoryStacklimit >= 0) 
				UpdatePlayer(player); 
		}  
		void CreateContainerVIP(List<BaseEntity> storages) 
		{
			containerVIP = new Dictionary<string, object>(); 
			
			foreach (var storage in storages) 
			{
				var name = storage.ShortPrefabName.Replace(".deployed","").Replace("_deployed",""); 
				
				if (containerVIP.ContainsKey(name)) 
					continue; 
					
				var dp = new Dictionary<string, object>(); 
					dp.Add("Enabled", false); 
					dp.Add("Permissions", new Dictionary<string, object>() {{"vip1",0}, {"vip2",0}, {"vip3",0}} ); 
					
				containerVIP.Add(name, dp); 
			} 
			
			Config["Storages", "VIP"] = containerVIP; 
			SaveConfig(); 
		}  
		void CreateContainerStacks(List<BaseEntity> storages) 
		{
			containerStacks = new Dictionary<string, object>(); 
			
			foreach (var storage in storages) 
			{
				var name = storage.ShortPrefabName.Replace(".deployed","").Replace("_deployed",""); 
				
				if (containerStacks.ContainsKey(name)) 
					continue; 
					
				containerStacks.Add(name, storage.GetComponent<StorageContainer>().maxStackSize); 
			} 
			
			Config["Storages", "Stack"] = containerStacks; 
			SaveConfig(); 
		}  
		void CreatePermissions() 
		{
			foreach (var permSet in containerVIP) 
			{
				var perms = (Dictionary<string, object>)permSet.Value; 
				
				if ((bool)perms["Enabled"]) 
				{
					foreach (var perm in ((Dictionary<string, object>)perms["Permissions"])) 
					{
						if (!registeredPermissions.ContainsKey(this.Title.ToLower()+"."+perm.Key)) 
							registeredPermissions.Add(this.Title.ToLower()+"."+perm.Key, new List<string>()); 
						if (!registeredPermissions[this.Title.ToLower()+"."+perm.Key].Contains(permSet.Key)) 
							registeredPermissions[this.Title.ToLower()+"."+perm.Key].Add(permSet.Key); 
						if (!permission.PermissionExists(this.Title.ToLower()+"."+perm.Key)) 
							permission.RegisterPermission(this.Title.ToLower()+"."+perm.Key, this); 
					} 		
				} 		
			} 		
		}  
		
		Dictionary<string, int> UpdateContainerStacks() 
		{
			var entities = BaseNetworkable.serverEntities.Where(p => (p as BaseEntity).GetComponent<StorageContainer>() != null && (p as BaseEntity).GetComponent<LootContainer>() == null).Cast<BaseEntity>().ToList(); 
			var counter = 0; 
			var vipcounter = 0; 
			var dp = new Dictionary<string, int>(); 
			
			foreach (var entity in entities) 
			{
				var name = entity.ShortPrefabName.Replace(".deployed","").Replace("_deployed",""); 
				
				object containerLimit; 
				
				if (containerStacks.TryGetValue(name, out containerLimit)) 
				{
					if (entity.GetComponent<StorageContainer>().inventory.maxStackSize != (int)containerLimit) 
					{
						entity.GetComponent<StorageContainer>().inventory.maxStackSize = (int)containerLimit; 
						counter++; 
						entity.SendNetworkUpdate(); 
					} 
					if (entity.OwnerID != 0) 
					{
						object containerPerms; 
						
						if (containerVIP.TryGetValue(name, out containerPerms)) 
						{
							var perms = (Dictionary<string, object>)containerPerms; 
							
							if ((bool)perms["Enabled"]) 
							{
								foreach (var perm in ((Dictionary<string, object>)perms["Permissions"]).Reverse()) 
								{
									if ((int)containerLimit > 0 && (int)perm.Value >= 0 && (int)perm.Value > (int)containerLimit && permission.UserHasPermission(entity.OwnerID.ToString(), this.Title.ToLower()+"."+perm.Key)) 
									{
										entity.GetComponent<StorageContainer>().inventory.maxStackSize = (int)perm.Value; 
										vipcounter++; 
										entity.SendNetworkUpdate(); 			
									} 			
								} 			
							} 
						} 			
					} 				
				} 			
			} 
			
			dp.Add("counter", counter); 
			dp.Add("vipcounter", vipcounter); 
			return dp; 
		}  
		
		Dictionary<string, int> UpdateQuarryVIP() 
		{
			var entities = BaseNetworkable.serverEntities.Where(p => (p as BaseEntity) is MiningQuarry).Cast<BaseEntity>().ToList(); 
			var hoppercounter = 0; 
			var fuelstoragecounter = 0; 
			var dp = new Dictionary<string, int>(); 
			
			foreach (var entity in entities) 
			{
				if (entity.OwnerID == 0) 
					continue; 
					
				var hopper = (entity as MiningQuarry).hopperPrefab.instance; 
				
				object hopperPerms; 
				
				if (containerVIP.TryGetValue(hopper.ShortPrefabName, out hopperPerms)) 
				{
					var perms = (Dictionary<string, object>)hopperPerms; 
					
					if ((bool)perms["Enabled"]) 
					{
						foreach (var perm in ((Dictionary<string, object>)perms["Permissions"]).Reverse()) 
						{
							object containerLimit; 
							
							containerStacks.TryGetValue(hopper.ShortPrefabName, out containerLimit); 
							
							if ((int)containerLimit > 0 && (int)perm.Value >= 0 && (int)perm.Value > (int)containerLimit && permission.UserHasPermission(entity.OwnerID.ToString(), this.Title.ToLower()+"."+perm.Key)) 
							{
								hopper.GetComponent<StorageContainer>().inventory.maxStackSize = (int)perm.Value; 
								hoppercounter++; 
								hopper.SendNetworkUpdate(); 
							} 
						} 
					} 
				} 
				
				var fuelstorage = (entity as MiningQuarry).fuelStoragePrefab.instance; 
				
				object fuelstoragePerms; 
				
				if (containerVIP.TryGetValue(fuelstorage.ShortPrefabName, out fuelstoragePerms)) 
				{
					var perms = (Dictionary<string, object>)fuelstoragePerms; 
					
					if ((bool)perms["Enabled"]) 
					{
						foreach (var perm in ((Dictionary<string, object>)perms["Permissions"]).Reverse()) 
						{
							object containerLimit; 
							
							containerStacks.TryGetValue(fuelstorage.ShortPrefabName, out containerLimit); 
							
							if ((int)containerLimit > 0 && (int)perm.Value >= 0 && (int)perm.Value > (int)containerLimit && permission.UserHasPermission(entity.OwnerID.ToString(), this.Title.ToLower()+"."+perm.Key)) 
							{
								fuelstorage.GetComponent<StorageContainer>().inventory.maxStackSize = (int)perm.Value; 
								fuelstoragecounter++;
								fuelstorage.SendNetworkUpdate(); 				
							}				
						}
					} 
				} 
			} 
			
			dp.Add("hoppercounter", hoppercounter); 
			dp.Add("fuelstoragecounter", fuelstoragecounter); 
			return dp; 
		}  
		void StackDefaults() 
		{			
			NextTick(() => 
			{
				var itemList = ItemManager.itemList;
				
				if (itemList == null || itemList.Count == 0) 
				{
					NextTick(StackDefaults); 
					return; 
				} 
				if (clearOnReboot && _loaded) 
				{
					clearOnReboot = false; 
					Config["Settings", "clearOnReboot"] = false; 
					Config.Save(); 
					Puts($"Forced stacksizes reset..."); 
				} 
				int i = 0; 
				
				foreach (var item in itemList) 
				{
					if (item.condition.enabled && item.condition.max > 0 && item.GetComponent<ItemModDeployable>() == null) 
						continue; 
					if (itemStackExcludes.Contains(item.shortname)) 
						continue; 
						
					Config["StackLimits", item.shortname] = item.stackable; 
					
					if (!itemCategories.Contains(item.category.ToString().ToLower())) 
						itemCategories.Add(item.category.ToString().ToLower()); 
					
					i++; 
				} 
				
				Config.Save(); 
				Puts($"Created stacksize file with '{i}' items"); 
			}); 
		}  
		void StackLoad() 
		{
			bool dirty = false; 
			bool changed = false; 
			
			var itemList = ItemManager.itemList; 
			
			if (itemList == null || itemList.Count == 0) 
			{
				NextTick(StackDefaults); 
				return; 
			} 
			int c = 0; 
			
			foreach (var item in itemList) 
			{
				if (itemStackExcludes.Contains(item.shortname)) 
					continue; 
				if (item.condition.max > 0 && item.GetComponent<ItemModDeployable>() == null) 
					continue; 
				if (Config["StackLimits", item.shortname] == null) 
				{
					Config["StackLimits", item.shortname] = item.stackable; 
					dirty = true; 
				} 
				if (item.stackable != (int)Config["StackLimits", item.shortname]) 
				{
					changed = true; 
					c++; 
				} 
				
				item.stackable = (int)Config["StackLimits", item.shortname]; 
				
				if (item.GetComponent<ItemModDeployable>() != null) 
					item.condition.enabled = false; 
				if (!itemCategories.Contains(item.category.ToString().ToLower())) 
					itemCategories.Add(item.category.ToString().ToLower()); 
			} 
			
			if (changed && !_loaded) 
				Puts($"Changed '{c}' stacks with new values"); 
			if (!changed && !dirty) 
				Puts("No stacksize changed"); 
			if (dirty) 
				Puts("Updated stacksize file with new items"); 
			if (dirty) 
				Config.Save(); 
		}  
		[ConsoleCommand("se.reload")] 
		void ccmdReload(ConsoleSystem.Arg arg) 
		{
			if(arg.Connection != null && arg.Connection.authLevel < commandsAuthLevel) 
				return; 
				
			LoadConfig(); 
			LoadVariables(); 
			NextTick(()=> 
			{
				var storages = Resources.FindObjectsOfTypeAll<StorageContainer>().Where(c => !c.isActiveAndEnabled && !c.GetComponent<LootContainer>()).Cast<BaseEntity>().Where(b => !b.ShortPrefabName.Contains("_static")).ToList(); 
				
				if (containerVIP == null || containerVIP.Count == 0) 
					CreateContainerVIP(storages); 
				if (containerStacks == null || containerStacks.Count == 0) 
					CreateContainerStacks(storages); 
					
				storages.Clear(); 
				
				if (limitPlayerInventory && playerInventoryStacklimit > 0) 
				{
					foreach(var player in BasePlayer.activePlayerList) UpdatePlayer(player); 
					foreach(var player in BasePlayer.sleepingPlayerList) UpdatePlayer(player); 
				} 
				
				StackLoad(); 
				registeredPermissions.Clear(); 
				CreatePermissions(); 
				
				var containerUpdates = UpdateContainerStacks(); 
				var quarryUpdates = UpdateQuarryVIP(); 
				
				SendReply(arg, $"Config reloaded and {containerUpdates["counter"]} Storages updated"); 
				SendReply(arg, $"VIP Changes > {containerUpdates["vipcounter"]} Storages | {quarryUpdates["hoppercounter"]} Quarry Output | {quarryUpdates["fuelstoragecounter"]} Quarry Fuel"); 
			}); 
		}  
		[ConsoleCommand("se.clearreload")] 
		private void ccmdStackReload(ConsoleSystem.Arg arg) 
		{
			if(arg.Connection != null && arg.Connection.authLevel < commandsAuthLevel) 
				return; 
			
			Config["Settings", "clearOnReboot"] = true; 
			Config.Save(); 
			SendReply(arg, $"Your stack and container limits will be reverted to the defaults on next startup"); 
		}  
		[ConsoleCommand("se.stackcategory")] 
		void ccmdStackCategory(ConsoleSystem.Arg arg) 
		{
			if(arg.Connection != null && arg.Connection.authLevel < commandsAuthLevel) 
				return; 
				
			bool noInput = false; 
			
			if (arg.Args == null || arg.Args.Length != 2) 
			{
				SendReply(arg, "Syntax Error: Requires 2 arguments. Example: resources 32000"); 
				noInput = true; 
			} 
			if (arg.Args != null && arg.Args.Length > 1 && arg.Args[0].ToLower() != "all") 
				foreach (var cat in itemCategories) 
				{
					if (cat.StartsWith(arg.Args[0].ToLower())) 
					{
						arg.Args[0] = cat; 
						break; 
					} 
				} 
			if (noInput || (arg.Args[0].ToLower() != "all" && !itemCategories.Contains(arg.Args[0].ToLower()))) 
			{
				string cats = ""; 
				
				foreach (var cat in itemCategories) 
				{
					cats += cat+" ";
				} 
				
				if (!noInput) 
					SendReply(arg, $"Category '{arg?.Args[0]}' not found"); 
					
					SendReply(arg, $"Categories: {cats}all"); 
				return; 
			} 
			
			int i = 0; 
			
			var itemList = ItemManager.itemList; 
			
			foreach (var item in itemList) 
			{
				if(arg.Args[0].ToLower() != "all" && item.category.ToString().ToLower() != arg.Args[0].ToLower()) 
					continue; 
				if (Config["StackLimits", item.shortname] == null) 
					continue; 
				if (itemStackExcludes.Contains(item.shortname)) 
					continue;  
					
				Config["StackLimits", item.shortname] = Convert.ToInt32(arg.Args[1]); 
				item.stackable = Convert.ToInt32(arg.Args[1]); 
				i++; 
			}
			
			Config.Save(); 
			SendReply(arg, $"The Stack Size of '{i}' stackable '{arg.Args[0]}' items has been set to '{arg.Args[1]}'"); 
		} 
		[ConsoleCommand("se.stackitem")] 
		void ccmdStackItem(ConsoleSystem.Arg arg) 
		{
			if(arg.Connection != null && arg.Connection.authLevel < commandsAuthLevel) 
				return; 
				
			bool noInput = false; 
			
			if (arg.Args == null || arg.Args.Length != 2) 
			{
				SendReply(arg, "Syntax Error: Requires 2 arguments (shortname + number). Example: wood 32000"); 
				return; 
			} 
			
			var itemDef = ItemManager.FindItemDefinition(arg.Args[0].ToLower()); 
			
			if (itemDef == null) 
			{
				SendReply(arg, $"Item '{arg.Args[0]}' does not exist"); 
				return; 
			} 
			if (itemStackExcludes.Contains(itemDef.shortname))
			{
				SendReply(arg, $"The provided item is excluded from stacking by the config"); 
				return;
			} 
			
			int limit = -1; 
			
			if (!int.TryParse(arg.Args[1], out limit)) 
			{
				SendReply(arg, $"You need to set any number greater then 0"); 
				return; 
			} 
			else 
				itemDef.stackable = limit; 
				
			Config["StackLimits", itemDef.shortname] = limit; 
			Config.Save(); 
			SendReply(arg, $"The stacksize of '{arg.Args[0]}' has been set to '{limit}'"); 
		}  
		[ConsoleCommand("se.listcategory")] 
		void ccmdListCategory(ConsoleSystem.Arg arg) 
		{
			if(arg.Connection != null && arg.Connection.authLevel < commandsAuthLevel) 
				return; 
				
			string cats = ""; 
			
			if (arg.Args == null || arg.Args.Length != 1) 
			{
				SendReply(arg, "Syntax Error: Requires 1 argument. Example: resources"); 
				
				foreach (var cat in itemCategories) 
				{
					cats += cat+" ";
				} 
				
				SendReply(arg, $"Categories are: {cats}all"); 
				return; 
			} 
			
			foreach (var cat in itemCategories) 
			{
				if (cat.StartsWith(arg.Args[0].ToLower())) 
				{
					arg.Args[0] = cat; 
					break; 
				} 
			} 
			if (!itemCategories.Contains(arg.Args[0].ToLower())) 
			{
				SendReply(arg, $"Category '{arg?.Args[0]}' not found"); 
				
				foreach (var cat in itemCategories) 
				{
					cats += cat+" ";
				} 
				
				SendReply(arg, $"Categories: {cats}all"); 
				return; 
			} 
			
			TextTable textTable = new TextTable(); 
				textTable.AddColumn("Shortname"); 
				textTable.AddColumn("DisplayName"); 
				textTable.AddColumn("StackSize"); 
			
			var sb = new StringBuilder(); 
				sb.AppendLine($"\n === Stacksizes for category '{arg.Args[0]}':\n"); 
			
			foreach (var item in ItemManager.GetItemDefinitions()) 
			{
				if (itemStackExcludes.Contains(item.shortname)) 
					continue; 
				if (item.category.ToString().ToLower() != arg.Args[0].ToLower()) 
					continue; 
					
				textTable.AddRow(new string[] 
				{
					item.shortname, 
					item.displayName.english, 
					item.stackable.ToString() 
				}); 
			} 
			
			sb.AppendLine(textTable.ToString()); 
			SendReply(arg, sb.ToString()); 
		}  
		[ConsoleCommand("se.permissions")] 
		void ccmdListPerms(ConsoleSystem.Arg arg) 
		{
			if(arg.Connection != null && arg.Connection.authLevel < commandsAuthLevel) 	
				return; 
				
			TextTable textTable = new TextTable(); 
				textTable.AddColumn("Permission"); 
				textTable.AddColumn("Containers"); 
				
			foreach (var perm in registeredPermissions) 
			{
				string perms = string.Empty; 
				
				foreach ( var cont in perm.Value) 
				{
					perms += cont+"("+(int)((containerVIP[cont] as Dictionary<string,object>)["Permissions"] as Dictionary<string,object>)[perm.Key.Replace(this.Title.ToLower()+".","")]+") "; 
				} 
				
				textTable.AddRow(new string[] { perm.Key.ToString(), perms }); 
			} 
			
			SendReply(arg, "\n"+textTable.ToString()); 
		} 
	} 
}

// --- End of file: StacksExtended.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CraftSpamBlocker.cs ---
// --- Original Local Path: CraftSpamBlocker.cs ---

//Requested by CCTV and RHAKOON on the Oxide Rust requests forum
using System.Collections.Generic;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Craft Spam Blocker", "LeoCurtss", 0.2)]
    [Description("Prevents items from being crafted if the player's inventory is full.")]

    class CraftSpamBlocker : RustPlugin
    {
		void Loaded()
        {
            //Lang API dictionary
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CPB_CantCraft"] = "Item not crafted!  Your inventory is full."
            }, this);
        }
		
		void OnItemCraftFinished(ItemCraftTask task, Item item)
        {
			BasePlayer player = task.owner;
			
			if (player.inventory.containerMain.itemList.Count > 23 && player.inventory.containerBelt.itemList.Count > 5)
			{
				task.cancelled = true;
				SendReply(player, GetMessage("CPB_CantCraft", player.UserIDString));
                Puts(player.displayName + " tried to craft an item, but their inventory was full!");
			}

			
        }
		
		private string GetMessage(string name, string sid = null)
        {
            return lang.GetMessage(name, this, sid);
        }
	
    }
}

// --- End of file: CraftSpamBlocker.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/IQBanSystem.cs ---
// --- Original Local Path: IQBanSystem.cs ---

using Rust;
using Oxide.Core;
using System.Collections.Generic;
using UnityEngine;
using System.Text.RegularExpressions;
using ConVar;
using Oxide.Core.Libraries.Covalence;
using System;
using Object = System.Object;
using Oxide.Core.Libraries;
using System.Text;
using Oxide.Core.Plugins;
using Oxide.Core.Database;
using Newtonsoft.Json.Linq;
using System.Linq;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("IQBanSystem", "rustmods.ru", "1.12.19")]
    [Description("IQBanSystem")]
    public class IQBanSystem : RustPlugin
    { 
		   		 		  						  	   		  		 			  	   		  		  		   		 

                
        
        private String SQL_Query_CreatedDatabase()
        {
            return $"CREATE TABLE IF NOT EXISTS `{config.mysqlConnected.dbTableName}`(" +
                               "`id` INT(11) NOT NULL AUTO_INCREMENT," +
                               "`steamid` VARCHAR(17) NOT NULL," +
                               "`ipAdress` VARCHAR(30) NOT NULL," +
                               "`permanent` VARCHAR(1) NOT NULL," +
                               "`timeUnbanned` VARCHAR(70) NOT NULL," +
                               "`reason` VARCHAR(70) NOT NULL," +
                               "`serverName` VARCHAR(70) NOT NULL," +
                               "`serverAdress` VARCHAR(70) NOT NULL," +
                               "`owner` VARCHAR(70) NOT NULL," +
                               "`nameHistory` TEXT NOT NULL," +
                               "`ipHistory` TEXT NOT NULL," +
                               "`steamIdHistory` TEXT NOT NULL," +
                               " PRIMARY KEY(`id`))" + 
                               " CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci;";
        }
        
        object OnTeamKick(RelationshipManager.PlayerTeam team, BasePlayer player, UInt64 target)
        {
            LeaveTeamPlayer(target);
            return null;
        }
        [ChatCommand("ban")]
        private void ChatBanCommand(BasePlayer ownerCommand, String cmd, String[] arg) => BanCommand(ownerCommand, arg);
        /// <summary>
        /// - Корректировка работы с хуком : OnUserConnected
        /// 
        /// </summary>
        
        
        private static IQBanSystem _;

        private class TeamLocalMemory
        {
            public Double firstJoin;
            public Double lastRemoved;
        }
        
        void OnTeamCreated(BasePlayer player, RelationshipManager.PlayerTeam team) => TeamAdded(team);

        public class Footer
        {
            public String text { get; set; }
            public String icon_url { get; set; }
            public String proxy_icon_url { get; set; }
            public Footer(String text, String icon_url, String proxy_icon_url)
            {
                this.text = text;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }
        protected override void SaveConfig() => Config.WriteObject(config);
        
        private class ProcessCheckVPN
        {
            public Int32 detectedVpn;
            public Boolean isCompleteProxyCheck;
            public Boolean isCompleteVpnApi;
            public Boolean isCompleteIPHub;
        }
        
                
        
        
        private List<String> ipListGods = new List<String>(); 
        private Timer timerCheckVpn;

        
                
        private Dictionary<Vector3, String> GetAuthCupboardPlayer(UInt64 playerID)
        {
            Dictionary<Vector3, String> resultData = new Dictionary<Vector3, String>();
            List<BaseNetworkable> listEntity = Facepunch.Pool.Get<List<BaseNetworkable>>();
            listEntity.AddRange(BaseNetworkable.serverEntities.entityList.Get().Values.Where(x => x.ShortPrefabName.Contains("cupboard") && x is BuildingPrivlidge));
                
            foreach (BaseNetworkable cupboards in listEntity)
            {
                BuildingPrivlidge cupboard = cupboards as BuildingPrivlidge;
                if (cupboard == null) continue;
                if (cupboard.IsAuthed(playerID) || cupboard.OwnerID == playerID)
                    resultData.Add(cupboard.transform.position, MapHelper.PositionToString(cupboard.transform.position));
            }
            
            Facepunch.Pool.FreeUnmanaged(ref listEntity);
            return resultData;
        }
        
        private void OnServerInitialized()
        {
            permission.RegisterPermission(permissionsBan,this);
            permission.RegisterPermission(permissionsUnBan,this);
            permission.RegisterPermission(permissionsKick,this);
            permission.RegisterPermission(permissionsIgnoreVPN,this);
            permission.RegisterPermission(permissionIgnoreBan,this);

            Configuration.BannedSetting.DestroyedAfterBannedSetting configDestroyed = config.bannedSetting.destroyedAfterBannedSetting;
            Boolean isMarkerUse = configDestroyed.mapMarkerDestroyedObjectSetting.useMapMarkerDestroyedObjectPlayer && config.generalSetting.additionalSetting.useAlertAllPlayers && configDestroyed.useAlertGridHomes &&
                                  configDestroyed.useDestroyObjects;

            if (isMarkerUse)
                timerUpdateMarkers = timer.Every(60f, MarkerUpdate);
            
            useIpHub = !String.IsNullOrWhiteSpace(config.vpnSetting.iPHubToken);
            useVpnApi = !String.IsNullOrWhiteSpace(config.vpnSetting.vpnApiIoToken);
            useProxyCheck = !String.IsNullOrWhiteSpace(config.vpnSetting.proxyCheckIo);
            maxDetectedVpn = (config.vpnSetting.countDetectedToKickInVPN <= 0 ? 1 : config.vpnSetting.countDetectedToKickInVPN);
            
            if(RustApp)
                if (RustApp.Version < new VersionNumber(1, 9, 2))
                {
                    PrintWarning(LanguageEn ? "" : "У вас установлен RustApp версии ниже 1.9.2 - плагины не смогут взаимодействовать! Обновите плагин RustApp..");
                }
        }
        private const String VendingPrefab = "assets/prefabs/deployable/vendingmachine/vending_mapmarker.prefab";

        private Boolean TryParseTimeSpan(String source, out Double timeSpan)
        {
            Int32 seconds = 0, minutes = 0, hours = 0, days = 0;

            MatchCollection matches = Regex.Matches(source, @"(\d+)([smhd])", RegexOptions.IgnoreCase);

            foreach (Match match in matches)
            {
                Int32 value = int.Parse(match.Groups[1].Value);
                Char unit = match.Groups[2].Value.ToLower()[0];
		   		 		  						  	   		  		 			  	   		  		  		   		 
                switch (unit)
                {
                    case 's':
                        seconds += value;
                        break;
                    case 'm':
                        minutes += value;
                        break;
                    case 'h':
                        hours += value;
                        break;
                    case 'd':
                        days += value;
                        break;
                }
            }

            source = Regex.Replace(source, @"(\d+)[smhd]", String.Empty, RegexOptions.IgnoreCase);

            if (!String.IsNullOrEmpty(source) || (seconds == 0 && minutes == 0 && hours == 0 && days == 0))
            {
                timeSpan = 0;
                return false;
            }

            timeSpan = new TimeSpan(days, hours, minutes, seconds).TotalSeconds;
            return true;
        }
        private const String permissionsUnBan = "iqbansystem.unban";
        private Dictionary<UInt64, Dictionary<UInt64, TeamLocalMemory>> teamLocalMemory = new();
        
        
        
                
        private void PullOutTeamsInfo(BasePlayer player)
        {
            RelationshipManager.PlayerTeam team = player.Team;
            if (team == null) return;
            //PrintToChat("Pull Out Teams");
            TeamAdded(team);
        }
        
        private Boolean IsIpAdress(String mbIP) => Regex.IsMatch(mbIP, patternIP);
        
        
        private void KickCommand(BasePlayer ownerCommand, String[] arg)
        {
            if (arg == null)
            {
                SendInfo(ownerCommand, LanguageEn ? "Use syntax: kick SteamID/IP/Name* Reason\nItems marked with * are mandatory" : "Используйте синтаксис : kick SteamID/IP/Name* Причина\nПункты помеченные `*` - это обязательные пункты");
                return;
            }
            
            if (ownerCommand != null)
                if (!permission.UserHasPermission(ownerCommand.UserIDString, permissionsKick))
                    return;
		   		 		  						  	   		  		 			  	   		  		  		   		 
            if (arg.Length < 1)
            {
                SendInfo(ownerCommand, LanguageEn ? "Use syntax: kick SteamID/IP/Name* Reason\nItems marked with * are mandatory" : "Используйте синтаксис : kick SteamID/IP/Name* Причина\nПункты помеченные `*` - это обязательные пункты");
                return;
            }

            String userParams = arg[0];
            IPlayer iPlayer = GetIPlayer(userParams);
            if (iPlayer == null)
            {
                SendInfo(ownerCommand, LanguageEn ? "Couldn't find a player" : "Не удалось найти игрока");
                return;
            }
            
            String reasonArg = String.Empty;
            if (arg.Length >= 2)
            {
                if (!String.IsNullOrWhiteSpace(arg[1]))
                    reasonArg = arg[1];
            }
            
            KickUser(iPlayer, reasonArg, ownerCommand);
        }
        private Connection sqlConnection = null;

        /// <summary>
        /// Returned unbanTime. -1 = permanent
        /// </summary>
        /// <param name="idOrIP"></param>
        /// <returns></returns>
        private Double GetUnbanTime(String idOrIP)
        {
            TypeAction typeAction = TypeAction.BannedSteamID;
            if (IsIpAdress(idOrIP))
                typeAction = TypeAction.BannedIP;
            
            PlayerInfo pInfo = PlayerInfo.Get(idOrIP, typeAction);
            if (pInfo == null) return 0;
            if (pInfo.permanent) return -1;
            
            return pInfo.GetUnbanTime;
        }
        
        
        
                
        private void BanUserOrIp(String idPlayer, String displayName, String ipAdress, String reason, Double banTime, TypeAction type, 
            BasePlayer ownerAction = null, Boolean skipTeam = false)  
        {
            if (permission.UserHasPermission(idPlayer, permissionIgnoreBan)) return;

            Boolean isBannedIP = type == TypeAction.BannedIP;
            String valueImported = isBannedIP ? ipAdress : idPlayer;

            PlayerInfo PlayerBanned = PlayerInfo.Get(valueImported, type);
            if (PlayerBanned != null && PlayerBanned.IsBanned()) return;

                        Configuration.BannedSetting.DestroyedAfterBannedSetting configDestroyed = config.bannedSetting.destroyedAfterBannedSetting;

            String ownerBanned = ownerAction == null ? "Console" : $"{ownerAction.displayName}({ownerAction.userID})";
            Boolean isPermanent = banTime <= 0;

            String banReason = String.IsNullOrWhiteSpace(reason) ? "Banned" : reason;
            String kickReason = isPermanent ? GetLang("BANNED_DEFAULT_REASON_PERMANENT", idPlayer) :
                GetLang("BANNED_DEFAULT_REASON", idPlayer, FormatTime(banTime, idPlayer));

            if (!String.IsNullOrWhiteSpace(reason))
            {
                kickReason = isPermanent ? GetLang("BANNED_ALERT_PERMANENT", idPlayer, reason) :
                    GetLang("BANNED_ALERT_TIME", idPlayer, reason, FormatTime(banTime, idPlayer));
            }
            
                        
                        
            String formatTime = DateTime.Now.ToString("HH:mm dd:MM:yyyy");
            List<PlayerInfo.History> nameHistory = String.IsNullOrWhiteSpace(displayName) ? new List<PlayerInfo.History>() : new List<PlayerInfo.History> { new() { value = displayName, time = formatTime } };
            List<PlayerInfo.History> ipHistory = String.IsNullOrWhiteSpace(ipAdress) ? new List<PlayerInfo.History>() : new List<PlayerInfo.History> { new() { value = ipAdress, time = formatTime } };
            List<PlayerInfo.History> steamIdHistory = String.IsNullOrWhiteSpace(idPlayer) ? new List<PlayerInfo.History>() : new List<PlayerInfo.History> { new() { value = idPlayer, time = formatTime } };

            PlayerInfo.Import(valueImported, new PlayerInfo
            {
                permanent = isPermanent,
                timeUnbanned = banTime + CurrentTime,
                reason = banReason,
                nameHistory = nameHistory,
                ipHistory = ipHistory,
                steamIdHistory = steamIdHistory,
                serverName = config.generalSetting.serverName, 
                serverAdress = config.generalSetting.serverAdress,
                owner = ownerBanned,
            }, type);

            IPlayer bannedPlayer = GetIPlayer(valueImported);
            UInt64 userID = 0;
            if(bannedPlayer != null)
                userID = UInt64.Parse(bannedPlayer.Id);
            else if(valueImported.IsSteamId())
                userID = UInt64.Parse(valueImported);
            Boolean isValidID = userID.IsSteamId();
            
            if (IsOpenMySQL())
                InserOrUpdateDatabase(valueImported, type, bannedPlayer);

            if (isBannedIP) 
                Interface.CallHook("OnBannedPlayerIP", ipAdress, reason, banTime, ownerAction);
            else Interface.CallHook("OnBannedPlayerID", userID, reason, banTime, ownerAction);

            
            List<String> posInGridDestroyed = Facepunch.Pool.Get<List<String>>();
            List<IPlayer> teamsBanneds = Facepunch.Pool.Get<List<IPlayer>>();
            
            if(bannedPlayer != null)
                if (config.bannedSetting.teamBannedSetting.useBlockTeam && !skipTeam && isValidID)
                    teamsBanneds = BannedTeams(userID, ownerAction);

            String playerBannedName = type == TypeAction.BannedIP ? ipAdress : !String.IsNullOrWhiteSpace(displayName) ? displayName : "Unknown";
            String playerBannedNameAlert = type == TypeAction.BannedIP ? ipAdress : !String.IsNullOrWhiteSpace(displayName) ? $"{displayName}({(String.IsNullOrWhiteSpace(idPlayer) ? "Unknown" : idPlayer)})" : "Unknown";

            
            if (config.bannedSetting.useKilledPlayer && bannedPlayer != null && isValidID)
            {
                BasePlayer bPlayer = BasePlayer.FindAwakeOrSleepingByID(userID);
                if (bPlayer != null) 
                    bPlayer.Hurt(1000f, DamageType.Suicide);
            }
                        
                        
            if (configDestroyed.useDestroyObjects)
            {
                if (bannedPlayer != null)
                    posInGridDestroyed = DestroyObjectBanned(bannedPlayer, playerBannedName); 
            }

            
                        
            if (config.generalSetting.additionalSetting.useAlertAllPlayers)
            {
                foreach (BasePlayer basePlayer in BasePlayer.activePlayerList)
                {
                    String banTimeFormat = isPermanent
                        ? GetLang("ALERT_ALL_TITILE_PERMANENT", basePlayer.UserIDString)
                        : FormatTime(banTime, basePlayer.UserIDString);

                    String reasonAlert = GetLang(banReason, basePlayer.UserIDString);
                    String ownerBannedAlert = ownerAction == null ? GetLang("ALERT_ALL_TITILE_ADMIN_BANNED", basePlayer.UserIDString) : ownerAction.displayName;
                    String playerNameAlert = GetLang(playerBannedName, basePlayer.UserIDString);
                    
                    String messagePlayers = GetLang("ALERT_ALL_PLAYER_BANNED", basePlayer.UserIDString, playerNameAlert, reasonAlert, banTimeFormat, ownerBannedAlert);

                    if (config.bannedSetting.teamBannedSetting.useBlockTeam && config.generalSetting.additionalSetting.useAlertBlockTeam && teamsBanneds != null && teamsBanneds.Count != 0)
                        messagePlayers += GetLang("ALERT_ALL_BANNED_TEAMS", basePlayer.UserIDString, String.Join(", ", teamsBanneds.Select(player => player.Name)));

                    if (configDestroyed.useDestroyObjects && configDestroyed.useAlertGridHomes && posInGridDestroyed != null && posInGridDestroyed.Count != 0)
                    {
                        String alertMessage = configDestroyed.typeDestroyed switch
                        {
                            TypeDestroy.AllObjectsAndDropInStorage => "ALERT_ALL_ADDITIONAL_DESTROY",
                            TypeDestroy.OnlyLocks => "ALERT_ALL_ADDITIONAL_DESTROY_ONLY_CODE_LOCK",
                            TypeDestroy.AllObjects => "ALERT_ALL_ADDITIONAL_DESTROY_CLEAR_STORAGE",
                            TypeDestroy.OnlyStorageAndDropInStorage => "ALERT_ALL_ADDITIONAL_DESTROY_ONLY_STORAGE",
                            _ => "ALERT_ALL_ADDITIONAL_DESTROY_ONLY_STORAGE_CLEAR"
                        };
                        
                        messagePlayers += GetLang(alertMessage, basePlayer.UserIDString,
                            String.Join(", ", posInGridDestroyed));
                        
                        if (configDestroyed.mapMarkerDestroyedObjectSetting.useMapMarkerDestroyedObjectPlayer)
                            if (TryParseTimeSpan(configDestroyed.mapMarkerDestroyedObjectSetting.markerLifeTime, out Double markerLife)) 
                                messagePlayers += GetLang("ALERT_ALL_USE_MARKER", basePlayer.UserIDString, FormatTime(markerLife, idPlayer));
                    }
                    
                    SendChat(messagePlayers, basePlayer);

                    if (skipTeam) continue;
                    String soundPath = config.generalSetting.additionalSetting.effectAlertAllPlayers;
                    if (soundPath != null && !String.IsNullOrWhiteSpace(soundPath))
                        RunEffect(basePlayer, soundPath);
                }
            }
            
                        
            if (bannedPlayer is { IsConnected: true }) 
                bannedPlayer.Kick(banReason);
            
            if(isValidID && isPermanent)
                SetTirifyBan(userID.ToString(), reason);
            
            String messageAlert = LanguageEn
                ? $"Player {playerBannedNameAlert} has been banned.\nBan Time: {(isPermanent ? "permanent" : FormatTime(banTime, null))}.\nReason: {banReason}.\nIssued by: {ownerBanned}"
                : $"Игрок {playerBannedNameAlert} заблокирован.\nВремя блокировки : {(isPermanent ? "навсегда" : FormatTime(banTime, null))}.\nПричина : {banReason}.\nВыдал блокировку : {ownerBanned}";
          
            Puts(messageAlert);

            String webhookBanned = config.generalSetting.discordSetting.alertBanned.webHookBanned;
            if (!String.IsNullOrWhiteSpace(webhookBanned))
            {
                List<Fields> fieldsBanned = new List<Fields>
                {
                    new Fields(type == TypeAction.BannedIP ? "IP" : LanguageEn ? "Player" : "Игрок", playerBannedNameAlert, true),
                    new Fields(LanguageEn ? "Issued by" : "Выдал блокировку", ownerBanned, true),
                    new Fields("", "", false),
                    new Fields(LanguageEn ? "Ban Time" : "Время блокировки", (isPermanent ? (LanguageEn ? "permanent" : "навсегда") : FormatTime(banTime, null)), true),
                    new Fields(LanguageEn ? "Reason" : "Причина", banReason, true),
                    new Fields("", "", false),
                };

                if (config.bannedSetting.teamBannedSetting.useBlockTeam && config.generalSetting.additionalSetting.useAlertBlockTeam && teamsBanneds != null && teamsBanneds.Count != 0)
                {
                    fieldsBanned.Add(new Fields(LanguageEn ? "Banneds teams" : "Заблокированные тиммейты", String.Join(", ", teamsBanneds.Select(player => player.Name)), false));
                    fieldsBanned.Add(new Fields("", "", false));
                }    
                
                if(posInGridDestroyed != null && posInGridDestroyed.Count != 0)
                {
                    fieldsBanned.Add(new Fields(LanguageEn ? "Destroyed buildings of the player in squares" : "Разрушенные строения игрока в квадратах", String.Join(", ", posInGridDestroyed), false));
                    fieldsBanned.Add(new Fields("", "", false));
                }

                if (config.generalSetting.discordSetting.alertBanned.cupboardAuthInfo)
                {
                    if (isValidID)
                    {
                        Dictionary<Vector3, String> infoCupboards = GetAuthCupboardPlayer(userID);
                        fieldsBanned.Add(new Fields(LanguageEn ? "Houses where the player is logged in" : "Дома в которых авторизован игрок", infoCupboards.Count == 0 ? (LanguageEn ? "Empty" : "Пусто") : String.Join("\n", infoCupboards.Select(kv => $"{kv.Value} - {kv.Key}")), false));
                        fieldsBanned.Add(new Fields("", "", false));
                    }
                }
                
                if (config.generalSetting.discordSetting.alertBanned.teamsAlert.saveInfoTeams)
                {
                    if (isValidID)
                    {
                        String timePlayeingInConfig = config.generalSetting.discordSetting.alertBanned.teamsAlert.formatTimePlaying;
                        if (TryParseTimeSpan(timePlayeingInConfig, out Double timePlaying))
                        {
                            Dictionary<UInt64, Double> teamMemory = GetTeamsBannedPlayer(userID);
                            
                                String resultTeams = teamMemory == null || teamMemory.Count == 0
                                    ? (LanguageEn ? "Empty" : "Пусто")
                                    : String.Join("\n",
                                        teamMemory.Where(memory => memory.Value > timePlaying && memory.Key != userID)
                                            .Select(memory =>
                                            {
                                                IPlayer iPlayer = GetIPlayer($"{memory.Key}");
                                                return iPlayer != null ? $"{iPlayer.Name} - {memory.Key}" : $"Unknown - {memory.Key}";
                                            }));
                                
                                resultTeams = String.IsNullOrWhiteSpace(resultTeams)
                                    ? (LanguageEn ? "Empty" : "Пусто")
                                    : resultTeams;

                                fieldsBanned.Add(new Fields(LanguageEn ? $"Players who have been blocked for more than {GetFormatTimeDiscord(timePlayeingInConfig)}" : $"Игроки с которым играл заблокированный более {GetFormatTimeDiscord(timePlayeingInConfig)}", resultTeams, false));
                                fieldsBanned.Add(new Fields("", "", false));
                        }
                    }
                }

                fieldsBanned.Add(new Fields(LanguageEn ? "History nick" : "История ников", nameHistory == null || nameHistory.Count == 0? (LanguageEn ? "Empty" : "Пусто") : String.Join("\n", nameHistory.Select(ph => $"{ph.time} - {ph.value}")), false));
                fieldsBanned.Add(new Fields(LanguageEn ? "History Steam64ID" : "История Steam64ID", steamIdHistory == null || steamIdHistory.Count == 0 ? (LanguageEn ? "Empty" : "Пусто") : String.Join("\n", steamIdHistory.Select(ph => $"{ph.time} - {ph.value}")), false));
                fieldsBanned.Add(new Fields(LanguageEn ? "History IPs" : "История IP", ipHistory == null || ipHistory.Count == 0 ? (LanguageEn ? "Empty" : "Пусто") : String.Join("\n", ipHistory.Select(ph => $"{ph.time} - {ph.value}")), false));
                fieldsBanned.Add(new Fields("", "", false));
                
                SendDiscord(fieldsBanned, TypeAlertDiscord.Banned, webhookBanned);
            }
            
            Facepunch.Pool.FreeUnmanaged(ref posInGridDestroyed);
            Facepunch.Pool.FreeUnmanaged(ref teamsBanneds);

            if (IQTeleportation && isValidID)
                IQTeleportation.CallHook("ClearHomesPlayer", userID, "IQBanSystem");
        }
        
        private const String permissionsBan = "iqbansystem.ban";
        void WriteData() {
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQBanSystem/ListGodIps", ipListGods);
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQBanSystem/TeamsMemory", teamLocalMemory);
        }
        private static Double CurrentTime => DateTime.UtcNow.Subtract(epoch).TotalSeconds;
        
        private IPlayer GetIPlayer(String userParams)
        {
            if (UInt64.TryParse(userParams, out UInt64 userID))
            {
                BasePlayer basePlayerByID = BasePlayer.FindByID(userID);
                if (basePlayerByID)
                    return basePlayerByID.IPlayer;

                BasePlayer sleepingPlayer = BasePlayer.sleepingPlayerList.FirstOrDefault(p => p.userID == userID);
                if (sleepingPlayer)
                    return sleepingPlayer.IPlayer;
		   		 		  						  	   		  		 			  	   		  		  		   		 
                IPlayer iPlayer = covalence.Players.FindPlayerById(userParams);
                if (iPlayer != null)
                    return iPlayer;
            }

            if (IsIpAdress(userParams))
            {
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    if (player.net?.connection?.ipaddress != null && player.net.connection.ipaddress.StartsWith(userParams))
                        return player.IPlayer;
                }

                foreach (BasePlayer player in BasePlayer.sleepingPlayerList)
                {
                    if (player.net?.connection?.ipaddress != null && player.net.connection.ipaddress.StartsWith(userParams))
                        return player.IPlayer;
                }
            }
		   		 		  						  	   		  		 			  	   		  		  		   		 
            BasePlayer activePlayer = BasePlayer.activePlayerList.FirstOrDefault(p => String.Equals(p.displayName, userParams, StringComparison.OrdinalIgnoreCase));
            if (activePlayer != null)
                return activePlayer.IPlayer;

            BasePlayer sleepingPlayerByName = BasePlayer.sleepingPlayerList.FirstOrDefault(p => String.Equals(p.displayName, userParams, StringComparison.OrdinalIgnoreCase));
            if (sleepingPlayerByName != null)
                return sleepingPlayerByName.IPlayer;

            List<BasePlayer> matchingPlayers = new List<BasePlayer>();
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (player.displayName.IndexOf(userParams, StringComparison.OrdinalIgnoreCase) >= 0)
                    matchingPlayers.Add(player);
            }

            foreach (BasePlayer player in BasePlayer.sleepingPlayerList)
            {
                if (player.displayName.IndexOf(userParams, StringComparison.OrdinalIgnoreCase) >= 0)
                    matchingPlayers.Add(player);
            }

            switch (matchingPlayers.Count)
            {
                case 1: return matchingPlayers[0].IPlayer;
                case > 1:
                {
                    String playerNames = "";
                    for (Int32 i = 0; i < matchingPlayers.Count; i++)
                    {
                        playerNames += matchingPlayers[i].displayName;
                        if (i < matchingPlayers.Count - 1)
                            playerNames += ", ";
                    }

                    Puts(LanguageEn ? $"Specify the nickname or use the ID.\nPossible players with a similar nickname : {playerNames}" : $"Уточните ник или используйте ID.\nВозможные игроки с похожим ником : {playerNames}");
                    return null;
                }
            }

            IPlayer covalencePlayer = covalence.Players.FindPlayer(userParams);
            return covalencePlayer ?? null;
        }
        
        private class PlayerInfo : SplitDatafile<PlayerInfo>
        {
                        
            private const String BaseFolder = "IQSystem" + "/" + "IQBanSystem" + "/";
            private const String UserFolder = "UserBanned" + "/";
            private const String IpFolder = "IPBanned" + "/";

            private static String GetFolder(TypeAction typeBanned) =>
                typeBanned == TypeAction.BannedIP ? BaseFolder + IpFolder : BaseFolder + UserFolder;
            public static PlayerInfo Save(String idOrIp, TypeAction type) => Save(type, GetFolder(type), idOrIp);
            public static void Import(String idOrIp, PlayerInfo data, TypeAction type) => Import(type, GetFolder(type), idOrIp, data);
            public static void Remove(String idOrIp, TypeAction type) => Remove(type, GetFolder(type), idOrIp);
            public static PlayerInfo Get(String idOrIp, TypeAction type) => Get(type, GetFolder(type), idOrIp);
            public static PlayerInfo Load(String idOrIp, TypeAction type) => Load(type, GetFolder(type), idOrIp);
            public static PlayerInfo Clear(String idOrIp, TypeAction type) => ClearAndSave(type, GetFolder(type), idOrIp);
            public static PlayerInfo GetOrLoad(String idOrIp, TypeAction type) => GetOrLoad(type, GetFolder(type), idOrIp);
            public static PlayerInfo GetOrCreate(String idOrIp, TypeAction type) => GetOrCreate(type, GetFolder(type), idOrIp);
            public static String[] GetFiles(TypeAction type) => GetFiles(GetFolder(type));
            
            
            public Boolean permanent = false;
            public Double timeUnbanned;
            public String reason;
            public String serverName;
            public String serverAdress;
            public String owner;

            public List<History> nameHistory = new();
            public List<History> ipHistory = new();
            public List<History> steamIdHistory = new();

            internal class History
            {
                public String value;
                public String time;
            }
            
            [JsonIgnore] public Double GetUnbanTime => timeUnbanned - CurrentTime;

            public Boolean IsBanned()
            {
                if (permanent) return true;
                return GetUnbanTime > 0;
            }
            public void UpdateHistory(TypeHistoryInfo typeInfo, String value) 
            {
                List<History> historyList = GetHistoryList(typeInfo);
                if (IsExistsValueHistory(historyList, value)) return;

                historyList.Insert(0, new History
                {
                    time = DateTime.Now.ToString("HH:mm dd:MM:yyyy"),
                    value = value,
                });
            }

            private List<History> GetHistoryList(TypeHistoryInfo typeInfo)
            {
                return typeInfo switch
                {
                    TypeHistoryInfo.Name => nameHistory,
                    TypeHistoryInfo.IP => ipHistory,
                    TypeHistoryInfo.SteamID => steamIdHistory,
                    _ => throw new ArgumentOutOfRangeException(nameof(typeInfo), typeInfo, null),
                };
            }

            private Boolean IsExistsValueHistory(List<History> histories, String value)
            {
                foreach (History history in histories)
                {
                    if (!history.value.Equals(value)) continue;
                    history.time = DateTime.Now.ToString("HH:mm dd:MM:yyyy");
                    return true;
                }

                return false;
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning(LanguageEn
                    ? $"Error reading #54327 configuration 'oxide/config/{Name}', creating a new configuration!!"
                    : $"Ошибка чтения #54327 конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

                
                
        private abstract class SplitDatafile<T> where T : SplitDatafile<T>, new()
        {
            public static Dictionary<String, T> _players = new();
            public static Dictionary<String, T> _ipAdresses = new();
            public static Dictionary<String, T> _savedItems = new();

            private static Dictionary<String, T> GetRepository(TypeAction type) =>
                type switch
                {
                    TypeAction.BannedIP => _ipAdresses,
                    TypeAction.BannedSteamID => _players,
                    _ => _savedItems
                };
            
            protected static void Import(TypeAction type, String baseFolder, String userId, T data)
            {
                Dictionary<String, T> repository = GetRepository(type);
                repository[userId] = data;

                Save(type, baseFolder, userId);
            }

            protected static String[] GetFiles(String baseFolder)
            {
                try
                {
                    Int32 json = ".json".Length;
                    String[] paths = Interface.Oxide.DataFileSystem.GetFiles(baseFolder, "*.json");
                    for (Int32 i = 0; i < paths.Length; i++)
                    {
                        String path = paths[i];
                        Int32 separatorIndex = path.LastIndexOf("/", StringComparison.Ordinal);
                        paths[i] = path.Substring(separatorIndex + 1, path.Length - separatorIndex - 1 - json);
                    }

                    return paths;
                }
                catch
                {
                    return Array.Empty<string>();
                }
            }

            protected static T Save(TypeAction type, string baseFolder, String userId)
            {
                Dictionary<String, T> repository = GetRepository(type);

                T data;
                if (!repository.TryGetValue(userId, out data))
                    return null;

                Interface.Oxide.DataFileSystem.WriteObject(baseFolder + userId, data);
                return data;
            }
            
            protected static void Remove(TypeAction type, string baseFolder, String userId)
            {
                Dictionary<String, T> repository = GetRepository(type);

                if (!repository.ContainsKey(userId))
                    return;

                repository.Remove(userId);
                Interface.Oxide.DataFileSystem.DeleteDataFile(baseFolder + userId);
            }

            protected static T Get(TypeAction type, string baseFolder, String userId)
            {
                Dictionary<String, T> repository = GetRepository(type);

                T data;
                if (repository.TryGetValue(userId, out data))
                    return data;

                return null;
            }

            protected static T Load(TypeAction type, String baseFolder, String userId)
            {
                Dictionary<String, T> repository = GetRepository(type);

                T data = null;

                try
                {
                    data = Interface.Oxide.DataFileSystem.ReadObject<T>(baseFolder + userId);
                }
                catch (Exception e)
                {
                    Interface.Oxide.LogError(e.ToString());
                }

                return repository[userId] = data;
            }

            protected static T GetOrLoad(TypeAction type, String baseFolder, String userId)
            {
                Dictionary<String, T> repository = GetRepository(type);

                T data;
                if (repository.TryGetValue(userId, out data))
                    return data;


                return Load(type, baseFolder, userId);
            }

            protected static T GetOrCreate(TypeAction type, String baseFolder, String userId)
            {
                Dictionary<String, T> repository = GetRepository(type);

                return GetOrLoad(type, baseFolder, userId) ?? (repository[userId] = new T());
            }

            protected static T ClearAndSave(TypeAction type, String baseFolder, String userId)
            {
                Dictionary<String, T> repository = GetRepository(type);

                T data;
                if (repository.TryGetValue(userId, out data))
                {
                    data = new T();
		   		 		  						  	   		  		 			  	   		  		  		   		 
                    Interface.Oxide.DataFileSystem.WriteObject(baseFolder + userId, data);
                    return data;
                }
		   		 		  						  	   		  		 			  	   		  		  		   		 
                return null;
            }
        }
        
        private void BanIp(String IpAdress, IPlayer iPlayer = null, String reason = default, Double banTime = 0, BasePlayer ownerCommand = null, Boolean skipTeam = false)
        {
            String displayName = iPlayer?.Name ?? String.Empty;
            String idPlayer = iPlayer?.Id ?? String.Empty;

            BanUserOrIp(idPlayer, displayName, IpAdress, reason, banTime, TypeAction.BannedIP, ownerCommand, skipTeam);
        }
        
        object OnTeamLeave(RelationshipManager.PlayerTeam team, BasePlayer player)
        {
            LeaveTeamPlayer(player.userID);
            return null;
        }
        
                
                
        private static Configuration config = new Configuration();

        private const String patternIP = @"^\b(?:\d{1,3}\.){3}\d{1,3}\b$";

        
        
                
        
        private void BanCommand(BasePlayer ownerCommand, String[] arg)
        {
            if (arg == null)
            {
                SendInfo(ownerCommand, LanguageEn ? "Use the syntax: ban SteamID/IP/Name* Time(1s/1m/1h/1d) Reason\nItems marked with `*` are mandatory" : "Используйте синтаксис : ban SteamID/IP/Name* Время(1s/1m/1h/1d) Причина\nПункты помеченные `*` - это обязательные пункты");
                return;
            }
            
            if (ownerCommand != null)
                if (!permission.UserHasPermission(ownerCommand.UserIDString, permissionsBan))
                    return;

            if (arg.Length < 1)
            {
                SendInfo(ownerCommand, LanguageEn ? "Use the syntax: ban SteamID/IP/Name* Time(1s/1m/1h/1d) Reason\nItems marked with `*` are mandatory" : "Используйте синтаксис : ban SteamID/IP/Name* Время(1s/1m/1h/1d) Причина\nПункты помеченные `*` - это обязательные пункты");
                return;
            }

            String userParams = arg[0];
            UInt64 targetUserID = 0;
            IPlayer iPlayer = GetIPlayer(userParams);

            Boolean isIp = IsIpAdress(userParams);

            if (!isIp)
            {
                if (!UInt64.TryParse(userParams, out targetUserID))
                {
                    if (iPlayer == null)
                    {
                        SendInfo(ownerCommand, LanguageEn ? "Couldn't find a player" : "Не удалось найти игрока");
                        return;
                    }
                    targetUserID = UInt64.Parse(iPlayer.Id);
                }
            }
            
            Double banTime = 0;
            String reasonArg = String.Empty;

            if (arg.Length >= 2)
            {
                String potentialTime = arg[1];
		   		 		  						  	   		  		 			  	   		  		  		   		 
                if (!String.IsNullOrWhiteSpace(potentialTime) && TryParseTimeSpan(potentialTime, out banTime))
                    reasonArg = arg.Length > 2 ? String.Join(" ", arg.Skip(2)) : null;
                else reasonArg = String.Join(" ", arg.Skip(1));
            }

            if (isIp) 
                BanIp(userParams, iPlayer, reasonArg, banTime, ownerCommand);
            else BanUser(targetUserID, iPlayer, reasonArg, banTime, ownerCommand);
        }

        private void HandlerSteam(IPlayer player, Int32 code, String response)
        {
            if (code != 200 || string.IsNullOrEmpty(response))
            {
                ResponseError("Steam", $"{code}");
                return;
            }
            
            Dictionary<String, Object> jsonresponse;
            try { jsonresponse = JsonConvert.DeserializeObject<Dictionary<String, Object>>(response); }
            catch (JsonReaderException e)
            {
                ResponseError("Steam", e.Message);
                return;
            }
		   		 		  						  	   		  		 			  	   		  		  		   		 
            if (!jsonresponse.TryGetValue("response", out Object value))
            {
                ResponseError("Steam", "Response == null");
                return;
            }
            
            JToken playerData = ((JObject)value)["players"]?[0];
            if (playerData == null)
            {
                ResponseError("Steam", "playerData == null");
                return;
            }
            
            Int64? accountCreationDate = (Int64?)playerData["timecreated"];
            webrequest.Enqueue(
                $"https://api.steampowered.com/IPlayerService/GetOwnedGames/v1/?key={config.steamSetting.steamApiKey}&steamid={player.Id}&include_played_free_games=1",
                String.Empty,
                (gameCode, gameResponse) => 
                    HandleGameTimes(player, accountCreationDate, gameCode, gameResponse), this, timeout: 10f);
        }

        private void MarkerUpdate()
        {
            for (Int32 i = 0; i < mapMarkers.Count; i++)
            {
                MarkerRepository marker = mapMarkers[i];
                TimeSpan timeSpan = DateTime.Now - marker.timeSetMarker;
                Double totalSeconds = timeSpan.TotalSeconds;

                if (!TryParseTimeSpan(config.bannedSetting.destroyedAfterBannedSetting.mapMarkerDestroyedObjectSetting.markerLifeTime, out Double markerUpdate))
                {
                    PrintError(LanguageEn ? "Incorrect marker update time format. The marker has been deleted." : "Некорректный формат времени обновления маркера. Маркер был удален.");
                    
                    if(!marker.vending.IsDestroyed)
                        marker.vending.Kill();
                    
                    if(!marker.marker.IsDestroyed)
                        marker.marker.Kill();
                    
                    mapMarkers.Remove(marker);
                } 

                if(totalSeconds < markerUpdate) continue;
                
                if(!marker.vending.IsDestroyed)
                    marker.vending.Kill();
                    
                if(!marker.marker.IsDestroyed)
                    marker.marker.Kill();

                mapMarkers.Remove(marker);
            }
        }

        public String FormatTime(Double Second, String UserID = null)
        {
            TimeSpan time = TimeSpan.FromSeconds(Second);
            String Result = String.Empty;
            String Days = GetLang("TITLE_FORMAT_DAYS", UserID);
            String Hourse = GetLang("TITLE_FORMAT_HOURSE", UserID);
            String Minutes = GetLang("TITLE_FORMAT_MINUTES", UserID);
            String Seconds = GetLang("TITLE_FORMAT_SECONDS", UserID);

            if (time.Seconds != 0)
                Result = $"{Format(time.Seconds, Seconds, Seconds, Seconds)}";

            if (time.Minutes != 0)
                Result = $"{Format(time.Minutes, Minutes, Minutes, Minutes)}";

            if (time.Hours != 0)
                Result = $"{Format(time.Hours, Hourse, Hourse, Hourse)}";

            if (time.Days != 0)
                Result = $"{Format(time.Days, Days, Days, Days)}";

            return Result;
        }
        
        
                void HandlerProxyCheckIo(Int32 code, String response, String adress)
        {
            ProcessCheckVPN processChecked = ipListChecked[adress];
            if (code != 200 || string.IsNullOrEmpty(response))
            {
                ResponseError("ProxyCheckIO", $"{code}");
                processChecked.isCompleteProxyCheck = true;
                return;
            }

            JObject jsonResponse;
            try { jsonResponse = JObject.Parse(response); }
            catch (JsonReaderException e)
            {
                ResponseError("ProxyCheckIO", e.Message);
                processChecked.isCompleteProxyCheck = true;
                return;
            }

            String status = jsonResponse["status"]?.ToString();
            if (!status.Equals("ok"))
            {
                String message = jsonResponse["message"]?.ToString();
                ResponseError("ProxyCheckIO", $"{status} : {message}");
                processChecked.isCompleteProxyCheck = true;
                return;
            }

            foreach (JProperty ipInfoProperty in jsonResponse.Properties())
            {
                if (ipInfoProperty.Name.Equals("status", StringComparison.OrdinalIgnoreCase))
                    continue;

                JToken ipInfo = ipInfoProperty.Value;
		   		 		  						  	   		  		 			  	   		  		  		   		 
                if (ipInfo["proxy"] != null && ipInfo["type"] != null)
                {
                    String proxy = ipInfo["proxy"].ToString();
                    String type = ipInfo["type"].ToString();

                    if (proxy.Equals("yes", StringComparison.OrdinalIgnoreCase) ||
                        type.Equals("VPN", StringComparison.OrdinalIgnoreCase))
                    {
                        //PrintError("DETECT ");
                        processChecked.detectedVpn++;
                    }
                }
            }
            
            processChecked.isCompleteProxyCheck = true;
        }
		   		 		  						  	   		  		 			  	   		  		  		   		 
        
        
        /// <summary>
        /// Returned IsBanned status
        /// </summary>
        /// <param name="idOrIP"></param>
        /// <returns></returns>
        private Boolean IsBanned(String idOrIP)
        {
            TypeAction typeAction = TypeAction.BannedSteamID;
            if (IsIpAdress(idOrIP))
                typeAction = TypeAction.BannedIP;
            
            PlayerInfo pInfo = PlayerInfo.Get(idOrIP, typeAction);
            return pInfo != null && pInfo.IsBanned();
        }
        
        private String SQL_Query_SelectedDatabase() => $"SELECT * FROM {config.mysqlConnected.dbTableName}";

        public class Fields
        {
            public String name { get; set; }
            public String value { get; set; }
            public bool inline { get; set; }
            public Fields(String name, String value, bool inline)
            {
                this.name = name;
                this.value = value;
                this.inline = inline;
            }
        }
   
        
        private void SaveDataFiles(TypeAction type)
        {
            foreach (KeyValuePair<String, PlayerInfo> player in PlayerInfo._players)
                PlayerInfo.Save(player.Key, type);
        }

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<String, String>
            {
                ["BANNED_ALERT_TIME"] = "You are banned for the reason {0}. Unban in: {1}",
                ["BANNED_ALERT_PERMANENT"] = "You are permanently banned for the reason {0}",
                ["BANNED_DEFAULT_REASON_PERMANENT"] = "You are permanently banned from the server",
                ["BANNED_DEFAULT_REASON"] = "You are banned from the server. Unban in: {0}",
                ["KICKED_VPN_REASON"] = "You were kicked from the server for using a VPN",
                ["KICKED_DEFAULT_REASON"] = "You were kicked from the server",
                ["KICKED_STEAM_ID_INCORRECTED"] = "Incorrect SteamID",
                ["KICKED_STEAM_NEW_ACCOUNT"] = "Your account is too new to play on our server",
                ["KICKED_STEAM_NO_GAME_TIME"] = "You don't have enough playtime in RUST to play on this server",
                ["BANNED_DEFAULT_REASON_GAME_WITH_CHEATER"] = "Playing with a cheater",

                ["ALERT_ALL_PLAYER_KICKED"] = "Player <color=#CD412B>{0}</color> was kicked from the server.\nReason: <color=#CD412B>{1}</color>\nKick issued by: <color=#1F6BA0>{2}</color>",
                ["ALERT_ALL_PLAYER_BANNED"] = "Player <color=#CD412B>{0}</color> was banned from the server.\nReason: <color=#CD412B>{1}</color>\nBan duration: <color=#CD412B>{2}</color>\nBan issued by: <color=#1F6BA0>{3}</color>",
                ["ALERT_ALL_ADDITIONAL_DESTROY_ONLY_STORAGE_CLEAR"] = "\n\nAll this player's storage boxes were destroyed, and all items were deleted in the areas: <color=#C26D33>{0}</color>\nThe building was preserved, and you can claim it\n<color=#738D45>*Items will disappear over time!</color>",
                ["ALERT_ALL_ADDITIONAL_DESTROY_ONLY_STORAGE"] = "\n\nAll this player's storage boxes were destroyed, and all items were dropped on the ground in the areas: <color=#C26D33>{0}</color>\nYou can raid the building and claim the items\n<color=#738D45>*Items will disappear over time!</color>",
                ["ALERT_ALL_ADDITIONAL_DESTROY_CLEAR_STORAGE"] = "\n\nThis player's buildings were destroyed, and all items were deleted in the areas: <color=#C26D33>{0}</color>",
                ["ALERT_ALL_ADDITIONAL_DESTROY"] = "\n\nThis player's buildings were destroyed, and all items were dropped on the ground in the areas: <color=#C26D33>{0}</color>\n<color=#738D45>*Items will disappear over time!</color>",
                ["ALERT_ALL_ADDITIONAL_DESTROY_ONLY_CODE_LOCK"] = "\n\nAll this player's locks were destroyed in houses in the areas: <color=#C26D33>{0}</color>\n<color=#738D45>You are free to claim the buildings and loot</color>",
                ["ALERT_ALL_USE_MARKER"] = "\n\nAll house locations have been marked on the G-map!\nThey will be removed in: <color=#CD412B>{0}</color>",
                ["ALERT_ALL_BANNED_TEAMS"] = "\nBanned teammates: <color=#CD412B>{0}</color>",
                ["ALERT_ALL_TITILE_PERMANENT"] = "permanently",
                ["ALERT_ALL_TITILE_ADMIN_BANNED"] = "administrator",

                ["TITLE_FORMAT_DAYS"] = "D",
                ["TITLE_FORMAT_HOURSE"] = "H",
                ["TITLE_FORMAT_MINUTES"] = "M",
                ["TITLE_FORMAT_SECONDS"] = "S",
            }, this);

            lang.RegisterMessages(new Dictionary<String, String>
            {
                ["BANNED_ALERT_TIME"] = "Вы заблокированы по причине {0}. Разблокировка через : {1}",
                ["BANNED_ALERT_PERMANENT"] = "Вы заблокированы навсегда по причине {0}",
                ["BANNED_DEFAULT_REASON_PERMANENT"] = "Вы навсегда заблокированы на сервере",
                ["BANNED_DEFAULT_REASON"] = "Вы заблокированы на сервере. Разблокировка через : {0}",
                ["KICKED_VPN_REASON"] = "Вы были кикнуты с сервера за использование VPN",
                ["KICKED_DEFAULT_REASON"] = "Вы были кикнуты с сервера",
                ["KICKED_STEAM_ID_INCORRECTED"] = "Некорректный SteamID",
                ["KICKED_STEAM_NEW_ACCOUNT"] = "Ваш аккаунт слишком новый для игры на нашем сервере",
                ["KICKED_STEAM_NO_GAME_TIME"] = "Вы слишком мало времени провели в RUST для игры на сервере",
                ["BANNED_DEFAULT_REASON_GAME_WITH_CHEATER"] = "игра с нарушителем",

                ["ALERT_ALL_PLAYER_KICKED"] = "Игрок <color=#CD412B>{0}</color> был кикнут с сервере.\nПричина : <color=#CD412B>{1}</color>\nВыдал кик : <color=#1F6BA0>{2}</color>",
                ["ALERT_ALL_PLAYER_BANNED"] = "Игрок <color=#CD412B>{0}</color> был заблокирован на сервере.\nПричина : <color=#CD412B>{1}</color>\nВремя блокировки : <color=#CD412B>{2}</color>\nВыдал блокировку : <color=#1F6BA0>{3}</color>",
                ["ALERT_ALL_ADDITIONAL_DESTROY_ONLY_STORAGE_CLEAR"] = "\n\nВсе сундуки данного игрока были разрушены и все предметы удалены на квадратах : <color=#C26D33>{0}</color>\nСтроение было сохранено, вы можете завладеть им\n<color=#738D45>*Предметы исчезнут через время!</color>",
                ["ALERT_ALL_ADDITIONAL_DESTROY_ONLY_STORAGE"] = "\n\nВсе сундуки данного игрока были разрушены и все предметы были выброшены на землю на квадратах : <color=#C26D33>{0}</color>\nВы можете пробраться в строение и забрать их\n<color=#738D45>*Предметы исчезнут через время!</color>",
                ["ALERT_ALL_ADDITIONAL_DESTROY_CLEAR_STORAGE"] = "\n\nСтроения данного игрока были разрушены и все предметы удалены на квадратах : <color=#C26D33>{0}</color>",
                ["ALERT_ALL_ADDITIONAL_DESTROY"] = "\n\nСтроения данного игрока были разрушены и все предметы были выброшены на землю в квадратах : <color=#C26D33>{0}</color>\n<color=#738D45>*Предметы исчезнут через время!</color>",
                ["ALERT_ALL_ADDITIONAL_DESTROY_ONLY_CODE_LOCK"] = "\n\nВсе замки данного игрока были разрушены в домах на квадратах : <color=#C26D33>{0}</color>\n<color=#738D45>Вы вправе забрать строения и лут</color>",
                ["ALERT_ALL_USE_MARKER"] = "\n\nВсе точки домов были отмечены на G-карте!\nОни будут удалены через : <color=#CD412B>{0}</color>",
                ["ALERT_ALL_BANNED_TEAMS"] = "\nЗаблокированные тиммейты : <color=#CD412B>{0}</color>",
                ["ALERT_ALL_TITILE_PERMANENT"] = "навсегда",
                ["ALERT_ALL_TITILE_ADMIN_BANNED"] = "администратор",

                ["TITLE_FORMAT_DAYS"] = "Д",
                ["TITLE_FORMAT_HOURSE"] = "Ч",
                ["TITLE_FORMAT_MINUTES"] = "М",
                ["TITLE_FORMAT_SECONDS"] = "С",

            }, this, "ru");
        }
        
        private String Format(Int32 units, String form1, String form2, String form3)
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                return $"{units}{form1}";
		   		 		  						  	   		  		 			  	   		  		  		   		 
            if (tmp >= 2 && tmp <= 4)
                return $"{units}{form2}";

            return $"{units}{form3}";
        }
        
        private enum TypeAction
        {
            BannedIP,
            BannedSteamID,
        }

        private String SQL_Query_UpdateUser(TypeAction typeBanned)
        {
            StringBuilder queryBuilder = new StringBuilder();
            queryBuilder.Append($"UPDATE {config.mysqlConnected.dbTableName} SET ");
            
            if (typeBanned == TypeAction.BannedSteamID)
            {
                queryBuilder.Append("`steamid` = @0,");
                queryBuilder.Append("`ipAdress` = @1,");
            }
            else queryBuilder.Append("`ipAdress` = @1,");
            queryBuilder.Append("`permanent` = @2,");
            queryBuilder.Append("`timeUnbanned` = @3,");
            queryBuilder.Append("`reason` = @4,");
            queryBuilder.Append("`serverName` = @5,");
            queryBuilder.Append("`serverAdress` = @6,");
            queryBuilder.Append("`owner` = @7,");
            queryBuilder.Append("`nameHistory` = @8,");
            queryBuilder.Append("`ipHistory` = @9,");
            queryBuilder.Append("`steamIdHistory` = @10");

            if (queryBuilder[queryBuilder.Length - 1] == ',')
                queryBuilder.Remove(queryBuilder.Length - 1, 1);
		   		 		  						  	   		  		 			  	   		  		  		   		 
            queryBuilder.Append(typeBanned == TypeAction.BannedSteamID ? " WHERE `steamid` = @0" : " WHERE `ipAdress` = @1");
		   		 		  						  	   		  		 			  	   		  		  		   		 
            return queryBuilder.ToString();
        }

        private void Unload()
        {
            if (_ == null) return;
            
            if (IsOpenMySQL())
                sqlLibrary.CloseDb(sqlConnection);
            else
            {
                SaveDataFiles(TypeAction.BannedIP);
                SaveDataFiles(TypeAction.BannedSteamID);
            }
            
            if (config.vpnSetting.useSaveGodIps)
                WriteData();
            
            if (config.bannedSetting.destroyedAfterBannedSetting.mapMarkerDestroyedObjectSetting.useMapMarkerDestroyedObjectPlayer)
            {
                if (timerUpdateMarkers is { Destroyed: false })
                {
                    timerUpdateMarkers.Destroy();
                    timerUpdateMarkers = null;
                }
                
                foreach (MarkerRepository markerRepository in mapMarkers)
                {
                    if(!markerRepository.vending.IsDestroyed)
                        markerRepository.vending.Kill();
                    
                    if(!markerRepository.marker.IsDestroyed)
                        markerRepository.marker.Kill();
                }
            }
            
            _ = null;
        }

        
                
                
        private void IsAvailabilityConnection(IPlayer player)
        {
            if (permission.UserHasPermission(player.Id, permissionIgnoreBan)) return;
            
            String ipAddress = player.Address;
		   		 		  						  	   		  		 			  	   		  		  		   		 
            if (config.mysqlConnected.useMySQL)
            {
                GetUserData(player, ipAddress);
                return;
            }
            
            String userID = player.Id;
		   		 		  						  	   		  		 			  	   		  		  		   		 
            PlayerInfo playerDataSteam = PlayerInfo.Get(userID, TypeAction.BannedSteamID);
            PlayerInfo playerDataIps = PlayerInfo.Get(ipAddress, TypeAction.BannedIP);
            
            if (playerDataSteam == null && playerDataIps == null)
                return;
            
            ProcessBanData(player, playerDataSteam, TypeAction.BannedSteamID, userID, ipAddress);
            ProcessBanData(player, playerDataIps, TypeAction.BannedIP, userID, ipAddress);
        }

        
        
        private void GetUserData(IPlayer player, String ipAddress)
        {
            if (sqlConnection == null) return;
    
            String sqlQueryGetUserData = SQL_Query_GetUserData();
            Sql selectCommand = Oxide.Core.Database.Sql.Builder.Append(sqlQueryGetUserData, player.Id, ipAddress);
    
            sqlLibrary.Query(selectCommand, sqlConnection, list =>
            {
                if (list.Count > 0)
                {
                    foreach (Dictionary<String, Object> entry in list)
                    {
                        String valueImported = String.Empty;
                        TypeAction typeBanned;
                        
                        if (UInt64.TryParse((String)entry["steamid"], out UInt64 steamIdParse))
                        {
                            valueImported = player.Id;
                            typeBanned = TypeAction.BannedSteamID;
                        }
                        else
                        {
                            valueImported = (String)entry["ipAdress"];
                            typeBanned = TypeAction.BannedIP;
                        }
                        
                        if (!Int32.TryParse((String)entry["permanent"], out Int32 permanent))
                        {
                            PrintError(LanguageEn ? $"Error retrieving permanent information for player {valueImported} ({typeBanned})" : $"Ошибка получения информации permanent для игрока {valueImported}({typeBanned})");
                            return;
                        }
                        Boolean isPemanent = permanent != 0;

                        if (!Double.TryParse((String)entry["timeUnbanned"], out Double timeUnbanned))
                        {
                            PrintError(LanguageEn ? $"Error retrieving timeUnbanned information for player {{valueImported}} ({{typeBanned}})" : $"Ошибка получения информации timeUnbanned для игрока {valueImported}({typeBanned}))");
                            return;
                        }

                        if (!isPemanent && timeUnbanned - CurrentTime <= 0)
                            continue;
                        
                        String serverAdress = (String)entry["serverAdress"];
                        String reason = (String)entry["reason"];
                        String serverName = (String)entry["serverName"];
                        
                        String owner = (String)entry["owner"];
                        List<PlayerInfo.History> nameHistory = new ();
                        List<PlayerInfo.History> ipHistory = new ();
                        List<PlayerInfo.History> steamIdHistory = new ();
                        
                        String jsonNameHistory = (String)entry["nameHistory"];
                        String jsonipHistory = (String)entry["ipHistory"];
                        String jsonsteamIdHistory = (String)entry["steamIdHistory"];
                        
                        nameHistory = JsonConvert.DeserializeObject<List<PlayerInfo.History>>(jsonNameHistory);
                        ipHistory = JsonConvert.DeserializeObject<List<PlayerInfo.History>>(jsonipHistory);
                        steamIdHistory = JsonConvert.DeserializeObject<List<PlayerInfo.History>>(jsonsteamIdHistory);
                        
                        PlayerInfo.Import(valueImported, new PlayerInfo
                        {
                            permanent = isPemanent,
                            timeUnbanned = timeUnbanned,
                            reason = reason,
                            nameHistory = nameHistory,
                            ipHistory = ipHistory,
                            steamIdHistory = steamIdHistory,
                            serverName = serverName, 
                            serverAdress = serverAdress,
                            owner = owner,
                        }, typeBanned);
                        
                        PlayerInfo playerDataSteam = PlayerInfo.Get(player.Id, TypeAction.BannedSteamID);
                        PlayerInfo playerDataIps = PlayerInfo.Get(ipAddress, TypeAction.BannedIP);
            
                        if (playerDataSteam == null && playerDataIps == null)
                            return;
            
                        ProcessBanData(player, playerDataSteam, TypeAction.BannedSteamID, player.Id, ipAddress);
                        ProcessBanData(player, playerDataIps, TypeAction.BannedIP, player.Id, ipAddress);
                    }
                }
            });
        }
        
        private enum TypeHistoryInfo
        {
            Name,
            IP,
            SteamID
        }

        [ConsoleCommand("kick")] 
        private void ConsoleKickCommand(ConsoleSystem.Arg arg) => KickCommand(arg.Player(), arg.Args);

        private String GetFormatTimeDiscord(String input)
        {
            String result = Regex.Replace(input, @"(\d+)s", m => $"{m.Groups[1].Value} {(LanguageEn ? "seconds" : "секунды")}");
            result = Regex.Replace(result, @"(\d+)m", m => $"{m.Groups[1].Value} {(LanguageEn ? "minuts" : "минуты")}");
            result = Regex.Replace(result, @"(\d+)h", m => $"{m.Groups[1].Value} {(LanguageEn ? "hours" : "часов")}");
            result = Regex.Replace(result, @"(\d+)d", m => $"{m.Groups[1].Value} {(LanguageEn ? "days" : "дней")}");
		   		 		  						  	   		  		 			  	   		  		  		   		 
            return result;
        }
        
        private String BuildConnectionString(String host, Int32 port, String database, String user, String password)
        {
            return String.Format(
                "Server={0};Port={1};Database={2};User={3};Password={4};Pooling=false;default command timeout=120;Allow Zero Datetime=true;CharSet=utf8mb4;",
                host, port, database, user, password
            );
        }
		   		 		  						  	   		  		 			  	   		  		  		   		 
                
        private void Init()
        {
            _ = this;
            
            if (config.mysqlConnected.useMySQL)
                SQL_OpenConnection();
            else
            {
                LoadDataFiles(TypeAction.BannedIP);
                LoadDataFiles(TypeAction.BannedSteamID);
                
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                    OnPlayerConnected(player);
            }
            
            if(config.vpnSetting.useSaveGodIps)
                ReadData();

            if (!config.generalSetting.discordSetting.alertBanned.teamsAlert.saveInfoTeams &&
                !config.generalSetting.additionalSetting.useAlertBlockTeam && !config.bannedSetting.teamBannedSetting.useBlockTeam)
            {
                Unsubscribe(nameof(OnTeamCreated));
                Unsubscribe(nameof(OnTeamDisbanded));
                Unsubscribe(nameof(OnTeamKick));
                Unsubscribe(nameof(OnTeamLeave));
                Unsubscribe(nameof(OnTeamAcceptInvite));
            }
        }

        private void Request(String url, String payload, Action<Int32> callback = null)
        {
            Dictionary<String, String> header = new Dictionary<String, String>();
            header.Add("Content-Type", "application/json");
            webrequest.Enqueue(url, payload, (code, response) =>
            {
                if (code != 200 && code != 204)
                {
                    if (response != null)
                    {
                        try
                        {
                            JObject json = JObject.Parse(response);
                            if (code == 429)
                            {
                                Single seconds = Single.Parse(Math.Ceiling((Double)(Int32)json["retry_after"] / 1000).ToString());
                            }
                            else
                            {
                                PrintWarning($" Discord rejected that payload! Responded with \"{json["message"].ToString()}\" Code: {code}");
                            }
                        }
                        catch
                        {
                            PrintWarning($"Failed to get a valid response from discord! Error: \"{response}\" Code: {code}");
                        }
                    }
                    else
                    {
                        PrintWarning($"Discord didn't respond (down?) Code: {code}");
                    }
                }
                try
                {
                    callback?.Invoke(code);
                }
                catch (Exception ex) { }

            }, this, RequestMethod.POST, header, timeout: 10f);
        }

        private List<Int32> appIds = new() { 252490, 480 };

        private String SQL_Query_DeletedDatabase(TypeAction typeUnBanned) => $"DELETE FROM `{config.mysqlConnected.dbTableName}` WHERE " + 
                                                                             $"{(typeUnBanned == TypeAction.BannedSteamID ? "`steamid` = @0" : "`ipAdress` = @0")}";

        public String GetLang(String LangKey, String userID = null, params Object[] args)
        {
            sb.Clear();
            if (args == null) return lang.GetMessage(LangKey, this, userID);
            sb.AppendFormat(lang.GetMessage(LangKey, this, userID), args);
            return sb.ToString();
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (config.generalSetting.discordSetting.alertBanned.teamsAlert.saveInfoTeams ||
                config.generalSetting.additionalSetting.useAlertBlockTeam || config.bannedSetting.teamBannedSetting.useBlockTeam)
                PullOutTeamsInfo(player);

            Configuration.BannedSetting.DestroyedAfterBannedSetting configDestroyed = config.bannedSetting.destroyedAfterBannedSetting;
            Boolean isMarkerUse = configDestroyed.mapMarkerDestroyedObjectSetting.useMapMarkerDestroyedObjectPlayer && config.generalSetting.additionalSetting.useAlertAllPlayers && configDestroyed.useAlertGridHomes && configDestroyed.useDestroyObjects;

            if (isMarkerUse)
            {
                foreach (MarkerRepository markerRepository in mapMarkers)
                {
                    if(!markerRepository.vending.IsDestroyed)
                        markerRepository.vending.SendNetworkUpdate();
                    
                    if(!markerRepository.marker.IsDestroyed)
                        markerRepository.marker.SendNetworkUpdate();
                }
            }
        }

        
        
        private void SetTirifyBan(String steamIdString, String reason)
        {
            if (!TirifyGamePluginRust) return;
            if (!config.bannedSetting.tirifyBannedReplace) return;

            TirifyGamePluginRust.Call("SetTirifyBan", steamIdString, reason);
            Puts(LanguageEn ? $"Additional blocking was detected by the player's hardware {steamIdString} (Tirify)" : $"Выдана дополнительная блокировка по железу игроку {steamIdString} (Tirify)");
        }
        private String SQL_Query_GetUserData() => $"SELECT `steamid`, `ipAdress`, `permanent`, `timeUnbanned`, `reason`, `serverName`, `serverAdress`, `owner`, `nameHistory`, `ipHistory`, `steamIdHistory` FROM {config.mysqlConnected.dbTableName} WHERE `steamid` = @0 OR `ipAdress` = @1";
        
        [ConsoleCommand("ban")] 
        private void ConsoleBanCommand(ConsoleSystem.Arg arg) => BanCommand(arg.Player(), arg.Args);

        void OnUserConnected(IPlayer player)
        {
             if (useVpnApi || useProxyCheck)
                 CheckPlayerUsedVPN(player);

             if (!String.IsNullOrWhiteSpace(config.steamSetting.steamApiKey))
                 CheckSteamController(player);

             IsAvailabilityConnection(player);
        }
        
                
        
        private static StringBuilder sb = new StringBuilder();
        
                
        
        
                
        private void SendInfo(BasePlayer player, String message)
        {
            if (player != null)
                SendChat(message, player);
            else Puts(message);
        }

                
                private void ProcessStorageContainer(BaseEntity entityPlayer, Action<StorageContainer> action)
        {
            if (entityPlayer is not StorageContainer) return;
            StorageContainer storage = entityPlayer as StorageContainer;
            if (storage.inventory != null && storage.inventory.itemList.Count != 0)
                action(storage);
        }
		   		 		  						  	   		  		 			  	   		  		  		   		 
        
                void HandlerVpnApiIo(Int32 code, String response, String adress)
        {
            ProcessCheckVPN processChecked = ipListChecked[adress];
            if (code != 200 || string.IsNullOrEmpty(response))
            {
                ResponseError("VPNApiIO", $"{code}");
                processChecked.isCompleteVpnApi = true;
                return;
            }
            
            JObject jsonResponse;
            try { jsonResponse = JObject.Parse(response); }
            catch (JsonReaderException e)
            {
                ResponseError("VPNApiIO", e.Message);
                processChecked.isCompleteVpnApi = true;
                return;
            }

            String message = jsonResponse["message"]?.ToString();
            if (!string.IsNullOrEmpty(message))
            {
                ResponseError("VPNApiIO", message);
                processChecked.isCompleteVpnApi = true;
                return;
            }

            JToken security = jsonResponse["security"];
            if (security == null)
            {
                ResponseError("VPNApiIO", "Security information is missing in the response.");
                processChecked.isCompleteVpnApi = true;
                return;
            }

            Boolean isVpn = security["vpn"]?.ToObject<Boolean>() ?? false;
            Boolean isProxy = security["proxy"]?.ToObject<Boolean>() ?? false;

            if (isVpn || isProxy)
            {
                //PrintError("DETECT ");
                processChecked.detectedVpn++;
            }            
            processChecked.isCompleteVpnApi = true;
        }

        
        
        // [ConsoleCommand("db.steam")]
        // private void DebugSteam(ConsoleSystem.Arg arg)
        // {
        //     String steamID = "76561198434075094";//arg.Args[0];
        //     webrequest.Enqueue(
        //         $"https://api.steampowered.com/IPlayerService/GetOwnedGames/v1/?key={config.steamSetting.steamApiKey}&steamid={steamID}&include_played_free_games=1",
        //         String.Empty,
        //         (gameCode, gameResponse) =>
        //         {
        //             
        //             Dictionary<Int32, Int32> gameTimes = new();
        //             Int32 allTimeGames = 0;
        //     
        //             Dictionary<String, Object> jsonresponse;
        //             try { jsonresponse = JsonConvert.DeserializeObject<Dictionary<String, Object>>(gameResponse); }
        //             catch (JsonReaderException e)
        //             {
        //                 ResponseError("Steam", e.Message);
        //                 return;
        //             }
        //             
        //             if (jsonresponse.TryGetValue("response", out Object value))
        //             {
        //                 JToken games = ((JObject)value)["games"];
        //                 if (games != null)
        //                 {
        //                     foreach (JToken game in games)
        //                     {
        //                         Int32 appId = (Int32)game["appid"];
        //                         Int32 playtime = (Int32)game["playtime_forever"];
        //                 
        //                         if (appIds.Contains(appId))
        //                             gameTimes[appId] = playtime;
        //
        //                         allTimeGames += playtime;
        //                     }
        //                 }
        //             }
        //
        //             Boolean isClosedProfile = allTimeGames == 0;
        //             
        //             if (isClosedProfile || gameTimes.Count == 0)
        //                 return;
        //     
        //             Int32 timeToGamingAll = 0;
        //             foreach (Int32 appId in appIds)
        //                 if (gameTimes.TryGetValue(appId, out Int32 time))
        //                     timeToGamingAll += time;
        //     
        //             timeToGamingAll *= 3600;
        //             TryParseTimeSpan(config.steamSetting.minPlayGameTime, out Double minPlayGameTimes);
        //             PrintWarning(timeToGamingAll.ToString() + " | " + minPlayGameTimes.ToString());
        //             
        //         }, this, timeout: 10f);
        //     
        //     //76561198434075094
        // }
        
        private void CheckSteamController(IPlayer player)
        {
            if (String.IsNullOrWhiteSpace(config.steamSetting.steamApiKey)) return;

            webrequest.Enqueue($"https://api.steampowered.com/ISteamUser/GetPlayerSummaries/v2/?key={config.steamSetting.steamApiKey}&steamids={player.Id}", String.Empty,
                (code, response) => HandlerSteam(player, code, response), this, timeout: 10f);
        }
        
        private void TeamAdded(RelationshipManager.PlayerTeam team)
        {
            NextTick(() =>
            {
                for (Int32 i = 0; i < team.members.Count; i++)
                for (Int32 j = i + 1; j < team.members.Count; j++)
                {
                    UInt64 player1 = team.members[i];
                    UInt64 player2 = team.members[j];

                    if (!teamLocalMemory.ContainsKey(player1))
                        teamLocalMemory[player1] = new Dictionary<UInt64, TeamLocalMemory>();

                    if (!teamLocalMemory.ContainsKey(player2))
                        teamLocalMemory[player2] = new Dictionary<UInt64, TeamLocalMemory>();

                    if (!teamLocalMemory[player1].ContainsKey(player2))
                        teamLocalMemory[player1][player2] = new TeamLocalMemory
                        {
                            firstJoin = CurrentTime,
                            lastRemoved = 0,
                        };

                    if (!teamLocalMemory[player2].ContainsKey(player1))
                        teamLocalMemory[player2][player1] = new TeamLocalMemory
                        {
                            firstJoin = CurrentTime,
                            lastRemoved = 0,
                        };
                }
            });
        }

        
        private void SendChat(String message, BasePlayer player, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            if (IQChat)
                IQChat?.Call("API_ALERT_PLAYER", player, message, config.generalSetting.iqchatSetting.customPrefix, config.generalSetting.iqchatSetting.customAvatar);
            else player.SendConsoleCommand("chat.add", channel, 0, message);
        }
        [ChatCommand("unban")] 
        private void ChatUnBanCommand(BasePlayer ownerCommand, String cmd, String[] arg) => UnBanCommand(ownerCommand, arg);
        
        object OnTeamAcceptInvite(RelationshipManager.PlayerTeam team, BasePlayer player)
        {
            TeamAdded(team);
            return null;
        }

        
        
        
        private Boolean IsOpenMySQL() => config.mysqlConnected.useMySQL && sqlConnection != null;

        [ConsoleCommand("unban")] 
        private void ConsoleUnBanCommand(ConsoleSystem.Arg arg) => UnBanCommand(arg.Player(), arg.Args);
        
        [ChatCommand("kick")] 
        private void ChatKickCommand(BasePlayer ownerCommand, String cmd, String[] arg) => KickCommand(ownerCommand, arg);

        private void SQL_GetData()
        {
            Sql sql = Sql.Builder.Append(SQL_Query_CreatedDatabase());
            sqlLibrary.Insert(sql, sqlConnection);
            sql = Sql.Builder.Append(SQL_Query_SelectedDatabase());
            sqlLibrary.Query(sql, sqlConnection, list =>
            {
                if (list.Count > 0)
                    foreach (Dictionary<String, Object> entry in list)
                    {
                        String valueImported = String.Empty;
                        TypeAction typeBanned;
                        
                        if (UInt64.TryParse((String)entry["steamid"], out UInt64 steamID))
                        {
                            valueImported = steamID.ToString();
                            typeBanned = TypeAction.BannedSteamID;
                        }
                        else
                        {
                            valueImported = (String)entry["ipAdress"];
                            typeBanned = TypeAction.BannedIP;
                        }
                        
                        if (!Int32.TryParse((String)entry["permanent"], out Int32 permanent))
                        {
                            PrintError(LanguageEn ? $"Error retrieving permanent information for player {valueImported} ({typeBanned})" : $"Ошибка получения информации permanent для игрока {valueImported}({typeBanned})");
                            return;
                        }
                        Boolean isPemanent = permanent != 0;

                        if (!Double.TryParse((String)entry["timeUnbanned"], out Double timeUnbanned))
                        {
                            PrintError(LanguageEn ? $"Error retrieving timeUnbanned information for player {valueImported} ({typeBanned})" : $"Ошибка получения информации timeUnbanned для игрока {valueImported}({typeBanned}))");
                            return;
                        }

                        String reason = (String)entry["reason"];
                        String serverName = (String)entry["serverName"];
                        String serverAdress = (String)entry["serverAdress"];
                        
                        String owner = (String)entry["owner"];
                        List<PlayerInfo.History> nameHistory = new ();
                        List<PlayerInfo.History> ipHistory = new ();
                        List<PlayerInfo.History> steamIdHistory = new ();
                        
                        String jsonNameHistory = (String)entry["nameHistory"];
                        String jsonipHistory = (String)entry["ipHistory"];
                        String jsonsteamIdHistory = (String)entry["steamIdHistory"];
                        
                        nameHistory = JsonConvert.DeserializeObject<List<PlayerInfo.History>>(jsonNameHistory);
                        ipHistory = JsonConvert.DeserializeObject<List<PlayerInfo.History>>(jsonipHistory);
                        steamIdHistory = JsonConvert.DeserializeObject<List<PlayerInfo.History>>(jsonsteamIdHistory);
                        
                        PlayerInfo.Import(valueImported, new PlayerInfo
                        {
                            permanent = isPemanent,
                            timeUnbanned = timeUnbanned,
                            reason = reason,
                            nameHistory = nameHistory,
                            ipHistory = ipHistory,
                            steamIdHistory = steamIdHistory,
                            serverName = serverName, 
                            serverAdress = serverAdress,
                            owner = owner,
                        }, typeBanned);
                    }
                
                Puts(LanguageEn ? $"MySQL database initialized, {list.Count} users retrieved" : $"Инициализирована база данных MySQL, получено {list.Count} пользователей");
                
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                    OnPlayerConnected(player);
            });
        }

        private class Configuration
        {
            [JsonProperty(LanguageEn ? "Server data configuration" : "Настройка данных сервера")]
            public GeneralSetting generalSetting = new GeneralSetting();
            [JsonProperty(LanguageEn ? "Setting up MySQL connection" : "Настройка подключения MySQL")]
            public MySQLSetting mysqlConnected = new MySQLSetting();
            [JsonProperty(LanguageEn ? "Setting up interaction with Steam" : "Настройка взаимодействия со Steam")]
            public SteamSetting steamSetting = new SteamSetting();
            [JsonProperty(LanguageEn ? "Setting up VPN protection" : "Настройка защиты от VPN")]
            public VPNSetting vpnSetting = new VPNSetting();
            [JsonProperty(LanguageEn ? "Setting up the blocking system" : "Настройка системы блокировки")]
            public BannedSetting bannedSetting = new BannedSetting();    
            
            internal class GeneralSetting
            {
                [JsonProperty(LanguageEn ? "Server name" : "Название сервера")] 
                public String serverName;
                [JsonProperty(LanguageEn ? "IP:PORT server" : "IP:Port сервера")] 
                public String serverAdress;
                [JsonProperty(LanguageEn ? "Additional configuration" : "Дополнительная настройка")]
                public AdditionalSetting additionalSetting = new AdditionalSetting();    
                [JsonProperty(LanguageEn ? "Setting IQChat" : "Настройка IQChat")]
                public IQChatSetting iqchatSetting = new IQChatSetting();  
                [JsonProperty(LanguageEn ? "Setting Discord" : "Настройка Discord")]
                public DiscordSetting discordSetting = new DiscordSetting();  
                
                internal class AdditionalSetting
                {
                    [JsonProperty(LanguageEn ? "Sound effect for all players to notify when a player is blocked ('Notify all players' should be enabled) (leave it blank - if you don't need it)" : "Звуковой эффект для всех игроков для уведомления о блокировке игрока (должно быть включено 'Уведомлять всех игроков') (оставьте пустым - если вам не нужно это)")]
                    public String effectAlertAllPlayers;
                    [JsonProperty(LanguageEn ? "Notify all players when a player is blocked" : "Уведомлять всех игроков о блокировке игрока")]
                    public Boolean useAlertAllPlayers;
                    [JsonProperty(LanguageEn ? "Notify all players about player's kick" : "Уведомлять всех игроков о кике игрока")]
                    public Boolean useAlertKickPlayer;
                    [JsonProperty(LanguageEn ? "Add information about blocked teammates to the blocking notification" : "Добавлять в уведомление о блокировке - информацию о заблокированных тиммейтах")]
                    public Boolean useAlertBlockTeam; 
                }
                
                internal class IQChatSetting
                {
                    [JsonProperty(LanguageEn ? "IQChat: Chat Prefix" : "IQChat : Префикс в чате")]
                    public String customPrefix; 
                    [JsonProperty(LanguageEn ? "IQChat: Chat Avatar (Use Steam64ID)" : "IQChat : Аватарка в чате (Используйте Steam64ID)")]
                    public String customAvatar;
                }

                internal class DiscordSetting
                {
                    [JsonProperty(LanguageEn ? "Discord notification setting for player ban" : "Настройка уведомления в Discord о блокировке игрока")]
                    public AlertBanned alertBanned = new AlertBanned();
    
                    internal class AlertBanned
                    {
                        [JsonProperty(LanguageEn ? "Webhooks: For banned notifications" : "Webhooks : Для уведомлений о блокировке")]
                        public String webHookBanned;
                        [JsonProperty(LanguageEn ? "Include home information of the banned player in the notification" : "Добавлять в уведомление дома где прописан заблокированный игрок")]
                        public Boolean cupboardAuthInfo;
                        [JsonProperty(LanguageEn ? "Additional notification setting for players who played with the banned player" : "Настройка дополнительного уведомления о тех с кем играл заблокированный")]
                        public TeamsAlert teamsAlert = new TeamsAlert();
        
                        internal class TeamsAlert
                        {
                            [JsonProperty(LanguageEn ? "Include players who played with the banned player in the notification" : "Добавлять в уведомление игроков с которыми играл забаненный")]
                            public Boolean saveInfoTeams;
                            [JsonProperty(LanguageEn ? "Time spent together with the banned player to be included in the notification (Format: 1s/1m/1h/1d)" : "Сколько времени должны провести вместе забаненный с игроком для его отображения в уведомлении (В формате 1s/1m/1h/1d)")]
                            public String formatTimePlaying;
                        }
                    }
                    
                    [JsonProperty(LanguageEn ? "Webhooks : For unbanned notifications" : "Webhooks : Для уведомлений о разблокировке")]
                    public String webHookUnBanned;
                    [JsonProperty(LanguageEn ? "Webhooks : For kicked notifications" : "Webhooks : Для уведомлений о киках")]
                    public String webHookKicked;
                    [JsonProperty(LanguageEn ? "Webhooks : For notifications about a blocked player's login attempt" : "Webhooks : Для уведомлений о попытке входа заблокированного игрока")]
                    public String webHookConnectedBanned;
                    [JsonProperty(LanguageEn ? "Link to the image in Discord" : "Ссылка на изображение в Discord")]
                    public String imageLink;
                }
            }
            internal class SteamSetting
            {
                [JsonProperty(LanguageEn ? "Please provide the Steam API Key for the operation of these functions (Obtain it here - https://steamcommunity.com/dev/apikey)" : "Укажите SteamApiKey для работы данных функций (Взять тут - https://steamcommunity.com/dev/apikey)")]
                public String steamApiKey;
                [JsonProperty(LanguageEn ? "The minimum amount of time since Steam account registration for logging into the server. Format: 1m/1h/1d (leave empty if you don't need this function)" : "Минимальное количество времени с регистрации аккаунта Steam для входа на сервер. Формат 1m/1h/1d (оставьте пустым - если вам не нужна эта функция)")]
                public String minSteamRegisterTime; 
                [JsonProperty(LanguageEn ? "The minimum amount of playtime in RUST required for logging into the server. Format: 1m/1h/1d (leave empty if you don't need this function)" : "Минимальное количество отыгранного времени в RUST для входа на сервер. Формат 1m/1h/1d (оставьте пустым - если вам не нужна эта функция)")]
                public String minPlayGameTime; 
            }
            internal class MySQLSetting
            {
                [JsonProperty(LanguageEn ? "Use MySQL database (true - yes/false - no)" : "Использовать базу-данных MySQL (true - да/false - нет)")]
                public Boolean useMySQL;
                [JsonProperty(LanguageEn ? "Host (IP-Address)" : "Хост (IP-Address)")]
                public String dbIP;
                [JsonProperty(LanguageEn ? "Port (default 3306)" : "Порт (стандартно 3306)")]
                public String dbPort;
                [JsonProperty(LanguageEn ? "Database name" : "Имя базы данных")]
                public String dbName;
                [JsonProperty(LanguageEn ? "Username" : "Имя пользователя")]
                public String dbUser;
                [JsonProperty(LanguageEn ? "Password" : "Пароль")]
                public String dbPassword;
                [JsonProperty(LanguageEn ? "Table name" : "Название таблицы")]
                public String dbTableName;
            }
            
            internal class VPNSetting
            {
                [JsonProperty(LanguageEn ? "Saving 'Good IPs' to avoid reusing requests on the player" : "Сохранять `Хорошие IP`, чтобы не тратить запросы повторно на игрока")]
                public Boolean useSaveGodIps;
                [JsonProperty(LanguageEn ? "The number of detects for kicking a player for VPN (if you use more than 1 service for VPN checking)" : "Количество детектов для кика игрока за VPN (Если вы испольузете более 1 сервиса на проверку VPN)")]
                public Int32 countDetectedToKickInVPN;
                [JsonProperty(LanguageEn ? "Token https://iphub.info/" : "Токен от https://iphub.info/")]
                public String iPHubToken;
                [JsonProperty(LanguageEn ? "Token https://proxycheck.io/" : "Токен от https://proxycheck.io/")]
                public String proxyCheckIo;
                [JsonProperty(LanguageEn ? "Token https://vpnapi.io/" : "Токен от https://vpnapi.io/")]
                public String vpnApiIoToken;
                [JsonProperty(LanguageEn ? "IP Whitelist for ignoring VPN" : "Белый список IP для игнорирования VPN")]
                public List<String> vpnWhiteList = new List<String>();
            }
            
            internal class BannedSetting
            {
                [JsonProperty(LanguageEn ? "TirifyGamePluginRust : Block the player by hardware using Tirify if the lock is issued forever (true - yes/false - no)" : "TirifyGamePluginRust : Блокировать игрока по железу с помощью Tirify если блокировка выдана навсегда (true - да/false - нет)")]
                public Boolean tirifyBannedReplace;
                [JsonProperty(LanguageEn ? "Kill player after being banned on the server" : "Убивать игрока после блокировки на сервере")]
                public Boolean useKilledPlayer;
                [JsonProperty(LanguageEn ? "Setting for banning teammates for playing with the offender" : "Настройка блокировки тиммейтов за игру с нарушителем")]
                public TeamBannedSetting teamBannedSetting = new TeamBannedSetting();
                [JsonProperty(LanguageEn ? "Setting for destroying player's objects after being banned" : "Настройка уничтожения объектов игрока после блокировки")]
                public DestroyedAfterBannedSetting destroyedAfterBannedSetting = new DestroyedAfterBannedSetting();
                
                internal class TeamBannedSetting
                {
                    [JsonProperty(LanguageEn ? "Specify the time played with the offender for issuing a ban. Format 1s/1m/1h/1d" : "Укажите время игры с нарушителем для выдачи блокировки. Формат 1s/1m/1h/1d")]
                    public String timeDeteckGamingTeamMemory;
                    [JsonProperty(LanguageEn ? "Ban teammates of the banned player" : "Блокировать тиммейтов заблокированного игрока")]
                    public Boolean useBlockTeam;
                    [JsonProperty(LanguageEn ? "Specify the ban time for teammates for playing with the offender. Format 1s/1m/1h/1d (Leave empty for issuing a permanent ban)" : "Укажите время блокировки тиммейтов за игру с нарушителем. Формат 1s/1m/1h/1d (Оставьте пустым - для выдачи блокировки навсегда)")]
                    public String timeBlockTeam; 
                }

                internal class DestroyedAfterBannedSetting
                {
                    [JsonProperty(LanguageEn ? "Use the function to delete player's objects after being banned" : "Использовать функцию удаления объектов игрока после блокировки")]
                    public Boolean useDestroyObjects;
                    [JsonProperty(LanguageEn ? "Type of object destruction: 0 - All objects, 1 - All objects and dropping items from containers on the ground, 2 - Only locks, 3 - Only boxes, 4 - Only boxes with dropping items from them" : "Тип уничтожения объектов : 0 - Все объекты, 1 - Все объекты и выбрасывание предметов из контейнеров на пол, 2 - Только замки, 3 - Только ящики, 4 - Только ящики с выбрасыванием предметов из них")]
                    public TypeDestroy typeDestroyed;
                    [JsonProperty(LanguageEn ? "Notify in chat about squares of destroyed player's objects" : "Уведомлять в чате о квадратах разрушенных объектах игрока")]
                    public Boolean useAlertGridHomes;
                    [JsonProperty(LanguageEn ? "Setting for displaying markers on the G-Map" : "Настройка отображения маркеров на G-Map")]
                    public MapMarkerDestroyedObject mapMarkerDestroyedObjectSetting = new();
                    
                    internal class MapMarkerDestroyedObject
                    {
                        [JsonProperty(LanguageEn ? "Display points with destroyed objects on the map" : "Отображать на карте точки с разрушенными объектами")]
                        public Boolean useMapMarkerDestroyedObjectPlayer;
                        [JsonProperty(LanguageEn ? "Main marker color" : "Основной цвет маркера")]
                        public String mainColorMarker;
                        [JsonProperty(LanguageEn ? "Outline marker color" : "Цвет обводки маркера")]
                        public String additionalColorMarker;
                        [JsonProperty(LanguageEn ? "Marker radius on the map" : "Радиус маркера на карте")]
                        public Single radiusMarker;
                        [JsonProperty(LanguageEn ? "How long the marker will be displayed. Format 1s/1m/1h/1d" : "Сколько будет отображаться маркер. Формат 1s/1m/1h/1d")]
                        public String markerLifeTime;
                    }
                }
            }
            
	        public static Configuration GetNewConfiguration()
	        {
		        return new Configuration
                {
                    generalSetting = new GeneralSetting
                    {
                        serverName = "MY SERVER",
                        serverAdress = "127.0.0.1",
                        additionalSetting = new GeneralSetting.AdditionalSetting
                        {
                            effectAlertAllPlayers = "assets/bundled/prefabs/fx/item_unlock.prefab",
                            useAlertAllPlayers = true,
                            useAlertKickPlayer = false,
                            useAlertBlockTeam = false,
                        },
                        iqchatSetting = new GeneralSetting.IQChatSetting
                        {
                            customPrefix = "<color=#1F6BA0>[IQBanSystem]</color>",
                            customAvatar = "0"
                        },
                        discordSetting = new GeneralSetting.DiscordSetting
                        {
                            alertBanned = new GeneralSetting.DiscordSetting.AlertBanned
                            {
                                webHookBanned = String.Empty,
                                cupboardAuthInfo = false,
                                teamsAlert = new GeneralSetting.DiscordSetting.AlertBanned.TeamsAlert
                                {
                                    saveInfoTeams = false,
                                    formatTimePlaying = "12h",
                                }
                            },
                            webHookUnBanned = String.Empty,
                            webHookKicked = String.Empty,
                            webHookConnectedBanned = String.Empty,
                            imageLink = "https://i.postimg.cc/MGLfp4dR/IQBan-System.png",
                        },
                    },
                    mysqlConnected = new MySQLSetting
                    {
                        useMySQL = false,
                        dbIP = "",
                        dbPort = "3306",
                        dbName = "",
                        dbUser = "",
                        dbPassword = "",
                        dbTableName = "IQBanSystem_Db"
                    },
                    steamSetting = new SteamSetting
                    {
                        steamApiKey = "",
                        minSteamRegisterTime = "14d",
                        minPlayGameTime = "3d",
                    },
                    vpnSetting = new VPNSetting
                    {
                        useSaveGodIps = true,
                        countDetectedToKickInVPN = 1,
                        iPHubToken = "",
                        proxyCheckIo = "",
                        vpnApiIoToken = "",
                        vpnWhiteList = new List<String>
                        {
                            "127.0.0.1"
                        }
                    },
                    bannedSetting = new BannedSetting
                    {
                        tirifyBannedReplace = false,
                        useKilledPlayer = true,
                        teamBannedSetting = new BannedSetting.TeamBannedSetting
                        {
                            useBlockTeam = false,
                            timeDeteckGamingTeamMemory = "3h",
                            timeBlockTeam = "7d"
                        },
                        destroyedAfterBannedSetting = new BannedSetting.DestroyedAfterBannedSetting
                        {
                            useDestroyObjects = false,
                            typeDestroyed = TypeDestroy.AllObjects,
                            useAlertGridHomes = false,
                            mapMarkerDestroyedObjectSetting = new BannedSetting.DestroyedAfterBannedSetting.MapMarkerDestroyedObject
                            {
                                useMapMarkerDestroyedObjectPlayer = false,
                                mainColorMarker = "#CD412B",
                                additionalColorMarker = "#1E2020",
                                radiusMarker = 0.25f,
                                markerLifeTime = "10m",
                            }
                        },
                    }
                };
	        }
        }

        private Boolean useIpHub = false;
        
        private List<String> DestroyObjectBanned(IPlayer bannedPlayer, String bannedDisplayName)
        {
            Vector3 lastObjectPos = Vector3.zero;
            List<String> homeCords = new ();
            List<BaseEntity> entitesPlayer = Facepunch.Pool.Get<List<BaseEntity>>();
            Configuration.BannedSetting.DestroyedAfterBannedSetting configDestroyed = config.bannedSetting.destroyedAfterBannedSetting;

            Func<BaseNetworkable, Boolean> baseFilter = e => e != null && e is BaseEntity && (e as BaseEntity).OwnerID == UInt64.Parse(bannedPlayer.Id);
            
            Func<BaseNetworkable, Boolean> filter = baseFilter;
            baseFilter = configDestroyed.typeDestroyed switch
            {
                TypeDestroy.OnlyLocks => e => filter(e) && e is BaseLock,
                TypeDestroy.OnlyStorageAndDropInStorage or TypeDestroy.OnlyStorage => e => filter(e) && e is StorageContainer,
                _ => baseFilter
            };

            Boolean isBuildingAccess = false;
            
            foreach (BaseEntity entityPlayer in BaseNetworkable.serverEntities.entityList.Get().Values.Where(baseFilter).OrderByDescending(x => x is StorageContainer))
            {
                if (entityPlayer.IsDestroyed) continue;
                if (!isBuildingAccess)
                {
                    BuildingPrivlidge buildingPrivilage = entityPlayer.GetBuildingPrivilege();
                    if (buildingPrivilage == null) continue;
                    isBuildingAccess = true;
                }

                switch (configDestroyed.typeDestroyed)
                {
                    case TypeDestroy.AllObjectsAndDropInStorage or TypeDestroy.OnlyStorageAndDropInStorage:
                        ProcessStorageContainer(entityPlayer, storage => { storage.DropItems(); });
                        break;
                    case TypeDestroy.AllObjects or TypeDestroy.OnlyStorage:
                        ProcessStorageContainer(entityPlayer, storage => { storage.inventory.Clear(); });
                        break;
                }
                
                if (config.generalSetting.additionalSetting.useAlertAllPlayers && configDestroyed.useAlertGridHomes)
                {
                    if (lastObjectPos != Vector3.zero)
                        if (Vector3.Distance(lastObjectPos, entityPlayer.transform.position) >= 100)
                        {
                            String cordHomeOnMap = MapHelper.PositionToString(entityPlayer.transform.position);

                            if (!homeCords.Contains(cordHomeOnMap))
                            {
                                homeCords.Add(cordHomeOnMap);
                                CreateMapMarker(entityPlayer.transform.position, bannedDisplayName);
                            }
                                        
                            lastObjectPos = entityPlayer.transform.position;
                            continue;
                        }
            
                    lastObjectPos = entityPlayer.transform.position;
                                
                    if (homeCords.Count == 0)
                    {
                        homeCords.Add(MapHelper.PositionToString(entityPlayer.transform.position));
                        CreateMapMarker(entityPlayer.transform.position, bannedDisplayName);
                    }
                }
                
                entityPlayer.Kill();
            }
            
            Facepunch.Pool.FreeUnmanaged(ref entitesPlayer);
            
            return homeCords; 
        }
		   		 		  						  	   		  		 			  	   		  		  		   		 
                
        
        [PluginReference] private Plugin IQChat, RustApp, IQTeleportation, TirifyGamePluginRust;

        
        
        private void KickUser(IPlayer iTarget, String reason, BasePlayer ownerCommand)
        {
            if (iTarget == null)
            {
                SendInfo(ownerCommand, LanguageEn ? "Couldn't find a player" : "Не удалось найти игрока");
                return;
            }
            
            if (!iTarget.IsConnected)
            {
                SendInfo(ownerCommand, LanguageEn ? "The player has not yet connected to the server" : "Игрок еще не подключился к серверу");
                return;
            }
            
            String resultReason = String.IsNullOrWhiteSpace(reason) ? GetLang("KICKED_DEFAULT_REASON", iTarget.Id) : reason;
            String ownerKicked = ownerCommand == null ? "Console" : $"{ownerCommand.displayName}({ownerCommand.userID})";

            if (!String.IsNullOrWhiteSpace(config.generalSetting.discordSetting.webHookKicked))
            {
                List<Fields> fieldsKick = new List<Fields>
                {
                    new Fields(LanguageEn ? "Issued by kick" : "Выдал кик", ownerKicked, false),
                    new Fields("", "", false),
                    new Fields(LanguageEn ? "Player" : "Игрок", $"{iTarget.Name}({iTarget.Id})", false),
                    new Fields(LanguageEn ? "Reason" : "Причина", resultReason, false),
                };

                SendDiscord(fieldsKick, TypeAlertDiscord.Kicked, config.generalSetting.discordSetting.webHookKicked);
            }
            
            Interface.CallHook("OnKickPlayer", iTarget.Id, resultReason, ownerCommand);

            iTarget.Kick(resultReason);
            
            SendInfo(ownerCommand, LanguageEn ? $"You have successfully kicked player {iTarget.Name}" : $"Вы успешно кикнули игрока {iTarget.Name}");
            if (ownerCommand != null)
                Puts(LanguageEn ? $"Player {iTarget.Name}({iTarget.Id}) was kicked for: {resultReason}.\nKicked by: {ownerKicked}" : $"Игрок {iTarget.Name}({iTarget.Id}) был кикнут по причине : {resultReason}.\nВыдал кик : {ownerKicked}");
            
            if(config.generalSetting.additionalSetting.useAlertKickPlayer)
                foreach (BasePlayer basePlayer in BasePlayer.activePlayerList)
                    SendChat(GetLang("ALERT_ALL_PLAYER_KICKED", basePlayer.UserIDString, iTarget.Name, resultReason, ownerKicked), basePlayer);
        }
        
        private const String GenericPrefab = "assets/prefabs/tools/map/genericradiusmarker.prefab";
        
        
        public class FancyMessage
        {
            public String content { get; set; }
            public Boolean tts { get; set; }
            public Embeds[] embeds { get; set; }

            public class Embeds
            {
                public String title { get; set; }
                public Int32 color { get; set; }
                public List<Fields> fields { get; set; }
                public Footer footer { get; set; }
                public Authors author { get; set; }

                public Embeds(String title, Int32 color, List<Fields> fields, Authors author, Footer footer)
                {
                    this.title = title;
                    this.color = color;
                    this.fields = fields;
                    this.author = author;
                    this.footer = footer;

                }
            }

            public FancyMessage(String content, bool tts, Embeds[] embeds)
            {
                this.content = content;
                this.tts = tts;
                this.embeds = embeds;
            }

            public String toJSON() => JsonConvert.SerializeObject(this);
        }
        private void CreateMapMarker(Vector3 position, String namePlayer)
        {
            Configuration.BannedSetting.DestroyedAfterBannedSetting configDestroyed = config.bannedSetting.destroyedAfterBannedSetting;
            if (!configDestroyed.mapMarkerDestroyedObjectSetting.useMapMarkerDestroyedObjectPlayer) return;
            VendingMachineMapMarker vending = GameManager.server.CreateEntity(VendingPrefab, position, Quaternion.identity, true) as VendingMachineMapMarker;
            vending.markerShopName = namePlayer;
            vending.enableSaving = false;
            vending.EnableGlobalBroadcast(true);
            vending.Spawn();
                
            MapMarkerGenericRadius genericMarker = GameManager.server.CreateEntity(GenericPrefab, new Vector3(), Quaternion.identity, true) as MapMarkerGenericRadius;
            ColorUtility.TryParseHtmlString(configDestroyed.mapMarkerDestroyedObjectSetting.mainColorMarker, out Color color1);
            ColorUtility.TryParseHtmlString(configDestroyed.mapMarkerDestroyedObjectSetting.additionalColorMarker, out Color color2);
            genericMarker.color1 = color1;
            genericMarker.color2 = color2;
            genericMarker.radius = configDestroyed.mapMarkerDestroyedObjectSetting.radiusMarker;
            genericMarker.alpha = 1f;
            genericMarker.SetParent(vending);
            genericMarker.Spawn();
            genericMarker.SendUpdate(); 
            genericMarker.EnableGlobalBroadcast(true);
        
            MarkerRepository markerInfo = new MarkerRepository() { vending = vending, marker = genericMarker, timeSetMarker = DateTime.Now };
            mapMarkers.Add(markerInfo);
        }
        
        private void RunEffect(BasePlayer player, String effectPath)
        {
            Effect effect = new Effect(effectPath, player, 0, new Vector3(), new Vector3());
            EffectNetwork.Send(effect, player.Connection);
        }

        
        private String SQL_Query_InsertUser()
        {
            return $"INSERT INTO {config.mysqlConnected.dbTableName} " +
                          "(`steamid`, `ipAdress`, `permanent`, `timeUnbanned`, `reason`, `serverName`, `serverAdress`, `owner`, `nameHistory`, `ipHistory`, `steamIdHistory`) " +
                          "VALUES (@0, @1, @2, @3, @4, @5, @6, @7, @8, @9, @10)";
        }
		   		 		  						  	   		  		 			  	   		  		  		   		 
        
        
        private void UnBanCommand(BasePlayer ownerCommand, String[] arg)
        {
            if (arg == null)
            {
                SendInfo(ownerCommand, LanguageEn ? "Use syntax: unban SteamID/IP/Name* Time(1s/1m/1h/1d)\nItems marked with * are mandatory" : "Используйте синтаксис : unban SteamID/IP/Name* Время(1s/1m/1h/1d) \nПункты помеченные `*` - это обязательные пункты");
                return;
            }
            
            if (ownerCommand != null)
                if (!permission.UserHasPermission(ownerCommand.UserIDString, permissionsUnBan))
                    return;

            if (arg.Length < 1)
            {
                SendInfo(ownerCommand, LanguageEn ? "Use syntax: unban SteamID/IP/Name* Time(1s/1m/1h/1d)\nItems marked with * are mandatory" : "Используйте синтаксис : unban SteamID/IP/Name* Время(1s/1m/1h/1d) \nПункты помеченные `*` - это обязательные пункты");
                return;
            }
            
            String userParams = arg[0];
            UInt64 targetUserID = 0;
            IPlayer iPlayer = GetIPlayer(userParams);
		   		 		  						  	   		  		 			  	   		  		  		   		 
            Boolean isIp = IsIpAdress(userParams);

            if (!isIp)
            {
                if (!UInt64.TryParse(userParams, out targetUserID))
                {
                    if (iPlayer == null)
                    {
                        SendInfo(ownerCommand, LanguageEn ? "Couldn't find a player" : "Не удалось найти игрока");
                        return;
                    }
                    targetUserID = UInt64.Parse(iPlayer.Id);
                }
            }
            
            Double unBanTime = 0;

            if (arg.Length >= 2)
            {
                String timeFormat = arg[1];
                if (!String.IsNullOrWhiteSpace(timeFormat))
                {
                    if (!TryParseTimeSpan(timeFormat, out unBanTime))
                    {
                        SendInfo(ownerCommand, LanguageEn ? "Incorrect time format specified, use 1s/1m/1h/1d" : "Неверно указан формат времени, используйте 1s/1m/1h/1d");
                        return;
                    }
                }
            }

            TypeAction typeUnbanned = isIp ? TypeAction.BannedIP : TypeAction.BannedSteamID;
            String valueInfo = isIp ? userParams : targetUserID.ToString();
            PlayerInfo infoUser = PlayerInfo.Get(valueInfo, typeUnbanned);
            
            if (infoUser == null)
            {
                SendInfo(ownerCommand, LanguageEn ? "This player is not banned" : "Данный игрок не имеет блокировки");
                return;
            }
            
            UnBanUserOrIp(valueInfo, infoUser, typeUnbanned, unBanTime, ownerCommand);
        }
        
                
                
        private List<IPlayer> BannedTeams(UInt64 playerID, BasePlayer ownerCommand)
        {
            List<IPlayer> PlayersFromTeam = new List<IPlayer>();
            
            if (config.bannedSetting.teamBannedSetting.useBlockTeam)
            {
                if (!TryParseTimeSpan(config.bannedSetting.teamBannedSetting.timeDeteckGamingTeamMemory, out Double banGaming))
                    return PlayersFromTeam;
                
                Dictionary<UInt64, Double> teamMemory = GetTeamsBannedPlayer(playerID);
                if(teamMemory == null || teamMemory.Count == 0) return PlayersFromTeam;

                TryParseTimeSpan(config.bannedSetting.teamBannedSetting.timeBlockTeam, out Double banTeamTime);
                
                foreach (KeyValuePair<UInt64, Double> memory in teamMemory)
                {
                    if(memory.Value < banGaming) continue;
                    if(memory.Key == playerID) continue;
                    IPlayer iPlayer = GetIPlayer($"{memory.Key}");
                    
                    BanUser(memory.Key, iPlayer,"BANNED_DEFAULT_REASON_GAME_WITH_CHEATER", banTeamTime, ownerCommand, true);
                    
                    if (!PlayersFromTeam.Contains(iPlayer))
                        PlayersFromTeam.Add(iPlayer);
                }
            }
            // else
            // {
            //  RelationshipManager.PlayerTeam teams = player.Team;

            //     if(teams != null)
            //         foreach (UInt64 teamsMember in teams.members)
            //         {
            //             if (teamsMember == playerID) continue;
            //             TryParseTimeSpan(config.bannedSetting.teamBannedSetting.timeBlockTeam, out Double banTimeTeam);
            //             BanUser(teamsMember, reason: "BANNED_DEFAULT_REASON_GAME_WITH_CHEATER", banTime: banTimeTeam, skipTeam: true, ownerCommand: ownerCommand);
            //             IPlayer iPlayer = GetIPlayer($"{teamsMember}");
            //
            //             if (!PlayersFromTeam.Contains(iPlayer))
            //                 PlayersFromTeam.Add(iPlayer);
            //         }
            // }

            return PlayersFromTeam;
        }
        void ReadData()
        {
            ipListGods = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<List<String>>("IQSystem/IQBanSystem/ListGodIps");
            teamLocalMemory = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<UInt64, Dictionary<UInt64, TeamLocalMemory>>>("IQSystem/IQBanSystem/TeamsMemory");
            Puts(LanguageEn ? $"Database initialized with {ipListGods.Count} VPN-verified IPs" : $"Инициализирована база данных {ipListGods.Count} проверенных на VPN IP");
        }
        
        
        private void SQL_OpenConnection()
        {
            if (String.IsNullOrWhiteSpace(config.mysqlConnected.dbIP) || String.IsNullOrWhiteSpace(config.mysqlConnected.dbPassword) ||
                String.IsNullOrWhiteSpace(config.mysqlConnected.dbPort) || String.IsNullOrWhiteSpace(config.mysqlConnected.dbName) ||
                String.IsNullOrWhiteSpace(config.mysqlConnected.dbUser))
            {
                config.mysqlConnected.useMySQL = false;
                PrintWarning(LanguageEn ? "Incorrect MySQL data entered, MySQL usage has been disabled. Please check the configuration for correct data" : "Некорректно введены данные для MySQL, использование MySQL было отключено. Проверьте конфигурацию на корректность данных");
                Init();
                return;
            }
            
            sqlConnection = 
                sqlLibrary.OpenDb(
                BuildConnectionString(
                    config.mysqlConnected.dbIP, 
                    Convert.ToInt32(config.mysqlConnected.dbPort), 
                    config.mysqlConnected.dbName, 
                    config.mysqlConnected.dbUser, 
                    config.mysqlConnected.dbPassword
                ), 
                this);
            
            if (sqlConnection == null) return;

            SQL_GetData();
        }
        
        
        void HandlerIPHub(Int32 code, String response, String adress)
        {
            ProcessCheckVPN processChecked = ipListChecked[adress];
            if (code != 200 || string.IsNullOrEmpty(response))
            {
                ResponseError("IPHub", $"{code}");
                processChecked.isCompleteIPHub = true;
                return;
            }

            Dictionary<String, Object> jsonresponse;
            try { jsonresponse = JsonConvert.DeserializeObject<Dictionary<String, Object>>(response); }
            catch (JsonReaderException e)
            {
                ResponseError("IPHub", e.Message);
                processChecked.isCompleteIPHub = true;
                return;
            }

            if (jsonresponse["block"] == null)
            {
                processChecked.isCompleteIPHub = true;
                return;
            }
            String playerVpn = (jsonresponse["block"].ToString());

            if (playerVpn == "1")
            {
                //PrintError("DETECT ");
                processChecked.detectedVpn++;
            }
            
            processChecked.isCompleteIPHub = true;
        }


        
        
        
        // private void RustApp_BanDeleted(String steamID)
        // {
        //     if (String.IsNullOrWhiteSpace(steamID)) return;
        //     PlayerInfo infoUser = PlayerInfo.Get(steamID, TypeAction.BannedSteamID);
        //     if (infoUser == null)
        //     {
        //         PrintWarning(LanguageEn ? $"We received an unlock request from RusApp for the ID '{steamID}', there is no such user in the database" : $"Получили запрос на разблокировку от RusApp для ID '{steamID}', такого пользователя нет в базе данных");
        //         return;
        //     }
        //     
        //     UnBanUserOrIp(steamID, infoUser, TypeAction.BannedSteamID);
        // }


        private void RustApp_OnPaidAnnounceBan(String steamID, List<String> targets, String reason)
        {
            if (!UInt64.TryParse(steamID, out UInt64 userID)) return;
            IPlayer iPlayer = GetIPlayer(steamID);
            BanUser(userID, iPlayer, reason: reason);
        }

        private List<MarkerRepository> mapMarkers = new List<MarkerRepository>();

        private void ProcessBanData(IPlayer player, PlayerInfo playerData, TypeAction typeAction, String userID, String ipAddress)
        {
            if (playerData == null)
                return;

            playerData.UpdateHistory(TypeHistoryInfo.Name, player.Name);
            playerData.UpdateHistory(TypeHistoryInfo.IP, ipAddress);
            playerData.UpdateHistory(TypeHistoryInfo.SteamID, userID);

            if (playerData.IsBanned())
            {
                String kickReason = GetKickReason(playerData, userID);
                player.Kick(kickReason);
                
                if (!String.IsNullOrWhiteSpace(config.generalSetting.discordSetting.webHookConnectedBanned))
                {
                    List<Fields> fieldsKick = new List<Fields>
                    {
                        new Fields(LanguageEn ? "Player" : "Игрок", $"{player.Name}({player.Id})", false),
                        new Fields("IP", ipAddress, false),
                        new Fields(LanguageEn ? "Banned reason" : "Причина блокировки", playerData.reason, false),
                        new Fields(LanguageEn ? "Unban time" : "Время разблокировки", playerData.permanent ? (LanguageEn ? "never" : "никогда") : FormatTime(playerData.GetUnbanTime), false),
                    };
                    
                    SendDiscord(fieldsKick, TypeAlertDiscord.ConnectionBanned, config.generalSetting.discordSetting.webHookConnectedBanned);
                }
            }
            else
            {
                PlayerInfo.Remove(userID, typeAction);
            }
        }
        
        private void SetTirifyUnBan(String steamIdString, String reason = "")
        {
            if (!TirifyGamePluginRust) return;
            if (!config.bannedSetting.tirifyBannedReplace) return;
		   		 		  						  	   		  		 			  	   		  		  		   		 
            TirifyGamePluginRust.Call("SetTirifyUnBan", steamIdString, reason);
            Puts(LanguageEn ? $"The player's hardware has been unblocked {steamIdString} (Tirify)" : $"Выдана разблокировка по железу игроку {steamIdString} (Tirify)");
        }
        
        private void OnServerShutdown() => Unload();
        
        private Dictionary<UInt64, Double> GetTeamsBannedPlayer(UInt64 bannedPlayer)
        {
            Dictionary<UInt64, Double> playerTeamMemory = new Dictionary<UInt64, Double>();
            
            if (teamLocalMemory.TryGetValue(bannedPlayer, out Dictionary<UInt64, TeamLocalMemory> teamsPlayers))
            {
                foreach (KeyValuePair<UInt64, TeamLocalMemory> teammate in teamsPlayers)
                {
                    Double duration = (teammate.Value.lastRemoved == 0 ? CurrentTime : teammate.Value.lastRemoved) - teammate.Value.firstJoin;
                    playerTeamMemory.Add(teammate.Key, duration);
                   // PrintToChat(teammate.Key.ToString() + " " + teammate.Value.firstJoin + " " + teammate.Value.lastRemoved);
                }
            }
            //PrintToChat(playerTeamMemory.Count.ToString());
            return playerTeamMemory;
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        private Boolean useVpnApi = false;
		   		 		  						  	   		  		 			  	   		  		  		   		 

        private void ResponseError(String nameService, String message) => PrintWarning(LanguageEn ? $"[{nameService}] The service is temporarily unavailable or your key is incorrect, it returned a negative code, the request was not sent.\nInformation (Code or messages from the service): {message}" : $"[{nameService}] Сервис временно недоступен или ваш ключ некорректен, он вернул отрицательный код, запрос не был отправлен.\nИнформация (Код или сообщения от сервиса) : : {message}");
        
                
                
                
        
        public class MarkerRepository
        {
            public VendingMachineMapMarker vending;
            public MapMarkerGenericRadius marker;
            public DateTime timeSetMarker;
        }
        private const String permissionsKick = "iqbansystem.kick";
        
        private void HandleGameTimes(IPlayer player, Int64? accountCreationDate, Int32 code, String response)
        {
            if (code != 200 || string.IsNullOrEmpty(response))
            {
                ResponseError("Steam", $"{code}");
                return;
            }
            
            Dictionary<String, Object> jsonresponse;
            try { jsonresponse = JsonConvert.DeserializeObject<Dictionary<String, Object>>(response); }
            catch (JsonReaderException e)
            {
                ResponseError("Steam", e.Message);
                return;
            }

            Dictionary<Int32, Int32> gameTimes = new();
            Int32 allTimeGames = 0;
            
            if (jsonresponse.TryGetValue("response", out Object value))
            {
                JToken games = ((JObject)value)["games"];
                if (games != null)
                {
                    foreach (JToken game in games)
                    {
                        Int32 appId = (Int32)game["appid"];
                        Int32 playtime = (Int32)game["playtime_forever"];
                        
                        if (appIds.Contains(appId))
                            gameTimes[appId] = playtime;

                        allTimeGames += playtime;
                    }
                }
            }

            Boolean isClosedProfile = allTimeGames == 0;

            if (!String.IsNullOrWhiteSpace(config.steamSetting.minSteamRegisterTime))
                if (TryParseTimeSpan(config.steamSetting.minSteamRegisterTime, out Double minRegisterSteamTime))
                    if (accountCreationDate < minRegisterSteamTime)
                        KickUser(player, GetLang("KICKED_STEAM_NEW_ACCOUNT", player.Id), null);
            
            if (isClosedProfile || gameTimes.Count == 0)
                return;
            
            Int64 timeToGamingAll = 0;
            foreach (Int32 appId in appIds)
                if (gameTimes.TryGetValue(appId, out Int32 time))
                    timeToGamingAll += time;
            
            timeToGamingAll *= 60;

            if (!String.IsNullOrWhiteSpace(config.steamSetting.minPlayGameTime))
                if (TryParseTimeSpan(config.steamSetting.minPlayGameTime, out Double minPlayGameTimes))
                    if (timeToGamingAll < minPlayGameTimes) 
                        KickUser(player, GetLang("KICKED_STEAM_NO_GAME_TIME", player.Id), null);
        }


                
                
        private void CheckPlayerUsedVPN(IPlayer player)
        {
            if (player == null) return;
            if (!player.IsConnected) return;
            
            if (permission.UserHasPermission(player.Id, permissionsIgnoreVPN)) return;
            
            String adress = player.Address;
            
            PlayerInfo playerDataSteam = PlayerInfo.Get(player.Id, TypeAction.BannedSteamID);
            if (playerDataSteam != null && playerDataSteam.IsBanned()) return;
            
            PlayerInfo playerDataIP = PlayerInfo.Get(adress, TypeAction.BannedIP);
            if (playerDataIP != null && playerDataIP.IsBanned()) return;

            if (config.vpnSetting.vpnWhiteList.Contains(adress)) return;
            if (ipListGods.Contains(adress)) return;
            if (ipListChecked.TryGetValue(adress, out ProcessCheckVPN value))
            {
                if (value == null) return;
                if ((useIpHub && !value.isCompleteIPHub) || (useVpnApi && !value.isCompleteVpnApi) ||
                    (useProxyCheck && !value.isCompleteProxyCheck))
                {
                    if (timerCheckVpn == null || timerCheckVpn.Destroyed)
                        timerCheckVpn = timer.Once(5f, () => { CheckPlayerUsedVPN(player); });
                    return;
                }
                
                if (value.detectedVpn >= maxDetectedVpn)
                { 
                    KickUser(player, GetLang("KICKED_VPN_REASON", player.Id), null);
                    ipListChecked.Remove(adress);
                    
                    if (ipListChecked.Count == 0)
                    {
                        if (timerCheckVpn is { Destroyed: false })
                        {
                            timerCheckVpn.Destroy();
                            timerCheckVpn = null;
                        }
                    }
                    return;
                }

                ipListGods.Add(adress);
                ipListChecked.Remove(adress);

                if (ipListChecked.Count == 0)
                {
                    if (timerCheckVpn is { Destroyed: false })
                    {
                        timerCheckVpn.Destroy();
                        timerCheckVpn = null;
                    }
                }
                return;
            }
            
            ipListChecked.Add(adress, new ProcessCheckVPN
            {
                isCompleteIPHub = !useIpHub,
                isCompleteVpnApi = !useVpnApi,
                isCompleteProxyCheck = !useProxyCheck,
                detectedVpn = 0,
            });
            
            if (useIpHub)
            {
                webrequest.Enqueue($"http://v2.api.iphub.info/ip/{adress}", String.Empty,
                    (code, response) => HandlerIPHub(code, response, adress), this,
                    RequestMethod.GET,
                    new Dictionary<String, String> { ["X-Key"] = config.vpnSetting.iPHubToken }, timeout: 10f);
            }

            if (useVpnApi)
            {
                webrequest.Enqueue($"https://vpnapi.io/api/{adress}?key={config.vpnSetting.vpnApiIoToken}", String.Empty,
                    (code, response) => HandlerVpnApiIo(code, response, adress), this, timeout: 10f);
            }

            if (useProxyCheck)
            {
                webrequest.Enqueue($"https://proxycheck.io/v2/{adress}?key={config.vpnSetting.proxyCheckIo}&risk=1&vpn=1",
                    String.Empty,
                    (code, response) => HandlerProxyCheckIo(code, response, adress),
                    this, timeout: 10f);
            }

            if (timerCheckVpn == null || timerCheckVpn.Destroyed)
                timerCheckVpn = timer.Once(5f, () =>
                {
                    CheckPlayerUsedVPN(player);
                });
        }

                
        
        
        
        private void UnBanUserOrIp(String valueInfo, PlayerInfo infoUser, TypeAction type, Double unBanTime = 0, BasePlayer ownerPlayer = null)
        {
            if (type == TypeAction.BannedSteamID)
            {
                Object canUnBanPlayer = Interface.Oxide.CallHook("CanUnBanPlayer",UInt64.Parse(valueInfo), unBanTime, ownerPlayer); 
                if (canUnBanPlayer != null)
                {
                    switch (canUnBanPlayer)
                    {
                        case String player when !string.IsNullOrWhiteSpace(player):
                            Puts($"{canUnBanPlayer}");
                            return;
                        case Boolean value when !value:
                            return;
                    }
                }
                
                SetTirifyUnBan(valueInfo, String.Empty);
            }

            String ownerCommand = ownerPlayer == null ? "Console" : $"{ownerPlayer.displayName}({ownerPlayer.UserIDString})";
            String ownerID = ownerPlayer != null ? ownerPlayer.UserIDString : null;
            
            if (unBanTime != 0 && (infoUser.GetUnbanTime > 0 || infoUser.permanent))
            {
                if (infoUser.permanent)
                {
                    infoUser.permanent = false;
                    infoUser.timeUnbanned = unBanTime + CurrentTime;
                        
                    PlayerInfo.Save(valueInfo, type);
                    InserOrUpdateDatabase(valueInfo, type);
                    
                    Interface.CallHook(type == TypeAction.BannedSteamID ? "OnChangePermanentBannedID" : "OnChangePermanentBannedIP", valueInfo, unBanTime, ownerPlayer); 
                    
                    SendInfo(ownerPlayer, LanguageEn ? $"The permanent ban has been changed to a temporary ban, unlocking in: {FormatTime(unBanTime, ownerID)}" : $"Бан навсегда был заменен на временный бан, разблокировка через : {FormatTime(unBanTime, ownerID)}"); 
                    
                    if (!String.IsNullOrWhiteSpace(config.generalSetting.discordSetting.webHookUnBanned))
                    {
                        List<Fields> fieldsUnban = new List<Fields>();

                        fieldsUnban.Add(new Fields(LanguageEn ? "Replaced permanent ban with a temporary ban" : "Заменил блокировку навсегда на временную", ownerCommand, true));
                        fieldsUnban.Add(new Fields(type == TypeAction.BannedIP ? "IP" : LanguageEn ? "Player" : "Игрок", valueInfo, false));
                        fieldsUnban.Add(new Fields(LanguageEn ? "Time left until unban" : "Осталось до разблокировки", FormatTime(infoUser.GetUnbanTime, null), false));
                        fieldsUnban.Add(new Fields("", "", false));

                        SendDiscord(fieldsUnban, TypeAlertDiscord.Unbanned, config.generalSetting.discordSetting.webHookUnBanned);
                    }
                    return;
                }
                
                if (unBanTime < infoUser.GetUnbanTime)
                {
                    infoUser.timeUnbanned -= unBanTime;
                    
                    PlayerInfo.Save(valueInfo, type);
                    InserOrUpdateDatabase(valueInfo, type);
                    
                    Interface.CallHook(type == TypeAction.BannedSteamID ? "OnUpdateTimeBannedID" : "OnUpdateTimeBannedIP", valueInfo, infoUser.timeUnbanned - CurrentTime, ownerPlayer); 

                    SendInfo(ownerPlayer, LanguageEn ? $"You've reduced the player's ban time to {FormatTime(unBanTime, ownerID)}. Unlock in: {FormatTime(infoUser.GetUnbanTime, ownerID)}" : $"Вы снизили время блокировки игрока на {FormatTime(unBanTime, ownerID)}. Разблокировка через : {FormatTime(infoUser.GetUnbanTime, ownerID)}");
                    
                    if (!String.IsNullOrWhiteSpace(config.generalSetting.discordSetting.webHookUnBanned))
                    {
                        List<Fields> fieldsUnban = new List<Fields>();

                        fieldsUnban.Add(new Fields(LanguageEn ? "Reduced ban time" : "Снизил время блокировки", ownerCommand, true));
                        fieldsUnban.Add(new Fields(type == TypeAction.BannedIP ? "IP" : LanguageEn ? "Player" : "Игрок", valueInfo, false));
                        fieldsUnban.Add(new Fields(LanguageEn ? "Reduced by" : "Снижено на", FormatTime(unBanTime, null), false));
                        fieldsUnban.Add(new Fields(LanguageEn ? "Time left until unban" : "Осталось до разблокировки", FormatTime(infoUser.GetUnbanTime, null), false));
                        fieldsUnban.Add(new Fields("", "", false));

                        SendDiscord(fieldsUnban, TypeAlertDiscord.Unbanned, config.generalSetting.discordSetting.webHookUnBanned);
                    }
                    return;
                }
            }
            
            PlayerInfo.Remove(valueInfo, type);

            if (IsOpenMySQL())
                DeleteDatabase(valueInfo, type);

            Interface.CallHook(type == TypeAction.BannedSteamID ? "OnUnbannedID" : "OnUnbannedIP", valueInfo, ownerPlayer); 
		   		 		  						  	   		  		 			  	   		  		  		   		 
            SendInfo(ownerPlayer, LanguageEn ? $"Player {valueInfo} has been unbanned. Unban issued by {ownerCommand}" : $"Игрок {valueInfo} был разблокирован. Выдал разблокировку {ownerCommand}");
            if (ownerPlayer != null)
                SendInfo(null, LanguageEn ? $"Player {valueInfo} has been unbanned. Unban issued by {ownerCommand}" : $"Игрок {valueInfo} был разблокирован. Выдал разблокировку {ownerCommand}");
            
            if (!String.IsNullOrWhiteSpace(config.generalSetting.discordSetting.webHookUnBanned))
            {
                List<Fields> fieldsUnban = new List<Fields>();

                fieldsUnban.Add(new Fields(LanguageEn ? "Removed ban" : "Снял блокировку", ownerCommand, true));
                fieldsUnban.Add(new Fields(type == TypeAction.BannedIP ? "IP" : LanguageEn ? "Player" : "Игрок", valueInfo, false));
                fieldsUnban.Add(new Fields("", "", false));
		   		 		  						  	   		  		 			  	   		  		  		   		 
                SendDiscord(fieldsUnban, TypeAlertDiscord.Unbanned, config.generalSetting.discordSetting.webHookUnBanned);
            }
        }

        private void LeaveTeamPlayer(UInt64 targetPlayer)
        {
            foreach (KeyValuePair<UInt64, Dictionary<UInt64, TeamLocalMemory>> memoryTeams in teamLocalMemory)
            {
                foreach (KeyValuePair<UInt64,TeamLocalMemory> localMemory in memoryTeams.Value)
                {
                    if ((localMemory.Key != targetPlayer && memoryTeams.Key != targetPlayer)) continue;
                    localMemory.Value.lastRemoved = CurrentTime;
                }
            }
        }

        private enum TypeAlertDiscord
        {
            Banned,
            Unbanned,
            Kicked,
            ConnectionBanned
        }
        
        private enum TypeDestroy
        {
            AllObjects,
            AllObjectsAndDropInStorage,
            OnlyLocks,
            OnlyStorage,
            OnlyStorageAndDropInStorage,
        }
        
        private readonly Core.MySql.Libraries.MySql sqlLibrary = Interface.Oxide.GetLibrary<Core.MySql.Libraries.MySql>();

        
        private void SendDiscord(List<Fields> fields, TypeAlertDiscord typeAlertDiscord, String webHooks)
        {
            if (String.IsNullOrWhiteSpace(webHooks)) return;
            
            String nameAction = typeAlertDiscord switch
            {
                TypeAlertDiscord.Banned => LanguageEn ? "Banned function" : "Функции блокировки",
                TypeAlertDiscord.Unbanned => LanguageEn ? "Unbanned function" : "Функции разблокировки",
                TypeAlertDiscord.Kicked => LanguageEn ? "Player Kicked" : "Игрок кикнут",
                TypeAlertDiscord.ConnectionBanned => LanguageEn ? "A blocked player's login attempt" : "Попытка входа заблокированного игрока",
                _ => "ERROR ALERT EMBED"
            };
            
            Int32 colorEmbed = typeAlertDiscord switch
            {
                TypeAlertDiscord.Banned => 16734296,
                TypeAlertDiscord.Unbanned => 16752984,
                TypeAlertDiscord.Kicked => 12741939,
                TypeAlertDiscord.ConnectionBanned => 5832569,
                _ => 2558568
            };
            
            FancyMessage newMessage = new FancyMessage(null, false, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, colorEmbed, fields, new Authors(nameAction, null, config.generalSetting.discordSetting.imageLink, null), 
                new Footer($"{(LanguageEn ? "Server" : "Сервер")} {config.generalSetting.serverName} - {config.generalSetting.serverAdress}", "", "")) });

            Request(webHooks, newMessage.toJSON());
        }

        private String GetKickReason(PlayerInfo playerData, string userID)
        {
            if (!string.IsNullOrWhiteSpace(playerData.reason))
            {
                return playerData.permanent ? 
                    GetLang("BANNED_ALERT_PERMANENT", userID, playerData.reason) :
                    GetLang("BANNED_ALERT_TIME", userID, playerData.reason, FormatTime(playerData.GetUnbanTime, userID));
            }
            else
            {
                return playerData.permanent ? 
                    GetLang("BANNED_DEFAULT_REASON_PERMANENT", userID) :
                    GetLang("BANNED_DEFAULT_REASON", userID, FormatTime(playerData.GetUnbanTime, userID));
            }
        }
        private const String permissionsIgnoreVPN = "iqbansystem.ignorevpncheck";

        
        
        private void DeleteDatabase(String idOrIP, TypeAction typeUnBanned)
        {
            if (sqlConnection == null) return;
            String sqlQueryDelete = SQL_Query_DeletedDatabase(typeUnBanned);
            Sql deleteCommand = Oxide.Core.Database.Sql.Builder.Append(sqlQueryDelete, idOrIP);
            sqlLibrary.Delete(deleteCommand, sqlConnection, rowsAffected =>
            {
                Puts(LanguageEn ? $"User removed from the database: {idOrIP}" : $"В базе данных удален пользователь : {idOrIP}");
            });
        }
        private Int32 maxDetectedVpn = 1;
		   		 		  						  	   		  		 			  	   		  		  		   		 
        private void LoadDataFiles(TypeAction type)
        {
            String[] players = PlayerInfo.GetFiles(type);
            foreach (String player in players)
                PlayerInfo.Load(player, type);

            String Message = type == TypeAction.BannedSteamID
                ? (LanguageEn ? $"Database initialized with {players.Length} banned players" : $"Инициализирована база данных {players.Length} забаненных игроков")
                : (LanguageEn ? $"Database initialized with {players.Length} banned IPs" : $"Инициализирована база данных {players.Length} забаненных IP-адресов");
            
            Puts(Message);
        }

        private void BanUser(UInt64 userID, IPlayer iPlayer = null, String reason = default, Double banTime = 0, BasePlayer ownerCommand = null, Boolean skipTeam = false)
        {
            if (!userID.IsSteamId()) return;

            Object canBanPlayer = Interface.Oxide.CallHook("CanBanPlayer", userID, reason, banTime, ownerCommand); 
            if (canBanPlayer != null)
            {
                switch (canBanPlayer)
                {
                    case String player when !string.IsNullOrWhiteSpace(player):
                        Puts($"{canBanPlayer}");
                        return;
                    case Boolean value when !value:
                        return;
                }
            }
            
            String idPlayer = userID.ToString();
            
            BanUserOrIp(idPlayer, iPlayer?.Name, iPlayer?.Address, reason, banTime, TypeAction.BannedSteamID, ownerCommand, skipTeam);
        }
        private const Boolean LanguageEn = false;
        private readonly Dictionary<String, ProcessCheckVPN> ipListChecked = new Dictionary<String, ProcessCheckVPN>();
        private const String permissionIgnoreBan = "iqbansystem.ignoreban";
        private Boolean useProxyCheck = false;
        
        void OnTeamDisbanded(RelationshipManager.PlayerTeam team)
        {
            foreach (UInt64 teamMember in team.members)
                LeaveTeamPlayer(teamMember);
        }
		   		 		  						  	   		  		 			  	   		  		  		   		 
        private Timer timerUpdateMarkers = null;

        public class Authors
        {
            public String name { get; set; }
            public String url { get; set; }
            public String icon_url { get; set; }
            public String proxy_icon_url { get; set; }
            public Authors(String name, String url, String icon_url, String proxy_icon_url)
            {
                this.name = name;
                this.url = url;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        private static readonly DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);

        
        
        private void InserOrUpdateDatabase(String idOrIP, TypeAction typeBanned, IPlayer mbPlayer = null)
        {
            if (sqlConnection == null) return;

            PlayerInfo playerInfo = PlayerInfo.Get(idOrIP, typeBanned);
            if (playerInfo == null) return;
            
            String ipAddress = typeBanned == TypeAction.BannedIP ? idOrIP : mbPlayer?.Address ?? "None";
            String userID = typeBanned == TypeAction.BannedSteamID ? idOrIP : mbPlayer?.Id ?? "None";
            
            String jsonNameHistory = JsonConvert.SerializeObject(playerInfo.nameHistory, Formatting.None);
            String jsonIpHistory = JsonConvert.SerializeObject(playerInfo.ipHistory, Formatting.None);
            String jsonSteamHistory = JsonConvert.SerializeObject(playerInfo.steamIdHistory, Formatting.None);
            
            String sqlQueryUpdate = SQL_Query_UpdateUser(typeBanned);
            Sql updateCommand = Oxide.Core.Database.Sql.Builder.Append(sqlQueryUpdate, userID, ipAddress, 
                playerInfo.permanent, playerInfo.timeUnbanned, playerInfo.reason, playerInfo.serverName, playerInfo.serverAdress, playerInfo.owner, jsonNameHistory, jsonIpHistory, jsonSteamHistory);
        
            sqlLibrary.Update(updateCommand, sqlConnection, rowsAffected =>
            {
                if (rowsAffected <= 0)
                {
                    String sqlQueryInsert = SQL_Query_InsertUser();
                    Sql insertCommand = Oxide.Core.Database.Sql.Builder.Append(sqlQueryInsert, userID, ipAddress, 
                        playerInfo.permanent, playerInfo.timeUnbanned, playerInfo.reason, playerInfo.serverName, playerInfo.serverAdress, playerInfo.owner, jsonNameHistory, jsonIpHistory, jsonSteamHistory);
                    
                    sqlLibrary.Insert(insertCommand, sqlConnection, rowsAffecteds =>
                    {
                        Puts(LanguageEn ? $"New user added to the database: {userID}/{ipAddress}" : $"В базу данных добавлен новый пользователь : {userID}/{ipAddress}");
                    });
                }
                else Puts(LanguageEn ? $"User data updated in the database: {userID}/{ipAddress}" : $"В базе данных обновлены данные о пользователе : {userID}/{ipAddress}");
            });
        }
        
            }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    



// --- End of file: IQBanSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/VoteDay.cs ---
// --- Original Local Path: VoteDay.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("VoteDay", "S1m0n", "1.0.0")]
    class VoteDay : RustPlugin
    {
        #region Fields
        private List<ulong> votesReceived = new List<ulong>();
        static Dictionary<string, string> imageIds = new Dictionary<string, string>();

        private bool voteOpen;
        private bool isWaiting;
        private int timeRemaining;
        private int requiredVotes;
        private Timer voteTimer;
        private Timer timeMonitor;
        #endregion

        #region UI
        public class UI
        {
            static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool useCursor = false)
            {
                var NewElement = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color},
                            RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                            CursorEnabled = useCursor
                        },
                        new CuiElement().Parent,
                        panelName
                    }
                };
                return NewElement;
            }
            static public void CreatePanel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel);
            }
            static public void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);

            }
            public static string Color(string hexColor, float alpha)
            {
                if (hexColor.StartsWith("#"))
                    hexColor = hexColor.TrimStart('#');
                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} {alpha}";
            }
        }
        #endregion

        #region UI Creation
        private const string Main = "VDUIMain";
        private void CreateTimeUI(BasePlayer player)
        {
            var MainCont = UI.CreateElementContainer(Main, UI.Color(configData.Colors.UIBackgroundColor, configData.Colors.UIBackgroundAlpha), "0.702 0.96", "1 1");
            UI.CreateLabel(ref MainCont, Main, "", $"<color={configData.Colors.MainColor}>{msg("Пропуcтить ночь", player.UserIDString)}</color>", 20, "0.018 0", "3 1", TextAnchor.MiddleLeft);

            var percentVotes = System.Convert.ToDouble((float)votesReceived.Count / (float)requiredVotes);
            var yMaxVotes = 0.25f + (0.55f * percentVotes);
            UI.CreatePanel(ref MainCont, Main, UI.Color(configData.Colors.UIBackgroundColor, configData.Colors.UIBackgroundAlpha), $"0.4 0", $"0.84 1");
            UI.CreatePanel(ref MainCont, Main, UI.Color(configData.Colors.ProgressBarColor, 1), $"0.4 0.15", $"{yMaxVotes} 0.85");            
            UI.CreateLabel(ref MainCont, Main, "", $"{votesReceived.Count} / {requiredVotes}", 19, "0.25 0.15", "1 0.85");

            UI.CreateLabel(ref MainCont, Main, "", GetFormatTime(), 20, "0.8 0.1", "0.98 0.9", TextAnchor.MiddleRight);

            CuiHelper.DestroyUi(player, Main);
            CuiHelper.AddUi(player, MainCont);
        }
        
        private void RefreshAllUI()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (voteOpen)
                    CreateTimeUI(player);
                else CuiHelper.DestroyUi(player, Main);
            }
        }
        #endregion

        #region Oxide Hooks
        void Loaded()
        {
            lang.RegisterMessages(Messages, this);
            permission.RegisterPermission("voteday.admin", this);           
        }
        void OnServerInitialized()
        {
            LoadVariables();
            votesReceived = new List<ulong>();
            requiredVotes = 0;
            voteOpen = false;
            timeRemaining = 0;
            CheckTime();
        }
        void OnPlayerDisconnected(BasePlayer player) => CuiHelper.DestroyUi(player, Main);
        void Unload()
        {
            if (voteTimer != null)
                voteTimer.Destroy();            

            foreach (var player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, Main);
        }
        #endregion

        #region Functions
        private void OpenVote()
        {
            var required = BasePlayer.activePlayerList.Count * configData.Options.RequiredVotePercentage;
            if (required < 1) required = 1;
            requiredVotes = Convert.ToInt32(required);
            voteOpen = true;
            Print("commandSyn");
            VoteTimer();
        }
        private void VoteTimer()
        {
            timeRemaining = configData.Options.VoteOpenTime;
            voteTimer = timer.Repeat(1, timeRemaining, () =>
            {
                RefreshAllUI();
                timeRemaining--;
                switch (timeRemaining)
                {
                    case 0:
                        TallyVotes();
                        return;
                    case 240:
                    case 180:
                    case 120:
                    case 60:
                    case 30:
                        MessageAll();
                        break;
                    default:
                        break;
                }                            
            });
        }
        private void MessageAll()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (player != null)
                {
                    if (!AlreadyVoted(player))
                        Reply(player, "commandSyn");
                }
            }
        }
        private string GetFormatTime()
        {
            var time = timeRemaining;
            double minutes = Math.Floor((double)(time / 60));
            time -= (int)(minutes * 60);            
            return string.Format("{0:00}:{1:00}", minutes, time);
        }
        private void CheckTime()
        {            
            if (!voteOpen)
            {
                if (isWaiting)
                {
                    timeMonitor = timer.Once(20, () => CheckTime());
                    return;
                }
                
                if ((TOD_Sky.Instance.Cycle.Hour >= configData.Options.TimeToOpen && TOD_Sky.Instance.Cycle.Hour < 24) || (TOD_Sky.Instance.Cycle.Hour >= 0 && TOD_Sky.Instance.Cycle.Hour < configData.Options.TimeToSet))                                    
                    OpenVote();                
                else timeMonitor = timer.Once(20, () => CheckTime());
            }
            else
            {
                if (TOD_Sky.Instance.Cycle.Hour >= configData.Options.TimeToSet && TOD_Sky.Instance.Cycle.Hour < configData.Options.TimeToOpen)                
                    VoteEnd(false);
            }
        }
        private void TallyVotes()
        {
            if (votesReceived.Count >= requiredVotes)
                VoteEnd(true);
            else VoteEnd(false);
        }
        private void VoteEnd(bool success)
        {
            foreach (var player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, Main);
            voteOpen = false;
            requiredVotes = 0;
            voteTimer.Destroy();
            votesReceived.Clear();
            timeRemaining = 0;

            if (success)
            {
                TOD_Sky.Instance.Cycle.Hour = configData.Options.TimeToSet;
                Print("votingSuccessful");
            }
            else Print("votingUnsuccessful");
            isWaiting = true;
            timer.In(600, () => isWaiting = false);          
            CheckTime();
        }
        #endregion

        #region Helpers
        private bool AlreadyVoted(BasePlayer player) => votesReceived.Contains(player.userID);
        #endregion

        #region ChatCommands
        [ChatCommand("voteday")]
        private void cmdVoteDay(BasePlayer player, string command, string[] args)
        {
            if (args.Length == 0)
            {
                if (voteOpen)
                {
                    if (!AlreadyVoted(player))
                    {
                        votesReceived.Add(player.userID);
                        Reply(player, "voteSuccess");
                        if (votesReceived.Count >= requiredVotes)
                            VoteEnd(true);
                        return;
                    }
                }
                else Reply(player, "noVote");
            }
            else
            {
                if (!permission.UserHasPermission(player.UserIDString, "voteday.admin")) return;
                switch (args[0].ToLower())
                {
                    case "open":
                        if (!voteOpen)
                            OpenVote();
                        else Reply(player, "alreadyOpen");
                        return;
                    case "close":
                        if (voteOpen)
                            VoteEnd(false);
                        else Reply(player, "noVote");
                        return;
                    default:
                        Reply(player, "invalidSyntax");
                        break;
                }
            }
        }       
        #endregion

        #region Config        
        private ConfigData configData;
        class Colors
        {
            public string MainColor { get; set; }
            public string MSGColor { get; set; }
            public string ProgressBarColor { get; set; }
            public string UIBackgroundColor { get; set; }
            public float UIBackgroundAlpha { get; set; }
        }
        
        class Options
        {
            public float RequiredVotePercentage { get; set; }
            public float TimeToOpen { get; set; }
            public float TimeToSet { get; set; }
            public int VoteOpenTime { get; set; }            
        }
        class ConfigData
        {
            public Colors Colors { get; set; }            
            public Options Options { get; set; } 
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {

                Colors = new Colors
                {
                    MainColor = "#ffae00",
                    MSGColor = "#ffffff",
                    ProgressBarColor = "#EBB146",
                    UIBackgroundAlpha = 0.7f,
                    UIBackgroundColor = "#404040"
                },
                Options = new Options
                {
                    RequiredVotePercentage = 0.4f,
                    TimeToOpen = 18f,
                    TimeToSet = 8f,
                    VoteOpenTime = 240
                }                
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Localization
        void Reply(BasePlayer player, string langKey) => SendReply(player, msg(langKey, player.UserIDString).Replace("{main}", $"<color={configData.Colors.MainColor}>").Replace("{msg}", $"<color={configData.Colors.MSGColor}>").Replace("{percent}", (configData.Options.RequiredVotePercentage * 100).ToString()));
        void Print(string langKey) => PrintToChat(msg(langKey).Replace("{main}", $"<color={configData.Colors.MainColor}>").Replace("{msg}", $"<color={configData.Colors.MSGColor}>").Replace("{percent}", (configData.Options.RequiredVotePercentage * 100).ToString()));
        string msg(string key, string playerId = "") => lang.GetMessage(key, this, playerId);
        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            {"voteSuccess", "{msg}Вы проголосовали за пропуск ночи!</color>" },
            {"noVote", "{msg}На данный момент голосование не запущено!</color>" },
            {"alreadyOpen", "{msg}Голосование уже запущено!</color>" },
            {"invalidSyntax", "{msg}Неправильный синтаксис!</color> {main}/voteday open</color>{msg} или </color> {main}/voteday close</color>" },
            {"votingSuccessful", "{main}Голосование прошло успешно!</color>{msg} Ночь пропущена</color>" } ,
            {"votingUnsuccessful", "{msg}Голосование не удалось! Слишком мало игроков проголосовало!</color>" },
            {"commandSyn", "{msg}Введите </color>{main}/voteday</color>{msg}, если вы хотите пропустить ночь!\n-- Необходимо </color>{main}{percent}%</color>{msg} голосов от общего количества игроков</color>" },
            {"skipNight", "Пропуcтить ночь" }        
        };
        #endregion
    }
}



// --- End of file: VoteDay.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BestLoot.cs ---
// --- Original Local Path: BestLoot.cs ---

﻿using Rust;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Reflection;
using UnityEngine;
using Oxide.Core.Plugins;
using Random = System.Random;
using Oxide.Core;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("BestLoot", "Admin", "1.0", ResourceId = 0)]
    [Description("Настройка лута в различных бочках и ящиках.")]

    public class BestLoot : RustPlugin
    {
        public const string LOOTTABLES_DATA = "BestLoot\\LootTables";

        // Привилегии
        public const string permReloadLoot = "bestloot.reloadloot";
        public const string permResetConfig = "bestloot.resetconfig";

        public Random rnd = new Random();

        bool initialized = false;

        private ConfigData configData;
        private Dictionary<string, LootTableEntry> lootTables = new Dictionary<string, LootTableEntry>();

        class ConfigData
        {
            public Dictionary<string, LootTableMap> tables { get; set; }
            public List<string> includeammo_items { get; set; }
        }

        // Потому что это не .NET 4.0 ...
        class LootTuple
        {
            public string item { get; set; }
            public int amount { get; set; }
            public string subitem { get; set; }
            public int subamount { get; set; }
            public bool nostack { get; set; }
            public float condition { get; set; }

            public LootTuple(string i, int a, string si = null, int sa = 0, bool ns = false, float c = 100)
            {
                item = i;
                amount = a;
                subitem = si;
                subamount = sa;
                nostack = ns;
                condition = c;
            }
        }

        // Отображает таблицу добычи в контейнерах и настройки параметров.
        class LootTableMap
        {
            public List<string> containers { get; set; }

            // Эти два параметра предназначены для простого распределения таблицы.
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate, NullValueHandling = NullValueHandling.Ignore)]
            public string table { get; set; }

            [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate, NullValueHandling = NullValueHandling.Ignore)]
            public int amount { get; set; }

            // Используйте это, если вы хотите иметь несколько таблиц со случайным шансом выпадения.
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate, NullValueHandling = NullValueHandling.Ignore)]
            public Dictionary<string, TableEntry> tables { get; set; }
        }

        class LootTableEntry
        {
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate, NullValueHandling = NullValueHandling.Ignore)]
            public bool includeammo { get; set; }

            public Dictionary<string, ItemEntry> items { get; set; } = new Dictionary<string, ItemEntry>();
        }

        class TableEntry
        {
            public string table { get; set; }
            public int chance { get; set; }
            public int amount { get; set; }
        }

        class ItemEntry
        {
            // Сумма, которая должна быть равна 0, приведет к использованию min/max.
            public int amount { get; set; }

            // Шанс выпадения в от 1-100%.
            public int chance { get; set ; }

            [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate, NullValueHandling = NullValueHandling.Ignore)]
            public bool nostack { get; set; }

            // Минимальная сумма предмета.
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate, NullValueHandling = NullValueHandling.Ignore)]
            public int min { get; set; }

            // Максимальная сумма предмета.
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate, NullValueHandling = NullValueHandling.Ignore)]
            public int max { get; set ; }

            [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate, NullValueHandling = NullValueHandling.Ignore)]
            public float? condition { get; set ; }

            [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate, NullValueHandling = NullValueHandling.Ignore)]
            public float? conditionmin { get; set ; }

            [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate, NullValueHandling = NullValueHandling.Ignore)]
            public float? conditionmax { get; set ; }

            // Имеется ли в элементе подтип (вода в бутылках, топливо в шляпах)
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate, NullValueHandling = NullValueHandling.Ignore)]
            public string subitem { get; set; }

            // Какую часть этого подпункта включить?
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate, NullValueHandling = NullValueHandling.Ignore)]
            public int subamount { get; set; }
        }


        void Init()
        {
            #if !RUST
            throw new NotSupportedException("Плагин поддерживается только в RUST.");
            #endif

            permission.RegisterPermission(permReloadLoot, this);
            permission.RegisterPermission(permResetConfig, this);
        }

        void OnServerInitialized()
        {
            LoadVariables();

            if (initialized)
                return;

            // Список еще не заполнен, повторный обратный вызов.
            var itemList = ItemManager.itemList;
            if (itemList == null || itemList.Count == 0) {
                NextTick(OnServerInitialized);
                return;
            }

            // Удалить все существующие контейнеры.
            timer.Once(0.1f, () =>  {
                foreach (var container in UnityEngine.Object.FindObjectsOfType<LootContainer>()) {
                    FillContainer(container);
                }

                initialized = true;
            });
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            LoadLootTables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
             configData = new ConfigData {
                includeammo_items = new List<string> {
                    "bow.hunting",
                    "crossbow",
                    "pistol.eoka"
                },
                tables = new Dictionary<string, LootTableMap> {
                    { "scrap", new LootTableMap {
                        containers = new List<string> { "trash-pile", "foodbox", "loot_barrel", "loot-barrel", "crate_normal_2.prefab" },
                        table = "ScrapTable",
                        amount = 1 }
                    },
                    { "foodboxes", new LootTableMap {
                        containers = new List<string> { "trash-pile", "foodbox" },
                        table = "FoodTable",
                        amount = 3 }
                    },
                    { "foodcrate", new LootTableMap {
                        containers = new List<string> { "crate_normal_2_food.prefab" },
                        table = "FoodTable",
                        amount = 5 }
                    },
                    { "oilbarrels", new LootTableMap {
                        containers = new List<string> { "oil_barrel" },
                        table = "FuelTable",
                        amount = 2 }
                    },
                    { "barrels", new LootTableMap {
                        containers = new List<string> { "loot_barrel", "loot-barrel" },
                        table = "BarrelTable",
                        amount = 2 }
                    },
                    { "normalcrates", new LootTableMap {
                        containers = new List<string> { "crate_normal_2.prefab" },
                        table = "NormalCrateTable",
                        amount = 2 }
                    },
                    { "greencrates", new LootTableMap {
                        containers = new List<string> { "crate_normal.prefab" },
                    //    table = "GreenCrateTable",
                    //    amount = 3 
                          tables = new Dictionary<string, TableEntry> {
                              { "GreenCrateTable", new TableEntry {
                                    chance = 50,
                                    amount = 1 } },
                              { "BarrelTable", new TableEntry {
                                   chance = 50,
                                   amount = 2 } } 
                          } }
                    },
                    { "medicalcrates", new LootTableMap {
                        containers = new List<string> { "crate_normal_2_medical.prefab" },
                        table = "MedicalCrateTable",
                        amount = 3 }
                    },
                    { "toolcrates", new LootTableMap {
                        containers = new List<string> { "crate_tools.prefab" },
                        table = "ToolsCrateTable",
                        amount = 3 }
                    },
                    { "bradleycrates", new LootTableMap {
                        containers = new List<string> { "bradley_crate" },
                        table = "BradleyCrateTable",
                        amount = 4 }
                    },
                    { "helicrates", new LootTableMap {
                        containers = new List<string> { "heli_crate" },
                        table = "HeliCrateTable",
                        amount = 4 }
                    },
                    { "bow.hunting", new LootTableMap {
                        containers = new List<string>(),
                        table = "ArrowsTable",
                        amount = 2 }
                    },
                    { "crossbow", new LootTableMap {
                        containers = new List<string>(),
                        table = "ArrowsTable",
                        amount = 2 }
                    },
                    { "pistol.eoka", new LootTableMap {
                        containers = new List<string>(),
                        table = "HandmadeShellTable",
                        amount = 1 }
                    },
                    { "shotgun.waterpipe", new LootTableMap {
                        containers = new List<string>(),
                        table = "HandmadeShellTable",
                        amount = 1 }
                    }
                }
            };

            SaveConfig(configData);
        }

        void LoadLootTables()
        {
            lootTables = Interface.GetMod().DataFileSystem.ReadObject<Dictionary<string, LootTableEntry>>(LOOTTABLES_DATA);
            if (lootTables.Count == 0) {
                Puts("Empty loot table, populating with defaults.");
                CreateDefaultLootTables();
            }
        }

        void CreateDefaultLootTables()
        {
            lootTables = new Dictionary<string, LootTableEntry> {
                { "ScrapTable", new LootTableEntry {
                        items = new Dictionary<string, ItemEntry> {
                            { "scrap",    new ItemEntry { chance = 100, min = 1, max = 10 } }
                        }
                    }
                },
                { "HandmadeShellTable", new LootTableEntry {
                        items = new Dictionary<string, ItemEntry> {
                            { "ammo.handmade.shell", new ItemEntry { chance = 100, min = 5, max = 15 } }
                        }
                    }
                },
                { "FoodTable", new LootTableEntry {
                        items = new Dictionary<string, ItemEntry> {
                            { "apple",            new ItemEntry { chance = 10, min = 1, max = 10 } },
                            { "chocholate",       new ItemEntry { chance = 15, min = 1, max = 3 } },
                            { "granolabar",       new ItemEntry { chance = 15, min = 1, max = 3 } },
                            { "can.beans",        new ItemEntry { chance = 15, min = 1, max = 3 } },
                            { "can.tuna",         new ItemEntry { chance = 15, min = 1, max = 3 } },
                            { "smallwaterbottle", new ItemEntry { chance = 10, amount = 1, subitem = "water", subamount = 250, nostack = true } },
                            { "waterjug",         new ItemEntry { chance = 5, amount = 1, subitem = "water", subamount = 3000, nostack = true } },
                            { "candycane",        new ItemEntry { chance = 1, amount = 1 } },
                            { "pumpkin",          new ItemEntry { chance = 7, min = 1, max = 2, nostack = true } },
                            { "corn",             new ItemEntry { chance = 7, min = 1, max = 2, nostack = true } }
                        }
                    }
                },
                { "FuelTable", new LootTableEntry {
                        items = new Dictionary<string, ItemEntry> {
                            { "crude.oil",    new ItemEntry { chance = 50, min = 5, max = 15 } },
                            { "lowgradefuel", new ItemEntry { chance = 50, min = 10, max = 30 } }
                        }
                    }
                },
                { "BarrelTable", new LootTableEntry {
                        items = new Dictionary<string, ItemEntry> {
                            { "rope",            new ItemEntry { chance = 10, min = 1, max = 4 } },
                            { "sewingkit",       new ItemEntry { chance = 10, min = 1, max = 4 } },
                            { "tarp",            new ItemEntry { chance = 7, min = 1, max = 3 } },
                            { "roadsigns",       new ItemEntry { chance = 10, min = 1, max = 3 } },
                            { "metalpipe",       new ItemEntry { chance = 5, min = 1, max = 2 } },
                            { "metalspring",     new ItemEntry { chance = 8, min = 1, max = 2 } },
                            { "metalblade",      new ItemEntry { chance = 10, min = 1, max = 3 } },
                            { "gears",           new ItemEntry { chance = 10, min = 1, max = 3 } },
                            { "semibody",        new ItemEntry { chance = 5, amount = 1 } },
                            { "propanetank",     new ItemEntry { chance = 5, amount = 1 } },
                            { "sheetmetal",      new ItemEntry { chance = 12, min = 1, max = 2 } },
                            { "syringe.medical", new ItemEntry { chance = 5, min = 1, max = 2 } },
                            { "ammo.pistol",     new ItemEntry { chance = 3, min = 10, max = 30 } }
                        }
                    }
                },
                { "ToolsCrateTable", new LootTableEntry {
                        includeammo = true,
                        items = new Dictionary<string, ItemEntry> {
                            { "grenade.beancan",   new ItemEntry { chance = 1, min = 1, max = 2 } },
                            { "grenade.f1",        new ItemEntry { chance = 1, amount = 1 } },
                            { "coffeecan.helmet",  new ItemEntry { chance = 1, amount = 1, nostack = true } },
                            { "jacket.snow",       new ItemEntry { chance = 5, amount = 1, nostack = true } },
                            { "jacket",            new ItemEntry { chance = 5, amount = 1, nostack = true } },
                            { "shirt.collared",    new ItemEntry { chance = 5, amount = 1, nostack = true } },
                            { "machete",           new ItemEntry { chance = 5, amount = 1, nostack = true } },
                            { "bow.hunting",       new ItemEntry { chance = 10, amount = 1, nostack = true } },
                            { "crossbow",          new ItemEntry { chance = 5, amount = 1, nostack = true } },
                            { "shotgun.waterpipe", new ItemEntry { chance = 4, amount = 1, nostack = true } },
                            { "pistol.eoka",       new ItemEntry { chance = 7, amount = 1, nostack = true } },
                            { "pants",             new ItemEntry { chance = 5, amount = 1, nostack = true } },
                            { "hoodie",            new ItemEntry { chance = 5, amount = 1, nostack = true } },
                            { "hat.wolf",          new ItemEntry { chance = 5, amount = 1, nostack = true } },
                            { "pickaxe",           new ItemEntry { chance = 8, amount = 1, nostack = true } },
                            { "mace",              new ItemEntry { chance = 7, amount = 1, nostack = true } },
                            { "longsword",         new ItemEntry { chance = 4, amount = 1, nostack = true } },
                            { "hatchet",           new ItemEntry { chance = 7, amount = 1, nostack = true } },
                            { "axe.salvaged",      new ItemEntry { chance = 5, amount = 1, nostack = true } },
                            { "icepick.salvaged",  new ItemEntry { chance = 5, amount = 1, nostack = true } }
                        }
                    }
                },
                { "MedicalCrateTable", new LootTableEntry {
                        items = new Dictionary<string, ItemEntry> {
                            { "jacket.snow",       new ItemEntry { chance = 5, amount = 1, nostack = true } },
                            { "syringe.medical",   new ItemEntry { chance = 20, min = 1, max = 5 } },
                            { "antiradpills",      new ItemEntry { chance = 25, min = 1, max = 3 } },
                            { "bandage",           new ItemEntry { chance = 25, min = 3, max = 9 } },
                            { "black.raspberries", new ItemEntry { chance = 15, min = 1, max = 4 } },
                            { "largemedkit",       new ItemEntry { chance = 10, min = 1, max = 3 } }
                        }
                    }
                },
                { "NormalCrateTable", new LootTableEntry {
                        items = new Dictionary<string, ItemEntry> {
                            { "hazmatsuit",         new ItemEntry { chance = 5, amount = 1, nostack = true } },
                            { "cctv.camera",        new ItemEntry { chance = 5, amount = 1 } },
                            { "tool.binoculars",    new ItemEntry { chance = 5, amount = 1 } },
                            { "tool.camera",        new ItemEntry { chance = 2, amount = 1 } },
                            { "targeting.computer", new ItemEntry { chance = 5, amount = 1 } },
                            { "gears",              new ItemEntry { chance = 15, min = 2, max = 5 } },
                            { "metalpipe",          new ItemEntry { chance = 10, min = 2, max = 4 } },
                            { "smgbody",            new ItemEntry { chance = 8, min = 1, max = 2 } },
                            { "semibody",           new ItemEntry { chance = 12, min = 1, max = 2 } },
                            { "riflebody",          new ItemEntry { chance = 1, amount = 1 } },
                            { "roadsigns",          new ItemEntry { chance = 12, min = 2, max = 5 } },
                            { "sewingkit",          new ItemEntry { chance = 15, min = 2, max = 6 } },
                            { "ammo.rifle",         new ItemEntry { chance = 5, min = 10, max = 30 } }

                        }
                    }
                },
                { "HeliCrateTable", new LootTableEntry {
                        items = new Dictionary<string, ItemEntry> {
                            { "rifle.ak",             new ItemEntry { chance = 8, amount = 1, nostack = true } },
                            { "rocket.launcher",      new ItemEntry { chance = 5, amount = 1, nostack = true } },
                            { "pistol.m92",           new ItemEntry { chance = 5, amount = 1, nostack = true } },
                            { "lmg.m249",             new ItemEntry { chance = 4, amount = 1, nostack = true } },
                            { "metal.refined",        new ItemEntry { chance = 13, min = 100, max = 200 } },
                            { "techparts",            new ItemEntry { chance = 10, min = 10, max = 20 } },
                            { "explosive.timed",      new ItemEntry { chance = 5, min = 5, max = 10 } },
                            { "riflebody",            new ItemEntry { chance = 5, min = 4, max = 8 } },
                            { "ammo.rocket.basic",    new ItemEntry { chance = 5, min = 6, max = 15 } },
                            { "ammo.rocket.fire",     new ItemEntry { chance = 5, min = 12, max = 18 } },
                            { "ammo.rocket.hv",       new ItemEntry { chance = 5, min = 12, max = 18 } },
                            { "ammo.pistol.hv",       new ItemEntry { chance = 10, min = 100, max = 300 } },
                            { "ammo.rifle.explosive", new ItemEntry { chance = 10, min = 100, max = 300 } },
                            { "ammo.rifle.hv",        new ItemEntry { chance = 10, min = 100, max = 300 } }

                        }
                    }
                },
                { "BradleyCrateTable", new LootTableEntry {
                        items = new Dictionary<string, ItemEntry> {
                            { "rifle.ak",             new ItemEntry { chance = 8, amount = 1, nostack = true } },
                            { "rocket.launcher",      new ItemEntry { chance = 5, amount = 1, nostack = true } },
                            { "lmg.m249",             new ItemEntry { chance = 2, amount = 1, nostack = true } },
                            { "pistol.m92",           new ItemEntry { chance = 5, amount = 1, nostack = true } },
                            { "smg.mp5",              new ItemEntry { chance = 5, amount = 1, nostack = true } },
                            { "metal.refined",        new ItemEntry { chance = 15, min = 100, max = 200 } },
                            { "techparts",            new ItemEntry { chance = 10, min = 10, max = 20 } },
                            { "explosive.timed",      new ItemEntry { chance = 5, min = 5, max = 10 } },
                            { "riflebody",            new ItemEntry { chance = 10, min = 4, max = 8 } },
                            { "ammo.rocket.basic",    new ItemEntry { chance = 5, min = 6, max = 15 } },
                            { "ammo.pistol.hv",       new ItemEntry { chance = 10, min = 100, max = 300 } },
                            { "ammo.rifle.explosive", new ItemEntry { chance = 10, min = 100, max = 300 } },
                            { "ammo.rifle.hv",        new ItemEntry { chance = 10, min = 100, max = 300 } }

                        }
                    }
                },
                { "GreenCrateTable", new LootTableEntry {
                        items = new Dictionary<string, ItemEntry> {
                            { "rifle.ak",           new ItemEntry { chance = 1, amount = 1, nostack = true, condition = 50 } },
                            { "smg.thompson",       new ItemEntry { chance = 1, amount = 1, nostack = true, conditionmin = 1, conditionmax = 20 } },
                            { "smg.mp5",            new ItemEntry { chance = 1, amount = 1, nostack = true } },
                            { "metal.refined",      new ItemEntry { chance = 14, min = 5, max = 10 } },
                            { "cctv.camera",        new ItemEntry { chance = 10, amount = 1 } },
                            { "targeting.computer", new ItemEntry { chance = 10, amount = 1 } },
                            { "techparts",          new ItemEntry { chance = 15, min = 1, max = 4 } },
                            { "metalpipe",          new ItemEntry { chance = 12, min = 4, max = 7 } },
                            { "smgbody",            new ItemEntry { chance = 10, min = 1, max = 2 } },
                            { "riflebody",          new ItemEntry { chance = 10, min = 1, max = 2 } },
                            { "roadsigns",          new ItemEntry { chance = 12, min = 2, max = 5 } },
                            { "ammo.pistol.hv",     new ItemEntry { chance = 2, min = 10, max = 30 } },
                            { "ammo.rifle.hv",      new ItemEntry { chance = 2, min = 10, max = 30 } }

                        }
                    }
                },
                { "ArrowsTable", new LootTableEntry {
                        items = new Dictionary<string, ItemEntry> {
                            { "arrow.hv",     new ItemEntry { chance = 50, min = 5, max = 15 } },
                            { "arrow.wooden", new ItemEntry { chance = 50, min = 5, max = 15 } }
                        }
                    }
                }
            };

            SaveLootTables();
        }

        void SaveLootTables() => Interface.GetMod().DataFileSystem.WriteObject(LOOTTABLES_DATA, lootTables);
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        bool HasPerm(string id, string perm) => permission.UserHasPermission(id, perm);

        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (!initialized || entity == null)
                return;


            NextTick(() => {
                if (entity == null)
                    return;

                var container = entity as LootContainer;
                if (container == null)
                    return;

                FillContainer(container);
            });

        }

        // Для отладки прочности.
        void OnLoseCondition(Item item, ref float amount)
        {
            Puts("item condition is " + item.condition + " with a loss of " + amount);
        }


        void Unload()
        {
            var lootContainers = Resources.FindObjectsOfTypeAll<LootContainer>().Where(c => c.isActiveAndEnabled && !c.IsInvoking("SpawnLoot")).ToList();
            foreach (var container in lootContainers) {
                try {
                    container.Invoke("SpawnLoot", UnityEngine.Random.Range(container.minSecondsBetweenRefresh, container.maxSecondsBetweenRefresh));
                } catch {}
            }
        }

        [ConsoleCommand("reloadloot")]
        void ReloadLootConsoleCmd(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null && !arg.Player().IsAdmin) {
                return;
            }

            arg.ReplyWith("[BestLoot] Перезагрузка контейнеров");
            ReloadLoot();
        }

        [ChatCommand("reloadloot")]
        void ReloadLootCmd(BasePlayer player)
        {
            if (!HasPerm(player.UserIDString, permReloadLoot)) {
                return;
            }

            Puts("Перезагрузка контейнеров");
            PrintToChat(player, "[BestLoot] Перезагрузка контейнеров");
            ReloadLoot();
        }

        [ChatCommand("resetconfig")]
        void ResetConfigCmd(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null && !arg.Player().IsAdmin) {
                return;
            }

            arg.ReplyWith("[BestLoot] Сброс настроек по умолчанию.");
            ResetConfig();
        }

        void ResetConfigCmd(BasePlayer player)
        {
            if (!HasPerm(player.UserIDString, permResetConfig)) {
                return;
            }

            Puts("Сброс настроек loot обратно по умолчанию.");
            PrintToChat(player, "[BestLoot] Сброс конфигурации по умолчанию");
            ResetConfig();
        }

        private void ResetConfig()
        {
            LoadDefaultConfig();
            CreateDefaultLootTables();
        }

        private void ReloadLoot()
        {
            timer.Once(0.1f, () =>  {
                foreach (var container in UnityEngine.Object.FindObjectsOfType<LootContainer>()) {
                    FillContainer(container);
                }
            });
        }


        string PickLookTable(LootTableMap lootmap)
        {
            int cumulativeP = 0;
            int diceRoll = rnd.Next(1, 101);

            foreach (KeyValuePair<string, TableEntry> te in lootmap.tables) {
                cumulativeP += te.Value.chance;
                if (diceRoll < cumulativeP) {
                    return te.Key;
                }
            }

            return "";
        }

        /**
         * This is the meat of the loot table lookup. It uses a cumulative
         * distribution to pick items randomly based on their defined
         * percentages. This means if your loot tables do not add up to 100%
         * in chance, whatever percentage is left over is the percentage this
         * function will not drop loot. This is a 'feature' not a bug.
         *
         * Additionally, this function will cross reference the the lookup
         * table for ammo if includeammo is true.
         */
        List<LootTuple> PickItems(LootTableMap lootmap, bool ammolookup = true)
        {
            List<LootTuple> items = new List<LootTuple>();
            LootTableEntry tableEntry;

            int itemamount = 0;

            if (lootmap.table != null && !lootmap.table.Equals("")) {
                tableEntry = lootTables[lootmap.table];
                itemamount = lootmap.amount;
            } else if (lootmap.tables != null) {
                string table = PickLookTable(lootmap);

                if (table.Equals("")) {
                    return items;
                }

                tableEntry = lootTables[table];
                itemamount = lootmap.tables[table].amount;
            } else {
                Puts("Нет таблицы или таблиц определения.");                
                return items;
            }

            for (int c = 0; c < itemamount; c++) {
                int cumulativeP = 0;
                int diceRoll = rnd.Next(1, 101);

                foreach (KeyValuePair<string, ItemEntry> ie in tableEntry.items) {
                    cumulativeP += ie.Value.chance;
                    if (diceRoll < cumulativeP) {
                        int amount = ie.Value.amount;
                        if (amount == null || amount == 0) {
                            if (ie.Value.min == null || ie.Value.max == null) {
                                // No amounts set? Use 1.
                                amount = 1;
                            } else {
                                // Use min/max instead:
                                amount = rnd.Next(ie.Value.min, ie.Value.max + 1);
                            }
                        }

                        float condition = 100;
                        if (ie.Value.condition != null) {
                            condition = (float)ie.Value.condition;
                        } else if (ie.Value.conditionmin != null && ie.Value.conditionmax != null) {
                            condition = (float)rnd.Next((int)ie.Value.conditionmin, (int)ie.Value.conditionmax);
                        }

                        items.Add(new LootTuple(
                            ie.Key,
                            amount,
                            ie.Value.subitem,
                            ie.Value.subamount,
                            ie.Value.nostack,
                            condition
                        ));

                        if (configData.includeammo_items.Contains(ie.Key) && ammolookup && tableEntry.includeammo) {
                            if (configData.tables.ContainsKey(ie.Key)) {
                                items.AddRange(PickItems(configData.tables[ie.Key], false));
                            } else {
                                Puts("[BestLoot] WARNING: боеприпасы включены, но таблица боеприпасов не найдена для " + ie.Key);
                            }

                        }
                        break;
                    }
                }
            }

            return items;
        }

        // I think this is whats causing older loot tables to appear, this is
        // different than despawning/respawning, but actually just changes loot.
        void DisableSpawnLoot(LootContainer container)
        {
            container.minSecondsBetweenRefresh = -1;
            container.maxSecondsBetweenRefresh = 0;

            container.CancelInvoke("SpawnLoot");
        }

        void FillContainer(LootContainer container)
        {
            if (container.inventory == null) {
                container.inventory = new ItemContainer();
                container.inventory.ServerInitialize(
                    null, container.inventorySlots);
                container.inventory.GiveUID();
            }

            string containerName = container.gameObject.name.ToLower();

            Dictionary<string, LootTuple>rolledLoot = new Dictionary<string, LootTuple>();

            foreach (KeyValuePair<string, LootTableMap> tables in configData.tables) {
                var containers = tables.Value.containers;
                if (containers == null)
                    continue;

                foreach (var c in containers) {
                    if (containerName.Contains(c)) {
                        DisableSpawnLoot(container);
                        EmptyContainer(container);

                        IEnumerable<LootTuple> pickeditems = PickItems(tables.Value);
                        foreach (var i in pickeditems) {
                            // Consolidate duplicate items from tables so we're
                            // not having two slots filled with the same items.
                            if (rolledLoot.ContainsKey(i.item)) {
                                rolledLoot[i.item].amount += i.amount;
                            } else {
                                rolledLoot.Add(i.item, i);
                            }
                        }
                    }
                }
            }

            if (rolledLoot.Count <= 0)
                return;

            // Make sure there are enough available slots for fill with the
            // rolled loots.

            int containerSize = 0;
            foreach (KeyValuePair<string, LootTuple> loots in rolledLoot) {
                if (loots.Value.nostack)
                    containerSize += loots.Value.amount;
                else
                    containerSize += 1;
            }

            if (container.inventory.capacity < containerSize) {
                if (containerSize <= 36) {
                    container.inventory.capacity = containerSize;
                    container.inventorySlots = containerSize;
                } else {
                    Puts("[BestLoot] WARNING: Container " + containerName + " rolled more than 36 loot items, truncating.");
                    container.inventory.capacity = 36;
                    container.inventorySlots = 36;
                }
            }

            foreach (KeyValuePair<string, LootTuple> loots in rolledLoot) {
                if (loots.Value.nostack) {
                    for (int x = 0; x < loots.Value.amount; x++) {
                        var item = ItemManager.CreateByName(loots.Key, 1);

                        item.condition = loots.Value.condition;

                        if (item == null) {
                            Puts("[BestLoot] WARNING: No item for " + loots.Key + " found.");
                            break;
                        }

                        if (loots.Value.subitem != null && !loots.Value.subitem.Equals("")) {
                            item.contents.AddItem(ItemManager.FindItemDefinition(loots.Value.subitem), loots.Value.subamount);
                        }

                        item.MoveToContainer(container.inventory, -1, false);
                    }
                } else {
                    var item = ItemManager.CreateByName(loots.Key, loots.Value.amount);

                    item.condition = loots.Value.condition;

                    if (item == null) {
                        Puts("[BestLoot] WARNING:  No item for " + loots.Key + " found.");
                        continue;
                    }

                    if (loots.Value.subitem != null && !loots.Value.subitem.Equals("")) {
                        item.contents.AddItem(ItemManager.FindItemDefinition(loots.Value.subitem), loots.Value.subamount);
                    }

                    item.MoveToContainer(container.inventory, -1, false);
                }
            }
            container.inventory.MarkDirty();
        }

        void EmptyContainer(LootContainer container)
        {
            while (container.inventory.itemList.Count > 0) {
                var item = container.inventory.itemList[0];
                item.RemoveFromContainer();
                item.Remove(0);
            }
        }
    }
}

// --- End of file: BestLoot.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RemoteDoors.cs ---
// --- Original Local Path: RemoteDoors.cs ---

using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("RemoteDoors", "Reneb", "1.0.8", ResourceId = 1379)]
    class RemoteDoors : RustPlugin
    {
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// Configs
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        protected override void LoadDefaultConfig() { }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        static string permissionRemoteDoors = "remotedoors.use";
        static bool allowusers = true;
        static Dictionary<string, object> cost = defaultCost();
        static int maxDistance = 60;
        static int antiTrapDistance = 80;
        static int maxDoors = 20;

        void Init()
        {
            CheckCfg("Remote Activator - Cost", ref cost);
            CheckCfg("Remote Activator - Max Door Distance", ref maxDistance);
            CheckCfg("Remote Activator - Max Doors", ref maxDoors);
            CheckCfg("Remote Activator - Anti Trap Distance", ref antiTrapDistance);
            SaveConfig();
        }

        static Dictionary<string, object> defaultCost()
        {
            var defaultcost = new Dictionary<string, object>();
            defaultcost.Add("High Quality Metal", "200");
            defaultcost.Add("Battery - Small", "1");
            return defaultcost;
        }

        bool hasAccess(BasePlayer player)
        {
            if (player.net.connection.authLevel > 1) return true;
            return permission.UserHasPermission(player.userID.ToString(), permissionRemoteDoors);
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// Fields
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        static int constructionColl = LayerMask.GetMask("Construction");
        static int doorColl = LayerMask.GetMask("Construction Trigger", "Construction");
        static int signColl = LayerMask.GetMask("Deployed");
        static int playerColl = LayerMask.GetMask("Player (Server)");

        Vector3 VectorForward = new Vector3(0f, 0f, 0.10f);

        RaycastHit cachedHit;

        static FieldInfo serverinput;
        static FieldInfo buildingPriviledge;
        static FieldInfo fieldWhiteList;
        static MethodInfo updatelayer;

        static Hash<Vector3, RemoteActivator> remoteActivators = new Hash<Vector3, RemoteActivator>();


        void Loaded()
        {
            LoadData();
            serverinput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            buildingPriviledge = typeof(BasePlayer).GetField("buildingPrivilege", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            fieldWhiteList = typeof(CodeLock).GetField("whitelistPlayers", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            updatelayer = typeof(BuildingBlock).GetMethod("UpdateLayer", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            if (!permission.PermissionExists(permissionRemoteDoors)) permission.RegisterPermission(permissionRemoteDoors, this);
        }
        void OnServerInitialized()
        {
            InitializeTable();
            List<Vector3> toDelete = new List<Vector3>();

            foreach (Vector3 pos in remoteActivators.Keys)
            {
                bool todelete = true;
                foreach (Collider col in Physics.OverlapSphere(pos, 2f, signColl))
                {
                    Signage sign = col.GetComponentInParent<Signage>();
                    if (sign == null) continue;
                    if (pos == new Vector3(Mathf.Ceil(sign.transform.position.x), Mathf.Ceil(sign.transform.position.y), Mathf.Ceil(sign.transform.position.z)))
                        todelete = false;
                }
                if (todelete)
                    toDelete.Add(pos);
            }
            foreach (Vector3 del in toDelete)
            {
                storedData.RemoteActivators.Remove(remoteActivators[del]);
                remoteActivators.Remove(del);
                Debug.Log("removed a sign");
            }
        }
        //////////////////////////////////////////////////////////////////////////////////////
        // Item Management ///////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////
        readonly Dictionary<string, string> displaynameToShortname = new Dictionary<string, string>();
        private void InitializeTable()
        {
            displaynameToShortname.Clear();
            var ItemsDefinition = ItemManager.itemList;
            foreach (var itemdef in ItemsDefinition)
            {
                displaynameToShortname.Add(itemdef.displayName.english.ToLower(), itemdef.shortname);
            }
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// Data
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        static StoredData storedData;

        class StoredData
        {
            public HashSet<RemoteActivator> RemoteActivators = new HashSet<RemoteActivator>();

            public StoredData()
            {
            }
        }

        void LoadData()
        {
            remoteActivators.Clear();
            try
            {
                storedData = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("RemoteDoors");
            }
            catch
            {
                storedData = new StoredData();
            }
            foreach (var remote in storedData.RemoteActivators)
                remoteActivators[remote.Pos()] = remote;
        }
        void Unloaded()
        {
            SaveData();
        }
        void SaveData()
        {
            Interface.GetMod().DataFileSystem.WriteObject("RemoteDoors", storedData);
        }


        public class RemoteDoor
        {
            public string x;
            public string y;
            public string z;

            Door door;
            Vector3 pos = default(Vector3);

            public RemoteDoor()
            {
            }
            public RemoteDoor(Vector3 pos)
            {
                x = pos.x.ToString();
                y = pos.y.ToString();
                z = pos.z.ToString();
                this.pos = new Vector3(float.Parse(x), float.Parse(y), float.Parse(z));
            }
            public bool OpenDoor(bool openclose)
            {
                if (door == null)
                    door = FindDoor();
                if (door == null) return false;
                door.SetFlag(BaseEntity.Flags.Open, openclose);
                door.SendNetworkUpdateImmediate();
                return true;
            }
            public Vector3 Pos()
            {
                if (pos == default(Vector3))
                    pos = new Vector3(float.Parse(x), float.Parse(y), float.Parse(z));
                return pos;
            }
            Door FindDoor()
            {
                foreach (Collider col in Physics.OverlapSphere(Pos(), 2f, doorColl))
                {
                    if (col.GetComponentInParent<Door>() == null) continue;
                    if (Mathf.Ceil(col.transform.position.x) == pos.x && Mathf.Ceil(col.transform.position.y) == pos.y && Mathf.Ceil(col.transform.position.z) == pos.z)
                    {
                        door = col.GetComponentInParent<Door>();
                    }
                }
                return door;
            }
        }

        Dictionary<Vector3, float> allowAuth = new Dictionary<Vector3, float>();
        public class RemoteActivator
        {
            public string name;
            public string x;
            public string y;
            public string z;
            public string owner;
            public List<string> autorizedUsers;
            public List<RemoteDoor> listedDoors;

            Vector3 pos = default(Vector3);

            public RemoteActivator() { }

            public RemoteActivator(Vector3 pos, string name, string owner)
            {
                x = pos.x.ToString();
                y = pos.y.ToString();
                z = pos.z.ToString();

                this.name = name;
                this.owner = owner;

                autorizedUsers = new List<string>();
                autorizedUsers.Add(owner);

                listedDoors = new List<RemoteDoor>();
            }

            public Vector3 Pos()
            {
                if (pos == default(Vector3))
                    pos = new Vector3(Mathf.Ceil(float.Parse(x)), Mathf.Ceil(float.Parse(y)), Mathf.Ceil(float.Parse(z)));
                return pos;
            }
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// Remote Activator Spawning
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        string SignTexture()
        {
            return "iVBORw0KGgoAAAANSUhEUgAAAlgAAAEsCAYAAAAfPc2WAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAAsSAAALEgHS3X78AABKxElEQVR42u2dz28bSXr+H3Y3f0mUTdsaj5yxFtEG2okxMTZz8GWAILdFbnMOcshhc86/sN9T/oBcN8AiCILcAiSnHPawQYAcMggGyeyuM6vNehEpY9qWLUqixCbZTX4PzttbLFVVV5MtqSk9H8CwSDa7q6ubbz/11lvvWwMwAyGEEEIIKY3guhtACCGEEHLToMAihBBCCCkZCixCCCGEkJKhwCKEEEIIKRkKLEIIIYSQkqHAIoQQQggpGQosQgghhJCSocAihBBCCCkZCixCCCGEkJKhwCKEEEIIKRkKLEIIIYSQkqHAIoQQQggpGQosQgghhJCSocAihBBCCCkZCixCCCGEkJKhwCKEEEIIKRkKLEIIIYSQkqHAIoQQQggpGQosQgghhJCSocAihBBCCCkZCixCCCGEkJKhwCKEEEIIKRkKLEIIIYSQkqHAIoQQQggpGQosQgghhJCSocAihBBCCCkZCixCCCGEkJKhwCKEEEIIKRkKLEIIIYSQkqHAIoQQQggpGQosQgghhJCSocAihBBCCCkZCixCCCGEkJKhwCKEEEIIKZlo2R3U63V89tln2NjYwGQyQZqm6Pf7mE6n2Taz2Qyz2QxJkqBWq2XvAZh7LX8DwHQ6RRAECMMQ0+k024e6fRAESNMUABCGIcIwnNuHevwkSbLvq/+r29RqtQvv6/sBgCAIUKvV5s5R/Z7aBtt56uerH386naJWqyEIgqw/9P2o+w6CILfdeeeWd/5qv6vnL++p37P1gb5vW7vV81f7TL8H5Ngu1O3y+sL0vn48aZft+uddb9d2epvDMMz+l+vjc67ym9Gvr+l+1I/vc59EUYQkSeauv+089N+cqx1yjtJ+OX99G/166P1iO67+uXqvAcjOS9/edo/o/aa3U9+P3DtFrmWapqjVatn/tvNY9P5TX8t9rfer6TeR9/uR6+hzrvp2uj1S7wnT7123x6a2qH2mf08+Fxuhvue6B3zvE9c26m/V1OfqM0C1v6bju663j01Wzz+v3abjm35zURRZn8tpms49w9V+V+8BedaLLtDP13Ses9ksO7Z6/CAI0O12Ua/X0Ww2kSQJ/v3f/x1v375FkiQX7qNlqAGYLfLFKIrw7W9/G2tra5hMJpkB6HQ6uHv3Lo6Ojqw/ZJvIyXu4q9sFQYAkSbKLstDJWwy+rQ02A1r0mEJe/yxKkX51Pex8+qDo58uck22/ef1V5Jou2i7Zh29f+7ZPjIQYoUXO0fS57TdYdL9Ft1P7rEif54myIvfwZZzfojbN5/hhGM4NTn334XMv2uxREXxswiJ9cB22xPe4RZ4Fiz7nfPrLNrBbpN+K/I58nudFEAEVRdGFwaFPe23tMG1z7949HB8fYzAYIAxDRFGEjY0NAMCvfvUrjEYjnJ2dYTgcLnyNsuOhoMASYdVsNjEejzMVWK/XkSQJkiRBEARot9sXGpg3IgCK3RSi5k0Cy+YZ8OqUBQzWVbDo8X2+d93ndpltrcq5LUoRj6J+r/vey5fVR5f1kKxKG3z70fS+6lX18ZisKpfxe63Kb/oy23rd51jmc9DmQRXkOV7kPvf5XeufiS6ZTqeIoghRFGEymWA8HmM6neLhw4eo1+vo9XoYj8f45S9/mXnqF+pDFBBYjx49wu7uLg4ODtBqtbC2tjbXwFarhVqthslkAgAXvEt5UzlFEMVruwHUqUV9mqmKVLlt5HoxDSBUYSWvgfIexFdxP17GMcruh8tss8lbYHvIlGk7yc2hys8NfXpXnerLe26Xha4/ZCagXq9jNpshjmM0Go3MQTQcDlGr1fDkyRMcHR3hv//7v9FsNvH1118vJpLhKbA++eQTfPjhh/jmm29Qr9ezqcE4jrG+vj4nZkQdytSh6WTL6DQ95kqdE07T9NYapcsStZdJlQ3FdZ+Deg1lAKN6btUYrTKm+66DIrbBdk9X7fx8r4fEVsm5TafT7AGwSP+U1b5VYJXOYRXt8mX0gcRVmuIJRQCV1T96vJYIKdVjFgQBzs7O0Gq1UK/XcX5+jiRJsLu7i2azif/4j//A2toa/vM//7Pw79BLYD1+/BgfffQRRqNRZgwajUZmCGSqcDqdYjgcZuKm2WxmQW5ra2uI4xhpmmbf9Z2+U4WT/Jim0ykajQYajQbG4zFGo9Gc4ArDcM5w+WJqk36xJdAu7wcjn+uB6vpreU8P4DPhusDS9mazCQCI4/g3F9oQc2H6vmyrvlb3YTtvnxtP3dY2tetzPYpiOpbeFlsf+7ZT31b2qY7WfI2GOtJSH8Ky/0ajgVqtlrmuqzp9pN5PamDuZDKZC16XzwVToK8+DZemKVqtFu7du4d+v4/BYIB6vQ7gN9dUjqcHEVcRaV8URZjNZhiPx9n11sVzkVG+GqwchuHce4ve2/JaP47NFhQ5jqt/fK6dbkeL2iV9P64FL+prV5vVfbRaLQDAaDTKPSefZ0GePba91vdj6z/TNkWuh/4deS7L6zRN0Ww2s+e43PfSt7ZFLK7+DoIA4/EYYRii1Wplgmk2m2E0GmW/qXa7jSAIMJlM0Gg0soHreDzOYl8fPHiA9fV1/OxnPwPwPkaryL2cK7A2Njawu7uLfr+P+/fvZycu6k/1Wp2dneFb3/oW/vAP/xC7u7vY2trKOu3DDz9Eu93Opg/1DsxbAWO6oLPZ+9WB/X4fd+7cyW5eW+Cb+r25TjAcT242n4uq7kO/2KbXs9kMr1+/Zr8Y+sW22kR//9WrV+y/JfrP9r6+Asi2AslHsMv3ZIVvGIbo9/vo9/toNptoNpuIoiiL41QHSKZ+nU6nWZxnkiRI0xRhGGIymeD8/Dwb3IVhiM3NTXS73WyVkm1awnXupmvhOvdl+t91XfPuCROqsHLFv+Qt0pDP4zjGyckJut2ucVWY+iC0Hc/2u6zX6xgOh3j16hUajQY+/PBD9t8S/ffw4UP2i6FfGo0Ger0e9vb28M///M/4n//5H6yvr895s9SQIgA4OTnBb//2b2M8HuPdu3fo9/vY39/3X0QDh8AKggCffPIJjo+P8ejRI0wmk6zREn0/Go0wGo3wu7/7u/jTP/1TPHv2DBsbG9koUxouqhHAhalDZwNrtbmLqv4TxSmrCV2pCoriq5qXPQb7hf13nVzG1JN6rpJqJQxD1Ot1vH37Fm/fvkW73Uar1coElrjngyBAFF3MHpMkSRbrKQJrNBplwno2m2E4HGI0GiEIAmxtbeHBgwdZ6hixRZc5nVSlaR8ZPJSB/FbUVV4yhan+kz7wPa5M2QDIPLRVme5j/928fhFbNJvNcHp6ii+++AJ//dd/jf/6r//KBnwycJNBe71ex5s3b/DJJ5/g1atXeP36NYIgwK9+9Su/c4RDYK2traHT6eCjjz7CbDbL3Gjioh4MBrh79y7++I//GH/yJ3+CVquFs7OzrGEiriQeS1yPeq4N6Wy1g0yxW2ouIJlqiKIIYRhmhtWlzk2jT5MqNo2ifS9s3nfUY7Bf7O1RMU0xsP+W7z+1D8pGdfNHUZQZt6OjI/T7fbRaLbRarSzAtNFoZEKs0Whk11PaKN4pEUwysAN+M90i6QySJEG328W9e/cyYSVTBFdxzr797+s5WHQ6Rv3fdl/meStlu+l0imaziTRNkSQJ6vX6nBfYFDvj8vCqK1/l9yvxMey/cvqP/XKxX2RKsF6vY319HXEc42//9m/xd3/3dzg+Pkan08lCNCT8KQgCDIdDbG1tZR74yWSCg4OD3P5yCqx2u43t7W3cuXMna1wcx+h0Onj9+jV+7/d+D3/+53+OZ8+e4fz8HKPRCI1GA6PRKFtRKLEShBACAD//+c+xtraGtbW1zHUvYks8hvK/GMvxeJx5sORv8WDJe2oQ68cff3zdp0kIqQhxHGfeqziOszRTzWYTa2tr+OKLL/CXf/mX+OlPf4qHDx9iMBig1WplIk2NgRWv209/+tNcr1oI4P+ZPgiCAOvr67h//342wk+SJJsW/Oijj/AXf/EXePLkCc7Pz7OgMABoNpvZCFQdiRJCyC9/+cu5VXJqZnM1IF4NyhZRlSQJxuMx4jjO/o1GIwyHQ5ycnGA4HCIIggtxPISQ24tqV8T2iOAaj8f41re+hd///d/Hv/3bv6Hf76Ner2fxnOJcGo1GcwtpNjY28O7dO+dxrconDEM8ePAgE00ioGSV2g9+8APs7Ozg5ORkLnpfpgOqFGdCCKkOqpgyfab+r39Hfa2vPBQjeH5+ft2nSAipICadMpvNcHJygp2dHfzgBz+Yy36gTomK6AKQedvzMAqsMAxx586dLMJebdzp6Sm+//3v47vf/S76/X52EDWgVZ1DJYQQFZddsH1msiem2DY1xQUhhAjqqnE1BAFAtsL5u9/9Lr7//e/j9PTUOMiT+NzZbIa1tbXcYxoFVhAE2NzczNxhsvOzszM8e/YMn3/+OUajUZZqXvdamZZjEkKIDVe6C9s2Ji+YreA7IeT2Yku7It4s+TcajfD555/j2bNnODs7u2BLZLWjvk8bRoElq3j0/BOz2Qzf+9730G63MR6Ps/dUo6YvfSeEkDzU0aVr6tD2Wn2PdocQoqPaFj0Br9ie8XiMdruN733vexdWQ6qpp3wxCqxms4lWqzVXwy9JEmxvb+Ozzz7LIullWbWg563Q4yQIIcQlgIqEFai5chiWQAixoesR3VaIlhFt89lnn2F7extJkswlIJWM897HNb0piULVBF2j0Qgff/wxHj58iDiOs6B3VYSp/0yZVQkhxGQTFvV4m7I8X2byVELI6mHyRqm2Q6YKJY3Dw4cP8fHHH2d5ENUM70U0jVFgra+vZ41So+i/853vZAeRpY42Y0Z3PSGkKEUHZa4SHYQQAuTrEanyILomCAJ85zvfmdM/eqkzH1sTmd5sNptz4knyQezs7GRlROSgrkzZRWocEUJuD66FMLa6c+pnJhG2SGZqQsjNx1VTVd5XvVuTyQQ7OztzxalFhEnqKnURoA1nHiyZf5ScEFKfRw7kKiHiClglhBBBFUu2v/UYK7Er6mIcqR/JsARCiIo6HQiYPd9qqbXJZIJ2u53l/pQ4dIk5V3NiuTAKLBFWegPUgomCrgL19wghRMc0MCs63aeKLrVI98bGxnWfHiGkgphqI+phCZIjy6RjRGjJvzyMU4Q2F72peK1NEZq+RwghtilBm92xTSeK/VFXNdfrda5cJoTMYdIhJqGlv29bkDOdThfPg2XLmGw7mD4d6IqTIITcblyDMR1XXix91Nlut1Gr1XB8fHzdp0gIqRgmQaWvQDZtb9JDURQtXipHdqILpjzhpMdPMAaLEJKHvnRa/0zdRrUx4sYPwxCNRgMAMBwOr/t0CCEVQ4/BAvJ1jEn/+HxfxSiw1ALPeUkBbdtQXBFCTLhWDbrisNTpQPXzZrMJAIjjGAA4RUgIuUCeN9wlmFRxpRaBzsM6RaiPGG3BYTavlsv1Rgi5vdhSLPgYLX214J07d5CmKc7Pz537J4TcXmx6RNU0rsV6i1aLMAos08FMjbK91htHCCE2XOEEtuXU9XodURRhPB5jPB6zTA4hxIktaN1Hz5icSj7kCizbQdSG+BRnJYQQwG+1oG1byXslZbok5qqI254QcjtxaRVb7JW+bRGR5Zwi1Evl+ASF6Y2l0SOEmPC1DXoBeVkmPR6Ps5w16rJpDu4IISq6HnGFN6nf0fWProvyiGwf6ErNR7mZGk8IISZ8wxAkubGIqNlshjRNs4B3FncmhPjgG0dl0j/q/7440zSofxfJtExxRQhZBJMhc40cbRUnCCHEhK9uMdmcorYlN9GoqSCiaTuby41iixBiwmQ/8tz1ptAF2hhCiAtTKhh9pm0R3ZOHNchdP4hpx7Ylj+rfHE0SQlRMq3aK2Ak9/94yI0xCyM3HpEeK6BlTmiofnB4sWxBYnpDyCYwnhNxO8lbpmNC9V/RaEUJ80b3e6vu29/TXi5QANAqsNE0vVKo3BbmbahD6ROcTQm4vtpFj3oDMFQ+Rl7uPEHK70acGTTUJBV3zqFooTVPvYxpXEboytZtqgsm2ptgrGjtCiIotlUuercgLTuWAjhBiQtUn6kAtr5C8absimiZyfWibgzRts2gDCCG3i0ViGXwC4PX9E0KIji1o3RSDZRJbRXBWRS1iAPOSkBJCiIpP5nbXZ8y3RwjxoQx9soitsQa5T6fTLEuyunN5T5L/mSrXM00DIcSGHscZBEFW+qaIJ2oRTxgh5PbhyoYAYE7PyN/q99Rkx0sHucsOR6MR4jjO3gvD0FqPUIdpGgghJmQAN5vNMpuivifYXPb6ezoUXIQQlTw9YqpDKCILAOI4xmg0MjqUXORmcm82mwCAyWQCAFlZCn2FoQpd94QQG2I3VA+4iKsyXPkc1BFCTLj0imp/ROeI7hEdVEomd9mRWqH+wYMHiKIIaZrOjTZdeWkotAghOuq0oLxWRZfNiLkGcrQzhBAbNi2iCitV16RpiiiK8ODBAwAX9ZAvRoGlGzlpxLt377JK9noj1f9VOJokhKiIkJKYBrEnEv9gw+ThMrn+KbYIISquUALdXkhR+Xfv3hmr2ahTh3kYrZlu5IIgwOnpaTbi1Bttqg9GYUUIMdFqtRCGIcbjcSauZOAmSY51fAZxzIdFCHFh0im2+KwoinB6emrUQ77kblmv15EkCWq1GhqNBgA4pwM5LUgIcVGr1TAej5EkSfaeKpJspSzyhBeFFSEkjzytIu81Gg3UajUkSYJ6vb7QsawCq1arodlsYjQazUXU5yUU1Q0lxRYhRGU0GmEymVxwtZviOV2rlnVbQ4FFCDGh65G81cdqWqparYbRaIRms1lYz1inCNfW1nB2doYwDBFFEeI4zmKzfIslUlwRQnQkx56tlqANk/hi7BUhxAfXIE1/T2Kt4jhGFEUIwxBnZ2dYW1tbfopwbW0Nw+Ewc4ulaZoFpOoNtS175IiSEGJC0jOoRVN97YWtUDRDEwghLmwZD/Riz/K5DATFTtXrdQyHQ6ytrc1t58IosN6+fXthtaDNpaYHibEmISHEhawc1MMOihZ7tq0oJIQQHZv325VqSrUpsrrw7du3Fz6zYRRYEtTuK5b0ZYx5c52EkNuLblvKsBG0M4QQG654TV9tI3ZLXZyTh1FgtdvtuUYte1KEECKYDFwRb7fNk0V7QwixUZaeEX3kQ2R601TQ0JVdWfdYMbsyIcSGyYOVF4PlWj2oL7mm3SGEqJimB02aRcekg/RE6y6MHiwRWKZgMP1gvkaREEKAix6nPA+WywC6VgYRQoiQp1VsC2jU16UILFsV+zzDRcNGCPFF92LliSj9tY/nixBCTPjoGZPuKeIhtwos0wpB0zb6CJKrCAkheegepzwPlssWAawkQQhxY9ImuhfdFd9pS0vlwpnJ3ZZjxjZq1CtTqw0khBDBx1vls9JHHwzSo0UI0THVH7SlZbAtwFlk8GYVWD7Vp21Z3fXEXYQQoqIbMdOATLc3eXlqCCHEhu6BMmVvB8q1N0aBJVnbdaPnyoJqOxlCCNHRRZWvraBNIYQsgs3p46pGA8zrHzVBsg/OojqmSvW2kSeXSBNCiuATdpD3fZPdoQ0ihLgwzcaZwhNcaacWLpWjf1kXUabcEGrEPXNhEUJ8sQklm50xvcc0DYQQG7qzSNcrKi69Y3I6uYhyt8BiIolV7gkhPugGT8izGwxDIIT4sMygyySmfG1P4LtT1xJHfXtWuCeE5OFaSOOzret9QggRTF5y27SgLdxgkQFdbgxWXiFEW2MprAghLvSBWF4clqkkjsnm0PYQQkyYSubI375aR/AZ3BkFVpqmznTwvjmumJOGEJJHETthirfS08LQ5hBCVHxsjI/9mE6nSNPU+7hGgRVFkTMHhCnQy2TgOEVICNGxhRjkjSBteWs4kCOEuDDlv7IVfLYt5pPPosgrdB1ATpD7Isum9WBVCixCiIrJNixiawghxBfdGeRrQ/JSVLkwerAmk8mFKULbMmiX2nO9Twi53dgW0fjEYal/L5KfhhBye8jTJzb7o39vOp1iMpl46xprsecwDI1BpHm1wlR1SENHCDHhGkEWed+Vx4YQQgQ1VjMv755N+4gu8sW5itBUW9C0tFEvtmpbWUgIIT61Sl1JRovEbhFCiCle3JV/T/0sb5bORW4md32ntpo9Ju8WCz4TQmzkBbXnfWbK4k4IITo2IWWLx7KlZCglD5bJDVZUMFFcEUJM5MVY5X2XC2gIIUUpGthu0jAyTeiL1YOl5nqYzWbWuUfTUmkKK0KIDVcslc12mALa87zrhBCi46tZREypn4ku8rU1xjQNtVoNaZpmSm02m2E6nTqTj+rfZ/wVIcREkRI5ru/qoouLawghJnQb4eMEEs0TBEH2/TRNC83OWfNgicgCgCAIjKPFvNEkRRYhxBeXh1z/W16bMrsTQoiOa9pP/rfFXhX1XAm5tQjlIPq8Y5HSFoQQomOqAqGzyAoeDuoIISqL6hV1inARuxLkbvB/3qu8kaQNGjtCiIqtqr1voWcmFiWEFMFlI1x6RrRPEORKJSPGb+kHCILAO3vpInOdhJDbgy2cwLV93jTgMmV3CCE3m0VK+M1mM0wmkwshUkXsi1VgqQ0IggDr6+vZNGFeNnf1b44uCSE6usGyeacAv9QNhBBiw6RH8nRMGIZYX1+f814VdRpZS+WoKwaDIMDDhw/RbDYvLG3UV/Ew4JQQ4sJUhgIwl71RtzF9bvouB3WEEB3T1B9wsbKEfNZsNvHw4cM5gTWdTpcvlSPTgrJMcTgc4u3bt4iiyOqxcr1HCCE2TGUpTNvkvb9MSQtCyO0hT7vMZjNEUYS3b99iOBzOpWxY2oOleq9qtRoajQZOT09xcnKCKIoQhuGFoC/duNHIEUJ88Kn35QpuZ9A7IcQHXZ/otiIIAoRhiCiKcHJygtPTUzQajbntfPOBAo48WKpSkzQNks09DMPsIK5sysyFRQjRyZsKNG2vfm6LozBtTwghpiB33Q7VajUEQZAlFhXNo3rXi64mdG6tz1lOp1OkaYo0TbNpRP2AujKkuCKE6JgCTG3CSzeGedsTQoiKKTWMimiZ2WyWaZzpdOqMKffRNkYPli6S9B3rU4i2gzHolBCiU2RKz5WjxvY92htCiIrL8aPOsom2UR1HNj3kM7iz1iI0vRaVJ8rOlj6eo0pCiA1byZu8OCvb5z6iixBCbCuRRVhJrUF1dm4ZG2MUWGr8lWrgVENoarj6/aINIYTcHlzpFmzbm9LAmFLFEEKIip4A3TQLJ3+btI76XpE4LKsHy2SoXAc1wQB3QoiOnncGyBdGNu+VLqxcqR5uIoPBAP1+H6enp0iSBP1+f+7zVquFVquFTqeDdruNbreLVqtV2vH7/T7iOEaSJJhMJhgMBnOf5dHtdgEA9+7dy9q5TPv+5V/+pdT+tbX56dOnpbRhd3cXW1tbl3Kuee28beTpFPWfTdcU1TSR60PbvKXJMOorBnXFSAghKkXsgsngmWIhboO9ieMYL1++xOHhIeI4zt02juM5sdPtdvHBBx8s/GBX+eqrr5b6vrRLbV+n08GjR49KaV/V2d/fvxXned2odkFdUWjyVplix12zdy6sHiyJtVIPaFriaFr6mLeMmhBye1mksr3umdKN5G2oRZgkCV68eIFer7fUfvr9Pvr9Pvb397G9vV25B/xgMMDe3h729/exs7ODzc3N627SpRHHMQ4ODvD48ePrbsqNxhQnbkoppW5rGsAVTTRq9WDphisvuZZpdHmT8mD1+30MBoPMFS8jQxVxx0dRhI2NDbRaLXS7XUSR3VHo407e2dm59h/gdU9F5CGj9NPT0+za6Nen0+kgiiJ0Oh3U63V0u110Op1Cx6nCFMRNpGhViKJTjKtOr9fDixcvkCRJafuM4xh7e3t48+YNnjx54rRT10Ecx3j+/Dm2trawu7t73c25NMSLVbX+v0noziB5z+d7phWFvljTNLjiHdTX+ihTXovSW2Vx1ev1cHR0hMPDQ6/t1Ye6+p1Op5O55FfpR1SlqQgbvV4PL1++nIv9sCHbqG0UEfzo0aPCYouUT5GUDbb3V9nmmNjb21vaa+Wi3+/jiy++wNOnTyv5G5Bzv6kiK0mSzFtHLgc1E4I4i0z6xaRx9P2U5sFy5cOyTRuaTmqVRpdJkqDX62F/f7+00eJgMMBgMLh2L1SRPqj6VMTh4SFevHiRK/zyiOMYvV4PvV4Pn376aSUfMLeFonZCNYA3TVQJly2uhCRJ8NVXX1VaZLXb7ZWxoUU5ODjAo0ePrtTrf5uwZT4whTvZ9M4iiY2txZ7VKcK8uUmTuFolUSUcHh7iiy++KN0VD/xmtUzV6fV6+OKLL0o16jIV8dVXX5XSr3t7e3j+/PnS4kpFpjfJ1eO7KtmWb++m5uG7KnEliMjy8QZfB2UMqKrMixcvrrsJNx5bKJP6mUnv5K0utGENctdzReiNke2K1BSrKkmS4Pnz517Lihfl3r17132auazCVMRltXFVBPBNIC8WwmY7XNutejiCzsHBQeH7XKa72+02AGA4HGZpFHxJkgR7e3t4+vRpaeEMMgWv7y+OY5yenhY6zxcvXuDJkydLtUfiRRflsgZih4eH6Pf7tEWXiK9mMdkoicey6SMTzl+QOrJUVxS6Vg7aXGxVRVasXPaoreo/mlWYiihj2tLGxsbGpZ87eY9LDLnEVV45rlWwNz4MBoNC3oxut4vt7W2rjZFpet8B5GAwKDUm6N69e9aVgFtbW9je3sbe3p5X+yQedBmB9OjRo8pONe7v71f+WbGKmPLk2VJJqbZERJW+jV6n0IZxijBNU2c29rxYK/XgVTZ6g8HgSlzisnKtqqzCVES/38fBwcGltekmLwWvOq4UCy5Pl82lv+rs7e15b7uzs4OnT586H8qyKrWIYDo4OLiy6bhWq4UnT55420jfRUerSL/fv1JbfFtQbYWefsonxEANkk/T1FvXePuATQrPJKJWxcjJQ36ZmCBZ9q/u0yQaqjwiWZWpiCIPHeCiqLVdG+DidVyWqk5BVA1bwmITvnZl1TO593o974FH0Szg4rXx9Y7t7+9f2cq9KIqwu7uLL7/8Mnfb09PTK2nTdcHko5ePrmFMseb634tgTdNgOrhpyaK65FFvfJUN3SLiStIt5OVPklWDkuKhqtNPqzIVUUS8bW1tOVMuqPmyDg8PkSQJPvjgg1L7tcpTEFXAVhnCVojV9j1TcHyVPeY+7O/ve223ubm50EP48ePH2b2fR6/Xw/b29pWtbOt0Ouh0OrkCc9UD3Tc3N539z+Sjl4dttaCpxqA+VbiIjbEGucv/pmXQ6kH1RujfqyIHBweFpqc6nQ52dna8PVFiKLa2tkpfjVgmRaci8n7w3W4X3W4XBwcH3sLNZ3ny0dGR1758RvStVgtbW1vY2trCzs4ODg8Pb43HqKqoNcB8sOXeK7qfquGTbw74jbdnUXZ2dtDv971s0+Hh4ZU+6D/44INc21zVVY6+bGxsYDAYOK81k49eDibPlfo+YJ6RW9Sr5UzToL9nOoAutvTvVM3YxXHsPUoE3ntEPv3004Wn+aIoquSPpOhURBEj+/jx40LxHnnXw6ed3W638Ig+iiJsbW1RYF0xrliqIolGTTXEVtmL5TuQWPbBK4MMH16+fHnd3XIjefTokfNzycdIysGWpzMvzMlmc3xxCizbSFF9zzVirJq4AlAogejOzs6NzR58FVMRvoHjvV7POZrzEVirkAaDmMmrI+gyaDdp9aBv8Hbew7nMfZhKTpHl8bGpNz3v11Xj0ikmHaMP+BYZwAXWD/4v34O647z8NMuqvctGsnb7sLm5eWPnwK9yKsJ3pO16uPgI4slkcgk9RS4TPb4hb0CWl6bBtV3V8Z2y63Q6pcREFUmse5n5AXWGw6FXH6w64j3Po8hsC7HjmpVz5cXSpxP1OK08vLY21R00baM3vGr4jhCXFRZV5yZORUjAOlkdfEWRK25C/Vyoqv1x4TtdX+aKZN99+YiesvCx0VUMuViE7e3t3G16vd6VCtzbgG/WAzWD+6I4g9xNSUVt29tyR1TJ2Pk+xIt4XlaRq56K8MlfJVMRptF5t9vNNTJxHGcJTG/ytbvtuOImVtFzJfimHihzRbLvvq4qqLzX63kNkpYNB3j58qX3IFNHFjyVQavVyl1RCDD5aFm46hG6tvfVQSaMTyJ5QKnLGU15r6o2BejCN5YgiqIbnXTyuqYifIx0v983erw6nY7XKG4wGODLL78svbA0uXx8bIkpTYxqBH1KV1QVX+9rmYMH331dhWe4SMqYZacIqxRX9ujRo1yB1e/3WULnEvFJYKwKsSK/QesUYV4dQkENELPlt6kCvm7Wzc3NG+0BWcWpiCJ5qqSwtBSs5rRhdSkyIrSVtTAtxllFT1aVf5eX7cHq9/veeQklyfFNQVLb5GGKxbpJ/XAVmEIMXAv1TDNwRQdxViUhSUT1OAc9Hkt3n+knUhWR5fuglezkN5VVnIrodDpe04QqIrRevHiBzc1NZ/LRsqnKFETV0QdiiyyiMQ3qigaiVoGbPBAwDZwk4e+bN28K/a7LCFu4bvT+2N7ezu0DerGWxzYTp3uoVI2jD+aK2harwDLtPC+XhCvr8nXj+8C7CStUXKzqVMTOzo5XGQ3TPnu9Hnq9HjqdDh49enTp04dVmoJYdWzF5W3byd+kOsjvb1l8V95VHd02iBcrT2QxFmtxTI4iwL6C2aR3FnEYOdM0+OTBUv+Xhq0yN/0GXtWpiE6ns/TKzsFgMDd9SK4Hk+cqL9DUtJL5suqHkWry5MmTGxu+4bOiULxYZHnysrXLNst6sIxbp2nqnVHZ5XKrktha9fIKZbHKUxFbW1ulpM+Q6cNli32TcljEVojgmk6nWSiD5O6r1+vXfUo3iiqImt3d3Rs9+PWNxWJm/cUxVX5Q31e3s1Gr1ZCmafZ3HkaBNZ1OjTkg8hSeHuhepZEkH6Q3g62trdJGsv1+H1988QXF9xVjcsvbvOD636qwStMUURTNCapWq7WSAss3NKHMe9XXG3KdYROSk/AmTA3m4ePFUpNEV0H4rhIufeKaoVO3L7pa2XiFTG4wm6ozxUaYXPmElMXm5ia63S5evHix9FRfkiRZ/qybHn9XZUyJRE1/q+IsCAKkaYo0TREEAVqtFqbT6UrGv11HyoTriMcsQrfbxe7ubinpYlR8Ctdf1/lubW3l2rT9/X3s7u5iY2PDO6fhbceWikG3KXnfA35T5WZhD5YqsEzue5+EXVXzYJHqU8SQy8j26dOnS08dJEmC58+f08t5hbhGjLYgdlM6Bnk/DEMA71dorWLZpOvwYPkK0TJXFPuwubmJp0+f4unTp6WLq6rj68WirSqOj9dK3lfRbY9aRjAP4xMtSRJEUXRhmtCnVI5p5WEVKJLs8ibP9fv2w2AwKM2jc5lTERK7EMcxXr58uXDuqziO8eLFixtdIqlqFMmgrOesmU6nSJIE9XodYRhiNBrh/Pw8s12rhm96mDdv3pTmfXnz5o3Xdpft2e10Ouh0OtjY2LjxeQjzkPJiLi+WrIwm/phSMajvmzB5uWazWWZ3fOJGrVOEpoaYGq02ZJFU8leF7492FacXLqMfVm0qotVqYWdnBzs7Ozg8PMTLly8Lr7jp9XrY3t5eetRc1SmIquBrH2zxEmIowzBEEASYTCaYTCaYTqcXVj+vCkVW2pYhIuM49vaGLSuwdnZ2jPu4yQPZZRAb5rKbL1++5GBwCWxJR3VM6R2K2BjjFKEplsqk/nwaXxVj5/vQ9E3EuarchqkImWJ49uxZYSPOmIbLxzQ16BpR6ukcRFhFUYQ0TefE1arSarW8bVQZ3gvf+7wsj5J4mtV/xEwURblThUUEMimWJ89kixbNs2e0SHk7yovJqmKaBt+H901/wBaZiiiL65qKaLVaePr0aaGR3k0X2FVET/XisifymXjZZarwJuCbpXx/f3+pc06SxFh6xcSyhZXJYmxtbeUKW6ZsKIYtmN0Uc2X7vml7F84hn63+l63hVcb34X3T57eLTkUsy1VORdjY2tryLj9z06eIVwWXPRFxNZlMsgD3KoYlFMW3yHwRgWRib2/P67d90wvfVxlfLxZZjjztYktm7It1FaEpY7LJdZ8nvqpi+DqdjrcLftkRYpW56VMRNh4/fuy1f7rdr4e8UaW+2CZJksKFV6uOBDj7cHBwsNDvs9fref8mt7e3b3XA+XXz+PHjW7eK8rLI0yi++qZoNnfvKcI8D5YtSKxKni3f0ZisKLup3NapCOa5qgZFBl0mG5SmaWbobPmzVhWfZfrC3t5eIZHV6/Wwt7fnte1Nqfu36hS5H4gdWzqGvDhxUwLkUqcITS4yUw0xW3bmKhm9IpXYyypQWkU4FWGHI8bLR1917HpftS9SYUJe+9QyXDVarVahFahS8sm1YjaOYzx//txbXAHvV7LRe3X9bG1tcUFACdhyYNm0jLwnr/Oq2thw/oL00hSuTO2uaPuqGD+fHCMqIhBu2pL7Iv1wcHCAdrtdeDRb9lREHMdLiZ84jr3SNlBgXR22aUCXJ9wVM1Elb/kybG9vo9/ve09XSxHgVquFbrebLWQZDocYDAaFp703NzdvtPfq5cuXODo6WmofnU7HO65zWeR+IItjG8wB9vAEsTUyJeiTcF3H+VSzBbnbRqCrwPb2diHP1IsXL3B0dITt7e0bNZIo0g8y8vU1upcxFfH8+XMA772QReO1JFO7D1w1dXXYMrbrr1XvlU1gVW0wtwxSpaBoMfI4jpf2unc6nRufXymO45UKEJe0FhRZl4vNg27yYPlqH+NTSpJpqUWfbR4rG1XKgaUiCSmLxFjJCLHT6eCDDz5At9t1xvPIyrnT01McHh5iZ2enMlNgaj88fvwYBwcHXtvv7e3hzZs3TqEpsWtFUl34TEUkSZKNwvf29rC3t4fNzU1sbGw4r0WSJDg8PMT+/r63Qa3adbqJ2Ko+uOIk9OTHNm9XlapHLEOn08HTp08Li6wyjsmpweqxs7ODL7/88rqbsfL4ahfbd0QX+WL8JU2n02wnPg3SRZgr6L0KPH78GEdHR4VHBLq7vdPpzBkjVQioLDtaevHixdJB93/wB39w4b1VmYowXafDw8M5IaevjlxklNrtdkuZIly1KYjrQo9/cNkM27RhXoHoVeYqRRbFVbXpdDqFwlvIPDbvk15Cx4Sqb0Qb+a4ktHqw1B1LDJZpO1fAapUN3ZMnT/DVV18ttSzf97tHR0eVjONalakIn+SfZbj9yxI0qzYFcdXYFs3oXiyXDdG301/fFDqdDp49e4bnz59f2hTR48ePb7yYvwkUDW8hFykSiyWf6zFYS68idKk9V2NMJS+qauyiKMLTp0+vZOl+lXMrXcfItegxryL2YHd3l2kcrhGTQHItkda9XjfRgyWIrdrd3S11EUa328Wnn35KcbUiSHgLKY6e5SCv9qD+t2/KKh2jwEqSZM575ROMampk1Q2dGK7LjrtJkqTSHo2rFFlFj2Wbdi2Tra2tG71qqmqYUrsEQZDFWfkUlle/r1PVQd2ybG1t4dmzZ0sNBmRRyaeffnplA0xSHj4ldIgZH11isyeqFioy22O9Uq78V6bG+GxfRaIowpMnT3BwcHCpGdwHg0GlUwBUdSrisr1Xu7u7FFfXgGoroihCo9EovDBmkVU9NwEZEEjqETUGUrdf3W4XURRhY2MDnU7nRq2Evo1ICZ2bnAj7srClkMrLy7eMd9wosMIwXCimQS/KWtWVhCYeP36Mra2tbBVc2UKryh4sQTx6vV6v0Mq7PLrdLnZ2dpYadZd9PbrdbulTLsSfWq2GMAwRRRFmsxnG4zHq9TrCMJzbLi/5qMtA3nSKlNa5LEyLZ257ey67DY8fP65kTG/VWTQ/py7MdBvlwhrk7jJspu30bfWGrQIS9L2zs4Ner7fQSkPTPjc3N1fKFS8j5F6vh5cvXy40RSfn/ejRo6XOfXNzE5ubm3PXY1GxJW2SVBvkepDpwCAIEIYhptMpkiS5MPWhx0zI/6bRp5pahhBCVEyrBU2VZ/TvqNuavpPHQpO5poymJiG2SuJqrlOiKBslSAyQ5LWS1/pDPoqiTEh0Oh3U6/WVd8lXaSpCjZOS1BKTySRriy4C5XpweqSaSLzVZDJBEATecSW2bMpVXlBDCLl+TIM0k2Aq047kWjV1qs/VmFWKuyrUQVGUZdK9DKrg0s6jClMRKpd5PfJYhetVdaIoQq1WQ5IkxlWBwm2NsSKEXD6uKUPV46UXlS+CV7as6XQ6J7R8gt7lNQ0jIURF8uqlaXrB220LOfBJNJqXrJQQcjsxaRFXUHteDlBfcgWWxErYhJUpmJ3CihBiYzweYzabzU0LmmyGKRGpycOlTxPS9hBCTNiSGdty7kmiUd/M7TrOb0nOh1qthjRNrdH3JsFFCCEm0jSdGxXm2Yxl0jcQQohKXuFmdcAmXnbJDVoUZwyWHGg6nRqXJroM302NySKELIeMBnXXe57IAuzG0LUNIYTk2QeT/ZFVzosO2rz8XqLk0jQ1fubTeEIIEUwhBUWr3Kvf4dQgIcQXH90immcZu+IUWKpBC8MQw+Ewd4lj3mtCyO3GZjeKhhfkufoJIQTI1yUmXTMcDudm7hbRMoUit4bDoTX5n95IaSiNHiFEx2YXinqxfD8jhNxebMHtgF3HDIfDpY/rLbDCMMymCPMKrC5aeZoQcvMxearyBmO2Zdb6+7Q3hBAdm6fbpWXSNC1UFseEt8BSa7bZlk+bljwSQojKIrUDbbVNVXuz6hUkCCGXj57TU7dHqv1YtlatdwxWFEVot9sYj8feBmyVij0TQq4WfQVgEWFkqyrBsARCiE6RGoK1Wg3j8RjtdnsuV98iAzfvWoS1Wg2NRgOz2Wwus7sstdbVICGE+OBayeNaUs38e4QQX/QVx7r3SuqjTqdTzGYzNBqNpW2K9xRhrVZDGIZzFev1UhV62QpCCNGxeZ5MdsNVzFmtkSrbmPZPCCHAvDbRq9OI/ZhOpwiCAGEYXq7AUg2a6rWS3BB64BhzYRFCFmGRJIDyvmn1MiGEmDA5hdTXkr1dr0N4acWeAcwVZxWxZRJZ6t8cSRJCdHxX/rmytqv7yduOEEJcAzFVz4i+0Ut6mfaXh7cHazweYzgcol6vzx1Uyl6YAlY5kiSE5OESSj55sdTVgxRXhBATpjAE+Vst5jydTlGv1zEcDjEej+e+r+8vD+8g9zRNMRqN5lxnNlcbIYS4KLKiB7DnyWJiY0LIoqjB7voCvtFoZCwPWARvDxbwXmSpkfa2uAk1aJUQQkwUyebu8k4x0SghJA99UYygOopE1wRBcEFclR6DZYp5iKLowkpC0/amGC1CCAHMpSoEPa6ziICiB4sQomPSI6b4cVlBGEVRKbGdhWoR6tH1LiXIvFiEEBtFijSbsi2rnzH2ihDiQq82I+/p2+jZEpalkMDSG2ULGDNtSwghNlxpGFyoAfK0N4QQGy6PlK5lyrIl3gJLMp3K0kUpgqhXoLY1mBBCAHvOK5fNcHnDaWcIIXmYRJQephCGYZaSKgiCpYVWoUzuEnslYkttmGu6kBBCBNMimCIB74KeDoa2hhBiwleniKiSWKwrK5UjSHB7GIa5LjfTCRFCSF6wqfqZy4ZwIQ0hJA/TIMwU0iQzc64Eo0XwzoMlDRLXGYC51YSu7xBCiGAybCYhpRtFky1hklFCSB55tkE8VgCyUKgy7EkhD5Zep0capnurbCt+CCFEyFsGbRNNpjQOeuF5QghRsekTteagXm95WQoLLLUOoWvptH5ShBAC2GOw8myFyd6YxBRtDiFExWUzVLui1iMsw47kThGqrvvJZJIFuKvqjyNGQkgR9OB033xWNo8WbRAhxBdXVQjRN5PJZG77RQSXU2DpjYjjeM6YMZkoIaQotpiqvHxW+vcYikAIKYJPYXmxL3EcW7fxpVAerDiO0Ww2Lxg6k8HkiJIQ4oPqmvf1RqniylZjjBBCVEwaxfR/s9lEHMe5aWLyyBVYao0eU2oG07YUV4QQG66cV67YTpW84HdCCDHhk0JKUjaYai6r2+RRKMg9ii7OKPq49AkhJA+XR1yFAzlCSFFc9sSkYUx6J29fF/ZhelPN2K5iynmVlyGVEEJUFhFGJq8W08IQQnwp6gjS9Y58v0gJHaMHq9Vq5TbEFOxu2p6jTEKIL7bUDS47UiR2ixBy+3Dl1LNlRLDZE5s+MmEUWOPx2Lix6jLLCyqlsSOEmHCtFjQVjLdtq3vP86YWCSG3G5dt0O2MbYrQpo9MFBJY6+vrxsbaCq7SZU8I0dE9TnneJ1VouUahnCokhNgwJRtVbYpuW3S9IywtsGz1Bbvd7oVG6Q2ncSOE5OGbtT1vG3qrCCFFsWkW1VkkekenSCFoo8BqNBpZVWk56HQ6RavVMga1mxIAUmgRQkzYyuT4lrPQ92GqLUYIITqmuE6Ts6hWq6HVas3VWgaAMAzRaDS8j2cUWEmSZJWl1YOK6HKJLPnbJ9cEIeT24VoQYxNHpkLQek1D2hxCiAmfQHZdeIneUe1JEARIksT7uEaBlabpherSahyEqeG29POEEKKSl2jUtr2vPaHdIYTo2Epzyd/6Z6YaqdPpFGmaeh/TO5O72si8Qs8cQRJCbJi8UfK/K0O7avRs+5LtCCHEhG1FsivtlGsVswujwFJdY6ZYCZk+VGMndKPHeAhCiA++i2T01YK24qu0OYQQFZt4Um2KnkjUFvxumjq0YY3BUmvw6AezLXdUP2cBVkKIC91mLFLn1BRDQZtDCFFRHUEmLePKiqDapul0unwMlslV74rD4oiREFIUU+1Bm2veFNSetz9CCMnDZHNsi26KVozwFljqwdXtTGLLlRSQEHK78cnKrr9v+r4+urQNAAkhRNUlNlGlvrbtY2mBpRssW0kK3eVmi8MihBDBJ8eVjs+AjSEJhBAbpvgr9X2TvpHXi6aeyvVguZL/2UaXNHKEEBe2dC++3nNCCFmEvNqmptc+9smENU3DdDp15qtR/zc1lMaQEGLCFGwKXLQb+iplV1yovCaEEBsuT3ierpnNZnNlcpZK02AaYZpSzJuWTDP+ihBSBNfiGVtuLDVdjFp5ghBCTNh0iq0ihEkHLZ2mQW2MfnD9YHlCikKLEKJiE06uJKM6s9kMaZrOLZ9Wq08QQojgo1Ns04bL5PS0Cix96XQRMWXycBFCiA2fPFimz4MgmPNkqf8TQghg9lD5iq5lwhC8S+XoYklfEm0LWiWEEBOmVTq+xZ6B9+IqiiJEUTQntAghxISrlrJuf/QpxEUwWiQxVnnLpgF7AlIGnhJCXOixDnlGzLTEejqdol6vIwxDTKdTiixCyAVMesSUUNSldSTWs4iNMW6Zpimm02luAUR53xYQTy8WIURHH7i5qkS4SNMUcRxjMpmgXq+j0WjMrfIhhBDBpktcaRt0GzWdTpGmqfcxrVIsL9Je3cblvaLIIoSo2EaTrtGj/n0RUmEYIo5jpGmKtbU1RFFEm0MImcMUg6W/b6tS4wqFysM6RWhb4WOLwzJtT0NHCNFx2QXfJKNic5rNJsIwxHA4xGQyyUQWIYSouHSKKf5KPte3X3qKUE0ymieUfEedhBBiwmZrfEadUtk+CAKcn58jjmN0Op3rPiVCSEUpqll0L1eRMARrDJaprmCeF0t9jxBCTPjmuzIJLn17yYUlryeTSSa6CCFExxborr4n25nqF0qM+sKJRlXRVMQbRWFFCMljUZtiE2Fiq2Tl82AwuO5TJIRUnCJ6xVWyy0XgszPTqh/1tfq9ZTOfEkJuHz6ii6EHhJBF0RfruQrOq691LVQk4N1ai1AN5DLV6FFfmz5TG0YIIS587ETewhuxN1IrjBBCAHu4gUvDmOI/gyAoZF+cQe56NXuXB4sxWIQQX3y9UUUW2IitKpKnhhByuzDFW6l/mzxd6r+lg9wBzCUa1QWT3iiTuGJdMEKIDZdNUd8rUqqC1SMIISZsYU7yns1ZJNuqiUb177uw5sEyNU49mOk1c18RQhYhb2WhT2FWMX7Mg0UIcaGngLFpGtlWRS0jmIdXsee8TKbqNrY4CUIIAXAhWNTXRthiOtVVhMD7VA2EECK4Eozm1R9cxnFkFVi6YNILs6rvLZNKnhBy+7Atd86Lj8jzpgdBgHq9ft2nRwipMKZSgD4ap4hXHXDkwdIDvCR6Xtzv4o6XgHhTRWp6rwghOq5iq7bFMrZC82qsaJIkCMMQa2tr132KhJCKYdInonFUPQO8DzOQbAr6Qr8icaFGgTWZTIxGMI5jAL/JnqxmM2XJHELIIpiqQQiuKvdqclEAaLVaqNfrGI1G131KhJCKkTcVKHpGViHHcWzUQUmSeCcctXqwdKbTKX79619naeKDIMhGjKbvFFF5hJDbgyknjS1LsishoJqTpl6vo9VqIU3TbCBICCGAu3gz8D73Z5IkCIIA0+kUaZri17/+tTElg03zmLDmwdKp1Wr4+uuvs1o84/E4c8/bToJThIQQH1wDMlvCP5kWbDabqNfriOMYo9GIdocQcgFbwnR5bzqdYjweZ7WYRe/Y9rPwFKHNyO3t7eH09BTA+yr20+k0c5e54ioIIUQoGixqCkOQUWaj0QAAjMfjbNBHu0MI0TFpErFFqp4BgNPTU+zt7TlXLQ+Hw9xjenuwAKDX6+EXv/gFGo1G5lKT6cLZbJYFhqmJuTiaJIS4ULMkmz6zecTr9XoWqiCGUTxbhBAi6JpEFuxJHKeIqzAM0Wg08Itf/AK9Xs+6rzAM8e7du9zjWoPcTcRxjB//+McAgPPzc0wmEwyHQ6Rpinq9jiRJsgB4iitCiIkidsGUcVlSMaiDPHV72h1CiI66mCZNUyRJgnq9jjRNMRwOMZlMcH5+DgD48Y9/bI3lFO/VwgLLtgqn0WjgJz/5CX72s5/h/v37ODs7w3g8xunpKdI0RRRFF0aQNHaEEBVTKQrT3zoipGT5tAzmXGUuCCHElC8viiKkaYrT01OMx2OcnZ3h/v37+NnPfoaf/OQnWfiBaV9xHGdecxdGgSUqzrTjs7Mz/PCHP8S7d++wvr6O6XSK09NTHB8fzy2bpqEjhPigerxddiMMw2wFj8Rg6d4r2R8hhOjo6V2Oj49xenqK6XSK9fV1vHv3Dj/84Q9xdnbmHOzFcexV9NkosE5OTqxerHa7ja+++go/+tGP5uKtzs7O8Pr1awwGAwBcSUgIMaPXAFO93rb4zVqthnq9jkajMReMqu+XU4SEEB1djwwGA7x+/ToTUhJX9aMf/QhfffUV2u22dV9pmnpNDwJACOD/6W9Op1Ocn5+j2+1eKPwMAM1mEz//+c8RxzE++eQTNJvNbEQ5mUyypY6qWiSEEAD45ptvEEURWq1W5pWSaT+9NEWappktGY/HiOMYcRxnyZAnkwmSJMF4PMZkMslGld/61reu+zQJIRVhMplkMeODwQDD4TDLe9VsNpEkCf7mb/4G//iP/4j19XWrFzwIgsyZ5OMpt5adHw6HODw8xNbWlvEgzWYTf//3f49er4c/+7M/w/b2Nl69eoW7d+9iNpvh5OQka8BHH3103f1LCKkIx8fHGI1GGA6HWFtbQ6vVQhRFiKIIzWYTzWYzE12Sd0+ElaRjUIWW5K+Rz6WcFyGEAMCrV68AvB+4NZtNNBoNHB8f48MPP8T+/j7+6q/+Cv/6r/+KZrOZxXfqSDqHb775xmt6EABqAKwyLIoi/M7v/A7W19fNX/6/YK8PPvgAn3/+Of7oj/4InU4nU4vj8RhJkmA2m2XGUseWYVXPlaNvbz2h/5tykOONRqO5zM+SUOy6kXw97Bc3phpQ7L/l+w94H9N0WW2WY6Vpin6/n61MPj8/x/n5OdbW1rIEoa1WKzN6zWYzS/ciaRhmsxnOz88xHA4zYTYejzGbzTAajTIPlqwECsMQ9+7dy2oS1ut1dLvdLH7rsmK0TIbZ1f9VQPpX7gN5AIn30CevmO33ZPrtubaXBI/qjAf7b7n+Y7/8pl+iKEKj0UC9Xke9XsdgMMA//dM/4R/+4R/w5s0btFota5tkJu7ly5fo9XrlCCzgvcja3NzEw4cPjQ+zWq2G09NTfPDBB/j444/x8ccf49NPP8W9e/dw586drHyFq2OKdKr8LRdQ3V5dti2dKVMLkq9Lcl7o+7YVc9SPoWd/Vb9na7/pfMIwZL9Yzkf9js3AqqvI2H/F+0/93NUfPg842zUQ43Z0dITJZIJGo4GTkxMMBgOsra2h3W6j1WrNCSwRVSK0JN5qNBplHivdkyWDudFohDRNEYYh7t+/jzt37mA8HqNer+PevXtzMaN57fe9jnqcmC2Roeva+FxX232h3xt6ipy86yj3rdzHjUYDtVotGxyrq630Y8hD0tYfpnvb1Gb1u7roZ/8V7z8RFOyX+X6J4xgnJyc4OjrCl19+ia+//hpff/013rx5g42NDeNvV84jiiIcHBzg9evXRu+WjVyBJY1uNBr49re/nbnQVNQR/Pn5OZrNJjY3N7G9vY3NzU1EUTSnrPMupn7x9c5S47pcRWJrtRo6nQ5GoxGOjo4yI246vn6+1+WNkPNVvYBqW+/cuYMwDDEcDrNkaT79YDvnIg9kG2EYzq0cDcMQd+/eRZIkOD4+zu4PNSO3ei8sQtkrVW0rYE9PT/HRRx+h3W7j7du3mEwmxgDsZY6r7yNP6Mj2+uhwOBzi+Pg4G6GJJ0i2sT2cTGLPJVr11XrqvnXDWqvVcH5+ng0qRBxJG+Ue1h8O9+/fRxiGmcdK8tYAyPYPIMu9J8lG5bgi3GR/a2tr2YhaF8QmIZtnm3yul75vaaf8tu/evYt2u33BG5r3e7SJ8zLuQ/l7NpuhXq/jwYMHGA6H+N///V9sbGzM9Yncg2V6lpZZpCDfU9skfTedTnH37l1EUYTj4+PsISnH831o5gk+vT159lT9ntzL7XYbaZri5ORkbhvV+6Jfs6tEvUdt5yNiajQa4d69e2g2mxgMBl79INfP9z63DU5lX7PZ+wLNh4eH2N/fx+HhIUajEdbW1i542tR9qs+Dt2/f4ptvvvFKzTB3XvAQWEK9XsdHH32E+/fvGz8XpSc3qwSeSiLSsn6IrptbN5CtVgv1ej0Lwhdj5ut+1N8vOpIvel5yUWU6ShUnkmdM+lRuDJvYuCq3unocMbrtdht3797NHvqqZ0gecup1uoz+9EU16urUI/B+1Wy73cZwOMyEwjL9JMcrAzFEIiCiKJoL9JYyVqoguQ5cnjPpb0n4V6/X0W63EUUR3rx5kwkh9f4STFMhJoFken2ViKCT37C8J8mZ5b5SBx7LUsa9JveV3P9SGkSfiip7sOM6J9f5qL9h3d6ImD0+PsZwOJwTCddhJ/V2S3/KQEOeWWopOjU1SRni1vdZtujzUmIp5ZkliTtdA7Syp4Nns1kWNiCrkIH54s6m66He09988w0ODw8Lea6yfaGAwJKGPXjwAL/1W791oXEyEpCl1HLjyPs2l95l/jhdSvsqjl/0GPqNXeQYVcDmnVTvB9O5VqXN4kWxcVntXfQ+tAVkXlW7y0DK3ZhGpjLQWMS4VQWf67poPNxl2i/XflVvY9V+x+prddCq91kV2izt9MVnoG/6zlU+4/KeuZd9fP19dYZF7ofxeJy9rzMejwG8n0Xa39/3znllbBcKCizgvUHc3NzE48ePM/EkHqrJZFKJIDvAfeNW5cdlavOiP4jrPqdFf8TX2e6ibS57OmTZPvONtyi77WWgehpM1Ot1pyFcBYoMrJYNwi/7QXqdv43LbmsV2rxou6smEIucU1XaPJ1OUa/X5zxcMgNwfHyMV69e4fz8fGnP/0ICSzoqiiJ0Oh08ePAgS8wly611N1uZUxRXociv+rhqf5V9Ey7iEbvu/qjC8S6j/UKeEco7T5luklW66qBm2et9Ffe5z3HE86kLDz3+7Ko942UIY/X74t2V65n3+/fpN2HVfy+rbl8uy/aqQedVvM+rdFw1Xlv2LVOt4jmWBTNlCavsXLCgwFKRlVWtVgsbGxtZ8Jh4tfQVCK7Atbx5YUE6xrS9Lu5cAfX6ts7OMpyL7ha1zbHr26jxAeo2ywbY26bg9P7VS4zoP9i8qUrfVR2+bXZdB9cDx9RuV3+Ip0BiGpaNUbEFtur3CXAx+NbHkNgWKMhqOTWmTR3M6DFuYkzSNHV6mF33r35fuqZ7Tfeefs+5PFgSkyKxEr6xevp2ej/kBfTnfV8/rg1Tf+sxQqZ+kOuad/1t1079DejCW78vbffuosjxZFbDFBKgH893YGm7R4rYb1uf+R5LPjO1W/2OvhLZde8tih5Dph/XtWhDP77pGVFkJsV0P5mmZG3bqn2jhzz4xojp26p9o24rvy85xmw2w+npKV69eoXRaFR6rGopAkuQYM56vY719XW0Wq1MeEkHqFH7ErStZn1XC7kCvwlGUy+O2nHqj1rtWDVJoXrxJFBQjQ8Tb4Ba20y9CdRVR6rBlP2qYk9dPaULQPV46sNWF4ONRsM5dWJDD4JU+1HtO934qf0uAdF6DJ2co5y/KtL0YFcZjavbmq6f2mb5W7bR/1YfSuo+1Xwq6r71a5Dd8Er/i1tYCpXniS1xJ9seDOr1lqBtW7CofFeCWdXvqvvOC+RWR2T6CK3dbmNtbQ1hGOLo6Ci7Hqo4U/ta+kU9jvpPvXfUFTbqvar+bk0P9Hq9ngXir6+vo1arza3MUUeX6vnr96N+/mohaHH/y7XS26G2Uc5Tv9/0KTv1n2rvZP9qf0j/yj127949pGma5fKSvldtnj7tY/rtq21Uz0nsk77C1XTvhWGYZcGX76qfq/v2WZg0m71foSV2Wv3N67871fabHo5qW+R6qqs+9ftNvT/Efum/D/VBK9dDBLvaV6otU7fVn09yTP2ZoB9Tv3fUe1P2obbZF7k/JQ+c+juV46n9r4s79fxkO1PKG/X81UUy+nNR+lM9nv48Ue89+X3o18n2+5ZjqYvn1GeR/nySwHX9+aTae1lxfHJygtevX2e/h8ugVIFFCCGEEEIsxZ4JIYQQQsjiUGARQgghhJQMBRYhhBBCSMlQYBFCCCGElAwFFiGEEEJIyVBgEUIIIYSUDAUWIYQQQkjJUGARQgghhJQMBRYhhBBCSMlQYBFCCCGElAwFFiGEEEJIyVBgEUIIIYSUDAUWIYQQQkjJUGARQgghhJQMBRYhhBBCSMlQYBFCCCGElAwFFiGEEEJIyVBgEUIIIYSUDAUWIYQQQkjJUGARQgghhJQMBRYhhBBCSMlQYBFCCCGElAwFFiGEEEJIyVBgEUIIIYSUDAUWIYQQQkjJUGARQgghhJQMBRYhhBBCSMlQYBFCCCGElAwFFiGEEEJIyVBgEUIIIYSUDAUWIYQQQkjJUGARQgghhJQMBRYhhBBCSMlQYBFCCCGElAwFFiGEEEJIyVBgEUIIIYSUDAUWIYQQQkjJUGARQgghhJQMBRYhhBBCSMlQYBFCCCGElAwFFiGEEEJIyVBgEUIIIYSUDAUWIYQQQkjJUGARQgghhJQMBRYhhBBCSMn8f8kzn+4/fE6rAAAAAElFTkSuQmCC";
        }

        private void SpawnDeployableSign(string prefab, Vector3 pos, Quaternion angles)
        {
            var newItem = ItemManager.CreateByName(prefab);
            if (newItem?.info.GetComponent<ItemModDeployable>() == null)
            {
                return;
            }
            var deployable = newItem.info.GetComponent<ItemModDeployable>().entityPrefab.resourcePath;
            if (deployable == null)
            {
                return;
            }
            var newBaseEntity = GameManager.server.CreateEntity(deployable, pos, angles);
            if (newBaseEntity == null)
            {
                return;
            }
            newBaseEntity.SendMessage("InitializeItem", newItem, SendMessageOptions.DontRequireReceiver);
            newBaseEntity.Spawn();

            var stream = new MemoryStream();
            var stringSign = Convert.FromBase64String(SignTexture());
            stream.Write(stringSign, 0, stringSign.Length);

            var sign = newBaseEntity.GetComponent<Signage>();
            sign.textureID = FileStorage.server.Store(stream, FileStorage.Type.png, sign.net.ID);

            stream.Position = 0;
            stream.SetLength(0);

            newBaseEntity.SetFlag(BaseEntity.Flags.Locked, true);
            newBaseEntity.SendNetworkUpdate();
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// HUD
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        public string doorsoverlay = @"[
		                {
							""name"": ""RemoteOverlay"",
                            ""parent"": ""Overlay"",
                            ""components"":
                            [
                                {
                                     ""type"":""UnityEngine.UI.Image"",
                                     ""color"":""0.1 0.1 0.1 0.8"",
                                },
                                {
                                    ""type"":""RectTransform"",
                                    ""anchormin"": ""0 0"",
                                    ""anchormax"": ""1 1""
                                },
                                {
                                    ""type"":""NeedsCursor"",
                                }
                            ]
                        },
                        {
                            ""parent"": ""RemoteOverlay"",
                            ""components"":
                            [
                                {
                                    ""type"":""UnityEngine.UI.Text"",
                                    ""text"":""REMOTE ACTIVATOR"",
                                    ""fontSize"":20,
                                    ""align"": ""MiddleLeft"",
                                },
                                {
                                    ""type"":""RectTransform"",
                                    ""anchormin"": ""0 0.99"",
                                    ""anchormax"": ""1 0.89""
                                }
                            ]
                        },
                        {
                            ""parent"": ""RemoteOverlay"",
                            ""components"":
                            [
                                {
                                    ""type"":""UnityEngine.UI.Text"",
                                    ""text"":""Close"",
                                    ""fontSize"":20,
                                    ""align"": ""MiddleCenter"",
                                },
                                {
                                    ""type"":""RectTransform"",
                                    ""anchormin"": ""0 0"",
                                    ""anchormax"": ""1 0.10""
                                }
                            ]
                        },
                        {
				            ""parent"": ""RemoteOverlay"",
				            ""components"":
				            [
					            {
						            ""type"":""UnityEngine.UI.Button"",
						            ""command"":""remote.close"",
						            ""color"": ""0.5 0.5 0.5 0.2"",
						            ""imagetype"": ""Tiled""
					            },
					            {
						            ""type"":""RectTransform"",
                                    ""anchormin"": ""0 0"",
                                    ""anchormax"": ""1 0.10""
					            }
				            ]
			            },
                        {
                            ""parent"": ""RemoteOverlay"",
                            ""components"":
                            [
                                {
                                    ""type"":""UnityEngine.UI.Text"",
                                    ""text"":""Close"",
                                    ""fontSize"":15,
                                    ""align"": ""MiddleCenter"",
                                },
                                {
                                    ""type"":""RectTransform"",
                                    ""anchormin"": ""0.4 0.60"",
                                    ""anchormax"": ""0.5 0.70""
                                }
                            ]
                        },
                        {
				            ""parent"": ""RemoteOverlay"",
				            ""components"":
				            [
					            {
						            ""type"":""UnityEngine.UI.Button"",
						            ""command"":""remote.cmd close {remoteid}"",
						            ""color"": ""0.1 0.1 0.1 0.9"",
						            ""imagetype"": ""Tiled""
					            },
					            {
						            ""type"":""RectTransform"",
						             ""anchormin"": ""0.4 0.60"",
                                     ""anchormax"": ""0.5 0.70""
					            }
				            ]
			            },
                        {
                            ""parent"": ""RemoteOverlay"",
                            ""components"":
                            [
                                {
                                    ""type"":""UnityEngine.UI.Text"",
                                    ""text"":""Open"",
                                    ""fontSize"":15,
                                    ""align"": ""MiddleCenter"",
                                },
                                {
                                    ""type"":""RectTransform"",
						             ""anchormin"": ""0.50 0.60"",
                                     ""anchormax"": ""0.60 0.70""
                                }
                            ]
                        },
                        {
				            ""parent"": ""RemoteOverlay"",
				            ""components"":
				            [
					            {
						            ""type"":""UnityEngine.UI.Button"",
						            ""command"":""remote.cmd open {remoteid}"",
						            ""color"": ""0.1 0.1 0.1 0.9"",
						            ""imagetype"": ""Tiled""
					            },
					            {
						            ""type"":""RectTransform"",
						             ""anchormin"": ""0.50 0.60"",
                                     ""anchormax"": ""0.60 0.70""
					            }
				            ]
			            }
                    ]
                    ";
        public string getaccessoverlay = @"[
                        {
                            ""parent"": ""RemoteOverlay"",
                            ""components"":
                            [
                                {
                                    ""type"":""UnityEngine.UI.Text"",
                                    ""text"":""Access"",
                                    ""fontSize"":15,
                                    ""align"": ""MiddleCenter"",
                                },
                                {
                                    ""type"":""RectTransform"",
						             ""anchormin"": ""0.40 0.50"",
                                     ""anchormax"": ""0.60 0.60""
                                }
                            ]
                        },
                        {
				            ""parent"": ""RemoteOverlay"",
				            ""components"":
				            [
					            {
						            ""type"":""UnityEngine.UI.Button"",
						            ""command"":""remote.cmd access {remoteid}"",
						            ""color"": ""0.1 0.1 0.1 0.9"",
						            ""imagetype"": ""Tiled""
					            },
					            {
						            ""type"":""RectTransform"",
						             ""anchormin"": ""0.40 0.50"",
                                     ""anchormax"": ""0.60 0.60""
					            }
				            ]
			            }
                    ]
                    ";
        public string adminoverlay = @"[
                        {
                            ""parent"": ""RemoteOverlay"",
                            ""components"":
                            [
                                {
                                    ""type"":""UnityEngine.UI.Text"",
                                    ""text"":""Reset Doors"",
                                    ""fontSize"":15,
                                    ""align"": ""MiddleCenter"",
                                },
                                {
                                    ""type"":""RectTransform"",
						             ""anchormin"": ""0.40 0.30"",
                                     ""anchormax"": ""0.50 0.40""
                                }
                            ]
                        },
                        {
				            ""parent"": ""RemoteOverlay"",
				            ""components"":
				            [
					            {
						            ""type"":""UnityEngine.UI.Button"",
						            ""command"":""remote.cmd reset {remoteid}"",
						            ""color"": ""0.1 0.1 0.1 0.9"",
						            ""imagetype"": ""Tiled""
					            },
					            {
						            ""type"":""RectTransform"",
						             ""anchormin"": ""0.40 0.30"",
                                     ""anchormax"": ""0.50 0.40""
					            }
				            ]
			            },
                        {
                            ""parent"": ""RemoteOverlay"",
                            ""components"":
                            [
                                {
                                    ""type"":""UnityEngine.UI.Text"",
                                    ""text"":""Add Doors"",
                                    ""fontSize"":15,
                                    ""align"": ""MiddleCenter"",
                                },
                                {
                                    ""type"":""RectTransform"",
						             ""anchormin"": ""0.50 0.30"",
                                     ""anchormax"": ""0.60 0.40""
                                }
                            ]
                        },
                        {
				            ""parent"": ""RemoteOverlay"",
				            ""components"":
				            [
					            {
						            ""type"":""UnityEngine.UI.Button"",
						            ""command"":""remote.cmd add {remoteid}"",
						            ""color"": ""0.1 0.1 0.1 0.9"",
						            ""imagetype"": ""Tiled""
					            },
					            {
						            ""type"":""RectTransform"",
						             ""anchormin"": ""0.50 0.30"",
                                     ""anchormax"": ""0.60 0.40""
					            }
				            ]
			            },
                         {
                            ""parent"": ""RemoteOverlay"",
                            ""components"":
                            [
                                {
                                    ""type"":""UnityEngine.UI.Text"",
                                    ""text"":""Reset Access"",
                                    ""fontSize"":15,
                                    ""align"": ""MiddleCenter"",
                                },
                                {
                                    ""type"":""RectTransform"",
						             ""anchormin"": ""0.40 0.20"",
                                     ""anchormax"": ""0.50 0.30""
                                }
                            ]
                        },
                        {
				            ""parent"": ""RemoteOverlay"",
				            ""components"":
				            [
					            {
						            ""type"":""UnityEngine.UI.Button"",
						            ""command"":""remote.cmd resetaccess {remoteid}"",
						            ""color"": ""0.1 0.1 0.1 0.9"",
						            ""imagetype"": ""Tiled""
					            },
					            {
						            ""type"":""RectTransform"",
						             ""anchormin"": ""0.40 0.20"",
                                     ""anchormax"": ""0.50 0.30""
					            }
				            ]
			            },
                        {
                            ""parent"": ""RemoteOverlay"",
                            ""components"":
                            [
                                {
                                    ""type"":""UnityEngine.UI.Text"",
                                    ""text"":""Give Access"",
                                    ""fontSize"":15,
                                    ""align"": ""MiddleCenter"",
                                },
                                {
                                    ""type"":""RectTransform"",
						             ""anchormin"": ""0.50 0.20"",
                                     ""anchormax"": ""0.60 0.30""
                                }
                            ]
                        },
                        {
				            ""parent"": ""RemoteOverlay"",
				            ""components"":
				            [
					            {
						            ""type"":""UnityEngine.UI.Button"",
						            ""command"":""remote.cmd giveaccess {remoteid}"",
						            ""color"": ""0.1 0.1 0.1 0.9"",
						            ""imagetype"": ""Tiled""
					            },
					            {
						            ""type"":""RectTransform"",
						             ""anchormin"": ""0.50 0.20"",
                                     ""anchormax"": ""0.60 0.30""
					            }
				            ]
			            }
                    ]
                    ";

        void ShowUI(BasePlayer player, Vector3 remotePos, string ttype)
        {
            RemoteActivator ract = remoteActivators[remotePos];
            if (ract == null)
            {
                SendReply(player, "Invalid Remove Activator");
                return;
            }
            var doverlay = doorsoverlay.Replace("{remoteid}", string.Format("'{0}' '{1}' '{2}'", remotePos.x, remotePos.y, remotePos.z));
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "AddUI", new Facepunch.ObjectList(doverlay));
            if (ttype == "admin")
            {
                var aoverlay = adminoverlay.Replace("{remoteid}", string.Format("'{0}' '{1}' '{2}'", remotePos.x, remotePos.y, remotePos.z));
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "AddUI", new Facepunch.ObjectList(aoverlay));
            }
            if (allowAuth.ContainsKey(remotePos) && (Time.realtimeSinceStartup - allowAuth[remotePos] <= 15))
            {
                var goverlay = getaccessoverlay.Replace("{remoteid}", string.Format("'{0}' '{1}' '{2}'", remotePos.x, remotePos.y, remotePos.z));
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "AddUI", new Facepunch.ObjectList(goverlay));
            }
        }

        void OnUseSignage(BasePlayer player, Signage sign)
        {
            Vector3 targetPos = new Vector3(Mathf.Ceil(sign.transform.position.x), Mathf.Ceil(sign.transform.position.y), Mathf.Ceil(sign.transform.position.z));
            if (remoteActivators[targetPos] == null) return;
            if (remoteActivators[targetPos].owner == player.userID.ToString())
                ShowUI(player, targetPos, "admin");
            else if (remoteActivators[targetPos].autorizedUsers.Contains(player.userID.ToString()) || (allowAuth.ContainsKey(targetPos) && (Time.realtimeSinceStartup - allowAuth[targetPos] <= 15)))
                ShowUI(player, targetPos, "normal");
            else
            {
                SendReply(player, "You are not allowed to use the remote doors here");
            }
        }

        void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (input.WasJustPressed(BUTTON.USE))
            {
                if (Physics.Raycast(player.eyes.HeadRay(), out cachedHit, 1f, signColl))
                    if (cachedHit.collider.GetComponentInParent<Signage>() != null)
                        OnUseSignage(player, cachedHit.collider.GetComponentInParent<Signage>());
            }
        }

        class RemoteDoorAdder : MonoBehaviour
        {
            BasePlayer player;
            float lastUpdate;
            public Vector3 remoteActivate;
            InputState inputState;

            void Awake()
            {
                player = GetComponent<BasePlayer>();
                lastUpdate = Time.realtimeSinceStartup;
                Invoke("DestroyThis", 60f);
            }
            void FixedUpdate()
            {
                if (!player.IsConnected() || player.IsDead()) { Destroy(this); return; }
                inputState = serverinput.GetValue(player) as InputState;
                if (inputState.WasJustPressed(BUTTON.FIRE_PRIMARY))
                {
                    float currentTime = Time.realtimeSinceStartup;
                    if (lastUpdate + 0.5f < currentTime)
                    {
                        lastUpdate = currentTime;
                        TryAddDoor(player, remoteActivate);
                    }
                }
            }
            public void Refresh()
            {
                CancelInvoke("DestroyThis");
                Invoke("DestroyThis", 60f);
            }
            void DestroyThis()
            {
                PrintToChat(player, "You are done added new doors");
                Destroy(this);
            }
        }
        static void PrintToChat(BasePlayer player, string message)
        {
            player.SendConsoleCommand("chat.add", 0, message, 1f);
        }
        static void TryAddDoor(BasePlayer player, Vector3 remoteActivate)
        {
            if (remoteActivators[remoteActivate] == null)
            {
                Debug.Log("This remote activator doesnt exist");
                return;
            }
            BaseEntity foundEntity = FindRayStructure(player.eyes.HeadRay(), doorColl);
            if (foundEntity == null)
            {
                PrintToChat(player, "Couldn't find a door");
                return;
            }
            if (foundEntity.GetComponent<Door>() == null)
            {
                PrintToChat(player, "You are not looking at a door");
                return;
            }
            if (remoteActivators[remoteActivate].listedDoors.Count >= maxDoors)
            {
                PrintToChat(player, "You've reached the max doors allowed per remote activator");
                return;
            }
            Door door = foundEntity.GetComponent<Door>();
            if (!door.HasSlot(BaseEntity.Slot.Lock))
            {
                PrintToChat(player, "This door doesn't have a lock");
                return;
            }
            if (Vector3.Distance(remoteActivate, door.transform.position) > float.Parse(maxDistance.ToString()))
            {
                PrintToChat(player, "This door is too far from the remote activator");
                return;
            }
            BaseEntity baselock = door.GetSlot(BaseEntity.Slot.Lock);
            if (baselock == null)
            {
                PrintToChat(player, "This door doesn't have a lock");
                return;
            }
            CodeLock codelock = baselock.GetComponent<CodeLock>();
            if (codelock == null)
            {
                PrintToChat(player, "This door needs a Code Lock");
                return;
            }
            List<ulong> whitelistcodelock = fieldWhiteList.GetValue(codelock) as List<ulong>;
            if (!whitelistcodelock.Contains(player.userID))
            {
                PrintToChat(player, "You must have access to this code lock to add this door.");
                return;
            }
            Vector3 goodPos = new Vector3(Mathf.Ceil(foundEntity.transform.position.x), Mathf.Ceil(foundEntity.transform.position.y), Mathf.Ceil(foundEntity.transform.position.z));
            foreach (RemoteDoor rdoorr in remoteActivators[remoteActivate].listedDoors)
            {
                if (rdoorr.Pos() == goodPos)
                {
                    PrintToChat(player, "This door is already listed");
                    return;
                }
            }
            storedData.RemoteActivators.Remove(remoteActivators[remoteActivate]);
            remoteActivators[remoteActivate].listedDoors.Add(new RemoteDoor(goodPos));
            storedData.RemoteActivators.Add(remoteActivators[remoteActivate]);
            PrintToChat(player, "Added a new door");
        }

        static BaseEntity FindRayStructure(Ray ray, int currentCol)
        {
            RaycastHit hit;
            if (!Physics.Raycast(ray, out hit, 3f, currentCol))
                return null;
            return hit.GetEntity();
        }
        [ConsoleCommand("remote.close")]
        void ccmdRemoteClose(ConsoleSystem.Arg arg)
        {
            var player = arg.connection?.player as BasePlayer;
            if (player == null) return;
            CuiHelper.DestroyUi(player, "RemoteOverlay");
        }
        [ConsoleCommand("remote.cmd")]
        void ccmdRemoteCommand(ConsoleSystem.Arg arg)
        {
            if (!arg.HasArgs(4)) return;
            var player = arg.connection?.player as BasePlayer;
            if (player == null) return;
            var arg1 = arg.GetString(0).Replace("'", "");
            var x = arg.GetString(1).Replace("'", "");
            var y = arg.GetString(2).Replace("'", "");
            var z = arg.GetString(3).Replace("'", "");

            Vector3 targetPos = new Vector3(float.Parse(x), float.Parse(y), float.Parse(z));
            if (remoteActivators[targetPos] == null) return;

            if (Vector3.Distance(remoteActivators[targetPos].Pos(), player.transform.position) > 3f)
            {
                SendReply(player, "You are too far from the remote activator.");
                return;
            }
            switch (arg1)
            {
                case "add":
                    if (remoteActivators[targetPos].owner != player.userID.ToString())
                    {
                        SendReply(player, "Only the owner of this remote activator can add new doors");
                        return;
                    }
                    RemoteDoorAdder remoteadded = player.GetComponent<RemoteDoorAdder>();
                    if (remoteadded == null)
                        remoteadded = player.gameObject.AddComponent<RemoteDoorAdder>();
                    remoteadded.remoteActivate = targetPos;
                    remoteadded.Refresh();
                    SendReply(player, "You are now adding doors for 1 minute");
                    break;
                case "reset":
                    if (remoteActivators[targetPos].owner != player.userID.ToString())
                    {
                        SendReply(player, "Only the owner of this remote activator can reset the doors");
                        return;
                    }
                    storedData.RemoteActivators.Remove(remoteActivators[targetPos]);
                    remoteActivators[targetPos].listedDoors.Clear();
                    storedData.RemoteActivators.Add(remoteActivators[targetPos]);
                    SendReply(player, "You've cleared all the doors");
                    break;
                case "open":
                case "close":
                    if (!remoteActivators[targetPos].autorizedUsers.Contains(player.userID.ToString()))
                    {
                        SendReply(player, "You dont have access to this remote activator.");
                        return;
                    }
                    foreach (Collider col in Physics.OverlapSphere(targetPos, float.Parse(antiTrapDistance.ToString()), playerColl))
                    {
                        BasePlayer tplayer = col.GetComponentInParent<BasePlayer>();
                        if (tplayer == null) continue;
                        if (!tplayer.IsConnected()) continue;
                        if (!remoteActivators[targetPos].autorizedUsers.Contains(tplayer.userID.ToString()))
                        {
                            SendReply(player, "Someone that doesn't have the authorisation to use this switch is near, you must wait for him to leave or give him access.");
                            return;
                        }
                    }
                    bool shouldopen = arg1 == "open" ? true : false;
                    List<RemoteDoor> toDelete = new List<RemoteDoor>();
                    foreach (RemoteDoor rdoor in remoteActivators[targetPos].listedDoors)
                    {
                        if (!rdoor.OpenDoor(shouldopen))
                        {
                            toDelete.Add(rdoor);
                        }
                    }
                    if (toDelete.Count > 0)
                    {
                        storedData.RemoteActivators.Remove(remoteActivators[targetPos]);
                        foreach (RemoteDoor rdoor in toDelete)
                        {
                            remoteActivators[targetPos].listedDoors.Remove(rdoor);
                        }
                        storedData.RemoteActivators.Add(remoteActivators[targetPos]);
                    }
                    break;
                case "access":
                    if (!allowAuth.ContainsKey(targetPos))
                    {
                        SendReply(player, "You are not allowed to get access to this remote activator.");
                        return;
                    }
                    if (Time.realtimeSinceStartup - allowAuth[targetPos] > 15)
                    {
                        SendReply(player, "You are not allowed to get access to this remote activator.");
                        return;
                    }
                    if (remoteActivators[targetPos].autorizedUsers.Contains(player.userID.ToString()))
                    {
                        SendReply(player, "You already have access to this remote activator.");
                        return;
                    }
                    if (Vector3.Distance(remoteActivators[targetPos].Pos(), player.transform.position) > 3f)
                    {
                        SendReply(player, "You are too far from the remote activator." + Vector3.Distance(remoteActivators[targetPos].Pos(), player.transform.position));
                        return;
                    }
                    storedData.RemoteActivators.Remove(remoteActivators[targetPos]);
                    remoteActivators[targetPos].autorizedUsers.Add(player.userID.ToString());
                    storedData.RemoteActivators.Add(remoteActivators[targetPos]);
                    SendReply(player, "You now have access to this remote activator.");
                    break;
                case "giveaccess":
                    if (remoteActivators[targetPos].owner != player.userID.ToString())
                    {
                        SendReply(player, "Only the owner of this remote activator give access to other players");
                        return;
                    }
                    if (allowAuth.ContainsKey(targetPos)) allowAuth.Remove(targetPos);
                    allowAuth.Add(targetPos, Time.realtimeSinceStartup);
                    SendReply(player, "People that use the remote activator will be allowed to auth in the next 15 seconds");
                    break;
                case "resetaccess":
                    if (remoteActivators[targetPos].owner != player.userID.ToString())
                    {
                        SendReply(player, "Only the owner of this remote activator reset the access");
                        return;
                    }
                    storedData.RemoteActivators.Remove(remoteActivators[targetPos]);
                    remoteActivators[targetPos].autorizedUsers.Clear();
                    remoteActivators[targetPos].autorizedUsers.Add(player.userID.ToString());
                    storedData.RemoteActivators.Add(remoteActivators[targetPos]);
                    SendReply(player, "You have reseted the remote activator access list.");
                    break;

            }

        }
        void Pay(BasePlayer player)
        {
            List<Item> collect = new List<Item>();
            foreach (KeyValuePair<string, object> pair in cost)
            {
                string itemname = pair.Key.ToLower();
                if (displaynameToShortname.ContainsKey(itemname))
                    itemname = displaynameToShortname[itemname];
                ItemDefinition itemdef = ItemManager.FindItemDefinition(itemname);
                if (itemdef == null) continue;
                player.inventory.Take(collect, itemdef.itemid, Convert.ToInt32(pair.Value));
                player.Command(string.Format("note.inv {0} -{1}", itemdef.itemid, pair.Value));
            }
            foreach (Item item in collect)
            {
                item.Remove(0f);
            }
        }
        bool CanPay(BasePlayer player)
        {
            foreach (KeyValuePair<string, object> pair in cost)
            {
                string itemname = pair.Key.ToLower();
                if (displaynameToShortname.ContainsKey(itemname))
                    itemname = displaynameToShortname[itemname];
                ItemDefinition itemdef = ItemManager.FindItemDefinition(itemname);
                if (itemdef == null) continue;
                int amount = player.inventory.GetAmount(itemdef.itemid);
                if (amount < Convert.ToInt32(pair.Value))
                    return false;
            }
            return true;
        }
        [ChatCommand("remote")]
        void cmdChatNPCPathTest(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player))
            {
                SendReply(player, "You are not allowed to use this.");
                return;
            }
            if (args.Length == 0)
            {
                SendHelp(player);
                return;
            }
            switch (args[0].ToLower())
            {
                default:
                    List<BuildingPrivlidge> playerpriv = buildingPriviledge.GetValue(player) as List<BuildingPrivlidge>;
                    if (playerpriv.Count == 0)
                    {
                        SendReply(player, "You must have a Tool Cupboard to use this");
                        return;
                    }
                    foreach (BuildingPrivlidge priv in playerpriv.ToArray())
                    {
                        List<ProtoBuf.PlayerNameID> authorized = priv.authorizedPlayers;
                        bool foundplayer = false;
                        foreach (ProtoBuf.PlayerNameID pni in authorized.ToArray())
                        {
                            if (pni.userid == player.userID)
                                foundplayer = true;
                        }
                        if (!foundplayer)
                        {
                            SendReply(player, "You must have access to all surrounding tool cupboards");
                            return;
                        }
                    }
                    if (!CanPay(player))
                    {
                        SendReply(player, "You don't have enough resources to create a new remote activator");
                        return;
                    }
                    BaseEntity targetEnt = FindRayStructure(player.eyes.HeadRay(), constructionColl);
                    if (targetEnt == null)
                    {
                        SendReply(player, "You must be looking at a wall from maximum 3m away");
                        return;
                    }
                    BuildingBlock targetBlock = targetEnt.GetComponent<BuildingBlock>();
                    if (targetBlock == null)
                    {
                        SendReply(player, "You must be looking at a wall from maximum 3m away");
                        return;
                    }
                    if (targetBlock.blockDefinition.info.name.english.ToLower() != "wall")
                    {
                        SendReply(player, "You must be looking at a wall from maximum 3m away");
                        return;
                    }
                    Quaternion newRotation = targetEnt.transform.rotation * Quaternion.Euler(0, -90, 0);
                    Vector3 newPosition = targetEnt.transform.position + new Vector3(0f, 1.5f, 0f) + (newRotation * VectorForward);

                    RemoteActivator newRemote = new RemoteActivator(newPosition, args[0], player.userID.ToString());
                    if (remoteActivators[newRemote.Pos()] != null)
                    {
                        SendReply(player, "There is already a remote activator on this wall");
                        return;
                    }
                    SpawnDeployableSign("sign.wooden.small", newPosition, newRotation);
                    storedData.RemoteActivators.Add(newRemote);
                    remoteActivators[newRemote.Pos()] = newRemote;
                    Pay(player);
                    break;
            }
        }
        string GetCostInString()
        {
            var coststring = string.Empty;
            foreach (KeyValuePair<string, object> pair in cost)
            {
                coststring += string.Format("{0}x {1} - ", pair.Value, pair.Key);
            }
            return coststring;
        }
        void SendHelp(BasePlayer player, bool full = true)
        {
            var coststring = GetCostInString();
            var text = "<size=18>Remote Door Switch</size>\n<color=\"#ffd479\">/remote</color> - Get help on how to create a remote door switch that will remotely open and close your doors.";

            if (full)
            {
                text += "\n<color=\"#ffd479\">/remote</color> \"NAME\" - Create a new remote switch for doors where you are looking at. Needs to be on a wall!!";
                text += string.Format("\nIt will cost you: {0}", coststring == string.Empty ? "Nothing" : coststring);
                text += string.Format("\nYou may have {0} doors per remote, max {1}m away from the remote.", maxDoors, maxDistance);
            }
            SendReply(player, text);
        }
        [HookMethod("SendHelpText")]
        private void SendHelpText(BasePlayer player)
        {
            SendHelp(player, false);
        }
    }
}


// --- End of file: RemoteDoors.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Minstrel.cs ---
// --- Original Local Path: Minstrel.cs ---

using Oxide.Core;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Linq;
using UnityEngine;
using System.Text;

namespace Oxide.Plugins
{
    [Info("Minstrel", "4seti [Lunatiq] for Rust Planet", "0.0.7", ResourceId = 981)]
    public class Minstrel : RustPlugin
    {

        #region Utility Methods

        private void Log(string message)
        {
            Puts("{0}: {1}", Title, message);
        }

        private void Warn(string message)
        {
            PrintWarning("{0}: {1}", Title, message);
        }

        private void Error(string message)
        {
            PrintError("{0}: {1}", Title, message);
        }

        // Gets a config value of a specific type
        private T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null)
                return defaultValue;
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

        #endregion

        void Loaded()
        {
            Log("Loaded");
        }

        #region VARS
        private static FieldInfo serverinput;
        Dictionary<string, List<TuneNote>> tuneDict;
        Dictionary<ulong, List<TuneNote>> tuneRecTemp;
        List<string> cfgTunes;
        #endregion

        // Loads the default configuration
        protected override void LoadDefaultConfig()
        {
            Log("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }

        void LoadVariables()
        {
            Config["tunes"] = new List<string>();
            Config["version"] = Version;
        }

        void Init()
        {
            serverinput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Instance | BindingFlags.NonPublic));
            try
            {
                LoadConfig();
                tuneRecTemp = new Dictionary<ulong, List<TuneNote>>();
                var version = GetConfig<Dictionary<string, object>>("version", null);
                VersionNumber verNum = new VersionNumber(Convert.ToUInt16(version["Major"]), Convert.ToUInt16(version["Minor"]), Convert.ToUInt16(version["Patch"]));
                var savedTunes = GetConfig<List<object>>("tunes", new List<object>());
                tuneDict = new Dictionary<string,List<TuneNote>>();
                cfgTunes = new List<string>();
                foreach (var savedTune in savedTunes)
                {
                    cfgTunes.Add((string)savedTune);
                    List<TuneNote> loadTune;
                    if (LoadTune((string)savedTune, out loadTune))
                        tuneDict.Add((string)savedTune, loadTune);
                }

            }
            catch (Exception ex)
            {
                Error("Init failed: " + ex.Message);
            }
        }
        void Unload()
        {
            DestroyAll<KeyboardGuitar>();
        }
        private static void DestroyAll<T>()
        {
            UnityEngine.Object[] objects = GameObject.FindObjectsOfType(typeof(T));
            if (objects != null)
                foreach (UnityEngine.Object gameObj in objects)
                    GameObject.Destroy(gameObj);
        }
        
        
        [ChatCommand("ms")]
        void cmdToggleMS(BasePlayer player, string cmd, string[] args)
        {
            if (player.net.connection.authLevel == 0) return;
            if (player.GetComponent<KeyboardGuitar>() == null)
            {
                player.gameObject.AddComponent<KeyboardGuitar>();
                player.ChatMessage("ON - Added");
                player.ChatMessage(BuildNoteList(2.9f, 0));
            }
            else
            {
                if (player.GetComponent<KeyboardGuitar>().enabled)
                {
                    player.ChatMessage("OFF");
                    player.GetComponent<KeyboardGuitar>().enabled = false;
                }
                else
                {
                    player.ChatMessage("ON");
                    player.GetComponent<KeyboardGuitar>().enabled = true;
                    player.ChatMessage(BuildNoteList(player.GetComponent<KeyboardGuitar>().adjust, player.GetComponent<KeyboardGuitar>().start));
                }
            }
        }

        private bool LoadTune(string tuneName, out List<TuneNote> list)
        {
            try
            {
				list = Interface.GetMod().DataFileSystem.ReadObject<List<TuneNote>>("ms-" + tuneName);				
                return true;                
            }
            catch (Exception ex)
            {
				list = new List<TuneNote>();
                return false;
            }
        }
        void SaveTune(string playerName, string tuneName, ulong userID)
        {
            Interface.GetMod().DataFileSystem.WriteObject<List<TuneNote>>("ms-" + tuneName, tuneRecTemp[userID]);
            Log("Tune " + tuneName + " saved by " + playerName);
        }

        private string BuildNoteList(float adjust, float start)
        {
            string noteList = string.Empty;
            for (int i = 1; i < 9; i++)
            {
                noteList += string.Format("{0}: {1:0.00} ", i, (i-1) / adjust + start);
            }
            return noteList;
        }

        [ChatCommand("ms_tune")]
        void cmdTune(BasePlayer player, string cmd, string[] args)
        {
            if (player.net.connection.authLevel == 0) return;
            if (!checkComponent(player)) return;
            if (args.Length == 0) return;
            if (tuneDict.ContainsKey(args[0]))
            {
				if (!player.GetComponent<KeyboardGuitar>().playingTune)
				{
					player.ChatMessage("Playing: " + args[0]);
					playTune(player, args[0]);
				}
				else
				{
					player.ChatMessage("Already playing");
				}
            }
            else
                player.ChatMessage("Tune doesn't exists: " + args[0]);
        }
        
        [ChatCommand("ms_rec")]
        void cmdRec(BasePlayer player, string cmd, string[] args)
        {
            if (player.net.connection.authLevel == 0) return;
            if (!checkComponent(player)) return;
            if (args.Length == 0)
            {
                if (!player.GetComponent<KeyboardGuitar>().Recording)
                {
                    player.GetComponent<KeyboardGuitar>().Recording = true;
                    player.ChatMessage("Recording started...");
                }
                else
                {
                    player.GetComponent<KeyboardGuitar>().Recording = false;
                    if (tuneRecTemp.ContainsKey(player.userID))
                        tuneRecTemp[player.userID] = player.GetComponent<KeyboardGuitar>().recTune;
                    else
                        tuneRecTemp.Add(player.userID, player.GetComponent<KeyboardGuitar>().recTune);
                    player.GetComponent<KeyboardGuitar>().recTune = null;
                    //foreach (var item in playbackTune)
                    //{
                    //    player.ChatMessage(string.Format("NoteScale: {0:N2} - Delay: {1:N2}", item.NoteScale, item.Delay));
                    //}                    
                    player.ChatMessage("Recording stoped!");
                    player.ChatMessage(string.Format("Notes: {0} - Length: {1:N2}", tuneRecTemp[player.userID].Count, tuneRecTemp[player.userID].Sum(x => x.Delay)));
                }
            }
            else if (args.Length > 1 && !player.GetComponent<KeyboardGuitar>().Recording)
            {
                if (args[0] == "save")
                {
                    string tuneName = args[1];
                    if (!tuneRecTemp.ContainsKey(player.userID))
                    {
                        player.ChatMessage("Nothing to save!");
                    }
                    else
                    {
                        SaveTune(player.displayName, tuneName, player.userID);
                        if (tuneDict.ContainsKey(tuneName)) tuneDict.Remove(tuneName);
                        tuneDict.Add(tuneName, tuneRecTemp[player.userID]);
                        player.ChatMessage("Tune " + tuneName + " saved!");
                        cfgTunes.Add(tuneName);
                        Config["tunes"] = cfgTunes;
                        SaveConfig();
                        tuneRecTemp.Remove(player.userID);
                    }
                }
            }

        }
        void playTune(BasePlayer player, string tuneName)
        {
            player.GetComponent<KeyboardGuitar>().curTune = tuneDict[tuneName];
            player.GetComponent<KeyboardGuitar>().PlayTune();            
        }

        private bool checkComponent(BasePlayer player)
        {
            if (player.GetComponent<KeyboardGuitar>() == null)
            {
                player.ChatMessage("You have " + Title + " disabled!");
                return false;
            }
            return true;
        }

        List<object> getTune(string tuneName)
        {
            if (!tuneDict.ContainsKey(tuneName)) return null;
            var tunes = new List<object>();
            foreach (TuneNote note in tuneDict[tuneName])
            {
                var tunenote = new Dictionary<string, object>();
                tunenote.Add("NoteScale", note.NoteScale);
                tunenote.Add("Delay", note.Delay);
                tunenote.Add("Pluck", note.Pluck);
                tunes.Add(tunenote);
            }
            return tunes;
        }

        [ChatCommand("ms_adj")]
        void cmdMSAdjust(BasePlayer player, string cmd, string[] args)
        {
            if (player.net.connection.authLevel == 0) return;
            if (args.Length == 0) return;

            if (!checkComponent(player))
            {
                player.ChatMessage("Turn it ON, before using this");
            }
            else
            {
                if (player.GetComponent<KeyboardGuitar>().enabled)
                {
                    float adjust;
                    if (float.TryParse(args[0], out adjust))
                    {
                        player.GetComponent<KeyboardGuitar>().adjust = adjust;
                        player.ChatMessage(string.Format("Adjusted to: {0:N2}", adjust));
                    }
                    if (args.Length > 1)
                    {
                        float start;
                        if (float.TryParse(args[1], out start))
                        {
                            player.GetComponent<KeyboardGuitar>().start = start;
                            player.ChatMessage(string.Format("Start set to: {0:N2}", start));
                        }
                    }
                    player.ChatMessage(BuildNoteList(player.GetComponent<KeyboardGuitar>().adjust, player.GetComponent<KeyboardGuitar>().start));
                }
                else
                {
                    player.ChatMessage("Turn it ON, before using this");               
                }
            }
        }

        [ChatCommand("ms_list")]
        void cmdMSList(BasePlayer player, string cmd, string[] args)
        {
            if (player.net.connection.authLevel == 0) return;
            if (tuneDict.Count > 0)
            {
                player.ChatMessage("List of tunes avaliable");
                foreach (var tune in tuneDict)
                {
                    player.ChatMessage(string.Format("Name: {0}, Duration: {1:N2} seconds", tune.Key, tune.Value.Sum(x => x.Delay)));
                }
            }
            else
                player.ChatMessage("List of tunes is EMPTY");
        }

        [ChatCommand("ms_rel")]
        void cmdMSReload(BasePlayer player, string cmd, string[] args)
        {
            if (player.net.connection.authLevel == 0) return;
            if (args.Length == 0) return;
            List<TuneNote> tune;
            if (LoadTune(args[0], out tune))
            {
                if (tuneDict.ContainsKey(args[0]))
                {
                    tuneDict[args[0]] = tune;
                    player.ChatMessage("Reloaded: " + args[0]);
                }
                else
                {
                    tuneDict.Add(args[0], tune);
                    cfgTunes.Add(args[0]);
                    Config["tunes"] = cfgTunes;
                    SaveConfig();
                    player.ChatMessage("Tune: " + args[0] + " was added to playlist");
                }
            }
            else
            {
                player.ChatMessage("File not found!");
            }
        }

        [ChatCommand("ms_del")]
        void cmdMSDelete(BasePlayer player, string cmd, string[] args)
        {
            if (player.net.connection.authLevel == 0) return;
            if (args.Length == 0) return;
            List<TuneNote> tune;
            if (LoadTune(args[0], out tune))
            {
                if (tuneDict.ContainsKey(args[0]))
                {
                    cfgTunes.Remove(args[0]);
                    Config["tunes"] = cfgTunes;
                    SaveConfig();
                    tuneDict.Remove(args[0]);
                    player.ChatMessage("Removed from loadup: " + args[0] + " remove file in /data/ folder manually");
                }
                else
                {
                    player.ChatMessage("Tune wasn't added to loadup, but file exists!");
                }
            }
            else
            {
                player.ChatMessage("File not found!");
            }
        }

		[ChatCommand("msp")]
		void cmdMSPluck(BasePlayer player, string cmd, string[] args)
		{
			if (player.net.connection.authLevel == 0) return;
			if (args.Length == 0) return;
			if (!checkComponent(player))
			{
				player.ChatMessage("Turn it ON, before using this");
			}
			else
			{
				if (player.GetComponent<KeyboardGuitar>().enabled)
				{
					float scale;
					float repeat = 1;
					if (args.Length > 1)
						float.TryParse(args[1], out repeat);

                    if (float.TryParse(args[0], out scale))
					{
						List<TuneNote> repeatNote = new List<TuneNote>();
						for (int i = 0; i < repeat; i++)
						{
							repeatNote.Add(new TuneNote(scale, 2f));
                        }
						player.GetComponent<KeyboardGuitar>().curTune = repeatNote;
						if (!player.GetComponent<KeyboardGuitar>().playingTune)
						{
							player.GetComponent<KeyboardGuitar>().PlayTune();
							player.ChatMessage(string.Format("Note playing: {0:N2} - {1} times", scale, repeat));
						}
						else
							player.ChatMessage("Already playing");
					}					
				}
				else
				{
					player.ChatMessage("Turn it ON, before using this");
				}
			}
		}

		public class KeyboardGuitar : MonoBehaviour
        {
            private static float noteTime = 0.1f;

            public float adjust, start, NextTimeToPress, noteToPlay;
            private InputState input;
            public bool Recording = false;
            public BasePlayer owner;
            public List<TuneNote> recTune;
            public float nextNoteTime;
            //private TuneNote prevNote;
            Effect effectP = new Effect("fx/gestures/guitarpluck", new Vector3(0, 0, 0), Vector3.forward);
            Effect effectS = new Effect("fx/gestures/guitarstrum", new Vector3(0, 0, 0), Vector3.forward);
            void Awake()
            {
                owner = GetComponent<BasePlayer>();
                input = serverinput.GetValue(owner) as InputState;
                //enabled = false;
                adjust = 2.9f;
                NextTimeToPress = 0f;
                start = 0f;
            }
            void FixedUpdate()
            {
                float time = Time.realtimeSinceStartup;
                if (input.current.buttons != input.previous.buttons && input.current.buttons != 0 && NextTimeToPress < time)
                {
                    float num_shift = input.WasDown(BUTTON.SPRINT) ? 0.2f : 0;
                    bool Strum = input.WasDown(BUTTON.DUCK);
                        //fx/gestures/guitarstrum
                    NextTimeToPress = time + noteTime;
                    float num = (float)Math.Log((input.current.buttons / 262144), 2) / adjust + num_shift + start;
                    //owner.ChatMessage(num.ToString("N2"));
                    if (float.IsInfinity(num)) return;
                    if (num > 7) num = 7;
                    else if (num < -2) num = -2;
                    if (!Strum)
                    {
                        effectP.worldPos = transform.position;
                        effectP.origin = transform.position;
                        effectP.scale = num;
                        EffectNetwork.Send(effectP);
                    }
                    else
                    {
                        effectS.worldPos = transform.position;
                        effectS.origin = transform.position;
                        effectS.scale = num;
                        EffectNetwork.Send(effectS);
                    }
                    if (Recording)
                    {
                        if (recTune == null) recTune = new List<TuneNote>();
                        if (recTune.Count == 0)
                        {
                            recTune = new List<TuneNote>();
                            TuneNote curNote = new TuneNote(num, 0f, !Strum);
                            recTune.Add(curNote);
                            nextNoteTime = time;
                        }
                        else
                        {
                            recTune[recTune.Count - 1].Delay = time - nextNoteTime;
                            TuneNote curNote = new TuneNote(num, 0f, !Strum);
                            recTune.Add(curNote);
                            nextNoteTime = time;
                        }
                    }
                }   
            }

			public void PlayNote(float scale)
			{				
					effectP.worldPos = transform.position;
					effectP.origin = transform.position;
					effectP.scale = scale;
					EffectNetwork.Send(effectP);
			}

			public List<TuneNote> curTune;
			private Stack<TuneNote> tuneToPlay;
            public bool playingTune = false;
			private TuneNote nextNote;
			public void PlayTune()
			{
				tuneToPlay = new Stack<TuneNote>();
				foreach (var note in curTune.Reverse<TuneNote>())				
					tuneToPlay.Push(note);


				curTune = new List<TuneNote>();
				if (tuneToPlay.Count > 0)
				{
					nextNote = tuneToPlay.Pop();
					if (!playingTune)
						PlayTuneStack();
				}
            }
            private void PlayTuneStack()
            {
                if (!playingTune) playingTune = true;
                if (nextNote.Pluck)
                {
                    effectP.worldPos = transform.position;
                    effectP.origin = transform.position;
                    effectP.scale = nextNote.NoteScale;
                    EffectNetwork.Send(effectP);
                }
                else
                {
                    effectS.worldPos = transform.position;
                    effectS.origin = transform.position;
                    effectS.scale = nextNote.NoteScale;
                    EffectNetwork.Send(effectS);
                }
                if (tuneToPlay.Count > 0 && enabled)
                {					
					Invoke("PlayTuneStack", nextNote.Delay);
					nextNote = tuneToPlay.Pop();
				}
                else
                {
					if (!enabled)
						tuneToPlay = new Stack<TuneNote>();
					playingTune = false;
                }
            }
        }
        public class TuneNote
        {
            public float NoteScale, Delay;
            public bool Pluck;
            public TuneNote(float note, float delay, bool pluck = true)
            {
                NoteScale = note;
                Delay = delay;
                Pluck = pluck;
            }
        }
    }
}


// --- End of file: Minstrel.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ProtocolKickInfo.cs ---
// --- Original Local Path: ProtocolKickInfo.cs ---

using System;
using System.Collections.Generic;
using Network;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("ProtocolKickInfo", "Fujikura", "1.0.2", ResourceId = 2041)]
    class ProtocolKickInfo : RustPlugin
    {
		
		private int serverProtocol;
		
		Dictionary <ulong, int> antiSpam = new Dictionary <ulong, int>();
		Dictionary <ulong, int> quitTimer = new Dictionary <ulong, int>();

		void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			                      {
									{"msgServerWrong", "This server is not updated yet. Come back later"},
									{"msgClientWrong", "Your Rust client needs to be updated. Close your client."},
								  },this);
		}
		
		void Init()
		{
			LoadDefaultMessages();
			serverProtocol = Rust.Protocol.network;
			antiSpam.Clear();
			quitTimer.Clear();
		}
				
		void OnClientAuth(Connection connection)
		{
			if (connection.protocol > serverProtocol)
			{
				if (!antiSpam.ContainsKey(connection.userid))
					antiSpam.Add(connection.userid, -1);
				if (!quitTimer.ContainsKey(connection.userid))
					quitTimer.Add(connection.userid, 0);			
				if (quitTimer[connection.userid] == 2 )
				{
					ConsoleNetwork.SendClientCommand(connection, "global.quit", new object[] {} );
					quitTimer[connection.userid] = 0;
					return;
				}
				if (antiSpam[connection.userid] != DateTime.Now.Minute)
				{
					quitTimer[connection.userid] = 0;
					var player = rust.FindPlayerById(connection.userid);
					if (player != null)
						Puts($"Kicked '{player.displayName}' with client protocol '{connection.protocol}' | server has '{serverProtocol}'");
					else
						Puts($"Kicked '{connection}' with client protocol '{connection.protocol}' | server has '{serverProtocol}'");
					antiSpam[connection.userid] = DateTime.Now.Minute;
				}
				else
					quitTimer[connection.userid]++;
				Network.Net.sv.Kick(connection, lang.GetMessage("msgServerWrong", this, connection.userid.ToString()));
				connection.protocol = (uint)serverProtocol;
				NextTick(() => ServerMgr.Instance.connectionQueue.RemoveConnection(connection));
			}
			if (connection.protocol < serverProtocol)
			{
				if (!antiSpam.ContainsKey(connection.userid))
					antiSpam.Add(connection.userid, -1);
				if (!quitTimer.ContainsKey(connection.userid))
					quitTimer.Add(connection.userid, 0);			
				if (quitTimer[connection.userid] == 2 )
				{
					ConsoleNetwork.SendClientCommand(connection, "global.quit", new object[] {} );
					quitTimer[connection.userid] = 0;
					return;
				}
				if (antiSpam[connection.userid] != DateTime.Now.Minute)
				{
					quitTimer[connection.userid] = 0;
					var player = rust.FindPlayerById(connection.userid);
					if (player != null)
						Puts($"Kicked '{player.displayName}' with client protocol '{connection.protocol}' | server has '{serverProtocol}'");
					else
						Puts($"Kicked '{connection}' with client protocol '{connection.protocol}' | server has '{serverProtocol}'");
					antiSpam[connection.userid] = DateTime.Now.Minute;
				}
				else
					quitTimer[connection.userid]++;
				Network.Net.sv.Kick(connection, lang.GetMessage("msgClientWrong", this, connection.userid.ToString()));
				connection.protocol = (uint)serverProtocol;
				NextTick(() => ServerMgr.Instance.connectionQueue.RemoveConnection(connection));
			}
		}
	}
}

// --- End of file: ProtocolKickInfo.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HCraft.cs ---
// --- Original Local Path: HCraft.cs ---

﻿//---------------------Используем исходники----------------------
using UnityEngine;
using Rust;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using System;
using System.Reflection;
using Oxide.Core;
using System.Linq;
using Oxide.Game.Rust.Cui;
//---------------------------------------------------------------
namespace Oxide.Plugins
{
    [Info("HCraft", "Hougan", "1.0", ResourceId = 1855)]
    public class HCraft : RustPlugin
    {
        Dictionary<ulong, int> Craft = new Dictionary<ulong, int>();
        Dictionary<ulong, bool> Pay = new Dictionary<ulong, bool>();
        void Loaded()
        {
            permission.RegisterPermission("HCraft.User", this);
            foreach(var tried in BasePlayer.activePlayerList)
            {
                Pay.Add(tried.userID, false);
                Craft.Add(tried.userID, 0);
            }
        }
        void OnItemCraft(ItemCraftTask task, BasePlayer crafter)
        {
            task.cancelled = true;
            Craft[crafter.userID] = task.amount;
            while (Craft[crafter.userID]!=0)
            {
                if(30 - crafter.inventory.containerMain.itemList.Count - crafter.inventory.containerBelt.itemList.Count <= 0)
                {
                    var i = task.takenItems.Count;
                    if (Pay[crafter.userID] == true)
                    {
                        SendReply(crafter, "[<color=#DC143C>RM</color>] Ваш инвентарь <color=#DC143C>переполнен</color>!\n<size=12><color=#D3D3D3>(Ресурсы <color=#DC143C>не возвращены</color>, вы были <color=#DC143C>предупреждены</color>!)</color></size>");
                        Craft[crafter.userID]=0;
                        return;
                    }
                    for (int b = 0; b<i; b++)
                        ItemManager.CreateByItemID(Convert.ToInt32(task.takenItems[b].info.itemid), task.takenItems[b].amount/task.amount* Craft[crafter.userID]).Drop(crafter.transform.position, Vector3.zero);
                    SendReply(crafter, "[<color=#DC143C>RM</color>] Ваш инвентарь <color=#DC143C>переполнен</color>!\n<size=12><color=#D3D3D3>(В течении <color=#DC143C>5-и</color> секунд ресурсы возвращаться <color=#DC143C>не будут</color>!)</color></size>");
                    Pay[crafter.userID] = true;
                    Craft[crafter.userID] = 0;
                    timer.Once(5, () =>
                    {
                        Pay[crafter.userID] = false;
                    });
                }
                else
                {
                    crafter.inventory.GiveItem(ItemManager.CreateByItemID(task.blueprint.targetItem.itemid, task.blueprint.amountToCreate));
                    Craft[crafter.userID]--;
                }
            }
            Craft[crafter.userID] = 0;
        }
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            Craft.Remove(player.userID);
            Pay.Remove(player.userID);
        }
    }
}


// --- End of file: HCraft.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NoAnimals.cs ---
// --- Original Local Path: NoAnimals.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using Random = UnityEngine.Random;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
  [Info("NoAnimals", "Phraxxer", "0.0.1", ResourceId = 1337)]
  [Description("This plugin removes all animals from your server.")]
  class NoAnimals : RustPlugin
  {
    private bool serverInit = false;
    private List<string> animal_list = new List<string>() { "bear", "stag", "chicken", "boar", "horse", "wolf" };
	
    private bool checkEnt(BaseNetworkable entity)
    {
        if (entity.isActiveAndEnabled && animal_list.Contains(entity.LookupPrefab().name))
        {
            entity.Kill();
            return true;
        }
        return false;
    }
		
    void OnServerInitialized()
    {
		var animals = Resources.FindObjectsOfTypeAll<BaseNPC>();
		int count_animal = 0;
		
        foreach (var b in animals)
        {
            if (checkEnt(b))
                count_animal++;
        }
		
		Puts($"Deleted {count_animal} animals on server start.");
        serverInit = true;
    }

    void OnEntitySpawned(BaseNetworkable entity)
    {
        if (!serverInit)
            return;
        if(checkEnt(entity))
            return;
    }
  }
}


// --- End of file: NoAnimals.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RFTeleports.cs ---
// --- Original Local Path: RFTeleports.cs ---

﻿﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UnityEngine;
 using VLB;

 namespace Oxide.Plugins
{
    [Info("RFTeleports", "LAGZYA", "1.0.7")]
    public class RFTeleports : RustPlugin
    {
        #region Cfg
        private ConfigData cfg { get; set; }  
        private class ConfigData
        {
            [JsonProperty("Разрешить телепорт c коптера?(true = да)")] public bool blockcopter = true;
            [JsonProperty("Разрешить телепорт c лошади?(true = да)")] public bool blockhorse = true;
            [JsonProperty("Разрешить телепорт c каргошипа?(true = да)")] public bool blockcargo = true;
            [JsonProperty("Разрешить телепорт c воздушного шара?(true = да)")] public bool blockhot = true;
            [JsonProperty("Разрешить телепорт во время плавания?(true = да)")] public bool blockswim = true;
            [JsonProperty("Разрешить телепорт c кровотечением?(true = да)")] public bool blockblood = true;
            [JsonProperty("Кол-во кровотечения для блока")] public int blood = 25;
            [JsonProperty("Разрешить телепорт если жарко?(true = да)")] public bool blocktemp = true;
            [JsonProperty("Кол-во тепла для блока")] public int temp = 15;
            [JsonProperty("Разрешить телепорт если холодно?(true = да)")]public bool blockсcold = true;
            [JsonProperty("Кол-во холода для блока")] public int cold = 25;
            [JsonProperty("Разрешить телепорт если радиация?(true = да)")]public bool blockrad = true;
            [JsonProperty("Кол-во радиации для блока")] public int rad = 25;
            [JsonProperty("Разрешить телепорт в запрете строительства?(true = да)")] public bool blockbuild = true;
            [JsonProperty("Скорость телепорта на спальнике(Чем больше число тем быстрее телепортация)")] public int sleepbeg = 1;
            [JsonProperty("Скорость телепорта на кровате(Чем больше число тем быстрее телепортация))")] public int bad = 2;
            [JsonProperty("Время перезарядки на спальнике(Секунды)")] public int sleepcd = 300;
            [JsonProperty("Время перезарядки на кровате(Секунды)")] public int badcd = 90;
            [JsonProperty("Включить сетхом (true = да)")] public bool hometeleport = true;
            [JsonProperty("Включить телепорт к игрокам (true = да)")] public bool playerteleport = true;

            [JsonProperty("Привелегия: кол-во домов")]
            public Dictionary<string, int> permHomeLimit;

            [JsonProperty("Привелегия: Ускорение телепорта(Чем больше число тем быстрее телепортация)")]
            public Dictionary<string, int> permTPRTIME;
            
            [JsonProperty("Привелегия: время перезарядки тп к игроку")]
            public Dictionary<string, int> permTPRCD;
            public static ConfigData GetNewConf()
            {
                var newConfig = new ConfigData();
                newConfig.permTPRCD =new Dictionary<string, int>()
                {
                    ["rfteleports.default"] = 1,
                    ["rfteleports.vip"] = 3,
                };
                newConfig.permHomeLimit = new Dictionary<string, int>()
                {
                    ["rfteleports.default"] = 300,
                    ["rfteleports.vip"] = 150,
                }; 
                newConfig.permTPRTIME = new Dictionary<string, int>()
                {
                    ["rfteleports.default"] = 1,
                    ["rfteleports.vip"] = 2,
                }; 
                return newConfig;
            }
        } 

        protected override void LoadDefaultConfig()
        {
            cfg = ConfigData.GetNewConf();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(cfg);
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                cfg = Config.ReadObject<ConfigData>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }
        
        int GetHomeLimit(ulong uid)
        {
            int max = 0;
            foreach (var privilege in cfg.permHomeLimit) if (permission.UserHasPermission(uid.ToString(), privilege.Key)) max = Mathf.Max(max, privilege.Value);
            return max;
        }

        #endregion

        private Dictionary<ulong, PlayerData> _homeList = new Dictionary<ulong, PlayerData>();

        void OnServerSave()
        { 
            Interface.Oxide.DataFileSystem.WriteObject("RFTeleport", _homeList);
            Puts("Произошло сохранение даты!");
        }
        private void OnServerInitialized()
        {
            _homeList = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, PlayerData>>("RFTeleport");
            foreach (var tt in cfg.permHomeLimit)
            {
                if(!permission.PermissionExists(tt.Key))
                    permission.RegisterPermission(tt.Key, this);
            }
            foreach (var tt in cfg.permTPRCD)
            {
                if(!permission.PermissionExists(tt.Key))
                    permission.RegisterPermission(tt.Key, this);
            }
            permission.RegisterPermission("rfteleports.admin", this);
            foreach (var tt in cfg.permTPRTIME)
            {
                if(!permission.PermissionExists(tt.Key))
                    permission.RegisterPermission(tt.Key, this);
            }
            foreach (var basePlayer in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(basePlayer);
            }
        } 

        void OnPlayerConnected(BasePlayer player)
        {
            if(_homeList.ContainsKey(player.userID)) return;
            _homeList.Add(player.userID, new PlayerData()
            {
                _homeList = new Dictionary<int, Homes>(),
                HOMECD = CurrentTime(),
                TPRCD = CurrentTime(),
                NickName = player.displayName,
            });
        }
        void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            PlayerData f;
            if (item.info.shortname != "rf.detonator") return;
            var player = container.playerOwner;
            if (player != null && container == player.inventory.containerMain || player != null && container == player.inventory.containerBelt)
            { 
                if (!_homeList.TryGetValue(player.userID, out f)) return;
                var racia = item.GetHeldEntity().GetComponent<Detonator>();
                if (f._homeList.Count <= 0 || racia.frequency != 0) return;
                racia.frequency = f._homeList.ToList()[0].Key;
                player.SendNetworkUpdate();
            }
        }
        private void Unload()
        {
            Interface.Oxide.DataFileSystem.WriteObject("RFTeleport", _homeList);
            foreach (var basePlayer in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(basePlayer, AcceptLayer);
            }
            foreach (var rfTeleport in UnityEngine.Object.FindObjectsOfType<RFTeleport>())
            {
                rfTeleport.OnDestroy();
            }
            foreach (var rfTeleport in UnityEngine.Object.FindObjectsOfType<RFPager>())
            {
                rfTeleport.OnDestroy();
            }
        }

        class PlayerData
        {
            public string NickName;
            public double HOMECD;
            
            public double TPRCD;
            public Dictionary<int, Homes> _homeList = new Dictionary<int, Homes>();
            public double IsTPR()
            {
                return Math.Max(TPRCD - CurrentTime(), 0);
            }
            public double IsHome()
            {
                return Math.Max(HOMECD - CurrentTime(), 0);
            }
        }

        class Homes
        {
            public Vector3 position;
            public string ShortName;
            public uint netId;
        }

        public static RFTeleports ins;

        private void OnActiveItemChanged(BasePlayer player, Item oldItem, Item newItem)
        {
            if (player == null || newItem == null) return;
            if (newItem.info.shortname == "rf.detonator") player.gameObject.GetOrAddComponent<RFTeleport>();
            if(newItem.info.shortname == "rf_pager" && cfg.playerteleport) player.gameObject.GetOrAddComponent<RFPager>();
        }
        private string AcceptLayer = "AcceptLayerSH";
        void AcceptHouse(BasePlayer player, uint numid )
        { 
            CuiHelper.DestroyUi(player, AcceptLayer);
            var cont = new CuiElementContainer();
            cont.Add(new CuiPanel()
            {
                Image =
                {
                    Color = "0.25 0.25 0.25 0.56", FadeIn = 1f,
                    Sprite = "assets/content/ui/ui.background.transparent.linearltr.tga"
                },
                RectTransform =
                {
                    AnchorMin = "0 0.5", 
                    AnchorMax = "0 0.5", 
                    OffsetMin = "0 -25", 
                    OffsetMax = "250 25"
                }
            }, "Overlay", AcceptLayer);
            cont.Add(new CuiButton()
            {
                Text =
                {
                    FadeIn = 1f, Text = "<size=14>Телепортация</size>\nЧтобы сохранить точку телепорта на этом спальнике/кровати, <color=#FFFF00><size=16>нажмите сюда</size></color>.", Align = TextAnchor.MiddleLeft, FontSize = 12
                },
                RectTransform =
                {
                    AnchorMin = "0.04 0", AnchorMax = "2 1.3"
                },
                Button =
                {
                    Color = "0 0 0 0",
                    Command = $"rfteleport sethome {numid}",
                    Close = AcceptLayer
                }
            }, AcceptLayer);
            CuiHelper.AddUi(player, cont);
            timer.Once(10f, () => CuiHelper.DestroyUi(player, AcceptLayer));
        }
        void HomeGenerate(uint nument, BasePlayer player)
        {
            if(!cfg.hometeleport) return;
            var entity = BaseNetworkable.serverEntities.Find(nument) as SleepingBag;
            if(entity == null) return;
            PlayerData f;
            int number = Core.Random.Range(1, 9999);
            if (_homeList.TryGetValue(player.userID, out f))
            {
                if (f._homeList.ContainsKey(number))
                {
                    HomeGenerate(entity.net.ID, player);
                    return;
                }

                f._homeList.Add(number, new Homes()
                {
                    ShortName = entity.ShortPrefabName,
                    position = entity.transform.position + Vector3.up,
                    netId = entity.net.ID
                });
            }

            entity.niceName = $"HOME: {number}";
            entity.SendNetworkUpdate();
            ReplySend(player, "Вы поставили спальник или кровать. Ваш номер для телепорта через рацию: " + number);
            Effect x = new Effect("assets/prefabs/misc/easter/painted eggs/effects/gold_open.prefab", player, 0, new Vector3(), new Vector3());
            EffectNetwork.Send(x, player.Connection);
        }

        void OnEntitySpawned(SleepingBag entity)
        {
            if(!cfg.hometeleport) return;
            PlayerData playerData;
            var player = BasePlayer.FindByID(entity.OwnerID);
            if (player == null) return;
            if(player.IsBuildingAuthed())
                if(_homeList.TryGetValue(player.userID, out playerData))
                {
                    if (GetHomeLimit(player.userID) > playerData._homeList.Count)
                        AcceptHouse(player, entity.net.ID);
                }
                else
                {
                    AcceptHouse(player, entity.net.ID);
                }
        }
        void Init()
        {
            ins = this;
        }

        [ConsoleCommand("rfteleport")]
        void RFCommand(ConsoleSystem.Arg arg)
        {
            PlayerData playerData;
            var player = arg.Player();
            switch (arg.Args[0])
            {
                case "sethome": 
                    HomeGenerate(uint.Parse(arg.Args[1]), player);
                    CuiHelper.DestroyUi(player, AcceptLayer);
                    break;
            }
        }
        private static string Blur = "assets/content/ui/uibackgroundblur.mat";
        Dictionary<ulong, int> _pagerList = new Dictionary<ulong, int>();
        class RFPager : MonoBehaviour
        {
            private BasePlayer player;
            private static PagerEntity pager;
            private int num;
            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                var ent = BaseNetworkable.serverEntities.Find(player.GetActiveItem().instanceData.subEntity);
                if(player.GetActiveItem() == null || ent == null)
                {
                    Destroy(this);
                    return;
                } 
                 
                pager = ent.GetComponent<PagerEntity>();
                if (ins._pagerList.ContainsValue(pager.GetFrequency()))
                {
                    ins.ReplySend(player, "Введите другую частоту!");
                    Destroy(this);
                    return;
                }
                ins._pagerList.Add(player.userID, pager.GetFrequency());
                num = pager.GetFrequency();
                ins.ReplySend(player, "Вы взяли пейджер.Сообщите свою частоту человеку,чтобы тот мог телепортироваться!");
            }

            private void Update()
            {
                if(player.GetActiveItem() == null ||player.GetActiveItem().info.itemid != -566907190)
                {
                      OnDestroy();
                      return;
                }
                if (ins._pagerList.ContainsKey(player.userID) && ins._pagerList[player.userID] != num)
                    ins._pagerList[player.userID] = num;

            }

            public void OnDestroy()
            {
                ins._pagerList.Remove(player.userID);
                Destroy(this);
            } 
        }
        public class RFTeleport : MonoBehaviour
        {
            private BasePlayer playerTarget;
            private Item rftrans;
            private Detonator racia;
            private BasePlayer player;
            private double procent = 0;
            private PlayerData playerData;
            private Dictionary<int, Homes> homes;
            private string color = ins.HexToRustFormat("#2df79b8A");
            private int tprtime;

            private string text = "stop";

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                rftrans = player.GetActiveItem();
                racia = rftrans.GetHeldEntity().GetComponent<Detonator>();
                if (!ins._homeList.TryGetValue(player.userID, out playerData)) OnDestroy();
                else homes = playerData._homeList;
                tprtime = GetTPRTime(player.userID);
            } 

            public void OnDestroy()
            {
                CuiHelper.DestroyUi(player, "ProgressBar");
                Destroy(this);
            }

            private void StartUI()
            {
                CuiHelper.DestroyUi(player, "ProgressBar");
                var cont = new CuiElementContainer();
                cont.Add(new CuiPanel()
                {
                    Image =
                    {
                        Color = "0.25 0.25 0.25 0.45"
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5",
                        OffsetMin = "-50 -275", OffsetMax = "50 -260"
                    }
                }, "Hud", "ProgressBar");
                if (playerTarget != null)
                {
                    cont.Add(new CuiElement()
                    {
                        Parent = "ProgressBar",
                        Components =
                        {
                            new CuiTextComponent()
                            {
                                Text = $"ТЕЛЕПОРТАЦИЯ {playerTarget.displayName.ToUpper()}", Align = TextAnchor.MiddleCenter, FontSize = 9,
                                Font = "robotocondensed-regular.ttf"
                            },
                            new CuiRectTransformComponent()
                            {
                                AnchorMin = "0 0", AnchorMax = $"1 1"
                            }
                        }
                    });  
                }
                else
                {
                    cont.Add(new CuiElement()
                    {
                        Parent = "ProgressBar",
                        Components =
                        {
                            new CuiTextComponent()
                            {
                                Text = $"ТЕЛЕПОРТАЦИЯ", Align = TextAnchor.MiddleCenter, FontSize = 9,
                                Font = "robotocondensed-regular.ttf"
                            },
                            new CuiRectTransformComponent()
                            {
                                AnchorMin = "0 0", AnchorMax = $"1 1"
                            }
                        }
                    }); 
                }

                CuiHelper.AddUi(player, cont);
            }
            private void DrawUi(int time, int max)
            { 
                CuiHelper.DestroyUi(player, "Progress");
                CuiHelper.DestroyUi(player, "time");
                var cont = new CuiElementContainer();
                cont.Add(new CuiElement()
                {
                    FadeOut = 0.05f,
                    Parent = "ProgressBar",
                    Name = "Progress",
                    Components =
                    {
                        new CuiImageComponent()
                        {
                            Color = color
                        },
                        new CuiRectTransformComponent()
                        {
                            AnchorMin = "0 0", AnchorMax = $"{Math.Min(0.05 + ((float) time / max), 0.99)} 0.99"
                        }
                    }
                });
                cont.Add(new CuiElement()
                {
                    Parent = "ProgressBar",
                    Name = "time",
                    Components =
                    {
                        new CuiTextComponent()
                        {
                            Text = $"{time}%", Align = TextAnchor.MiddleCenter, FontSize = 8,
                            Font = "robotocondensed-regular.ttf"
                        },
                        new CuiRectTransformComponent()
                        {
                            AnchorMin = "0 1", AnchorMax = $"1 2"
                        }
                    }
                });
                CuiHelper.AddUi(player, cont);
            }

            private void DrawUiCD(int time, int max)
            {
                
                CuiHelper.DestroyUi(player, "Progress");
                CuiHelper.DestroyUi(player, "time");
                var cont = new CuiElementContainer();
                cont.Add(new CuiElement()
                {
                    FadeOut = 0.05f,
                    Parent = "ProgressBar",
                    Name = "Progress",
                    Components =
                    {
                        new CuiImageComponent()
                        {
                            Color = color
                        },
                        new CuiRectTransformComponent()
                        {
                            AnchorMin = "0 0", AnchorMax = $"{Math.Min(0.05 + ((float) time / max), 0.99)} 0.99"
                        }
                    }
                });
                cont.Add(new CuiElement()
                {
                    Parent = "ProgressBar",
                    Name = "time",
                    Components =
                    {
                        new CuiTextComponent()
                        {
                            Text = $"{time} сек", Align = TextAnchor.MiddleCenter, FontSize = 8,
                            Font = "robotocondensed-regular.ttf"
                        },
                        new CuiRectTransformComponent()
                        {
                            AnchorMin = "0 1", AnchorMax = $"1 2"
                        }
                    } 
                });
                CuiHelper.AddUi(player, cont);
            }

            bool CheckPlayer(BasePlayer basePlayer)
            {
                if (basePlayer.GetMounted() != null)
                {
                    if (basePlayer.GetMounted().ShortPrefabName == "minihelipassenger" && ins.cfg.blockcopter || basePlayer.GetMounted().ShortPrefabName == "saddletest" && ins.cfg.blockhorse|| basePlayer.GetMounted().ShortPrefabName == "transporthelicopilot" && ins.cfg.blockcopter)
                        return false;
                } 
                
                if (basePlayer.GetComponentInParent<ScrapTransportHelicopter>() && ins.cfg.blockcopter)
                    return false;
                if (basePlayer.GetComponentInParent<CargoShip>() && ins.cfg.blockcargo)
                    return false;
                if (basePlayer.GetComponentInParent<HotAirBalloon>() && ins.cfg.blockhot)
                    return false;
                if (basePlayer.IsBuildingBlocked() && ins.cfg.blockbuild)
                    return false;
                if (basePlayer.metabolism.temperature.value <=  -ins.cfg.cold && ins.cfg.blockсcold)
                    return false;
                if (basePlayer.metabolism.heartrate.value >=  ins.cfg.temp && ins.cfg.blocktemp)
                    return false;
                if (basePlayer.metabolism.radiation_poison.value >=  ins.cfg.rad && ins.cfg.blockrad)
                    return false;
                if (basePlayer.metabolism.bleeding.value >= ins.cfg.blood && ins.cfg.blockblood)
                    return false;
                if (basePlayer.IsSwimming() && ins.cfg.blockswim)
                    return false;
                if (basePlayer.IsWounded())
                    return false;
                return true;
            }
            int GetTprCD(ulong uid)
            {
                int min = 300;
                foreach (var privilege in ins.cfg.permTPRCD)
                {
                    if (ins.permission.UserHasPermission(uid.ToString(), privilege.Key))
                        min = Mathf.Min(min, privilege.Value);
                }
                return min;
            }
            int GetTPRTime(ulong uid)
            {
                int max = 1;
                foreach (var privilege in ins.cfg.permTPRTIME) if (ins.permission.UserHasPermission(uid.ToString(), privilege.Key)) max = Mathf.Max(max, privilege.Value);
                return max;
            }
            private void Update()
            {
                if (player.GetActiveItem() == null)
                {
                    OnDestroy();
                    return;
                } 
                if (player.GetActiveItem().info.shortname != "rf.detonator")
                {
                    OnDestroy();
                    return;
                }
                if(ins._pagerList.ContainsValue(racia.frequency))
                {
                    var getPlayer = ins._pagerList.First(p => p.Value == racia.frequency).Key;
                    playerTarget = BasePlayer.FindByID(getPlayer);
                } 
                else
                {
                    playerTarget = null;
                }

                Homes f;
                InputState input = player.serverInput;

                if (text == "start")
                { 
                    if (!CheckPlayer(player))
                    { 
                        if (procent >= 100) procent = 0;
                        procent += 0.02;
                        color = ins.HexToRustFormat("#ff665e8A");
                        DrawUi((int) procent, 100); 
                    }
                    else if (homes.TryGetValue(racia.frequency, out f))
                    {
                        if (playerData.IsHome() > 0)
                        {
                            color = ins.HexToRustFormat("#ff665e8A");
                            procent += 0.02;
                            DrawUiCD((int) playerData.IsHome(), 1);
                        }
                        else
                        { 
                            color = ins.HexToRustFormat("#2df79b8A");
                            if(f.ShortName == "sleepingbag_leather_deployed") procent += ins.cfg.sleepbeg * 0.02;
                            else procent += ins.cfg.bad * 0.02;
                            DrawUi((int) procent, 100);
                            if (procent >= 100)
                            {
                        
                                procent = 0;
                                RaycastHit hit;

                                if (!Physics.Linecast(f.position, f.position + Vector3.down, out hit))
                                {
                                    ins.ReplySend(player, "Сетхом разуршен.");
                                    playerData._homeList.Remove(racia.frequency);
                                    return;
                                }
                                if (hit.GetEntity() == null)
                                {
                                    ins.ReplySend(player, "Сетхом разуршен.");
                                    playerData._homeList.Remove(racia.frequency);
                                    return;
                                }
                                else if (hit.GetEntity().net.ID == f.netId)
                                {
                                    if (!CheckPlayer(player))
                                        return;
                                    Teleport(player, f.position);
                                    if(f.ShortName == "bed_deployed") playerData.HOMECD = CurrentTime() + ins.cfg.badcd;
                                    else playerData.HOMECD = CurrentTime() + ins.cfg.sleepcd;
                                    OnDestroy();
                                    return;
                                }
                                else
                                {
                                    ins.ReplySend(player, "Сетхом разуршен.");
                                    playerData._homeList.Remove(racia.frequency);
                                    
                                    return;
                                }
                            } 
                        }
                    }
                    else if (ins._pagerList.ContainsValue(racia.frequency))
                    {
                        if(playerTarget == null) return;
                        if (playerData.IsTPR() > 0)
                        {
                            color = ins.HexToRustFormat("#ff665e8A");
                            DrawUiCD((int) playerData.IsTPR(), 1);
                        }
                        else if (procent >= 100) 
                        {
                            Teleport(player, playerTarget.transform.position);
                            playerData.TPRCD = CurrentTime() + GetTprCD(player.userID);
                            procent = 0;
                            ins.ReplySend(playerTarget, $"К вам успешно телепортировался <color=#2df79b>{player.displayName}</color>");
                            ins.ReplySend(player, $"Вы успешно телепортировались к <color=#2df79b>{playerTarget.displayName}</color>");
                            OnDestroy();
                        } 
                        else
                        {  
                            if(!CheckPlayer(playerTarget))
                            {
                                if (procent >= 100) procent = 0;
                                procent += 0.1 * tprtime;
                                color = ins.HexToRustFormat("#ff665e8A");
                                DrawUi((int) procent, 100);
                                return;
                            }
                            procent += 0.1 * tprtime;
                            color = ins.HexToRustFormat("#2df79b8A");
                            DrawUi((int) procent, 100);
                        }
                    } 
                    else if(!homes.TryGetValue(racia.frequency, out f))
                    {
                        if (procent >= 100) procent = 0;
                        procent += 0.1;
                        color = ins.HexToRustFormat("#ff665e8A");
                        DrawUi((int) procent, 100); 
                    }

                }
                if (input.WasDown(BUTTON.FIRE_PRIMARY) && text == "stop")
                {
                    StartUI();
                    text = "start";
                }
                if (!input.IsDown(BUTTON.FIRE_PRIMARY) && text == "start")
                {
                    text = "stop";
                    procent = 0;
                    CuiHelper.DestroyUi(player, "ProgressBar");
                }
            }

            private void Teleport(BasePlayer player, Vector3 pos)
            {
                if (player == null || !player.IsConnected || player.IsDead()) return;
                player.StartSleeping();
                player.MovePosition(pos);
                player.UpdateNetworkGroup();
                player.SendNetworkUpdateImmediate(false);
                if (player.net?.connection != null) player.ClientRPCPlayer(null, player, "ForcePositionTo", pos);
                if (player.net?.connection != null)
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
                if (player.net?.connection == null) return;
                try
                {
                    player.ClearEntityQueue(null);
                }
                catch
                {
                    // ignored
                }

                player.SendFullSnapshot();
                player.SetParent(null, true, true);
                player.SendNetworkUpdate();
            }
        }

        #region Commands

        [ChatCommand("sethome")] 
        void SetHome(BasePlayer player)
        {
            if(!cfg.hometeleport) return;
            RaycastHit hit;
            PlayerData playerData;
            if(!player.IsBuildingAuthed())
            {
                ReplySend(player, "Запрещенная территория для установки дома!");
                return;
            }
            if (!Physics.Linecast(player.transform.position, player.transform.position + Vector3.down, out hit))
                ReplySend(player, "Встаньте на кровать или спальник!");
            else if (hit.GetEntity() == null)
                ReplySend(player, "Встаньте на кровать или спальник!");
            else if (hit.GetEntity().ShortPrefabName != "sleepingbag_leather_deployed" && hit.GetEntity().ShortPrefabName !="bed_deployed")
                ReplySend(player, "Встаньте на кровать или спальник!");
            else if(hit.GetEntity().OwnerID != player.userID)
                ReplySend(player, "Это не ваш спальник или кровать!");
            else 
            if(_homeList.TryGetValue(player.userID, out playerData))
            {
                if (playerData._homeList.Count >= 1 && playerData._homeList.First(p => p.Value.netId == hit.GetEntity().net.ID).Value != null) return;
                if (GetHomeLimit(player.userID) > playerData._homeList.Count)
                    HomeGenerate(hit.GetEntity().net.ID, player);
                else ReplySend(player, "У вас максимальное кол-во домов.");
            }
            else
            {
                HomeGenerate(hit.GetEntity().net.ID, player);
            }
        }
        private void Teleport(BasePlayer player, Vector3 pos)
        {
            if (player == null || !player.IsConnected || player.IsDead()) return;
            player.StartSleeping();
            player.MovePosition(pos);
            player.UpdateNetworkGroup();
            player.SendNetworkUpdateImmediate(false);
            if (player.net?.connection != null) player.ClientRPCPlayer(null, player, "ForcePositionTo", pos);
            if (player.net?.connection != null)
                player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
            if (player.net?.connection == null) return;
            try
            {
                player.ClearEntityQueue(null);
            }
            catch
            {
            }

            player.SendFullSnapshot();
            player.SetParent(null, true, true);
            player.SendNetworkUpdate();
        }
        [ChatCommand("tp")]
        void AdminTeleport(BasePlayer p, string c, string[] a)
        {
            if(!permission.UserHasPermission(p.UserIDString, "rfteleports.admin")) return;
            
            var targetPlayer = BasePlayer.Find(string.Join(" ", a.ToArray()));
            if (targetPlayer == null) 
            {
                ReplySend(p, "Игрок не найден"); 
                return;
            }
            Teleport(p, targetPlayer.transform.position + Vector3.up);
        }
        [ChatCommand("tpr")]
        void Tpr(BasePlayer p, string c, string[] a)
        {
            ReplySend(p, "Прочитайте о нашей системе телепортации в информации о сервере.");
        }
        [ChatCommand("tpa")]
        void Tpa(BasePlayer p, string c, string[] a)
        {
            ReplySend(p, "Прочитайте о нашей системе телепортации в информации о сервере.");
        }
        [ChatCommand("tpc")]
        void Tpc(BasePlayer p, string c, string[] a)
        {
            ReplySend(p, "Прочитайте о нашей системе телепортации в информации о сервере.");
        }
        [ChatCommand("home")]
        void Home(BasePlayer p, string c, string[] a)
        {
            if(!cfg.hometeleport) return;
            PlayerData playerData;
            Homes home;
            if(a.Length < 1) return;
            switch (a[0])
            {
                case "list":
                    if(!_homeList.TryGetValue(p.userID, out playerData)) return;
                    var text = "Список Домов:\n";
                    foreach (var HomeList in playerData._homeList)
                        text += $"Номер: <color=#E10394>{HomeList.Key}</color> Квадрат: <color=#00ffcc>{getGrid(HomeList.Value.position)}</color>\n";
                    ReplySend(p, text);
                    PrintToConsole(p, text);
                    break;
                case "remove":
                    if(!_homeList.TryGetValue(p.userID, out playerData)) return;
                    int num;
                    if (a.Length < 2) 
                    {
                        ReplySend(p, "Введите номер дома. Посмотреть можно здесь /home list");
                        PrintToConsole(p, "Введите номер дома. Посмотреть можно здесь /home list");
                        return;
                    }
                    if (!int.TryParse(a[1], out num))
                    {
                        ReplySend(p, "Введите номер дома. Посмотреть можно здесь /home list");
                        PrintToConsole(p, "Введите номер дома. Посмотреть можно здесь /home list");
                        return;
                    }

                    if(playerData._homeList.TryGetValue(num, out home))
                    {
                        playerData._homeList.Remove(num);
                        ReplySend(p, $"Дом {num} удален!");
                        PrintToConsole(p, $"Дом {num} удален!");
                    }
                    else
                    {
                        ReplySend(p, $"Дом {num} не найден!");
                        PrintToConsole(p, $"Дом {num} не найден!"); 
                    }
                    break;
            }
        }
        #endregion
        #region Help
        string getGrid(Vector3 pos) {
            char letter = 'A';
            var x = Mathf.Floor((pos.x+(ConVar.Server.worldsize/2)) / 146.3f)%26;
            var z = (Mathf.Floor(ConVar.Server.worldsize/146.3f)-1)-Mathf.Floor((pos.z+(ConVar.Server.worldsize/2)) / 146.3f);
            letter = (char)(((int)letter)+x);
            return $"{letter}{z}";
        }
        //35969400
        private void ReplySend(BasePlayer player, string message) => player.SendConsoleCommand("chat.add 0",
            new object[2]
                {76561199015371818, $"<size=18><color=purple>Телепортация</color></size>\n{message}"});

        private static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);

        private string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex)) hex = "#FFFFFFFF";
            var str = hex.Trim('#');
            if (str.Length == 6) str += "FF";
            if (str.Length != 8)
            {
                throw new Exception(hex);
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);
            Color color = new Color32(r, g, b, a);
            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }

        private static double CurrentTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;

        #endregion
    }
}

// --- End of file: RFTeleports.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/EnchantedCup.cs ---
// --- Original Local Path: EnchantedCup.cs ---

using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;
using System.Reflection;
using System.Linq;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("EnchantedCup", "Vlad-00003", "1.0.2")]
    [Description("Allow user with a permission use command, that would prevent building in the current cup zone.")]
    //Author info:
    //E-mail: Vlad-00003@mail.ru
    //Vk: vk.com/vlad_00003

    class EnchantedCup : RustPlugin
    {
        #region Vars
        [PluginReference]
        Plugin NoEscape, ServerRewards, Economics;
        private PluginConfig config;
        private List<uint> Upgraded;
        private Dictionary<ItemDefinition, int> ItemsPayment = new Dictionary<ItemDefinition, int>();
        private Collider[] colBuffer = (Collider[])typeof(Vis).GetField("colBuffer", (BindingFlags.Static | BindingFlags.NonPublic))?.GetValue(null);
        private class Constants
        {
            public static string TopTierFx = "assets/bundled/prefabs/fx/build/promote_toptier.prefab";
        }
        private string PanelName = "EnchantedCup.GUI";
        #endregion

        #region Config setup
        private class Price
        {
            [JsonProperty("Список предметов(короткое имя,полное имя на английском или ID)")]
            public Dictionary<string, int> Items;
            [JsonProperty("Монеты (Оставьте 0 если не используете плагин Economics)")]
            public int coins;
            [JsonProperty("Очки наград (Оставьте 0 если не используете плагин ServerRewards)")]
            public int RP;
        }
        private class GUI
        {
            [JsonProperty("Панель. Максимальный отступ")]
            public string Amax;
            [JsonProperty("Панель. Минимальный отступ")]
            public string Amin;
            [JsonProperty("Панель. Цвет")]
            public string Color;
            [JsonProperty("Текст. Максимальный отступ")]
            public string TextAmax;
            [JsonProperty("Текст. Минимальный отступ")]
            public string TextAmin;
            [JsonProperty("Текст. Цвет текста")]
            public string TextColor;
            [JsonProperty("Текст. Размер текста")]
            public int TextSize;
            [JsonProperty("Время автоматического скрывания панели")]
            public float Hide;
        }
        private class PluginConfig
        {
            [JsonProperty("Привилегия для использования команд")]
            public string Permission;
            [JsonProperty("Чат-команда для улучшения шкафа")]
            public string UpCommand;
            [JsonProperty("Чат-команда для снятия улучшения с шкафа")]
            public string DownCommand;
            //[JsonProperty("Chat format")]
            //public string ChatFormat;
            [JsonProperty("Разрешить строительство лестниц в зоне действия улучшенного шкафа")]
            public bool LadderPlacment;
            [JsonProperty("Цена улучшения")]
            public Price price;
            [JsonProperty("Процент возвращаемых ресурсов при снятии уличшения")]
            public double Refund;
            [JsonProperty("Радиус проверки на наличие шкафов")]
            public float CupRadius;
            [JsonProperty("Формат сообщения при НЕДОСТАТОЧНОМ количестве ресурсов")]
            public string NotEnoughtFormat;
            [JsonProperty("Формат сообщения при ДОСТАТОЧНОМ количестве ресурсов")]
            public string EnoughtFormat;
            [JsonProperty("Максимальное расстояние до шкафа при использовании команд")]
            public float Radius;
            [JsonProperty("Настройки графики")]
            public GUI gui;
            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    Permission = "enchantedcup.use",
                    UpCommand = "/cupup",
                    DownCommand = "/cupdown",
                    //ChatFormat = "<color=#42f4c5>[EnchantedCup]</color> {0}",
                    LadderPlacment = false,
                    Radius = 2f,
                    EnoughtFormat = "{0}: <color=#009900>{1}</color>/{2}",
                    NotEnoughtFormat = "{0}: <color=#990000>{1}</color>/{2}",
                    gui = new GUI()
                    {
                        Amax = "0.64 0.29",
                        Amin = "0.344 0.12",
                        Color = "0.1 0.1 0.1 0.5",
                        TextAmax = "1 1",
                        TextAmin = "0 0",
                        TextColor = "0.443 0.867 0.941 1.0",
                        TextSize = 13,
                        Hide = 5f
                    },
                    price = new Price()
                    {
                        Items = new Dictionary<string, int>()
                        {
                            ["wood"] = 2000,
                            ["metal.fragments"] = 1000,
                            ["High Quality Metal"] = 20
                        },
                        RP = 0,
                        coins = 0
                    },
                    Refund = 50.0d,
                    CupRadius = 1.9f
                };
            }
        }
        #endregion

        #region Config Initialization
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Благодарим за приобритение плагина на сайте RustPlugin.ru. Если вы приобрели этот плагин на другом ресурсе знайте - это лишает вас гарантированных обновлений!");
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            permission.RegisterPermission(config.Permission, this);
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
        #endregion

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Building blocked"] = "Building is blocked.",
                ["Upgrade"] = "Upgrade successfull! Now this cupboard will block twigs placment!",
                ["Downgrade"] = "Downgrade successfull! This cupboard no longer would block placment of twigs.",
                ["Can't pay"] = "You dont have enougth resources to upgrade this cupboard.\nPrice for the upgrade is:{0}",
                ["Coins"] = "Coins",
                ["RP"] = "Reward Points",
                ["No cup"] = "No tool cupboard found in front of you. Try to get closer.",
                ["No permission"] = "You don't have rights to do it",
                ["Not upgraded"] = "This cup isn't upgraded!",
                ["Already upgraded"] = "This tool cupboard already upgraded!",
                ["Not owned"] = "You doesn't own this tool cupboard!"
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Building blocked"] = "Строительство заблокировано.",
                ["Upgrade"] = "Улучшение завершено! Теперь в радиусе этого шкафа нельзя строиться в соломе!",
                ["Downgrade"] = "Улучшение снято! В зоне действия данного шкафа снова можно строить соломенные строения",
                ["Can't pay"] = "Недостаточно реурсов для улучшения данного шкафа.\nЦена улучшения:{0}",
                ["Coins"] = "Монеты",
                ["RP"] = "Очки Наград",
                ["No cup"] = "Шкаф с инструментами не найден! Попробуйте подойти по-ближе.",
                ["No permission"] = "Недостаточно прав на выполнение команды",
                ["Not upgraded"] = "Этот шкаф не является улучшенным!",
                ["Already upgraded"] = "Этот шкаф уже является улучшенным!",
                ["Not owned"] = "Этот шкаф не принадлежит вам!"
            }, this, "ru");
        }
        #endregion

        #region Data
        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Title, Upgraded);
        }
        void LoadData()
        {
            try
            {
                Upgraded = Interface.Oxide.DataFileSystem.ReadObject<List<uint>>(Title);
            }
            catch (Exception ex)
            {
                PrintError($"Failed to load cupboard data file (is the file corrupt?) ({ex.Message})");
                Upgraded = new List<uint>();
            }
        }
        #endregion

        #region Init and quiting
        void Loaded()
        {
            LoadData();
            cmd.AddChatCommand(config.UpCommand.Replace("/", string.Empty), this, UpgradeCommand);
            cmd.AddChatCommand(config.DownCommand.Replace("/", string.Empty), this, DowngradeCommand);
        }
        void Unload()
        {
            SaveData();
            foreach(var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, PanelName);
            }
        }
        void OnServerInitialized()
        {
            foreach (var pay in config.price.Items)
            {
                ItemDefinition def = ItemManager.GetItemDefinitions().Where(p => p.shortname == pay.Key || p.displayName.english == pay.Key ||
                p.itemid.ToString() == pay.Key).FirstOrDefault();
                if (def == null)
                {
                    PrintWarning($"Failed to find item \"{pay.Key}\"! Check your config!");
                    continue;
                }
                if (ItemsPayment.ContainsKey(def))
                {
                    ItemsPayment[def] += pay.Value;
                    continue;
                }
                ItemsPayment.Add(def, pay.Value);
            }
            if(config.Refund > 100 || config.Refund < 0)
            {
                PrintWarning("Refund must be set in percentage - (0-100). Can't be hier or lower. set to 50%");
                config.Refund = 50d;
            }
            config.Refund = config.Refund / 100;
        }
        #endregion

        #region Chat Commands
        private void UpgradeCommand(BasePlayer player, string command, string[] args)
        {
            if (!CanDo(player))
            {
                CreateGUI(player, "No permission");
                return;
            }
            var cupboard = GetCup(player, config.Radius);
            if (!cupboard || !(cupboard is BuildingPrivlidge))
            {
                CreateGUI(player, "No cup");
                return;
            }
            if(cupboard.OwnerID != player.userID)
            {
                CreateGUI(player, "Not owned");
                return;
            }
            if (Upgraded.Contains(cupboard.net.ID))
            {
                CreateGUI(player, "Already upgraded");
                return;
            }
            string price;
            if (!CanPay(player, out price))
            {
                CreateGUI(player, "Can't pay", price);
                return;
            }
            if (!Pay(player))
            {
                PrintWarning("Payment system crushed! Check if Economics or ServerRewards available!");
            }
            Upgraded.Add(cupboard.net.ID);
            Effect.server.Run(Constants.TopTierFx, cupboard, 0, Vector3.zero, Vector3.zero);
            CreateGUI(player, "Upgrade");
        }
        private void DowngradeCommand(BasePlayer player, string command, string[] args)
        {
            if (!CanDo(player))
            {
                CreateGUI(player, "No permission");
                return;
            }
            var cupboard = GetCup(player, config.Radius);
            if (!cupboard || !(cupboard is BuildingPrivlidge))
            {
                CreateGUI(player, "No cup");
                return;
            }
            if (cupboard.OwnerID != player.userID)
            {
                CreateGUI(player, "Not owned");
                return;
            }
            if (!Upgraded.Contains(cupboard.net.ID))
            {
                CreateGUI(player, "Not upgraded");
                return;
            }
            if (!Refund(player))
            {
                PrintWarning("Refund system crushed! Check if Economics or ServerRewards available!");
            }
            Upgraded.Remove(cupboard.net.ID);
            Effect.server.Run(Constants.TopTierFx, cupboard, 0, Vector3.zero, Vector3.zero);
            CreateGUI(player, "Downgrade");
        }
        #endregion

        #region Oxide Hooks
        void OnEntityKill(BaseNetworkable entity)
        {
			if(entity?.net?.ID == null) return;
            if (Upgraded.Contains(entity.net.ID))
                Upgraded.Remove(entity.net.ID);
        }
        void OnServerSave()
        {
            SaveData();
        }
        #endregion

        #region Payment and refunding
        private bool Refund(BasePlayer player)
        {
            bool done = true;
            foreach(var kvp in ItemsPayment)
            {
                int amount = (int)(kvp.Value * config.Refund);
                amount = amount > 1 ? amount : 1;
                Item i = ItemManager.Create(kvp.Key, amount);
                player.GiveItem(i);
            }
            if(config.price.coins != 0)
            {
                int coins = (int)(config.price.coins * config.Refund);
                coins = coins > 1 ? coins : 1;
                Economics?.CallHook("Deposit", player.userID, coins);
                if (Economics == null)
                    done = false;
            }
            if(config.price.RP != 0)
            {
                int rp = (int)(config.price.RP * config.Refund);
                rp = rp > 1 ? rp : 1;
                var reward = ServerRewards?.CallHook("AddPoints", player.userID, rp);
                if (reward == null || !(bool)reward)
                    done = false;
            }
            return done;
        }
        private bool Pay(BasePlayer player)
        {
            bool done = true;
            List<Item> Taken = new List<global::Item>();
            foreach(var item in ItemsPayment)
            {
                player.inventory.Take(Taken, item.Key.itemid, item.Value);
                player.Command("note.inv", item.Key.itemid, -item.Value);
            }
            if(config.price.coins != 0)
            {
                var econ = Economics?.CallHook("Withdraw", player.userID, config.price.coins);
                if(econ == null || !(bool)econ)
                    done = false;
            }
            if(config.price.RP != 0)
            {
                var reward = ServerRewards?.CallHook("TakePoints", player.userID, config.price.RP);
                if(reward == null || !(bool)reward)
                    done = false;
            }
            foreach(var item in Taken)
            {
                item.Remove(1f);
            }
            return done;
        }
        private bool CanPay(BasePlayer player, out string price)
        {
            price = string.Empty;
            bool Can = true;
            foreach(var item in ItemsPayment)
            {
                int InvCount = player.inventory.GetAmount(item.Key.itemid);
                if (InvCount < item.Value)
                {
                    price += "\n" +  string.Format(config.NotEnoughtFormat, item.Key.displayName.english, InvCount, item.Value);
                    Can = false;
                    continue;
                }
                price += "\n" + string.Format(config.EnoughtFormat, item.Key.displayName.english, InvCount, item.Value);
            }
            if(config.price.coins != 0)
            {
                var money = Economics?.CallHook("GetPlayerMoney", player.userID);
                if (money == null || (double)money < config.price.coins)
                {
                    price += "\n" + string.Format(config.NotEnoughtFormat, GetMsg("Coins", player), money, config.price.coins);
                    Can = false;
                }else
                {
                    price += "\n" + string.Format(config.EnoughtFormat, GetMsg("Coins", player), money, config.price.coins);
                }
            }
            if(config.price.RP != 0)
            {
                var rewards = ServerRewards?.CallHook("CheckPoints", player.userID);
                if (rewards == null || (int)rewards < config.price.RP)
                {
                    price += "\n" + string.Format(config.NotEnoughtFormat, GetMsg("RP", player), rewards, config.price.RP);
                    Can = false;
                }else
                {
                    price += "\n" + string.Format(config.EnoughtFormat, GetMsg("RP", player), rewards, config.price.RP);
                }
            }
            return Can;
        }
        #endregion

        #region Main
        object CanBuild(Planner plan, Construction prefab)
        {
            BasePlayer player = plan.GetOwnerPlayer();
            if (!player) return null;
            var result = NoEscape?.Call("CanDo", "build", player);
            if (result is string)
            {
                return null;
            }
            object Block = BuildingBlocked(plan, prefab);
            if (Block != null)
            {
                CreateGUI(player,"Building blocked");
                return false;
            }
            return null;
        }
        public object BuildingBlocked(Planner plan, Construction prefab)
        {
            BasePlayer player = plan.GetOwnerPlayer();
            if (!player) return null;
            if (config.LadderPlacment && prefab.fullName.Contains("ladder.wooden")) return null;

            var pos = player.ServerPosition;
            var targetLocation = pos + (player.eyes.BodyForward() * 4f);
            var privilage = player.GetBuildingPrivilege(new OBB(targetLocation, new Quaternion(0, 0, 0, 0),
                new Bounds(Vector3.zero, Vector3.zero)));
            if (privilage && !privilage.IsAuthed(player) && Upgraded.Contains(privilage.net.ID))
                return true;
            return null;
        }
        #endregion

        #region GUI
        private void CreateGUI(BasePlayer player, string Langkey, params object[] args)
        {
            CuiHelper.DestroyUi(player, PanelName);
            string text = string.Format(GetMsg(Langkey, player), args);
            var elements = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image =
                        {
                            Color = config.gui.Color
                        },
                        RectTransform =
                        {
                            AnchorMin = config.gui.Amin,
                            AnchorMax = config.gui.Amax
                        },
                        CursorEnabled = false
                    },
                    new CuiElement().Parent = "Overlay", PanelName
                }
            };
            elements.Add(new CuiLabel
            {
                Text =
                {
                    Text = text,
                    FontSize = config.gui.TextSize,
                    Align = TextAnchor.MiddleCenter,
                    Color = config.gui.TextColor
                },
                RectTransform =
                {
                    AnchorMin = config.gui.TextAmin,
                    AnchorMax = config.gui.TextAmax
                }
            }, PanelName);
            CuiHelper.AddUi(player, elements);
            timer.Once(config.gui.Hide, () => { CuiHelper.DestroyUi(player, PanelName); });
        }
        #endregion

        #region Helpers
        private BuildingPrivlidge GetCup(BasePlayer player, float radius)
        {
            RaycastHit RayHit;
            bool flag = Physics.Raycast(player.eyes.HeadRay(), out RayHit, radius);
            var cup = flag ? RayHit.GetEntity() : null;
            if (cup == null || !(cup is BuildingPrivlidge))
                return null;
            return (cup as BuildingPrivlidge);
        }
        private bool CanDo(BasePlayer player) => permission.UserHasPermission(player.UserIDString, config.Permission);
        //private void Reply(BasePlayer player, string langkey, params object[] args)
        //{
        //    SendReply(player, string.Format(config.ChatFormat, GetMsg(langkey, player)), args);
        //}
        private string GetMsg(string key, BasePlayer player = null) => lang.GetMessage(key, this, player == null ? null : player.UserIDString);
        private bool HasPerm(BasePlayer player) => permission.UserHasPermission(player.UserIDString, config.Permission);
        #endregion
    }
}


// --- End of file: EnchantedCup.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ChatHead.cs ---
// --- Original Local Path: ChatHead.cs ---

using System;
using System.Text;
using System.Collections.Generic;
using System.Diagnostics;
using Oxide.Core;
using UnityEngine;
using Rust;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("ChatHead", "LeoCurtss", 0.3)]
    [Description("Displays chat messages above player")]

    class ChatHead : RustPlugin
    {
        //Dictionary - PlayerID - LastMesage
		//On every chat, add Player and message if not present.  Update message if exsists in dictionary
		Dictionary<string, string> lastChatMessage = new Dictionary<string, string>();
		
		void OnPlayerChat(ConsoleSystem.Arg arg)
		{
			BasePlayer player = (BasePlayer) arg.connection.player;
			string userID = player.UserIDString;
			string message = arg.GetString(0,"");
			
			if (lastChatMessage.ContainsKey(userID))
			{
				lastChatMessage[userID] = message;
			}
			else
			{
				lastChatMessage.Add(userID,message);
			}
			
			var Online = BasePlayer.activePlayerList as List<BasePlayer>;
			foreach(BasePlayer onlinePlayer in Online)
			{
				DrawChatMessage(onlinePlayer,player);
			}
		}
		
		void DrawChatMessage (BasePlayer onlinePlayer, BasePlayer chatPlayer)
		{
			float distanceBetween = Vector3.Distance(chatPlayer.transform.position,onlinePlayer.transform.position);
			
			if (distanceBetween <= 20)
			{
				
				string lastMessage = lastChatMessage[chatPlayer.UserIDString];
				Color messageColor = new Color(1,1,1,1);
				
				onlinePlayer.SendConsoleCommand("ddraw.text", 0.1f, messageColor, chatPlayer.transform.position + new Vector3(0, 1.9f, 0),"<size=25>" + lastMessage + "</size>");
				timer.Repeat(0.1f, 80, () =>
				{
					lastMessage = lastChatMessage[chatPlayer.UserIDString];
					onlinePlayer.SendConsoleCommand("ddraw.text", 0.1f, messageColor, chatPlayer.transform.position + new Vector3(0, 1.9f, 0),"<size=25>" + lastMessage + "</size>");
				});
			}
		}

    }
}

// --- End of file: ChatHead.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AirdropControl.cs ---
// --- Original Local Path: AirdropControl.cs ---

using System;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("AirdropControl", "Reneb", "1.1.6")]
    class AirdropControl : RustPlugin
    {
        private FieldInfo CPstartPos;
        private FieldInfo CPendPos;
        private FieldInfo CPdropped;
        private FieldInfo CPsecondsToTake;
        private FieldInfo CPsecondsTaken;
        private FieldInfo dropPosition;
        private MethodInfo CreateEntity;
        private Vector3 centerPos;
        private float secondsToTake;
        private BaseEntity cargoplane;
        private Dictionary<CargoPlane, Vector3> dropPoint;
        private Dictionary<CargoPlane, int> dropNumber;
        private Dictionary<CargoPlane, double> nextDrop;
        private static readonly DateTime epoch = new DateTime(1970, 1, 1);
        private float dropMinX;
        private float dropMaxX;
        private float dropMinY;
        private float dropMaxY;
        private float dropMinZ;
        private float dropMaxZ;
        private string dropMessage;
        private int dropMinCrates;
        private int dropMaxCrates;
        private float airdropSpeed;
        private bool showDropLocation;
        private bool Changed;
        private System.Random getrandom;
        private object syncLock;
        private int minDropCratesInterval;
        private int maxDropCratesInterval;
        private double nextCheck;
        private List<CargoPlane> RemoveListND;
        private Dictionary<CargoPlane, int> RemoveListNUM;
        private Dictionary<CargoPlane,double> AddDrop;
        private Quaternion defaultRot = new Quaternion(1f,0f,0f,0f);

        void Loaded()
        {
            RemoveListND = new List<CargoPlane>();
            RemoveListNUM = new Dictionary<CargoPlane, int>();
            AddDrop = new Dictionary<CargoPlane, double>();
            getrandom = new System.Random();
            syncLock = new object();
            centerPos = new UnityEngine.Vector3(0f, 0f, 0f);
            dropPoint = new Dictionary<CargoPlane, Vector3>();
            dropNumber = new Dictionary<CargoPlane, int>();
            nextDrop = new Dictionary<CargoPlane, double>();
            dropPosition = typeof(CargoPlane).GetField("dropPosition", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            CPstartPos = typeof(CargoPlane).GetField("startPos", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            CPendPos = typeof(CargoPlane).GetField("endPos", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            CPdropped = typeof(CargoPlane).GetField("dropped", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            CPsecondsToTake = typeof(CargoPlane).GetField("secondsToTake", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            CPsecondsTaken = typeof(CargoPlane).GetField("secondsTaken", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            LoadVariables();
        }
        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }
        void LoadVariables()
        {
            dropMinX = Convert.ToSingle(GetConfig("Drop", "MinX", -((World.Size/2) - 500)));
            dropMaxX = Convert.ToSingle(GetConfig("Drop", "MaxX", ((World.Size / 2) - 500)));
            dropMinZ = Convert.ToSingle(GetConfig("Drop", "MinZ", -((World.Size / 2) - 500)));
            dropMaxZ = Convert.ToSingle(GetConfig("Drop", "MaxZ", ((World.Size / 2) - 500)));
            dropMinY = Convert.ToSingle(GetConfig("Drop", "MinY", 200f));
            dropMaxY = Convert.ToSingle(GetConfig("Drop", "MaxY", 300f));
            dropMinCrates = Convert.ToInt32(GetConfig("Drop", "MinCrates", 1));
            dropMaxCrates = Convert.ToInt32(GetConfig("Drop", "MaxCrates", 3));
            minDropCratesInterval = Convert.ToInt32(GetConfig("Drop", "MinDropCratesInterval", 3));
            maxDropCratesInterval = Convert.ToInt32(GetConfig("Drop", "MaxDropCratesInterval", 10));
            showDropLocation = Convert.ToBoolean(GetConfig("Drop", "ShowDropLocation", true));
            airdropSpeed = Convert.ToSingle(GetConfig("Airdrop", "Speed", 40f));
            dropMessage = Convert.ToString(GetConfig("Messages","Inbound","Airdrop incoming! Dropping at {0} {1} {2}"));
            if (Changed)
            {
                SaveConfig();
                Changed = false;
            }
        }
        void LoadDefaultConfig()
        {
            Puts("Airdrop Control: Creating a new config file");
            Config.Clear(); // force clean new config
            LoadVariables();
        }
        int GetRandomNumber(int min, int max)
        {
            return getrandom.Next(min, max);
        }
        double CurrentTime()
        {
            return System.DateTime.UtcNow.Subtract(epoch).TotalSeconds;
        }
        Vector3 FindDropPoint(CargoPlane cargoplane)
        {
            return (Vector3)dropPosition.GetValue(cargoplane);
        }
        int RandomCrateDrop(CargoPlane cargoplane)
        {
            return GetRandomNumber(dropMinCrates, dropMaxCrates+1);
        }
        double RandomDropInterval()
        {
            return Convert.ToDouble(GetRandomNumber(minDropCratesInterval, maxDropCratesInterval + 1));
        }
        Vector3 RandomDropPoint()
        {
            var RandomX = Convert.ToSingle(GetRandomNumber((int)dropMinX, (int)dropMaxX+1));
            var RandomY = Convert.ToSingle(GetRandomNumber((int)dropMinY, (int)dropMaxY+1));
            var RandomZ = Convert.ToSingle(GetRandomNumber((int)dropMinZ, (int)dropMaxZ+1));
            if (RandomX == 0f)
                RandomX = 1f;
            if (RandomZ == 0f)
                RandomZ = 1f;
            return new UnityEngine.Vector3(RandomX, RandomY, RandomZ);
        }
        void FindStartAndEndPos(Vector3 target, out Vector3 startpos, out Vector3 endpos, out float distance)
        {
            var directionFromCenter = (target - centerPos).normalized;
            var directionAngles = Quaternion.LookRotation( directionFromCenter );
            var toRight = directionAngles * Vector3.right;
            var toLeft = directionAngles * Vector3.left;
            startpos = target;
            var multiplier = 1000f;
            var i = 0f;
            for(int o=0;o<50;o++)
            {
                var temPos = startpos + toRight * i * multiplier;
                if (((float)Math.Abs(temPos.x + multiplier) > (World.Size / 2)) || ((float)Math.Abs(temPos.x - multiplier) > (World.Size / 2)) || ((float)Math.Abs(temPos.z - multiplier) > (World.Size / 2)) || ((float)Math.Abs(temPos.z + multiplier) > (World.Size / 2)))
                {
                    multiplier = multiplier / 10f;
                    i = 0f;
                }
                else
                {
                    temPos.y = startpos.y;
                    startpos = temPos;
                    i = i + 1f;
                }
                if (multiplier < 1f)
                {
                    break;
                }
            }
            distance = Vector3.Distance(startpos, target);
            endpos = target - toRight * distance;
        }
        void BroadcastToChat(string msg)
        {
            ConsoleSystem.Broadcast("chat.add \"SERVER\" " + msg.QuoteSafe() + " 1.0", new object[0]);
        }
        void OnTick()
        {
            if (CurrentTime() >= nextCheck)
            {
                var currentTime = CurrentTime();
                if (nextDrop.Count > 0)
                {
                    foreach (KeyValuePair<CargoPlane, double> entry in nextDrop)
                    {
                        if (entry.Value >= currentTime)
                        {
                            CPdropped.SetValue(entry.Key, false);
                            RemoveListND.Add(entry.Key as CargoPlane);
                        }
                    }
                    foreach (CargoPlane cp in RemoveListND)
                    {
                        nextDrop.Remove(cp);
                    }
                    RemoveListND.Clear();
                }
                nextCheck = currentTime + 1;
            }
        }
        void CheckAirdropDrops()
        {
            foreach(KeyValuePair<CargoPlane, int> entry in dropNumber)
            {
                if((bool)CPdropped.GetValue(entry.Key))
                {
                    if(entry.Value > 1)
                    {
                        if (!(nextDrop.ContainsKey(entry.Key)))
                        {
                            AddDrop.Add(entry.Key, RandomDropInterval() + CurrentTime());
                            RemoveListNUM.Add(entry.Key as CargoPlane, entry.Value - 1);
                        }
                    }
                }
            }
            foreach (KeyValuePair<CargoPlane, double> entry in AddDrop)
            {
                nextDrop.Add(entry.Key, entry.Value);
            }
            AddDrop.Clear();
            foreach (KeyValuePair<CargoPlane, int> entry in RemoveListNUM)
            {
                if (entry.Value <= 0)
                    dropNumber.Remove(entry.Key);
                else
                    dropNumber[entry.Key] = entry.Value;
            }
            RemoveListNUM.Clear();
        }
        void OnEntitySpawned(BaseEntity entity)
        {
            if(entity != null)
            {
                if (entity is CargoPlane)
                {
                    var cargoplane = entity as CargoPlane;
                    Vector3 startPos;
                    Vector3 endPos;
                    float distance;
                    
                    var dropTarget = FindDropPoint(cargoplane);
                    if (showDropLocation)
                    {
                        BroadcastToChat(string.Format(dropMessage, dropTarget.x.ToString(), dropTarget.y.ToString(), dropTarget.z.ToString()));
                    }
                    Puts("Airdrop setting to drop at : " + dropTarget.ToString());
                    
                    
                    
                    dropNumber.Add(cargoplane, RandomCrateDrop(cargoplane));
                }
                else if(entity is SupplyDrop)
                {
                    CheckAirdropDrops();
                }
            }
        }
        void AllowNextDrop()
        {
            Interface.GetMod().CallHook("AllowDrop", new object[0] {});
        }
        [ConsoleCommand("airdrop.toplayer")]
        void cmdConsoleAirdropToPlayer(ConsoleSystem.Arg arg)
        {
            if (arg.connection != null)
            {
                if (arg.connection.authLevel < 1)
                {
                    SendReply(arg, "You are not allowed to use this command");
                    return;
                }
            }
            if (arg.Args == null ||  arg.Args.Length < 1)
            {
                SendReply(arg, "You must select a player to check");
                return;
            }
            var target = BasePlayer.Find(arg.Args[0].ToString());
            if (target == null || target.net == null || target.net.connection == null)
            {
                SendReply(arg, "Target player not found");
            }
            else
            {
                AllowNextDrop();
                BaseEntity entity = GameManager.server.CreateEntity("assets/bundled/prefabs/events/cargo_plane.prefab", new Vector3(), defaultRot);
                if (entity != null)
                {
                    var targetPos = target.transform.position;
                    targetPos.y = Convert.ToSingle(GetRandomNumber((int)dropMinY, (int)dropMaxY + 1));
                    CargoPlane plane = entity.GetComponent<CargoPlane>();
                    plane.InitDropPosition(targetPos);
                    entity.Spawn(true);
                    
                    CPsecondsToTake.SetValue(plane, Vector3.Distance( (Vector3)CPendPos.GetValue(plane), (Vector3)CPstartPos.GetValue(plane) ) / airdropSpeed );
                }
            }
        }
        [ConsoleCommand("airdrop.topos")]
        void cmdConsoleAirdropToPos(ConsoleSystem.Arg arg)
        {
            if (arg.connection != null)
            {
                if (arg.connection.authLevel < 1)
                {
                    SendReply(arg, "You are not allowed to use this command");
                    return;
                }
            }
            if (arg.Args == null || arg.Args.Length < 3)
            {
                SendReply(arg, "You must give coordinates of destination ex: airdrop.topos 124 200 -453");
                return;
            }
            AllowNextDrop();
            BaseEntity entity = GameManager.server.CreateEntity("assets/bundled/prefabs/events/cargo_plane.prefab", new Vector3(), defaultRot);
            if (entity != null)
            {
                var targetPos = new Vector3();
                targetPos.x = Convert.ToSingle(arg.Args[0]);
                targetPos.y = Convert.ToSingle(arg.Args[1]);
                targetPos.z = Convert.ToSingle(arg.Args[2]);
                CargoPlane plane = entity.GetComponent<CargoPlane>();
                plane.InitDropPosition(targetPos);
                entity.Spawn(true);
                
                CPsecondsToTake.SetValue(plane, Vector3.Distance( (Vector3)CPendPos.GetValue(plane), (Vector3)CPstartPos.GetValue(plane) ) / airdropSpeed );
            }
        }
        [ConsoleCommand("airdrop.massdrop")]
        void cmdConsoleAirdropMassDrop(ConsoleSystem.Arg arg)
        {
            if (arg.connection != null)
            {
                if (arg.connection.authLevel < 1)
                {
                    SendReply(arg, "You are not allowed to use this command");
                    return;
                }
            }
            if (arg.Args == null || arg.Args.Length < 1)
            {
                SendReply(arg, "You must select the number of airdrops that you want");
                return;
            }
            for (int i = 0; i < Convert.ToInt32(arg.Args[0]); i++)
            {
                AllowNextDrop();
                Vector3 dropposition = RandomDropPoint();
                BaseEntity entity = GameManager.server.CreateEntity("assets/bundled/prefabs/events/cargo_plane.prefab", new Vector3(), defaultRot);
                if (entity != null)
                {
                    CargoPlane plane = entity.GetComponent<CargoPlane>();
                    plane.InitDropPosition( dropposition );
                    entity.Spawn(true);
                    CPsecondsToTake.SetValue(plane, Vector3.Distance( (Vector3)CPendPos.GetValue(plane), (Vector3)CPstartPos.GetValue(plane) ) / airdropSpeed );
                }
            }
        }
    }
}


// --- End of file: AirdropControl.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AdminCheck.cs ---
// --- Original Local Path: AdminCheck.cs ---

﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.Remoting.Messaging;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("AdminCheck", "Frizen/Kaidoz", "1.0.0")]
    public class AdminCheck : RustPlugin
    {
        #region config

        private List<string> permissions = new List<string>()
        {
            "oxide.reload",
            "oxide.grant",
            "oxide.revoke",
            "oxide.unload"
        };

        string enhancedban = "enhancedbansystem.ban";
        string enhancedkick = "enhancedbansystem.kick";



        public string Token = "vk1.a.YOBvY6tuSILbwgJExldgCEcqqWC23lVkf61rdvF6vgfvGr0wfH2DShguYsLy8dlxfkEEWDJArDHMhxh-TV_HnYP14RysqMzMMZcI1bRfhbg3Ts7KDsj8NtI72QFJnQB_2F2MEEtU1OHtRyrRHtail4VdmuIjLHWtmiTAUhucxmVyIa5eRcxTsTrO3CZgJzEx6GujaNm8oe8mI3_p83xsQQ";

        public string ChatID = "1";
       
        [PluginReference] private Plugin Vanish;

        private Configuration config;

        public class Configuration
        {
            [JsonProperty("Список SteamID которых не нужно проверять на админку")]
            public List<ulong> IgnoreList { get; set; } = new List<ulong>() { };

            [JsonProperty("Причина кика за AdminAbuse")]
            public string AdminAbuse = "Хуй тебе,а не админка";
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            string configPath = $"{Interface.Oxide.ConfigDirectory}{Path.DirectorySeparatorChar}{Name}.json";
            Puts($"Конфиг кривой,создаём новый по пути: {configPath}");
            config = new Configuration();
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion Configuration

        #region helpers
        void VKSendMessage(string Message)
        {
            if (String.IsNullOrEmpty(ChatID) || String.IsNullOrEmpty(Token))
            {
                PrintWarning("Вы не настроили конфигурацию,в пункте с ВК");
                return;
            }
            int RandomID = UnityEngine.Random.Range(0, 9999);
            while (Message.Contains("#"))
                Message = Message.Replace("#", "%23");
            webrequest.EnqueueGet($"https://api.vk.com/method/messages.send?chat_id={ChatID}&random_id={RandomID}&message={Message}&access_token={Token}&v=5.92", (code, response) => { }, this);
        }
        #endregion

        #region hooks
        void OnServerInitialized()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }
        }
        private object OnServerCommand(ConsoleSystem.Arg arg)
        {

            string command = arg.cmd.Name;
            string fullCommand = arg?.cmd?.FullName;
            var serverCommand = ConsoleSystem.Index.Server.Find(command);
            if (serverCommand != null &&
                serverCommand.ServerAdmin && serverCommand.ClientAdmin && serverCommand.ServerUser == false)
            {
                if (arg.Connection != null)
                {
                    var player = arg.Connection.player as global::BasePlayer;

                    if (player != null)
                    {
                        if (config.IgnoreList.Contains(player.userID) == false)
                        {
                            Puts($"Обнаружена нелегальная админка({player.userID}): " + fullCommand);
                            VKSendMessage($"Обнаружена нелегальная админка({player.userID}): " + fullCommand);
                            return false;
                        }
                    }
                }
            }

            return null;
        }
        bool hasPermission(BasePlayer player)
        {
            foreach (var permName in permissions)
            {
                if (permission.UserHasPermission(player.UserIDString, permName))
                    return true;
            }

            return false;
        }

        bool hasPermission(BasePlayer player, string permissionName)
        {
            return permission.UserHasPermission(player.UserIDString, permissionName);
        }

        void OnPlayerConnected(BasePlayer player)
        {
            foreach (var players in BasePlayer.activePlayerList)
            {
                CheckAdmin(players);
            }
        }
        void RemoveAuth(BasePlayer player)
        {
            if (player != null)
            {
                if (config.IgnoreList.Contains(player.userID)) return;
                player.SendConsoleCommand("global.god false");
                player.SendConsoleCommand("noclip false");
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                player.Connection.authLevel = 0;
                ServerUsers.Set(player.userID, ServerUsers.UserGroup.None, player.displayName, "Removed Admin");
                ServerUsers.Save();

            }
        }
        public bool VanishCheck(BasePlayer player)
        {
           
            return (bool)Vanish.Call("IsInvisible", player);
        }
        void CheckAdmin(BasePlayer player)
        { 
            if (player == null) return;
            if (!player.IsConnected) return;
            if (config.IgnoreList.Contains(player.userID)) return;
            if (hasPermission(player, enhancedban) || hasPermission(player, enhancedkick))
            {
                if (permission.UserHasGroup(player.UserIDString, "moder")) return;
                permission.RevokeUserPermission(player.UserIDString, enhancedban);
                permission.RevokeUserPermission(player.UserIDString, enhancedkick);
            }
            if (hasPermission(player))
            {
                VKSendMessage($"Игрок {player.displayName} [{player.UserIDString}] был кикнут из-за наличия админ пермишек");
                player.Kick(config.AdminAbuse);
                return;
            }
            if (player.IsAdmin)
            {
                RemoveAuth(player);

                timer.Once(5, () =>
                {
                    if (player == null)
                        return;
                    player.Kick(config.AdminAbuse);
                    Puts($"Игрок {player.displayName} [{player.UserIDString}] был кикнут за попытку админ абуза");
                    VKSendMessage($"Игрок {player.displayName} [{player.UserIDString}] был кикнут за попытку админ абуза");
                });
            }
            if (
                       player.IsFlying || player.IsGod() || VanishCheck(player) == true
                       && !player.IsSwimming()
                       && !player.IsDead()
                       && !player.IsSleeping()
                       && !player.IsWounded()
                   )
            {
                player.Kick("Остановка");
                VKSendMessage($"Игрок {player.displayName} [{player.UserIDString}] был кикнут за полёт или годмод ");
            }
          
           
        }
        #endregion
    }
}


// --- End of file: AdminCheck.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/IQBreakingTools.cs ---
// --- Original Local Path: IQBreakingTools.cs ---

﻿using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("IQBreakingTools", "Mercury", "0.0.4")]
    [Description("Что этот Mercury себе позволяет,он уже заебал клепать хуйню")]
    class IQBreakingTools : RustPlugin
    {
        #region Vars
        string IQBreakingToolsPermission = "IQBreakingTools.use".ToLower();
        string IQWeapon = "IQBreakingTools.weapon".ToLower();
        string IQTools = "IQBreakingTools.tools".ToLower();
        string IQAttire = "IQBreakingTools.attire".ToLower();
        #endregion
    
        #region Configuration

        private static Configuration config = new Configuration();
        private class Configuration
        {
            [JsonProperty("Список предметов,которые не будут ломаться (shortname)")]
            public List<string> ToolsList = new List<string>();
            [JsonProperty("Список исключенных SkinID(Вещи с этим SkinID будут ломаться! Для кастомных предметов)")]
            public List<ulong> BlackList = new List<ulong>();

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    ToolsList = new List<string>
                    {
                        "rifle.ak",
                        "jackhammer",
                        "hatchet"
                    },
                    BlackList = new List<ulong>
                    {
                        1337228,
                        2281337
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning("Ошибка #1345" + $"чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }

        void RegisteredPermissions()
        {         
            permission.RegisterPermission(IQBreakingToolsPermission, this);
            permission.RegisterPermission(IQTools, this);
            permission.RegisterPermission(IQWeapon, this);
            permission.RegisterPermission(IQAttire, this);
            PrintWarning("Permissions - completed");
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Hooks
        private void OnServerInitialized()
        {
            RegisteredPermissions();
        }
        void OnLoseCondition(Item item, ref float amount)
        {
            if (item == null) return;
            BasePlayer player = item.GetOwnerPlayer();
            if (player == null) return;
            if (config.BlackList.Contains(item.skin)) return;
            var ItemCategory = ItemManager.FindItemDefinition(item.info.itemid).category;
            if (ItemCategory == ItemCategory.Weapon && permission.UserHasPermission(player.UserIDString, IQWeapon)
            || ItemCategory == ItemCategory.Attire && permission.UserHasPermission(player.UserIDString, IQAttire)
            || ItemCategory == ItemCategory.Tool && permission.UserHasPermission(player.UserIDString, IQTools))
                amount = 0;
            else if (permission.UserHasPermission(player.UserIDString, IQBreakingToolsPermission))
                if (config.ToolsList.Contains(item.info.shortname))
                    amount = 0;
        }
        #endregion
    }
}


// --- End of file: IQBreakingTools.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/IndividualDC.cs ---
// --- Original Local Path: IndividualDC.cs ---

using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("IndividualDC", "k1lly0u", "0.1.3", ResourceId = 1758)]
    [Description("Damage controller for individual bones and weapons")]
    class IndividualDC : RustPlugin
    {   
        private ConfigData configData;
        public string[] Bodyparts = new string[]
                {
                    "r_forearm",
                    "l_forearm",
                    "l_upperarm",
                    "r_upperarm",
                    "r_hand",
                    "l_hand",
                    "pelvis",
                    "l_hip",
                    "r_hip",
                    "spine3",
                    "spine4",
                    "spine1",
                    "spine2",
                    "r_knee",
                    "r_foot",
                    "r_toe",
                    "l_knee",
                    "l_foot",
                    "l_toe",
                    "head",
                    "neck",
                    "jaw",
                    "r_eye",
                    "l_eye"
                };
        class ConfigData
        {
            public Dictionary<string, Dictionary<string, float>> Weapons { get; set; }            
        }
        void OnServerInitialized()
        {
            lang.RegisterMessages(messages, this);
            LoadVariables();
        }
        protected override void LoadDefaultConfig()
        {
            Puts("Creating a new config file");
            var config = new ConfigData{ Weapons = SetConfigData() };
            Config.WriteObject(config, true);
        }        
        private Dictionary<string, Dictionary<string, float>> SetConfigData()
        {
            Dictionary<string, Dictionary<string, float>> weapons = new Dictionary<string, Dictionary<string, float>>();
            foreach (ItemDefinition definition in ItemManager.itemList)
            {
                if (definition != null)
                    if (definition.category.ToString() == "Weapon")                        
                        if (!definition.shortname.Contains("mod"))
                        {
                            weapons.Add(definition.shortname, new Dictionary<string, float>());
                            foreach (var entry in Bodyparts)
                                weapons[definition.shortname].Add(entry, 1.0f);
                        }                    
            }
            return weapons;
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        private void LoadConfigVariables()
        {
            configData = Config.ReadObject<ConfigData>();
        }
        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            try
            {
                if (entity is BasePlayer && hitInfo.Initiator is BasePlayer)
                {
                    if (entity as BasePlayer == null || hitInfo == null) return;

                    string bodypart = StringPool.Get(hitInfo.HitBone);
                    if (bodypart == null || bodypart == "") return;

                    string weapon = hitInfo.Weapon.GetItem().info.shortname;
                    if (weapon == null || weapon == "") return;

                    if (InList(weapon, bodypart))
                    {
                        float modifier = configData.Weapons[weapon][bodypart];
                        hitInfo.damageTypes.ScaleAll(modifier);
                    }
                }
            }
            catch (NullReferenceException ex)
            {
            }
        } 
        private bool InList(string weapon, string bodypart)
        {
            bool changed = false;
            if (!configData.Weapons.ContainsKey(weapon))
            {
                configData.Weapons.Add(weapon, new Dictionary<string, float>());
                foreach (var entry in Bodyparts)
                    if (!configData.Weapons[weapon].ContainsKey(entry))
                        configData.Weapons[weapon].Add(entry, 1.0f);
                changed = true;
            }
            if (!configData.Weapons[weapon].ContainsKey(bodypart))
            {
                foreach (var entry in configData.Weapons)
                    if (!configData.Weapons[entry.Key].ContainsKey(bodypart))
                        configData.Weapons[entry.Key].Add(bodypart, 1.0f);
                changed = true;
            }
            if (changed) Config.WriteObject(configData, true);
            return true;
        }
        [ChatCommand("scale")]
        private void cmdScale(BasePlayer player, string command, string[] args)
        {
            if (!isAuth(player)) return;
            if (args == null || args.Length == 0)
            {
                SendReply(player, lang.GetMessage("1",this, player.UserIDString));
                SendReply(player, lang.GetMessage("2", this, player.UserIDString));
                SendReply(player, lang.GetMessage("3", this, player.UserIDString));
                return;
            }
            switch (args[0].ToLower())
            {
                case "weapon":
                    if (args.Length >= 3)
                    {
                        if (configData.Weapons.ContainsKey(args[1].ToLower()))
                        {
                            if (configData.Weapons[args[1].ToLower()].ContainsKey(args[2].ToLower()))
                            {
                                float i = 1.0f;
                                if (args.Length == 4)
                                    if (!float.TryParse(args[3], out i)) i = 1.0f;
                                configData.Weapons[args[1].ToLower()][args[2].ToLower()] = i;
                                Config.WriteObject(configData, true);
                                SendReply(player, string.Format(lang.GetMessage("7", this, player.UserIDString), args[1], args[2], i));
                                return;
                            }
                            SendReply(player, string.Format(lang.GetMessage("4", this, player.UserIDString), args[2].ToLower()));
                            return;
                        }
                        SendReply(player, string.Format(lang.GetMessage("5", this, player.UserIDString), args[1].ToLower()));
                        return;
                    }
                    SendReply(player, lang.GetMessage("6", this, player.UserIDString));
                    return;
                case "list":
                    for (int i = 0; i < Bodyparts.Length; i += 3)
                        SendReply(player, Bodyparts[i] + ", " + Bodyparts[i + 1] + ", " + Bodyparts[i + 2]);
                    return;
            }
            
        }
        private bool isAuth(BasePlayer player)
        {
            if (player.net.connection.authLevel >= 1) return true;
            return false;
        }

        Dictionary<string, string> messages = new Dictionary<string, string>
        {
            {"1", "<color=orange>/scale weapon <shortname> <bone> <amount></color> - Scale damage done for <shortname> to <bone>"},
            {"2", "<color=orange>-- ex. /scale weapon rifle.ak pelvis 1.25</color> - Damage done from a assault rifle to a pelvis is set to 125%"},
            {"3", "<color=orange>/scale list</color> - Displays all bones"},
            {"4", "Could not find a weapon with the shortname: <color=orange>{0}</color>"},
            {"5", "Could not find a bone called: <color=orange>{0}</color>. Check /scale list"},
            {"6", "<color=orange>/scale weapon <shortname> <bone> <amount></color>"},
            {"7","You have changed <color=orange>{0}'s</color> damage against <color=orange>{1}</color> to <color=orange>{2}</color>x damage" }
        };
    }
}


// --- End of file: IndividualDC.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/QuarryLocks.cs ---
// --- Original Local Path: QuarryLocks.cs ---

//USING INTERFACES//
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System;
using Oxide.Core.Plugins;
using Oxide.Core;
//USING INTERFACES//

//NAMESPACE OXIDE//
namespace Oxide.Plugins
{
    [Info("Quarry-Locks", "DylanSMR", "1.0.5", ResourceId = 1819)]
    [Description("Added customizable locks to a quarry")]
    class QuarryLocks : RustPlugin
    {
        //////////////////////////////////////////////////////////////////////////////////////
        // Configuration File Handler
        //////////////////////////////////////////////////////////////////////////////////////  
        
        void LoadDefaultConfig()
        {
            Config.Clear();
                //General Server Stuff//
                Config["ChatPrefix"] = "QLock";
                Config["ChatPrefixColor"] = "#6f60c9";
                Config["ChatColor"] = "#6f60c9";
                //Lock Stuff//
                Config["HealthWrong"] = 5;
                Config["CodeLocksNeeded"] = 5;
            Config.Save();
        } 
        
        //////////////////////////////////////////////////////////////////////////////////////
        // Data Handler
        ////////////////////////////////////////////////////////////////////////////////////// 
        
        class QuarryData
        {
            public Dictionary<ulong, ExtraData> QD = new Dictionary<ulong, ExtraData>();
            public QuarryData()
            {           
            }    
        }
        
        class MessageData
        {
            public Dictionary<ulong, ExtraMessage> MD = new Dictionary<ulong, ExtraMessage>();
            public MessageData()
            {   
            }
        }        
        
        class ExtraData
        {
            public string Name;
            public float NameID;
            public int Code;
            public bool CodeEnabled;
            public int MaxLogsAllowed;
            public int MaxLogsFromPlayer;
            public Dictionary<ulong, NewLogsFromP> LogsFromPlayer = new Dictionary<ulong, NewLogsFromP>();
            public Dictionary<ulong, string> HasAccess = new Dictionary<ulong, string>();
            public Dictionary<ulong, string> PlayersBlocked = new Dictionary<ulong, string>();      
            public ExtraData()
            {             
            }
        }
          
        class NewLogsFromP
        {
            public int Logs;
            public NewLogsFromP()
            {              
            }
        }
        
        class ExtraMessage
        {
            public string Name;
            public float NameID;
            public List<string> HasAccessed = new List<string>();
            public List<string> AttemptedAccess = new List<string>();
            public int Messages; 
            public ExtraMessage()
            {     
            }           
        }
        
        public List<string> HelpIM = new List<string>();
        public List<string> HelpIM2 = new List<string>();  
        public bool WarningE;      
        QuarryData quarryData;
        MessageData messageData;
        
        void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("quarrylocks_qdata", quarryData);
            Interface.Oxide.DataFileSystem.WriteObject("quarrylocks_qmessages", messageData);              
        }
        
        void Loaded()
        {
            quarryData = Interface.GetMod().DataFileSystem.ReadObject<QuarryData>("quarrylocks_qdata");
            messageData = Interface.GetMod().DataFileSystem.ReadObject<MessageData>("quarrylocks_qmessages"); 
            LoadLangauge();          
        } 
        
        void OnPlayerInit(BasePlayer player)
        {
            if(!quarryData.QD.ContainsKey(player.userID))
            {
                var info = new ExtraData();
                info.Name = player.displayName;
                info.NameID = player.userID;
                info.Code = 1234;
                info.CodeEnabled = false;
                info.MaxLogsAllowed = 10;
                info.MaxLogsFromPlayer = 2;
                info.HasAccess = new Dictionary<ulong, string>();   
                info.PlayersBlocked = new Dictionary<ulong, string>();   
                info.LogsFromPlayer = new Dictionary<ulong, NewLogsFromP>();
                quarryData.QD.Add(player.userID, info);     
                Interface.Oxide.DataFileSystem.WriteObject("quarrylocks_qdata", quarryData);                
            }
            if(!messageData.MD.ContainsKey(player.userID))
            {
                var info = new ExtraMessage();
                info.Name = player.displayName;
                info.NameID = player.userID;
                info.Messages = 0;
                info.HasAccessed = new List<string>();
                info.AttemptedAccess = new List<string>();
                messageData.MD.Add(player.userID, info);     
                Interface.Oxide.DataFileSystem.WriteObject("quarrylocks_qmessages", messageData);     
                return;
            } 
            return;  
        }
        
        void OnPlayerSleepEnded(BasePlayer player)
        {
            if(!messageData.MD.ContainsKey(player.userID) || !quarryData.QD.ContainsKey(player.userID)) OnPlayerInit(player);
            SaveData();
            PlayerAlertMessages(player);
        }
        
        //////////////////////////////////////////////////////////////////////////////////////
        // Langauge Handler
        //////////////////////////////////////////////////////////////////////////////////////  
        
        void OnServerSave()
        {
            SaveData(); 
        }        
        
        //////////////////////////////////////////////////////////////////////////////////////
        // Langauge Handler
        //////////////////////////////////////////////////////////////////////////////////////  
        
        void LoadLangauge()
        {
			lang.RegisterMessages(new Dictionary<string,string>{
                //Regular//
                ["QL_ACCESSEDQUARRY"] = "<color='{0}'>{1}:</color><color='{2}'> {3} accessed your quarry at time | {4}!</color>",
                ["QL_ATTEMPTEDACCESS"] = "<color='{0}'>{1}:</color><color='{2}'> {3} attempted to access your quarry at time | {4}.</color>",
                ["QL_MESSAGES"] = "<color='{0}'>{1}:</color><color='{2}'> You have {3} new messages.</color>",
                ["QL_TRIEDACCESS"] = "<color='{0}'>{1}:</color><color='{2}'>{3} just tried to access your quarry!</color>",
                ["QL_GUESSED"] = "<color='{0}'>{1}:</color><color='{2}'> {3} just attempted to guess your passcode!</color>",
                ["QL_JUSTGUESSED"] = "<color='{0}'>{1}:</color><color='{2}'> {3} has just guessed or entered your pass code!</color>",
                ["QL_NEWPASSCODE"] = "<color='{0}'>{1}:</color><color='{2}'> Your new pass code is {3}. Keep it safe!</color>",
                ["QL_ISACCESSING"] = "<color='{0}'>{1}:</color><color='{2}'> {3} is looting your quarry!</color>",
                ["QL_NOFRIENDS"] = "<color='{0}'>{1}:</color><color='{2}'> No one currently knows your quarry passcode!</color>",
                ["QL_FRIENDS"] = "<color='{0}'>{1}:</color><color='{2}'> {3} knows your passcode.</color>",
                ["QL_NOBLOCKED"] = "<color='{0}'>{1}:</color><color='{2}'> No one is currently blocked!</color>",
                ["QL_ISBLOCKED"] = "<color='{0}'>{1}:</color><color='{2}'> {3} is currently blocked!</color>",
                ["QL_CODE"] = "<color='{0}'>{1}:</color><color='{2}'> {3} is your current code!</color>",
                ["QL_MESSAGESCLEARED"] = "<color='{0}'>{1}:</color><color='{2}'> All of your messages have been cleared!</color>",
                ["QL_INCORRECTCODE"] = "<color='{0}'>{1}:</color><color='{2}'> Incorrect Passcode.</color>",
                ["QL_CORRECTCODE"] = "<color='{0}'>{1}:</color><color='{2}'> Correct Passcode.</color>",
                ["QL_DCODE"] = "<color='{0}'>{1}:</color><color='{2}'> You currently have no code!</color>",
                ["QL_CANNOTBLOCKSELF"] = "<color='{0}'>{1}:</color><color='{2}'> You may not block yourself as that would be silly :).</color>",
                ["QL_CANNOTGUESSOWNCODE"] = "<color='{0}'>{1}:</color><color='{2}'> You cannot guess your own code.</color>",
                ["QL_NOTENABLED"] = "<color='{0}'>{1}:</color><color='{2}'> {3} does not have their code enabled.</color>",
                ["QL_ISENABLED"] = "<color='{0}'>{1}:</color><color='{2}'> Your code is already enabled.</color>",
                ["QL_ENABLED"] = "<color='{0}'>{1}:</color><color='{2}'> Your have enabled your code lock by using {3} code locks.</color>",
                ["QL_MESSAGE"] = "<color='{0}'>{1}:</color><color='{2}'> {3}</color>",
                ["QL_ALERTMESSAGES"] = "<color='{0}'>{1}:</color><color='{2}'> You have {3} new messagse! Do /qlock rmessage to check them!</color>",
                ["QL_MAYNOTOPEN"] = "<color='{0}'>{1}:</color><color='{2}'> You may not open this mans quarry.</color>",
                ["QL_NOTENOUGHLOCKS"] = "<color='{0}'>{1}:</color><color='{2}'> You only had {3} out of the {4} needed to create a code lock for your quarry.</color>",
                ["QL_ALREADYBLOCKED"] = "<color='{0}'>{1}:</color><color='{2}'> {3} is already blocked!</color>",
                ["QL_BLOCKED"] = "<color='{0}'>{1}:</color><color='{2}'> {3} is now blocked!</color>",
                ["QL_CODEDISABLED"] = "<color='{0}'>{1}:</color><color='{2}'> Your code system was disabled and you have been refunded your code locks!</color>",
                ["QL_CANNOTSETTOCURRENT"] = "<color='{0}'>{1}:</color><color='{2}'> You may not set {3} to your current code as it is your current code!</color>",
                ["QL_ALREADYFRIEND"] = "<color='{0}'>{1}:</color><color='{2}'> You are already a friend of {3}.</color>",
                ["QL_MAXLOGSET"] = "<color='{0}'>{1}:</color><color='{2}'> Your max logs total is now set too {3}.</color>",
                ["QL_MAXPLAYERLOGSET"] = "<color='{0}'>{1}:</color><color='{2}'> Your max logs per player total is now set too {3}.</color>",
                ["QL_REMOVEDFROMBLOCKED"] = "<color='{0}'>{1}:</color><color='{2}'> {3} was removed from your blocked list.</color>",
                ["QL_NOTINBLOCKED"] = "<color='{0}'>{1}:</color><color='{2}'> {3} is not in your blocked list therefor you may not remove him/her.</color>",
                ["QL_TOOMANYNUMBERS"] = "<color='{0}'>{1}:</color><color='{2}'> You entered {3} numbers while {4} is only allowed. Try again!!!</color>",
                ["QL_CODENENABLED"] = "<color='{0}'>{1}:</color><color='{2}'> You do not have the code lock system enabled!</color>",
                //Help//
                ["QLH_FRIENDHELP"] = "<color='{0}'>{1}:</color><color='{2}'> /qlock friends - Returns anyone who knows your quarry code.</color>",
                ["QLH_BLOCKEDHELP"] = "<color='{0}'>{1}:</color><color='{2}'> /qlock blocked - Returns anyone who is blocked from your code.</color>",
                ["QLH_BLOCKHELP"] = "<color='{0}'>{1}:</color><color='{2}'> /qlock block (player) - Will block a player.</color>",
                ["QLH_UNBLOCKHELP"] = "<color='{0}'>{1}:</color><color='{2}'> /qlock unblock (player) - Will unblock a player.</color>",
                ["QLH_CODEHELP"] = "<color='{0}'>{1}:</color><color='{2}'> /qlock code - Returns your quarry code.</color>",
                ["QLH_CREATECODEHELP"] = "<color='{0}'>{1}:</color><color='{2}'> /qlock createcode - Creates a code for your quarrys if you have the correct locks(must do setcode afterwards).</color>",
                ["QLH_DISABLECODEHELP"] = "<color='{0}'>{1}:</color><color='{2}'> /qlock disablecode - Disables your code and refunds the code locks.</color>",
                ["QLH_SETCODEHELP"] = "<color='{0}'>{1}:</color><color='{2}'> /qlock setcode (newcode) - Sets your code to (NewCode) if your code is enabled.</color>",
                ["QLH_ENTERCODE"] = "<color='{0}'>{1}:</color><color='{2}'> /qlock entercode (player) (code) - Unlocks a quarry if you used the right code.</color>",
                ["QLH_HELP"] = "<color='{0}'>{1}:</color><color='{2}'> /qlock help - Gives you this help page.</color>",
                ["QLH_HELP2"] = "<color='{0}'>{1}:</color><color='{2}'> /qlock help2 - Gives you the second help page.</color>",
                //Help2//
                ["QLH_RMESSAGEHELP"] = "<color='{0}'>{1}:</color><color='{2}'> /qlock rmessage - Returns all of your current messages.</color>",
                ["QLH_CLEARMESSAGESHELP"] = "<color='{0}'>{1}:</color><color='{2}'> /qlock clearmessages - Clears all of your logs|messages.</color>",
                ["QLH_SETMAXLOGSHELP"] = "<color='{0}'>{1}:</color><color='{2}'> /qlock setmaxlogs (#) - Sets your max logs allowed to (#).</color>",
                ["QLH_SETMAXLOGS(P)HELP"] = "<color='{0}'>{1}:</color><color='{2}'> /qlock help - Gives you this help page.</color>",
			}, this);                
        } 
        
        private string GetMessage(string name, string sid = null) {
			return lang.GetMessage(name, this, sid);
		}              
        
        //////////////////////////////////////////////////////////////////////////////////////
        // SendReplyHelp
        //////////////////////////////////////////////////////////////////////////////////////        
        
        void SendReplyHelp(BasePlayer player)
        {
            SendReply(player, string.Format(GetMessage("QLH_FRIENDHELP", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"]));
            SendReply(player, string.Format(GetMessage("QLH_BLOCKEDHELP", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"]));
            SendReply(player, string.Format(GetMessage("QLH_BLOCKHELP", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"]));
            SendReply(player, string.Format(GetMessage("QLH_UNBLOCKHELP", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"]));
            SendReply(player, string.Format(GetMessage("QLH_CODEHELP", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"]));
            SendReply(player, string.Format(GetMessage("QLH_CREATECODEHELP", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"]));
            SendReply(player, string.Format(GetMessage("QLH_DISABLECODEHELP", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"]));
            SendReply(player, string.Format(GetMessage("QLH_SETCODEHELP", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"]));
            SendReply(player, string.Format(GetMessage("QLH_ENTERCODE", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"]));
            SendReply(player, string.Format(GetMessage("QLH_HELP", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"]));
            SendReply(player, string.Format(GetMessage("QLH_HELP2", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"]));
        }
        
        void SendReplyHelp2(BasePlayer player)
        {
            SendReply(player, string.Format(GetMessage("QLH_RMESSAGEHELP", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"]));
            SendReply(player, string.Format(GetMessage("QLH_CLEARMESSAGESHELP", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"]));
            SendReply(player, string.Format(GetMessage("QLH_SETMAXLOGSHELP", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"]));
            SendReply(player, string.Format(GetMessage("QLH_SETMAXLOGS(P)HELP", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"]));            
        }
        
        //////////////////////////////////////////////////////////////////////////////////////
        // FindPlayer(string arg)
        //////////////////////////////////////////////////////////////////////////////////////               
        
        private object FindPlayer(string arg)
        {
            var foundPlayers = new List<BasePlayer>();
            ulong steamid;
            ulong.TryParse(arg, out steamid);
            string lowerarg = arg.ToLower();

            foreach (var p in BasePlayer.activePlayerList)
            {
                if (steamid != 0L)
                    if (p.userID == steamid)
                    {
                        foundPlayers.Clear();
                        foundPlayers.Add(p);
                        return foundPlayers;
                    }
                string lowername = p.displayName.ToLower();
                if (lowername.Contains(lowerarg))
                {
                    foundPlayers.Add(p);
                }
            }
            return foundPlayers[0];
        } 
        
        //////////////////////////////////////////////////////////////////////////////////////
        // OnPlayerJoin alert.
        //////////////////////////////////////////////////////////////////////////////////////         
              
        void PlayerAlertMessages(BasePlayer player)
        {
            var totalalerts = messageData.MD[player.userID].HasAccessed.Count + messageData.MD[player.userID].AttemptedAccess.Count;
            SendReply(player, string.Format(GetMessage("QL_ALERTMESSAGES", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"], totalalerts));
            return;    
        }      
               
        //////////////////////////////////////////////////////////////////////////////////////
        // ChatCommands(qlock)
        ////////////////////////////////////////////////////////////////////////////////////// 
        
        [ChatCommand("qlock")]
        void cmdQLock(BasePlayer player, string command, string[] args)
        {
            if(args.Length == 0 || args.Length >= 5)
            {
                SendReplyHelp(player); 
                return;
            }              
            switch(args[0])
            {                        
                case "friends":
                    if(args.Length >= 2 || args.Length == 0){ SendReplyHelp(player); return; }
                    if(quarryData.QD[player.userID].HasAccess.Count >= 1)
                    {
                        foreach(var friend in quarryData.QD[player.userID].HasAccess)
                        {
                            SendReply(player, string.Format(GetMessage("QL_FRIENDS", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"], friend)); 
                            return;   
                        }    
                    }
                    else
                    {
                        SendReply(player, string.Format(GetMessage("QL_NOFRIENDS", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"]));
                        return;
                    }
                break;
                
                case "blocked":
                    if(args.Length >= 2 || args.Length == 0){ SendReplyHelp(player); return; }
                    if(quarryData.QD[player.userID].PlayersBlocked.Count >= 1)
                    {
                        foreach(var block in quarryData.QD[player.userID].PlayersBlocked)
                        {
                            SendReply(player, string.Format(GetMessage("QL_ISBLOCKED", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"], block)) ;   
                            return;
                        }    
                    }
                    else
                    {
                        SendReply(player, string.Format(GetMessage("QL_NOBLOCKED", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"]));
                        return;
                    }
                break;
                
                case "code":
                    if(args.Length >= 2 || args.Length == 0){ SendReplyHelp(player); return; }
                    if(quarryData.QD[player.userID].Code != 1111)
                    {
                        SendReply(player, string.Format(GetMessage("QL_CODE", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"], quarryData.QD[player.userID].Code));
                        return;    
                    }
                    else
                    {
                        SendReply(player, string.Format(GetMessage("QL_DCODE", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"]));   
                        return;
                    }
                break;
                
                case "setcode": 
                    if(args.Length >= 3 || args.Length == 0 || args.Length == 1)
                    {
                        SendReplyHelp(player);
                        return;
                    }                            
                    if(quarryData.QD[player.userID].CodeEnabled == false)
                    {
                        SendReply(player, string.Format(GetMessage("QL_CODENENABLED", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"]));   
                        return;
                    }
                    if(quarryData.QD[player.userID].Code == Convert.ToInt32(args[1]))
                    {
                        SendReply(player, string.Format(GetMessage("QL_CANNOTSETTOCURRENT", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"], args[1]));  
                        return;
                    }
                    if(args[1].Length >= 5)
                    {
                        SendReply(player, string.Format(GetMessage("QL_TOOMANYNUMBERS", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"], args[1].Length, 4));   
                        return;
                    }
                    var newCode = args[1];                   
                    quarryData.QD[player.userID].Code = Convert.ToInt32(newCode);
                    quarryData.QD[player.userID].HasAccess.Clear();
                    SaveData();
                    SendReply(player, string.Format(GetMessage("QL_NEWPASSCODE", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"], newCode));  
                break;
                
                case "entercode":
                    if(args.Length >= 4 || args.Length == 0 || args.Length == 2 || args.Length == 1)
                    {
                        SendReplyHelp(player);
                        return;
                    }
                    object addPlayer = FindPlayer(args[1]);             
                    BasePlayer target = (BasePlayer)addPlayer;                 
                    if(quarryData.QD[target.userID].HasAccess.ContainsKey(player.userID))
                    {
                        SendReply(player, string.Format(GetMessage("QL_ALREADYFRIEND", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"], target.displayName)); 
                        return;
                    }                                                              
                    var targetCode = quarryData.QD[target.userID].Code.ToString();
                    var guessCode = args[2];
                    if(target == player || player == target)
                    {
                        Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.denied.prefab", player.transform.position);
                        SendReply(player, string.Format(GetMessage("You may not enter your own code!", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"]));  
                        return;
                    }                        
                    if(quarryData.QD[target.userID].CodeEnabled)     
                    {
                        if(guessCode == targetCode)
                        {
                            quarryData.QD[target.userID].HasAccess.Add(player.userID, player.displayName);
                            SaveData();
                            SendReply(target, string.Format(GetMessage("QL_JUSTGUESSED", target.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"], target.displayName)); 
                            SendReply(player, string.Format(GetMessage("QL_CORRECTCODE", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"])); 
                            Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.updated.prefab", player.transform.position);
                            Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.updated.prefab", target.transform.position);
                            return;     
                        }
                        else
                        {
                            SendReply(target, string.Format(GetMessage("QL_INCORRECTCODE", target.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"]));
                            timer.Repeat(0.1f, Convert.ToInt32(Config["HealthWrong"]), () => player.health--); 
                            Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.denied.prefab", player.transform.position);
                            foreach( var p in BasePlayer.activePlayerList )
                            {
                                try 
                                {
                                    if(target = p)
                                    {
                                        SendReply(target, string.Format(GetMessage("QL_GUESSED", target.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"], player.displayName)); 
                                        return;                                              
                                    }
                                    else 
                                    {
                                        return;
                                    }    
                                }
                                catch
                                {
                                    messageData.MD[target.userID].AttemptedAccess.Add(string.Format(GetMessage("GL_AAADD", target.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"], player.displayName, DateTime.Now.ToString("h:mm tt")));
                                    messageData.MD[target.userID].Messages++;
                                    return;                                     
                                }
                            }  
                        }
                    }
                    else
                    {
                        SendReply(target, string.Format(GetMessage("QL_NOTENABLED", target.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"], target.displayName));
                        return;
                    }                             
                break;
                
                case "createcode":
                    if(args.Length >= 2 || args.Length == 0){ SendReplyHelp(player); return; }
                    if(quarryData.QD[player.userID].CodeEnabled)
                    {
                        SendReply(player, string.Format(GetMessage("QL_ISENABLED", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"]));
                        return;                        
                    }
                    else
                    {
                        int codelocks = player.inventory.GetAmount(-975723312);
                        if(codelocks >= Convert.ToInt32(Config["CodeLocksNeeded"]))
                        {
                            player.inventory.Take(null, -975723312, Convert.ToInt32(Config["CodeLocksNeeded"]));
                            SendReply(player, string.Format(GetMessage("QL_ENABLED", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"], Config["CodeLocksNeeded"].ToString()));
                            quarryData.QD[player.userID].CodeEnabled = true; 
                            SaveData();
                            return;   
                        }
                        else
                        {
                            SendReply(player, string.Format(GetMessage("QL_NOTENOUGHLOCKS", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"], codelocks , Convert.ToInt32(Config["CodeLocksNeeded"])));
                            return;    
                        } 
                    }
                break;
                
                case "block":
                    if(args.Length >= 3 || args.Length == 0 || args.Length == 1)
                    {
                        SendReplyHelp(player);
                        return;
                    }                               
                    object newPlayer = FindPlayer(args[1]);             
                    BasePlayer blocker = (BasePlayer)newPlayer;   
                    if(blocker == player || player == blocker)
                    {
                        Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.denied.prefab", player.transform.position);
                        SendReply(player, string.Format(GetMessage("QL_CANNOTBLOCKSELF", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"]));  
                        return;
                    }                                             
                    if(quarryData.QD[player.userID].PlayersBlocked.ContainsKey(player.userID))
                    {
                        SendReply(player, string.Format(GetMessage("QL_ALREADYBLOCKED", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"], blocker.displayName));
                        return; 
                    }  
                    else
                    {
                        quarryData.QD[player.userID].PlayersBlocked.Add(player.userID, player.displayName);   
                        SendReply(player, string.Format(GetMessage("QL_BLOCKED", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"], blocker.displayName));
                        SaveData();
                    }              
                break;
                
                case "rmessage":
                    if(args.Length >= 2 || args.Length == 0){ SendReplyHelp(player); return; }
                    SendReply(player, "<color='#66ff33'>Tried Access:</color>");
                    foreach(var m in messageData.MD[player.userID].AttemptedAccess)
                    {
                        SendReply(player, string.Format(GetMessage("QL_MESSAGE", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"], m));
                    }
                    SendReply(player, "<color='#66ff33'>Has Accessed:</color>");
                    foreach(var mm in messageData.MD[player.userID].HasAccessed)
                    {
                        SendReply(player, string.Format(GetMessage("QL_MESSAGE", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"], mm));    
                    }
                break;
                
                case "unblock":
                    if(args.Length >= 3 || args.Length == 0 || args.Length == 1){ SendReplyHelp(player); return; }
                    else
                    {
                        object removePlayer = FindPlayer(args[1]);             
                        BasePlayer unblock = (BasePlayer)removePlayer;  
                        
                        if(quarryData.QD[player.userID].PlayersBlocked.ContainsKey(unblock.userID))
                        {
                            SendReply(player, string.Format(GetMessage("QL_REMOVEDFROMBLOCKED", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"], unblock.displayName)); 
                            quarryData.QD[player.userID].PlayersBlocked.Remove(unblock.userID);
                            SaveData();
                        }  
                        else
                        {
                            SendReply(player, string.Format(GetMessage("QL_NOTINBLOCKED", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"], args[1])); 
                            return;   
                        }                          
                    }
                break;
                
                case "setmaxlogs":
                if(args.Length >= 3 || args.Length == 0 || args.Length == 1){ SendReplyHelp(player); return; }
                    quarryData.QD[player.userID].MaxLogsAllowed = Convert.ToInt32(args[1]);
                    SaveData();
                    SendReply(player, string.Format(GetMessage("QL_MAXLOGSET", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"], args[1]));   
                break;
                
                case "setmaxlogs(p)":
                if(args.Length >= 3 || args.Length == 0 || args.Length == 1){ SendReplyHelp(player); return; }
                    quarryData.QD[player.userID].MaxLogsFromPlayer = Convert.ToInt32(args[1]);
                    SaveData();
                    SendReply(player, string.Format(GetMessage("QL_MAXPLAYERLOGSET", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"], args[1]));                       
                break;
                
                case "disablecode":
                    if(quarryData.QD[player.userID].CodeEnabled == false)
                    {
                        SendReply(player, string.Format(GetMessage("QL_CODENENABLED", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"]));   
                        return;
                    }
                    else
                    {
                        SendReply(player, string.Format(GetMessage("QL_CODEDISABLED", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"])); 
                        quarryData.QD[player.userID].CodeEnabled = false;
                        SaveData();
                        player.inventory.GiveItem(ItemManager.CreateByName("lock.code", Convert.ToInt32(Config["CodeLocksNeeded"])), player.inventory.containerMain);
                        return;
                    }                    
                break;
                
                case "clearmessages":
                    messageData.MD[player.userID].AttemptedAccess.Clear();
                    messageData.MD[player.userID].HasAccessed.Clear();
                    quarryData.QD[player.userID].LogsFromPlayer.Clear();
                    SendReply(player, string.Format(GetMessage("QL_MESSAGESCLEARED", player.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"])); 
                    SaveData();
                break;
                
                case "help":
                    SendReplyHelp(player);
                    return;
                break;
                
                case "help2":
                    SendReplyHelp2(player);
                    return;
                break;
                
                default:
                    SendReplyHelp(player);
                    return;
                break;
            }    
        } 
        
        
        
        [HookMethod("OnLootEntity")]
        void OnLootEntity(BasePlayer looter, BaseEntity entry)
        {
            try 
            {
                if (entry is ResourceExtractorFuelStorage)
                {
                    List<BaseEntity> nearby = new List<BaseEntity>();
                    Vis.Entities(entry.transform.position, 2, nearby);
                    MiningQuarry quarry = null;
                    foreach (var ent in nearby)               
                        if (ent is MiningQuarry)
                            quarry = ent.GetComponent<MiningQuarry>();
                            
                    if(quarry.OwnerID == null) return;
                    BasePlayer owner = BasePlayer.FindByID(quarry.OwnerID);                           
                    if (quarry != null)
                    {
                        if (looter.userID == owner.userID || quarryData.QD[owner.userID].HasAccess.ContainsKey(looter.userID) && !quarryData.QD[owner.userID].PlayersBlocked.ContainsKey(looter.userID))
                        {
                            if(looter.userID != owner.userID)
                            {
                                if(quarryData.QD[owner.userID].LogsFromPlayer.ContainsKey(looter.userID))
                                {
                                    if(quarryData.QD[owner.userID].LogsFromPlayer[looter.userID].Logs < quarryData.QD[owner.userID].MaxLogsFromPlayer && quarryData.QD[owner.userID].LogsFromPlayer[looter.userID].Logs < quarryData.QD[owner.userID].MaxLogsAllowed)
                                    {
                                        quarryData.QD[owner.userID].LogsFromPlayer[looter.userID].Logs++;
                                        SendReply(owner, string.Format(GetMessage("QL_ACCESSEDQUARRY", owner.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"], looter.displayName, DateTime.Now.ToString("h:mm tt")));
                                        messageData.MD[owner.userID].HasAccessed.Add(string.Format(GetMessage("QL_ACCESSEDQUARRY", owner.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"], looter.displayName, DateTime.Now.ToString("h:mm tt"))); 
                                        SaveData();                                        
                                    }
                                    else
                                    {
                                        SendReply(owner, string.Format(GetMessage("QL_ACCESSEDQUARRY", owner.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"], looter.displayName, DateTime.Now.ToString("h:mm tt")));
                                        return;
                                    }    
                                }
                                else
                                {
                                    messageData.MD[owner.userID].HasAccessed.Add(string.Format(GetMessage("QL_ACCESSEDQUARRY", owner.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"], looter.displayName, DateTime.Now.ToString("h:mm tt")));   
                                    quarryData.QD[owner.userID].LogsFromPlayer.Add(looter.userID, new NewLogsFromP());
                                    quarryData.QD[owner.userID].LogsFromPlayer[looter.userID].Logs = 1;
                                    SaveData();
                                }                                                    
                            }                        
                        }
                        else
                        {
                            if (owner != null)
                            {
                                SendReply(looter, string.Format(GetMessage("QL_MAYNOTOPEN", looter.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"]));
                                NextTick(() =>
                                {
                                    looter.EndLooting();    
                                });
                                NextTick(() =>
                                {
                                    looter.EndLooting();    
                                });
                                NextTick(() =>
                                {
                                    looter.EndLooting();    
                                });
                                if(quarryData.QD[owner.userID].LogsFromPlayer.ContainsKey(looter.userID))
                                {
                                    if(quarryData.QD[owner.userID].LogsFromPlayer[looter.userID].Logs != quarryData.QD[owner.userID].MaxLogsFromPlayer && quarryData.QD[owner.userID].MaxLogsAllowed != quarryData.QD[owner.userID].LogsFromPlayer[looter.userID].Logs)
                                    {
                                        quarryData.QD[owner.userID].LogsFromPlayer[looter.userID].Logs++;
                                        messageData.MD[owner.userID].AttemptedAccess.Add(string.Format(GetMessage("QL_ATTEMPTEDACCESS", owner.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"], looter.displayName, DateTime.Now.ToString("h:mm tt")));   
                                        SaveData();  
                                        return;                                      
                                    }
                                    else
                                    {
                                        SendReply(owner, string.Format(GetMessage("QL_ATTEMPTEDACCESS", owner.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"], looter.displayName, DateTime.Now.ToString("h:mm tt")));
                                        return;
                                    }    
                                }
                                else
                                {
                                    messageData.MD[owner.userID].HasAccessed.Add(string.Format(GetMessage("ATTEMPTEDACCESS", owner.UserIDString), Config["ChatPrefixColor"], Config["ChatPrefix"], Config["ChatColor"], looter.displayName, DateTime.Now.ToString("h:mm tt")));   
                                    quarryData.QD[owner.userID].LogsFromPlayer.Add(looter.userID, new NewLogsFromP());
                                    quarryData.QD[owner.userID].LogsFromPlayer[looter.userID].Logs = 1;
                                    SaveData();
                                    return;
                                }                                                        
                            }
                            return;
                        }
                    }
                }                
            }
            catch(System.Exception)
            {
                return;                                
            }
        }              
    }
}

// --- End of file: QuarryLocks.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RaidBlock.cs ---
// --- Original Local Path: RaidBlock.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using ConVar;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using UnityEngine;
using VLB;
using Oxide.Plugins.RaidBlockExt;
using UnityEngine.Networking;
using Layer = Rust.Layer;
using Pool = Facepunch.Pool;
using Time = UnityEngine.Time;

namespace Oxide.Plugins
{
	[Info("RaidBlock", "Mercury", "1.1.24")]
	public class RaidBlock : RustPlugin
	{
        /// <summary>
        /// - Исправлена проблема с блокировкой комманд. Нужно заного заполнить команды в конфигурации. без слэша в нижнем регистре
        /// - Добавлена поддержка плагина RaidableBases - настраивается в конфигурации.
        /// </summary>
        
        #region ReferencePlugins

        [PluginReference] Plugin Friends, Clans, IQChat;
        
        #region IQChat

        private List<BasePlayer> playerInCache = new();
        private void SendChat(string message, BasePlayer player, Single timeout = 0f, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            if (playerInCache.Contains(player)) return;
            if (timeout != 0)
            {
                playerInCache.Add(player);
                player.Invoke(() => playerInCache.Remove(player), timeout);
            }
            
            Configuration.IQChat chat = config.IQChatSetting;
            if (IQChat)
                if (chat.UIAlertUse)
                    IQChat?.Call("API_ALERT_PLAYER_UI", player, message);
                else IQChat?.Call("API_ALERT_PLAYER", player, message, chat.CustomPrefix, chat.CustomAvatar);
            else player.SendConsoleCommand("chat.add", channel, 0, message);
        }
        #endregion
        
        private bool IsFriends(BasePlayer player, ulong targetID)
        {
            ulong[] friendList = GetFriendList(player);
            return friendList != null && friendList.Contains(targetID);
        }
        
        private ulong[] GetFriendList(BasePlayer targetPlayer)
        {
            List<ulong> friendList = new();
            if (Friends)
            {
                if (Friends.Call("GetFriends", targetPlayer.userID) is ulong[] friends)
                    friendList.AddRange(friends);
            }
            
            if (Clans)
            {
                if (Clans.Call("GetClanMembers", targetPlayer.UserIDString) is ulong[] clanMembers)
                    friendList.AddRange(clanMembers);
            }

            if(targetPlayer.Team != null)
                friendList.AddRange(targetPlayer.Team.members);

            return friendList.ToArray();
        }

        #endregion

        #region Var
        
        public static RaidBlock Instance;

        private static InterfaceBuilder _interface;
        private List<RaidableZone> _raidZoneComponents = new(); 
        private static ImageUI _imageUI;
        private const Boolean LanguageEn = true;
        
        private const string GENERIC_MAP_MARKER_PREFAB = "assets/prefabs/tools/map/genericradiusmarker.prefab";
        private const string EXPLOSION_MAP_MARKER_PREFAB = "assets/prefabs/tools/map/explosionmarker.prefab";
        private const string VENDING_MAP_MARKER_PREFAB = "assets/prefabs/deployable/vendingmachine/vending_mapmarker.prefab";
        private const string VISUALIZATION_SPHERE_PREFAB = "assets/prefabs/visualization/sphere.prefab";
        
        private const string VISUALIZATION_BR_SPHERE_PREFAB_BLUE = "assets/bundled/prefabs/modding/events/twitch/br_sphere.prefab";
        private const string VISUALIZATION_BR_SPHERE_PREFAB_GREEN = "assets/bundled/prefabs/modding/events/twitch/br_sphere_green.prefab";
        private const string VISUALIZATION_BR_SPHERE_PREFAB_PURPLE = "assets/bundled/prefabs/modding/events/twitch/br_sphere_purple.prefab";
        private const string VISUALIZATION_BR_SPHERE_PREFAB_RED = "assets/bundled/prefabs/modding/events/twitch/br_sphere_red.prefab";
        
        private const string RB_WHITE_AND_BLACK_LIST_ITEM = "toolgun";
        private const ulong RB_WHITELIST_ITEM_SKIN = 3100653846;
        private const ulong RB_BLACKLIST_ITEM_SKIN = 3100653751;
        
        private readonly string _permIgnoreRaid = ".ignore";
        private readonly string _permHelperToolGun = ".toolgun";


        #endregion

        #region Types

        private enum SphereTypes
        {
            BlackSphere,
            BRSphere,
        }
        
        private enum BRZoneColor
        {
            Blue,
            Green,
            Purple,
            Red
        }
        
        private enum MarkerTypes
        {
            Explosion,
            MarkerRadius,
            ExplosionMarkerRadius,
            MarkerRadiusTimer,
        }

        #endregion

        #region Configuration
        private Configuration config;

        private class Configuration
        {
            public class IQChat
            {
                [JsonProperty(LanguageEn ? "IQChat : Custom prefix in the chat" : "IQChat : Кастомный префикс в чате")]
                public String CustomPrefix = "[RaidBlock]";
                [JsonProperty(LanguageEn ? "IQChat : Custom avatar in the chat (If required)" : "IQChat : Кастомный аватар в чате(Если требуется)")]
                public String CustomAvatar = "0";
                [JsonProperty(LanguageEn ? "IQChat : Use UI notifications" : "IQChat : Использовать UI уведомления")]
                public Boolean UIAlertUse = false;
            }
            
            public class RaidableBases
            {
                [JsonProperty(LanguageEn ? "RaidableBases: Enable support for Raidable Bases?" : "RaidableBases : Включить поддержку Raidable Bases ?")]
                public bool useRaidableBases = false;
                [JsonProperty(LanguageEn ? "RaidableBases: Blocking time (Seconds)" : "RaidableBases: Время блокировки (Секунды)")]
                public int RaidBlockDuration = 600;
                [JsonProperty(LanguageEn ? "RaidableBases : Give a raid block when entering the Raidable Bases zone" : "RaidableBases : Давать рейд блок при входе в зону Raidable Bases")]
                public bool BlockOnEnterZone = false;
                [JsonProperty(LanguageEn ? "RaidableBases : Remove the raid block when leaving the Raidable Bases zone" : "RaidableBases : Снимать рейд блок при выходе из зоны Raidable Bases")]
                public bool BlockOnExitZone = false;
            }
            public class RaidBlockActionsBlocked
            {
                [JsonProperty(LanguageEn ? "Forbid building repair" : "Запретить починку строений")]
                public bool CanRepairObjects = true;
                [JsonProperty(LanguageEn ? "Forbid picking up items (furnaces, boxes, etc.)" : "Запретить поднятие вещей (печки/ящики и т.д)")]
                public bool CanPickUpObjects = false;
                [JsonProperty(LanguageEn ? "Forbid upgrading buildings" : "Запретить улучшение строений")]
                public bool CanUpgradeObjects = true;
                [JsonProperty(LanguageEn ? "Forbid building removal" : "Запретить удаление строений")]
                public bool CanDemolishObjects = true;
                [JsonProperty(LanguageEn ? "Forbid teleportation" : "Запретить телепортацию")]
                public bool CanUseTeleport = true;
                [JsonProperty(LanguageEn ? "Forbid the use of kits" : "Запретить использование китов")]
                public bool CanUseKit = true;
                [JsonProperty(LanguageEn ? "Forbid the use of trade" : "Запретить использование обмена (Trade)")]
                public bool CanUseTrade = true;
                [JsonProperty(LanguageEn ? "Allow building" : "Запретить строение")] 
                public bool CanBuildTwig = true;
                [JsonProperty(LanguageEn ? "Allow object placement (furnaces, boxes, etc.)" : "Запретить размещение объектов (Печки, ящики и другое)")]
                public bool CanDeployObjects = false;
                [JsonProperty(LanguageEn ? "List of objects allowed to build/place during the raidblock (shortname)" : "Список объектов, которые разрешено строить/размещать во время рейдблока (PrefabName)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public List<string> RbDeployWhiteList = new()
                {
                    "bed_deployed",
                    "ladder.wooden.wall",
                };
                [JsonProperty(LanguageEn ? "List of prohibited commands when blocking is active [specify them without a slash (/) in lower case]" : "Список запрещенных команд при активной блокировки [указывайте их без слэша (/) в нижнем регистре]", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public List<string> RbBlackListCommand = new()
                {
                    "commandexample",
                };
            }
            public class RaidBlockDetect
            {
                [JsonProperty(LanguageEn ? "List of items that will trigger a raid block upon destruction (prefabID)" : "Список предметов за которые при уничтожении будет даваться рейдблок (prefabID)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public HashSet<uint> RbBlackList = new()
                {
                    12312312,
                };
                [JsonProperty(LanguageEn ? "List of items that will not trigger a raid block upon destruction (prefabID)" : "Список предметов за которые при уничтожении не будет даваться рейдблок (prefabID)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public HashSet<uint> RbWhiteList = new()
                {
                    1231223,
                };
                [JsonProperty(LanguageEn ? "Ignore objects with a maximum health state less than N (0 - disabled)" : "Игнорировать объекты с максимальным состоянием здоровья меньше N (0 - отключено)")]
                public int IgnoreEntsHealth = 0;
                [JsonProperty(LanguageEn ? "Activate raidblock upon the destruction of own or friends' buildings" : "Активировать рейдблок при уничтожении собственного строения или строения друзей")]
                public bool RaidYourself = false;
                [JsonProperty(LanguageEn ? "Activate raidblock if there is no tool cupboard in the building" : "Активировать рейдблок если в строении нет шкафа")]
                public bool CanRaidIfNotCupboard = false;
            }

            public class RaidBlock
            {
                [JsonProperty(LanguageEn ? "Radius of blocking zone (Meters)" : "Радиус зоны блокировки (Метры)")]
                public int RaidBlockDistance = 130;
                [JsonProperty(LanguageEn ? "Blocking time (Seconds)" : "Время блокировки (Секунды)")]
                public int RaidBlockDuration = 300;
                [JsonProperty(LanguageEn ? "Use dynamic raid zone (shift the zone center to the explosion location)" : "Использовать динамичную зону рейда (смещение центра зоны к месту взрыва)")]
                public bool IsDynamicRaidZone = false;
                [JsonProperty(LanguageEn ? "Spread raidblock to all team players" : "Распространять рейд блок на всех игроков в команде инициатора рейда")]
                public bool RaidBlockShareOnFriends = true; 
                [JsonProperty(LanguageEn ? "When entering the active raid block zone, activate the player raid block" : "При входе в активную зону рейдблока - активировать рейдблок игроку")]
                public bool RaidBlockOnEnterRaidZone = true;
                [JsonProperty(LanguageEn ? "Upon exiting the raid block zone, deactivate the raid block for the player" : "При выходе из зоны рейдблока - деактивировать рейдблок игроку")]
                public bool RaidBlockOnExitRaidZone = false;
                [JsonProperty(LanguageEn ? "When exiting the raid block zone, leave a lock for N seconds (leave 0 if you don't need it)" : "При выходе из зоны рейдблока - оставлять N секунд блокировки (оставьте 0 - если вам не нужно это)")] 
                public Int32 TimeLeftOnExitZone = 0;
                [JsonProperty(LanguageEn ? "Activate raid block for all players within the effective radius after the raid starts" : "Активировать рейдблок для всех игроков в радиусе действия после начала рейда")]
                public bool RaidBlockAddedAllPlayersInZoneRaid = true;
                [JsonProperty(LanguageEn ? "Deactivate the raid block for the player upon death" : "Деактивировать рейдблок игроку после смерти")]
                public bool RaidBlockOnPlayerDeath = true;
                [JsonProperty(LanguageEn ? "Raid zone map marker settings" : "Настройки маркера на карте в зоне рейда")]
                public MapMarkerSettings mapMarkerSettings = new();
                [JsonProperty(LanguageEn ? "Visual raid zone (Dome) settings" : "Настройка визуальной зоны рейда (купол)")]
                public SphereSettings RaidZoneSphereSettings = new();
                [JsonProperty(LanguageEn ? "Integration settings with RaidableBases" : "Настройки интеграции с RaidableBases")]
                public RaidableBases RaidableBasesIntegration = new();

                public class SphereSettings
                {
                    [JsonProperty(LanguageEn ? "Activate visual raid zone (Dome)" : "Активировать визуальную зону рейда (купол)")]
                    public bool IsSphereEnabled = false;
                    [JsonProperty(LanguageEn ? "Choose marker type: 0 - standard dome, 1 - BattleRoyale dome" : "Выберете тип купола : 0 - cтандартный купол, 1 - BattleRoyale купол")]
                    public SphereTypes SphereType = SphereTypes.BlackSphere;
                    [JsonProperty(LanguageEn ? "Color for BattleRoyale dome: 0 - blue | 1 - green | 2 - purple | 3 - red" : "Цвет для BattleRoyale купола : 0 - blue | 1 - green | 2 - purple | 3 - red")]
                    public BRZoneColor BRZoneColor = BRZoneColor.Blue;
                    [JsonProperty(LanguageEn ? "Transparency level of the standard dome (Lower values mean more transparency. The value should not exceed 5)" : "Уровень прозрачности стандартного купола (Чем меньше - тем прозрачнее. Значения должно быть не более 5)")]
                    public int DomeTransparencyLevel = 3;
                    
                    public string GetBRZonePrefab()
                    {
                        return BRZoneColor switch
                        {
                            BRZoneColor.Blue => VISUALIZATION_BR_SPHERE_PREFAB_BLUE,
                            BRZoneColor.Green => VISUALIZATION_BR_SPHERE_PREFAB_GREEN,
                            BRZoneColor.Purple => VISUALIZATION_BR_SPHERE_PREFAB_PURPLE,
                            BRZoneColor.Red => VISUALIZATION_BR_SPHERE_PREFAB_RED,
                            _ => throw new ArgumentOutOfRangeException(nameof(BRZoneColor), BRZoneColor, null)
                        };
                    }
                }
                
                public class MapMarkerSettings
                {
                    [JsonProperty(LanguageEn ? "Display the block zone on the G map" : "Отображать зону блокировки на G карте")]
                    public bool IsRaidBlockMarkerEnabled = true;
                    [JsonProperty(LanguageEn ? "Choose marker type: 0 - Explosion, 1 - Circle, 2 - Explosion + Circle, 3 - Circle + Timer" : "Выберите тип маркера: 0 - Explosion | 1 - Marker Radius | 2 - Explosion + Marker Radius | 3 - Marker Radius + Timer")]
                    public MarkerTypes RaidBlockMarkerType = MarkerTypes.ExplosionMarkerRadius;
                    [JsonProperty(LanguageEn ? "Marker color (without #) (For marker types 1, 2, and 3)" : "Цвет маркера (без #) (Для маркера типа 1, 2 и 3)")]
                    public string MarkerColorHex = "f3ecad";
                    [JsonProperty(LanguageEn ? "Outline color (without #) (For marker types 1, 2, and 3)" : "Цвет обводки (без #) (Для маркера типа 1, 2 и 3)")]
                    public string OutlineColorHex = "ff3535";
                    [JsonProperty(LanguageEn ? "Marker transparency (For marker types 1, 2, and 3)" : "Прозрачность маркера (Для маркера типа 1, 2 и 3)")]
                    public float MarkerAlpha = 0.5f;
                }
            }
            
            public class RaidBlockUi
            {
                [JsonProperty(LanguageEn ? "Interface variant (0, 1, 2) - example: " : "Вариант интерфейса (0, 1, 2)")]
                public int UiType = 0;
                [JsonProperty(LanguageEn ? "Interface layer: Overlay - will overlay other UI, Hud - will be overlaid by other interfaces" : "Слой интерфейса : Overlay - будет перекрывать другие UI, Hud - будет перекрываться другим интерфейсом")]
                public string Layers = "Hud";
                [JsonProperty(LanguageEn ? "Vertical padding" : "Вертикальный отступ")]
                public int OffsetY = 0;
                [JsonProperty(LanguageEn ? "Horizontal padding" : "Горизонтальный отступ")]
                public int OffsetX = 0;
                
                [JsonProperty(LanguageEn ? "Interface settings for variant 0" : "Настройки интерфейса для варианта 0")]
                public RaidBlockUiSettings InterfaceSettingsVariant0 = new()
                {
                    BackgroundColor = "0.19 0.19 0.19 1",
                    IconColor = "0 0.77 1 1",
                    AdditionalElementsColor = "",
                    MainTextColor = "1 1 1 1",
                    SecondaryTextColor = "1 1 1 0.50",
                    ProgressBarMainColor = "0.34 0.54 0.96 1",
                    ProgressBarBackgroundColor = "1 1 1 0.10",
                    SmoothTransition = 0.22f,
                };
                
                [JsonProperty(LanguageEn ? "Interface settings for variant 1" : "Настройки интерфейса для варианта 1")]
                public RaidBlockUiSettings InterfaceSettingsVariant1 = new()
                {
                    BackgroundColor = "0.96 0.77 0.73 0.70",
                    IconColor = "1 1 1 1",
                    AdditionalElementsColor = "0.92 0.30 0.17 1",
                    MainTextColor = "0.19 0.19 0.19 1",
                    SecondaryTextColor = "0.13 0.13 0.13 1",
                    ProgressBarMainColor = "0.92 0.30 0.17 1",
                    ProgressBarBackgroundColor = "1 1 1 0.41",
                    SmoothTransition = 0.22f
                };
                
                [JsonProperty(LanguageEn ? "Interface settings for variant 2" : "Настройки интерфейса для варианта 2")]
                public RaidBlockUiSettings InterfaceSettingsVariant2 = new()
                {
                    BackgroundColor = "0.19 0.19 0.19 1",
                    IconColor = "0.94 0.31 0.28 1",
                    AdditionalElementsColor = "0.95 0.36 0.26 1",
                    MainTextColor = "1 1 1 1",
                    SecondaryTextColor = "1 1 1 0.50",
                    ProgressBarMainColor = "1 1 1 1",
                    ProgressBarBackgroundColor = "1 1 1 0.41",
                    SmoothTransition = 0.22f
                };
                
                public class RaidBlockUiSettings
                {
                    [JsonProperty(LanguageEn ? "Background color (RGBA)" : "Цвет фона (RGBA)")]
                    public string BackgroundColor;
                    [JsonProperty(LanguageEn ? "Icon color (RGBA)" : "Цвет иконки (RGBA)")]
                    public string IconColor;
                    [JsonProperty(LanguageEn ? "Color of additional elements (RGBA)" : "Цвет дополнительных элементов (RGBA)")]
                    public string AdditionalElementsColor;
                    [JsonProperty(LanguageEn ? "Main text color (RGBA)" : "Цвет основного текста (RGBA)")]
                    public string MainTextColor;
                    [JsonProperty(LanguageEn ? "Secondary text Color (RGBA)" : "Цвет второстепенного текста (RGBA)")]
                    public string SecondaryTextColor;
                    [JsonProperty(LanguageEn ? "Main color of the progress-bar (RGBA)" : "Основной цвет прогресс-бара (RGBA)")]
                    public string ProgressBarMainColor;
                    [JsonProperty(LanguageEn ? "Background Color of the Progress Bar (RGBA)" : "Цвет фона прогресс-бара (RGBA)")]
                    public string ProgressBarBackgroundColor;
                    [JsonProperty(LanguageEn ? "Delay before the UI appears and disappears (for smooth transitions)" : "Задержка перед появлением и исчезновением UI (для плавности)")]
                    public float SmoothTransition;
                }
            }
            
            [JsonProperty(LanguageEn ? "Main raidblock settings" : "Основные настройки рейд-блока")] 
            public RaidBlock RaidBlockMain = new();
            [JsonProperty(LanguageEn ? "Setting up triggers for the raidblock" : "Настройка триггеров для рейдблока")] 
            public RaidBlockDetect BlockDetect = new();
            [JsonProperty(LanguageEn ? "Setting restrictions during the raid block" : "Настройка ограничений во время рейдблока")] 
            public RaidBlockActionsBlocked ActionsBlocked = new();
            [JsonProperty(LanguageEn ? "Interface settings" : "Настройки интерфейса")] 
            public RaidBlockUi RaidBlockInterface = new();
            [JsonProperty(LanguageEn ? "Setting IQChat" : "Настройка IQChat")]
            public IQChat IQChatSetting = new IQChat();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new Exception();
                }

                SaveConfig();
            }
            catch
            {
                for (int i = 0; i < 3; i++)
                {
                    PrintError(LanguageEn ? "Configuration file is corrupt! Check your config file at https://jsonlint.com/" : "Вы допустили ошибку синтаксиса в конфигурационном файле! Проверьте файл на https://jsonlint.com/");
                }

                LoadDefaultConfig();
            }
            ValidateConfig();
            SaveConfig();
        }

        private void ValidateConfig()
        {
            if (config.RaidBlockMain.RaidZoneSphereSettings.DomeTransparencyLevel > 5)
            {
                config.RaidBlockMain.RaidZoneSphereSettings.DomeTransparencyLevel = 3;
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        protected override void LoadDefaultConfig()
        {
            config = new Configuration();
        }
        #endregion  
        
        #region Lang
		
		protected override void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			{
                ["RAIDBLOCK_ACTION_BLOCKED"] = "You are not allowed to perform this action during a raid. Please wait {0}.",
                ["RAIDBLOCK_ENTER_RAID_ZONE"] = "You have entered the raid zone! Some features will be restricted for {0}.",
                ["RAIDBLOCK_EXIT_RAID_ZONE"] = "You have exited the raid zone! Features are now unlocked.",
                ["RAIDBLOCK_END_RAID"] = "The block has been deactivated. Features are now unlocked.",
                ["RAIDBLOCK_ENTER_RAID_INITIATOR"] = "You destroyed someone else's object! Raid block activated for {0}.\nSome features are temporarily unavailable.",
                ["RAIDBLOCK_OWNER_NOTIFY"] = "Your base in quadrant {0} has been raided!",
                ["RAIDBLOCK_UI_IN_RAIDZONE"] = "YOU ARE IN THE RAID ZONE",
                ["RAIDBLOCK_UI_TIMER"] = "Time left: {0}",
                ["RAIDBLOCK_UI_TITLE"] = "RAID BLOCK",
                ["RAIDBLOCK_UI_DESCRIPTIONS_V1"] = "It seems that you are being raided, and some features have been restricted.",
                ["RAIDBLOCK_UI_DESCRIPTIONS_V2"] = "Some features have been disabled.",
                ["RAIDBLOCK_KILL_PLAYER"] = "You were killed! Functions are unlocked.",
                ["RAIDBLOCK_TOOLGUN_BLACKLIST_ITEM_NAME"] = "RAID BLOCK - BLACK LIST",
                ["RAIDBLOCK_TOOLGUN_WHITELIST_ITEM_NAME"] = "RAID BLOCK - WHITE LIST",
                ["RAIDBLOCK_TOOLGUN_PERMISSION_DENIED"] = "You do not have permission to use this command",
                ["RAIDBLOCK_TOOLGUN_ALREADY_IN_INVENTORY"] = "You already have '<color=#FFA500>ToolGun - {0}</color>' in your inventory",
                ["RAIDBLOCK_TOOLGUN_REMOVED_FROM_WHITELIST"] = "The item '<color=#FF6347>{0} ({1})</color>' has been removed from the whitelist",
                ["RAIDBLOCK_TOOLGUN_ADDED_TO_WHITELIST"] = "The item '<color=#00FF7F>{0} ({1})</color>' has been added to the whitelist",
                ["RAIDBLOCK_TOOLGUN_REMOVED_FROM_BLACKLIST"] = "The item '<color=#FF3232>{0} ({1})</color>' has been removed from the blacklist",
                ["RAIDBLOCK_TOOLGUN_ADDED_TO_BLACKLIST"] = "The item '<color=#00FF7F>{0} ({1})</color>' has been added to the blacklist",
                ["RAIDBLOCK_TOOLGUN_BLACKLIST_USAGE"] = "You have received '<color=#FF6347>ToolGun - {0}</color>'.\nTo add an item to the blacklist - shoot it.\nA repeat shot will remove the item from the blacklist.\nFor destroyed items in this list - a raid block will be activated",
                ["RAIDBLOCK_TOOLGUN_WHITELIST_USAGE"] = "You have received '<color=#FF6347>ToolGun - {0}</color>'.\nTo add an item to the whitelist - shoot it.\nA repeat shot will remove the item from the whitelist.\nFor destroyed items in this list - a raid block will not be activated",
            }, this);
            
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["RAIDBLOCK_ACTION_BLOCKED"] = "Вам запрещено совершать это действие во время рейда. Подождите {0}.",
                ["RAIDBLOCK_ENTER_RAID_ZONE"] = "Вы вошли в зону рейда! Некоторые функции будут ограничены в течение {0}.",
                ["RAIDBLOCK_EXIT_RAID_ZONE"] = "Вы вышли из зоны рейда! Функции разблокированы.",
                ["RAIDBLOCK_END_RAID"] = "Блок деактивирован. Функции разблокированы.",
                ["RAIDBLOCK_ENTER_RAID_INITIATOR"] = "Вы уничтожили чужой объект! Активирован рейд блок на {0}.\nНекоторые функции временно недоступны.",
                ["RAIDBLOCK_OWNER_NOTIFY"] = "Ваш дом в квадрате {0} подвергся рейду!",
                ["RAIDBLOCK_UI_IN_RAIDZONE"] = "ВЫ НАХОДИТЕСЬ В ЗОНЕ РЕЙДА",
                ["RAIDBLOCK_UI_TIMER"] = "Осталось {0}",
                ["RAIDBLOCK_UI_TITLE"] = "RAID BLOCK",
                ["RAIDBLOCK_UI_DESCRIPTIONS_V1"] = "Похоже, что вас начали рейдить, и некоторые функции были ограничены.",
                ["RAIDBLOCK_UI_DESCRIPTIONS_V2"] = "Некоторые функции были отключены.",
                ["RAIDBLOCK_KILL_PLAYER"] = "Вы были убиты! Функции разблокированы.",
                ["RAIDBLOCK_TOOLGUN_BLACKLIST_ITEM_NAME"] = "RAID BLOCK - BLACK LIST",
                ["RAIDBLOCK_TOOLGUN_WHITELIST_ITEM_NAME"] = "RAID BLOCK - WHITE LIST",
                ["RAIDBLOCK_TOOLGUN_PERMISSION_DENIED"] = " У вас нет прав для использования этой команды",
                ["RAIDBLOCK_TOOLGUN_ALREADY_IN_INVENTORY"] = "у вас уже есть '<color=#FFA500>ToolGun - {0}</color>' в инвентаре",
                ["RAIDBLOCK_TOOLGUN_REMOVED_FROM_WHITELIST"] = "Предмет '<color=#FF6347>{0} ({1})</color>' был удален из белого списка",
                ["RAIDBLOCK_TOOLGUN_ADDED_TO_WHITELIST"] = "Предмет '<color=#00FF7F>{0} ({1})</color>' был добавлен в белый список",
                ["RAIDBLOCK_TOOLGUN_REMOVED_FROM_BLACKLIST"] = "Предмет '<color=#FF3232>{0} ({1})</color>' был удален из черного списка",
                ["RAIDBLOCK_TOOLGUN_ADDED_TO_BLACKLIST"] = "Предмет '<color=#00FF7F>{0} ({1})</color>' был добавлен в черный список",
                ["RAIDBLOCK_TOOLGUN_BLACKLIST_USAGE"] = " Вы получили '<color=#FF6347>ToolGun - {0}</color>'.\nЧтобы занести предмет в черный список - выстрелите в него.\nПовторный выстрел удалит предмет из черного списка.\nЗа уничтоженные предметы в данном списке - будет активирован рейдблок",
                ["RAIDBLOCK_TOOLGUN_WHITELIST_USAGE"] = " Вы получили '<color=#FF6347>ToolGun - {0}</color>'.\nЧтобы занести предмет в белый список - выстрелите в него.\nПовторный выстрел удалит предмет из белого списка.\nЗа уничтоженные предметы в данном списке - не будет активирован рейдблок",
            }, this, "ru");
        }

		#endregion
		
		#region Hooks

        private void Unload()
        {
            foreach (RaidableZone obj in _raidZoneComponents) 
                UnityEngine.Object.DestroyImmediate(obj);

            foreach (RaidPlayer rPlayer in raidPlayersList)
                if(rPlayer != null)
                    rPlayer.Kill(true);

            if (_imageUI != null)
            {
                _imageUI.UnloadImages();
                _imageUI = null;
            }
            _interface = null;
            Instance = null;
        }

        private void Init()
        {
            Instance = this;
            UnsubscribeHook(true, true);
        }
        
        private void OnServerInitialized()
        {
            permission.RegisterPermission(Name + _permIgnoreRaid,this);
            permission.RegisterPermission(Name + _permHelperToolGun,this);

            _imageUI = new ImageUI();
            _imageUI.DownloadImage();
            
            SubscribeHook(true, false);
        }
        
        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info) => OnEntCheck(entity, info);
        
        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.TryGetComponent(out RaidPlayer rp))
                rp.CrateUI();
        }

        void OnPlayerSleepEnded(BasePlayer player)
        {
            if (player == null || player.IsDead() || !player.IsConnected) return;
            RaidableZone rbZone = GetRbZone(player.transform.position);
            if (rbZone == null) return;
            rbZone.AddPlayer(player);
        }

        private void OnPlayerDeath(BasePlayer player, HitInfo hitInfo)
        {
            if (player == null || hitInfo == null || !player.userID.IsSteamId())
                return;
            RaidPlayer raidPlayer = GetRaidPlayer(player);
            if (raidPlayer != null)
            {
                Instance.SendChat("RAIDBLOCK_KILL_PLAYER".GetAdaptedMessage(player.UserIDString), player);
                UnityEngine.Object.DestroyImmediate(raidPlayer);
            }
        }

        #endregion

        #region [Raidable Bases]

        void OnPlayerEnteredRaidableBase(BasePlayer player, Vector3 raidPos, bool allowPVP, int mode)
        {
            float time = config.RaidBlockMain.RaidableBasesIntegration.RaidBlockDuration;
            RaidPlayer raidPlayer = player.GetOrAddComponent<RaidPlayer>();
            SendChat("RAIDBLOCK_ENTER_RAID_ZONE".GetAdaptedMessage(player.UserIDString, time.ToTimeFormat()), player, 3f);
            
            raidPlayer.ActivateBlock(Time.realtimeSinceStartup + time);

            Interface.CallHook("OnEnterRaidZone", player);
        }

        void OnPlayerExitedRaidableBase(BasePlayer player, Vector3 raidPos, bool allowPVP, int mode)
        {
            RaidPlayer rp = GetRaidPlayer(player);
            if (rp != null)
            {
                UnityEngine.Object.DestroyImmediate(rp);
                SendChat("RAIDBLOCK_EXIT_RAID_ZONE".GetAdaptedMessage(player.UserIDString), player);

                Interface.CallHook("OnExitRaidZone", player);
            }
            
            RaidableZone rbZone = GetRbZone(player.transform.position);
            if (rbZone == null) return;
            rbZone.AddPlayer(player);
        }

        #endregion

        #region HooksBlockedActions
 
        private object CanBuild(Planner planner, Construction prefab, Construction.Target target)
        {
            BasePlayer player = planner.GetOwnerPlayer();
            if (player == null) return null;
            string shortname = prefab.hierachyName[(prefab.hierachyName.IndexOf("/", StringComparison.Ordinal) + 1)..];
            
            if (config.ActionsBlocked.RbDeployWhiteList.Contains(shortname))
                return null;
            Deployable deployable = planner.GetDeployable();
            if (deployable != null && !config.ActionsBlocked.CanDeployObjects)
                return null;
            if (prefab.defaultGrade != null && !config.ActionsBlocked.CanBuildTwig)
                return null;

            return CanActions(player);
        }
        
        private object OnPlayerCommand(BasePlayer player, String command, String[] args)
        {
            if (player == null) return null;
            
            if (args != null && args.Length != 0)
                command += " " + String.Join(" ", args);
            
            String onlyCommand = !String.IsNullOrWhiteSpace(command) && command.Contains(" ") ? command.Substring(0, command.IndexOf(" ", StringComparison.Ordinal)) : command;
            
            return config.ActionsBlocked.RbBlackListCommand.Contains(onlyCommand.ToLower()) ? CanActions(player) : null;
        }

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null || arg.cmd.FullName == "chat.say") return null;
			
            String command = arg.cmd.Name;
            if (arg.Args != null && arg.Args.Length != 0)
                command += " " + String.Join(" ", arg.Args);
            
            String onlyCommand = !String.IsNullOrWhiteSpace(command) && command.Contains(" ") ? command.Substring(0, command.IndexOf(" ", StringComparison.Ordinal)) : command;
			
            return config.ActionsBlocked.RbBlackListCommand.Contains(onlyCommand.ToLower()) ? CanActions(player) : null;
        }
        
        private object OnStructureRepair(BaseCombatEntity entity, BasePlayer player) => CanActions(player);
        private object OnStructureUpgrade(BuildingBlock block, BasePlayer player, BuildingGrade.Enum grade) => CanActions(player);
        private object OnStructureDemolish(BaseCombatEntity entity, BasePlayer player, bool immediate) => CanActions(player);
        private object OnStructureRotate(BaseCombatEntity entity, BasePlayer player) => CanActions(player);

        private object CanPickupEntity(BasePlayer player, BaseEntity entity) => CanActions(player);
        #endregion

        #region Api
        private object CanBGrade(BasePlayer player, int grade, BuildingBlock buildingBlock, Planner planner) => CanActions(player); 
        private object CanTeleport(BasePlayer player) => CanActions(player, true);
        private object canTeleport(BasePlayer player) => CanActions(player);
        private object CanRedeemKit(BasePlayer player) => CanActions(player);
        private object canRemove(BasePlayer player) => CanActions(player);
        private object CanRemove(BasePlayer player) => CanActions(player);
        private object canTrade(BasePlayer player) => CanTrade(player);
        private object CanTrade(BasePlayer player) => CanActions(player, true);

        #region Call

        private bool IsBlocked(BasePlayer player)
        {
            RaidPlayer obj = player.GetComponent<RaidPlayer>();
            return obj != null && obj.UnblockTimeLeft > 0;
        }
        
        private RaidPlayer GetRaidPlayer(BasePlayer player)
        {
            RaidPlayer obj = player.GetComponent<RaidPlayer>();
            return obj;
        }
        
        private bool IsRaidBlocked(string playerId)
        {
            BasePlayer target = BasePlayer.Find(playerId);
            return target != null && IsBlocked(target);
        }
        
        private bool IsRaidBlocked(ulong playerId)
        {
            BasePlayer target = BasePlayer.Find(playerId.ToString());
            return target != null && IsBlocked(target);
        }
        
        private bool IsRaidBlocked(BasePlayer player) => IsBlocked(player);
        
        private bool IsRaidBlock(ulong userId) => IsRaidBlocked(userId);
        
        private int ApiGetTime(ulong userId)
        {
            if (!IsRaidBlocked(userId.ToString())) return 0;
            BasePlayer player = BasePlayer.FindByID(userId);
            if (player == null) return 0;
            RaidPlayer obj = player.GetComponent<RaidPlayer>();
            return obj == null ? 0 : int.Parse(obj.UnblockTimeLeft.ToString(CultureInfo.InvariantCulture));
        }
        #endregion
        
        #endregion
        
        #region Metods

        private void CheckUnsubscribeOrSubscribeHooks()
        {
            if (_raidZoneComponents.Count == 0)
                UnsubscribeHook(false, true);
            else
                SubscribeHook(false, true);
        }

        private void SubscribeHook(bool main, bool raidActions)
        {
            if (main)
            {
                Subscribe(nameof(OnEntityDeath));
                Subscribe(nameof(OnPlayerConnected));
                if (config.RaidBlockMain.RaidableBasesIntegration.useRaidableBases)
                {
                    if(config.RaidBlockMain.RaidableBasesIntegration.BlockOnEnterZone)
                        Subscribe(nameof(OnPlayerEnteredRaidableBase));
                    if(config.RaidBlockMain.RaidableBasesIntegration.BlockOnExitZone)
                        Subscribe(nameof(OnPlayerExitedRaidableBase));
                }
            }

            if (raidActions)
            {
                
                if (config.ActionsBlocked.RbBlackListCommand != null && config.ActionsBlocked.RbBlackListCommand.Count != 0)
                {
                    if (config.ActionsBlocked.RbBlackListCommand.Count == 1 && config.ActionsBlocked.RbBlackListCommand[0].Equals("commandExample")) return;
				
                    Subscribe(nameof(OnPlayerCommand));
                    Subscribe(nameof(OnServerCommand));
                }
                if (config.RaidBlockMain.RaidBlockOnPlayerDeath)
                {
                    Subscribe(nameof(OnPlayerDeath));
                }
                if (config.ActionsBlocked.CanUseKit)
                {
                    Subscribe(nameof(CanRedeemKit));
                }
                if (config.ActionsBlocked.CanUseTeleport)
                {
                    Subscribe(nameof(canTeleport));
                    Subscribe(nameof(CanTeleport));
                }
                if (config.ActionsBlocked.CanUseTrade)
                {
                    Subscribe(nameof(canTrade));
                    Subscribe(nameof(CanTrade));
                }
                if (config.ActionsBlocked.CanDemolishObjects)
                {
                    Subscribe(nameof(OnStructureDemolish));
                    Subscribe(nameof(canRemove));
                    Subscribe(nameof(CanRemove));
                }
                if (config.ActionsBlocked.CanRepairObjects)
                {
                    Subscribe(nameof(OnStructureRepair));
                }
                if (config.ActionsBlocked.CanBuildTwig || config.ActionsBlocked.CanDeployObjects || config.ActionsBlocked.RbDeployWhiteList.Count > 0)
                {
                    Subscribe(nameof(CanBuild));
                }
                if (config.ActionsBlocked.CanUpgradeObjects)
                {
                    Subscribe(nameof(OnStructureUpgrade));
                    Subscribe(nameof(CanBGrade));
                    Subscribe(nameof(OnStructureRotate));
                }
                if (config.ActionsBlocked.CanPickUpObjects)
                {
                    Subscribe(nameof(CanPickupEntity));
                }
            }
        }

        private void UnsubscribeHook(bool main, bool raidActions)
        {
            if (main)
            {
                Unsubscribe(nameof(OnEntityDeath));
                Unsubscribe(nameof(OnPlayerConnected));
                Unsubscribe(nameof(OnPlayerEnteredRaidableBase));
                Unsubscribe(nameof(OnPlayerExitedRaidableBase));
            }

            if (raidActions)
            {
                Unsubscribe(nameof(OnPlayerDeath));
                Unsubscribe(nameof(CanBGrade));
                Unsubscribe(nameof(CanBuild));
                Unsubscribe(nameof(OnStructureUpgrade));
                Unsubscribe(nameof(OnStructureRepair));
                Unsubscribe(nameof(OnStructureDemolish));
                Unsubscribe(nameof(OnStructureRotate));
                Unsubscribe(nameof(canTeleport));
                Unsubscribe(nameof(CanTeleport));
                Unsubscribe(nameof(OnPlayerCommand));
                Unsubscribe(nameof(OnServerCommand));
                Unsubscribe(nameof(canRemove));
                Unsubscribe(nameof(CanRemove));
                Unsubscribe(nameof(canTrade));
                Unsubscribe(nameof(CanTrade));
                Unsubscribe(nameof(CanRedeemKit));
                Unsubscribe(nameof(CanPickupEntity));
            }
            
        }
        private static void RunEffect(BasePlayer player, string prefab)
        {
            Effect effect = new Effect();
            effect.Init(Effect.Type.Generic, player.transform.position, Vector3.zero);
            effect.pooledString = prefab;
            EffectNetwork.Send(effect, player.net.connection);
        }

        private object CanActions(BasePlayer player, bool returnMessage = false)
        {
            RaidPlayer playPlayer = player.GetComponent<RaidPlayer>();
            if (playPlayer != null && playPlayer.UnblockTimeLeft > 0)
            {
                RunEffect(player, "assets/prefabs/locks/keypad/effects/lock.code.denied.prefab");
                if (returnMessage == false)
                {
                    SendChat("RAIDBLOCK_ACTION_BLOCKED".GetAdaptedMessage(player.UserIDString, playPlayer.UnblockTimeLeft.ToTimeFormat()), player);
                    return false;
                }
                else
                {
                    return "RAIDBLOCK_ACTION_BLOCKED".GetAdaptedMessage(player.UserIDString, playPlayer.UnblockTimeLeft.ToTimeFormat());
                }
            }
            
            return null;
        }
        
        private void OnEntCheck(BaseCombatEntity entity, HitInfo info)
        {
            DamageType? majorityDamageType = info?.damageTypes.GetMajorityDamageType();
            if (majorityDamageType == DamageType.Decay)
                return;

            if(!config.BlockDetect.CanRaidIfNotCupboard && entity.GetBuildingPrivilege() == null)
                return;

            BasePlayer raider = info?.InitiatorPlayer ? info.InitiatorPlayer : entity.lastAttacker as BasePlayer;
            if(raider == null) return;
            
            if (IsBlackList(entity) || (IsBlockedClass(entity) && !IsWhiteList(entity)))
            {
                if (CheckEntity(entity, info, raider))
                {
                    BasePlayer ownerPlayer = BasePlayer.FindByID(entity.OwnerID);
                    if (ownerPlayer != null && ownerPlayer.IsConnected)
                        SendChat("RAIDBLOCK_OWNER_NOTIFY".GetAdaptedMessage(ownerPlayer.UserIDString, GetGridString(entity.transform.position)), ownerPlayer, 3f);

                    CreateOrRefreshRaidblock(entity.transform.position, raider);
                }
            }
        }
        private void CreateOrRefreshRaidblock(Vector3 position, BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, Name + _permIgnoreRaid)) 
                return;
            
            if (Interface.Call("CanRaidBlock", player, position) != null)
                return;

            RaidableZone raidableZone = _raidZoneComponents != null && _raidZoneComponents.Count != 0 ? _raidZoneComponents.FirstOrDefault(x => x != null && Vector3.Distance(position, x.transform.position) < config.RaidBlockMain.RaidBlockDistance) : null;
            if (raidableZone != null)
                raidableZone.RefreshTimer(position, player);
            else
            {
                raidableZone = new GameObject().AddComponent<RaidableZone>();
                _raidZoneComponents.Add(raidableZone);
                raidableZone.CreateRaidZone(position, player);
            }
            
            Interface.CallHook("OnRaidBlock", position);
        }
        

        [ChatCommand("rbtest")]
        void rbtest(BasePlayer player)
        {
            if(!player.IsAdmin) return;
            CreateOrRefreshRaidblock(player.transform.position, player);
        }
        
        private static string GetGridString(Vector3 position) => PhoneController.PositionToGridCoord(position);
        private bool CheckEntity(BaseCombatEntity entity, HitInfo info, BasePlayer raider)
        {
            if (entity.OwnerID == 0)
                return false;
            if (config.BlockDetect.IgnoreEntsHealth > 0 && entity.MaxHealth() < config.BlockDetect.IgnoreEntsHealth)
                return false;
            if (entity is BuildingBlock { grade: BuildingGrade.Enum.Twigs } block) return false;
 
            if (raider != null && config.BlockDetect.RaidYourself == false)
            {
                if (raider.userID == entity.OwnerID)
                    return false;
                if (IsFriends(raider, entity.OwnerID))
                    return false;
            }
            
            return true;
        }
        
        private bool IsBlockedClass(BaseCombatEntity entity) => entity is BuildingBlock or Door or SimpleBuildingBlock or Workbench or Barricade;

        private bool IsWhiteList(BaseCombatEntity entity)
        {
            return config.BlockDetect.RbWhiteList.Any(whiteEnt => entity.prefabID == whiteEnt);
        }
        private bool IsBlackList(BaseCombatEntity entity)
        {
            return config.BlockDetect.RbBlackList.Any(blackEnt => entity.prefabID == blackEnt);
        }

        #endregion

        #region ToolGunAdminHelper
        
        private object OnHammerHit(BasePlayer player, HitInfo info)
        {
            if (player == null || info is null) return null;

            if (player.GetActiveItem() is not { } activeItem) return null;
    
            if (!activeItem.info.shortname.Equals(RB_WHITE_AND_BLACK_LIST_ITEM) ||
                (activeItem.skin is not RB_WHITELIST_ITEM_SKIN and not RB_BLACKLIST_ITEM_SKIN))
                return null;

            if (!HasPermission(player)) return null;

            UpdateWhiteOrBlackList(player, activeItem.skin, info);

            return false;
        }

        private void UpdateWhiteOrBlackList(BasePlayer player, ulong skinId, HitInfo info)
        {
            BaseEntity entity = info.HitEntity;
            if (entity == null) return;

            uint prefabId = entity.prefabID;
            HashSet<uint> listToUpdate = skinId switch
            {
                RB_WHITELIST_ITEM_SKIN => config.BlockDetect.RbWhiteList,
                RB_BLACKLIST_ITEM_SKIN => config.BlockDetect.RbBlackList,
                _ => null
            };

            if (listToUpdate == null) return;

            string messageKey = UpdateList(listToUpdate, prefabId) 
                ? skinId == RB_WHITELIST_ITEM_SKIN ? "RAIDBLOCK_TOOLGUN_ADDED_TO_WHITELIST" : "RAIDBLOCK_TOOLGUN_ADDED_TO_BLACKLIST"
                : skinId == RB_WHITELIST_ITEM_SKIN ? "RAIDBLOCK_TOOLGUN_REMOVED_FROM_WHITELIST" : "RAIDBLOCK_TOOLGUN_REMOVED_FROM_BLACKLIST";

            GameTipsSendPlayer(player, messageKey.GetAdaptedMessage(player.UserIDString, entity.ShortPrefabName, prefabId));

            SaveConfig();
            return;

            bool UpdateList(HashSet<uint> list, uint id)
            {
                if (list.Contains(id))
                {
                    list.Remove(id);
                    return false;
                }

                list.Add(id);
                return true;
            }
        }

        
        [ChatCommand("rb.white")]
        private void RaidBlockDetectWhiteList(BasePlayer player)
        {
            if (!HasPermission(player))
                return;
            
            string itemName = "RAIDBLOCK_TOOLGUN_WHITELIST_ITEM_NAME".GetAdaptedMessage(player.UserIDString);
            
            if (FindItemInInventory(player, RB_WHITELIST_ITEM_SKIN))
            {
                GameTipsSendPlayer(player, "RAIDBLOCK_TOOLGUN_ALREADY_IN_INVENTORY".GetAdaptedMessage(player.UserIDString, itemName), error: true);
                return;
            }

            CreateToolGunItem(player, itemName, RB_WHITELIST_ITEM_SKIN);
            GameTipsSendPlayer(player, "RAIDBLOCK_TOOLGUN_WHITELIST_USAGE".GetAdaptedMessage(player.UserIDString, itemName));
        }

        [ChatCommand("rb.black")]
        private void RaidBlockDetectBlackList(BasePlayer player)
        {
            if (!HasPermission(player))
                return;
            
            string itemName = "RAIDBLOCK_TOOLGUN_BLACKLIST_ITEM_NAME".GetAdaptedMessage(player.UserIDString);

            if (FindItemInInventory(player, RB_BLACKLIST_ITEM_SKIN))
            {
                GameTipsSendPlayer(player, "RAIDBLOCK_TOOLGUN_ALREADY_IN_INVENTORY".GetAdaptedMessage(player.UserIDString, itemName), error: true);
                return;
            }

            CreateToolGunItem(player, itemName, RB_BLACKLIST_ITEM_SKIN);
            GameTipsSendPlayer(player, "RAIDBLOCK_TOOLGUN_BLACKLIST_USAGE".GetAdaptedMessage(player.UserIDString, itemName));
        }

        private bool HasPermission(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, Name + _permHelperToolGun) && !player.IsAdmin)
            {
                SendChat("RAIDBLOCK_TOOLGUN_PERMISSION_DENIED".GetAdaptedMessage(player.UserIDString), player);
                return false;
            }
            return true;
        }

        private bool FindItemInInventory(BasePlayer player, ulong skinId)
        {
            return player.inventory.AllItems().Any(item => item.skin == skinId);
        }

        private void GameTipsSendPlayer(BasePlayer player, string message, float seconds = 10f, bool error = false)
        {
            player.SendConsoleCommand("gametip.hidegametip");
            string tips = error ? "showtoast 1" : "showgametip"; 
            player.SendConsoleCommand($"gametip.{tips} \"{message}\"");

            DeleteNotification(player, seconds);
        }
        private readonly Dictionary<BasePlayer, Timer> _playerTimer = new Dictionary<BasePlayer, Timer>();

        private void DeleteNotification(BasePlayer player, float seconds)
        {
            Timer timers = timer.Once(seconds, () =>
            {
                player.SendConsoleCommand("gametip.hidegametip");
            });

            if (_playerTimer.ContainsKey(player))
            {
                if (_playerTimer[player] != null && !_playerTimer[player].Destroyed) _playerTimer[player].Destroy();
                _playerTimer[player] = timers;
            }
            else _playerTimer.Add(player, timers);
        }

        private void CreateToolGunItem(BasePlayer player, string name, ulong skinId)
        {
            Item toolGun = ItemManager.CreateByName(RB_WHITE_AND_BLACK_LIST_ITEM, 1, skinId);
            toolGun.name = name;
            toolGun.info.stackable = 1;
            player.GiveItem(toolGun);
        }

        #endregion

        private List<RaidPlayer> raidPlayersList = new();
        private class RaidPlayer : FacepunchBehaviour
        {
            public BasePlayer player;
            public Single blockEnds;
            public float UnblockTimeLeft => Convert.ToInt32(blockEnds - Time.realtimeSinceStartup);
        
            #region UnityHooks
            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                
                if(!Instance.raidPlayersList.Contains(this))
                    Instance.raidPlayersList.Add(this);
                
                Interface.CallHook("OnRaidBlockStarted", player);
            }

            public void Kill(Boolean force = false)
            {
                if (!force)
                {
                    if (Instance.raidPlayersList.Contains(this))
                        Instance.raidPlayersList.Remove(this);
                }

                DestroyImmediate(this);
            }
            private void OnDestroy()
            {
                CuiHelper.DestroyUi(player, InterfaceBuilder.RB_MAIN);
                Interface.CallHook("OnRaidBlockStopped", player);
            }
        
            #endregion
        
            #region Metods
        
            public void UpdateTime(Single time, Boolean customTime = false)
            {
                if (customTime)
                {
                    blockEnds = time;
                    return;
                }
                
                if (time > blockEnds)
                    blockEnds = time;
            }
        
            public void ActivateBlock(Single time)
            {
                if(time > blockEnds)
                    blockEnds = time;
                CrateUI();
                InvokeRepeating(CheckTimeLeft, 0, 1);
            }
            private void CheckTimeLeft()
            {
                if (UnblockTimeLeft > 0)
                {
                    RefreshUI();
                }
                else
                {
                    CuiHelper.DestroyUi(player, InterfaceBuilder.RB_MAIN);
                    CancelInvoke(nameof(CheckTimeLeft));
                    Kill();
                }
            }
            #endregion
        
            #region UI Methods
            
            public void CrateUI() => Instance.DrawUI_RB_Main(player, UnblockTimeLeft);
            private void RefreshUI() => Instance.DrawUI_RB_Updated(player, UnblockTimeLeft);
        
            #endregion
        }
        
        
        private static RaidableZone GetRbZone(Vector3 position)
        {
            List<SphereCollider> sphereColliders = new ();
            Vis.Colliders(position, 0.1f, sphereColliders);
            if (sphereColliders.Count <= 0) return null;
            foreach (SphereCollider sCollider in sphereColliders)
            {
                if (!sCollider.gameObject.TryGetComponent(out RaidableZone rbZone)) continue;
                return rbZone;
            }
            return null;
        }
        private class RaidableZone : MonoBehaviour
        {
            #region Vars
            
            private Dictionary<BasePlayer, RaidPlayer> _playersAndComponentZone = new();
            
            private MapMarkerExplosion marker;
            private MapMarkerGenericRadius mapMarkerGenericRadius;
            private VendingMachineMapMarker vendingMakrer;
            private List<BaseEntity> _spheres = new();
            
            private SphereCollider triggerZone;
            private BasePlayer initiatorRaid;
            
            private Single timeToUnblock;
            private Single UnblockTimeLeft => Convert.ToInt32(timeToUnblock - Time.realtimeSinceStartup);
            private Int32 raidBlockDistance;
            private Int32 raidBlockDuration;
            private bool IsDynamicRaidZone;

            
            #endregion

            #region Metods

            #region VisualizationSphere

            private void CreateSphere()
            {
                Configuration.RaidBlock.SphereSettings settings = Instance.config.RaidBlockMain.RaidZoneSphereSettings;
                bool isBlackSphere = settings.SphereType == SphereTypes.BlackSphere;
    
                int domeTransparencyLevel = isBlackSphere ? settings.DomeTransparencyLevel : 1;
                string spherePrefab = isBlackSphere ? VISUALIZATION_SPHERE_PREFAB : settings.GetBRZonePrefab();

                for (int i = 0; i < domeTransparencyLevel; i++)
                {
                    SphereEntity sphere = GameManager.server.CreateEntity(spherePrefab, transform.position) as SphereEntity;
                    if (sphere != null)
                    {
                        sphere.currentRadius = raidBlockDistance * 2;
                        sphere.lerpSpeed = 0f;
                        sphere.enableSaving = false;
                        sphere.Spawn();
                        _spheres.Add(sphere);
                    }
                }
            }

            #endregion

            #region MapMarker

            private void CreateMapMarker()
            {
                MarkerTypes raidBlockType = Instance.config.RaidBlockMain.mapMarkerSettings.RaidBlockMarkerType;
                if (raidBlockType is MarkerTypes.MarkerRadiusTimer)
                {
                    CreateVendingMapMarker();
                }
                
                if (raidBlockType is MarkerTypes.ExplosionMarkerRadius or MarkerTypes.MarkerRadius or MarkerTypes.MarkerRadiusTimer)
                {
                    CreateGenericRadiusMapMarker();
                }
                
                if (raidBlockType is MarkerTypes.Explosion or MarkerTypes.ExplosionMarkerRadius)
                {
                    CreateExplosionMapMarker();
                }
                InvokeRepeating(nameof(UpdateGenericRadiusMapMarker), 10f, 10f);
            }

            private void CreateExplosionMapMarker()
            {
                marker = GameManager.server.CreateEntity(EXPLOSION_MAP_MARKER_PREFAB, transform.position) as MapMarkerExplosion;
                marker.enableSaving = false;
                marker.Spawn();
            }
            
            private void CreateVendingMapMarker()
            {
                vendingMakrer = GameManager.server.CreateEntity(VENDING_MAP_MARKER_PREFAB, transform.position) as VendingMachineMapMarker;
                vendingMakrer.enableSaving = false;
                vendingMakrer.markerShopName = "RAID BLOCK: " + UnblockTimeLeft.ToTimeFormat();
                vendingMakrer.Spawn();
            }

            private void CreateGenericRadiusMapMarker()
            {
                if (!ColorUtility.TryParseHtmlString($"#{Instance.config.RaidBlockMain.mapMarkerSettings.MarkerColorHex}", out Color color1) ||
                    !ColorUtility.TryParseHtmlString($"#{Instance.config.RaidBlockMain.mapMarkerSettings.OutlineColorHex}", out Color color2)) return;
                mapMarkerGenericRadius = GameManager.server.CreateEntity(GENERIC_MAP_MARKER_PREFAB) as MapMarkerGenericRadius;
                if (mapMarkerGenericRadius == null) return;
                mapMarkerGenericRadius.color1 = color1;
                mapMarkerGenericRadius.color2 = color2;
                mapMarkerGenericRadius.radius = (raidBlockDistance / 100f) * CalculateRadius();
                mapMarkerGenericRadius.alpha = Instance.config.RaidBlockMain.mapMarkerSettings.MarkerAlpha;
                mapMarkerGenericRadius.enableSaving = false;
                if (vendingMakrer != null)
                    mapMarkerGenericRadius.SetParent(vendingMakrer);
                else
                {
                    mapMarkerGenericRadius.transform.position = transform.position;
                }
                mapMarkerGenericRadius.Spawn();
                mapMarkerGenericRadius.SendUpdate();
                return;
                

                float CalculateRadius()
                {
                    const float a = 100 / 6f;
                    float b = Mathf.Sqrt(a) / 2f;
                    float c = World.Size / 1300f;
                    float d = b / c;

                    return d;
                }
               
            }

            public void UpdateGenericRadiusMapMarker()
            {
                if (vendingMakrer.IsValid())
                {
                    vendingMakrer.markerShopName = "RAID BLOCK: " + UnblockTimeLeft.ToTimeFormat();
                    vendingMakrer.SendNetworkUpdate();
                }
                if (marker.IsValid())
                    marker.SendNetworkUpdate();
                if (mapMarkerGenericRadius.IsValid())
                    mapMarkerGenericRadius.SendUpdate();
            }

            #endregion

            #region Core

            private void UpdateZonePosition(Vector3 position)
            {
                transform.position = position;
            
                if (marker.IsValid())
                {
                    marker.transform.position = position;
                }
                if (vendingMakrer.IsValid())
                {
                    vendingMakrer.markerShopName = "RAID BLOCK: " + UnblockTimeLeft.ToTimeFormat();
                    vendingMakrer.transform.position = position;
                }
                else if (mapMarkerGenericRadius.IsValid())
                {
                    mapMarkerGenericRadius.transform.position = position;
                }

                UpdateGenericRadiusMapMarker();

                foreach (BaseEntity sphere in _spheres)
                {
                    sphere.transform.position = position;
                    sphere.SendNetworkUpdate();
                }
            }
            
            private void InitializeTriggerZone()
            {
                triggerZone = gameObject.AddComponent<SphereCollider>();

                triggerZone.radius = raidBlockDistance;
                triggerZone.gameObject.layer = (int) Layer.Reserved1;
                triggerZone.transform.SetParent(transform, true);
                triggerZone.isTrigger = true;
            }

            public void CreateRaidZone(Vector3 raidPos, BasePlayer initiator)
            {
                Instance.CheckUnsubscribeOrSubscribeHooks();
          
                transform.position = raidPos;
                initiatorRaid = initiator;

                InitializeTriggerZone();
                AddPlayer(initiatorRaid, true);
                
                if (Instance.config.RaidBlockMain.mapMarkerSettings.IsRaidBlockMarkerEnabled)
                    CreateMapMarker();

                if (Instance.config.RaidBlockMain.RaidZoneSphereSettings.IsSphereEnabled)
                    CreateSphere();
                
                if (Instance.config.RaidBlockMain.RaidBlockAddedAllPlayersInZoneRaid) 
                    AddAllPlayerInZoneDistance();

                if (Instance.config.RaidBlockMain.RaidBlockShareOnFriends)
                    AddAllPlayerFriendsInitiator(initiator);
                
                Interface.CallHook("OnCreatedRaidZone", raidPos, initiator);
            }
            
            public void RefreshTimer(Vector3 pos, BasePlayer initiatorReply = null)
            {
                if (IsDynamicRaidZone)
                    UpdateZonePosition(pos);
                timeToUnblock = Time.realtimeSinceStartup + raidBlockDuration;
                CancelInvoke(nameof(EndRaid));
                Invoke(nameof(EndRaid), raidBlockDuration);

                if (initiatorReply != null && !_playersAndComponentZone.ContainsKey(initiatorReply))
                {
                    AddPlayer(initiatorReply);
                    
                    if (Instance.config.RaidBlockMain.RaidBlockShareOnFriends)
                        AddAllPlayerFriendsInitiator(initiatorReply);
                }
                
                foreach (KeyValuePair<BasePlayer, RaidPlayer> playerAndComponent in _playersAndComponentZone)
                {
                    RaidPlayer raidPlayer = playerAndComponent.Value;
                    if (raidPlayer != null)
                    {
                        if (Vector3.Distance(playerAndComponent.Key.transform.position,
                                triggerZone.transform.position) >= raidBlockDistance)
                        {
                            Instance.NextTick(() =>
                            {
                                _playersAndComponentZone.Remove(playerAndComponent.Key);
                            });
                            continue;
                        }
                        raidPlayer.UpdateTime(timeToUnblock);
                    }
                }
            }
            
            private void EndRaid() 
            {
                Interface.CallHook("OnRaidBlockStopped", transform.position);
                Instance._raidZoneComponents.Remove(this);
                Instance.CheckUnsubscribeOrSubscribeHooks();
                
                Destroy(this);
            }
            
            #endregion

            #region Player Action

            private void AddAllPlayerInZoneDistance() 
            {
                List<BasePlayer> players = Pool.GetList<BasePlayer>();
                Vis.Entities(transform.position, raidBlockDistance, players);
                foreach (BasePlayer player in players)
                {
                    if(_playersAndComponentZone.ContainsKey(player))
                        continue;
                    AddPlayer(player, true);
                }
                
                Pool.FreeList(ref players);
            }
            
            private void AddAllPlayerFriendsInitiator(BasePlayer initiator) 
            {
                foreach (UInt64 playerID in Instance.GetFriendList(initiator))
                {
                    BasePlayer player = BasePlayer.FindByID(playerID);
                    if (player == null) continue;
                    if(_playersAndComponentZone.ContainsKey(player))
                        continue;
                    
                    AddPlayer(player, true);
                }
            }
            
            public void AddPlayer(BasePlayer player, Boolean force = false)
            {
                if (!Instance.config.RaidBlockMain.RaidBlockOnEnterRaidZone && !force) return;
                RaidPlayer raidPlayer = player.GetOrAddComponent<RaidPlayer>();
                
                Single leftTimeZone = raidPlayer.UnblockTimeLeft > UnblockTimeLeft
                    ? raidPlayer.UnblockTimeLeft
                    : UnblockTimeLeft;
                
                if (player == initiatorRaid)
                {
                    Instance.SendChat("RAIDBLOCK_ENTER_RAID_INITIATOR".GetAdaptedMessage(player.UserIDString, leftTimeZone.ToTimeFormat()), player);
                    initiatorRaid = null;
                }
                else if(!_playersAndComponentZone.ContainsKey(player))
                    Instance.SendChat("RAIDBLOCK_ENTER_RAID_ZONE".GetAdaptedMessage(player.UserIDString, leftTimeZone.ToTimeFormat()), player, 3f);
            
                _playersAndComponentZone[player] = raidPlayer;
                
                raidPlayer.ActivateBlock(timeToUnblock);

                Interface.CallHook("OnEnterRaidZone", player);
            }

            public void RemovePlayer(BasePlayer player)
            {
                if(!_playersAndComponentZone.ContainsKey(player)) return;
                RaidPlayer raidPlayer = _playersAndComponentZone[player];
                if (raidPlayer == null) return;
                
                if (Instance.config.RaidBlockMain.RaidBlockOnExitRaidZone && Instance.config.RaidBlockMain.TimeLeftOnExitZone == 0)
                {
                    Destroy(_playersAndComponentZone[player]);
                    Instance.SendChat("RAIDBLOCK_EXIT_RAID_ZONE".GetAdaptedMessage(player.UserIDString), player);
                }
                else if(Instance.config.RaidBlockMain.TimeLeftOnExitZone != 0)
                {
                    if (raidPlayer.UnblockTimeLeft > Instance.config.RaidBlockMain.TimeLeftOnExitZone)
                        raidPlayer.UpdateTime(Time.realtimeSinceStartup + Instance.config.RaidBlockMain.TimeLeftOnExitZone, true);
                }
                _playersAndComponentZone.Remove(player);
                
                player.Invoke(() => RecheackRbZone(player), 0.1f);

                Interface.CallHook("OnExitRaidZone", player);
            }
            
            public void RecheackRbZone(BasePlayer player)
            {
                if (player == null || player.IsDead() || !player.IsConnected) return;
                
                RaidableZone rbZone = GetRbZone(player.transform.position);
                if (rbZone == null) return;
                rbZone.AddPlayer(player);
            }
            
            #endregion
            
            #endregion
            
            #region Init

            private void Awake()
            {
                raidBlockDistance = Instance.config.RaidBlockMain.RaidBlockDistance;
                raidBlockDuration = Instance.config.RaidBlockMain.RaidBlockDuration;
                IsDynamicRaidZone = Instance.config.RaidBlockMain.IsDynamicRaidZone;

                RefreshTimer(transform.position);
            }
            
            #endregion

            #region Hooks

            private void OnDestroy()
            {
                CancelInvoke(nameof(UpdateGenericRadiusMapMarker));
                if (marker.IsValid())
                    marker.Kill();
                
                if (vendingMakrer.IsValid())
                    vendingMakrer.Kill();

                if (mapMarkerGenericRadius.IsValid())
                    mapMarkerGenericRadius.Kill();
                
                foreach (BaseEntity sphere in _spheres)
                    if (sphere.IsValid())
                        sphere.Kill();
                
                marker = null;
                mapMarkerGenericRadius = null;
                _spheres = null;
                
                Destroy(triggerZone);
            }
        
            private void OnTriggerEnter(Collider collider)
            {
                BasePlayer player = collider.GetComponentInParent<BasePlayer>();
                if (player != null && player.net?.connection!=null)
                {
                    AddPlayer(player);
                }
            }
        
            private void OnTriggerExit(Collider collider)
            {
                BasePlayer player = collider.GetComponentInParent<BasePlayer>();
                if (player != null && player.net?.connection!=null)
                {
                    RemovePlayer(player);
                }
            }
            
            #endregion
        }
        
        #region Refference

        #region Friends
        
        private List<BasePlayer> GetPlayerFriends(BasePlayer player)
        {
            List<BasePlayer> teamMembers = new List<BasePlayer>();
            if (RelationshipManager.maxTeamSize > 0 && player.currentTeam != 0UL)
            {
                foreach (ulong member in player.Team.members)
                {
                    BasePlayer playerInTeam = BasePlayer.FindByID(member);
                    if(playerInTeam != null && playerInTeam != player)
                        teamMembers.Add(playerInTeam);
                }
            }
            else if (Friends)
            {
                ulong[] playersInTeam = Friends?.Call<ulong[]>("GetFriends", player.userID) ?? new ulong[]{};
                foreach (ulong member in playersInTeam)
                {
                    BasePlayer playerInTeam = BasePlayer.FindByID(member);
                    if(playerInTeam != null)
                        teamMembers.Add(playerInTeam);
                }
            }

            return teamMembers;
        }


        #endregion

        #endregion

        #region UI
        
        private void DrawUI_RB_Main(BasePlayer player,  float timeLeft = 0f)
        {
            string Interface = InterfaceBuilder.GetInterface(InterfaceBuilder.RB_MAIN);
            if (Interface == null) return;

            switch (InterfaceBuilder.TypeUi)
            {
                case 0:
                    Interface = Interface.Replace("%Descriptions%", "RAIDBLOCK_UI_DESCRIPTIONS_V1".GetAdaptedMessage(player.UserIDString));
                    break;
                case 1:
                    Interface = Interface.Replace("%Descriptions%", "RAIDBLOCK_UI_DESCRIPTIONS_V2".GetAdaptedMessage(player.UserIDString));
                    break;
            }

            Interface = Interface.Replace("%Title%", "RAIDBLOCK_UI_TITLE".GetAdaptedMessage(player.UserIDString));


            CuiHelper.DestroyUi(player, InterfaceBuilder.RB_MAIN);
            CuiHelper.AddUi(player, Interface);
            
            DrawUI_RB_Updated(player, timeLeft == 0 ? config.RaidBlockMain.RaidBlockDuration : timeLeft, true);
        }	
        
        private void DrawUI_RB_Updated(BasePlayer player, float timeLeft, bool upd = false)
        {
            string Interface = InterfaceBuilder.GetInterface(InterfaceBuilder.RB_PROGRESS_BAR);
            if (Interface == null) return;
            double factor = InterfaceBuilder.Factor * timeLeft / config.RaidBlockMain.RaidBlockDuration;

            Interface = Interface.Replace("%left%", factor.ToString(CultureInfo.InvariantCulture));
            Interface = Interface.Replace("%TimeLeft%", "RAIDBLOCK_UI_TIMER".GetAdaptedMessage(player.UserIDString, timeLeft.ToTimeFormat()));
            if(!upd)
                Interface = Interface.Replace("0.22", "0");

            CuiHelper.DestroyUi(player, InterfaceBuilder.RB_PROGRESS);
            CuiHelper.DestroyUi(player, InterfaceBuilder.RB_PROGRESS_TIMER);
            CuiHelper.AddUi(player, Interface);
        }
        

        private class InterfaceBuilder
		{
			#region Vars

			private static InterfaceBuilder _instance;
            public const string RB_MAIN = "RB_MAIN";
            public const string RB_PROGRESS_BAR = "RB_PROGRESS_BAR";
            public const string RB_PROGRESS = "RB_PROGRESS";
            public const string RB_PROGRESS_TIMER = "RB_PROGRESS_TIMER";

            public static int TypeUi;
            public static double Factor;
            private Configuration.RaidBlockUi.RaidBlockUiSettings _uiSettings;
            private static float _fade;

			private Dictionary<string, string> _interfaces;

			#endregion

			#region Main
			public InterfaceBuilder()
			{
				_instance = this;
				_interfaces = new Dictionary<string, string>();
                TypeUi = Instance.config.RaidBlockInterface.UiType;
                Factor = TypeUi switch
                {
                    0 => 142,
                    1 => 195,
                    _ => 130
                };
                _uiSettings = TypeUi switch
                {
                    0 => Instance.config.RaidBlockInterface.InterfaceSettingsVariant0,
                    1 => Instance.config.RaidBlockInterface.InterfaceSettingsVariant1,
                    2 => Instance.config.RaidBlockInterface.InterfaceSettingsVariant2,
                    _ => throw new ArgumentOutOfRangeException()
                };
                _fade = _uiSettings.SmoothTransition;
              

                switch (TypeUi)
                {
                    case 0:
                        BuildingRaidBlockMain();
                        BuildingRaidBlockUpdated();
                        break;
                    case 1:
                        BuildingRaidBlockMainV2();
                        BuildingRaidBlockUpdatedV2();
                        break;
                    case 2:
                        BuildingRaidBlockMainV3();
                        BuildingRaidBlockUpdatedV3();
                        break;
                }
            }

			private static void AddInterface(string name, string json)
			{
				if (_instance._interfaces.ContainsKey(name))
				{
					Instance.PrintError($"Error! Tried to add existing cui elements! -> {name}");
					return;
				}

				_instance._interfaces.Add(name, json);
			}

			public static string GetInterface(string name)
			{
				string json;
				if (_instance._interfaces.TryGetValue(name, out json) == false)
				{
					Instance.PrintWarning($"Warning! UI elements not found by name! -> {name}");
				}

				return json;
			}

			public static void DestroyAll()
			{
				foreach (BasePlayer player in BasePlayer.activePlayerList)
					CuiHelper.DestroyUi(player, RB_MAIN);
			}

			#endregion

			#region Building UI V-1

			private void BuildingRaidBlockMain()
            {

				CuiElementContainer container = new CuiElementContainer();
                
                container.Add(new CuiPanel
                {
                    FadeOut = _fade,
                    CursorEnabled = false,
                    Image = { Color = "0 0 0 0", FadeIn = _fade },
                    RectTransform ={ AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = $"{-179.00 + Instance.config.RaidBlockInterface.OffsetX} {-34.5 + Instance.config.RaidBlockInterface.OffsetY}", OffsetMax = $"{-0.00 + Instance.config.RaidBlockInterface.OffsetX} {34.5 + Instance.config.RaidBlockInterface.OffsetY}" }
                },Instance.config.RaidBlockInterface.Layers ,RB_MAIN);
                
                container.Add(new CuiElement
                {
                    FadeOut = _fade,
                    Name = "RB_BACKGROUND",
                    Parent = RB_MAIN,
                    Components = {
                        new CuiRawImageComponent { Color = _uiSettings.BackgroundColor, Png = _imageUI.GetImage("RB_FON0"), FadeIn = _fade },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1"}
                    }
                });
                
                container.Add(new CuiPanel
                {
                    FadeOut = _fade,
                    CursorEnabled = false,
                    Image = { Color = _uiSettings.ProgressBarBackgroundColor, FadeIn = _fade },
                    RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-71.00 9.36", OffsetMax = "70.99 12.03" }
                },RB_MAIN,RB_PROGRESS_BAR);
                
                container.Add(new CuiLabel
                {
                    FadeOut = _fade,
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-71.00 -9.63", OffsetMax = "84.10 14.71" },
                    Text = { Text = "%Descriptions%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = _uiSettings.SecondaryTextColor, FadeIn = _fade }
                }, RB_MAIN);
                
                container.Add(new CuiLabel
                {
                    FadeOut = _fade,
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-71.00 14.71", OffsetMax = "-9.04 29.11"},
                    Text = { Text = "%Title%", Font = "robotocondensed-bold.ttf", FontSize = 11, Align = TextAnchor.MiddleLeft, Color = _uiSettings.MainTextColor , FadeIn = _fade}
                }, RB_MAIN);
                
                container.Add(new CuiElement
                {
                    Name = "RB_ICON",
                    Parent = RB_MAIN,
                    Components = {
                        new CuiRawImageComponent { Color = _uiSettings.IconColor, Png = _imageUI.GetImage("RB_VARIANT0_ICON") },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-7.38 16.91", OffsetMax = "2.62 26.91" }
                    }
                });

                AddInterface(RB_MAIN, container.ToJson());
			}
            
            private void BuildingRaidBlockUpdated()
            {
                CuiElementContainer container = new CuiElementContainer();
                container.Add(new CuiPanel
                {
                    FadeOut = _fade,
                    CursorEnabled = false,
                    Image = { Color = _uiSettings.ProgressBarMainColor, FadeIn = _fade },
                    RectTransform ={ AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "0 -1.33", OffsetMax = "%left% 1.33" }
                },RB_PROGRESS_BAR,RB_PROGRESS);

                container.Add(new CuiLabel
                {
                    FadeOut = _fade,
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-71.00 -21.16", OffsetMax = "35.49 -9.63"},
                    Text = {  Text = "%TimeLeft%", Font = "robotocondensed-regular.ttf", FontSize = 9, Align = TextAnchor.MiddleLeft, Color = _uiSettings.MainTextColor }
                }, RB_MAIN, RB_PROGRESS_TIMER);

                AddInterface(RB_PROGRESS_BAR, container.ToJson());
            }
            #endregion
            
            #region Building UI V-2

			private void BuildingRaidBlockMainV2()
            {
				CuiElementContainer container = new CuiElementContainer();
                container.Add(new CuiPanel
                {
                    FadeOut = _fade,
                    CursorEnabled = false,
                    Image = { Color = "1 1 1 0", FadeIn = _fade },
                    RectTransform ={ AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = $"{-200.01 + Instance.config.RaidBlockInterface.OffsetX} {-20 + Instance.config.RaidBlockInterface.OffsetY}", OffsetMax = $"{-0.01 + Instance.config.RaidBlockInterface.OffsetX} {20 + Instance.config.RaidBlockInterface.OffsetY}" }

                },Instance.config.RaidBlockInterface.Layers,RB_MAIN);
                
                container.Add(new CuiElement
                {
                    FadeOut = _fade,
                    Name = "RB_BACKGROUND",
                    Parent = RB_MAIN,
                    Components = {
                        new CuiRawImageComponent { Color = _uiSettings.BackgroundColor , Png = _imageUI.GetImage("RB_FON1"), FadeIn = _fade },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-100.00 -17", OffsetMax = "99.99 20" }
                    }
                });
                
                container.Add(new CuiPanel
                {
                    FadeOut = _fade,
                    CursorEnabled = false,
                    Image = { Color = _uiSettings.ProgressBarBackgroundColor, FadeIn = _fade },
                    RectTransform ={ AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-97.5 0", OffsetMax = "97.5 3.33" }
                },RB_MAIN,RB_PROGRESS_BAR);

                container.Add(new CuiLabel
                {
                    FadeOut = _fade,
                    RectTransform = {AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-64.62 0", OffsetMax = "-13.36 15.56" },
                    Text = {  Text = "%Title%", Font = "robotocondensed-bold.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = _uiSettings.MainTextColor, FadeIn = _fade }
                }, RB_MAIN);
                
                container.Add(new CuiLabel
                {
                    FadeOut = _fade,
                    RectTransform = {  AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-64.62 -12.76", OffsetMax = "68.69 2.76" },
                    Text = { Text = "%Descriptions%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = _uiSettings.SecondaryTextColor, FadeIn = _fade}
                }, RB_MAIN);
                
                container.Add(new CuiElement
                {
                    Name = "RB_ICON_FON",
                    Parent = RB_MAIN,
                    Components = {
                        new CuiRawImageComponent { Color = _uiSettings.AdditionalElementsColor, Png = _imageUI.GetImage("RB_VARIANT1_ICON_FON") },
                        new CuiRectTransformComponent { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "8.19 -10", OffsetMax = "32.19 13" }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "RB_ICON",
                    Parent = "RB_ICON_FON",
                    Components = {
                        new CuiRawImageComponent { Color = _uiSettings.IconColor, Png = _imageUI.GetImage("RB_VARIANT1_ICON") },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-9 -8.5", OffsetMax = "9 8.5" }
                    }
                });
                
                AddInterface(RB_MAIN, container.ToJson());
			}
            
            private void BuildingRaidBlockUpdatedV2()
            {
                CuiElementContainer container = new CuiElementContainer();
                container.Add(new CuiPanel
                {
                    FadeOut = _fade,
                    CursorEnabled = false,
                    Image = { Color = _uiSettings.ProgressBarMainColor, FadeIn = _fade },
                    RectTransform ={ AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "0 -1.66", OffsetMax = "%left% 1.66" }
                },RB_PROGRESS_BAR,RB_PROGRESS);
                AddInterface(RB_PROGRESS_BAR, container.ToJson());
            }
            #endregion
            
            #region Building UI V-3

			private void BuildingRaidBlockMainV3()
            {
				CuiElementContainer container = new CuiElementContainer();
                
                container.Add(new CuiPanel
                {
                    FadeOut = _fade,
                    CursorEnabled = false,
                    Image = { Color = "1 1 1 0", FadeIn = _fade },
                    RectTransform ={ AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = $"{-200 + Instance.config.RaidBlockInterface.OffsetX} {-28 + Instance.config.RaidBlockInterface.OffsetY}", OffsetMax = $"{0 + Instance.config.RaidBlockInterface.OffsetX} {28 + Instance.config.RaidBlockInterface.OffsetY}" }
                },Instance.config.RaidBlockInterface.Layers,RB_MAIN);
                
                container.Add(new CuiElement
                {
                    FadeOut = _fade,
                    Name = "RB_BACKGROUND",
                    Parent = RB_MAIN,
                    Components = {
                        new CuiRawImageComponent { Color = _uiSettings.BackgroundColor, Png = _imageUI.GetImage("RB_FON2"), FadeIn = _fade },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1"}
                    }
                });
                
                container.Add(new CuiPanel
                {
                    FadeOut = _fade,
                    CursorEnabled = false,
                    Image = { Color = _uiSettings.ProgressBarBackgroundColor, FadeIn = _fade },
                    RectTransform ={ AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-46.03 9.42", OffsetMax = "83.97 12.75" }
                },RB_MAIN,RB_PROGRESS_BAR);
                
                container.Add(new CuiLabel
                {
                    FadeOut = _fade,
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-2.95 1.54", OffsetMax = "83.97 21.85" },
                    Text = { Text = "%Title%", Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleRight, Color = _uiSettings.MainTextColor, FadeIn = _fade}
                }, RB_MAIN);
                
                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = _uiSettings.AdditionalElementsColor },
                    RectTransform ={ AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-7.9 -25", OffsetMax = "-1.9 26" }
                },RB_MAIN,"RB_RIGHT_PANEL");
                
                container.Add(new CuiElement
                {
                    Name = "RB_ICON",
                    Parent = RB_MAIN,
                    Components = {
                        new CuiRawImageComponent { Color = _uiSettings.IconColor, Png = _imageUI.GetImage("RB_VARIANT2_ICON") },
                        new CuiRectTransformComponent { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "2.3 -20", OffsetMax = "42.3 20" }
                    }
                });
                
                AddInterface(RB_MAIN, container.ToJson());
			}
            
            private void BuildingRaidBlockUpdatedV3()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = _uiSettings.ProgressBarMainColor, FadeIn = _fade },
                    RectTransform ={ AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "0 -1.66", OffsetMax = "%left% 1.66" }
                },RB_PROGRESS_BAR,RB_PROGRESS);
                
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-46.03 -12.24", OffsetMax = "83.97 5.46" },
                    Text = { Text = "%TimeLeft%", Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleRight, Color = _uiSettings.SecondaryTextColor, FadeIn = _fade}
                }, RB_MAIN, RB_PROGRESS_TIMER);

                AddInterface(RB_PROGRESS_BAR, container.ToJson());
            }
            #endregion
		}

        #endregion
        
        #region ImageLoader

		private class ImageUI
		{
			private readonly string _paths;
			private readonly string _printPath;
			private readonly Dictionary<string, ImageData> _images;

			private enum ImageStatus
			{
				NotLoaded,
				Loaded,
				Failed
			}

			public ImageUI()
			{
				_paths = Instance.Name + "/Images/";
				_printPath = "data/" + _paths;
				_images = new Dictionary<string, ImageData>
				{
					{ "RB_FON0", new ImageData() },
					{ "RB_FON1", new ImageData() },
					{ "RB_FON2", new ImageData() },
					{ "RB_VARIANT0_ICON", new ImageData() },
					{ "RB_VARIANT1_ICON_FON", new ImageData() },
					{ "RB_VARIANT1_ICON", new ImageData() },
					{ "RB_VARIANT2_ICON", new ImageData() },
				};
			}

			private class ImageData
			{
				public ImageStatus Status = ImageStatus.NotLoaded;
				public string Id { get; set; }
			}

			public string GetImage(string name)
			{
				ImageData image;
				if (_images.TryGetValue(name, out image) && image.Status == ImageStatus.Loaded)
					return image.Id;
				return null;
			}

			public void DownloadImage()
			{
				KeyValuePair<string, ImageData>? image = null;
				foreach (KeyValuePair<string, ImageData> img in _images)
				{
					if (img.Value.Status == ImageStatus.NotLoaded)
					{
						image = img;
						break;
					}
				}

				if (image != null)
				{
					ServerMgr.Instance.StartCoroutine(ProcessDownloadImage(image.Value));
				}
				else
				{
					List<string> failedImages = new List<string>();

					foreach (KeyValuePair<string, ImageData> img in _images)
					{
						if (img.Value.Status == ImageStatus.Failed)
						{
							failedImages.Add(img.Key);
						}
					}

					if (failedImages.Count > 0)
					{
						string images = string.Join(", ", failedImages);
						Instance.PrintError(LanguageEn
							? $"Failed to load the following images: {images}. Perhaps you did not upload them to the '{_printPath}' folder."
							: $"Не удалось загрузить следующие изображения: {images}. Возможно, вы не загрузили их в папку '{_printPath}'.");
						Interface.Oxide.UnloadPlugin(Instance.Name);
					}
					else
					{
						Instance.Puts(LanguageEn
							? $"{_images.Count} images downloaded successfully!"
							: $"{_images.Count} изображений успешно загружено!");
                        
                        Instance.Puts(LanguageEn ? "Generating the interface, please wait for approximately 5-10 seconds" : "Генерируем интерфейс, ожидайте ~5-10 секунд");
                        _interface = new InterfaceBuilder();
                        Instance.Puts(LanguageEn ? "The interface has been successfully loaded" : "Интерфейс успешно загружен!");
					}
				}
			}

			public void UnloadImages()
			{
				foreach (KeyValuePair<string, ImageData> item in _images)
					if (item.Value.Status == ImageStatus.Loaded)
						if (item.Value?.Id != null)
							FileStorage.server.Remove(uint.Parse(item.Value.Id), FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID);

				_images?.Clear();
			}

            private IEnumerator ProcessDownloadImage(KeyValuePair<string, ImageData> image)
			{
                string url = "file://" + Interface.Oxide.DataDirectory + "/" + _paths + image.Key + ".png";

                using UnityWebRequest www = UnityWebRequestTexture.GetTexture(url);
                yield return www.SendWebRequest();

                if (www.result is UnityWebRequest.Result.ConnectionError or UnityWebRequest.Result.ProtocolError)
                {
                    image.Value.Status = ImageStatus.Failed;
                }
                else
                {
                    Texture2D tex = DownloadHandlerTexture.GetContent(www);
                    image.Value.Id = FileStorage.server.Store(tex.EncodeToPNG(), FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID).ToString();
                    image.Value.Status = ImageStatus.Loaded;
                    UnityEngine.Object.DestroyImmediate(tex);
                }

                DownloadImage();
            }
		}

		#endregion
    }
}

namespace Oxide.Plugins.RaidBlockExt
{
    public static class ExtensionMethods
    {
        private static readonly Lang Lang = Interface.Oxide.GetLibrary<Lang>();

        #region GetLang

        public static string GetAdaptedMessage(this string langKey, string userID = null, params object[] args)
        {
            string message = Lang.GetMessage(langKey, RaidBlock.Instance, userID);

            if (args == null || args.Length == 0)
            {
                return message;
            }
            
            return new StringBuilder().AppendFormat(message, args).ToString();
        }

        #endregion
        
        #region TimeFormat

        public static string ToTimeFormat(this float source)
        {
            TimeSpan ts = TimeSpan.FromSeconds(source);
            return $"{ts.Minutes:D1}:{ts.Seconds:D2}";
        }

        #endregion
        
    }
}

// --- End of file: RaidBlock.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/MagazinBoost.cs ---
// --- Original Local Path: MagazinBoost.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEngine;
using Oxide.Game.Rust;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("MagazinBoost", "Fujikura", "1.2.1", ResourceId = 1962)]
    [Description("Can change magazines, ammo and conditon for most projectile weapons")]
    public class MagazinBoost : RustPlugin
    {	
		private bool Changed;

		StoredWeapons storedWeapons = new StoredWeapons();
		
		private FieldInfo _itemCondition = typeof(Item).GetField("_condition", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
		private FieldInfo _itemMaxCondition = typeof(Item).GetField("_maxCondition", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));

		#region Config
		
		private string permissionAll;
		private string permissionMaxAmmo;
		private string permissionPreLoad;
		private string permissionMaxCondition;
		private string permissionAmmoType;
		private bool checkPermission;
		private bool removeSkinIfNoRights;		
		
		private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }
		
		void LoadVariables()
        {
			permissionAll = Convert.ToString(GetConfig("Permissions", "permissionAll", "magazinboost.canall"));
			permissionMaxAmmo = Convert.ToString(GetConfig("Permissions", "permissionMaxAmmo", "magazinboost.canmaxammo"));
			permissionPreLoad = Convert.ToString(GetConfig("Permissions", "permissionPreLoad", "magazinboost.canpreload"));
			permissionMaxCondition = Convert.ToString(GetConfig("Permissions", "permissionMaxCondition", "magazinboost.canmaxcondition"));
			permissionAmmoType = Convert.ToString(GetConfig("Permissions", "permissionAmmoType", "magazinboost.canammotype"));
			checkPermission = Convert.ToBoolean(GetConfig("CheckRights", "checkForRightsInBelt", true));
			removeSkinIfNoRights = Convert.ToBoolean(GetConfig("CheckRights", "removeSkinIfNoRights", true));
            
			if (!Changed) return;
            SaveConfig();
            Changed = false;
        }
		
        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }
		
		#endregion Config
		
		
		#region WeaponData

		private void SetupDefaultWeapons()
        {
			var defaultWeapons = new Dictionary<string,ItemDefinition>();
			var weapons = ItemManager.itemList.Where(p => p.category == ItemCategory.Weapon);
			foreach( var weapon in weapons )
			{
				var item = ItemManager.CreateByName(weapon.shortname);
				if (item.GetHeldEntity() is BaseProjectile)
					defaultWeapons.Add(item.info.shortname, item.info);
				item.Remove(0f);
			}
			for(int i=0; i < storedWeapons.weaponStatsList.Count; ++i)
				foreach (WeaponStats stats in storedWeapons.weaponStatsList[i].weaponStatsContent)
					{
						if (stats.servermaxammo > 0 && stats.serverpreload > 0 && stats.serverammotype != null && stats.servermaxcondition > 0 && stats.serveractive)
						{
							defaultWeapons[stats.name].GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.definition.builtInSize = stats.servermaxammo;
							defaultWeapons[stats.name].GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.contents = stats.serverpreload;
							var ammo = ItemManager.FindItemDefinition(stats.serverammotype);
							if (ammo != null)
								defaultWeapons[stats.name].GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.ammoType = ammo;
							defaultWeapons[stats.name].condition.max = (float)stats.servermaxcondition;

						}
						if (stats.servermaxammo == 0 || stats.serverpreload == 0 || stats.serverammotype == null || stats.servermaxcondition == 0) 
						{
							stats.servermaxammo = defaultWeapons[stats.name].GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.definition.builtInSize;
							stats.serverpreload = defaultWeapons[stats.name].GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.contents;
							stats.serverammotype = defaultWeapons[stats.name].GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.ammoType.shortname;
							stats.servermaxcondition = (int)defaultWeapons[stats.name].condition.max;
						}
					}
		}
		
		class StoredWeapons
        {
            public List<WeaponInventory> weaponStatsList = new List<WeaponInventory>();

            public StoredWeapons()
            {
            }
        }
		
		class WeaponInventory
        {
            private FieldInfo _itemMaxCon = typeof(Item).GetField("_maxCondition", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
			
			public List<WeaponStats> weaponStatsContent = new List<WeaponStats>();

            public WeaponInventory() { }

            public WeaponInventory(List<WeaponStats> list)
            {
                weaponStatsContent = list;
            }

            public WeaponInventory(string name, string displayname, int maxammo, int preload, int maxcondition, string ammotype, ulong skinid)
            {
                weaponStatsContent.Add(new WeaponStats(name, displayname, maxammo, preload, maxcondition, ammotype, skinid));
            }

            public int InventorySize()
            {
                return weaponStatsContent.Count;
            }

            public List<WeaponStats> GetweaponStatsContent()
            {
                return weaponStatsContent;
            }
        }
		
		private class WeaponStats
        {
            public string name;
            public string displayname;
			public int maxammo;
			public int preload;
			public int maxcondition;
			public string ammotype;
			public ulong skinid;
			public bool settingactive;
			
			public int servermaxammo;
			public int serverpreload;
			public string serverammotype;
			public int servermaxcondition;
			public bool serveractive;

            public WeaponStats() { }

            public WeaponStats(string name, string displayname, int maxammo, int preload, int maxcondition, string ammotype, ulong skinid)
            {
                this.name = name;
                this.displayname = displayname;
				this.maxammo = maxammo;
                this.preload = preload;
				this.maxcondition = maxcondition;
				this.ammotype = ammotype;
				this.skinid = skinid;
				this.settingactive = true;
            }
        }

		private void LoadWeaponData()
        {
            storedWeapons = Interface.GetMod().DataFileSystem.ReadObject<StoredWeapons>("MagazinBoost");
            if (storedWeapons.weaponStatsList.Count == 0)
            {
                storedWeapons = new StoredWeapons();
                WeaponInventory inv;
				var weapons = ItemManager.itemList.Where(p => p.category == ItemCategory.Weapon).ToList();
				foreach( var weapon in weapons )
				{
					var item = ItemManager.CreateByName(weapon.shortname);
					if (item.GetHeldEntity() is BaseProjectile)
					{
						inv = new WeaponInventory(
							item.info.shortname,
							item.info.displayName.english,
							(item.GetHeldEntity() as BaseProjectile).primaryMagazine.capacity,
							(item.GetHeldEntity() as BaseProjectile).primaryMagazine.contents,
							Convert.ToInt32(_itemMaxCondition.GetValue(item)),
							(item.GetHeldEntity() as BaseProjectile).primaryMagazine.ammoType.shortname,
							item.GetHeldEntity().skinID
							);
						storedWeapons.weaponStatsList.Add(inv);
					}
					item.Remove(0f);
				}
				SaveWeaponData();
            }
        }
		
		private void SaveWeaponData()
		{
			Interface.GetMod().DataFileSystem.WriteObject("MagazinBoost", storedWeapons);
		}
		
		#endregion WeaponData
		        
		private WeaponStats craftedWeapon(string name)
		{
			for(int i=0; i < storedWeapons.weaponStatsList.Count; ++i)
				foreach (WeaponStats stats in storedWeapons.weaponStatsList[i].weaponStatsContent.ToList())
					{
						if (stats.name == name)
						return stats;
					}
					return null;
		}
		
		private bool hasAnyRight(BasePlayer player)
		{
			if (permission.UserHasPermission(player.UserIDString, permissionAll)) return true;
			if (permission.UserHasPermission(player.UserIDString, permissionMaxAmmo)) return true;
			if (permission.UserHasPermission(player.UserIDString, permissionPreLoad)) return true;
			if (permission.UserHasPermission(player.UserIDString, permissionMaxCondition)) return true;
			if (permission.UserHasPermission(player.UserIDString, permissionAmmoType)) return true;
			return false;
		}
		
		private bool hasRight(BasePlayer player, string perm)
		{
			bool right = false;
			switch (perm)
			{
				case "all":
						if (permission.UserHasPermission(player.UserIDString, permissionAll)) {right = true;}
						break;
				case "maxammo":
						if (permission.UserHasPermission(player.UserIDString, permissionMaxAmmo)) {right = true;}
						break;
				case "preload":
						if (permission.UserHasPermission(player.UserIDString, permissionPreLoad)) {right = true;}
						break;
				case "maxcondition":
						if (permission.UserHasPermission(player.UserIDString, permissionMaxCondition)) {right = true;}
						break;
				case "ammotype":
						if (permission.UserHasPermission(player.UserIDString, permissionAmmoType)) {right = true;}
						break;
				default:
						break;
				
			}
			return right;
		}

		private void OnServerInitialized()
        {
			NextTick( ()=> {
				LoadVariables();
				LoadWeaponData();
				SetupDefaultWeapons();
				SaveWeaponData();
				if (!permission.PermissionExists(permissionAll)) permission.RegisterPermission(permissionAll, this);
				if (!permission.PermissionExists(permissionMaxAmmo)) permission.RegisterPermission(permissionMaxAmmo, this);
				if (!permission.PermissionExists(permissionPreLoad)) permission.RegisterPermission(permissionPreLoad, this);
				if (!permission.PermissionExists(permissionMaxCondition)) permission.RegisterPermission(permissionMaxCondition, this);
				if (!permission.PermissionExists(permissionAmmoType)) permission.RegisterPermission(permissionAmmoType, this);
			});
		}

		private void OnItemCraftFinished(ItemCraftTask task, Item item)
		{
			if(item.GetHeldEntity() is BaseProjectile)
			{
				if(!hasAnyRight(task.owner)) return;
				var weaponstats = craftedWeapon(item.info.shortname);
				if(weaponstats != null && weaponstats.settingactive == true)			
				{
					if (hasRight(task.owner,"maxammo") || hasRight(task.owner, "all"))
						(item.GetHeldEntity() as BaseProjectile).primaryMagazine.capacity = Convert.ToInt32(weaponstats.maxammo);
					if (hasRight(task.owner,"preload") || hasRight(task.owner, "all"))
						(item.GetHeldEntity() as BaseProjectile).primaryMagazine.contents = Convert.ToInt32(weaponstats.preload);
					if (hasRight(task.owner,"ammotype") || hasRight(task.owner, "all"))
					{
						var ammo = ItemManager.FindItemDefinition(weaponstats.ammotype);
						if (ammo != null)
							(item.GetHeldEntity() as BaseProjectile).primaryMagazine.ammoType = ammo;
					}
					if (hasRight(task.owner,"maxcondition") || hasRight(task.owner, "all"))
					{
						_itemMaxCondition.SetValue(item, Convert.ToSingle(weaponstats.maxcondition));
						_itemCondition.SetValue(item, Convert.ToSingle(weaponstats.maxcondition));				
					}
					if(weaponstats.skinid != 0)
						foreach( var skin in item.info.skins.ToList())
							if (skin.id == (int)weaponstats.skinid)
							{
								item.skin = weaponstats.skinid;
								item.GetHeldEntity().skinID = weaponstats.skinid;
								break;
							}
				}
			}
		}
		
		private void OnItemAddedToContainer(ItemContainer container, Item item)
		{
			if(!checkPermission) return;
			if(item.GetHeldEntity() is BaseProjectile && container.HasFlag(ItemContainer.Flag.Belt))
			{
				var weaponstats = craftedWeapon(item.info.shortname);
				if(weaponstats != null && weaponstats.settingactive)	
				{
					if ((item.GetHeldEntity() as BaseProjectile).primaryMagazine.capacity > item.info.GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.definition.builtInSize && !(hasRight(container.playerOwner, "maxammo") || hasRight(container.playerOwner, "all")))
					{
						(item.GetHeldEntity() as BaseProjectile).primaryMagazine.capacity = item.info.GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.definition.builtInSize;
						if ((item.GetHeldEntity() as BaseProjectile).primaryMagazine.contents > (item.GetHeldEntity() as BaseProjectile).primaryMagazine.capacity)
							(item.GetHeldEntity() as BaseProjectile).primaryMagazine.contents = (item.GetHeldEntity() as BaseProjectile).primaryMagazine.capacity;
					}
					if (item.maxCondition > item.info.condition.max && !(hasRight(container.playerOwner, "maxcondition") || hasRight(container.playerOwner, "all")))
					{
						var newCon = item.condition * (item.info.condition.max / item.maxCondition);
						_itemMaxCondition.SetValue(item, Convert.ToSingle(item.info.condition.max));
						_itemCondition.SetValue(item, Convert.ToSingle(newCon));
					}
					if (removeSkinIfNoRights && !hasAnyRight(container.playerOwner) && item.GetHeldEntity().skinID == weaponstats.skinid && item.GetHeldEntity().skinID != 0)
					{
						item.skin = 0;
						item.GetHeldEntity().skinID = 0;
					}
				}
			}
		}

	}
}


// --- End of file: MagazinBoost.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CombatBlock-1.1.1.cs ---
// --- Original Local Path: CombatBlock-1.1.1.cs ---

using Oxide.Core;
using ConVar;
using System.Text;
using UnityEngine.Networking;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Libraries;
using System;
using Oxide.Plugins.CombatBlockExt;
using Oxide.Core.Plugins;
using System.Collections;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using System.Globalization;
using Time = UnityEngine.Time;

namespace Oxide.Plugins.CombatBlockExt
{
	public static class ExtensionMethods
	{
		private static readonly Lang Lang = Interface.Oxide.GetLibrary<Lang>();

		
		public static string GetAdaptedMessage(this string langKey, string userID = null, params object[] args)
		{
			string message = Lang.GetMessage(langKey, CombatBlock.Instance, userID);

			if (args == null || args.Length == 0)
			{
				return message;
			}
            
			return new StringBuilder().AppendFormat(message, args).ToString();
		}

				
		
		public static string ToTimeFormat(this float source)
		{
			TimeSpan ts = TimeSpan.FromSeconds(source);
			return $"{ts.Minutes:D1}:{ts.Seconds:D2}";
		}

			}
}
namespace Oxide.Plugins
{
	[Info("CombatBlock", "Mercury", "1.1.1")]
	public class CombatBlock : RustPlugin
	{
		   		 		  						  	   		  		 			  	   		  		  		   		 
				
		
				private static void RunEffect(BasePlayer player, string prefab)
		{
			Effect effect = new Effect();
			effect.Init(Effect.Type.Generic, player.transform.position, Vector3.zero);
			effect.pooledString = prefab;
			EffectNetwork.Send(effect, player.net.connection);
		}

				
		
		private List<BasePlayer> _playerInCache = new();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new Exception();
                }

                SaveConfig();
            }
            catch
            {
                for (int i = 0; i < 3; i++)
                {
                    PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                }

                LoadDefaultConfig();
            }
            ValidateConfig();
            SaveConfig();
        }

		
		
		private void OnRaidBlock(BasePlayer player, Vector3 position)
		{
			if (player != null && player.gameObject != null)
			{
				if (player.gameObject.TryGetComponent(out CombatPlayer combatBlocker))
					combatBlocker.KillComponent(true);
			}
		}
		
		private void OnPlayerConnected(BasePlayer player)
		{
			if (player.TryGetComponent(out CombatPlayer rp))
				rp.CreateUI();
		}

		private Boolean IsCombatBlock(BasePlayer player)
		{
			if (!_combatPlayers.ContainsKey(player)) return false;
			CombatPlayer combatP = _combatPlayers[player];
			if (combatP == null) return false;
			if (combatP.UnblockTimeLeft <= 0) return false;

			return true;
		}

				
		        
        private void DrawUI_CB_Main(BasePlayer player,  float timeLeft = 0f)
        {
            string Interface = InterfaceBuilder.GetInterface(InterfaceBuilder.CB_MAIN);
            if (Interface == null) return;

            Interface = InterfaceBuilder.TypeUi switch
            {
	            0 => Interface.Replace("%Descriptions%", "COMBATBLOCK_UI_DESCRIPTIONS_V1".GetAdaptedMessage(player.UserIDString)),
	            1 => Interface.Replace("%Descriptions%", "COMBATBLOCK_UI_DESCRIPTIONS_V2".GetAdaptedMessage(player.UserIDString)),
	            _ => Interface
            };

            Interface = Interface.Replace("%Title%", "COMBATBLOCK_UI_TITLE".GetAdaptedMessage(player.UserIDString));

		   		 		  						  	   		  		 			  	   		  		  		   		 
            CuiHelper.DestroyUi(player, InterfaceBuilder.CB_MAIN);
            CuiHelper.AddUi(player, Interface);
            
            DrawUI_CB_Updated(player, timeLeft == 0 ? config.CombatBlockMain.CombatBlockDuration : timeLeft, true);
        }	
		   		 		  						  	   		  		 			  	   		  		  		   		 
		
		
		private bool IsDuel(ulong userID)
		{
			object playerId = ObjectCache.Get(userID);
			BasePlayer player = null;
			if (Duel != null || Duelist != null)
				player = BasePlayer.FindByID(userID);

			object result = EventHelper?.Call("EMAtEvent", playerId);
			if (result is bool && ((bool)result) == true)
				return true;
		   		 		  						  	   		  		 			  	   		  		  		   		 

			if (Battles != null && Battles.Call<bool>("IsPlayerOnBattle", playerId))
				return true;


			if (Duel != null && Duel.Call<bool>("IsPlayerOnActiveDuel", player))
				return true;
			if (Duelist != null && Duelist.Call<bool>("inEvent", player))
				return true;
		   		 		  						  	   		  		 			  	   		  		  		   		 
			if (ArenaTournament != null && ArenaTournament.Call<bool>("IsOnTournament", playerId))
				return true;

			return false;
		}
		private Dictionary<BasePlayer ,CombatPlayer> _combatPlayers = new();

		
		private Boolean IsCombatBlocked(BasePlayer player) => IsCombatBlock(player);
		private static ImageUI _imageUI;
		private object canTeleport(BasePlayer player) => CanTeleport(player);

		
        
        private class CombatPlayer : FacepunchBehaviour
        {
	        public BasePlayer player;
            private float _timeToUnblock;
            private int _combatBlockDuration;
            public float UnblockTimeLeft => _timeToUnblock - Time.realtimeSinceStartup;

            private void Awake()
            {
	            player = gameObject.GetComponent<BasePlayer>();
	            _combatBlockDuration = Instance.config.CombatBlockMain.CombatBlockDuration;
	            _timeToUnblock = Time.realtimeSinceStartup + _combatBlockDuration;
	            CreateUI();
	            InvokeRepeating(RefreshUI, 0f, 1);
	            
	            Instance.SendChat("COMBATBLOCK_ENTER_COMBAT_INITIATOR".GetAdaptedMessage(player.UserIDString, UnblockTimeLeft.ToTimeFormat()), player);
            }
		   		 		  						  	   		  		 			  	   		  		  		   		 
            private void OnDestroy()
            {
	            Interface.CallHook ("OnCombatBlockStopped", player);
            }
            
            public void UpdateBlockTime()
            {
	            _timeToUnblock = Time.realtimeSinceStartup + _combatBlockDuration;
            }
		   		 		  						  	   		  		 			  	   		  		  		   		 
            public void CreateUI()
            {
	            if (player != null)
	            {
		            Instance.DrawUI_CB_Main(player, UnblockTimeLeft);
	            }
            }

            
            public void KillComponent(bool isRaidBlocked = false)
            {
	            if (player != null)
		            CuiHelper.DestroyUi(player, InterfaceBuilder.CB_MAIN);
	            
	            if(!isRaidBlocked)
					Instance.SendChat("COMBATBLOCK_END_BLOCK".GetAdaptedMessage(player.UserIDString), player);

	            CancelInvoke(nameof(RefreshUI));
	            if (Instance._combatPlayers.ContainsKey(player))
		            Instance._combatPlayers.Remove(player);
	            
	            Destroy(this);
            }

            private void RefreshUI()
            {
	            if (UnblockTimeLeft <= 0)
	            {
		            KillComponent();
	            }
	            else if (player != null)
	            {
		            Instance.DrawUI_CB_Updated(player, UnblockTimeLeft);
	            }
            }
        }
		private Boolean IsCombatBlocked(String playerID)
		{
			if (!UInt64.TryParse(playerID, out UInt64 id)) return false;
			BasePlayer player = BasePlayer.FindByID(id);
			return player != null && IsCombatBlock(player);
		}
		private object CanRedeemKit(BasePlayer player) => CanActions(player);
		private object CanTrade(BasePlayer player) => CanActions(player, true);
		
		private void Unload()
		{
			foreach (CombatPlayer obj in _combatPlayers.Values)
				UnityEngine.Object.Destroy(obj);
			InterfaceBuilder.DestroyAll();
			_interface = null;
			Instance = null;
		}

                
        
		private class ImageUI
		{
			private readonly string _paths;
			private readonly string _printPath;
			private readonly Dictionary<string, ImageData> _images;

			private enum ImageStatus
			{
				NotLoaded,
				Loaded,
				Failed
			}

			public ImageUI()
			{
				_paths = Instance.Name + "/Images/";
				_printPath = "data/" + _paths;
				_images = new Dictionary<string, ImageData>
				{
					{ "CB_FON0", new ImageData() },
					{ "CB_FON1", new ImageData() },
					{ "CB_FON2", new ImageData() },
					{ "CB_VARIANT0_ICON", new ImageData() },
					{ "CB_VARIANT1_ICON_FON", new ImageData() },
					{ "CB_VARIANT1_ICON", new ImageData() },
					{ "CB_VARIANT2_ICON", new ImageData() },
				};
			}

			private class ImageData
			{
				public ImageStatus Status = ImageStatus.NotLoaded;
				public string Id { get; set; }
			}

			public string GetImage(string name)
			{
				ImageData image;
				if (_images.TryGetValue(name, out image) && image.Status == ImageStatus.Loaded)
					return image.Id;
				return null;
			}

			public void DownloadImage()
			{
				KeyValuePair<string, ImageData>? image = null;
				foreach (KeyValuePair<string, ImageData> img in _images)
				{
					if (img.Value.Status == ImageStatus.NotLoaded)
					{
						image = img;
						break;
					}
				}

				if (image != null)
				{
					ServerMgr.Instance.StartCoroutine(ProcessDownloadImage(image.Value));
				}
				else
				{
					List<string> failedImages = new List<string>();

					foreach (KeyValuePair<string, ImageData> img in _images)
					{
						if (img.Value.Status == ImageStatus.Failed)
						{
							failedImages.Add(img.Key);
						}
					}

					if (failedImages.Count > 0)
					{
						string images = string.Join(", ", failedImages);
						Instance.PrintError(LanguageEn
							? $"Failed to load the following images: {images}. Perhaps you did not upload them to the '{_printPath}' folder."
							: $"Не удалось загрузить следующие изображения: {images}. Возможно, вы не загрузили их в папку '{_printPath}'.");
						Interface.Oxide.UnloadPlugin(Instance.Name);
					}
					else
					{
						Instance.Puts(LanguageEn
							? $"{_images.Count} images downloaded successfully!"
							: $"{_images.Count} изображений успешно загружено!");
                        
                        Instance.Puts(LanguageEn ? "Generating the interface, please wait for approximately 5-10 seconds" : "Генерируем интерфейс, ожидайте ~5-10 секунд");
                        _interface = new InterfaceBuilder();
                        Instance.Puts(LanguageEn ? "The interface has been successfully loaded" : "Интерфейс успешно загружен!");
					}
				}
			}

			public void UnloadImages()
			{
				foreach (KeyValuePair<string, ImageData> item in _images)
					if (item.Value.Status == ImageStatus.Loaded)
						if (item.Value?.Id != null)
							FileStorage.server.Remove(uint.Parse(item.Value.Id), FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID);

				_images?.Clear();
			}

            private IEnumerator ProcessDownloadImage(KeyValuePair<string, ImageData> image)
			{
                string url = "file://" + Interface.Oxide.DataDirectory + "/" + _paths + image.Key + ".png";

                using UnityWebRequest www = UnityWebRequestTexture.GetTexture(url);
                yield return www.SendWebRequest();

                if (www.result is UnityWebRequest.Result.ConnectionError or UnityWebRequest.Result.ProtocolError)
                {
                    image.Value.Status = ImageStatus.Failed;
                }
                else
                {
                    Texture2D tex = DownloadHandlerTexture.GetContent(www);
                    image.Value.Id = FileStorage.server.Store(tex.EncodeToPNG(), FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID).ToString();
                    image.Value.Status = ImageStatus.Loaded;
                    UnityEngine.Object.DestroyImmediate(tex);
                }

                DownloadImage();
            }
		}

		private void OnServerInitialized()
		{
			permission.RegisterPermission(Name + _permIgnoreCombat,this);
			
			_imageUI = new ImageUI();
			_imageUI.DownloadImage();
			
			if(config.BlockDetect.ActivateOnNpcDamageReceived)
				Subscribe(nameof(OnEntityTakeDamage));

			if (config.ActionsBlocked.CanTeleport)
			{
				Subscribe(nameof(CanTeleport));
				Subscribe(nameof(canTeleport));
			}
			if (config.ActionsBlocked.CanTrade)
			{
				Subscribe(nameof(canTrade));
				Subscribe(nameof(CanTrade));
			}
			if (config.ActionsBlocked.CanUseKit)
			{
				Subscribe(nameof(CanRedeemKit));
			}
		   		 		  						  	   		  		 			  	   		  		  		   		 
			if (config.CombatBlockMain.CombatBlockOnRaidBlock)
			{
				Subscribe(nameof(OnRaidBlock));
				Subscribe(nameof(OnRaidBlockStarted));
			}
			
			if (config.ActionsBlocked.BlockedCommands != null && config.ActionsBlocked.BlockedCommands.Count != 0)
			{
				if (config.ActionsBlocked.BlockedCommands.Count == 1 && config.ActionsBlocked.BlockedCommands[0].Equals("commandExample")) return;
				
				Subscribe(nameof(OnPlayerCommand));
				Subscribe(nameof(OnServerCommand));
			}
		}

		
		
		private void Init()
		{
			Instance = this;
			Unsubscribe(nameof(OnEntityTakeDamage));
			Unsubscribe(nameof(OnPlayerCommand));
			Unsubscribe(nameof(OnServerCommand));
			Unsubscribe(nameof(CanTeleport));
			Unsubscribe(nameof(canTeleport));
			Unsubscribe(nameof(CanRedeemKit));
			Unsubscribe(nameof(canTrade));
			Unsubscribe(nameof(CanTrade));
			Unsubscribe(nameof(OnRaidBlock));
			Unsubscribe(nameof(OnRaidBlockStarted));
		}

		private void StartCombatBlocked(BasePlayer player)
		{
			if (player == null)
			{
				Debug.LogError("StartCombatBlocked was called with a null player.");
				return;
			}

			if (permission.UserHasPermission(player.UserIDString, $"{Name}{_permIgnoreCombat}"))
				return;

			if (Interface.Call("CanCombatBlocked", player) != null) 
				return;
			
			if (Interface.Call("CanCombatBlock", player) != null) 
				return;

			if (player.gameObject.TryGetComponent(out CombatPlayer combatBlocker))
			{
				combatBlocker.UpdateBlockTime();
			}
			else
			{
				try
				{
					combatBlocker = player.gameObject.AddComponent<CombatPlayer>();
					_combatPlayers.Add(player, combatBlocker);
				}
				catch (Exception ex)
				{
					Debug.LogError($"Error adding CombatPlayer component: {ex.Message}");
					return;
				}
			}

			Interface.CallHook("OnCombatBlockStarted", player);
		}

        protected override void LoadDefaultConfig()
        {
            config = new Configuration();
        }
        
        private void DrawUI_CB_Updated(BasePlayer player, float timeLeft, bool upd = false)
        {
            string Interface = InterfaceBuilder.GetInterface(InterfaceBuilder.CB_PROGRESS_BAR);
            if (Interface == null) return;
            double factor = InterfaceBuilder.Factor * timeLeft / config.CombatBlockMain.CombatBlockDuration;

            Interface = Interface.Replace("%left%", factor.ToString(CultureInfo.InvariantCulture));
            Interface = Interface.Replace("%TimeLeft%", "COMBATBLOCK_UI_TIMER".GetAdaptedMessage(player.UserIDString, timeLeft.ToTimeFormat()));
            if(!upd)
                Interface = Interface.Replace("0.222", "0");

            CuiHelper.DestroyUi(player, InterfaceBuilder.CB_PROGRESS);
            CuiHelper.DestroyUi(player, InterfaceBuilder.CB_PROGRESS_TIMER);
            CuiHelper.AddUi(player, Interface);
        }
		private object canTrade(BasePlayer player) => CanTrade(player);

		private bool IsClans(string userID, string targetID)
		{
			if (Clans)
			{
				string tagUserID = (string)Clans?.Call("GetClanOf", userID);
				string tagTargetID = (string)Clans?.Call("GetClanOf", targetID);
				if (tagUserID == null && tagTargetID == null)
				{
					return false;
				}

				return tagUserID == tagTargetID;
			}

			return false;
		}

		private void OnEntityDeath(BaseCombatEntity entity, HitInfo hitInfo)
		{
			if (entity.ToPlayer() == null)
				return;
			BasePlayer player = entity.ToPlayer();

			if (player != null && player.gameObject != null)
			{
				CombatPlayer combatBlocker = player.gameObject.GetComponent<CombatPlayer>();
				if (config.BlockDetect.DeactivateOnPlayerDeath && combatBlocker != null)
					combatBlocker.KillComponent();
			}
		}
        

        private class InterfaceBuilder
		{
			
			private static InterfaceBuilder _instance;
            public const string CB_MAIN = "CB_MAIN";
            public const string CB_PROGRESS_BAR = "CB_PROGRESS_BAR";
            public const string CB_PROGRESS = "CB_PROGRESS";
            public const string CB_PROGRESS_TIMER = "CB_PROGRESS_TIMER";

            public static int TypeUi;
            public static double Factor;
            private Configuration.CombatBlockUi.CombatBlockUiSettings _uiSettings;
            private static float _fade;

			private Dictionary<string, string> _interfaces;

			
						public InterfaceBuilder()
			{
				_instance = this;
				_interfaces = new Dictionary<string, string>();
                TypeUi = Instance.config.CombatBlockInterface.UiType;
                Factor = TypeUi switch
                {
                    0 => 142,
                    1 => 195,
                    _ => 130
                };
                _uiSettings = TypeUi switch
                {
                    0 => Instance.config.CombatBlockInterface.InterfaceSettingsVariant0,
                    1 => Instance.config.CombatBlockInterface.InterfaceSettingsVariant1,
                    2 => Instance.config.CombatBlockInterface.InterfaceSettingsVariant2,
                    _ => throw new ArgumentOutOfRangeException()
                };
                _fade = _uiSettings.SmoothTransition;
              

                switch (TypeUi)
                {
                    case 0:
                        BuildingCombatBlockMain();
                        BuildingCombatBlockUpdated();
                        break;
                    case 1:
                        BuildingCombatBlockMainV2();
                        BuildingCombatBlockUpdatedV2();
                        break;
                    case 2:
                        BuildingCombatBlockMainV3();
                        BuildingCombatBlockUpdatedV3();
                        break;
                }
            }

			private static void AddInterface(string name, string json)
			{
				if (_instance._interfaces.ContainsKey(name))
				{
					Instance.PrintError($"Error! Tried to add existing cui elements! -> {name}");
					return;
				}

				_instance._interfaces.Add(name, json);
			}

			public static string GetInterface(string name)
			{
				string json;
				if (_instance._interfaces.TryGetValue(name, out json) == false)
				{
					Instance.PrintWarning($"Warning! UI elements not found by name! -> {name}");
				}

				return json;
			}

			public static void DestroyAll()
			{
				foreach (BasePlayer player in BasePlayer.activePlayerList)
					CuiHelper.DestroyUi(player, CB_MAIN);
			}

			
			
			private void BuildingCombatBlockMain()
            {
		   		 		  						  	   		  		 			  	   		  		  		   		 
				CuiElementContainer container = new CuiElementContainer();
                
                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "0 0 0 0", FadeIn = _fade },
                    RectTransform ={ AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = $"{-179.006 + Instance.config.CombatBlockInterface.OffsetX} {-110.5 + Instance.config.CombatBlockInterface.OffsetY}", OffsetMax = $"{-0.006 + Instance.config.CombatBlockInterface.OffsetX} {-40.5 + Instance.config.CombatBlockInterface.OffsetY}" }
                },Instance.config.CombatBlockInterface.Layers ,CB_MAIN);
                
                container.Add(new CuiElement
                {
                    Name = "CB_BACKGROUND",
                    Parent = CB_MAIN,
                    Components = {
                        new CuiRawImageComponent { Color = _uiSettings.BackgroundColor, Png = _imageUI.GetImage("CB_FON0"), FadeIn = _fade },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1"}
                    }
                });
                
                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = _uiSettings.ProgressBarBackgroundColor, FadeIn = _fade },
                    RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-71.001 9.367", OffsetMax = "70.999 12.033" }
                },CB_MAIN,CB_PROGRESS_BAR);
                
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-71.001 -9.637", OffsetMax = "84.101 14.717" },
                    Text = { Text = "%Descriptions%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = _uiSettings.SecondaryTextColor, FadeIn = _fade }
                }, CB_MAIN);
                
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-71.001 14.717", OffsetMax = "5.043 29.111"},
                    Text = { Text = "%Title%", Font = "robotocondensed-bold.ttf", FontSize = 11, Align = TextAnchor.MiddleLeft, Color = _uiSettings.MainTextColor , FadeIn = _fade}
                }, CB_MAIN);
                
                container.Add(new CuiElement
                {
                    Name = "CB_ICON",
                    Parent = CB_MAIN,
                    Components = {
                        new CuiRawImageComponent { Color = _uiSettings.IconColor, Png = _imageUI.GetImage("CB_VARIANT0_ICON") },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "6.38 16.914", OffsetMax = "15.62 26.914" }
                    }
                });
		   		 		  						  	   		  		 			  	   		  		  		   		 
                AddInterface(CB_MAIN, container.ToJson());
			}
            
            private void BuildingCombatBlockUpdated()
            {
                CuiElementContainer container = new CuiElementContainer();
                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = _uiSettings.ProgressBarMainColor, FadeIn = _fade },
                    RectTransform ={ AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "0 -1.333", OffsetMax = "%left% 1.333" }
                },CB_PROGRESS_BAR,CB_PROGRESS);

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-71.001 -21.162", OffsetMax = "35.499 -9.638"},
                    Text = {  Text = "%TimeLeft%", Font = "robotocondensed-regular.ttf", FontSize = 9, Align = TextAnchor.MiddleLeft, Color = _uiSettings.MainTextColor }
                }, CB_MAIN, CB_PROGRESS_TIMER);

                AddInterface(CB_PROGRESS_BAR, container.ToJson());
            }
                        
            
			private void BuildingCombatBlockMainV2()
            {
				CuiElementContainer container = new CuiElementContainer();
                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "1 1 1 0", FadeIn = _fade },
                    RectTransform ={ AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = $"{-200.01 + Instance.config.CombatBlockInterface.OffsetX} {-96 + Instance.config.CombatBlockInterface.OffsetY}", OffsetMax = $"{-0.01 + Instance.config.CombatBlockInterface.OffsetX} {-56 + Instance.config.CombatBlockInterface.OffsetY}"
                    }

                },Instance.config.CombatBlockInterface.Layers,CB_MAIN);
                
                container.Add(new CuiElement
                {
                    Name = "CB_BACKGROUND",
                    Parent = CB_MAIN,
                    Components = {
                        new CuiRawImageComponent { Color = _uiSettings.BackgroundColor , Png = _imageUI.GetImage("CB_FON1"), FadeIn = _fade },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-100.001 -17", OffsetMax = "99.999 20" }
                    }
                });
                
                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = _uiSettings.ProgressBarBackgroundColor, FadeIn = _fade },
                    RectTransform ={ AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-97.5 0", OffsetMax = "97.5 3.33" }
                },CB_MAIN,CB_PROGRESS_BAR);

                container.Add(new CuiLabel
                {
                    RectTransform = {AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-64.622 0", OffsetMax = "5.368 15.562" },
                    Text = {  Text = "%Title%", Font = "robotocondensed-bold.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = _uiSettings.MainTextColor, FadeIn = _fade }
                }, CB_MAIN);
                
                container.Add(new CuiLabel
                {
                    RectTransform = {  AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-64.622 -12.76", OffsetMax = "68.698 2.76" },
                    Text = { Text = "%Descriptions%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = _uiSettings.SecondaryTextColor, FadeIn = _fade}
                }, CB_MAIN);
                
                container.Add(new CuiElement
                {
                    Name = "CB_ICON_FON",
                    Parent = CB_MAIN,
                    Components = {
                        new CuiRawImageComponent { Color = _uiSettings.AdditionalElementsColor, Png = _imageUI.GetImage("CB_VARIANT1_ICON_FON") },
                        new CuiRectTransformComponent { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "8.199 -10", OffsetMax = "32.199 13" }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "CB_ICON",
                    Parent = "CB_ICON_FON",
                    Components = {
                        new CuiRawImageComponent { Color = _uiSettings.IconColor, Png = _imageUI.GetImage("CB_VARIANT1_ICON") },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-9 -8.5", OffsetMax = "9 8.5" }
                    }
                });
                
                AddInterface(CB_MAIN, container.ToJson());
			}
            
            private void BuildingCombatBlockUpdatedV2()
            {
                CuiElementContainer container = new CuiElementContainer();
                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = _uiSettings.ProgressBarMainColor, FadeIn = _fade },
                    RectTransform ={ AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "0 -1.665", OffsetMax = "%left% 1.665" }
                },CB_PROGRESS_BAR,CB_PROGRESS);
                AddInterface(CB_PROGRESS_BAR, container.ToJson());
            }
                        
            
			private void BuildingCombatBlockMainV3()
            {
				CuiElementContainer container = new CuiElementContainer();
                
                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "1 1 1 0", FadeIn = _fade },
                    RectTransform ={ AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = $"{-200 + Instance.config.CombatBlockInterface.OffsetX} {-104 + Instance.config.CombatBlockInterface.OffsetY}", OffsetMax = $"{0 + Instance.config.CombatBlockInterface.OffsetX} {-48 + Instance.config.CombatBlockInterface.OffsetY}"
                    }
                },Instance.config.CombatBlockInterface.Layers,CB_MAIN);
                
                container.Add(new CuiElement
                {
                    Name = "CB_BACKGROUND",
                    Parent = CB_MAIN,
                    Components = {
                        new CuiRawImageComponent { Color = _uiSettings.BackgroundColor, Png = _imageUI.GetImage("CB_FON2"), FadeIn = _fade },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1"}
                    }
                });
                
                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = _uiSettings.ProgressBarBackgroundColor, FadeIn = _fade },
                    RectTransform ={ AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-46.03 9.425", OffsetMax = "83.97 12.755" }
                },CB_MAIN,CB_PROGRESS_BAR);
                
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-15.954 1.549", OffsetMax = "83.97 21.851" },
                    Text = { Text = "%Title%", Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleRight, Color = _uiSettings.MainTextColor, FadeIn = _fade}
                }, CB_MAIN);
                
                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = _uiSettings.AdditionalElementsColor },
                    RectTransform ={ AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-7.9 -25", OffsetMax = "-1.9 26" }
                },CB_MAIN,"CB_RIGHT_PANEL");
                
                container.Add(new CuiElement
                {
                    Name = "CB_ICON",
                    Parent = CB_MAIN,
                    Components = {
                        new CuiRawImageComponent { Color = _uiSettings.IconColor, Png = _imageUI.GetImage("CB_VARIANT2_ICON") },
                        new CuiRectTransformComponent { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "2.3 -20", OffsetMax = "42.3 20" }
                    }
                });
                
                AddInterface(CB_MAIN, container.ToJson());
			}
            
            private void BuildingCombatBlockUpdatedV3()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = _uiSettings.ProgressBarMainColor, FadeIn = _fade },
                    RectTransform ={ AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "0 -1.665", OffsetMax = "%left% 1.665" }
                },CB_PROGRESS_BAR,CB_PROGRESS);
                
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-46.03 -12.245", OffsetMax = "83.97 5.465" },
                    Text = { Text = "%TimeLeft%", Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleRight, Color = _uiSettings.SecondaryTextColor, FadeIn = _fade}
                }, CB_MAIN, CB_PROGRESS_TIMER);

                AddInterface(CB_PROGRESS_BAR, container.ToJson());
            }
            		}

		private void OnRaidBlockStarted(BasePlayer player)
		{
			if (player != null && player.gameObject != null)
			{
				if (player.gameObject.TryGetComponent(out CombatPlayer combatBlocker))
					combatBlocker.KillComponent(true);
			}
		}

				private bool IsRaidBlocked(BasePlayer player, bool chat = false)
		{
			if (!config.CombatBlockMain.CombatBlockOnRaidBlock && !chat)
				return false;
			if (RaidBlock)
				return RaidBlock.Call<bool>("IsRaidBlocked", player);
			if (NoEscape)
				return NoEscape.Call<bool>("IsRaidBlocked", player);

			return false;
		}

				
				[PluginReference] Plugin RaidBlock, NoEscape, IQChat, Friends, Clans, Duelist, Duel, EventHelper, Battles, ArenaTournament;
		
				
		        private Configuration config;

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

		private void OnPlayerAttack(BasePlayer attacker, HitInfo hitInfo)
		{
			if (hitInfo.HitEntity is not BasePlayer target) return;
			if (!config.BlockDetect.ActivateOnNpcAttack && target.IsNpc) return;
			if (!config.BlockDetect.ActivateOnSleeperAttack && target.IsSleeping()) return;
			if (!config.BlockDetect.ActivateOnNpcDamageReceived && attacker.IsNpc) return;
		   		 		  						  	   		  		 			  	   		  		  		   		 
			if (!target.IsNpc && !attacker.IsNpc)
				if (IsFriends(attacker.userID.Get(), target.userID.Get()) || IsClans(attacker.UserIDString, target.UserIDString))
					return;

			if (!IsRaidBlocked(target) && !IsDuel(target.userID.Get()))
				StartCombatBlocked(target);
			if (!IsRaidBlocked(attacker) && !IsDuel(attacker.userID.Get()))
				StartCombatBlocked(attacker);
		}

		private const string _permIgnoreCombat = ".ignore";

		private Boolean IsCombatBlocked(UInt64 playerID)
		{
			BasePlayer player = BasePlayer.FindByID(playerID);
			return player != null && IsCombatBlock(player);
		}

		private object OnServerCommand(ConsoleSystem.Arg arg)
		{
			BasePlayer player = arg.Player();
			if (player == null || arg.cmd.FullName == "chat.say") return null;
			
			String command = arg.cmd.Name;
			if (arg.Args != null && arg.Args.Length != 0)
				command += " " + String.Join(" ", arg.Args);
            
			String onlyCommand = !String.IsNullOrWhiteSpace(command) && command.Contains(" ") ? command.Substring(0, command.IndexOf(" ", StringComparison.Ordinal)) : command;
			
			return config.ActionsBlocked.BlockedCommands.Contains(onlyCommand.ToLower()) ? CanActions(player) : null;
		}
		private void SendChat(string message, BasePlayer player, Single timeout = 0f, Chat.ChatChannel channel = Chat.ChatChannel.Global)
		{
			if(IsRaidBlocked(player, true))
				return;
			if (_playerInCache.Contains(player)) return;
			if (timeout != 0)
			{
				_playerInCache.Add(player);
				player.Invoke(() => _playerInCache.Remove(player), timeout);
			}
            
			Configuration.IQChat chat = config.IQChatSetting;
			if (IQChat)
				if (chat.UIAlertUse)
					IQChat?.Call("API_ALERT_PLAYER_UI", player, message);
				else IQChat?.Call("API_ALERT_PLAYER", player, message, chat.CustomPrefix, chat.CustomAvatar);
			else player.SendConsoleCommand("chat.add", channel, 0, message);
		}
		private const bool LanguageEn = false;
        		
				
		protected override void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["COMBATBLOCK_ACTION_BLOCKED"] = "You are prohibited from performing this action during a <color=#C26D33>combat-block</color>, please wait {0}",
				["COMBATBLOCK_END_BLOCK"] = "Block <color=#738D45>deactivated</color>.\nFunctions unlocked",
				["COMBATBLOCK_ENTER_COMBAT_INITIATOR"] = "Combat activity!\nCombat-block activated for <color=#C26D33>{0}</color>.\nSome functions are temporarily unavailable",
				["COMBATBLOCK_UI_TIMER"] = "Time remaining {0}",
				["COMBATBLOCK_UI_TITLE"] = "COMBAT BLOCK",
				["COMBATBLOCK_UI_DESCRIPTIONS_V1"] = "Combat activity, some functions have been restricted",
				["COMBATBLOCK_UI_DESCRIPTIONS_V2"] = "Some functions have been disabled",
			}, this);
			
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["COMBATBLOCK_ACTION_BLOCKED"] = "Вам запрещено совершать это действие во время <color=#C26D33>комбат-блока</color>, подождите {0}",
				["COMBATBLOCK_END_BLOCK"] = "Блок <color=#738D45>деактивирован</color>.\nФункции разблокированы",
				["COMBATBLOCK_ENTER_COMBAT_INITIATOR"] = "Боевая активность!\nАктивирован комбат-блок на <color=#C26D33>{0}</color>.\nНекоторые функции временно недоступны.",
				["COMBATBLOCK_UI_TIMER"] = "Осталось {0}",
				["COMBATBLOCK_UI_TITLE"] = "COMBAT BLOCK",
				["COMBATBLOCK_UI_DESCRIPTIONS_V1"] = "Боевая активность, некоторые функции были ограничены",
				["COMBATBLOCK_UI_DESCRIPTIONS_V2"] = "Некоторые функции были отключены",
			}, this, "ru");
		}
		
		public static CombatBlock Instance;

        private class Configuration
        {
             
            [JsonProperty(LanguageEn ? "Primary combat settings" : "Основные настройки комбат-блока")] 
            public CombatBlock CombatBlockMain = new();
	        public class CombatBlockActionsBlocked
	        {
		        [JsonProperty(LanguageEn ? "Disable teleportation capability (true - yes/false - no)" : "Блокировать возможность телепортироваться (true - да/false - нет)")]
		        public bool CanTeleport = true;
		        [JsonProperty(LanguageEn ? "Disable the use of kits (true - yes/false - no)" : "Блокировать возможность использования китов (true - да/false - нет)")]
		        public bool CanUseKit = true;
		        [JsonProperty(LanguageEn ? "Disable trade functionality (true - yes/false - no)" : "Блокировать возможность обмена (Trade) (true - да/false - нет)")]
		        public bool CanTrade = true;

		        [JsonProperty(LanguageEn ? "List of prohibited commands during active lockdown [Specify them without a slash (/)]" : "Список запрещенных команд при активной блокировки [указывайте их без слэша (/)]", ObjectCreationHandling = ObjectCreationHandling.Replace)]
		        public List<string> BlockedCommands = new List<string>()
		        {
			        "commandExample",
		        };
	        }
	        public class CombatBlock
	        {
		        
		        [JsonProperty(LanguageEn ? "Disable the combat block when receiving a raid block (true - yes/false - no)" : "Отключить комбат блок при получении рейд блока (true - да/false - нет)")]
                public bool CombatBlockOnRaidBlock = true;
		        [JsonProperty(LanguageEn ? "Lockout time (seconds)" : "Время блокировки (секунды)")]
		        public int CombatBlockDuration = 150;
	        }
            [JsonProperty(LanguageEn ? "Interface settings" : "Настройки интерфейса")] 
            public CombatBlockUi CombatBlockInterface = new();
             
             public class IQChat
             {
	             [JsonProperty(LanguageEn ? "IQChat : Custom prefix in the chat" : "IQChat : Кастомный префикс в чате")]
	             public String CustomPrefix = "[<color=#C26D33>CombatBlock</color>]";
	             [JsonProperty(LanguageEn ? "IQChat : Custom avatar in the chat (If required)" : "IQChat : Кастомный аватар в чате(Если требуется)")]
	             public String CustomAvatar = "0";
	             [JsonProperty(LanguageEn ? "IQChat : Use UI notifications" : "IQChat : Использовать UI уведомления")]
	             public Boolean UIAlertUse = false;
             }
            [JsonProperty(LanguageEn ? "Trigger settings" : "Настройка триггеров")] 
            public CombatBlockDetect BlockDetect = new();
            
             public class CombatBlockUi
            {
                [JsonProperty(LanguageEn ? "Interface variant (0, 1, 2) - example: " : "Вариант интерфейса (0, 1, 2)")]
                public int UiType = 0;
                [JsonProperty(LanguageEn ? "Interface layer: Overlay - will overlay other UI, Hud - will be overlaid by other interfaces" : "Слой интерфейса : Overlay - будет перекрывать другие UI, Hud - будет перекрываться другим интерфейсом")]
                public string Layers = "Hud";
                [JsonProperty(LanguageEn ? "Vertical padding" : "Вертикальный отступ")]
                public int OffsetY = 0;
                [JsonProperty(LanguageEn ? "Horizontal padding" : "Горизонтальный отступ")]
                public int OffsetX = 0;
                
                [JsonProperty(LanguageEn ? "Interface settings for variant 0" : "Настройки интерфейса для варианта 0")]
                public CombatBlockUiSettings InterfaceSettingsVariant0 = new()
                {
                    BackgroundColor = "0.1921569 0.1921569 0.1921569 1",
                    IconColor = "0 0.7764706 1 1",
                    AdditionalElementsColor = "",
                    MainTextColor = "1 1 1 1",
                    SecondaryTextColor = "1 1 1 0.5019608",
                    ProgressBarMainColor = "0.3411765 0.5490196 0.9607843 1",
                    ProgressBarBackgroundColor = "1 1 1 0.1019608",
                    SmoothTransition = 0.222f,
                };
                
                [JsonProperty(LanguageEn ? "Interface settings for variant 1" : "Настройки интерфейса для варианта 1")]
                public CombatBlockUiSettings InterfaceSettingsVariant1 = new()
                {
                    BackgroundColor = "0.9607843 0.772549 0.7333333 0.7019608",
                    IconColor = "1 1 1 1",
                    AdditionalElementsColor = "0.9215686 0.3058824 0.172549 1",
                    MainTextColor = "0.1921569 0.192081 0.1921569 1",
                    SecondaryTextColor = "0.1320755 0.1320755 0.1320755 1",
                    ProgressBarMainColor = "0.9215686 0.3058824 0.172549 1",
                    ProgressBarBackgroundColor = "1 1 1 0.4117647",
                    SmoothTransition = 0.222f
                };
                
                [JsonProperty(LanguageEn ? "Interface settings for variant 2" : "Настройки интерфейса для варианта 2")]
                public CombatBlockUiSettings InterfaceSettingsVariant2 = new()
                {
                    BackgroundColor = "0.1921569 0.1921569 0.1921569 1",
                    IconColor = "0.9411765 0.3137255 0.286081 1",
                    AdditionalElementsColor = "0.9568627 0.3607843 0.2627451 1",
                    MainTextColor = "1 1 1 1",
                    SecondaryTextColor = "1 1 1 0.5019608",
                    ProgressBarMainColor = "1 1 1 1",
                    ProgressBarBackgroundColor = "1 1 1 0.4117647",
                    SmoothTransition = 0.222f
                };
                
                public class CombatBlockUiSettings
                {
                    [JsonProperty(LanguageEn ? "Background color (RGBA)" : "Цвет фона (RGBA)")]
                    public string BackgroundColor;
                    [JsonProperty(LanguageEn ? "Icon color (RGBA)" : "Цвет иконки (RGBA)")]
                    public string IconColor;
                    [JsonProperty(LanguageEn ? "Color of additional elements (RGBA)" : "Цвет дополнительных элементов (RGBA)")]
                    public string AdditionalElementsColor;
                    [JsonProperty(LanguageEn ? "Main text color (RGBA)" : "Цвет основного текста (RGBA)")]
                    public string MainTextColor;
                    [JsonProperty(LanguageEn ? "Secondary text Color (RGBA)" : "Цвет второстепенного текста (RGBA)")]
                    public string SecondaryTextColor;
                    [JsonProperty(LanguageEn ? "Main color of the progress-bar (RGBA)" : "Основной цвет прогресс-бара (RGBA)")]
                    public string ProgressBarMainColor;
                    [JsonProperty(LanguageEn ? "Background Color of the Progress Bar (RGBA)" : "Цвет фона прогресс-бара (RGBA)")]
                    public string ProgressBarBackgroundColor;
                    [JsonProperty(LanguageEn ? "Delay before the UI appears and disappears (for smooth transitions)" : "Задержка перед появлением и исчезновением UI (для плавности)")]
                    public float SmoothTransition;
                }
            }
            [JsonProperty(LanguageEn ? "Setting IQChat" : "Настройка IQChat")]
            public IQChat IQChatSetting = new IQChat();
	        public class CombatBlockDetect
	        {
		        [JsonProperty(LanguageEn ? "Activate combat mode upon NPC attack (true - yes/false - no)" : "Активировать комбат-блок при атаке NPC (true - да/false - нет)")]
		        public bool ActivateOnNpcAttack = true;
		        [JsonProperty(LanguageEn ? "Activate combat mode upon receiving damage from NPCs (true - yes/false - no)" : "Активировать комбат-блок при получении урона от NPC (true - да/false - нет)")]
		        public bool ActivateOnNpcDamageReceived = true;
		        [JsonProperty(LanguageEn ? "Activate combat block when dealing damage to a sleeping player (true - yes/false - no)" : "Активировать комбат-блок при нанесении урона спящему игроку (true - да/false - нет)")]
		        public bool ActivateOnSleeperAttack = false;
		        [JsonProperty(LanguageEn ? "Deactivate combat mode after death (true - yes/false - no)" : "Деактивировать комбат-блок после смерти (true - да/false - нет)")]
		        public bool DeactivateOnPlayerDeath = true;
	        }
            [JsonProperty(LanguageEn ? "Combat mode restrictions settings" : "Настройка ограничений во время комбат-блока")] 
            public CombatBlockActionsBlocked ActionsBlocked = new();
            
        }

		
		
		private object OnPlayerCommand(BasePlayer player, String command, String[] args)
		{
			if (player == null) return null;
            
			if (args != null && args.Length != 0)
				command += " " + String.Join(" ", args);
            
			String onlyCommand = !String.IsNullOrWhiteSpace(command) && command.Contains(" ") ? command.Substring(0, command.IndexOf(" ", StringComparison.Ordinal)) : command;
            
			return config.ActionsBlocked.BlockedCommands.Contains(onlyCommand.ToLower()) ? CanActions(player) : null;
		}

        private void ValidateConfig()
        {
            
        }


		
		
		private static class ObjectCache
		{
			private static readonly object True = true;
			private static readonly object False = false;
		   		 		  						  	   		  		 			  	   		  		  		   		 
			private static class StaticObjectCache<T>
			{
				private static readonly Dictionary<T, object> CacheByValue = new Dictionary<T, object>();

				public static object Get(T value)
				{
					object cachedObject;
					if (!CacheByValue.TryGetValue(value, out cachedObject))
					{
						cachedObject = value;
						CacheByValue[value] = cachedObject;
					}

					return cachedObject;
				}
			}

			public static object Get<T>(T value)
			{
				return StaticObjectCache<T>.Get(value);
			}

			public static object Get(bool value)
			{
				return value ? True : False;
			}
		}

				
				private object CanTeleport(BasePlayer player) => CanActions(player, true);

		
		
		private bool IsFriends(ulong userID, ulong targetID)
		{
			if (Friends is not null)
				return Friends.Call("HasFriend", userID, targetID) is true;
    
			return RelationshipManager.ServerInstance.playerToTeam.TryGetValue(userID, out RelationshipManager.PlayerTeam team) && team.members.Contains(targetID);
		}
		private object CanActions(BasePlayer player, bool returnMessage = false)
		{
			if (!IsCombatBlock(player)) return null;
			CombatPlayer combatP = _combatPlayers[player];
			
			RunEffect(player, "assets/prefabs/locks/keypad/effects/lock.code.denied.prefab");
			if (returnMessage == false)
			{
				SendChat("COMBATBLOCK_ACTION_BLOCKED".GetAdaptedMessage(player.UserIDString, combatP.UnblockTimeLeft.ToTimeFormat()), player);
				return false;
			}

			return "COMBATBLOCK_ACTION_BLOCKED".GetAdaptedMessage(player.UserIDString, combatP.UnblockTimeLeft.ToTimeFormat());

		}
		private static InterfaceBuilder _interface;

		
		
		private void OnEntityTakeDamage(BasePlayer target, HitInfo hitInfo)
		{
			if (target == null || hitInfo == null) return;
			if (target.IsNpc || hitInfo.Initiator is not BasePlayer attacker) return;
			if(!attacker.IsNpc) return;

			if (!IsRaidBlocked(target) && !IsDuel(target.userID))
				StartCombatBlocked(target);
		}

        	}
}


// --- End of file: CombatBlock-1.1.1.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Tournament.cs ---
// --- Original Local Path: Tournament.cs ---

﻿﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Tournament", "Xavier", "1.0.0")]
    public class Tournament : RustPlugin
    {

        [PluginReference] private Plugin Clans;
        public class CupSettings
        {
            public ulong ownerclan;
            public bool isremove;
            public uint build;
            // МАРКЕР
            public VendingMachineMapMarker Marker;
        }
        public List<CupSettings> ClanData = new List<CupSettings>(); 

        void AddMarker(CupSettings settings)
        {
            string name = Clans?.Call("ClanAlready", settings.ownerclan) as string;
            var vendingMarker = GameManager.server.CreateEntity("assets/prefabs/deployable/vendingmachine/vending_mapmarker.prefab", (Vector3) BaseNetworkable.serverEntities.Find(settings.build)?.transform.position).GetComponent<VendingMachineMapMarker>();
            vendingMarker.markerShopName = name; 
            vendingMarker.Spawn();
            vendingMarker.enabled = false;
            settings.Marker = vendingMarker;
            WriteData();
        }
        void RemoveMarker(CupSettings settings)
        {
            // ReSharper disable once Unity.NoNullPropagation
            settings.Marker?.Kill();
        }

        void OnServerInitialized()
        {
            ReadData();
            if (ClanData.Count > 0)
            {
                foreach (var cup in ClanData)
                {
                    var entity = BaseNetworkable.serverEntities.Find(cup.build);
                    if (entity == null && cup.isremove == false)
                    {
                        cup.isremove = true;
                    }
                    if (entity != null && cup.isremove == false)
                    {
                        //AddMarker(cup);
                    }
                }
            }
            time += TimeSpan.FromSeconds(config.times);
            timer.Every(1f, () => { time -= TimeSpan.FromSeconds(1);});
            if (!Oxide.Core.Interface.Oxide.DataFileSystem.ExistsDatafile("Tournament/Data"))
                Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("Tournament/Data", ClanData);
        }
        void OnServerSave()
        {
            WriteData();
        }
        #region Configuration
        private Configur config;

        private class Configur
        {      
            [JsonProperty("Изначальное время в секундах")]
            public int times = 600;

            public static Configur GetNewConfiguration()
            {
                return new Configur
                {
                   
                };
            }
        }
        protected override void LoadDefaultConfig()
        {
            config = Configur.GetNewConfiguration();

            PrintWarning("Создание начальной конфигурации плагина!!!");
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();

            config = Config.ReadObject<Configur>();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion 
        void ReadData() => ClanData = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<List<CupSettings>>("Tournament/Data");
        void WriteData() => Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("Tournament/Data", ClanData);
        TimeSpan time = TimeSpan.FromSeconds(0);
        public static string FormatShortTime(TimeSpan time)
        {
            string result = string.Empty;

            result += $"{time.Hours.ToString("00")}:";

            result += $"{time.Minutes.ToString("00")}:";

            result += $"{time.Seconds.ToString("00")}";

            return result;
        }
        [ConsoleCommand("tournament")]
        void testcm(ConsoleSystem.Arg arg)
        {
            if(arg == null) return;
            if(arg.Player() != null && arg.Player().IsAdmin == false) return;
            var player = arg.Player();
            switch(arg.Args[0])
            {
                case "time":
                    {
                        if(arg.Player() == null)
                            Puts($"{FormatShortTime(time)}");
                        else
                            player.ConsoleMessage($"<color=green><size=20>{time} до начала</size></color>");
                        break;
                    }
                case "addtime":
                    {
                        var tim = int.Parse(arg.Args[1]);

                        time += TimeSpan.FromSeconds(tim);

                        if(arg.Player() == null)
                            Puts($"{tim} сек. добавлено");
                        else
                            player.ConsoleMessage($"<color=green><size=20>{tim} сек. добавленоn\n{time} до начала</size></color>");
                        break;
                    }
                case "removetime":
                    {
                        var tim = int.Parse(arg.Args[1]);

                        time -= TimeSpan.FromSeconds(tim);

                        if(arg.Player() == null)
                            Puts($"{tim} сек. убавлено");
                        else
                            player.ConsoleMessage($"<color=green><size=20>{tim} сек. убавлено\n{time} до начала</size></color>");
                        break;
                    }
            }
        }

        void Unload()
        {
            if (ClanData.Count > 0)
            {
                foreach (var cup in ClanData)
                {
                    if (cup.isremove == false || cup != null)
                    {
                        RemoveMarker(cup);
                    }
                }
            }
            WriteData();
            foreach(var player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, CupLayer);
        }
        
        string CanRemove(BasePlayer player, BaseEntity entity)
        {
            if (!(entity as BuildingPrivlidge)) return null;
            var find = ClanData.FirstOrDefault(p => p.build == entity.net.ID);
            if (find != null && find.isremove == false)
            {
                return "Вы не имеете право удалять данный шкаф!";
            }
            return null;
        }
        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null) return null;
            if (info.InitiatorPlayer == null) return null;
            if (entity as BuildingPrivlidge)
            {
                var find = ClanData.FirstOrDefault(p => p.build == entity.net.ID);
                if (find != null)
                {
                    var clan = Clans?.CallHook("CheckClans", entity.net.ID, info.InitiatorPlayer.OwnerID);
                    if (clan is bool && (bool)clan)
                    {
                        info.InitiatorPlayer.ChatMessage("Вы не имеете право уничтожать турнирный шкаф своего же клана!");
                        info.damageTypes.ScaleAll(0f);
                        return false;
                    }
                    if (entity.OwnerID == info.InitiatorPlayer.userID)
                    {
                        info.InitiatorPlayer.ChatMessage("Вы не имеете право уничтожать турнирный шкаф своего же клана!");
                        info.damageTypes.ScaleAll(0f);
                        return false;
                    }
                }
            }
            return null;
        }



        bool CheckTournament(ulong owner)
        {
            var find = ClanData.FirstOrDefault(p => p.ownerclan == owner);
            if (find == null)
            {
                return false;
            }
            if (find.isremove)
            {
                return false;
            }
            return true;
        }
        
        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null) return;
            if (entity as BuildingPrivlidge && info != null && info.InitiatorPlayer != null)
            {
                var find = ClanData.FirstOrDefault(p => p.build == entity.net.ID);
                if (find != null)
                {
                    if (find.isremove == true)
                    {
                        info.InitiatorPlayer.ChatMessage("Произошла критическая ошибка! Плагин не выдал очки");    
                        return;
                    }
                    Clans?.CallHook("ScoreRemove", find.ownerclan, info.InitiatorPlayer.userID);
                    info.InitiatorPlayer.ChatMessage("Вы уничтожили турнирный шкаф чужого клана!");
                    find.isremove = true;
                    string name = Clans?.Call("ClanAlready", find.ownerclan) as string;
                    RemoveMarker(find);
                    LogToFile("Tournament", $"Клан {name} вылетел из турнира в {DateTime.Now.ToString(CultureInfo.InvariantCulture)}", this);
                }
            }
        }
        
        public string CupLayer = "UI_CupLayer";
        
        [ConsoleCommand("registration.clanssss")]
        void RegClan(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            uint ent = uint.Parse(args.Args[0]);
            ClanData.Add(new CupSettings(){ownerclan = player.userID,isremove = false,build = ent});
            player.ChatMessage("Вы успешно зарегистрировались на турнир!");
            CuiHelper.DestroyUi(player, CupLayer);
            //AddMarker(new CupSettings(){ownerclan = player.userID,isremove = false,build = ent});
            string name = Clans?.Call("ClanAlready", new CupSettings(){ownerclan = player.userID,isremove = false,build = ent}.ownerclan) as string;
            LogToFile("Tournament", $"Клан {name} зарегистрировались на турнир в {DateTime.Now.ToString(CultureInfo.InvariantCulture)}", this);
            WriteData();
        }
        
        
        private static string HexToCuiColor(string hex) { if (string.IsNullOrEmpty(hex)) { hex = "#FFFFFFFF"; } var str = hex.Trim('#'); if (str.Length == 6) str += "FF"; if (str.Length != 8) { throw new Exception(hex); throw new InvalidOperationException("Cannot convert a wrong format."); } var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber); var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber); var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber); var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber); Color color = new Color32(r, g, b, a); return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}"; }
        void ui(BasePlayer player)
        {
            var text = $"До начала - {FormatShortTime(time)}";
            if(time < TimeSpan.FromSeconds(0))
                text = $"Турнир начался!";
            CuiElementContainer container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = "txt",
                Parent = CupLayer,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = text,
                        FontSize = 16,
                        Align = TextAnchor.MiddleCenter,
                    },

                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.08181816 0.0208335",
                        AnchorMax = "0.9454545 0.4166667"
                    }
                }
            });
            CuiHelper.DestroyUi(player, "txt");
            CuiHelper.AddUi(player, container);
        }
        private readonly Dictionary<ulong, Timer> timers = new Dictionary<ulong, Timer>();
        private void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            if (player == null || entity == null) return;
            if (entity as BuildingPrivlidge)
            {
                CuiHelper.DestroyUi(player, CupLayer);
                if (entity.OwnerID != player.userID) return;
                CuiElementContainer container = new CuiElementContainer();
                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    RectTransform =
                        {AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-230 440", OffsetMax = "210 600"},
                    Image = {Color = "0 0 0 0"}
                }, "Overlay", CupLayer);
                
                timers[player.userID] = timer.Every(0.5f, () => { ui(player); });
                object clan = Clans?.CallHook("ClanCount", player.userID);
                if (clan is bool && !(bool) clan)
                {
                    container.Add(new CuiButton
                    {
                        RectTransform = {AnchorMin = "0.08181816 0.3208335", AnchorMax = "0.9454545 0.7166667"},
                        Button = {Color = HexToCuiColor("#919191BA"), Command = $""},
                        Text =
                        {
                            Text =
                                $"Ошибка! Возможно вы не состоите в клане, или же не являетесь главой клана в котором вы состоите",
                            Align = TextAnchor.MiddleCenter,
                            Font = "robotocondensed-regular.ttf", FontSize = 24
                        }
                    }, CupLayer);
                    CuiHelper.AddUi(player, container);
                    return;
                }

                var build = entity.GetBuildingPrivilege(entity.WorldSpaceBounds()).GetBuilding();
                var foundationlist = build.decayEntities.ToList().FindAll(p => p.PrefabName == "assets/prefabs/building core/foundation/foundation.prefab" || p.PrefabName == "assets/prefabs/building core/foundation.triangle/foundation.triangle.prefab");
                if (foundationlist.Count < 1)
                {
                    container.Add(new CuiButton
                    {
                        RectTransform = {AnchorMin = "0.08181816 0.3208335", AnchorMax = "0.9454545 0.7166667"},
                        Button = {Color = HexToCuiColor("#919191BA"), Command = $""},
                        Text =
                        {
                            Text = $"Необходимо иметь 50 фундаментов!", Align = TextAnchor.MiddleCenter,
                            Font = "robotocondensed-regular.ttf", FontSize = 24
                        }
                    }, CupLayer);
                    CuiHelper.AddUi(player, container);
                    return;
                }
                var find = ClanData.FirstOrDefault(p => p.ownerclan == player.userID);
                if (find != null)
                {
                    if (find.isremove == true)
                    {
                        container.Add(new CuiButton
                        {
                            RectTransform = {AnchorMin = "0.08181816 0.3208335", AnchorMax = "0.9454545 0.7166667"},
                            Button = {Color = HexToCuiColor("#919191BA"), Command = $""},
                            Text =
                            {
                                Text = $"Ваш шкаф уже был уничтожен! вы вылетели с турнира!",
                                Align = TextAnchor.MiddleCenter,
                                Font = "robotocondensed-regular.ttf", FontSize = 24
                            }
                        }, CupLayer);
                        CuiHelper.AddUi(player, container);
                        return;
                    }

                    container.Add(new CuiButton
                    {
                        RectTransform = {AnchorMin = "0.08181816 0.3208335", AnchorMax = "0.9454545 0.7166667"},
                        Button = {Color = HexToCuiColor("#919191BA"), Command = $""},
                        Text =
                        {
                            Text = $"Ошибка! Ваш клан уже зарегистрирован на турнир!", Align = TextAnchor.MiddleCenter,
                            Font = "robotocondensed-regular.ttf", FontSize = 24
                        }
                    }, CupLayer);
                    CuiHelper.AddUi(player, container);
                    return;
                }

                container.Add(new CuiButton
                {
                    RectTransform = {AnchorMin = "0.08181816 0.3208335", AnchorMax = "0.9454545 0.7166667"},
                    Button = {Color = HexToCuiColor("#919191BA"), Command = $"registration.clanssss {entity.net.ID}"},
                    Text =
                    {
                        Text = $"ЗАРЕГИСТРИРОВАТЬСЯ НА ТУРНИР!", Align = TextAnchor.MiddleCenter,
                        Font = "robotocondensed-regular.ttf", FontSize = 24
                    }
                }, CupLayer);
                CuiHelper.AddUi(player, container);
            }
        }

        private void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity) => CuiHelper.DestroyUi(player, CupLayer);


        object OnEntityGroundMissing(BaseEntity entity)
        {
            if (entity == null) return null;
            if (ClanData.Any(p => p.build == entity.net.ID))
            {
                return false;
            }
            return null;
        }
    }
}

// --- End of file: Tournament.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/EventBox.cs ---
// --- Original Local Path: EventBox.cs ---

using System.Collections.Generic;
using System.Linq;
using System;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("EventBox API", "LaserHydra", "1.0.0", ResourceId = 0)]
    [Description("allows you to set up spots for boxes which other plugins can use.")]
    class EventBox : RustPlugin
    {
        class Category : Dictionary<string, object>
        {
            public Category(int MinimalAmount, int MaximalAmount, bool Enabled)
            {
                this.Add("Minimal Amount", MinimalAmount);
                this.Add("Maximal Amount", MaximalAmount);
                this.Add("Enabled", Enabled);
            }
        }

        class Location
        {
            public float x;
            public float y;
            public float z;

            public Location()
            {
            }

            internal Location(float x, float y, float z)
            {
                this.x = x;
                this.y = y;
                this.z = z;
            }

            internal Location(Dictionary<string, float> dic)
            {
                this.x = dic["x"];
                this.y = dic["y"];
                this.z = dic["z"];
            }

            internal Location(Vector3 vector)
            {
                this.x = vector.x;
                this.y = vector.y;
                this.z = vector.z;
            }

            internal Vector3 Vector
            {
                get
                {
                    return new Vector3(this.x, this.y, this.z);
                }
            }

        }

        class Data
        {
            public Dictionary<string, List<Location>> locations = new Dictionary<string, List<Location>>();
        }

        Data data;

        Dictionary<string, List<BaseEntity>> boxes = new Dictionary<string, List<BaseEntity>>();

        ////////////////////////////////////////
        ///     Plugin Related
        ////////////////////////////////////////

        void Loaded()
        {
            permission.RegisterPermission("eventbox.use", this);

            LoadConfig();
            LoadData();
        }

        void Unloaded()
        {
            foreach(string name in names)
            {
                DestroyBoxes(name);
            }
        }

        ////////////////////////////////////////
        ///     Config Handling
        ////////////////////////////////////////

        void LoadConfig()
        {
            SetConfig("Categories", "Weapon", new Category(1, 2, true));
            SetConfig("Categories", "Construction", new Category(1, 5, true));
            SetConfig("Categories", "Items", new Category(1, 5, true));
            SetConfig("Categories", "Resources", new Category(500, 10000, false));
            SetConfig("Categories", "Attire", new Category(1, 2, true));
            SetConfig("Categories", "Tool", new Category(1, 2, true));
            SetConfig("Categories", "Medical", new Category(1, 5, true));
            SetConfig("Categories", "Food", new Category(5, 10, false));
            SetConfig("Categories", "Ammunition", new Category(5, 64, true));
            SetConfig("Categories", "Traps", new Category(1, 3, true));
            SetConfig("Categories", "Misc", new Category(1, 5, false));

            SetConfig("Settings", "Min Items", 1);
            SetConfig("Settings", "Max Items", 8);

            SetConfig("Settings", "Item Blacklist", new List<string> { "autoturret", "mining.quarry", "mining.pumpjack", "cctv.camera", "targeting.computer" });

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Generating new config file...");
        }

        ////////////////////////////////////////
        ///     Data Handling
        ////////////////////////////////////////

        void LoadData()
        {
            data = Interface.GetMod().DataFileSystem.ReadObject<Data>("EventBox_Data");
        }

        void SaveData()
        {
            Interface.GetMod().DataFileSystem.WriteObject("EventBox_Data", data);
        }

        ////////////////////////////////////////
        ///     Commands
        ////////////////////////////////////////

        [ChatCommand("eventbox")]
        void cmdEventBox(BasePlayer player, string cmd, string[] args)
        {
            if (!HasPermission(player))
            {
                SendChatMessage(player, "You have no permission to use this command.");
                return;
            }

            if(args.Length < 1)
            {
                SendChatMessage(player, "Syntax: /eventbox <add|build|destroy>");
                return;
            }

            switch(args[0])
            {
                case "add":
                    if(args.Length < 2)
                    {
                        SendChatMessage(player, "Syntax: /eventbox add <name>");
                        return;
                    }
                    string addname = args[1];

                    AddBox(addname, player.transform.position);
                    SendChatMessage(player, "Box has been added.");
                    break;

                case "build":
                    if (args.Length < 2)
                    {
                        SendChatMessage(player, "Syntax: /eventbox build <name>");
                        return;
                    }
                    string buildname = args[1];
                    
                    SendChatMessage(player, BuildBoxes(buildname));
                    break;

                case "destroy":
                    if (args.Length < 2)
                    {
                        SendChatMessage(player, "Syntax: /eventbox destroy <name>");
                        return;
                    }
                    string destroyname = args[1];

                    SendChatMessage(player, DestroyBoxes(destroyname));
                    break;
                default:
                    break;
            }
        }

        ////////////////////////////////////////
        ///     EventBox Related
        ////////////////////////////////////////

        List<string> names
        {
            get
            {
                return (from name in data.locations.Keys
                        select name).ToList();
            }
        }

        void AddBox(string name, Vector3 vector)
        {
            if (!data.locations.ContainsKey(name))
                data.locations.Add(name, new List<Location> { new Location(vector) });
            else
                data.locations[name].Add(new Location(vector));

            SaveData();
        }

        BaseEntity BuildBox(string name, Location location, bool items)
        {
            Vector3 vector = location.Vector;

            BaseEntity box = GameManager.server.CreateEntity("assets/prefabs/deployable/woodenbox/woodbox_deployed.prefab", vector);
            box.Spawn(true);

            if (!boxes.ContainsKey(name))
                boxes.Add(name, new List<BaseEntity> { box });
            else
                boxes[name].Add(box);

            if(items) AddItems(box);

            return box;
        }

        void AddItems(BaseEntity box)
        {
            int itemCount = UnityEngine.Random.Range((int) Config["Settings", "Min Items"], (int) Config["Settings", "Max Items"]);

            StorageContainer container = box.GetComponent<StorageContainer>();

            if (container == null)
            {
                return;
            }

            for (int i = 1; i <= itemCount; i++)
            {
                Item item = GetRandomItem();

                if (item == null)
                {
                    i--;
                    continue;
                }

                item.MoveToContainer(container.inventory);
            }
        }

        string BuildBoxes(string name)
        {
            if (data.locations.ContainsKey(name))
            {
                foreach (Location location in data.locations[name])
                {
                    BuildBox(name, location, true);
                }

                return "Boxes have been built!";
            }
            else
                return "FAILED: Name does not exist!";
        }

        string DestroyBoxes(string name)
        {
            if (boxes.ContainsKey(name))
            {
                foreach (BaseEntity box in boxes[name])
                {
                    box.Kill(BaseNetworkable.DestroyMode.None);
                }

                boxes.Remove(name);
                return "Boxes have been destroyed!";
            }
            else
                return "FAILED: Boxes are not built!";
        }

        Item GetRandomItem()
        {
            Item item = null;
            switch("")
            {
                default:
                    
                    ItemDefinition info = ItemManager.itemList[UnityEngine.Random.Range(0, ItemManager.itemList.Count - 1)];
                    Dictionary<string, object> settings = Config["Categories", info.category.ToString()] as Dictionary<string, object>;

                    List<object> blacklist = Config["Settings", "Item Blacklist"] as List<object>;

                    if (settings == null)
                        return null;

                    if (!(bool)settings["Enabled"] || blacklist.Contains(info.shortname))
                        goto default;

                    int amount = (int) GetRandomAmount(info.category.ToString());

                    item = GetItem(info.itemid, amount);

                    break;
            }

            return item;
        }

        object GetRandomAmount(string category)
        {
            if (Config["Categories", category] == null)
                return null;

            Dictionary<string, object> settings = Config["Categories", category] as Dictionary<string, object>;

            if (settings == null)
                return null;

            int minAmount = Convert.ToInt32(settings["Minimal Amount"]);
            int maxAmount = Convert.ToInt32(settings["Maximal Amount"]) + 1;

            return UnityEngine.Random.Range(minAmount, maxAmount);
        }

        Item GetItem(int id, int amount)
        {
            Item item = ItemManager.CreateByItemID(id);
            item.amount = amount;

            return item;
        }

        ////////////////////////////////////////
        ///     Permission
        ////////////////////////////////////////

        bool HasPermission(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, "eventbox.use"))
                return true;
            return false;
        }

        ////////////////////////////////////////
        ///     Console Command Handling
        ////////////////////////////////////////

        void RunAsChatCommand(ConsoleSystem.Arg arg, Action<BasePlayer, string, string[]> command)
        {
            if (arg == null) return;

            BasePlayer player = null;
            string cmd = string.Empty;
            string[] args = new string[0];

            if (arg.HasArgs()) args = arg.Args;
            if (arg.connection.player == null) return;

            player = arg.connection.player as BasePlayer;
            cmd = arg.cmd?.name ?? "unknown";

            command(player, cmd, args);
        }

        ////////////////////////////////////////
        ///     Converting
        ////////////////////////////////////////

        string ListToString(List<string> list, int first, string seperator)
        {
            return String.Join(seperator, list.Skip(first).ToArray());
        }

        ////////////////////////////////////////
        ///     Config Setup
        ////////////////////////////////////////

        void SetConfig(params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList<string>();
            stringArgs.RemoveAt(args.Length - 1);

            if (Config.Get(stringArgs.ToArray()) == null) Config.Set(args);
        }

        ////////////////////////////////////////
        ///     Chat Handling
        ////////////////////////////////////////

        void BroadcastChat(string prefix, string msg = null) => PrintToChat(msg == null ? prefix : "<color=#00FF8D>" + prefix + "</color>: " + msg);

        void SendChatMessage(BasePlayer player, string prefix, string msg = null) => SendReply(player, msg == null ? prefix : "<color=#00FF8D>" + prefix + "</color>: " + msg);
    }
}


// --- End of file: EventBox.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TPChat.cs ---
// --- Original Local Path: TPChat.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Game.Rust.Cui;
using UnityEngine; 

namespace Oxide.Plugins
{
    [Info("TPChat", "Sempai#3239", "5.0.0")]
    public class TPChat : RustPlugin
    {
        #region Classes

        private class Prefix
        {
            [JsonProperty("Наименование префикса")]
            public string Name;
            [JsonProperty("Цвет префикса")]
            public string Color;
            [JsonProperty("Размер префикса")]
            public string Size;

            [JsonProperty("Скобки префикса")]
            public string Hooks;
        }

        private class Chatter
        {
            [JsonProperty("Подсказки")]
            public bool Tips;
            [JsonProperty("Звуки личных сообщений")]
            public bool Sound;
            [JsonProperty("Звук сообщений в чате")]
            public bool Censor;
            [JsonProperty("Сообщения в чат")] 
            public bool Chat = true;
            [JsonProperty("Сообщения в ПМ")] 
            public bool PM = true;
        }

        private class Name
        {
            public string Color;
        }
        
        private class Settings
        {
            [JsonProperty("Настройки текущего префикса")]
            public Prefix Prefixes;
            [JsonProperty("Настройки чата")]
            public Chatter Chatters;
            [JsonProperty("Настройки имени")]
            public Name Names;

            [JsonProperty("Список игнорируемых игроков")] 
            public Dictionary<ulong, string> IgnoreList = new Dictionary<ulong, string>();
            [JsonProperty("Последнее личное сообщение для"), JsonIgnore] 
            public BasePlayer ReplyTarget = null;

            public double UMT; 
            
            public Settings() {}
            public static Settings Generate()
            {
                return new Settings
                {
                    Prefixes = new Prefix
                    {
                        Name = "-",
                        Hooks = "-", 
                        Size = "<size=14>",
                        Color = "<color=#c692de>"
                    },
                    Chatters = new Chatter
                    {
                        Censor = false,
                        Sound = true, 
                        Tips = true
                    },
                    Names = new Name
                    {
                        Color = "<color=#c692de>"
                    }
                }; 
            } 
        }

        private class DataBase
        {
            public Dictionary<ulong, Settings> Settingses = new Dictionary<ulong, Settings>();

            public static DataBase LoadData() => Interface.Oxide.DataFileSystem.ExistsDatafile("TPChat") ? Interface.Oxide.DataFileSystem.ReadObject<DataBase>("TPChat") : new DataBase();

            public void SaveData()
            {
                Interface.Oxide.DataFileSystem.WriteObject("TPChat", this);
                Interface.Oxide.DataFileSystem.WriteObject($"Logs", MessagesLogs);
            } 
        }

        private class Configuration
        {
            [JsonProperty("Список доступных префиксов")]
            public Dictionary<string, string> Prefixes = new Dictionary<string, string>();
            [JsonProperty("Список доступных цветов")]
            public Dictionary<string, string> Colors = new Dictionary<string, string>();
            [JsonProperty("Список доступных размеров")]
            public Dictionary<string, string> Sizes = new Dictionary<string, string>();
            [JsonProperty("Список доступных типов префикса")]
            public Dictionary<string, string> Types = new Dictionary<string, string>();
            [JsonProperty("Список цензуры и исключений")]
            public Dictionary<string, List<string>> Censures = new Dictionary<string, List<string>>(); 
            [JsonProperty("Список доступных сообщений")]
            public List<string> Broadcaster = new List<string>();
            [JsonProperty("Интервал отправки сообщений")]
            public int BroadcastInterval = 300;
            [JsonProperty("Оповещать о подключении с префиксом")]
            public bool WelcomePrefix = true;

            [JsonProperty("SteamID отправителя в чат")] 
            public ulong ImageID = 76561198185524239;
            
            public static Configuration LoadDefaultConfiguration()
            {
                return new Configuration
                {
                    WelcomePrefix = true,
                    BroadcastInterval = 300,
                    Broadcaster = new List<string>
                    {
                        "Все можно узнать здесь \n<size=10><color=#eb7d6a>МЕНЮ</color></size>",
						"Группа ВК - <color=#eb7d6a>vk.com/rasta_children</color>",
						"Наш магазин - <color=#eb7d6a>angarskrust38reg.gamestores.app</color>\n<size=10>Действуют скидки до <color=#eb7d6a>40%</color> на некоторые товары.</size>",
						"Увидел читера или нарушителей?\nОтправляй жалобу в <color=#eb7d6a>/report</color>",
						"Дискорд - <color=#eb7d6a>discord.gg/YkhyyEVAfG</color>",
                    },
                    Prefixes = new Dictionary<string, string>
                    {
						["Chat.Default"] = "НЕТ:-",
						["kits.secret2"] = "o:o",
						["Chat.Kaban1"] = "シ:シ",
						["Chat.Kaban2"] = "₪:₪",
						["Chat.Kaban4"] = "ВЕПРЬ:ВЕПРЬ",
						["Chat.Joker1"] = "¥:¥",
						["Chat.Joker2"] = "®:®",
						["Chat.Joker3"] = "〄:〄",
						["Chat.Joker4"] = "JOKER:JOKER",
						["Chat.Masnik1"] = "ס:ס",
						["Chat.Masnik2"] = "√:√",
						["Chat.Masnik3"] = "〤:〤",
						["Chat.Masnik4"] = "マ:マ",
						["Chat.Masnik5"] = "МЯСНИК:МЯСНИК",
						["Chat.Smert1"] = "ה:ה",
						["Chat.Smert2"] = "©:©",
						["Chat.Smert3"] = "〰:〰",
						["Chat.Smert4"] = "†:†",
						["Chat.Smert5"] = "€:€",
						["Chat.Smert6"] = "DEATH:DEATH",
						["Chat.Store1"] = "ש:ש",
						["Chat.Store2"] = "‡:‡",
						["Chat.Store3"] = "◊:◊",
						["Chat.Store4"] = "Ѫ:Ѫ",
						["Chat.Store5"] = "〶:〶"
                    },
                    Colors = new Dictionary<string, string>
                    {
						["Chat.Default"]= "СТАНДАРТНЫЙ:<color=#eb7d6a>",
						["Chat.White"]= "БЕЛЫЙ:<color=#d4d8de>",
						["Chat.Korange"]= "ОРАНЖЕВЕНЬКИЙ:<color=#ec9a49>",
						["Chat.Kcal"]= "КОРИЧНЕВЫЙ:<color=#b18755>",
						["Chat.Jgreen"]= "ЗЕЛЁНЫЙ:<color=#ADFF2F>",
						["Chat.Jpink"]= "СВ.РОЗОВЫЙ:<color=#e999c4>",
						["Chat.Jpaleturquoise"]= "БИРЮЗОВЫЙ:<color=#52d398>",
						["Chat.Mred"]= "КРАСНЫЙ:<color=#e25252>",
						["Chat.Mrosybrowm"]= "SALMON:<color=#FA8072>",
						["Chat.Mmistyrose"]= "KHAKI:<color=#f0e68c>",
						["Chat.Mdarkred"]= "ТЁМНО-КРАСНЫЙ:<color=#a86464>",
						["Chat.Sgray"]= "СЕРЫЙ:<color=#696969>",
						["Chat.Sskyblue"]= "НЕБЕСН.СИНИЙ:<color=#B1D6F1>",
						["Chat.Sdarkslategrey"]= "ТЁМНО-СЕР.ШИФЕР:<color=#FDD9B5>",
						["Chat.Sasdsd"]= "РОЗОВО-КОРИЧ.:<color=#bc8f8f>",
						["Chat.Sdarkgreen"]= "ТЁМНО-ЗЕЛЁНЫЙ:<color=#57a078>",
						["Chat.StoreColor1"]= "ЛИЛОВЫЙ:<color=#DB7093>",
						["Chat.StoreColor2"]= "СВЕТЛО-ГОЛУБОЙ:<color=#E0FFFF>",
						["Chat.StoreColor3"]= "ТЁМНО-ОЛИВКОВЫЙ:<color=#6B8E23>",
						["Chat.StoreColor4"]= "ЗОЛОТОЙ:<color=#FFD700>",
						["Chat.StoreColor5"]= "ТЁМНАЯ-ОРХИДЕЯ:<color=#9932CC>"
                    },
                    Sizes = new Dictionary<string, string>
                    {
                        ["Chat.Default"] = "СТАНДАРТНЫЙ:<size=14>",
                        ["Chat.Big"] = "БОЛЬШОЙ:<size=16>"
                    },
                    Types = new Dictionary<string, string>
                    {
                        ["Chat.Default"] = "НЕТ:-",
                        ["Chat.Hooks"] = "СКОБКИ:[]",
                        ["Chat.Limitter"] = "ПОЛОСА:|"
                    },
					Censures = new Dictionary<string,List<string>>{
						["бля"] = new List<string>{},
						["аху"] = new List<string>{},
						["впиз"] = new List<string>{},
						["въеб"] = new List<string>{},
						["выбля"] = new List<string>{},
						["выеб"] = new List<string>{},
						["выёб"] = new List<string>{},
						["гнид"] = new List<string>{},
						["гонд"] = new List<string>{},
						["доеб"] = new List<string>{},
						["долбо"] = new List<string>{},
						["дроч"] = new List<string>{},
						["ёб"] = new List<string>{},
						["елд"] = new List<string>{},
						["заеб"] = new List<string>{},
						["заёб"] = new List<string>{},
						["залуп"] = new List<string>{},
						["захуя"] = new List<string>{},
						["заяб"] = new List<string>{},
						["злоеб"] = new List<string>{},
						["ипа"] = new List<string>{},
						["лох"] = new List<string>{},
						["лошар"] = new List<string>{},
						["манд"] = new List<string>{"мандар"},
						["мля"] = new List<string>{},
						["мраз"] = new List<string>{},
						["муд"] = new List<string>{"мудр"},
						["наеб"] = new List<string>{},
						["наёб"] = new List<string>{},
						["напизд"] = new List<string>{},
						["нах"] = new List<string>{"наха","нахо","нахл"},
						["нех"] = new List<string>{"нехо","нехв", "неха"},
						["нии"] = new List<string>{},
						["обоср"] = new List<string>{}
					}
                };
            }
        }

        #endregion

        #region Variables

        private static TPChat _;
        private static DataBase Handler;
        private static Configuration Settingses;
        
        private static List<ulong> AntiSpamFilter = new List<ulong>();

        #endregion

        #region Initialization

        private void Unload(){
			Handler.SaveData();
			BasePlayer.activePlayerList.ToList().ForEach((player) =>
            {
				CuiHelper.DestroyUi(player, SettingsLayer);
				//CuiHelper.DestroyUi(player, SettingsLayer + ".WINDOW");
				CuiHelper.DestroyUi(player, SettingsLayer + ".INNER");
			});
		}
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                Settingses = Config.ReadObject<Configuration>();
            }
            catch
            {
                PrintWarning($"Error reading config, creating one new config!");
                LoadDefaultConfig();
            }

            SaveConfig();
        } 

        protected override void LoadDefaultConfig() => Settingses = Configuration.LoadDefaultConfiguration();
        protected override void SaveConfig()        => Config.WriteObject(Settingses); 
        
        private void OnServerInitialized()
        {
            _ = this;
            Handler = DataBase.LoadData();
             
            BasePlayer.activePlayerList.ToList().ForEach((player) =>
            {
                if (!Handler.Settingses.ContainsKey(player.userID))
                    Handler.Settingses.Add(player.userID, Settings.Generate());
            });  
            
            if (Interface.Oxide.DataFileSystem.ExistsDatafile("Logs"))
                MessagesLogs = Interface.Oxide.DataFileSystem.ReadObject<HashSet<Message>>($"Logs");
            if (MessagesLogs.Count > 1000)
            {
                MessagesLogs.Clear();
                PrintError("Data messages was cleared!"); 
            } 

            permission.RegisterPermission("TPChat.mute", this);
              
            Settingses.Colors.ToList().ForEach(p => { if (!permission.PermissionExists(p.Key) && p.Key.ToLower().StartsWith("chat")) permission.RegisterPermission(p.Key, this);});
            Settingses.Types.ToList().ForEach(p => { if (!permission.PermissionExists(p.Key) && p.Key.ToLower().StartsWith("chat")) permission.RegisterPermission(p.Key, this);});
            Settingses.Sizes.ToList().ForEach(p => { if (!permission.PermissionExists(p.Key) && p.Key.ToLower().StartsWith("chat")) permission.RegisterPermission(p.Key, this);});
            Settingses.Prefixes.ToList().ForEach(p => { if (!permission.PermissionExists(p.Key) && p.Key.ToLower().StartsWith("chat")) permission.RegisterPermission(p.Key, this);});

            timer.Every(Settingses.BroadcastInterval, () =>
            {
                var message = Settingses.Broadcaster.GetRandom();
                foreach (var check in BasePlayer.activePlayerList.ToList())
                {
                    var settings = Handler.Settingses[check.userID];
                    if (!settings.Chatters.Tips)
                        continue;

                    check.SendConsoleCommand("chat.add", 0, Settingses.ImageID, message);
                    check.SendConsoleCommand($"echo [<color=white>ЧАТ</color>] {message}");
                }
            }).Callback();
            timer.Every(10, AntiSpamFilter.Clear);
            timer.Every(60, Handler.SaveData);
            timer.Every(300, () => BasePlayer.activePlayerList.ToList().ForEach(p => FetchStatus(p)));    
        }
 
        #endregion

        #region Commands

        [ConsoleCommand("UI_Chat")]
        private void CmdConsoleHandler(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (!player || !arg.HasArgs(1)) return;

            switch (arg.Args[0].ToLower())
            {
                case "chatpm":
                {
                    Handler.Settingses[player.userID].Chatters.PM = Convert.ToBoolean(arg.Args[1]);
                    InitializeInterface(player,true); 
                    break;
                }
                case "chatglobal":
                {
                    Handler.Settingses[player.userID].Chatters.Chat = Convert.ToBoolean(arg.Args[1]);
                    InitializeInterface(player,true); 
                    break;
                }
                case "censor":
                {
                    Handler.Settingses[player.userID].Chatters.Censor = Convert.ToBoolean(arg.Args[1]);
                    InitializeInterface(player,true); 
                    break;
                }
                case "sound":
                {
                    Handler.Settingses[player.userID].Chatters.Sound = Convert.ToBoolean(arg.Args[1]);
                    InitializeInterface(player,true); 
                    break;
                }
                case "tips":
                {
                    Handler.Settingses[player.userID].Chatters.Tips = Convert.ToBoolean(arg.Args[1]);
                    InitializeInterface(player,true); 
                    break;
                }
                case "name_color": 
                {
                    var nameColor = Settingses.Colors.FirstOrDefault(p => p.Value == arg.Args[1]);
                    if (!permission.UserHasPermission(player.UserIDString, nameColor.Key)) return;

                    Handler.Settingses[player.userID].Names.Color = nameColor.Value.Split(':')[1];
                    InitializeInterface(player,true); 
                    break;
                }
                case "prefix_color":
                {
                    var nameColor = Settingses.Colors.FirstOrDefault(p => p.Value == arg.Args[1]);
                    if (!permission.UserHasPermission(player.UserIDString, nameColor.Key)) return;

                    Handler.Settingses[player.userID].Prefixes.Color = nameColor.Value.Split(':')[1];
                    InitializeInterface(player,true); 
                    break;
                }
                case "prefix_size":
                {
                    var nameColor = Settingses.Sizes.FirstOrDefault(p => p.Value == arg.Args[1]);
                    if (!permission.UserHasPermission(player.UserIDString, nameColor.Key)) return;

                    Handler.Settingses[player.userID].Prefixes.Size = nameColor.Value.Split(':')[1];
                    InitializeInterface(player,true); 
                    break;
                }
                case "hook_type":
                {
                    var nameColor = Settingses.Types.FirstOrDefault(p => p.Value == arg.Args[1]);
                    if (!permission.UserHasPermission(player.UserIDString, nameColor.Key)) return;

                    Handler.Settingses[player.userID].Prefixes.Hooks = nameColor.Value.Split(':')[1];
                    InitializeInterface(player,true); 
                    break;
                }
                case "prefix":
                {
                    var nameColor = Settingses.Prefixes.FirstOrDefault(p => p.Value == arg.Args[1]);
                    if (!permission.UserHasPermission(player.UserIDString, nameColor.Key)) return;

                    Handler.Settingses[player.userID].Prefixes.Name = nameColor.Value.Split(':')[1];
                    InitializeInterface(player,true); 
                    break;
                }
            }
        }

        #endregion

        #region Hooks
  
        private class Response
        {
            [JsonProperty("country")]
            public string Country { get; set; }
        }
        
        void OnCorpse(BasePlayer player, BaseCorpse corpse)
        {
            if (!Handler.Settingses.ContainsKey(player.userID)) return;

            var obj = corpse.GetComponent<PlayerCorpse>();
            if (obj == null) return;
            obj._playerName = PrepareNick(player);
        }

        private void FetchStatus(BasePlayer player)
        {
            if (!Handler.Settingses.ContainsKey(player.userID))
            {
                OnPlayerInit(player);
                FetchStatus(player);
                return;
            }
            
            var settings = Handler.Settingses[player.userID];            
            if (Settingses.Prefixes.All(p => !p.Value.Contains(settings.Prefixes.Name)) || !permission.UserHasPermission(player.UserIDString, Settingses.Prefixes.FirstOrDefault(p => p.Value.Contains(settings.Prefixes.Name)).Key))
            {
                settings.Prefixes.Name = Settingses.Prefixes.FirstOrDefault(p => permission.UserHasPermission(player.UserIDString, p.Key)).Value.Split(':')[1]; 				
            }
            if (Settingses.Colors.All(p => !p.Value.Contains(settings.Prefixes.Color)) || !permission.UserHasPermission(player.UserIDString, Settingses.Colors.FirstOrDefault(p => p.Value.Contains(settings.Prefixes.Color)).Key))
            {
                settings.Prefixes.Color = Settingses.Colors.FirstOrDefault(p => permission.UserHasPermission(player.UserIDString, p.Key)).Value.Split(':')[1]; 
            }
            if (Settingses.Types.All(p => !p.Value.Contains(settings.Prefixes.Hooks)) || !permission.UserHasPermission(player.UserIDString, Settingses.Types.FirstOrDefault(p => p.Value.Contains(settings.Prefixes.Hooks)).Key))
            {
                 settings.Prefixes.Hooks = Settingses.Types.FirstOrDefault(p => permission.UserHasPermission(player.UserIDString, p.Key)).Value.Split(':')[1]; 
            } 
            if (Settingses.Sizes.All(p => !p.Value.Contains(settings.Prefixes.Size)) || !permission.UserHasPermission(player.UserIDString, Settingses.Sizes.FirstOrDefault(p => p.Value.Contains(settings.Prefixes.Size)).Key))
            {
                settings.Prefixes.Size = Settingses.Sizes.FirstOrDefault(p => permission.UserHasPermission(player.UserIDString, p.Key)).Value.Split(':')[1]; 
            }
            if (Settingses.Colors.All(p => !p.Value.Contains(settings.Names.Color)) || !permission.UserHasPermission(player.UserIDString, Settingses.Colors.FirstOrDefault(p => p.Value.Contains(settings.Names.Color)).Key))
            { 
                settings.Names.Color = Settingses.Colors.FirstOrDefault(p => permission.UserHasPermission(player.UserIDString, p.Key)).Value.Split(':')[1]; 
            } 
        }
        
        private void OnPlayerInit(BasePlayer player)
        {
            if (!Handler.Settingses.ContainsKey(player.userID))
                Handler.Settingses.Add(player.userID, Settings.Generate());
            
            FetchStatus(player); 
/*
			foreach (var check in BasePlayer.activePlayerList.ToList())
			{ 
				check.SendConsoleCommand("chat.add", 0, player.userID, $"<size=12>Игрок {_.PrepareNickForConnect(player)} присоединился!</size>");
			}*/
        }

        private static HashSet<Message> MessagesLogs = new HashSet<Message>();
        
        #region Helpers

        private void Broadcast(string text)
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (!Handler.Settingses.ContainsKey(player.userID))
                    continue;
                    
                var targetSettings = Handler.Settingses[player.userID];
                if (!targetSettings.Chatters.Tips) continue;
                
                SafeMessage(player, text, Settingses.ImageID);
            }
        }

        [ChatCommand("none")]
        void ChatMute(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "TPChat.mute"))
            {
                SendReply(player, "<size=12>У вас нет доступа к команде /mute</size>");
                return;
            }

            if (args.Length < 3)
            {
                SendReply(player, "<size=12>Пример использования:\n/mute <color=#ee3e61>[имя или steamid]</color> <color=#ee3e61>[время мута (в секундах)]</color> <color=#ee3e61>[причина мута]</color></size>");
                return;
            }

            var target = FindBasePlayer(args[0]);
            if (target == null)
            {
                SendReply(player, $"<size=12>Игрок не найден!</size>");
                return;
            }

            MutePlayer(target, player.displayName, int.Parse(args[1]), args[2]);
        }

        [ChatCommand("none")]
        void ChatUnMute(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "TPChat.mute"))
            {
                SendReply(player, "<size=12>У вас нет доступа к команде /unmute</size>");
                return;
            }

            if (args.Length < 1)
            {
                SendReply(player, "<size=12>Пример использования:\n/unmute <color=#ee3e61>[имя или steamid]</color></size>");
                return;
            }

            var target = FindBasePlayer(args[0]);
            if (target == null)
            {
                SendReply(player, $"<size=12>Игрок не найден!</size>");
                return;
            }

            MutePlayer(player, target.displayName, 0, "");
        }

        private void MutePlayer(BasePlayer player, string initiatorName, int time, string reason)
        {
            var settings = Handler.Settingses[player.userID];
            
            if (time == 0)
            {
                Broadcast($"<color=#90e095>{initiatorName}</color> разблокировал чат игроку <color=#e68585>{player.displayName}</color>");
                Handler.Settingses[player.userID].UMT = 0;
            }
            else 
            {
                Broadcast($"<color=#90e095>{initiatorName}</color> выдал мут игроку <color=#e68585>{player.displayName}</color>\n" +
                          $"  <size=12><color=#e3e3e3>Причина: {reason} [{TimeSpan.FromSeconds(time).ToShortString()}]</color></size>");
                Handler.Settingses[player.userID].UMT = Time() + time;
            }
        }

        BasePlayer FindBasePlayer(string nameOrUserId)
        {
            nameOrUserId = nameOrUserId.ToLower();
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (player.displayName.ToLower().Contains(nameOrUserId) || player.UserIDString == nameOrUserId) return player;
            }
            foreach (var player in BasePlayer.sleepingPlayerList)
            {
                if (player.displayName.ToLower().Contains(nameOrUserId) || player.UserIDString == nameOrUserId) return player;
            }
            return default(BasePlayer);
        }

        private void SendPrivateMessage(BasePlayer initiator, BasePlayer target, string message)
            => SendPrivateMessage(initiator.userID, target.userID, message);

        private void SendPrivateMessage(ulong initiatorReadyId, ulong targetReadyId, string message)
        {
            BasePlayer initiator = BasePlayer.FindByID(initiatorReadyId);
            BasePlayer target    = BasePlayer.FindByID(targetReadyId);

            string targetReadyName                        = BasePlayer.FindByID(targetReadyId)?.displayName ?? "UNKNOWN";
            string initiatorReadyName                     = BasePlayer.FindByID(initiatorReadyId)?.displayName ?? "UNKNOWN";
            if (initiatorReadyId == 76561199039326412) initiatorReadyName = "ADMIN";

            if (target == null || !target.IsConnected)
            {
                SafeMessage(initiator, "Игрок не находится на сервере!");
                return;
            }

            var targetSettings = Handler.Settingses[targetReadyId];
            if (!targetSettings.IgnoreList.ContainsKey(initiatorReadyId))
            {
                if (!targetSettings.Chatters.PM)
                {
                    initiator.ChatMessage("У игрока отключены приватные сообщения");
                    return;
                }
                if (targetSettings.Chatters.Sound)
                {
                    Effect effect = new Effect("assets/bundled/prefabs/fx/notice/item.select.fx.prefab", target, 0, new Vector3(), new Vector3());
                    EffectNetwork.Send(effect, target.Connection);
                }

                if (initiator != null && initiator.IsConnected)
                {
                    targetSettings.ReplyTarget = initiator;
                }

                string prepareName = PrepareNick(new BasePlayer {userID = initiatorReadyId, displayName = initiatorReadyName});
                SafeMessage(target, $"<size=14>Личное сообщение от {prepareName}</size>\n<size=12>{message}</size>", initiatorReadyId);
            }
 
            string prepareTargetName = PrepareNick(new BasePlayer {userID = targetReadyId, displayName = targetReadyName});
            SafeMessage(initiator, $"<size=14>Личное сообщение для {prepareTargetName}</size>\n<size=12>{message}</size>", targetReadyId);
            AddMessage(initiatorReadyName, initiatorReadyId, message, targetReadyName, targetReadyId);
            
            DebugEx.Log((object) "[CHAT] " + initiatorReadyName + $" [{initiatorReadyId}] : > {target.displayName} [{target.userID}] :" + message); 
        }
		
        public class Message
        {
            [JsonProperty("id")] public string Id = CuiHelper.GetGuid();
            
            [JsonProperty("displayName")] public string DisplayName;
            [JsonProperty("userId")]      public string UserID;

            [JsonProperty("targetDisplayName")] public string TargetDisplayName;
            [JsonProperty("targetUserId")]      public string TargetUserId;

            [JsonProperty("text")]   public string Text;
            [JsonProperty("isTeam")] public bool   IsTeam;
            [JsonProperty("time")]   public string Time;
        }
		
        private void AddMessage(BasePlayer player, string message, bool team = false) => AddMessage(player.displayName, player.userID, message, team: team);

        private void AddMessage(string displayName, ulong userId, string message, string targetName = "", ulong targetId = 0UL, bool team = false)
        {
            var time       = DateTime.Now;
            var resultTime = $"{time.Hour}:{time.Minute}:{time.Second}";

            var chat = new Message
            {
                DisplayName       = displayName,
                Text              = message,
                TargetDisplayName = targetName,
                TargetUserId      = targetId.ToString(),
                Time              = resultTime,
                UserID            = userId.ToString(),
                IsTeam            = team
            };

            MessagesLogs.Add(chat);

            string logFormat = $"{displayName} [{targetId}]: {message}";
            if (team)
            {
                logFormat = "TEAM: " + logFormat;
            }
            else if (targetId != 0)
            {
                logFormat = $"{displayName} [{userId}] -> {targetName}[{targetId}]: {message}";
            }

            LogToFile($"{(!team ? targetId == 0 ? "Chat" : "PM" : "Team")}", logFormat, this);
        }

        #endregion

        #region Utils

        private static void LogInfo(string text)
        {
            //if (Settings) 
            //{
               // _.PrintWarning(text);
            //}
        }
        private static void UnloadPlugin() => _.NextTick(() => Interface.Oxide.UnloadPlugin("TPChat"));
      

        private static double Time() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;

        private static void SafeMessage(BasePlayer player, string text, ulong avatarId = 0)
        {
            if (player == null || !player.IsConnected) return;

            player.SendConsoleCommand("chat.add", 0, avatarId, text);
            player.SendConsoleCommand($"echo <color=white>[ЧАТ]</color> {text}");
        }

        #endregion
 
        private object OnPlayerChat(BasePlayer player, string message, ConVar.Chat.ChatChannel channel)
        {
            // TODO: HotFix
            while (message.Contains("size"))
                message = message.Replace("size", "");

            if (channel == ConVar.Chat.ChatChannel.Global)
            {
                if (AntiSpamFilter.Contains(player.userID) && !player.IsAdmin)
                {
                    player.ChatMessage("Вы не можете писать чаще, чем раз в <color=#fd7d6b>10</color> секунд!\n<size=12>Старайтесь писать всё в одном сообщении.</size>");
                    return false;
                }

                if (Handler.Settingses[player.userID].UMT > Time())
                {
                    player.ChatMessage("Ссори, у вас мут!");
                    return false;
                }

                string realMessage = PrepareMessage(player, message);
                string censureMessage = PrepareMessage(player, Censure(message));
                
                AntiSpamFilter.Add(player.userID); 
                foreach (var check in BasePlayer.activePlayerList.ToList())
                {
                    var settings = Handler.Settingses[check.userID];
                    if (settings.IgnoreList.ContainsKey(player.userID) || !settings.Chatters.Chat)
                        continue;
                    
                    string prepareMessagge = settings.Chatters.Censor ? censureMessage : realMessage; 
                    check.SendConsoleCommand("chat.add", 0, player.userID, prepareMessagge);
                    check.SendConsoleCommand($"echo [<color=white>ЧАТ</color>] {prepareMessagge}");
                }
            
                DebugEx.Log((object) ("[CHAT] " + player.displayName + $" [{player.UserIDString}] : " + message));
                LogChat(player.displayName + $" [{player.UserIDString}]: " + message);
                AddMessage(player, message);
                return false;
            }
            else
            {
                foreach (var check in player.Team.members)
                {
                    var settings = Handler.Settingses[player.userID]; 
                    if (settings.IgnoreList.ContainsKey(player.userID))
                        continue; 

                    var target = BasePlayer.FindByID(check);
                    if (target == null || !target.IsConnected) continue;
                    
                    string prepareMessagge = PrepareMessage(player, message, true);
                    target.SendConsoleCommand("chat.add", 0, player.userID, prepareMessagge);
                    target.SendConsoleCommand($"echo [<color=white>TEAM</color>] {prepareMessagge}");
                }
            
                DebugEx.Log((object) ("[CHAT] " + player.displayName + $" [{player.UserIDString}] : " + "TEAM> " + message));
                LogChat(player.displayName + $" [{player.UserIDString}]: " + message);
                AddMessage(player, message, true); 
                return false;
            }
            return null;
        }

        #endregion

        #region Commands

        [ChatCommand("chat")]
        private void CmdChatCommandSecret(BasePlayer player, string command, string[] args) => InitializeInterface(player);
        
        [ChatCommand("ignore")]
        private void CmdChatPersonalIgnore(BasePlayer player, string command, string[] args)
        {
            if (args.Length != 1)
            {
                player.ChatMessage($"Вы <color=orange>неправильно</color> используете команду!\n<size=12>/ignore <игрок> - отправить сообщение");
                return;
            }

            var targetSearch = args[0].ToLower();
            
            var target = BasePlayer.activePlayerList.ToList().FirstOrDefault(p => p.displayName.ToLower().Contains(targetSearch) || p.UserIDString == targetSearch);
            if (target == null || !target.IsConnected)
            {
                player.ChatMessage($"Игрок не найден!");
                return;
            }

            var settings = Handler.Settingses[player.userID];
            if (settings.IgnoreList.ContainsKey(target.userID))
            {
                player.ChatMessage($"Вы больше <color=orange>не игнорируете</color> этого игрока!");
                settings.IgnoreList.Remove(target.userID);
                return;
            }
            else
            {
                player.ChatMessage($"Теперь вы <color=orange>игнорируете</color> этого игрока!");
                settings.IgnoreList.Add(target.userID, target.displayName);
                return;
            }
        }

        [ChatCommand("r")]
        private void CmdChatPersonalReply(BasePlayer player, string command, string[] args)
        {
            if (args.Length < 1)
            {
                player.ChatMessage($"Вы <color=orange>неправильно</color> используете команду!\n<size=12>/r <сообщение> - отправить сообщение</size>");
                return;
            }

            var message = "";

            for (var i = 0; i < args.Length; i++)
                message += $"{args[i]} ";

            var target = Handler.Settingses[player.userID].ReplyTarget;
            if (target == null || !target.IsConnected)
            {
                player.ChatMessage($"Игрок не найден!");
                return;
            }

            SendPrivateMessage(player, target, message); 
        }
        
        [ChatCommand("pm")]
        private void CmdChatPersonalMessage(BasePlayer player, string command, string[] args)
        {
            if (args.Length <= 1)
            {
                player.ChatMessage($"Вы <color=orange>неправильно</color> используете команду!\n<size=12>/pm <имя> <сообщение> - отправить сообщение</size>");
                return;
            }

            var targetSearch = args[0].ToLower();
            var message      = "";

            for (var i = 1; i < args.Length; i++)
                message += $"{args[i]} ";

            var target = BasePlayer.activePlayerList.ToList().FirstOrDefault(p => p.displayName.ToLower().Contains(targetSearch));
            if (target == null || !target.IsConnected)
            {
                player.ChatMessage($"Игрок не найден!");
                return;
            }
            
            SendPrivateMessage(player, target, message);
        }
 
        #endregion

        #region Interface 

        private string SettingsLayer = "UI_SettingsLayer"; 
        private void InitializeInterface(BasePlayer player, bool reopen = false)
        {
            FetchStatus(player); 
			
            var settings = Handler.Settingses[player.userID];			 
			 
            CuiElementContainer container = new CuiElementContainer();
            if (!reopen)
            {
                CuiHelper.DestroyUi(player, SettingsLayer);
            
                container.Add(new CuiPanel()
                { 
                    CursorEnabled = true,
                    RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0"},  
                    Image         = {Color = "0 0 0 0" }
                }, ".Mains", SettingsLayer );
							
            container.Add(new CuiElement
            {
                Name = SettingsLayer + ".WINDOW_FRAME",
                Parent = ".Mains",
                Components =
                {
                    new CuiRawImageComponent {Url = "https://i.imgur.com/Do7pfe6.png"}, 

                    new CuiRectTransformComponent { AnchorMin = "-0.315 -0.27", AnchorMax = "1.3 1.275", OffsetMax = "0 0" },
                }
            });
				container.Add(new CuiElement
				{
					Name = SettingsLayer + ".WINDOW", 
					Parent = SettingsLayer + ".WINDOW_FRAME",
					Components =
					{
						new CuiImageComponent { Color = "0 0 0 0" },	
						new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1" },					
					}
				});
			}
			CuiHelper.DestroyUi(player, SettingsLayer + ".INNER");
            
			container.Add(new CuiPanel()
			{ 
				CursorEnabled = false,
				RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0"},  
				Image         = {Color = "0 0 0 0.0" }
			}, SettingsLayer + ".WINDOW", SettingsLayer + ".INNER");
            

            
            container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = $"250 -500", OffsetMax = $"800 -290"} , 

                    Text = { Text = $"ТВОЙ НИК : {PrepareNick(player)}", Align = TextAnchor.UpperLeft, Font = "robotocondensed-bold.ttf", FontSize = 25, Color = "250, 5, 5"}
                }, SettingsLayer + ".INNER");
            


            #region Switch layer Цвет
            
            var currentStatus = Settingses.Colors.FirstOrDefault(p => p.Value.Split(':')[1] == settings.Names.Color);
            List<KeyValuePair<string, string>> possibleStatuses = Settingses.Colors.ToList().FindAll(p => permission.UserHasPermission(player.UserIDString, p.Key));
 
            var colorIndex = possibleStatuses.IndexOf(currentStatus);
            string leftCommand = $"UI_Chat name_color {possibleStatuses.ElementAtOrDefault(colorIndex - 1).Value}"; 
            string rightCommand = $"UI_Chat name_color {possibleStatuses.ElementAtOrDefault(colorIndex + 1).Value}"; 
            bool leftActive = colorIndex > 0;
            bool rightActive = colorIndex < possibleStatuses.Count - 1;
            
            string guid = CuiHelper.GetGuid(); 

            container.Add(new CuiLabel 
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = $"250 -1000", OffsetMax = $"-200 -194" },
                Text = { Text = $"ЦВЕТ НИКА<size=12>({possibleStatuses.Count})</size>", Align = TextAnchor.UpperLeft, Font = "robotocondensed-bold.ttf", FontSize = 25, Color = "5, 225, 250"}
            }, SettingsLayer + ".INNER", guid);
            
            container.Add(new CuiPanel
            {
                RectTransform = {AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = $"-250 -30", OffsetMax = $"-30 0"},
                Image = {Color = "0.27 0.247 0.184 1"}
            }, guid, guid + ".P");
            
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 1", OffsetMax = "30 0" },
                Image = { Color = leftActive ? "0.81 0.77 0.74 0.2" : "0.81 0.77 0.74 0.15" }
            }, guid + ".P", guid + ".L"); 
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = leftActive ? leftCommand : "" },
                Text = { Text = "<b><</b>", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = leftActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2" }
            }, guid + ".L");
            
            container.Add(new CuiPanel 
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 1", OffsetMin = "-30 0", OffsetMax = "0 0" },
                Image = { Color = rightActive ? "0.81 0.77 0.74 0.2" : "0.81 0.77 0.74 0.1"}
            }, guid + ".P", guid + ".WINDOW");
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = rightActive ? rightCommand : "" },
                Text = { Text = "<b>></b>", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = rightActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2"}
            }, guid + ".WINDOW");
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"30 0", OffsetMax = $"-30 0" },  
                Text = { Text = currentStatus.Value.Split(':')[0], Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 18, Color = "250, 5, 5"}
            }, guid + ".P");

            #endregion 

            #region Switch layer Префикс
            
            currentStatus = Settingses.Prefixes.FirstOrDefault(p => p.Value.Split(':')[1] == settings.Prefixes.Name);
            possibleStatuses = Settingses.Prefixes.ToList().FindAll(p => permission.UserHasPermission(player.UserIDString, p.Key));
            bool canChange = currentStatus.Value != "НЕТ:-";
            
            colorIndex = possibleStatuses.IndexOf(currentStatus);
            leftCommand = $"UI_Chat prefix {possibleStatuses.ElementAtOrDefault(colorIndex - 1).Value}"; 
            rightCommand = $"UI_Chat prefix {possibleStatuses.ElementAtOrDefault(colorIndex + 1).Value}"; 
            leftActive = colorIndex > 0;
            rightActive = colorIndex < possibleStatuses.Count - 1;
            
            guid = CuiHelper.GetGuid(); 
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = $"250 -320", OffsetMax = $"-200 -226" },
                Text = { Text = $"ПРЕФИКС<size=12>({possibleStatuses.Count})</size>", Align = TextAnchor.UpperLeft, Font = "robotocondensed-bold.ttf", FontSize = 25, Color = "5, 225, 250"}
            }, SettingsLayer + ".INNER", guid);

            container.Add(new CuiPanel
            {
                RectTransform = {AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = $"-250 -30", OffsetMax = $"-30 0"},
                Image = {Color = "0.27 0.247 0.184 1"} 
            }, guid, guid + ".P");
            
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 1", OffsetMax = "30 0" },
                Image = { Color = leftActive ? "0.81 0.77 0.74 0.2" : "0.81 0.77 0.74 0.15" }
            }, guid + ".P", guid + ".L"); 
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = leftActive ? leftCommand : "" },
                Text = { Text = "<b><</b>", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = leftActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2" }
            }, guid + ".L");
            
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 1", OffsetMin = "-30 0", OffsetMax = "0 0" },
                Image = { Color = rightActive ? "0.81 0.77 0.74 0.2" : "0.81 0.77 0.74 0.1"}
            }, guid + ".P", guid + ".WINDOW");
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = rightActive ? rightCommand : "" },
                Text = { Text = "<b>></b>", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = rightActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2"}
            }, guid + ".WINDOW");
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"30 0", OffsetMax = $"-30 0" },  
                Text = { Text = currentStatus.Value.Split(':')[0], Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 18, Color = "250, 5, 5"}
            }, guid + ".P");

            #endregion 

            #region Switch layer ЦветПрефикс
            
            
            currentStatus = Settingses.Colors.FirstOrDefault(p => p.Value.Split(':')[1] == settings.Prefixes.Color);
            possibleStatuses = Settingses.Colors.ToList().FindAll(p => permission.UserHasPermission(player.UserIDString, p.Key));
 
            colorIndex = possibleStatuses.IndexOf(currentStatus);
            leftCommand = $"UI_Chat prefix_color {possibleStatuses.ElementAtOrDefault(colorIndex - 1).Value}"; 
            rightCommand = $"UI_Chat prefix_color {possibleStatuses.ElementAtOrDefault(colorIndex + 1).Value}"; 
            leftActive = colorIndex > 0 && canChange;
            rightActive = colorIndex < possibleStatuses.Count - 1 && canChange;
            
            guid = CuiHelper.GetGuid(); 
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = $"250 -390", OffsetMax = $"-200 -258" },
                Text = { Text = $"ЦВЕТ ПРЕФИКСА<size=12>({possibleStatuses.Count})</size>", Align = TextAnchor.UpperLeft, Font = "robotocondensed-bold.ttf", FontSize = 25, Color = "5, 225, 250"}
            }, SettingsLayer + ".INNER", guid);

            container.Add(new CuiPanel
            {
                RectTransform = {AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = $"-250 -30", OffsetMax = $"-30 0"},
                Image = {Color = "0.27 0.247 0.184 1"}
            }, guid, guid + ".P");
            
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 1", OffsetMax = "30 0" },
                Image = { Color = leftActive ? "0.81 0.77 0.74 0.2" : "0.81 0.77 0.74 0.15" }
            }, guid + ".P", guid + ".L"); 
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = leftActive ? leftCommand : "" },
                Text = { Text = "<b><</b>", Fon