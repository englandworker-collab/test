Colors = Pool.GetList<String>();

            correctedColors = ConvertStringToList(color);
            if (HasInvalidHexColor(correctedColors, out String invalidHex))
            {
                ReplySystem(player, GetLang("COMMAND_COLOR_CUSTOM_NOT_HEX", player.UserIDString, invalidHex));
                return;
            }

            if (correctedColors.Count > 10)
                ReplySystem(player, GetLang("COMMAND_COLOR_CUSTOM_MAX_ARGUMENTS", player.UserIDString));
            

            User User = UserInformation[player.userID];
            String resultColor = JoinStringList(correctedColors);
            
            User.Info.CustomColorMessage = resultColor;
            
            Pool.FreeList(ref correctedColors);
            
            ReplySystem(player, GetLang("COMMAND_COLOR_CUSTOM_ACCESS", player.UserIDString));
        }

        #endregion

        #region Hide Mute

        private void ConsoleOrPrintMessage(BasePlayer player, String Messages)
        {
            if (player != null)
                player.ConsoleMessage(Messages);
            else PrintWarning(Messages);
        }

        [ConsoleCommand("hmute")]
        void HideMuteConsole(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null)
                if (!permission.UserHasPermission(arg.Player().UserIDString, PermissionMute)) return;

            if (arg == null || arg.Args == null || arg.Args.Length != 3 || arg.Args.Length > 3)
            {
                ConsoleOrPrintMessage(arg.Player(),
                    LanguageEn
                        ? "Invalid syntax, use : hmute Steam64ID Reason Time (seconds)"
                        : "Неверный синтаксис,используйте : hmute Steam64ID Причина Время(секунды)");
                return;
            }
            string NameOrID = arg.Args[0];
            string Reason = arg.Args[1];
            Int32 TimeMute = 0;
            if (!Int32.TryParse(arg.Args[2], out TimeMute))
            {
                ConsoleOrPrintMessage(arg.Player(),
                    LanguageEn ? "Enter the time in numbers!" : "Введите время цифрами!");
                return;
            }
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if (UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            ConsoleOrPrintMessage(arg.Player(),
                                LanguageEn ? "The player already has a chat lock" : "Игрок уже имеет блокировку чата");
                            return;
                        }

                        Info.MuteInfo.SetMute(MuteType.Chat, TimeMute);

                        ConsoleOrPrintMessage(arg.Player(),
                            LanguageEn ? "Chat blocking issued to offline player" : "Блокировка чата выдана offline-игроку");
                        return;
                    }
                    else
                    {
                        ConsoleOrPrintMessage(arg.Player(),
                            LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                        return;
                    }
                }
                else
                {
                    ConsoleOrPrintMessage(arg.Player(),
                        LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                    return;
                }
            }

            MutePlayer(target, MuteType.Chat, 0, arg.Player(), Reason, TimeMute, true, true);
        }

        [ChatCommand("hmute")]
        void HideMute(BasePlayer Moderator, string cmd, string[] arg)
        {
            if (!permission.UserHasPermission(Moderator.UserIDString, PermissionMute)) return;
            if (arg == null || arg.Length != 3 || arg.Length > 3)
            {
                ReplySystem(Moderator, LanguageEn ? "Invalid syntax, use : hmute Steam64ID/Nick Reason Time(seconds)" : "Неверный синтаксис,используйте : hmute Steam64ID/Ник Причина Время(секунды)");
                return;
            }
            string NameOrID = arg[0];
            string Reason = arg[1];
            Int32 TimeMute = 0;
            if (!Int32.TryParse(arg[2], out TimeMute))
            {
                ReplySystem(Moderator, LanguageEn ? "Enter the time in numbers!" : "Введите время цифрами!");
                return;
            }
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if (UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            ReplySystem(Moderator, LanguageEn ? "The player already has a chat lock" : "Игрок уже имеет блокировку чата");
                            return;
                        }

                        Info.MuteInfo.SetMute(MuteType.Chat, TimeMute);
                        ReplySystem(Moderator, LanguageEn ? "Chat blocking issued to offline player" : "Блокировка чата выдана offline-игроку");
                        return;
                    }
                    else
                    {
                        ReplySystem(Moderator, LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                        return;
                    }
                }
                else
                {
                    ReplySystem(Moderator, LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                    return;
                }
            }

            MutePlayer(target, MuteType.Chat, 0, Moderator, Reason, TimeMute, true, true);
        }

        [ConsoleCommand("hunmute")]
        void HideUnMuteConsole(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null)
                if (!permission.UserHasPermission(arg.Player().UserIDString, PermissionMute)) return;
            if (arg == null || arg.Args == null || arg.Args.Length != 1 || arg.Args.Length > 1)
            {
                PrintWarning(LanguageEn ? "Invalid syntax, please use : hunmute Steam64ID" : "Неверный синтаксис,используйте : hunmute Steam64ID");
                return;
            }
            string NameOrID = arg.Args[0];
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if (UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (!Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            ConsoleOrPrintMessage(arg.Player(),
                                LanguageEn ? "The player does not have a chat lock" : "У игрока нет блокировки чата");
                            return;
                        }
                        
                        if (arg.Player()!= null)
                        {
                            if (!arg.Player().IsAdmin && arg.Player().userID == Steam64ID)
                            {
                                ConsoleOrPrintMessage(arg.Player(),
                                    LanguageEn
                                        ? "You can't unlock the chat by yourself"
                                        : "Вы не можете снять блокировку чата сами с себя");

                                return;
                            }
                        }
                    
                        Info.MuteInfo.UnMute(MuteType.Chat);

                        ConsoleOrPrintMessage(arg.Player(),
                            LanguageEn ? "You have unblocked the offline chat to the player" : "Вы разблокировали чат offline игроку");
                        return;
                    }
                    else
                    {
                        ConsoleOrPrintMessage(arg.Player(),
                            LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                        return;
                    }
                }
                else
                {
                    ConsoleOrPrintMessage(arg.Player(),
                        LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                    return;
                }
            }

            UnmutePlayer(target, MuteType.Chat, arg.Player(), true, true);
        }

        [ChatCommand("hunmute")]
        void HideUnMute(BasePlayer Moderator, string cmd, string[] arg)
        {
            if (!permission.UserHasPermission(Moderator.UserIDString, PermissionMute)) return;
            if (arg == null || arg.Length != 1 || arg.Length > 1)
            {
                ReplySystem(Moderator, LanguageEn ? "Invalid syntax, please use : hunmute Steam64ID/Nick" : "Неверный синтаксис,используйте : hunmute Steam64ID/Ник");
                return;
            }
            string NameOrID = arg[0];
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if (UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (!Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            ReplySystem(Moderator, LanguageEn ? "The player does not have a chat lock" : "У игрока нет блокировки чата");
                            return;
                        }

                        if (!Moderator.IsAdmin && Moderator.userID == Steam64ID)
                        {
                            ReplySystem(Moderator, GetLang("FUNC_MESSAGE_UNMUTE_YOURSELF", Moderator.UserIDString));
                            return;
                        }
                        
                        Info.MuteInfo.UnMute(MuteType.Chat);
                        ReplySystem(Moderator, LanguageEn ? "You have unblocked the offline chat to the player" : "Вы разблокировали чат offline игроку");
                        return;
                    }
                    else
                    {
                        ReplySystem(Moderator, LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                        return;
                    }
                }
                else
                {
                    ReplySystem(Moderator, LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                    return;
                }
            }

            UnmutePlayer(target, MuteType.Chat, Moderator, true, true);
        }

        #endregion

        #region Mute

        [ConsoleCommand("mutefull")]
        void MuteCustomAdminFull(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null)
                if (!permission.UserHasPermission(arg.Player().UserIDString, PermissionMute)) return;
            if (arg == null || arg.Args == null || arg.Args.Length != 3 || arg.Args.Length > 3)
            {
                PrintWarning(LanguageEn ? "Invalid syntax, use : mutefull Steam64ID/Nick Reason Time(seconds)" : "Неверный синтаксис,используйте : mutefull Steam64ID/Ник Причина Время(секунды)");
                return;
            }
            string NameOrID = arg.Args[0];
            string Reason = arg.Args[1];
            Int32 TimeMute = 0;
            if (!Int32.TryParse(arg.Args[2], out TimeMute))
            {
                PrintWarning(LanguageEn ? "Enter time in numbers!" : "Введите время цифрами!");
                return;
            }
            
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if (UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        
                        Info.MuteInfo.SetMute(MuteType.Chat, TimeMute);
                        Info.MuteInfo.SetMute(MuteType.Voice, TimeMute);
                        PrintWarning(LanguageEn ? "Chat and voice blocking issued to offline player" : "Блокировка чата и голоса выдана offline-игроку");
                        return;
                    }
                    else
                    {
                        PrintWarning(LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                        return;
                    }
                }
                else
                {
                    PrintWarning(LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                    return;
                }
            }

            MutePlayer(target, MuteType.Chat, 0, arg.Player(), Reason, TimeMute, true, true);
            MutePlayer(target, MuteType.Voice, 0, arg.Player(), Reason, TimeMute, true, true);
            Puts(LanguageEn ? "Successfully" : "Успешно");
        }
        
        [ConsoleCommand("mute")]
        void MuteCustomAdmin(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null)
                if (!permission.UserHasPermission(arg.Player().UserIDString, PermissionMute)) return;
            if (arg == null || arg.Args == null || arg.Args.Length != 3 || arg.Args.Length > 3)
            {
                PrintWarning(LanguageEn ? "Invalid syntax, use : mute Steam64ID/Nick Reason Time(seconds)" : "Неверный синтаксис,используйте : mute Steam64ID/Ник Причина Время(секунды)");
                return;
            }
            string NameOrID = arg.Args[0];
            string Reason = arg.Args[1];
            Int32 TimeMute = 0;
            if (!Int32.TryParse(arg.Args[2], out TimeMute))
            {
                PrintWarning(LanguageEn ? "Enter time in numbers!" : "Введите время цифрами!");
                return;
            }
            
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if (UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            PrintWarning(LanguageEn ? "The player already has a chat lock" : "Игрок уже имеет блокировку чата");
                            return;
                        }

                        Info.MuteInfo.SetMute(MuteType.Chat, TimeMute);
                        PrintWarning(LanguageEn ? "Chat blocking issued to offline player" : "Блокировка чата выдана offline-игроку");
                        return;
                    }
                    else
                    {
                        PrintWarning(LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                        return;
                    }
                }
                else
                {
                    PrintWarning(LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                    return;
                }
            }

            MutePlayer(target, MuteType.Chat, 0, arg.Player(), Reason, TimeMute, false, true);
            Puts(LanguageEn ? "Successfully" : "Успешно");
        }

        [ChatCommand("mute")]
        void MuteCustomChat(BasePlayer Moderator, string cmd, string[] arg)
        {
            if (!permission.UserHasPermission(Moderator.UserIDString, PermissionMute)) return;
            if (arg == null || arg.Length != 3 || arg.Length > 3)
            {
                ReplySystem(Moderator, LanguageEn ? "Invalid syntax, use : mute Steam64ID/Nick Reason Time(seconds)" : "Неверный синтаксис, используйте : mute Steam64ID/Ник Причина Время(секунды)");
                return;
            }
            string NameOrID = arg[0];
            string Reason = arg[1];
            Int32 TimeMute = 0;
            if (!Int32.TryParse(arg[2], out TimeMute))
            {
                ReplySystem(Moderator, LanguageEn ? "Enter time in numbers!" : "Введите время цифрами!");
                return;
            }
            
            if (IsFakeUser(NameOrID))
            {
                List<FakePlayer> playerList = GetCombinedPlayerList();
                if (playerList != null)
                {
                    FakePlayer fakeUser = playerList.FirstOrDefault(x => x.userId.Equals(NameOrID) || x.displayName.ToLower().Contains(NameOrID.ToLower()));
                    if (fakeUser != null)
                        MutePlayer(null, MuteType.Chat, 0, Moderator, Reason, TimeMute, false, true, fakeUser.userId);
                }
                return;
            }
            
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if (UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            ReplySystem(Moderator, LanguageEn ? "The player already has a chat lock" : "Игрок уже имеет блокировку чата");
                            return;
                        }

                        Info.MuteInfo.SetMute(MuteType.Chat, TimeMute);
                        ReplySystem(Moderator, LanguageEn ? "Chat blocking issued to offline player" : "Блокировка чата выдана offline-игроку");
                        return;
                    }
                    else
                    {
                        ReplySystem(Moderator, LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                        return;
                    }
                }
                else
                {
                    ReplySystem(Moderator, LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                    return;
                }
            }

            MutePlayer(target, MuteType.Chat, 0, Moderator, Reason, TimeMute, false, true);
        }
        
        [ChatCommand("mutevoice")]
        void MuteVoiceCustomChat(BasePlayer Moderator, string cmd, string[] arg)
        {
            if (!permission.UserHasPermission(Moderator.UserIDString, PermissionMute)) return;
            if (arg == null || arg.Length != 3 || arg.Length > 3)
            {
                ReplySystem(Moderator, LanguageEn ? "Invalid syntax, use : mutevoice Steam64ID/Nick Reason Time(seconds)" : "Неверный синтаксис, используйте : mutevoice Steam64ID/Ник Причина Время(секунды)");
                return;
            }
            string NameOrID = arg[0];
            string Reason = arg[1];
            Int32 TimeMute = 0;
            if (!Int32.TryParse(arg[2], out TimeMute))
            {
                ReplySystem(Moderator, LanguageEn ? "Enter time in numbers!" : "Введите время цифрами!");
                return;
            }
            
            if (IsFakeUser(NameOrID))
            {
                List<FakePlayer> playerList = GetCombinedPlayerList();
                if (playerList != null)
                {
                    FakePlayer fakeUser = playerList.FirstOrDefault(x => x.userId.Equals(NameOrID) || x.displayName.ToLower().Contains(NameOrID.ToLower()));
                    if (fakeUser != null)
                        MutePlayer(null, MuteType.Voice, 0, Moderator, Reason, TimeMute, false, true, fakeUser.userId);
                }
                return;
            }
            
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if (UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (Info.MuteInfo.IsMute(MuteType.Voice))
                        {
                            ReplySystem(Moderator, LanguageEn ? "The player already has a voice lock" : "Игрок уже имеет блокировку голосового чата");
                            return;
                        }

                        Info.MuteInfo.SetMute(MuteType.Voice, TimeMute);
                        ReplySystem(Moderator, LanguageEn ? "Voice blocking issued to offline player" : "Блокировка глосового чата выдана offline-игроку");
                        return;
                    }
                    else
                    {
                        ReplySystem(Moderator, LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                        return;
                    }
                }
                else
                {
                    ReplySystem(Moderator, LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                    return;
                }
            }

            MutePlayer(target, MuteType.Voice, 0, Moderator, Reason, TimeMute, false, true);
        }
        
        [ConsoleCommand("mutevoice")]
        void MuteCustomVoiceAdmin(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null)
                if (!permission.UserHasPermission(arg.Player().UserIDString, PermissionMute)) return;
            if (arg == null || arg.Args == null || arg.Args.Length != 3 || arg.Args.Length > 3)
            {
                PrintWarning(LanguageEn ? "Invalid syntax, use : mutevoice Steam64ID/Nick Reason Time(seconds)" : "Неверный синтаксис,используйте : mutevoice Steam64ID/Ник Причина Время(секунды)");
                return;
            }
            string NameOrID = arg.Args[0];
            string Reason = arg.Args[1];
            Int32 TimeMute = 0;
            if (!Int32.TryParse(arg.Args[2], out TimeMute))
            {
                PrintWarning(LanguageEn ? "Enter time in numbers!" : "Введите время цифрами!");
                return;
            }
            
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if (UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (Info.MuteInfo.IsMute(MuteType.Voice))
                        {
                            PrintWarning(LanguageEn ? "The player already has a voice lock" : "Игрок уже имеет блокировку голосового чата");
                            return;
                        }

                        Info.MuteInfo.SetMute(MuteType.Voice, TimeMute);
                        PrintWarning(LanguageEn ? "Voice blocking issued to offline player" : "Блокировка голосового чата выдана offline-игроку");
                        return;
                    }
                    else
                    {
                        PrintWarning(LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                        return;
                    }
                }
                else
                {
                    PrintWarning(LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                    return;
                }
            }

            MutePlayer(target, MuteType.Voice, 0, arg.Player(), Reason, TimeMute, false, true);
            Puts(LanguageEn ? "Successfully" : "Успешно");
        }

        [ConsoleCommand("unmute")]
        void UnMuteCustomAdmin(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null)
                if (!permission.UserHasPermission(arg.Player().UserIDString, PermissionMute)) return;

            if (arg?.Args == null || arg.Args.Length != 1 || arg.Args.Length > 1)
            {
                PrintWarning(LanguageEn ? "Invalid syntax, please use : unmute Steam64ID" : "Неверный синтаксис,используйте : unmute Steam64ID");
                return;
            }

            string NameOrID = arg.Args[0];
            BasePlayer target = GetPlayerNickOrID(NameOrID);

            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if (UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (!Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            ConsoleOrPrintMessage(arg.Player(),
                                LanguageEn ? "The player does not have a chat lock" : "У игрока нет блокировки чата");
                            return;
                        }

                        if (arg.Player()!= null)
                        {
                            if (!arg.Player().IsAdmin && arg.Player().userID == Steam64ID)
                            {
                                ConsoleOrPrintMessage(arg.Player(),
                                    LanguageEn
                                        ? "You can't unlock the chat by yourself"
                                        : "Вы не можете снять блокировку чата сами с себя");

                                return;
                            }
                        }

                        Info.MuteInfo.UnMute(MuteType.Chat);

                        ConsoleOrPrintMessage(arg.Player(),
                            LanguageEn ? "You have unblocked the offline chat to the player" : "Вы разблокировали чат offline игроку");
                        return;
                    }
                    else
                    {
                        ConsoleOrPrintMessage(arg.Player(),
                            LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                        return;
                    }
                }
                else
                {
                    ConsoleOrPrintMessage(arg.Player(),
                        LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                    return;
                }
            }

            UnmutePlayer(target, MuteType.Chat, arg.Player(), false, true);
            Puts(LanguageEn ? "Successfully" : "Успешно");
        }
        
        [ConsoleCommand("unmutevoice")]
        void UnMuteVoiceCustomAdmin(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null)
                if (!permission.UserHasPermission(arg.Player().UserIDString, PermissionMute)) return;

            if (arg?.Args == null || arg.Args.Length != 1 || arg.Args.Length > 1)
            {
                PrintWarning(LanguageEn ? "Invalid syntax, please use : unmutevoice Steam64ID" : "Неверный синтаксис,используйте : unmutevoice Steam64ID");
                return;
            }

            string NameOrID = arg.Args[0];
            BasePlayer target = GetPlayerNickOrID(NameOrID);

            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if (UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (!Info.MuteInfo.IsMute(MuteType.Voice))
                        {
                            ConsoleOrPrintMessage(arg.Player(),
                                LanguageEn ? "The player does not have a chat lock" : "У игрока нет блокировки чата");
                            return;
                        }
                        
                        if (arg.Player()!= null)
                        {
                            if (!arg.Player().IsAdmin && arg.Player().userID == Steam64ID)
                            {
                                ConsoleOrPrintMessage(arg.Player(),
                                    LanguageEn
                                        ? "You can't unlock the chat by yourself"
                                        : "Вы не можете снять блокировку чата сами с себя");

                                return;
                            }
                        }
                        
                        Info.MuteInfo.UnMute(MuteType.Voice);

                        ConsoleOrPrintMessage(arg.Player(),
                            LanguageEn ? "You have unblocked the offline chat to the player" : "Вы разблокировали чат offline игроку");
                        return;
                    }
                    else
                    {
                        ConsoleOrPrintMessage(arg.Player(),
                            LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                        return;
                    }
                }
                else
                {
                    ConsoleOrPrintMessage(arg.Player(),
                        LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                    return;
                }
            }

            UnmutePlayer(target, MuteType.Voice, arg.Player(), false, true);
            Puts(LanguageEn ? "Successfully" : "Успешно");
        }


        [ChatCommand("unmute")]
        void UnMuteCustomChat(BasePlayer Moderator, string cmd, string[] arg)
        {
            if (!permission.UserHasPermission(Moderator.UserIDString, PermissionMute)) return;
            if (arg == null || arg.Length != 1 || arg.Length > 1)
            {
                ReplySystem(Moderator, LanguageEn ? "Invalid syntax, please use : unmute Steam64ID" : "Неверный синтаксис,используйте : unmute Steam64ID");
                return;
            }
            string NameOrID = arg[0];
            
            if (IsFakeUser(NameOrID))
            {
                List<FakePlayer> playerList = GetCombinedPlayerList();
                if (playerList != null)
                {
                    FakePlayer fakeUser = playerList.FirstOrDefault(x => x.userId.Equals(NameOrID) || x.displayName.ToLower().Contains(NameOrID.ToLower()));
                    if (fakeUser != null)
                        UnmutePlayer(null, MuteType.Chat, Moderator, false, true, fakeUser.userId);
                }
                return;
            }
            
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if (UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (!Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            ReplySystem(Moderator, LanguageEn ? "The player does not have a chat lock" : "У игрока нет блокировки чата");
                            return;
                        }
                        
                        if (!Moderator.IsAdmin && Moderator.userID == Steam64ID)
                        {
                            ReplySystem(Moderator, GetLang("FUNC_MESSAGE_UNMUTE_YOURSELF", Moderator.UserIDString));
                            return;
                        }

                        Info.MuteInfo.UnMute(MuteType.Chat);
                        ReplySystem(Moderator, LanguageEn ? "You have unblocked the offline chat to the player" : "Вы разблокировали чат offline игроку");
                        return;
                    }
                    else
                    {
                        ReplySystem(Moderator, LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                        return;
                    }
                }
                else
                {
                    ReplySystem(Moderator, LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                    return;
                }
            }
            UnmutePlayer(target, MuteType.Chat, Moderator, false, true);
        }
        
        [ChatCommand("unmutevoice")]
        void UnMuteVoiceCustomChat(BasePlayer Moderator, string cmd, string[] arg)
        {
            if (!permission.UserHasPermission(Moderator.UserIDString, PermissionMute)) return;
            if (arg == null || arg.Length != 1 || arg.Length > 1)
            {
                ReplySystem(Moderator, LanguageEn ? "Invalid syntax, please use : unmutevoice Steam64ID" : "Неверный синтаксис,используйте : unmutevoice Steam64ID");
                return;
            }
            string NameOrID = arg[0];
            
            if (IsFakeUser(NameOrID))
            {
                List<FakePlayer> playerList = GetCombinedPlayerList();
                if (playerList != null)
                {
                    FakePlayer fakeUser = playerList.FirstOrDefault(x => x.userId.Equals(NameOrID) || x.displayName.ToLower().Contains(NameOrID.ToLower()));
                    if (fakeUser != null)
                        UnmutePlayer(null, MuteType.Chat, Moderator, false, true, fakeUser.userId);
                }
                return;
            }
            
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if (UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (!Info.MuteInfo.IsMute(MuteType.Voice))
                        {
                            ReplySystem(Moderator, LanguageEn ? "The player does not have a chat lock" : "У игрока нет блокировки чата");
                            return;
                        }
                        
                        if (!Moderator.IsAdmin && Moderator.userID == Steam64ID)
                        {
                            ReplySystem(Moderator, GetLang("FUNC_MESSAGE_UNMUTE_YOURSELF", Moderator.UserIDString));
                            return;
                        }

                        Info.MuteInfo.UnMute(MuteType.Voice);
                        ReplySystem(Moderator, LanguageEn ? "You have unblocked the offline chat to the player" : "Вы разблокировали чат offline игроку");
                        return;
                    }
                    else
                    {
                        ReplySystem(Moderator, LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                        return;
                    }
                }
                else
                {
                    ReplySystem(Moderator, LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                    return;
                }
            }
            UnmutePlayer(target, MuteType.Voice, Moderator, false, true);
        }

        #endregion

        #region ShowOnline

        [ChatCommand("online")]
        private void ShowPlayerOnline(BasePlayer player)
        {
            if (!config.OtherSetting.UseCommandOnline) return;
            
            String Message = String.Empty;
            if (config.OtherSetting.UseCommandShortOnline)
            {
                Int32 shortCount = GetPlayersOnlineShort();
                Message = GetLang("IQCHAT_INFO_ONLINE", player.UserIDString, $"{shortCount}");
            }
            else
            {
                List<String> PlayerNames = GetPlayersOnline();
                Message = GetLang("IQCHAT_INFO_ONLINE", player.UserIDString, String.Join($"\n", PlayerNames));
            }

            ReplySystem(player, Message);
            player.ConsoleMessage(Message);
        }

        [ConsoleCommand("online")]
        private void ShowPlayerOnlineConsole(ConsoleSystem.Arg arg)
        {
            if (!config.OtherSetting.UseCommandOnline) return;

            BasePlayer player = arg.Player();
            String Message = String.Empty;
            
            if (config.OtherSetting.UseCommandShortOnline)
            {
                Int32 shortCount = GetPlayersOnlineShort();
                Message = GetLang("IQCHAT_INFO_ONLINE", player != null ? player.UserIDString : null, $"{shortCount}");
            }
            else
            {
                List<String> PlayerNames = GetPlayersOnline();
                Message = GetLang("IQCHAT_INFO_ONLINE", player != null ? player.UserIDString : null, String.Join($"\n", PlayerNames));
            }

            if (player != null)
                player.ConsoleMessage(Message);
            else
            {
                String Pattern = @"</?size.*?>|</?color.*?>";
                String Messages = Regex.IsMatch(Message, Pattern) ? Regex.Replace(Message, Pattern, "") : Message;
                Puts(Messages);
            }
        }
        #endregion

        #region Alert Command

        #region Chat Command

        [ChatCommand("alert")]
        private void AlertChatCommand(BasePlayer Sender, String cmd, String[] args)
        {
            if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            Alert(Sender, args, false);
        }
        [ChatCommand("adminalert")]
        private void AdminAlertChatCommand(BasePlayer Sender, String cmd, String[] args)
        {
            if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            Alert(Sender, args, true);
        }

        [ChatCommand("alertui")]
        private void AlertUIChatCommand(BasePlayer Sender, String cmd, String[] args)
        {
            if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            AlertUI(Sender, args);
        }
        [ChatCommand("alertuip")]
        private void AlertUIPChatCommand(BasePlayer Sender, String cmd, String[] args)
        {
            if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            if (args == null || args.Length == 0)
            {
                ReplySystem(Sender, LanguageEn ? "You didn't specify a player!" : "Вы не указали игрока!");
                return;
            }
            BasePlayer Recipient = BasePlayer.Find(args[0]);
            if (Recipient == null)
            {
                ReplySystem(Sender, LanguageEn ? "The player is not on the server!" : "Игрока нет на сервере!");
                return;
            }
            AlertUI(Sender, Recipient, args.Skip(1).ToArray());
        }
        [ChatCommand("saybro")]
        private void AlertOnlyPlayerChatCommand(BasePlayer Sender, String cmd, String[] args)
        {
            if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            if (args == null || args.Length == 0)
            {
                ReplySystem(Sender, LanguageEn ? "You didn't specify a player!" : "Вы не указали игрока!");
                return;
            }
            BasePlayer Recipient = BasePlayer.Find(args[0]);
            if (Recipient == null)
            {
                ReplySystem(Sender, LanguageEn ? "The player is not on the server" : "Игрока нет на сервере!");
                return;
            }
            Alert(Sender, Recipient, args.Skip(1).ToArray());
        }
        #endregion

        #region Console Command

        [ConsoleCommand("alert")]
        private void AlertConsoleCommand(ConsoleSystem.Arg args)
        {
            BasePlayer Sender = args.Player();
            if (Sender != null)
                if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;

            Alert(Sender, args.Args, false);
        }
        [ConsoleCommand("adminalert")]
        private void AdminAlertConsoleCommand(ConsoleSystem.Arg args)
        {
            BasePlayer Sender = args.Player();
            if (Sender != null)
                if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            Alert(Sender, args.Args, true);
        }

        [ConsoleCommand("alertui")]
        private void AlertUIConsoleCommand(ConsoleSystem.Arg args)
        {
            BasePlayer Sender = args.Player();
            if (Sender != null)
                if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            AlertUI(Sender, args.Args);
        }
        [ConsoleCommand("alertuip")]
        private void AlertUIPConsoleCommand(ConsoleSystem.Arg args)
        {
            BasePlayer Sender = args.Player();
            if (Sender != null)
                if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            if (args.Args == null || args.Args.Length == 0)
            {
                if (Sender != null)
                    ReplySystem(Sender, LanguageEn ? "You didn't specify a player!" : "Вы не указали игрока!");
                else PrintWarning(LanguageEn ? "You didn't specify a player!" : "Вы не указали игрока!");
                return;
            }
            BasePlayer Recipient = BasePlayer.Find(args.Args[0]);
            if (Recipient == null)
            {
                if (Sender != null)
                    ReplySystem(Sender, LanguageEn ? "The player is not on the server!" : "Игрока нет на сервере!");
                else PrintWarning(LanguageEn ? "The player is not on the server!" : "Игрока нет на сервере!");
                return;
            }
            AlertUI(Sender, Recipient, args.Args.Skip(1).ToArray());
        }
        [ConsoleCommand("saybro")]
        private void AlertOnlyPlayerConsoleCommand(ConsoleSystem.Arg args)
        {
            BasePlayer Sender = args.Player();
            if (Sender != null)
                if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;

            if (args.Args == null || args.Args.Length == 0)
            {
                if (Sender != null)
                    ReplySystem(Sender, LanguageEn ? "You didn't specify a player!" : "Вы не указали игрока!");
                else PrintWarning(LanguageEn ? "You didn't specify a player" : "Вы не указали игрока!");
                return;
            }
            BasePlayer Recipient = BasePlayer.Find(args.Args[0]);
            if (Recipient == null)
            {
                if (Sender != null)
                    ReplySystem(Sender, LanguageEn ? "The player is not on the server!" : "Игрока нет на сервере!");
                else PrintWarning(LanguageEn ? "The player is not on the server!" : "Игрока нет на сервере!");
                return;
            }
            Alert(Sender, Recipient, args.Args.Skip(1).ToArray());
        }
        #endregion

        #endregion

        #region Admin Command

        #region Rename
        [ChatCommand("rename")]
        private void ChatCommandRename(BasePlayer Renamer, string command, string[] args)
        {
            if (!permission.UserHasPermission(Renamer.UserIDString, PermissionRename)) return;
            GeneralInformation General = GeneralInfo;
            if (General == null) return;

            if (Renamer == null)
            {
                ReplySystem(Renamer, LanguageEn ? "You can only use this command while on the server" : "Вы можете использовать эту команду только находясь на сервере");
                return;
            }
            if (args.Length == 0 || args == null)
            {
                ReplySystem(Renamer, lang.GetMessage("COMMAND_RENAME_NOTARG", this, Renamer.UserIDString));
                return;
            }

            String Name = args[0];
            UInt64 ID = Renamer.userID;
            if (args.Length == 2 && args[1] != null && !String.IsNullOrWhiteSpace(args[1]))
                if (!UInt64.TryParse(args[1], out ID))
                {
                    ReplySystem(Renamer, GetLang("COMMAND_RENAME_NOT_ID", Renamer.UserIDString));
                    return;
                }

            if (General.RenameList.ContainsKey(Renamer.userID))
            {
                General.RenameList[Renamer.userID].RenameNick = Name;
                General.RenameList[Renamer.userID].RenameID = ID;
            }
            else General.RenameList.Add(Renamer.userID, new GeneralInformation.RenameInfo { RenameNick = Name, RenameID = ID });

            ReplySystem(Renamer, GetLang("COMMAND_RENAME_SUCCES", Renamer.UserIDString, Name, ID));
            RenameUpdate(Renamer, Name);
        }
        
        [ChatCommand("rename.reset")]
        private void ChatCommandRenameReset(BasePlayer Renamer)
        {
            if (Renamer == null)
            {
                ReplySystem(Renamer, LanguageEn ? "You can only use this command while on the server" : "Вы можете использовать эту команду только находясь на сервере");
                return;
            }
            
            if (!permission.UserHasPermission(Renamer.UserIDString, PermissionRename)) return;
            GeneralInformation General = GeneralInfo;
            if (General == null) return;

            if (!General.RenameList.ContainsKey(Renamer.userID))
            {
                ReplySystem(Renamer, GetLang("COMMAND_RENAME_NOTHING", Renamer.UserIDString));
                return;
            }
            
            General.RenameList.Remove(Renamer.userID);
            RenameReset(Renamer);
        }
        
        [ConsoleCommand("rename.reset")]
        private void ConsoleCommandRenameReset(ConsoleSystem.Arg args)
        {
            BasePlayer Renamer = args.Player();
            if (Renamer == null)
            {
                ReplySystem(Renamer, LanguageEn ? "You can only use this command while on the server" : "Вы можете использовать эту команду только находясь на сервере");
                return;
            }
            
            if (!permission.UserHasPermission(Renamer.UserIDString, PermissionRename)) return;
            GeneralInformation General = GeneralInfo;
            if (General == null) return;

            if (!General.RenameList.ContainsKey(Renamer.userID))
            {
                ReplySystem(Renamer, GetLang("COMMAND_RENAME_NOTHING", Renamer.UserIDString));
                return;
            }
            General.RenameList.Remove(Renamer.userID);
            RenameReset(Renamer);
        }

        [ConsoleCommand("rename")]
        private void ConsoleCommandRename(ConsoleSystem.Arg args)
        {
            BasePlayer Renamer = args.Player();
            if (Renamer == null)
            {
                PrintWarning(LanguageEn ? "You can only use this command while on the server" : "Вы можете использовать эту команду только находясь на сервере");
                return;
            }

            if (!permission.UserHasPermission(Renamer.UserIDString, PermissionRename)) return;
            GeneralInformation General = GeneralInfo;
            if (General == null) return;

            if (args.Args.Length == 0 || args == null)
            {
                ReplySystem(Renamer, lang.GetMessage("COMMAND_RENAME_NOTARG", this, Renamer.UserIDString));
                return;
            }

            String Name = args.Args[0];
            UInt64 ID = Renamer.userID;
            if (args.Args.Length == 2 && args.Args[1] != null && !String.IsNullOrWhiteSpace(args.Args[1]))
                if (!UInt64.TryParse(args.Args[1], out ID))
                {
                    ReplySystem(Renamer, lang.GetMessage("COMMAND_RENAME_NOT_ID", this, Renamer.UserIDString));
                    return;
                }

            if (General.RenameList.ContainsKey(Renamer.userID))
            {
                General.RenameList[Renamer.userID].RenameNick = Name;
                General.RenameList[Renamer.userID].RenameID = ID;
            }
            else General.RenameList.Add(Renamer.userID, new GeneralInformation.RenameInfo { RenameNick = Name, RenameID = ID });

            ReplySystem(Renamer, GetLang("COMMAND_RENAME_SUCCES", Renamer.UserIDString, Name, ID));
            RenameUpdate(Renamer, Name);
        }

        private void RenameUpdate(BasePlayer Renamer, String NewName)
        {
            Renamer.displayName = NewName;
            Renamer.IPlayer?.Rename(NewName);
        }
        private void RenameReset(BasePlayer Renamer)
        {
            String apiKey = config.OtherSetting.renameSteamApiKey;
            if (String.IsNullOrWhiteSpace(apiKey))
            {
                ReplySystem(Renamer, LanguageEn ? "You do not have a Steam API Key specified in the configuration - it is impossible to get an up-to-date nickname" : "У вас не указан Steam API Key в конфигурации - невозможно получить актуальный ник");
                return;
            }
            webrequest.Enqueue($"https://api.steampowered.com/ISteamUser/GetPlayerSummaries/v2/?key={apiKey}&steamids={Renamer.userID}", null, (code, response) =>
            {
			    if(code == 200 && response != null)
                {
                    try
                    {
                        JObject json = JObject.Parse(response);
                        JToken players = json["response"]["players"];
                        if (players is { HasValues: true })
                        {
                            String nickname = players[0]["personaname"].ToString();
                            RenameUpdate(Renamer, nickname);
                            ReplySystem(Renamer, GetLang("COMMAND_RENAME_RESET_SUCCES", Renamer.UserIDString));
                        }
                        else
                        {
                            Puts("No player data found for the provided Steam64ID.");
                        }
                    }
                    catch (Exception ex)
                    {
                        PrintWarning($"Failed to parse the Steam API response! Error: \"{ex.Message}\"");
                    }
                }
                else
                {
                    PrintWarning($"Steam API didn't respond (down?) Code: {code}");
                }
            }, this, RequestMethod.GET, null, 5f);
            
            ReplySystem(Renamer, GetLang("COMMAND_RENAME_PROCESS_STEAM", Renamer.UserIDString));
        }
        
        #endregion

        [ConsoleCommand("set")]
        private void CommandSet(ConsoleSystem.Arg args)
        {
            BasePlayer Sender = args.Player();

            if (Sender != null)
                if (!Sender.IsAdmin)
                    return;

            if (args == null || args.Args == null || args.Args.Length != 3)
            {
                if (Sender != null)
                    ReplySystem(Sender, LanguageEn ? "Use syntax correctly : set [Steam64ID] [prefix/chat/nick/custom] [Argument]" : "Используйте правильно ситаксис : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                else PrintWarning(LanguageEn ? "Use syntax correctly : set [Steam64ID] [prefix/chat/nick/custom] [Argument]" : "Используйте правильно ситаксис : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                return;
            }

            UInt64 Steam64ID = 0;
            BasePlayer player = null;

            if (UInt64.TryParse(args.Args[0], out Steam64ID))
                player = BasePlayer.FindByID(Steam64ID);

            if (player == null)
            {
                if (Sender != null)
                    ReplySystem(Sender, LanguageEn ? "Incorrect player Steam ID or syntax error\nUse syntax correctly : set [Steam64ID] [prefix/chat/nick/custom] [Argument]" : "Неверно указан SteamID игрока или ошибка в синтаксисе\nИспользуйте правильно ситаксис : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                else PrintWarning(LanguageEn ? "Incorrect player Steam ID or syntax error\nUse syntax correctly : set [Steam64ID] [prefix/chat/nick/custom] [Argument]" : "Неверно указан SteamID игрока или ошибка в синтаксисе\nИспользуйте правильно ситаксис : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                return;
            }
            if (!UserInformation.ContainsKey(player.userID))
            {
                if (Sender != null)
                    ReplySystem(Sender, LanguageEn ? $"Player not found!" : $"Игрок не найден!");
                else PrintWarning(LanguageEn ? $"Player not found!" : $"Игрок не найден!");
                return;
            }
            User Info = UserInformation[player.userID];

            Configuration.ControllerParameters ControllerParameter = config.ControllerParameter;

            switch (args.Args[1])
            {
                case "prefix":
                    {
                        String KeyPrefix = args.Args[2];
                        if (ControllerParameter.Prefixes.Prefixes.Count(prefix => prefix.Argument.Contains(KeyPrefix)) == 0)
                        {
                            if (Sender != null)
                                ReplySystem(Sender, LanguageEn ? "Argument not found in your configuration" : $"Аргумент не найден в вашей конфигурации!");
                            else PrintWarning(LanguageEn ? $"Argument not found in your configuration" : $"Аргумент не найден в вашей конфигурации");
                            return;
                        }

                        foreach (Configuration.ControllerParameters.AdvancedFuncion Prefix in ControllerParameter.Prefixes.Prefixes.Where(prefix => prefix.Argument.Contains(KeyPrefix)).Take(1))
                        {
                            if (ControllerParameter.Prefixes.TurnMultiPrefixes)
                                Info.Info.PrefixList.Add(Prefix.Argument);
                            else Info.Info.Prefix = Prefix.Argument;

                            if (Sender != null)
                                ReplySystem(Sender, LanguageEn ? $"Prefix successfully set to - {Prefix.Argument}" : $"Префикс успешно установлен на - {Prefix.Argument}");
                            else Puts(LanguageEn ? $"Prefix successfully set to - {Prefix.Argument}" : $"Префикс успешно установлен на - {Prefix.Argument}");
                        }
                        break;
                    }
                case "chat":
                    {
                        String KeyChatColor = args.Args[2];
                        if (ControllerParameter.MessageColorList.Count(color => color.Argument.Contains(KeyChatColor)) == 0)
                        {
                            if (Sender != null)
                                ReplySystem(Sender, LanguageEn ? $"Argument not found in your configuration!" : $"Аргумент не найден в вашей конфигурации!");
                            else PrintWarning(LanguageEn ? $"Argument not found in your configuration" : $"Аргумент не найден в вашей конфигурации");
                            return;
                        }

                        foreach (Configuration.ControllerParameters.AdvancedFuncion ChatColor in ControllerParameter.MessageColorList.Where(color => color.Argument.Contains(KeyChatColor)).Take(1))
                        {
                            Info.Info.ColorMessage = ChatColor.Argument;
                            if (Sender != null)
                                ReplySystem(Sender, LanguageEn ? $"Message color successfully set to - {ChatColor.Argument}" : $"Цвет сообщения успешно установлен на - {ChatColor.Argument}");
                            else Puts(LanguageEn ? $"Message color successfully set to - {ChatColor.Argument}" : $"Цвет сообщения успешно установлен на - {ChatColor.Argument}");
                        }
                        break;
                    }
                case "nick":
                    {
                        String KeyNickColor = args.Args[2];
                        if (ControllerParameter.NickColorList.Count(color => color.Argument.Contains(KeyNickColor)) == 0)
                        {
                            if (Sender != null)
                                ReplySystem(Sender, LanguageEn ? $"Argument not found in your configuration!" : $"Аргумент не найден в вашей конфигурации!");
                            else PrintWarning(LanguageEn ? "Argument not found in your configuration" : $"Аргумент не найден в вашей конфигурации");
                            return;
                        }

                        foreach (Configuration.ControllerParameters.AdvancedFuncion NickColor in ControllerParameter.NickColorList.Where(color => color.Argument.Contains(KeyNickColor)).Take(1))
                        {
                            Info.Info.ColorNick = NickColor.Argument;
                            if (Sender != null)
                                ReplySystem(Sender, LanguageEn ? $"Message color successfully set to - {NickColor.Argument}" : $"Цвет сообщения успешно установлен на - {NickColor.Argument}");
                            else Puts(LanguageEn ? $"Message color successfully set to - {NickColor.Argument}" : $"Цвет сообщения успешно установлен на - {NickColor.Argument}");
                        }
                        break;
                    }
                case "custom":
                    {
                        String CustomPrefix = args.Args[2];
                        if (ControllerParameter.Prefixes.TurnMultiPrefixes)
                            Info.Info.PrefixList.Add(CustomPrefix);
                        else Info.Info.Prefix = CustomPrefix;
                        if (Sender != null)
                            ReplySystem(Sender, LanguageEn ? $"Custom prefix successfully set to - {CustomPrefix}" : $"Кастомный префикс успешно установлен на - {CustomPrefix}");
                        else Puts(LanguageEn ? $"Custom prefix successfully set to - {CustomPrefix}" : $"Кастомный префикс успешно установлен на - {CustomPrefix}");

                        break;
                    }
                default:
                    {
                        if (Sender != null)
                            ReplySystem(Sender, LanguageEn ? "Use syntax correctly : set [Steam64ID] [prefix/chat/nick/custom] [Argument]" : "Используйте правильно ситаксис : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                        break;
                    }
            }

        }
        #endregion

        #region PM

        private void ReplyTranslationPM(BasePlayer Sender, BasePlayer TargetUser, String Message, String DisplayNameSender, String TargetDisplayName)
        {
            if (!String.IsNullOrWhiteSpace(config.ReferenceSetting.translationApiSettings.codeLanguagePrimary))
            {
                Action<String> callback = translation =>
                {
                    ReplySystem(TargetUser, GetLang("COMMAND_PM_SEND_MSG", TargetUser.UserIDString, DisplayNameSender, !permission.UserHasPermission(TargetUser.UserIDString, PermissionTranslationIgnore) ? translation : Message));
                    ReplySystem(Sender, GetLang("COMMAND_PM_SUCCESS", Sender.UserIDString, Message, TargetDisplayName));
                };

                TranslationAPI.Call("Translate", Message, config.ReferenceSetting.translationApiSettings.codeLanguagePrimary, "auto", callback);
            }
            else
            {
                String codeResult = lang.GetLanguage(TargetUser.UserIDString);
                saveTranslate.TryAdd(codeResult, new TranslationState());

                Action<String> callback = translation =>
                {
                    saveTranslate[codeResult].IsProcessed = true;
                    saveTranslate[codeResult].Translation = translation;
                    saveTranslate[codeResult].DoTranslation = Message;

                    ReplySystem(TargetUser, GetLang("COMMAND_PM_SEND_MSG", TargetUser.UserIDString, DisplayNameSender, !permission.UserHasPermission(TargetUser.UserIDString, PermissionTranslationIgnore) ? translation : Message));
                    ReplySystem(Sender, GetLang("COMMAND_PM_SUCCESS", Sender.UserIDString, Message, TargetDisplayName));
                };

                if (lang.GetLanguage(Sender.UserIDString) == codeResult)
                {
                    ReplySystem(TargetUser, GetLang("COMMAND_PM_SEND_MSG", TargetUser.UserIDString, DisplayNameSender, Message));
                    ReplySystem(Sender, GetLang("COMMAND_PM_SUCCESS", Sender.UserIDString, Message, TargetDisplayName));
                }
                else if (saveTranslate[codeResult].IsProcessed && !string.IsNullOrWhiteSpace(saveTranslate[codeResult].Translation) && Message == saveTranslate[codeResult].DoTranslation)
                {
                    ReplySystem(TargetUser, GetLang("COMMAND_PM_SEND_MSG", TargetUser.UserIDString, DisplayNameSender, saveTranslate[codeResult].Translation));
                    ReplySystem(Sender, GetLang("COMMAND_PM_SUCCESS", Sender.UserIDString, Message, TargetDisplayName));
                }
                else TranslationAPI.Call("Translate", Message, codeResult, "auto", callback);
            }
        }

        [ChatCommand("pm")]
        void PmChat(BasePlayer Sender, String cmd, String[] arg)
        {
            Configuration.ControllerMessage ControllerMessages = config.ControllerMessages;
            if (!ControllerMessages.TurnedFunc.PMSetting.PMActivate) return;
            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(Sender, lang.GetMessage("COMMAND_PM_NOTARG", this, Sender.UserIDString));
                return;
            }

            Configuration.ControllerMessage.TurnedFuncional.AntiNoob.Settings antiNoob = config.ControllerMessages.TurnedFunc.AntiNoobSetting.AntiNoobPM;
            if (antiNoob.AntiNoobActivate)
                if (IsNoob(Sender.userID, antiNoob.TimeBlocked))
                {
                    ReplySystem(Sender, GetLang("IQCHAT_INFO_ANTI_NOOB_PM", Sender.UserIDString, FormatTime(UserInformationConnection[Sender.userID].LeftTime(antiNoob.TimeBlocked), Sender.UserIDString)));
                    return;
                }
            
            User InfoSender = UserInformation[Sender.userID];
            
            if(config.ControllerMutes.mutedPM)
                if (InfoSender.MuteInfo.IsMute(MuteType.Chat))
                {
                    ReplySystem(Sender, GetLang("IQCHAT_FUNCED_NO_SEND_CHAT_MUTED", Sender.UserIDString, FormatTime(InfoSender.MuteInfo.GetTime(MuteType.Chat), Sender.UserIDString)));
                    return;
                }
            
            String NameUser = arg[0];

            if (IsReadyIQFakeActive() && IsFakeUser(NameUser))
            {
                ReplySystem(Sender, GetLang("COMMAND_PM_SUCCESS", Sender.UserIDString, string.Join(" ", arg.ToArray()).Replace(NameUser, ""), NameUser));
                return;
            }
            
            BasePlayer TargetUser = GetPlayerNickOrID(NameUser);
            
            if (TargetUser == null || NameUser == null || !UserInformation.ContainsKey(TargetUser.userID))
            {
                ReplySystem(Sender, GetLang("COMMAND_PM_NOT_USER", Sender.UserIDString));
                return;
            }
            
            User InfoTarget = UserInformation[TargetUser.userID];
            
            if (!InfoTarget.Settings.TurnPM)
            {
                ReplySystem(Sender, GetLang("FUNC_MESSAGE_PM_TURN_FALSE", Sender.UserIDString));
                return;
            }

            if (ControllerMessages.TurnedFunc.IgnoreUsePM)
            {
                if (InfoTarget.Settings.IsIgnored(Sender.userID))
                {
                    ReplySystem(Sender, GetLang("IGNORE_NO_PM", Sender.UserIDString));
                    return;
                }
                if (InfoSender.Settings.IsIgnored(TargetUser.userID))
                {
                    ReplySystem(Sender, GetLang("IGNORE_NO_PM_ME", Sender.UserIDString));
                    return;
                }
            }
            String Message = GetMessageInArgs(Sender, arg.Skip(1).ToArray());

            if (Message == null || Message.Length <= 0)
            {
                ReplySystem(Sender, GetLang("COMMAND_PM_NOT_NULL_MSG", Sender.UserIDString));
                return;
            }
            Message = Message.EscapeRichText();

            if (Message.Length > 125) return;
            
            PMHistory[TargetUser] = Sender;
            PMHistory[Sender] = TargetUser;

            GeneralInformation.RenameInfo RenamerSender = GeneralInfo.GetInfoRename(Sender.userID);
            GeneralInformation.RenameInfo RenamerTarget = GeneralInfo.GetInfoRename(TargetUser.userID);

            String DisplayNameSender = RenamerSender != null ? RenamerSender.RenameNick ?? Sender.displayName : Sender.displayName;
            String TargetDisplayName = RenamerTarget != null ? RenamerTarget.RenameNick ?? TargetUser.displayName : TargetUser.displayName;

            if (TranslationAPI && config.ReferenceSetting.translationApiSettings.useTranslationApi && config.ReferenceSetting.translationApiSettings.translatePmChat)
                ReplyTranslationPM(Sender, TargetUser, Message, DisplayNameSender, TargetDisplayName);
            else
            {
                ReplySystem(TargetUser, GetLang("COMMAND_PM_SEND_MSG", TargetUser.UserIDString, DisplayNameSender, Message));
                ReplySystem(Sender, GetLang("COMMAND_PM_SUCCESS", Sender.UserIDString, Message, TargetDisplayName));
            }

            if (InfoTarget.Settings.TurnSound)
                Effect.server.Run(ControllerMessages.TurnedFunc.PMSetting.SoundPM, TargetUser.GetNetworkPosition());

            RustApp?.Call("RA_DirectMessageHandler", Sender.UserIDString, TargetUser.UserIDString, Message);
            
            Log(LanguageEn ? $"PRIVATE MESSAGES : {DisplayNameSender}({Sender.userID}) sent a message to the player - {TargetDisplayName}({TargetUser.userID})\nMESSAGE : {Message}" : $"ЛИЧНЫЕ СООБЩЕНИЯ : {DisplayNameSender}({Sender.userID}) отправил сообщение игроку - {TargetDisplayName}({TargetUser.userID})\nСООБЩЕНИЕ : {Message}");
            DiscordLoggPM(Sender, TargetUser, Message);

            RCon.Broadcast(RCon.LogType.Chat, new Chat.ChatEntry
            {
                Message = LanguageEn ? $"PRIVATE MESSAGES : {DisplayNameSender}({Sender.userID}) -> {TargetDisplayName}({TargetUser.userID}) : MESSAGE : {Message}" : $"ЛИЧНЫЕ СООБЩЕНИЯ : {DisplayNameSender}({Sender.userID}) -> {TargetDisplayName}({TargetUser.userID}) : СООБЩЕНИЕ : {Message}",
                UserId = Sender.UserIDString,
                Username = Sender.displayName,
                Channel = Chat.ChatChannel.Global,
                Time = (DateTime.UtcNow.Hour * 3600) + (DateTime.UtcNow.Minute * 60),
                Color = "#3f4bb8",
            });
            PrintWarning(LanguageEn ? $"PRIVATE MESSAGES : {DisplayNameSender}({Sender.userID}) -> {TargetDisplayName}({TargetUser.userID}) : MESSAGE : {Message}" : $"ЛИЧНЫЕ СООБЩЕНИЯ : {DisplayNameSender}({Sender.userID}) -> {TargetDisplayName}({TargetUser.userID}) : СООБЩЕНИЕ : {Message}");
        }

        [ChatCommand("r")]
        void RChat(BasePlayer Sender, string cmd, string[] arg)
        {
            Configuration.ControllerMessage ControllerMessages = config.ControllerMessages;
            if (!ControllerMessages.TurnedFunc.PMSetting.PMActivate) return;

            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(Sender, GetLang("COMMAND_R_NOTARG", Sender.UserIDString));
                return;
            }

            Configuration.ControllerMessage.TurnedFuncional.AntiNoob.Settings antiNoob = config.ControllerMessages.TurnedFunc.AntiNoobSetting.AntiNoobPM;
            if (antiNoob.AntiNoobActivate)
                if (IsNoob(Sender.userID, antiNoob.TimeBlocked))
                {
                    ReplySystem(Sender, GetLang("IQCHAT_INFO_ANTI_NOOB_PM", Sender.UserIDString, FormatTime(UserInformationConnection[Sender.userID].LeftTime(antiNoob.TimeBlocked), Sender.UserIDString)));
                    return;
                }

            if (!PMHistory.ContainsKey(Sender))
            {
                ReplySystem(Sender, GetLang("COMMAND_R_NOTMSG", Sender.UserIDString));
                return;
            }

            BasePlayer RetargetUser = PMHistory[Sender];
            if (RetargetUser == null)
            {
                ReplySystem(Sender, GetLang("COMMAND_PM_NOT_USER", Sender.UserIDString));
                return;
            }

            User InfoRetarget = UserInformation[RetargetUser.userID];
            User InfoSender = UserInformation[RetargetUser.userID];

            if(config.ControllerMutes.mutedPM)
                if (InfoSender.MuteInfo.IsMute(MuteType.Chat))
                {
                    ReplySystem(Sender, GetLang("IQCHAT_FUNCED_NO_SEND_CHAT_MUTED", Sender.UserIDString, FormatTime(InfoSender.MuteInfo.GetTime(MuteType.Chat), Sender.UserIDString)));
                    return;
                }

            if (!InfoRetarget.Settings.TurnPM)
            {
                ReplySystem(Sender, GetLang("FUNC_MESSAGE_PM_TURN_FALSE", Sender.UserIDString));
                return;
            }
            if (ControllerMessages.TurnedFunc.IgnoreUsePM)
            {
                if (InfoRetarget.Settings.IsIgnored(Sender.userID))
                {
                    ReplySystem(Sender, GetLang("IGNORE_NO_PM", Sender.UserIDString));
                    return;
                }
                if (InfoSender.Settings.IsIgnored(RetargetUser.userID))
                {
                    ReplySystem(Sender, GetLang("IGNORE_NO_PM_ME", Sender.UserIDString));
                    return;
                }
            }

            String Message = GetMessageInArgs(Sender, arg);
            if (Message == null || Message.Length <= 0)
            {
                ReplySystem(Sender, GetLang("COMMAND_PM_NOT_NULL_MSG", Sender.UserIDString));
                return;
            }
            if (Message.Length > 125) return;
            Message = Message.EscapeRichText();

            PMHistory[RetargetUser] = Sender;

            GeneralInformation.RenameInfo RenameSender = GeneralInfo.GetInfoRename(Sender.userID);
            GeneralInformation.RenameInfo RenamerTarget = GeneralInfo.GetInfoRename(RetargetUser.userID);
            String DisplayNameSender = RenameSender != null ? RenameSender.RenameNick ?? Sender.displayName : Sender.displayName;
            String TargetDisplayName = RenamerTarget != null ? RenamerTarget.RenameNick ?? RetargetUser.displayName : RetargetUser.displayName;

            if (TranslationAPI && config.ReferenceSetting.translationApiSettings.useTranslationApi && config.ReferenceSetting.translationApiSettings.translatePmChat)
                ReplyTranslationPM(Sender, RetargetUser, Message, DisplayNameSender, TargetDisplayName);
            else
            {
                ReplySystem(RetargetUser, GetLang("COMMAND_PM_SEND_MSG", RetargetUser.UserIDString, DisplayNameSender, Message));
                ReplySystem(Sender, GetLang("COMMAND_PM_SUCCESS", Sender.UserIDString, Message, TargetDisplayName));
            }
            
            if (InfoRetarget.Settings.TurnSound)
                Effect.server.Run(ControllerMessages.TurnedFunc.PMSetting.SoundPM, RetargetUser.GetNetworkPosition());

            RustApp?.Call("RA_DirectMessageHandler", Sender.UserIDString, RetargetUser.UserIDString, Message);
            
            Log(LanguageEn ? $"PRIVATE MESSAGES : {DisplayNameSender}({Sender.userID}) sent a message to the player - {TargetDisplayName}({RetargetUser.userID})\nMESSAGE : {Message}" : $"ЛИЧНЫЕ СООБЩЕНИЯ : {DisplayNameSender}({Sender.userID}) отправил сообщение игроку - {TargetDisplayName}({RetargetUser.userID})\nСООБЩЕНИЕ : {Message}");
            DiscordLoggPM(Sender, RetargetUser, Message);

            RCon.Broadcast(RCon.LogType.Chat, new Chat.ChatEntry
            {
                Message = LanguageEn ? $"PRIVATE MESSAGES : {DisplayNameSender}({Sender.userID}) -> {TargetDisplayName}({RetargetUser.userID}) : MESSAGE : {Message}" : $"ЛИЧНЫЕ СООБЩЕНИЯ : {DisplayNameSender}({Sender.userID}) -> {TargetDisplayName}({RetargetUser.userID}) : СООБЩЕНИЕ : {Message}",
                UserId = Sender.UserIDString,
                Username = Sender.displayName,
                Channel = Chat.ChatChannel.Global,
                Time = (DateTime.UtcNow.Hour * 3600) + (DateTime.UtcNow.Minute * 60),
                Color = "#3f4bb8",
            });
            PrintWarning(LanguageEn ? $"PRIVATE MESSAGES : {DisplayNameSender}({Sender.userID}) -> {TargetDisplayName}({RetargetUser.userID}) : MESSAGE : {Message}" : $"ЛИЧНЫЕ СООБЩЕНИЯ : {DisplayNameSender}({Sender.userID}) -> {TargetDisplayName}({RetargetUser.userID}) : СООБЩЕНИЕ : {Message}");
        }

        [ChatCommand("ignore")]
        void IgnorePlayerPM(BasePlayer player, String cmd, String[] arg)
        {
            Configuration.ControllerMessage ControllerMessages = config.ControllerMessages;
            if (!ControllerMessages.TurnedFunc.IgnoreUsePM) return;

            User Info = UserInformation[player.userID];

            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(player, GetLang("INGORE_NOTARG", player.UserIDString));
                return;
            }
            String NameUser = arg[0];
            
            if (IsFakeUser(NameUser))
            {
                var playerList = GetCombinedPlayerList();
                if (playerList != null)
                {
                    var fakeUser = playerList.FirstOrDefault(x => x.displayName.Contains(NameUser));
                    if (fakeUser != null)
                    {
                        if (UInt64.TryParse(fakeUser.userId, out UInt64 userIDFake))
                        {
                            String LangFake = !Info.Settings.IsIgnored(userIDFake)
                                ? GetLang("IGNORE_ON_PLAYER", player.UserIDString, fakeUser.displayName)
                                : GetLang("IGNORE_OFF_PLAYER", player.UserIDString, fakeUser.displayName);
                            ReplySystem(player, LangFake);

                            Info.Settings.IgnoredAddOrRemove(userIDFake);
                        }
                    }
                }
                return;
            }
            
            BasePlayer TargetUser = BasePlayer.Find(NameUser);

            if (TargetUser == null || NameUser == null)
            {
                ReplySystem(player, GetLang("COMMAND_PM_NOT_USER", player.UserIDString));
                return;
            }

            String Lang = !Info.Settings.IsIgnored(TargetUser.userID) ? GetLang("IGNORE_ON_PLAYER", player.UserIDString, TargetUser.displayName) : GetLang("IGNORE_OFF_PLAYER", player.UserIDString, TargetUser.displayName);
            ReplySystem(player, Lang);

            Info.Settings.IgnoredAddOrRemove(TargetUser.userID);
        }

        #endregion

        private Boolean HasInvalidHexColor(List<String> colorList, out String invalidHex)
        {
            foreach (String color in colorList)
            {
                if (!IsValidHexColor(color))
                {
                    invalidHex = color;
                    return true;
                }
            }
            
            invalidHex = String.Empty;
            return false; 
        }
        
        private Boolean IsValidHexColor(String color)
        {
            const String pattern = @"^#(?:[0-9a-fA-F]{3}){1,2}$";
            return Regex.IsMatch(color, pattern);
        }
        private String JoinStringList(List<String> inputList) => String.Join(", ", inputList);
        private List<String> ConvertStringToList(String input)
        {
            String pattern = @"[,\.\;\:\s]+";
        
            return Regex.Split(input, pattern) 
                .Select(item => item.Trim()) 
                .Where(item => !string.IsNullOrEmpty(item))
                .Take(10)
                .ToList();
        }
        private BasePlayer GetPlayerNickOrID(String Info)
        {
            String NameOrID = String.Empty;

            KeyValuePair<UInt64, GeneralInformation.RenameInfo> RenameInformation = GeneralInfo.RenameList.FirstOrDefault(x => x.Value.RenameNick.Contains(Info) || x.Value.RenameID.ToString() == Info);
            if (RenameInformation.Value == null)
                NameOrID = Info;
            else NameOrID = RenameInformation.Key.ToString();

            foreach (BasePlayer Finder in BasePlayer.activePlayerList)
            {
                if (Finder.displayName.ToLower().Contains(NameOrID.ToLower()) || Finder.userID.ToString() == NameOrID)
                    return Finder;
            }

            return null;
        }

        #endregion

        #endregion

        #region Lang
        private new void LoadDefaultMessages()
        {
            PrintWarning(LanguageEn ? "Language file is loading..." : "Языковой файл загружается...");
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["FUNC_MESSAGE_MUTE_CHAT"] = "{0} muted {1}\nDuration : {2}\nReason : {3}",
                ["FUNC_MESSAGE_UNMUTE_CHAT"] = "{0} unmuted {1}",
                ["FUNC_MESSAGE_MUTE_VOICE"] = "{0} muted voice to {1}\nDuration : {2}\nReason : {3}",
                ["FUNC_MESSAGE_UNMUTE_VOICE"] = "{0} unmuted voice to {1}",
                ["FUNC_MESSAGE_UNMUTE_YOURSELF"] = "You can't unlock the chat by yourself",
                ["FUNC_MESSAGE_MUTE_ALL_CHAT"] = "Chat disabled",
                ["FUNC_MESSAGE_UNMUTE_ALL_CHAT"] = "Chat enabled",
                ["FUNC_MESSAGE_MUTE_ALL_VOICE"] = "Voice chat disabled",
                ["FUNC_MESSAGE_UNMUTE_ALL_VOICE"] = "Voice chat enabled",
                ["FUNC_MESSAGE_MUTE_ALL_ALERT"] = "Blocking by Administrator",
                ["FUNC_MESSAGE_PM_TURN_FALSE"] = "The player has forbidden to send himself private messages",
                ["FUNC_MESSAGE_ALERT_TURN_FALSE"] = "The player has not been allowed to notify himself",

                ["FUNC_MESSAGE_NO_ARG_BROADCAST"] = "You can not send an empty broadcast message!",

                ["UI_ALERT_TITLE"] = "<size=14><b>Notification</b></size>",

                ["COMMAND_NOT_PERMISSION"] = "You dont have permissions to use this command",
                ["COMMAND_RENAME_NOTARG"] = "For rename use : /rename [NewNickname] [NewID (Optional)]",
                ["COMMAND_RENAME_NOT_ID"] = "Incorrect ID for renaming! Use Steam64ID or leave blank",
                ["COMMAND_RENAME_SUCCES"] = "You have successfully changed your nickname!\nyour nickname : {0}\nYour ID : {1}",
                ["COMMAND_RENAME_RESET_SUCCES"] = "You have successfully reset your nickname changes, all data is reset to zero",
                ["COMMAND_RENAME_PROCESS_STEAM"] = "Requesting data from Steam, it may take some time",
                ["COMMAND_RENAME_NOTHING"] = "Your nickname has not changed",

                ["COMMAND_PM_NOTARG"] = "To send pm use : /pm Nickname Message",
                ["COMMAND_PM_NOT_NULL_MSG"] = "Message is empty!",
                ["COMMAND_PM_NOT_USER"] = "User not found or offline",
                ["COMMAND_PM_SUCCESS"] = "Your private message sent successful\n\nMessage : {0}\n\nDelivered : {1}",
                ["COMMAND_PM_SEND_MSG"] = "Message from {0}\n\n{1}",
                
                ["COMMAND_COLOR_CUSTOM_MAX_ARGUMENTS"] = "You specified more than 10 colors for setting the color, the first 10 colors were taken",
                ["COMMAND_COLOR_CUSTOM_NOT_ARG"] = "You need to specify colors in HEX format",
                ["COMMAND_COLOR_CUSTOM_NOT_HEX"] = "You incorrectly specified this color: {0}",
                ["COMMAND_COLOR_CUSTOM_ACCESS"] = "You have successfully set the color",

                ["COMMAND_R_NOTARG"] = "For reply use : /r Message",
                ["COMMAND_R_NOTMSG"] = "You dont have any private conversations yet!",

                ["FLOODERS_MESSAGE"] = "You're typing too fast! Please Wait {0} seconds",

                ["PREFIX_SETUP"] = "You have successfully removed the prefix {0}, it is already activated and installed",
                ["COLOR_CHAT_SETUP"] = "You have successfully picked up the {0}, it is already activated and installed",
                ["COLOR_CHAT_SETUP_TITLE"] = "chat color",
                ["COLOR_NICK_SETUP"] = "You have successfully taken the {0}, it is already activated and installed",
                ["COLOR_NICK_SETUP_TITLE"] = "nickname color",

                ["PREFIX_RETURNRED"] = "Your prefix {0} expired, it was reset automatically",
                ["COLOR_CHAT_RETURNRED"] = "Action of your {0} over, it is reset automatically",
                ["COLOR_NICK_RETURNRED"] = "Action of your {0} over, it is reset automatically",
                ["COLOR_NICK_RETURNRED_TITLE"] = "color nick",
                ["COLOR_CHAT_RETURNRED_TITLE"] = "color chat",
                ["WELCOME_PLAYER"] = "{0} came online",
                ["LEAVE_PLAYER"] = "{0} left",
                ["WELCOME_PLAYER_WORLD"] = "{0} came online. Country: {1}",
                ["LEAVE_PLAYER_REASON"] = "{0} left. Reason: {1}",

                ["IGNORE_ON_PLAYER"] = "You added {0} in black list",
                ["IGNORE_OFF_PLAYER"] = "You removed {0} from black list",
                ["IGNORE_NO_PM"] = "This player added you in black list. Your message has not been delivered.",
                ["IGNORE_NO_PM_ME"] = "You added this player in black list. Your message has not been delivered.",
                ["INGORE_NOTARG"] = "To ignore a player use : /ignore nickname",

                ["DISCORD_SEND_LOG_CHAT"] = "Player : {0}({1})\nFiltred message : {2}\nMessage : {3}",
                ["DISCORD_SEND_LOG_MUTE"] = "{0}({1}) give mute chat\nSuspect : {2}({3})\nReason : {4}",

                ["TITLE_FORMAT_DAYS"] = "D",
                ["TITLE_FORMAT_HOURSE"] = "H",
                ["TITLE_FORMAT_MINUTES"] = "M",
                ["TITLE_FORMAT_SECONDS"] = "S",

                ["IQCHAT_CONTEXT_TITLE"] = "SETTING UP A CHAT", ///"%TITLE%"
                ["IQCHAT_CONTEXT_SETTING_ELEMENT_TITLE"] = "CUSTOM SETTING", ///"%SETTING_ELEMENT%"
                ["IQCHAT_CONTEXT_INFORMATION_TITLE"] = "INFORMATION", ///"%INFORMATION%"
                ["IQCHAT_CONTEXT_SETTINGS_TITLE"] = "SETTINGS", ///"%SETTINGS%"
                ["IQCHAT_CONTEXT_SETTINGS_PM_TITLE"] = "Private messages", ///"%SETTINGS_PM%"
                ["IQCHAT_CONTEXT_SETTINGS_ALERT_TITLE"] = "Notification in the chat", ///"%SETTINGS_ALERT%"
                ["IQCHAT_CONTEXT_SETTINGS_ALERT_PM_TITLE"] = "Mention in the chat", ///"%SETTINGS_ALERT_PM%"
                ["IQCHAT_CONTEXT_SETTINGS_SOUNDS_TITLE"] = "Sound notification", ///"%SETTINGS_SOUNDS%"
                ["IQCHAT_CONTEXT_MUTE_STATUS_NOT"] = "NO", ///"%MUTE_STATUS_PLAYER%"
                ["IQCHAT_CONTEXT_MUTE_STATUS_TITLE"] = "Blocking the chat", ///"%MUTE_STATUS_TITLE%"
                ["IQCHAT_CONTEXT_IGNORED_STATUS_COUNT"] = "<size=11>{0}</size> human (а)", ///"%IGNORED_STATUS_COUNT%"
                ["IQCHAT_CONTEXT_IGNORED_STATUS_TITLE"] = "Ignoring", ///"%IGNORED_STATUS_TITLE%"
                ["IQCHAT_CONTEXT_NICK_DISPLAY_TITLE"] = "Your nickname", ///"%NICK_DISPLAY_TITLE%"
                ["IQCHAT_CONTEXT_NICK_DISPLAY_MESSAGE"] = "i love iqchat",
                ["IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE"] = "Prefix", /// %SLIDER_PREFIX_TITLE%
                ["IQCHAT_CONTEXT_SLIDER_NICK_COLOR_TITLE"] = "Nick", /// %SLIDER_NICK_COLOR_TITLE%
                ["IQCHAT_CONTEXT_SLIDER_MESSAGE_COLOR_TITLE"] = "Message", /// %SLIDER_MESSAGE_COLOR_TITLE%
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE"] = "Rank",
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_NULLER"] = "Absent",
                ["IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE_DESCRIPTION"] = "Choosing a prefix", /// 
                ["IQCHAT_CONTEXT_SLIDER_CHAT_NICK_TITLE_DESCRIPTION"] = "Choosing a nickname color", /// 
                ["IQCHAT_CONTEXT_SLIDER_CHAT_MESSAGE_TITLE_DESCRIPTION"] = "Chat Color Selection", /// 
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_DESCRIPTION"] = "Rank Selection", /// 
                ["IQCHAT_CONTEXT_DESCRIPTION_PREFIX"] = "Prefix Setting",
                ["IQCHAT_CONTEXT_DESCRIPTION_NICK"] = "Setting up a nickname",
                ["IQCHAT_CONTEXT_DESCRIPTION_CHAT"] = "Setting up a message",
                ["IQCHAT_CONTEXT_DESCRIPTION_RANK"] = "Setting up the rank",

                ["IQCHAT_ALERT_TITLE"] = "ALERT", /// %TITLE_ALERT%

                ["IQCHAT_TITLE_IGNORE_AND_MUTE_MUTED"] = "LOCK MANAGEMENT",
                ["IQCHAT_TITLE_IGNORE_AND_MUTE_IGNORED"] = "IGNORING MANAGEMENT",
                ["IQCHAT_TITLE_IGNORE_TITLES"] = "<b>DO YOU REALLY WANT TO IGNORE\n{0}?</b>",
                ["IQCHAT_TITLE_IGNORE_TITLES_UNLOCK"] = "<b>DO YOU WANT TO REMOVE THE IGNORING FROM THE PLAYER\n{0}?</b>",
                ["IQCHAT_TITLE_IGNORE_BUTTON_YES"] = "<b>YES, I WANT TO</b>",
                ["IQCHAT_TITLE_IGNORE_BUTTON_NO"] = "<b>NO, I CHANGED MY MIND</b>",
                ["IQCHAT_TITLE_MODERATION_PANEL"] = "MODERATOR PANEL",

                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU"] = "Lock Management",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT"] = "SELECT AN ACTION",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_REASON"] = "SELECT THE REASON FOR BLOCKING",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_CHAT"] = "Block chat",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_VOICE"] = "Block voice",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_CHAT"] = "Unblock chat",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_VOICE"] = "Unlock voice",
                ["IQCHAT_BUTTON_MODERATION_MUTE_ALL_CHAT"] = "Block all chat",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_CHAT"] = "Unblock all chat",
                ["IQCHAT_BUTTON_MODERATION_MUTE_ALL_VOICE"] = "Block everyone's voice",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_VOICE"] = "Unlock everyone's voice",

                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED"] = "You have an active chat lock : {0}",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_CHAT"] = "The administrator blocked everyone's chat. Expect full unblocking",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_VOICE"] = "The administrator blocked everyone's voice chat. Expect full unblocking",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_UMMUTED_ALL_VOICE"] = "The administrator has unblocked the voice chat for everyone",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_UNMUTED_ALL_CHAT"] = "The administrator has unblocked the chat for everyone",

                ["IQCHAT_FUNCED_ALERT_TITLE"] = "<color=#a7f64f><b>[MENTION FROM {0}]</b></color>",
                ["IQCHAT_FUNCED_ALERT_TITLE_ISMUTED"] = "The player has already been muted!",
                ["IQCHAT_FUNCED_ALERT_TITLE_SERVER"] = "Administrator",

                ["IQCHAT_INFO_ONLINE"] = "Now on the server :\n{0}",

                ["IQCHAT_INFO_ANTI_NOOB"] = "You first connected to the server!\nPlay some more {0}\nTo get access to send messages to the global and team chat!",
                ["IQCHAT_INFO_ANTI_NOOB_PM"] = "You first connected to the server!\nPlay some more {0}\nTo access sending messages to private messages!",

                ["SKILLTREE_SYNTAX_PRESTIGE_LEVEL"] = "[{0} prestige]",
                ["SKILLTREE_SYNTAX_LEVEL"] = "[{0} Level]",
                ["SKILLTREE_SYNTAX_XP"] = "[{0} XP]",
                ["XLEVELS_SYNTAX_PREFIX"] = "[{0} Level]",
                ["CLANS_SYNTAX_PREFIX"] = "[{0}]",
                ["XPRISON_SYNTAX_PREFIX"] = "<color=orange>[{0}]</color>",

            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["FUNC_MESSAGE_MUTE_CHAT"] = "{0} заблокировал чат игроку {1}\nДлительность : {2}\nПричина : {3}",
                ["FUNC_MESSAGE_UNMUTE_CHAT"] = "{0} разблокировал чат игроку {1}",
                ["FUNC_MESSAGE_MUTE_VOICE"] = "{0} заблокировал голос игроку {1}\nДлительность : {2}\nПричина : {3}",
                ["FUNC_MESSAGE_UNMUTE_VOICE"] = "{0} разблокировал голос игроку {1}",
                ["FUNC_MESSAGE_UNMUTE_YOURSELF"] = "Вы не можете снять блокировку чата сами с себя",
                ["FUNC_MESSAGE_MUTE_ALL_CHAT"] = "Всем игрокам был заблокирован чат",
                ["FUNC_MESSAGE_UNMUTE_ALL_CHAT"] = "Всем игрокам был разблокирован чат",
                ["FUNC_MESSAGE_MUTE_ALL_VOICE"] = "Всем игрокам был заблокирован голос",
                ["FUNC_MESSAGE_MUTE_ALL_ALERT"] = "Блокировка Администратором",
                ["FUNC_MESSAGE_UNMUTE_ALL_VOICE"] = "Всем игрокам был разблокирован голос",

                ["FUNC_MESSAGE_PM_TURN_FALSE"] = "Игрок запретил присылать себе личные сообщения",
                ["FUNC_MESSAGE_ALERT_TURN_FALSE"] = "Игрок запретил уведомлять себя",

                ["FUNC_MESSAGE_NO_ARG_BROADCAST"] = "Вы не можете отправлять пустое сообщение в оповещение!",

                ["UI_ALERT_TITLE"] = "<size=14><b>Уведомление</b></size>",

                ["COMMAND_NOT_PERMISSION"] = "У вас недостаточно прав для данной команды",
                ["COMMAND_RENAME_NOTARG"] = "Используйте команду так : /rename [НовыйНик] [НовыйID (По желанию)]",
                ["COMMAND_RENAME_NOT_ID"] = "Неверно указан ID для переименования! Используйте Steam64ID, либо оставьте поле пустым",
                ["COMMAND_RENAME_SUCCES"] = "Вы успешно изменили ник!\nВаш ник : {0}\nВаш ID : {1}",
                ["COMMAND_RENAME_RESET_SUCCES"] = "Вы успешно сбросили изменения ника, все данные обнулены",
                ["COMMAND_RENAME_PROCESS_STEAM"] = "Запрашиваем данные у Steam, это может занять некоторое время",
                ["COMMAND_RENAME_NOTHING"] = "Ваш ник не изменялся",

                ["COMMAND_PM_NOTARG"] = "Используйте команду так : /pm Ник Игрока Сообщение",
                ["COMMAND_PM_NOT_NULL_MSG"] = "Вы не можете отправлять пустое сообщение",
                ["COMMAND_PM_NOT_USER"] = "Игрок не найден или не в сети",
                ["COMMAND_PM_SUCCESS"] = "Ваше сообщение успешно доставлено\n\nСообщение : {0}\n\nДоставлено : {1}",
                ["COMMAND_PM_SEND_MSG"] = "Сообщение от {0}\n\n{1}",

                ["COMMAND_COLOR_CUSTOM_MAX_ARGUMENTS"] = "Вы указали больше 10 цветов для установки цвета, были взяты первые 10 цветов",
                ["COMMAND_COLOR_CUSTOM_NOT_ARG"] = "Вам нужно указать цвета в формате HEX",
                ["COMMAND_COLOR_CUSTOM_NOT_HEX"] = "Вы некорректно указали данный цвет : {0}",
                ["COMMAND_COLOR_CUSTOM_ACCESS"] = "Вы успешно установили цвет",
                
                ["COMMAND_R_NOTARG"] = "Используйте команду так : /r Сообщение",
                ["COMMAND_R_NOTMSG"] = "Вам или вы ещё не писали игроку в личные сообщения!",

                ["FLOODERS_MESSAGE"] = "Вы пишите слишком быстро! Подождите {0} секунд",

                ["PREFIX_SETUP"] = "Вы успешно забрали префикс {0}, он уже активирован и установлен",
                ["COLOR_CHAT_SETUP"] = "Вы успешно забрали {0}, он уже активирован и установлен",
                ["COLOR_CHAT_SETUP_TITLE"] = "цвет чата",
                ["COLOR_NICK_SETUP"] = "Вы успешно забрали {0}, он уже активирован и установлен",
                ["COLOR_NICK_SETUP_TITLE"] = "цвет ника",

                ["PREFIX_RETURNRED"] = "Действие вашего префикса {0} окончено, он сброшен автоматически",
                ["COLOR_CHAT_RETURNRED"] = "Действие вашего {0} окончено, он сброшен автоматически",
                ["COLOR_CHAT_RETURNRED_TITLE"] = "цвета чата",
                ["COLOR_NICK_RETURNRED"] = "Действие вашего {0} окончено, он сброшен автоматически",
                ["COLOR_NICK_RETURNRED_TITLE"] = "цвета ника",

                ["WELCOME_PLAYER"] = "{0} зашел на сервер",
                ["LEAVE_PLAYER"] = "{0} вышел с сервера",
                ["WELCOME_PLAYER_WORLD"] = "{0} зашел на сервер.Из {1}",
                ["LEAVE_PLAYER_REASON"] = "{0} вышел с сервера.Причина {1}",

                ["IGNORE_ON_PLAYER"] = "Вы добавили игрока {0} в черный список",
                ["IGNORE_OFF_PLAYER"] = "Вы убрали игрока {0} из черного списка",
                ["IGNORE_NO_PM"] = "Данный игрок добавил вас в ЧС,ваше сообщение не будет доставлено",
                ["IGNORE_NO_PM_ME"] = "Вы добавили данного игрока в ЧС,ваше сообщение не будет доставлено",
                ["INGORE_NOTARG"] = "Используйте команду так : /ignore Ник Игрока",

                ["DISCORD_SEND_LOG_CHAT"] = "Игрок : {0}({1})\nФильтрованное сообщение : {2}\nИзначальное сообщение : {3}",
                ["DISCORD_SEND_LOG_MUTE"] = "{0}({1}) выдал блокировку чата\nИгрок : {2}({3})\nПричина : {4}",

                ["TITLE_FORMAT_DAYS"] = "Д",
                ["TITLE_FORMAT_HOURSE"] = "Ч",
                ["TITLE_FORMAT_MINUTES"] = "М",
                ["TITLE_FORMAT_SECONDS"] = "С",

                ["IQCHAT_CONTEXT_TITLE"] = "НАСТРОЙКА ЧАТА", ///"%TITLE%"
                ["IQCHAT_CONTEXT_SETTING_ELEMENT_TITLE"] = "ПОЛЬЗОВАТЕЛЬСКАЯ НАСТРОЙКА", ///"%SETTING_ELEMENT%"
                ["IQCHAT_CONTEXT_INFORMATION_TITLE"] = "ИНФОРМАЦИЯ", ///"%INFORMATION%"
                ["IQCHAT_CONTEXT_SETTINGS_TITLE"] = "НАСТРОЙКИ", ///"%SETTINGS%"
                ["IQCHAT_CONTEXT_SETTINGS_PM_TITLE"] = "Личные сообщения", ///"%SETTINGS_PM%"
                ["IQCHAT_CONTEXT_SETTINGS_ALERT_TITLE"] = "Оповещение в чате", ///"%SETTINGS_ALERT%"
                ["IQCHAT_CONTEXT_SETTINGS_ALERT_PM_TITLE"] = "Упоминание в чате", ///"%SETTINGS_ALERT_PM%"
                ["IQCHAT_CONTEXT_SETTINGS_SOUNDS_TITLE"] = "Звуковое оповещение", ///"%SETTINGS_SOUNDS%"
                ["IQCHAT_CONTEXT_MUTE_STATUS_NOT"] = "НЕТ", ///"%MUTE_STATUS_PLAYER%"
                ["IQCHAT_CONTEXT_MUTE_STATUS_TITLE"] = "Блокировка чата", ///"%MUTE_STATUS_TITLE%"
                ["IQCHAT_CONTEXT_IGNORED_STATUS_COUNT"] = "<size=11>{0}</size> человек (а)", ///"%IGNORED_STATUS_COUNT%"
                ["IQCHAT_CONTEXT_IGNORED_STATUS_TITLE"] = "Игнорирование", ///"%IGNORED_STATUS_TITLE%"
                ["IQCHAT_CONTEXT_NICK_DISPLAY_TITLE"] = "Ваш ник", ///"%NICK_DISPLAY_TITLE%"
                ["IQCHAT_CONTEXT_NICK_DISPLAY_MESSAGE"] = "люблю iqchat",
                ["IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE"] = "Префикс", /// %SLIDER_PREFIX_TITLE%
                ["IQCHAT_CONTEXT_SLIDER_NICK_COLOR_TITLE"] = "Ник", /// %SLIDER_NICK_COLOR_TITLE%
                ["IQCHAT_CONTEXT_SLIDER_MESSAGE_COLOR_TITLE"] = "Чат", /// %SLIDER_MESSAGE_COLOR_TITLE%
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE"] = "Ранг",
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_NULLER"] = "Отсутствует",
                ["IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE_DESCRIPTION"] = "Выбор префикса", /// 
                ["IQCHAT_CONTEXT_SLIDER_CHAT_NICK_TITLE_DESCRIPTION"] = "Выбор цвета ника", /// 
                ["IQCHAT_CONTEXT_SLIDER_CHAT_MESSAGE_TITLE_DESCRIPTION"] = "Выбор цвета чата", /// 
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_DESCRIPTION"] = "Выбор ранга", /// 
                ["IQCHAT_CONTEXT_DESCRIPTION_PREFIX"] = "Настройка префикса",
                ["IQCHAT_CONTEXT_DESCRIPTION_NICK"] = "Настройка ника",
                ["IQCHAT_CONTEXT_DESCRIPTION_CHAT"] = "Настройка сообщения",
                ["IQCHAT_CONTEXT_DESCRIPTION_RANK"] = "Настройка ранга",


                ["IQCHAT_ALERT_TITLE"] = "УВЕДОМЛЕНИЕ", /// %TITLE_ALERT%
                ["IQCHAT_TITLE_IGNORE_AND_MUTE_MUTED"] = "УПРАВЛЕНИЕ БЛОКИРОВКАМИ",
                ["IQCHAT_TITLE_IGNORE_AND_MUTE_IGNORED"] = "УПРАВЛЕНИЕ ИГНОРИРОВАНИЕМ",
                ["IQCHAT_TITLE_IGNORE_TITLES"] = "<b>ВЫ ДЕЙСТВИТЕЛЬНО ХОТИТЕ ИГНОРИРОВАТЬ\n{0}?</b>",
                ["IQCHAT_TITLE_IGNORE_TITLES_UNLOCK"] = "<b>ВЫ ХОТИТЕ СНЯТЬ ИГНОРИРОВАНИЕ С ИГРОКА\n{0}?</b>",
                ["IQCHAT_TITLE_IGNORE_BUTTON_YES"] = "<b>ДА, ХОЧУ</b>",
                ["IQCHAT_TITLE_IGNORE_BUTTON_NO"] = "<b>НЕТ, ПЕРЕДУМАЛ</b>",
                ["IQCHAT_TITLE_MODERATION_PANEL"] = "ПАНЕЛЬ МОДЕРАТОРА",

                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU"] = "Управление блокировками",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT"] = "ВЫБЕРИТЕ ДЕЙСТВИЕ",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_REASON"] = "ВЫБЕРИТЕ ПРИЧИНУ БЛОКИРОВКИ",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_CHAT"] = "Заблокировать чат",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_VOICE"] = "Заблокировать голос",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_CHAT"] = "Разблокировать чат",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_VOICE"] = "Разблокировать голос",
                ["IQCHAT_BUTTON_MODERATION_MUTE_ALL_CHAT"] = "Заблокировать всем чат",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_CHAT"] = "Разблокировать всем чат",
                ["IQCHAT_BUTTON_MODERATION_MUTE_ALL_VOICE"] = "Заблокировать всем голос",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_VOICE"] = "Разблокировать всем голос",

                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED"] = "У вас имеется активная блокировка чата : {0}",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_CHAT"] = "Администратор заблокировал всем чат. Ожидайте полной разблокировки",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_VOICE"] = "Администратор заблокировал всем голосоввой чат. Ожидайте полной разблокировки",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_UMMUTED_ALL_VOICE"] = "Администратор разрблокировал всем голосоввой чат",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_UNMUTED_ALL_CHAT"] = "Администратор разрблокировал всем чат",

                ["IQCHAT_FUNCED_ALERT_TITLE"] = "<color=#a7f64f><b>[УПОМИНАНИЕ ОТ {0}]</b></color>",
                ["IQCHAT_FUNCED_ALERT_TITLE_ISMUTED"] = "Игрок уже был замучен!",
                ["IQCHAT_FUNCED_ALERT_TITLE_SERVER"] = "Администратор",

                ["IQCHAT_INFO_ONLINE"] = "Сейчас на сервере :\n{0}",

                ["IQCHAT_INFO_ANTI_NOOB"] = "Вы впервые подключились на сервер!\nОтыграйте еще {0}\nЧтобы получить доступ к отправке сообщений в глобальный и командный чат!",
                ["IQCHAT_INFO_ANTI_NOOB_PM"] = "Вы впервые подключились на сервер!\nОтыграйте еще {0}\nЧтобы получить доступ к отправке сообщений в личные сообщения!",

                ["SKILLTREE_SYNTAX_LEVEL"] = "[{0} Level]",
                ["SKILLTREE_SYNTAX_PRESTIGE_LEVEL"] = "[{0} престиж]",
                ["SKILLTREE_SYNTAX_XP"] = "[{0} XP]",
                ["XLEVELS_SYNTAX_PREFIX"] = "[{0} Level]",
                ["CLANS_SYNTAX_PREFIX"] = "[{0}]",
                ["XPRISON_SYNTAX_PREFIX"] = "<color=orange>[{0}]</color>",

            }, this, "ru");

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["FUNC_MESSAGE_MUTE_CHAT"] = "{0} silenciado {1}\n Duración: {2}\nRazón: {3}",
                ["FUNC_MESSAGE_UNMUTE_CHAT"] = "{0} sin silenciar {1}",
                ["FUNC_MESSAGE_MUTE_VOICE"] = "{0} voz apagada a {1}\n Duracion : {2}\n Razon : {3}",
                ["FUNC_MESSAGE_UNMUTE_VOICE"] = "{0} voz no silenciada a {1}",
                ["FUNC_MESSAGE_UNMUTE_YOURSELF"] = "No puedes desbloquear el chat por ti mismo",
                ["FUNC_MESSAGE_MUTE_ALL_CHAT"] = "Chat desactivado",
                ["FUNC_MESSAGE_UNMUTE_ALL_CHAT"] = "Chat habilitado",
                ["FUNC_MESSAGE_MUTE_ALL_VOICE"] = "Chat de voz desactivado",
                ["FUNC_MESSAGE_UNMUTE_ALL_VOICE"] = "Chat de voz habilitado",
                ["FUNC_MESSAGE_MUTE_ALL_ALERT"] = "Bloqueo por parte del administrador",
                ["FUNC_MESSAGE_PM_TURN_FALSE"] = "El jugador tiene prohibido enviarse mensajes privados",
                ["FUNC_MESSAGE_ALERT_TURN_FALSE"] = "El jugador no ha podido notificarse a sí mismo",
                ["FUNC_MESSAGE_NO_ARG_BROADCAST"] = "No se puede enviar un mensaje vacío.",
                ["UI_ALERT_TITLE"] = "<size=14><b>Notificación</b></size>",
                ["COMMAND_NOT_PERMISSION"] = "No tienes permisos para usar este comando",
                ["COMMAND_RENAME_NOTARG"] = "Para renombrar utilice : /rename [NewNickname] [NewID (Optional)]",
                ["COMMAND_RENAME_NOT_ID"] = "¡ID incorrecto para renombrar! Utilice Steam64ID o déjelo en blanco",
                ["COMMAND_RENAME_SUCCES"] = "Has cambiado con éxito tu nombre de usuario. \n Tu nombre de usuario: {0}. \nTu ID: {1}.",
                ["COMMAND_RENAME_RESET_SUCCES"] = "Has restablecido con éxito los cambios de Nick, todos los datos están a cero",
                ["COMMAND_RENAME_PROCESS_STEAM"] = "Solicitamos datos a Steam, esto puede llevar algún tiempo",
                ["COMMAND_RENAME_NOTHING"] = "Su apodo no ha cambiado",
                ["COMMAND_PM_NOTARG"] = "Para enviar pm utilice : /pm [Nombre] [Mensaje]",
                ["COMMAND_PM_NOT_NULL_MSG"] = "¡El mensaje está vacío!",
                ["COMMAND_PM_NOT_USER"] = "Usuario no encontrado o desconectado",
                ["COMMAND_PM_SUCCESS"] = "Su mensaje privado enviado con éxito \n Mensage : {0}\n : Entregado{1}",
                ["COMMAND_PM_SEND_MSG"] = "Mensaje de {0}\n{1}",
                ["COMMAND_COLOR_CUSTOM_MAX_ARGUMENTS"] = "Has especificado más de 10 colores para configurar el color, se han tomado los primeros 10 colores",
                ["COMMAND_COLOR_CUSTOM_NOT_ARG"] = "Necesitas especificar colores en formato HEX",
                ["COMMAND_COLOR_CUSTOM_NOT_HEX"] = "Has especificado incorrectamente este color: {0}",
                ["COMMAND_COLOR_CUSTOM_ACCESS"] = "Has establecido el color con éxito",
                ["COMMAND_R_NOTARG"] = "Para responder utilice : /r Mensaje",
                ["COMMAND_R_NOTMSG"] = "Todavía no tienes ninguna conversación privada.",
                ["FLOODERS_MESSAGE"] = "¡Estás escribiendo demasiado rápido! Por favor, espere {0} segundos",
                ["PREFIX_SETUP"] = "Has eliminado con éxito el prefijo {0}.",
                ["COLOR_CHAT_SETUP"] = "Has obtenido un nuevo color en el chat",
                ["COLOR_CHAT_SETUP_TITLE"] = "chat color",
                ["COLOR_NICK_SETUP"] = "Has cambiado tu nick correctamente del chat",
                ["COLOR_NICK_SETUP_TITLE"] = "nick color",
                ["PREFIX_RETURNRED"] = "Su prefijo {0} ha caducado, se ha restablecido automáticamente",
                ["COLOR_CHAT_RETURNRED"] = "Acción de su {0} más, se restablece automáticamente",
                ["COLOR_NICK_RETURNRED"] = "Acción de su {0} sobre, se restablece automáticamente",
                ["COLOR_NICK_RETURNRED_TITLE"] = "color nick",
                ["COLOR_CHAT_RETURNRED_TITLE"] = "color chat",
                ["WELCOME_PLAYER"] = "{0} Se ha conectado",
                ["LEAVE_PLAYER"] = "{0} izquierda",
                ["WELCOME_PLAYER_WORLD"] = "{0} Se ha conectado del Pais: {1}",
                ["LEAVE_PLAYER_REASON"] = "{0} Se ha desconectado. Razon: {1}",
                ["IGNORE_ON_PLAYER"] = "Has añadido {0} en la lista negra",
                ["IGNORE_OFF_PLAYER"] = "Has eliminado el jugador {0} de la lista negra",
                ["IGNORE_NO_PM"] = "Este jugador te ha añadido a la lista negra. Su mensaje no ha sido entregado.",
                ["IGNORE_NO_PM_ME"] = "Has añadido a este jugador en la lista negra. Su mensaje no ha sido entregado.",
                ["INGORE_NOTARG"] = "Para ignorar a un jugador utiliza : /ignore nickname",
                ["DISCORD_SEND_LOG_CHAT"] = "JUgador : {0}({1})\nMensaje filtrado : {2}\nMensages : {3}",
                ["DISCORD_SEND_LOG_MUTE"] = "{0}({1}) give mute chat\nSuspect : {2}({3})\nReason : {4}",
                ["TITLE_FORMAT_DAYS"] = "D",
                ["TITLE_FORMAT_HOURSE"] = "H",
                ["TITLE_FORMAT_MINUTES"] = "M",
                ["TITLE_FORMAT_SECONDS"] = "S",
                ["IQCHAT_CONTEXT_TITLE"] = "ESTABLECER UN CHAT",
                ["IQCHAT_CONTEXT_SETTING_ELEMENT_TITLE"] = "AJUSTE PERSONALIZADO",
                ["IQCHAT_CONTEXT_INFORMATION_TITLE"] = "INFORMACIÓN",
                ["IQCHAT_CONTEXT_SETTINGS_TITLE"] = "AJUSTES",
                ["IQCHAT_CONTEXT_SETTINGS_PM_TITLE"] = "Mensajes privados",
                ["IQCHAT_CONTEXT_SETTINGS_ALERT_TITLE"] = "Notificación en el chat",
                ["IQCHAT_CONTEXT_SETTINGS_ALERT_PM_TITLE"] = "Mención en el chat",
                ["IQCHAT_CONTEXT_SETTINGS_SOUNDS_TITLE"] = "Notificación sonora",
                ["IQCHAT_CONTEXT_MUTE_STATUS_NOT"] = "NO",
                ["IQCHAT_CONTEXT_MUTE_STATUS_TITLE"] = "Bloqueo del chat",
                ["IQCHAT_CONTEXT_IGNORED_STATUS_COUNT"] = "<size=11>{0}</size> humano (а)",
                ["IQCHAT_CONTEXT_IGNORED_STATUS_TITLE"] = "Ignorando",
                ["IQCHAT_CONTEXT_NICK_DISPLAY_TITLE"] = "Su apodo",
                ["IQCHAT_CONTEXT_NICK_DISPLAY_MESSAGE"] = "Me encanta Zoxiland",
                ["IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE"] = "Prefijo",
                ["IQCHAT_CONTEXT_SLIDER_NICK_COLOR_TITLE"] = "Nick",
                ["IQCHAT_CONTEXT_SLIDER_MESSAGE_COLOR_TITLE"] = "Mensaje",
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE"] = "Rango",
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_NULLER"] = "Ausente",
                ["IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE_DESCRIPTION"] = "Elegir un prefijo",
                ["IQCHAT_CONTEXT_SLIDER_CHAT_NICK_TITLE_DESCRIPTION"] = "Elegir un color de apodo",
                ["IQCHAT_CONTEXT_SLIDER_CHAT_MESSAGE_TITLE_DESCRIPTION"] = "Selección del color del chat",
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_DESCRIPTION"] = "Selección de rangos",
                ["IQCHAT_CONTEXT_DESCRIPTION_PREFIX"] = "Ajuste del prefijo",
                ["IQCHAT_CONTEXT_DESCRIPTION_NICK"] = "Configurar un apodo",
                ["IQCHAT_CONTEXT_DESCRIPTION_CHAT"] = "Configurar un mensaje",
                ["IQCHAT_CONTEXT_DESCRIPTION_RANK"] = "Establecimiento del rango",
                ["IQCHAT_ALERT_TITLE"] = "ALERTA",
                ["IQCHAT_TITLE_IGNORE_AND_MUTE_MUTED"] = "GESTIÓN MUTEADOS",
                ["IQCHAT_TITLE_IGNORE_AND_MUTE_IGNORED"] = "GESTIÓN IGNORE",
                ["IQCHAT_TITLE_IGNORE_TITLES"] = "<b>¿REALMENTE QUIERES IGNORAR\n{0}?</b>",
                ["IQCHAT_TITLE_IGNORE_TITLES_UNLOCK"] = "<b>¿QUIERES QUITARLE AL JUGADOR LO DE IGNORAR?\n{0}?</b>",
                ["IQCHAT_TITLE_IGNORE_BUTTON_YES"] = "<b>SÍ, QUIERO</b>",
                ["IQCHAT_TITLE_IGNORE_BUTTON_NO"] = "<b>NO, HE CAMBIADO DE OPINIÓN</b>",
                ["IQCHAT_TITLE_MODERATION_PANEL"] = "PANEL DE MODERADORES",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU"] = "Menu de muteados",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT"] = "SELECCIONE UNA ACCIÓN",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_REASON"] = "SELECCIONE EL MOTIVO DEL BLOQUEO",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_CHAT"] = "Bloquear el Chat",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_VOICE"] = "Bloquear Voz",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_CHAT"] = "Desbloquear Chat",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_VOICE"] = "Desbloquear Voz",
                ["IQCHAT_BUTTON_MODERATION_MUTE_ALL_CHAT"] = "Bloquear todos los chats",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_CHAT"] = "Desbloquear todo el chat",
                ["IQCHAT_BUTTON_MODERATION_MUTE_ALL_VOICE"] = "Bloquear la voz de todos",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_VOICE"] = "Desbloquear la voz de todos",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED"] = "Tienes un bloqueo de chat activo : {0}",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_CHAT"] = "El administrador ha bloqueado el chat. Espera el desbloqueo completo",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_VOICE"] = "El administrador ha bloqueado el chat de voz. Espera el desbloqueo completo",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_UMMUTED_ALL_VOICE"] = "El administrador ha desbloqueado el chat de voz.",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_UNMUTED_ALL_CHAT"] = "El administrador ha desbloqueado el chat",
                ["IQCHAT_FUNCED_ALERT_TITLE"] = "<color=#a7f64f><b>[MENCIÓN de {0}]</b></color>",
                ["IQCHAT_FUNCED_ALERT_TITLE_ISMUTED"] = "El jugador ya ha sido silenciado.",
                ["IQCHAT_FUNCED_ALERT_TITLE_SERVER"] = "Administrador",
                ["IQCHAT_INFO_ONLINE"] = "Now on the server :\n{0}",
                ["IQCHAT_INFO_ANTI_NOOB"] = "Tienes que jugar un poco mas para poder hablar por el chat {0}.",
                ["IQCHAT_INFO_ANTI_NOOB_PM"] = "No puedes enviar un privado por que es un jugador nuevo.",
                ["SKILLTREE_SYNTAX_LEVEL"] = "[{0} Nivel]",
                ["SKILLTREE_SYNTAX_PRESTIGE_LEVEL"] = "[{0} prestige]",
                ["SKILLTREE_SYNTAX_XP"] = "[{0} XP]",
                ["XLEVELS_SYNTAX_PREFIX"] = "[{0} Nivel]",
                ["CLANS_SYNTAX_PREFIX"] = "[{0}]",
                ["XPRISON_SYNTAX_PREFIX"] = "<color=orange>[{0}]</color>",


            }, this, "es-ES");

            PrintWarning(LanguageEn ? "Language file uploaded successfully" : "Языковой файл загружен успешно");
        }

        #endregion

        #region Helpers
        
        private void Log(String LoggedMessage) => LogToFile("IQChatLogs", $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {LoggedMessage}", this);
        public String FormatTime(Double Second, String UserID = null)
        {
            TimeSpan time = TimeSpan.FromSeconds(Second);
            String Result = String.Empty;
            String Days = GetLang("TITLE_FORMAT_DAYS", UserID);
            String Hourse = GetLang("TITLE_FORMAT_HOURSE", UserID);
            String Minutes = GetLang("TITLE_FORMAT_MINUTES", UserID);
            String Seconds = GetLang("TITLE_FORMAT_SECONDS", UserID);

            if (time.Seconds != 0)
                Result = $"{Format(time.Seconds, Seconds, Seconds, Seconds)}";

            if (time.Minutes != 0)
                Result = $"{Format(time.Minutes, Minutes, Minutes, Minutes)}";

            if (time.Hours != 0)
                Result = $"{Format(time.Hours, Hourse, Hourse, Hourse)}";

            if (time.Days != 0)
                Result = $"{Format(time.Days, Days, Days, Days)}";

            return Result;
        }
        private String GetMessageInArgs(BasePlayer Sender, String[] arg)
        {
            if (arg == null || arg.Length == 0)
            {
                if (Sender != null)
                    ReplySystem(Sender, GetLang("FUNC_MESSAGE_NO_ARG_BROADCAST", Sender.UserIDString));
                else PrintWarning(GetLang("FUNC_MESSAGE_NO_ARG_BROADCAST"));
                return null;
            }
            String Message = String.Empty;
            foreach (String msg in arg)
                Message += " " + msg;

            return Message;
        }

        private String Format(Int32 units, String form1, String form2, String form3)
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                return $"{units}{form1}";

            if (tmp >= 2 && tmp <= 4)
                return $"{units}{form2}";

            return $"{units}{form3}";
        }
        #endregion

        #region API

        void API_SEND_PLAYER(BasePlayer player, String PlayerFormat, String Message, String Avatar, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            Configuration.ControllerMessage ControllerMessages = config.ControllerMessages;

            String OutMessage = Message; 

            if (ControllerMessages.Formatting.FormatMessage)
                OutMessage = $"{Message.ToLower().Substring(0, 1).ToUpper()}{Message.Remove(0, 1).ToLower()}";

            if (ControllerMessages.Formatting.UseBadWords)
                foreach (String DetectedMessage in OutMessage.Split(' '))
                    if (ControllerMessages.Formatting.BadWords.ContainsKey(DetectedMessage.ToLower()))
                        OutMessage = OutMessage.Replace(DetectedMessage, ControllerMessages.Formatting.ReplaceBadWord);
            
            player.SendConsoleCommand("chat.add", channel, ulong.Parse(Avatar), $"{PlayerFormat}: {OutMessage}");
            player.ConsoleMessage($"{PlayerFormat}: {OutMessage}");
        }
        void API_SEND_PLAYER_PM(BasePlayer player, string DisplayName, String userID, string Message)
        {
            if (!UserInformation.ContainsKey(player.userID)) return;
            if (!UInt64.TryParse(userID, out UInt64 idSender)) return;
            if (!UserInformation.ContainsKey(player.userID)) return;
            if (UserInformation[player.userID].Settings.IsIgnored(idSender)) return;
            
            ReplySystem(player, GetLang("COMMAND_PM_SEND_MSG", player.UserIDString, DisplayName, Message));

            if (UserInformation[player.userID].Settings.TurnSound)
                Effect.server.Run(config.ControllerMessages.TurnedFunc.PMSetting.SoundPM, player.GetNetworkPosition());
        }
        void API_SEND_PLAYER_CONNECTED(String DisplayName, String country, String userID) 
        {
            Configuration.ControllerAlert.PlayerSession AlertSessionPlayer = config.ControllerAlertSetting.PlayerSessionSetting;

            if (AlertSessionPlayer.ConnectedAlert)
            {
                String Avatar = AlertSessionPlayer.ConnectedAvatarUse ? userID : String.Empty;
                if (AlertSessionPlayer.ConnectedWorld)
                    ReplyBroadcast(null, Avatar, false, "WELCOME_PLAYER_WORLD", DisplayName, country);
                else ReplyBroadcast(null, Avatar, false, "WELCOME_PLAYER", DisplayName);
            }
        }
        void API_SEND_PLAYER_DISCONNECTED(String DisplayName, String reason, String userID) 
        {
            Configuration.ControllerAlert.PlayerSession AlertSessionPlayer = config.ControllerAlertSetting.PlayerSessionSetting;

            if (AlertSessionPlayer.DisconnectedAlert)
            {
                String Avatar = AlertSessionPlayer.ConnectedAvatarUse ? userID : String.Empty;

                System.Object[] args = AlertSessionPlayer.DisconnectedReason ? new System.Object[] { DisplayName, reason } : new System.Object[] { DisplayName };
                String Lang = AlertSessionPlayer.DisconnectedReason ? "LEAVE_PLAYER_REASON" : "LEAVE_PLAYER";
                ReplyBroadcast(null, Avatar, false, Lang, args);
            }
        }
        void API_ALERT(String Message, Chat.ChatChannel channel = Chat.ChatChannel.Global, String CustomPrefix = null, String CustomAvatar = null, String CustomHex = null)
        {
            foreach (BasePlayer p in BasePlayer.activePlayerList)
                ReplySystem(p, Message, CustomPrefix, CustomAvatar, CustomHex);
        }
        void API_ALERT_PLAYER(BasePlayer player, String Message, String CustomPrefix = null, String CustomAvatar = null, String CustomHex = null) => ReplySystem(player, Message, CustomPrefix, CustomAvatar, CustomHex);
        void API_ALERT_PLAYER_UI(BasePlayer player, String Message) => DrawUI_IQChat_Alert(player, Message);
        Boolean API_CHECK_MUTE_CHAT(BasePlayer.EncryptedValue<UInt64> ID) => API_CHECK_MUTE_CHAT(ID.Get());
        Boolean API_CHECK_MUTE_CHAT(UInt64 ID)
        {
            if (!UserInformation.ContainsKey(ID)) return false;
            return UserInformation[ID].MuteInfo.IsMute(MuteType.Chat);
        }

        Boolean API_CHECK_VOICE_CHAT(BasePlayer.EncryptedValue<UInt64> ID) => API_CHECK_VOICE_CHAT(ID.Get());
        Boolean API_CHECK_VOICE_CHAT(UInt64 ID)
        {
            if (!UserInformation.ContainsKey(ID)) return false;
            return UserInformation[ID].MuteInfo.IsMute(MuteType.Voice);
        }

        Boolean API_IS_IGNORED(BasePlayer.EncryptedValue<UInt64> UserHas, BasePlayer.EncryptedValue<UInt64> User) => API_IS_IGNORED(UserHas.Get(), User.Get());
        Boolean API_IS_IGNORED(UInt64 UserHas, UInt64 User)
        {
            if (!UserInformation.ContainsKey(UserHas)) return false;
            if (!UserInformation.ContainsKey(User)) return false;

            return UserInformation[UserHas].Settings.IsIgnored(User);
        }

        String API_GET_PREFIX(BasePlayer.EncryptedValue<UInt64> ID) => API_GET_PREFIX(ID.Get());
        String API_GET_PREFIX(UInt64 ID)
        {
            if (!UserInformation.ContainsKey(ID)) return String.Empty;
            Configuration.ControllerParameters ControllerParameter = config.ControllerParameter;

            User Info = UserInformation[ID];
            String Prefixes = String.Empty;

            if (ControllerParameter.Prefixes.TurnMultiPrefixes)
                Prefixes = String.Join("", Info.Info.PrefixList.Take(ControllerParameter.Prefixes.MaximumMultiPrefixCount));
            else Prefixes = Info.Info.Prefix;

            return Prefixes;
        }

        String API_GET_CHAT_COLOR(BasePlayer.EncryptedValue<UInt64> ID) => API_GET_CHAT_COLOR(ID.Get());
        String API_GET_CHAT_COLOR(UInt64 ID)
        {
            if (!UserInformation.ContainsKey(ID)) return String.Empty;

            return UserInformation[ID].Info.ColorMessage;
        }

        String API_GET_NICK_COLOR(BasePlayer.EncryptedValue<UInt64> ID) => API_GET_NICK_COLOR(ID.Get());
        String API_GET_NICK_COLOR(ulong ID)
        {
            if (!UserInformation.ContainsKey(ID)) return String.Empty;

            return UserInformation[ID].Info.ColorNick;
        }
        String API_GET_DEFAULT_PREFIX() => config.ControllerConnect.SetupDefaults.PrefixDefault;
        String API_GET_DEFAULT_NICK_COLOR() => config.ControllerConnect.SetupDefaults.NickDefault;
        String API_GET_DEFAULT_MESSAGE_COLOR() => config.ControllerConnect.SetupDefaults.MessageDefault;
        Int32 API_GET_DEFAULT_SIZE_MESSAGE() => config.ControllerMessages.GeneralSetting.OtherSetting.SizeMessage;
        Int32 API_GET_DEFAULT_SIZE_NICK() => config.ControllerMessages.GeneralSetting.OtherSetting.SizeNick;

        #endregion
    }
}



// --- End of file: IQChat-2.65.46.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XerCopterCraft.cs ---
// --- Original Local Path: XerCopterCraft.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("XerCopterCraft", "Mercury", "1.0.2")]
    class XerCopterCraft : RustPlugin
    {
        #region Reference

        [PluginReference] Plugin ImageLibrary;
        public string GetImage(string shortname, ulong skin = 0) => (string)ImageLibrary?.Call("GetImage", shortname, skin);
        public bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname, skin);

        #endregion

        #region Var
        private string prefab = "assets/content/vehicles/minicopter/minicopter.entity.prefab";
        #endregion

        #region Configuration
        private static Configuration config = new Configuration();

        private class Configuration
        {
            [JsonProperty("SkinId (Иконка в инвентаре)")]
            public ulong skinID = 1680939801;
            [JsonProperty("Миникоптер(Эту вещь игрок будет держать в руках,когда поставит - он заменится на коптер)")]
            public string Item = "electric.flasherlight";
            [JsonProperty("Название вещи в инвентаре")]
            public string ItemName = "Minicopter";
            [JsonProperty("Вещи для крафта")]
            public Dictionary<string, int> CraftItemList = new Dictionary<string, int>();

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    CraftItemList = new Dictionary<string, int>
                    {
                        ["metalblade"] = 10,
                        ["rope"] = 15,
                        ["gears"] = 15,
                        ["stones"] = 5,
                        ["fuse"] = 1,
                        ["wood"] = 5000,
                        ["metal.fragments"] = 6500,
                    }
                };
            }
            
            internal class Interface
            {
                [JsonProperty("Title в меню")]
                public string TitleMenu = "Создание миникоптера";
                [JsonProperty("Title предметов в меню")]
                public string TitleItems = "Список предметов,которые требуются для создания миникоптера";
                [JsonProperty("Текст в кнопке")]
                public string ButtonTitle = "Создать";
                [JsonProperty("Символ показывающий,что у игрока достаточно предметов на крафт")]
                public string Sufficiently = "√";
                [JsonProperty("Цвет символа(HEX)")]
                public string SufficientlyColor = "#33F874FF";
                [JsonProperty("Цвет показателя,сколько необходимо еще компонентов на создание")]
                public string IndispensablyColor = "#F83232FF";
                [JsonProperty("Minicopter.png(512x512)")]
                public string CopterPNG = "https://i.imgur.com/PoeTa16.png";
            }

            internal class Other
            {
                [JsonProperty("Звук при создании коптера")]
                public string EffectCreatedCopter = "assets/prefabs/deployable/tier 1 workbench/effects/experiment-start.prefab";
                [JsonProperty("Звук когда у игрока недостаточно ресурсов")]
                public string EffectCanceled = "assets/prefabs/npc/autoturret/effects/targetlost.prefab";
            }

            [JsonProperty("Настройки интерфейса")]
            public Interface InterfaceSettings = new Interface();
            [JsonProperty("Дополнительные настройки")]
            public Other OtherSettings = new Other();
        }
    
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);
      
        #endregion

        #region Commands

        [ChatCommand("copter")]
        void OpenCraftMenu(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, "xercoptercraft.use"))
                OpenMenuCraft(player);
            else SendReply(player,"Недостаточно прав");
        }

        [ConsoleCommand("craft_copter")]
        void CraftCopter(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (!CraftCheck(player))
            {
                Effect.server.Run(config.OtherSettings.EffectCanceled, player.transform.localPosition);
                MessageUI(player, "Недостаточно ресурсов", config.InterfaceSettings.IndispensablyColor);
                return;
            }
            foreach (var item in config.CraftItemList)
            {
                player.inventory.Take(null, ItemManager.FindItemDefinition(item.Key).itemid, item.Value);
            }
            GiveMinicopter(player);
            MessageUI(player, "Миникоптер создан успешно", config.InterfaceSettings.SufficientlyColor);
            Effect.server.Run(config.OtherSettings.EffectCreatedCopter, player.transform.localPosition);
            CuiHelper.DestroyUi(player, MainPanel);
            LogToFile("XerCopterLog", $"{player.displayName + "/" + player.UserIDString} скрафтил коптер",this);
            PrintWarning($"{player.displayName + "/" + player.UserIDString} скрафтил коптер");
        }

        [ConsoleCommand("give_minicopter")]
        void GiveMinicopterCommand(ConsoleSystem.Arg args)
        {
            BasePlayer target = BasePlayer.FindByID(ulong.Parse(args.Args[0]));
            if (target == null) { PrintWarning("Игрока нет на сервере!Он не получил миникоптер!"); return; };
            GiveMinicopter(target);
            PrintWarning($"Миникоптер выдан игроку {target.userID}");
            if(target.IsConnected)
               MessageUI(target, "Вы получили миникоптер", config.InterfaceSettings.SufficientlyColor);
        }

        #endregion

        #region Hooks

        void OnServerInitialized()
        {
            permission.RegisterPermission("xercoptercraft.use", this);
            AddImage(config.InterfaceSettings.CopterPNG, "CopterImage");

            PrintError($"-----------------------------------");
            PrintError($"           XerCopterCraft          ");
            PrintError($"          Created - Sky Eye        ");
            PrintError($"      Author = Mercury#5212        ");
            PrintError($"    https://vk.com/skyeyeplugins   ");
            PrintError($"-----------------------------------");
        }

        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            CheckDeploy(go.ToBaseEntity());
        }

        #endregion

        #region Main

        private void SpawnCopter(Vector3 position, Quaternion rotation = default(Quaternion), ulong ownerID = 0)
        {
            MiniCopter copter = (MiniCopter)GameManager.server.CreateEntity(prefab, position, rotation);
            if (copter == null) { return; }
            copter.Spawn();
        }

        private void GiveMinicopter(BasePlayer player, bool pickup = false)
        {
            var item = CreateItem();
            player.GiveItem(item);
        }

        private void CheckDeploy(BaseEntity entity)
        {
            if (entity == null) { return; }
            if (!CopterCheck(entity.skinID)) { return; }
            SpawnCopter(entity.transform.position, entity.transform.rotation, entity.OwnerID);
            timer.Once(0.5f, () => { entity.Kill(); });
        }

        private bool CopterCheck(ulong skin)
        {
            return skin != 0 && skin == config.skinID;
        }

        private Item CreateItem()
        {
            var item = ItemManager.CreateByName(config.Item, 1, config.skinID);
            if (item == null)
            {
                return null;
            }
            item.name = config.ItemName;
            return item;
        }

        private bool CraftCheck(BasePlayer player)
        {
            var craft = config.CraftItemList;
            var more = new Dictionary<string, int>();

            foreach (var component in craft)
            {
                var name = component.Key;
                var has = player.inventory.GetAmount(ItemManager.FindItemDefinition(component.Key).itemid);
                var need = component.Value;
                if (has < component.Value)
                {
                    if (!more.ContainsKey(name))
                    {
                        more.Add(name, 0);
                    }

                    more[name] += need - has;
                }
            }

            if (more.Count == 0)
                return true;
            else
                return false;
        }

        private bool UseCraft(BasePlayer player, string Short)
        {
            var craft = config.CraftItemList;
            var more = new Dictionary<string, int>();

            foreach (var component in craft)
            {
                var name = component.Key;
                var has = player.inventory.GetAmount(ItemManager.FindItemDefinition(component.Key).itemid);
                var need = component.Value;
                if (has < component.Value)
                {
                    if (!more.ContainsKey(name))
                    {
                        more.Add(name, 0);
                    }

                    more[name] += need - has;
                }
            }

            if (more.ContainsKey(Short))
                return true;
            else
                return false;
        }

        #endregion

        #region UI

        #region Parent
        static string MainPanel = "XCC_MAINPANEL_skykey";
        static string CraftItemsPanel = "XCC_CRAFT_ITEMS_PANEL";
        static string ItemParent = "XCC_CRAFT_ITEMS_PARENT";
        static string MessagePanel = "XCC_MESSAGE_PANEL";
        #endregion

        #region Message

        void MessageUI(BasePlayer player, string Messages, string Color)
        {
            CuiHelper.DestroyUi(player, MessagePanel);
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.3291668 0.8583333", AnchorMax = "0.6614581 0.9166667" },
                Image = {FadeIn = 0.4f, Color = HexToRustFormat(Color) }
            }, "Overlay", MessagePanel);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Text = { Text = String.Format(Messages), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 30, Color = HexToRustFormat("#FFFFFFFF") }
            }, MessagePanel);

            CuiHelper.AddUi(player, container);

            timer.Once(2f, () => { CuiHelper.DestroyUi(player, MessagePanel); });
        }

        #endregion

        #region MainMenu

        void OpenMenuCraft(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, MainPanel);
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1"},
                Image = { Color = HexToRustFormat("#0000008F") }
            }, "Overlay", MainPanel);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "-100 -100", AnchorMax = "100 100" },
                Button = { Close = MainPanel, Color = "0 0 0 0" },
                Text = { FadeIn = 0.8f, Text = "" }
            }, MainPanel);

            #region Titles

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.8962963", AnchorMax = "1 1" },
                Text = { Text = String.Format(config.InterfaceSettings.TitleMenu), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 30, Color = HexToRustFormat("#FFFFFFFF") }
            }, MainPanel);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.4805566", AnchorMax = "1 0.5546331" },
                Text = { Text = String.Format(config.InterfaceSettings.TitleItems), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 30, Color = HexToRustFormat("#FFFFFFFF") }
            }, MainPanel);

            #endregion

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.4078125 0.5546297", AnchorMax = "0.5895833 0.5962934" },
                Button = { Command = "craft_copter", Color = HexToRustFormat("#319A56FF") },
                Text = { FadeIn = 0.9f, Text = config.InterfaceSettings.ButtonTitle,Align = TextAnchor.MiddleCenter, FontSize = 25 }
            }, MainPanel);

            container.Add(new CuiElement
            {
                Parent = MainPanel,
                Components =
                {
                    new CuiRawImageComponent {
                        Png = GetImage("CopterImage"), 
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0.3989581 0.6",
                        AnchorMax = "0.5968745 0.8925924"
                    },
                }
            });

            #region CraftItems

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.1442708 0.01944444", AnchorMax = "0.8614583 0.4787037" },
                Image = { Color = "0 0 0 0" }
            },  MainPanel, CraftItemsPanel);

            int x = 0, y = 0, i = 0;
            foreach (var items in config.CraftItemList)
            {
                string color = UseCraft(player, items.Key) ? "#A60D0D2F" : "#1FB91931";

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{0.01386664 + (x * 0.17)} {0.5463711 - (y * 0.45)}", AnchorMax = $"{0.1416122 + (x * 0.17)} {0.8891131 - (y * 0.45)}" },
                    Image = { Color = HexToRustFormat(color) }
                }, CraftItemsPanel, $"Item_{i}");

                container.Add(new CuiElement
                {
                    Parent = $"Item_{i}",
                    Components =
                    {
                    new CuiRawImageComponent {
                        Png = GetImage(items.Key),
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    },
                }
                });

                var has = player.inventory.GetAmount(ItemManager.FindItemDefinition(items.Key).itemid);
                var result = items.Value - has <= 0 ? $"<color={config.InterfaceSettings.SufficientlyColor}>{config.InterfaceSettings.Sufficiently}</color>" : $"<color={config.InterfaceSettings.IndispensablyColor}>{Convert.ToInt32(items.Value - has).ToString()}</color>";

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = String.Format(result.ToString()), Align = TextAnchor.LowerCenter, Font = "robotocondensed-bold.ttf", FontSize = 16, Color = HexToRustFormat("#FFFFFFFF") }
                }, $"Item_{i}");


                x++; i++;
                if (x == 6)
                {
                    x = 0;
                    y++;
                }
                if (x == 6 && y == 1)
                    break;
            }
            #endregion

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #endregion

        #region Help

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        #endregion        
    }
}


// --- End of file: XerCopterCraft.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/MedkitSaver.cs ---
// --- Original Local Path: MedkitSaver.cs ---

//Requires: ImageLibrary

using UnityEngine;
using System;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Newtonsoft.Json;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("MedkitSaver", "walkinrey", "1.0.4")]
    class MedkitSaver : RustPlugin
    {
      #region Configuration
      class Conf
      {
         [JsonProperty("Сколько моментально установить хп при использовании аптечки (по умолчанию 15)")] public float hpMomental = 15f;
         [JsonProperty("Сколько хп восстанавливать при использовании аптечки (по умолчанию 100)")] public float hpRevive = 100f;
         [JsonProperty("Выводить сообщения в чат о использовании аптечки? (по умолчанию да)")] public bool messageUse = true;
         [JsonProperty("Сообщение о использовании аптечки")] public string messageString = "Вы использовали <color=red>аптечку!</color>";
      }
      protected override void LoadDefaultConfig() => config = new Conf();
      protected override void LoadConfig()
      {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Conf>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                LoadDefaultConfig();
            }
            Config.WriteObject(config, true);
            Config.ReadObject<Conf>();
      }
      #endregion
        #region References
        private Conf config;
        [PluginReference] private Plugin ImageLibrary;
        List<string> steamIDs = new List<string>();
        #endregion
        #region Hooks
        object OnPlayerWound(BasePlayer player, BasePlayer source)
        {       
          if(player.inventory.GetAmount(254522515) > 0)
          {
            CuiHelper.AddUi(player, CreateElements());
            steamIDs.Add(player.userID.ToString());
          }
            return null;
        }
        object OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if(player != null && player.userID.IsSteamId() && player.IsConnected && steamIDs.Contains(player.userID.ToString()))
            {
                DestroyMedkitUi(player);
                steamIDs.Remove(player.userID.ToString());
            }
            return null;
        }
        void Loaded()
        {
           LoadConfig();
        }
        #endregion
        #region Methods
        CuiElementContainer CreateElements()
        {
          CuiElementContainer container = new CuiElementContainer();
          CuiElement medkitPanel = new CuiElement
          {
             Name = "medkit_panel",
             Parent = "Overlay",
             Components = 
             {
               new CuiRawImageComponent
               {
                  Color = "0.49 0.49 0.49 0.39",
                  Sprite = "Assets/Content/UI/UI.Background.Tile.psd"
               },
               new CuiRectTransformComponent
               {
                 AnchorMin = "0.648 0.015",
                 AnchorMax = "0.688 0.086"
               }
             }
          };
          container.Add(medkitPanel);
          CuiElement medkitImage = new CuiElement
          {
            Name = "medkit_image",
            Parent = "Overlay",
            Components =
            {
              new CuiRawImageComponent
              {
                Png = (string)ImageLibrary.Call("GetImage", "largemedkit")
              },
              new CuiRectTransformComponent
              {
                AnchorMin = "0.650 0.019",
                AnchorMax = "0.688 0.086"
              }
            }
          };
          CuiElement medkitButton = new CuiElement
          {
            Name = "medkit_button",
            Parent = "Overlay",
            Components =
            {
              new CuiButtonComponent
              {
                Command = "medkituse",
                Color = "0 0 0 0"
              },
              new CuiRectTransformComponent
              {
                AnchorMin = "0.648 0.015",
                AnchorMax = "0.688 0.086"
              }
            }
          };
          container.Add(medkitImage);
          container.Add(medkitButton);
          return container;
        }
        [ConsoleCommand("medkituse")]
        private void cmd_Use(ConsoleSystem.Arg arg)
        {
          var player = arg.Player();
          DestroyMedkitUi(player);
          player.inventory.Take(null, 254522515, 1);
          player.IPlayer.Health = config.hpMomental;
          player.metabolism.pending_health.value = config.hpRevive;
          player.StopWounded();
          if(config.messageUse) SendReply(player, config.messageString);
        }
        private void DestroyMedkitUi(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "medkit_panel");
            CuiHelper.DestroyUi(player, "medkit_image");
            CuiHelper.DestroyUi(player, "medkit_button");
        }
        #endregion
    }
}

// --- End of file: MedkitSaver.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/MagicMeat.cs ---
// --- Original Local Path: MagicMeat.cs ---

using System.Collections.Generic;
using System;
using Rust;

namespace Oxide.Plugins
{
	[Info("MagicMeat", "ignignokt84", "0.1.1", ResourceId = 2011)]
	class MagicMeat : RustPlugin
	{
		void LoadDefaultMessages()
		{
			var messages = new Dictionary<string, string>
			{
				{"ConsoleCommand", "magicmeat"},
				{"VersionString", "MagicMeat v. {0}"},
				
				{"UsageHeader", "---- MagicMeat usage ----"},
				{"CmdUsageSet", "Set value of specified option"},
				{"CmdUsageGet", "Get value of specified option"},
				{"CmdUsageDef", "Loads default configuration"},
				{"CmdUsageVersion", "Prints version information"},
				{"CmdUsageOptionString", "[option]"},
				{"CmdUsageValueString", "[value]"},
				{"InvalidParameter", "Invalid parameter: {0}"},
				{"InvalidParamForCmd", "Invalid parameters for command \"{0}\""},
				{"NoPermission", "Cannot execute command: No permission"},
				{"SetSuccess", "Successfully set \"{0}\" to \"{1}\""},
				{"DefConfigLoad", "Loaded default configuration"}
			};
			lang.RegisterMessages(messages, this);
		}
		private Dictionary<Option,object> data = new Dictionary<Option,object>();
		// has config changed?
		private bool hasConfigChanged;
		// usage information string with formatting
		public string usageString;
		// command enum
		private enum Command { usage, set, get, version, def };
		// option enum
		private enum Option { pickup, store };
		// default values array
		private object[] def = { true, false };
		
		private Dictionary<int,int> recipes = new Dictionary<int,int>() {
			{1325935999, -2043730634},	// bear meat
			{-253819519, 991728250},	// pork
			{-1658459025, 1734319168},	// chicken
			{179448791, -1691991080},	// wolf meat
			{-533484654, -2078972355},	// fish
			{-642008142, -991829475}	// human meat
		};
		
		// load
		void Loaded()
		{
			LoadDefaultMessages();
			// build commands based on enum values
			string baseCommand = GetMessage("ConsoleCommand");
			foreach(Command command in Enum.GetValues(typeof(Command)))
				cmd.AddConsoleCommand((baseCommand + "." + command.ToString()), this, "ccmdDelegator");
			
			LoadConfig();
			// build usage string
			usageString = wrapSize(14, wrapColor("orange", GetMessage("UsageHeader"))) + "\n" +
						  wrapSize(12, wrapColor("cyan", baseCommand + "." + Command.set.ToString() + " " + GetMessage("CmdUsageOptionString") + " " + GetMessage("CmdUsageValueString")) + " - " + GetMessage("CmdUsageSet") + "\n" +
									   wrapColor("cyan", baseCommand + "." + Command.get.ToString() + " " + GetMessage("CmdUsageOptionString")) + " - " + GetMessage("CmdUsageGet") + "\n" +
									   wrapColor("cyan", baseCommand + "." + Command.def.ToString()) + " - " + GetMessage("CmdUsageDef") + "\n" +
									   wrapColor("cyan", baseCommand + "." + Command.version.ToString()) + " - " + GetMessage("CmdUsageVersion"));
		}
		
        // get message from Lang
        string GetMessage(string key, string userId = null) => lang.GetMessage(key, this, userId);
		
		// delegation method for console commands
		//[ConsoleCommand("tpve")]
		void ccmdDelegator(ConsoleSystem.Arg arg)
		{
			// user doesn't have access to run console command
			if(!hasAccess(arg)) return;
			
			string cmd = arg.cmd.namefull.Split('.')[1];
			if(!Enum.IsDefined(typeof(Command), cmd))
			{
				// shouldn't hit
				SendReply(arg, wrapSize(12, wrapColor("red", String.Format(GetMessage("InvalidParameter"), cmd))));
			}
			else
			{
				switch((Command) Enum.Parse(typeof(Command), cmd))
				{
					case Command.version:
						SendReply(arg, wrapSize(14, wrapColor("orange", String.Format(GetMessage("VersionString"), this.Version.ToString()))));
						return;
					case Command.def:
						LoadDefaultConfig();
						SendReply(arg, wrapSize(12, wrapColor("green", GetMessage("DefConfigLoad"))));
						return;
					case Command.set:
						if(handleSet(arg)) return;
						break;
					case Command.get:
						if(handleGet(arg)) return;
						break;
					case Command.usage:
						showUsage(arg);
						return;
				}
				SendReply(arg, wrapSize(12, wrapColor("red", String.Format(GetMessage("InvalidParamForCmd"), arg.cmd.namefull))));
			}
			showUsage(arg);
		}
		
		// handle set command
		private bool handleSet(ConsoleSystem.Arg arg)
		{
			if(!Enum.IsDefined(typeof(Option), arg.Args[0]))
			{
				SendReply(arg, wrapSize(12, wrapColor("red", String.Format(GetMessage("InvalidParameter"), arg.Args[0]))));
				return false;
			}
			
			Option opt = (Option) Enum.Parse(typeof(Option), arg.Args[0]);
			object value;
			try {
				value = Convert.ToBoolean(arg.Args[1]);
			} catch(FormatException e) {
				SendReply(arg, wrapSize(12, wrapColor("red", String.Format(GetMessage("InvalidParameter"), arg.Args[1]))));
				return false;
			}
			
			SaveEntry(opt,value);
			SendReply(arg, wrapSize(12, wrapColor("cyan", String.Format(GetMessage("SetSuccess"), new object[] {opt, value}))));
			return true;
		}
		
		// handle get command
		private bool handleGet(ConsoleSystem.Arg arg)
		{
			if(arg.Args[0] == "all")
			{
				foreach(Option option in Enum.GetValues(typeof(Option)))
				{
					printValue(arg, option);
				}
				return true;
			}
			if(!Enum.IsDefined(typeof(Option), arg.Args[0]))
			{
				SendReply(arg, wrapSize(12, wrapColor("red", String.Format(GetMessage("InvalidParameter"), arg.Args[0]))));
				return false;
			}
			Option opt = (Option) Enum.Parse(typeof(Option), arg.Args[0]);
			printValue(arg, opt);
			return true;
		}
		
		// show usage information
		void showUsage(ConsoleSystem.Arg arg)
		{
			SendReply(arg, usageString);
		}
		
		// prints the value of an Option
		private void printValue(ConsoleSystem.Arg arg, Option opt)
		{
			SendReply(arg, wrapSize(12, wrapColor("cyan", opt + ": ") + data[opt]));
		}
		
		// loads default configuration
		protected override void LoadDefaultConfig()
		{
			Config.Clear();
			LoadConfig();
		}
		
		// loads config from file
		private void LoadConfig()
		{
			foreach(Option opt in Enum.GetValues(typeof(Option)))
				data[opt] = Convert.ToBoolean(GetConfig(opt, def[(int)opt]));
			
			if (!hasConfigChanged) return;
			SaveConfig();
			hasConfigChanged = false;
		}
		
		// get config options, or set to default value if not found
		private object GetConfig(object opt, object defaultValue)
		{
			string optstr = opt.ToString();
			object value = Config[optstr];
			if (value == null)
			{
				value = defaultValue;
				Config[optstr] = value;
				hasConfigChanged = true;
			}
			return value;
		}
		
		// save updated entry to config
		private void SaveEntry(Option opt, object value)
		{
			string optstr = opt.ToString();
			data[opt] = value;
			Config[optstr] = value;
			SaveConfig();
		}
		
		// handle conversion of items
		void OnItemAddedToContainer(ItemContainer container, Item item)
		{
			// check if item is in recipe dictionary
			if(!recipes.ContainsKey((int) item.info.itemid))
				return; // item not found
			
			// get details of item
			int cookedId = recipes[(int) item.info.itemid];
			int amount = item.amount;
			int position = item.position;
			
			// handle pickup (player inventory)
			if(getBool(Option.pickup) && container.playerOwner != null)
			{
				// item added to player inventory
				item.RemoveFromContainer();
				Item cookedMeat = ItemManager.CreateByItemID(cookedId, amount);
				cookedMeat.AddOwners(item.owners);
				if (!cookedMeat.MoveToContainer(container, position, true))
					cookedMeat.Remove(0f);
			}
			
			// handle storage (other inventory)
			if(getBool(Option.store) && container.entityOwner != null)
			{
				// item added to storage box
				item.RemoveFromContainer();
				Item cookedMeat = ItemManager.CreateByItemID(cookedId, amount);
				cookedMeat.AddOwners(item.owners);
				if (!cookedMeat.MoveToContainer(container, position, true))
					cookedMeat.Remove(0f);
			}
			
		}
		
		// wrap a string in a <size> tag with the passed size
		static string wrapSize(int size, string input)
		{
			if(input == null || input == "")
				return input;
			return "<size=" + size + ">" + input + "</size>";
		}
		
		// wrap a string in a <color> tag with the passed color
		static string wrapColor(string color, string input)
		{
			if(input == null || input == "" || color == null || color == "")
				return input;
			return "<color=" + color + ">" + input + "</color>";
		}
		
		// convert Option value to bool
		private bool getBool(Option opt)
		{
			return Convert.ToBoolean(data[opt]);
		}
		
		// convert Option value to float
		private float getFloat(Option opt)
		{
			return Convert.ToSingle(data[opt]);
		}
		
		// send message to player
		void sendMessage(BasePlayer player, string message)
		{
			//if(checkPopup())
			//	PopupNotifications.Call("CreatePopupNotification", message, player);
			//else
				SendReply(player, message);
		}
		
		// is admin
        private bool isAdmin(BasePlayer player)
        {
        	if (player == null) return false;
            if (player?.net?.connection == null) return true;
            return player.net.connection.authLevel > 0;
        }
		
		// check user access
		bool hasAccess(ConsoleSystem.Arg arg)
		{
			if (arg.connection != null)
			{
				if (arg.connection.authLevel < 1)
				{
					SendReply(arg, GetMessage("NoPermission"));
					return false;
				}
			}
			return true;
		}
	}
}

// --- End of file: MagicMeat.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TPBaraxolka.cs ---
// --- Original Local Path: TPBaraxolka.cs ---

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Linq;
using UnityEngine;
using UnityEngine.Networking;
using Network;

namespace Oxide.Plugins
{
    [Info("TPBaraxolka", "Sempai#3239", "1.0.3")]
    internal class TPBaraxolka : RustPlugin
    {
        public List<BaseEntity> BaseEntityList = new List<BaseEntity>();
        [PluginReference] Plugin ImageLibrary, TPEconomic, TPMenuSystem;

        void Loaded()
        {
            ins = this;
            LoadSounds();

        }
        void OnServerInitialized()
        {
            PrintWarning("\n-----------------------------\n " +" Author - Sempai#3239\n " +" VK - https://vk.com/rustnastroika\n " +" Forum - https://topplugin.ru\n " +" Discord - https://discord.gg/5DPTsRmd3G\n" +"-----------------------------");
            if (ImageLibrary)
            {
                var images = config.bottleSetting.CustomItemsShop.Where(p => !string.IsNullOrEmpty(p.ImageURL));
                foreach (var check in images)
                    ImageLibrary.Call("AddImage", check.ImageURL, check.ImageURL);


                foreach (var check in config.bottleSetting.CustomItemsShop.Where(p => string.IsNullOrEmpty(p.ImageURL)))
                ImageLibrary.Call("AddImage", $"https://rustlabs.com/img/items180/{check.defaultItem.ShortName}.png", check.defaultItem.ShortName + 128);
                ImageLibrary.Call("AddImage", "https://media.discordapp.net/attachments/845901958820790285/1193980037347684403/2.png", "MainUI");
                ImageLibrary.Call("AddImage", "https://media.discordapp.net/attachments/845901958820790285/1193978187386990752/2.png", "DropUI");
                ImageLibrary.Call("AddImage", "https://media.discordapp.net/attachments/845901958820790285/1193978457428869130/2.png", "BuyerUI");
            }
            ServerMgr.Instance.StartCoroutine(DownloadImage("https://i.imgur.com/7fIELSt.png"));
            //FindPositions();

            foreach (var player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }
        }

        public string External = "UI_TPBaraxolka_External";
        public string Internal = "UI_TPBaraxolka_Internal";


        public string Layer95="MainUI_TPBaraxolka";
        private void DrawNPCUI(BasePlayer player, string img = "MainUI", int a=0)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, External);
            CuiHelper.DestroyUi(player, Internal);
            CuiHelper.DestroyUi(player, Layer95);


            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = "0 0 0 0", Material = "assets/content/ui/uibackgroundblur.mat", Sprite = "assets/content/ui/ui.background.transparent.radial.psd" }
            }, "Overlay", Layer95);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.233 0.2", AnchorMax = $"0.80 0.8", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0" }
            }, Layer95, ".Mains_Tr");

            container.Add(new CuiElement
            {
                Name = External,
                Parent = ".Mains_Tr",
                Components = 
                {
                    new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", img), Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "-0.315 -0.27", AnchorMax = "1.3 1.275", OffsetMax = "0 0" },
                }
            });

            CuiHelper.AddUi(player, container);
            InitializeLayers(player);
            if(img == "MainUI" && a==0)
                player.SendConsoleCommand("UI_TPBaraxolka info");
        }


        void CreateInfoPlayer(BasePlayer player, bool opened)
        {
            CuiHelper.DestroyUi(player, External + ".Mood1" + ".panel");
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiElement
            {
                Name = External + ".Mood1" + ".panel",
                Parent = "Overlay",
                Components =
                        {
                            new CuiImageComponent { FadeIn = 1f, Color = opened?  "0.235 0.227 0.180 0.6" :"0.235 0.227 0.180 0" , Sprite = "assets/content/ui/ui.background.transparent.linear.psd"},
                            new CuiRectTransformComponent {AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = opened ?  "-240 -81" : "-240 -141", OffsetMax = opened ? "-60 -30" : "-60 -90"}
                        }
            });



            container.Add(new CuiElement
            {
                Parent = External + ".Mood1" + ".panel",
                Name = External + ".Mood1",
                Components =
                        {
                            new CuiRawImageComponent {FadeIn = 1f,Png = (string)ImageLibrary.Call("GetImage", "https://i.imgur.com/ghyCq0Q.png"), Color = "0.929 0.882 0.847 1"},
                            new CuiRectTransformComponent {AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-30 -60", OffsetMax = "50 20"}
                        }
            });


            if (opened)
            {
                container.Add(new CuiElement
                {
                    Parent = External + ".Mood1" + ".panel",
                    Components =
                        {
                            new CuiTextComponent { FadeIn = 1f,Color = "0.929 0.882 0.847 0.5", Text = $"<color=#EDE1D8>ВАМ ПОСЫЛКА</color>", Align = TextAnchor.UpperLeft /*,Font="robotocondensed-regular.ttf"*/},
                            new CuiRectTransformComponent {AnchorMin = "0.03 0", AnchorMax = "1 0.9"}
                        }
                });

                container.Add(new CuiElement
                {
                    Parent = External + ".Mood1" + ".panel",
                    Components =
                        {
                            new CuiTextComponent {FadeIn = 1f, Color = "0.929 0.882 0.847 0.4", Text = $"НАЖМИТЕ ЧТОБЫ ЗАБРАТЬ", Align = TextAnchor.MiddleLeft ,Font="robotocondensed-regular.ttf", FontSize = 12},
                            new CuiRectTransformComponent {AnchorMin = "0.03 0", AnchorMax = "1 0.8"}
                        }
                });

                container.Add(new CuiElement
                {
                    Parent = External + ".Mood1" + ".panel",
                    Components =
                        {
                            new CuiButtonComponent { Color = "0.929 0.882 0.847 0", Command = "UI_TPBaraxolka givepackage"},
                            new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                        }
                });
            }
            else
            {
                container.Add(new CuiElement
                {
                    Parent = External + ".Mood1",
                    Components =
                        {
                            new CuiTextComponent { FadeIn = 1f,Color = "0.929 0.882 0.847 0.4   ", Text = $"ЗАБРАТЬ", Align = TextAnchor.UpperCenter ,Font="robotocondensed-regular.ttf"},
                            new CuiRectTransformComponent {AnchorMin = "0 -0.3", AnchorMax = "1 0.05"}
                        }
                });

                container.Add(new CuiElement
                {
                    Parent = External + ".Mood1",
                    Components =
                        {
                            new CuiButtonComponent { Color = "0.929 0.882 0.847 0", Command = "UI_TPBaraxolka givepackage"},
                            new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                        }
                });



            }

            CuiHelper.AddUi(player, container);
        }

        string GetMoodTranslate(FatherComponent.Mood mood)
        {
            switch (mood)
            {
                case FatherComponent.Mood.Neutral:
                    return "НЕЙТРАЛЬНЫЙ";

                case FatherComponent.Mood.Kind:
                    return "ВЕСЁЛЫЙ";

                case FatherComponent.Mood.Evil:
                    return "ЗЛОЙ";
            }
            return "НЕЙТРАЛЬНЫЙ";
        }


        string GetMoodInfoRmation(FatherComponent.Mood mood)
        {
            switch (mood)
            {
                case FatherComponent.Mood.Neutral:
                    return "От его настроения зависит дальнейший диалог с ним. Предметы какие обменяет батя будут стандартные. Чем лучше настроение, тем больше предметов предложит батя";

                case FatherComponent.Mood.Kind:
                    return "От его настроения зависит дальнейший диалог с ним. Предметы какие обменяет батя будут увеличенные. Чем лучше настроение тем, больше предметов предложит батя";


                case FatherComponent.Mood.Evil:
                    return "Предметы какие обменяет батя будут уменьшены. Смотри осторожно, есть возможность получить леща от него. Батя не особо дружелюбный, бонусов не накинет.";
            }

            return "От его настроения зависит дальнейший диалог с ним. Предметы какие обменяет батя будут стандартные. Чем лучше настроение, тем больше предметов предложит батя";

        }



        string InitialLayer = "UI_TPBaraxolka_InitialLayer";
        private void InitializeLayers(BasePlayer player, string SelectMenu = "")
        {
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0" },
                Image = { Color = "0 0 0 0" }
            }, External, InitialLayer);

            container.Add(new CuiPanel()
            {
                RectTransform = { AnchorMin = "0.7 0", AnchorMax = "0.9 1", OffsetMin = "0 0", OffsetMax = "0 0" },
                Image = { Color = "0.24 0.45 0.90 0", Material = "" }
            }, InitialLayer, InitialLayer + ".C");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5 0.804", AnchorMax = "0.57 0.83" },
                Button = { Close = "MainUI_TPBaraxolka", Color = "1 1 1 0" },
            }, InitialLayer + ".C");


            container.Add(new CuiPanel()
            {
                RectTransform = { AnchorMin = "0.25 0.2", AnchorMax = "0.754 0.64", OffsetMin = "0 0", OffsetMax = "0 0" },
                Image = { Color = "1 1 1 0" }
            }, InitialLayer, InitialLayer + ".R");
            CuiHelper.DestroyUi(player, InitialLayer);
            CuiHelper.AddUi(player, container);
            DrawMenuPoints(player);
        }

        void CreateInfoJson(BasePlayer player, int page)
        {
            CuiHelper.DestroyUi(player, InitialLayer + ".Expedition");
            DrawNPCUI(player, "DropUI");

            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel()
            {
                RectTransform = { AnchorMin = "-0.08 0.3", AnchorMax = "0.48 0.95" },
                Image = { Color = "0.24 0.45 0.90 0" }
            }, InitialLayer + ".R", InitialLayer + ".Expedition");

            container.Add(new CuiPanel()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "345 -95", OffsetMax="355 3" },
                Image = { Color = "0.24 0.45 0.90 0" }
            }, InitialLayer + ".Expedition", InitialLayer + ".ItemsList");

            var pos = GetPositions(7, 7, 0.01f, 0.02f);
            int count = 0;
            var itemsList = config.expeditionSettings.ItemsAdded.OrderBy(p => p.Value.amount).Skip(page * 49).Take(49);

            foreach (var item in itemsList)
            {
                container.Add(new CuiPanel()
                {
                    RectTransform = { AnchorMin = pos[count].AnchorMin, AnchorMax = pos[count].AnchorMax },
                    Image = { Color = "0.77 0.74 0.71 0"}
                }, InitialLayer + ".ItemsList", InitialLayer + item.Key);

                container.Add(new CuiElement
                {
                    Parent = InitialLayer + item.Key,
                    Components =
                            {
                                new CuiRawImageComponent {Png = (string) ImageLibrary.Call("GetImage", item.Key), Color = "1 1 1 0.6"},
                                new CuiRectTransformComponent { AnchorMin = "0.1 0.05", AnchorMax = "0.9 0.95" }
                            }
                });


                container.Add(new CuiElement
                {
                    Parent = InitialLayer + item.Key,
                    Components =
                        {
                            new CuiTextComponent { Color = "0.929 0.882 0.847 0.2", Text = $"<b>{item.Value.amount}</b>", Align = TextAnchor.MiddleCenter , FontSize = 23,Font="robotocondensed-regular.ttf"},
                            new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 5", OffsetMax="0 0" }
                        }
                });


                container.Add(new CuiElement
                {
                    Parent = InitialLayer + item.Key,
                    Components =
                        {
                            new CuiTextComponent { Color = "0.929 0.882 0.847 0.3", Text = $"MAX {item.Value.maxCount}", Align = TextAnchor.LowerCenter , FontSize = 8,Font="robotocondensed-regular.ttf"},
                            new CuiRectTransformComponent {AnchorMin = "0 0.05", AnchorMax = "1 1", OffsetMin = "0 -3", OffsetMax="0 0" }
                        }
                });


                count++;
            }

            container.Add(new CuiElement
            {
                Parent = InitialLayer + ".Expedition",
                Components =
                        {
                            new CuiTextComponent { Color = "1 1 1 0.6", Text = $"ОСНОВНАЯ ИНФОРМАЦИЯ", Align = TextAnchor.UpperCenter, FontSize = 13},
                            new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax="0 20" }
                        }
            });

            container.Add(new CuiElement
            {
                Parent = InitialLayer + ".Expedition",
                Components =
                        {
                            new CuiTextComponent { Color = "1 1 1 0.6", Text = $"СПИСОК ПРЕДМЕТОВ", Align = TextAnchor.UpperCenter, FontSize = 13},
                            new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "310 0", OffsetMax="400 20" }
                        }
            });

            container.Add(new CuiElement
            {
                Parent = InitialLayer + ".Expedition",
                Components =
                        {
                            new CuiTextComponent { Color = "1 1 1 0.6", Text = $"Здесь вы можете увидеть список предметов которые вы можете продать на барахолке, и количество TopCoin которые за них получите. Предметы и цена может меняться время от времени.\n\n\nНа что влияет цена:\n        Хлам из первого верстака (на него цена ниже).\n        Хлам второго верстака (На него цена повыше).\n        Хлам третьего верстака (На него цена высокая).\n\nНо имейте ввиду что вы вы не сможете продать на барахолку много одинакого хлама\nНа каждый товар действует лимит в зависимости от редкости товара", Align = TextAnchor.UpperLeft, FontSize = 11},
                            new CuiRectTransformComponent {AnchorMin = "0.05 0", AnchorMax = "1 0.95"}
                        }
            });

            container.Add(new CuiButton
            {
                Button =
                {
                    Color = "0 0 0 0" , Command = page > 0 ? $"UI_TPBaraxolka expedition {page -1}" : ""
                },
                Text =
                {
                    Text = "◀", FontSize = 55, Align = TextAnchor.LowerRight, Color = page > 0 ? "0.929 0.882 0.847 0.7" : "0.929 0.882 0.847 0.1"
                },
                RectTransform =
                {
                    AnchorMin = $"0 0.2", AnchorMax = $"0.1 0.4"
                }
            }, InitialLayer + ".Expedition");

            container.Add(new CuiButton
            {
                Button =
                {
                    Color = "0 0 0 0", Command =  page < 2 ? $"UI_TPBaraxolka expedition {page +1}" : ""
                },
                Text =
                {
                    Text = "▶", FontSize = 55, Align = TextAnchor.LowerLeft, Color = page < 2  ? "0.929 0.882 0.847 0.7" :  "0.929 0.882 0.847 0.1"
                },
                RectTransform =
                {
                  AnchorMin = $"0.9 0.2", AnchorMax = $"1 0.4"
                }
            }, InitialLayer + ".Expedition");


            container.Add(new CuiPanel()
            {
                RectTransform = { AnchorMin = "0.5 0.6", AnchorMax = "0.89 0.85" },
                Image = { Color = "0.77 0.74 0.71 0" }
            }, InitialLayer + ".Expedition", InitialLayer + ".buttonAccept");

            container.Add(new CuiElement
            {
                Parent = InitialLayer + ".buttonAccept",
                Components =
                        {
                            new CuiTextComponent { Color = "1 1 1 0.6", Text = $"*Нажми, чтобы передать бате предметы на обмен", Align = TextAnchor.UpperCenter , FontSize = 8},
                            new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin="-340 -250", OffsetMax="220 -225"}
                        }
            });

            container.Add(new CuiButton
            {
                Button =
                {
                    Color = "1 1 1 0" , Command = $"UI_TPBaraxolka startLoot"
                },
                Text =
                {
                    Text = "Начать обмен", FontSize = 12, Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.6"
                },
                RectTransform =
                {
                    AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMin="-47 -174", OffsetMax="-70 -198"
                }
            }, InitialLayer + ".buttonAccept");
            CuiHelper.AddUi(player, container);
        }

        void CreateInfo(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            DrawNPCUI(player, "MainUI", 1);

            container.Add(new CuiPanel()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = "0.24 0.45 0.90 0" }
            }, InitialLayer + ".R", InitialLayer + ".Info");

            container.Add(new CuiElement
            {
                Parent = InitialLayer + ".Info",
                Components =
                        {
                            new CuiTextComponent { Color = "1 1 1 0.6", Text = $"<b>Барахолка являются одним из самых популярных и полезных мест для покупки и продажи вещей.\nОна обладают рядом преимуществ, делая её незаменимой для многих игроков.\n\n<size=13>Во-первых:</size>\nБарахолки предлагают широкий ассортимент товаров, которые можно приобрести по выгодным ценам.\nБлагодаря большому количеству предложений, каждый пользователь может найти то, что ему нужно, и при этом выгодно купить товар.\n\n<size=13>Во-вторых:</size>\nБарахолки являются отличной площадкой для продажи ненужного хлама.\nВы можете продать свои ненужные предметы за <size=13>TopCoin</size> и купить что то полезное, либо испытать удачу в лотерее.</b>", Align = TextAnchor.UpperLeft , FontSize = 11},
                            new CuiRectTransformComponent {AnchorMin = "0.15 0", AnchorMax = "0.85 0.85"}
                        }
            });

            container.Add(new CuiElement
            {
                Parent = InitialLayer + ".Info",
                Components =
                        {
                            new CuiTextComponent { Color = "1 1 1 0.6", Text = "ОСНОВНАЯ ИНФОРМАЦИЯ", Align = TextAnchor.LowerCenter , FontSize = 20},
                            new CuiRectTransformComponent {AnchorMin = "0 0.9", AnchorMax = "1 1"}
                        }
            });

            container.Add(new CuiButton
	    {
	    Button = {
	    Command = $"playerVideoBatia {config.urlvido}",
	    Color = "0 0 0 0.5" ,
	    },
	    Text = {
	    Text = $"ВИДЕО ИНСТРУКЦИЯ", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = "0.929 0.882 0.847 0.7"
	    },
	    RectTransform = {
	    AnchorMin = "0.2 0", AnchorMax = "0.8 0.12"
	    }}, InitialLayer + ".Info");

            CuiHelper.DestroyUi(player, InitialLayer + ".Info");
            CuiHelper.AddUi(player, container);
            }
            [ConsoleCommand("playerVideoBatia")]
	    void paltdsag(ConsoleSystem.Arg arg)
	    {
	    BasePlayer baseplayer = arg.Player();
	    if(baseplayer == null) return;
	    string @string = arg.GetString(0, "");
	    baseplayer.Command("client.playvideo", new object[]
	    {
	    @string
	    });
	    }
            void CreateBottleExchange(BasePlayer player, int page = 0)
           {
            DrawNPCUI(player, "BuyerUI", 1);
            CuiElementContainer container = new CuiElementContainer();
            float amount = (float)TPEconomic.Call("API_GET_BALANCE", player.userID);

            container.Add(new CuiPanel()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "-5 5", OffsetMax = "5 5" },
                Image = { Color = "1 1 1 0"}
            }, InitialLayer + ".R", InitialLayer + ".Bottle");

            var itemList = config.bottleSetting.CustomItemsShop.Skip(page * 12);
            if (itemList.Count() > 12)
            {
                container.Add(new CuiButton
                {
                    Button =
                {
                    Command = $"UI_Gold page {page+1} ",
                    Color = "0 0 0 0" ,
                },
                    Text =
                {
                    Text = $"▶", FontSize = 60, Align = TextAnchor.MiddleRight, Color = "0.929 0.882 0.847 0.7"
                },
                    RectTransform =
                {
                    AnchorMin = $"0.89 -0.15",
                    AnchorMax = $"0.99 0"
                }
                }, InitialLayer + ".Bottle");
            }

            int i = 0;
            int u = 0;
            //var pos = GetPositions(3, 4, 0.02f, 0.02f);
            int aa=0;

            foreach (var item in itemList.Skip(page * 12).Take(12))
            {
                if(i==3)
                {
                    i=0;
                    u++;
                }
                container.Add(new CuiPanel()
                {//AnchorMin = $"0.340 0.77", AnchorMax = $"0.658 1"
                    //+22
                    RectTransform = { AnchorMin = $"0 0.77", AnchorMax = $"0.32 1", OffsetMin = $"{205*i} {-75*u}", OffsetMax = $"{205*i} {-75*u}" },
                    Image = { Color = "1 1 1 0"}
                }, InitialLayer + ".Bottle", InitialLayer + $".Shop.{i}");

                container.Add(new CuiPanel()
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "0.36 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                    Image = { Color = "0.815 0.776 0.741 0", Sprite = "assets/content/ui/ui.background.transparent.radial.psd" }
                }, InitialLayer + $".Shop.{i}");


                var image = !string.IsNullOrEmpty(item.ImageURL) ? item.ImageURL : item.defaultItem.ShortName + 128;

                container.Add(new CuiElement
                {
                    Parent = InitialLayer + $".Shop.{i}",
                    Components =
                    {
                        new CuiRawImageComponent {Png            = (string) ImageLibrary?.Call("GetImage",image) },
                        new CuiRectTransformComponent {AnchorMin = "0 0.08", AnchorMax = "0.34 0.92", OffsetMin = "10 5", OffsetMax = "-10 -5"}
                    }
                });

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.36 0.7", AnchorMax = "1 1", OffsetMin = "-3 0", OffsetMax = "0 0" },
                    Text = { Text = item.Title, Align = TextAnchor.MiddleLeft, Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 0.6" }
                }, InitialLayer + $".Shop.{i}");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "80 11", OffsetMax = "0 0" },
                    Text = { Text = $"{item.NeedGold} шт.", Align = TextAnchor.MiddleLeft, Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "0.929 0.882 0.847 0.7" }
                }, InitialLayer + $".Shop.{i}");

                var color = amount >= item.NeedGold ? "0.8 0.7 0.741 0" : "0.815 0.776 0.741 0";

                var Tcolor = amount >= item.NeedGold ? "1 1 1 0.8" : "1 1 1 0.3";

                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = $"UI_TPBaraxolka buy {aa}", Material = "" },
                    Text = { Text = "Купить", Color = Tcolor, Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.72 0.1", AnchorMax = $"0.96 0.44" },
                }, InitialLayer + $".Shop.{i}");
                i++;
                aa++;
            }

            CuiHelper.DestroyUi(player, InitialLayer + ".Bottle");

            CuiHelper.AddUi(player, container);
        }

        ItemContainer.CanAcceptResult? CanAcceptItem(ItemContainer container, Item item, int pos)
        {
            var newItem = container.parent as Item;
            if (newItem == null) return null;

            if (newItem.info.shortname == "wrappedgift")
                return ItemContainer.CanAcceptResult.CannotAccept;
            return null;
        }
        [ChatCommand("baraxolka")]
        void asf(BasePlayer player)
        {
            DrawNPCUI(player);
        }

        public void DrawMenuPoints(BasePlayer player, MenuPoints choosed = null)
        {
            CuiHelper.DestroyUi(player, InitialLayer + ".Bottle");
            CuiHelper.DestroyUi(player, InitialLayer + ".Info");
            CuiHelper.DestroyUi(player, InitialLayer + ".Expedition");

            CuiElementContainer container = new CuiElementContainer();
/*
            float marginTop = -211;
            float originalHeight = 35;
            float freeHeight = 20;
            float padding = 5;*/

            container.Add(new CuiPanel()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = "0.24 0.45 0.90 0", Material = "" }
            }, InitialLayer + ".R", InitialLayer + ".MenuInfo");

            container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = $"-355 -228", OffsetMax = $"-265 -205" },
                    Button = { Command = "UI_TPBaraxolka info", Color = "1 1 1 0" },
                    Text = { Text = "ИНФОРМАЦИЯ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 11, Color = "1 1 1 0.6" }
                }, InitialLayer + ".C", InitialLayer + "inf");

            container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = $"-245 -226", OffsetMax = $"-198 -205" },
                    Button = { Command = "UI_TPBaraxolka expedition 0", Color = "1 1 1 0" },
                    Text = { Text = "ДРОП", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 11, Color = "1 1 1 0.6" }
                }, InitialLayer + ".C", InitialLayer + "drop");

            container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = $"-180 -228", OffsetMax = $"-107 -205" },
                    Button = { Command = "UI_TPBaraxolka bottle", Color = "1 1 1 0" },
                    Text = { Text = "ПОКУПКА", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 11, Color = "1 1 1 0.6" }
                }, InitialLayer + ".C", InitialLayer + "sukablyatbottlevodkanaxuirusskiyvodkaPonyalDaAAAA");

 

            updateBalance(player);


            CuiHelper.DestroyUi(player, InitialLayer + ".MenuInfo");

            CuiHelper.AddUi(player, container);
        }
        void updateBalance(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, InitialLayer + "BalanceTbanyaShval");

            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = $"-100 -228", OffsetMax = $"-10 -203" },
                Text = { Text = $"{(float) TPEconomic.Call("API_GET_BALANCE", player.userID)}xp", Align = TextAnchor.MiddleLeft, Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 0.8" }
            }, InitialLayer + $".C", InitialLayer + "BalanceTbanyaShval");

            CuiHelper.AddUi(player, container);
        }
        [ConsoleCommand("UI_TPBaraxolka")]
        void cmdMenuTPBaraxolka(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null) return;

            if (!args.HasArgs(1)) return;
            switch (args.Args[0])
            {
                case "menu":
                    int chooseIndex = -1;
                    if (!int.TryParse(args.Args[1], out chooseIndex)) return;

                    DrawMenuPoints(player);

                    break;

                case "bottle":
                    CuiHelper.DestroyUi(player, InitialLayer + ".Expedition");
                    CuiHelper.DestroyUi(player, InitialLayer + ".Info");
                    CreateBottleExchange(player);
                    break;
                case "info":
                    CuiHelper.DestroyUi(player, InitialLayer + ".Expedition");
                    CuiHelper.DestroyUi(player, InitialLayer + ".art");
                    CreateInfo(player);
                    break;
               

                

                case "expedition":
                    int page;
                    if (!int.TryParse(args.Args[1], out page)) page = 0;
                    CuiHelper.DestroyUi(player, InitialLayer + ".Info");
                    CuiHelper.DestroyUi(player, InitialLayer + ".art");
                    CreateInfoJson(player, page);
                    break;

                case "startLoot":
                    CuiHelper.DestroyUi(player, "MainUI_TPBaraxolka");
                    ExpeditionExceptionBox box = ExpeditionExceptionBox.Spawn(player);
                    box.StartLoot();
                    break;
                case "sendLoot":
                    var entityLoot = player.inventory.loot;
                    if (entityLoot == null || entityLoot.entitySource.GetComponent<ExpeditionExceptionBox>() == null) return;
                    if (entityLoot.entitySource.GetComponent<ExpeditionExceptionBox>().PoitsInvectoryCount() < 1) return;

                    Dictionary<string, int> obmenList = DataObmen[player.userID];
                    foreach(var a in entityLoot.entitySource.GetComponent<ExpeditionExceptionBox>().storage.inventory.itemList)
                    {
                        if (obmenList.ContainsKey($"{a.info.shortname}"))
                        {
                            if(obmenList[a.info.shortname]+a.amount > config.expeditionSettings.ItemsAdded[a.info.shortname].maxCount)
                            {
                                player.ChatMessage($"Вы певышаете лимит {a.info.displayName.english}!\n{obmenList[a.info.shortname]} + {a.amount}/{config.expeditionSettings.ItemsAdded[a.info.shortname].maxCount}");
                                return;
                            }
                            obmenList[a.info.shortname] += a.amount;
                        }
                        else
                        {
                            if(a.amount > config.expeditionSettings.ItemsAdded[a.info.shortname].maxCount)
                            {
                                player.ChatMessage($"Вы певышаете лимит {a.info.displayName.english}!\n{a.amount}/{config.expeditionSettings.ItemsAdded[a.info.shortname].maxCount}");
                                return;
                            }
                            obmenList.Add(a.info.shortname, a.amount);
                        }
                    }
                      
                    entityLoot.entitySource.GetComponent<ExpeditionExceptionBox>().Close();
                    player.SendConsoleCommand("menu tpbaraxolka");
                    break;

                case "buy":
                    chooseIndex = -1;
                    if (!int.TryParse(args.Args[1], out chooseIndex)) return;
                    float amount = (float) TPEconomic.Call("API_GET_BALANCE", player.userID);
                    var buyItem = config.bottleSetting.CustomItemsShop.ElementAtOrDefault(chooseIndex);
                    if (buyItem == null) return;
                    if (amount < buyItem.NeedGold) 
                    {
                        CuiHelper.DestroyUi(player, "fdsfsdfasgdsag");
                        CuiElementContainer container = new CuiElementContainer();
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0.2 -0.5", AnchorMax = "0.78 0", OffsetMax = "0 0" },
                            Button = { Color = "1 1 1 0.03" },
                            Text = { Text = "НЕТ ДЕНЕГ НА БАЛАНСЕ", Align = TextAnchor.UpperCenter, Font = "robotocondensed-regular.ttf", FontSize = 18, Color = "0.929 0.882 0.847 1" }
                        }, InitialLayer + ".Bottle", "fdsfsdfasgdsag");
                        CuiHelper.AddUi(player, container);
                        timer.Once(2.0f, () =>
                        {
                            CuiHelper.DestroyUi(player, "fdsfsdfasgdsag");
                        });
                        return;
                    }
                    if (buyItem.Command.Count > 0)
                    {
                        foreach (var command in buyItem.Command)
                        {
                            Server.Command(command.Replace("%STEAMID%", player.UserIDString));
                        }
                        TPEconomic.Call("API_PUT_BALANCE_MINUS", player.userID, (float)buyItem.NeedGold);               
                        updateBalance(player);
                        break;
                    }
                    if (!string.IsNullOrEmpty(buyItem.defaultItem.ShortName))
                    {
                        var giveItem = ItemManager.CreateByName(buyItem.defaultItem.ShortName, buyItem.defaultItem.MinAmount, buyItem.defaultItem.SkinID);
                        player.GiveItem(giveItem, BaseEntity.GiveItemReason.Generic);
                        TPEconomic.Call("API_PUT_BALANCE_MINUS", player.userID, (float)buyItem.NeedGold);                    
                        updateBalance(player);
                        break;
                    }
                    SendReply(player, $"Ошибка");
                    break;

                case "close":
                    if (com != null && com.OpenInterface.Contains(player))
                        com.OpenInterface.Remove(player);
                    CuiHelper.DestroyUi(player, External);
                    CuiHelper.DestroyUi(player, "UI_TPBaraxolka_External" + ".Mood1" + ".panel");
                    break;
            }
        }

        public ulong ContainerID = 9876778;

        object CanLootEntity(BasePlayer player, BaseEntity container)
        {
            if (player == null || container == null) return null;
            if (container.OwnerID == ContainerID)
            {
                DrawNPCUI(player);
                com.OpenInterface.Add(player);
                return false;
            }
            return null;
        }

        void FindPositions()
        {
            var bandit = UnityEngine.Object.FindObjectsOfType<MonumentInfo>().FirstOrDefault(p => p.name.Contains("bandit"));
            if (bandit != null)
            {
                string chairprefab = "assets/bundled/prefabs/static/chair.invisible.static.prefab";
                var pos1 = bandit.transform.position + bandit.transform.rotation * new Vector3(-24.2f, 2f, 37.2f);

                string lump = "assets/prefabs/deployable/lantern/lantern.deployed.prefab";
                var sp1 = GameManager.server.CreateEntity(lump, bandit.transform.position + bandit.transform.rotation * new Vector3(-24.1f, 2.7f, 36.2f), bandit.transform.rotation * new Quaternion(0f, 2f, 0f, -0.2f), true);
                sp1.enableSaving = false;
                UnityEngine.Object.Destroy(sp1.GetComponent<DestroyOnGroundMissing>());
                UnityEngine.Object.Destroy(sp1.GetComponent<GroundWatch>());
                sp1.Spawn();
                sp1.SetFlag(BaseEntity.Flags.On, true);
                sp1.SetFlag(BaseEntity.Flags.Busy, true);
                sp1.SendNetworkUpdate();

                string cump = "assets/prefabs/deployable/fireplace/fireplace.deployed.prefab";
                var sp2 = GameManager.server.CreateEntity(cump, bandit.transform.position + bandit.transform.rotation * new Vector3(-21f, 2f, 37f), bandit.transform.rotation * new Quaternion(0f, 0.2f, 0f, -0.2f), true);
                sp2.enableSaving = false;
                UnityEngine.Object.Destroy(sp2.GetComponent<DestroyOnGroundMissing>());
                UnityEngine.Object.Destroy(sp2.GetComponent<GroundWatch>());
                sp2.Spawn();
                sp2.SetFlag(BaseEntity.Flags.On, true);
                sp2.SetFlag(BaseEntity.Flags.Busy, true);
                sp2.SendNetworkUpdate();
                string photou = "assets/prefabs/deployable/signs/sign.pictureframe.landscape.prefab";
                var photo = GameManager.server.CreateEntity(photou, bandit.transform.position + bandit.transform.rotation * new Vector3(-24.1f, 3.6f, 35.7f), bandit.transform.rotation * new Quaternion(0f, 0f, 0f, -0.2f), true);
                photo.enableSaving = false;
                photo.Spawn();
                photo.SetFlag(BaseEntity.Flags.Busy, true);
                var sp3 = GameManager.server.CreateEntity("assets/prefabs/deployable/rug/rug.deployed.prefab", bandit.transform.position + bandit.transform.rotation * new Vector3(-24.6f, 1.9f, 37.5f), bandit.transform.rotation * new Quaternion(0f, 0.2f, 0f, -0.2f), true);
                sp3.Spawn();
                sp3.SetFlag(BaseEntity.Flags.Busy, true);
                UnityEngine.Object.Destroy(sp3.GetComponent<DestroyOnGroundMissing>());
                UnityEngine.Object.Destroy(sp3.GetComponent<GroundWatch>());
                sp3.skinID = 871072156;
                sp3.SendNetworkUpdate();
                var chutemount = GameManager.server.CreateEntity(chairprefab, pos1, bandit.transform.rotation * new Quaternion(0f, 0.9f, 0f, -0.2f), true);
                chutemount.Spawn();
                SpawnNPC(pos1);
                var hasmount = chutemount.GetComponent<BaseMountable>();
                hasmount.MountPlayer(newPlayer);
                var fuel = GameManager.server.CreateEntity("assets/prefabs/deployable/quarry/fuelstorage.prefab", pos1 + new Vector3(0.3f, 0, 0), new Quaternion(0, 0, 90, 90), true);
                fuel.Spawn();
                fuel.OwnerID = ContainerID;
                fuel.SendNetworkUpdateImmediate();
                Item x = ItemManager.CreateByPartialName("targeting.computer", 1);

                BaseEntity dropped = x.Drop(photo.transform.position, Vector3.down, bandit.transform.rotation);
                dropped.SetParent(photo);
                UnityEngine.Object.Destroy(dropped.gameObject.GetComponent<Rigidbody>());
                dropped.transform.localPosition = new Vector3(-0.5f, -0.9f, 0.7f);

                dropped.transform.rotation = photo.transform.rotation;

                dropped.transform.eulerAngles = new Vector3(
                    dropped.transform.eulerAngles.x,
                    dropped.transform.eulerAngles.y + 190,
                    dropped.transform.eulerAngles.z
                );
                WorldItem worldItem = dropped as WorldItem;
                worldItem.allowPickup = false;
                worldItem.SetFlag(BaseEntity.Flags.Busy, true);
                dropped.GetComponent<DroppedItem>().CancelInvoke(new Action(dropped.GetComponent<DroppedItem>().IdleDestroy));
                dropped.SendNetworkUpdate();
                Item x1 = ItemManager.CreateByPartialName("shotgun.waterpipe", 1);
                BaseEntity dropped1 = x1.Drop(photo.transform.position, Vector3.down, bandit.transform.rotation);
                dropped1.SetParent(photo);
                UnityEngine.Object.Destroy(dropped1.gameObject.GetComponent<Rigidbody>());
                dropped.GetComponent<DroppedItem>().CancelInvoke(new Action(dropped1.GetComponent<DroppedItem>().IdleDestroy));

                dropped1.transform.localPosition = new Vector3(-0.9f, -0.88f, 1f);
                dropped1.transform.rotation = photo.transform.rotation;

                dropped1.transform.eulerAngles = new Vector3(
                     dropped1.transform.eulerAngles.x,
                     dropped1.transform.eulerAngles.y + 240,
                     dropped1.transform.eulerAngles.z + 90
                 );
                WorldItem worldItem1 = dropped1 as WorldItem;
                worldItem1.allowPickup = false;
                worldItem1.SetFlag(BaseEntity.Flags.Busy, true);

                BaseEntityList.Add(sp1);
                BaseEntityList.Add(sp2);
                BaseEntityList.Add(sp3);
                BaseEntityList.Add(fuel);
                BaseEntityList.Add(chutemount);
                BaseEntityList.Add(photo);

                if (photo.GetComponent<Signage>() != null)
                    FixSignage(photo.GetComponent<Signage>());
            }
        }

        private void FixSignage(Signage sign)
        {
            timer.Once(5f, () =>
            {
                sign.textureIDs[0] = FileStorage.server.Store(ImageBytes, FileStorage.Type.png, sign.net.ID);
                sign.SendNetworkUpdateImmediate();
            });
        }

        private static byte[] ImageBytes;

        private IEnumerator DownloadImage(string url)
        {
            UnityWebRequest www = UnityWebRequest.Get(url);

            yield return www.SendWebRequest();
            if (www.isNetworkError || www.isHttpError)
            {
                www.Dispose();
                yield break;
            }

            Texture2D texture = new Texture2D(2, 2);
            texture.LoadImage(www.downloadHandler.data);
            if (texture != null)
            {
                ImageBytes = texture.EncodeToPNG();
            }

            www.Dispose();
        }

        public static TPBaraxolka ins;

        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Благодарим за покупку плагина на сайте TopPlugin.ru. Если вы передадите этот плагин сторонним лицам знайте - это лишает вас гарантированных обновлений!");
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < new VersionNumber(1, 0, 1))
            {
                PrintWarning("Config update detected! Updating config values...");
        

                PrintWarning("Config update completed!");
            }
            config.PluginVersion = Version;
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        public class MenuPoints
        {
            [JsonProperty("Название пункта меню в UI")]
            public string DisplayName;

            [JsonProperty("Выполняемая команда")]
            public string DrawMethod;

            [JsonProperty("Титл страницы")]
            public string Title;


            [JsonProperty("Диалог при нажатии (Пустое ничего не будет)")]
            public string Sound = "";

        }

        class PluginConfig
        {
            [JsonProperty("Видео обзор")]
	    public string urlvido;

            [JsonProperty("Настройка продажи предметов")]
            public BottleSetting bottleSetting;

            [JsonProperty("Настройка покупки")]
            public ExpeditionSettings expeditionSettings;


          

            [JsonProperty("Configuration Version")]
            public VersionNumber PluginVersion = new VersionNumber();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    urlvido = "https://cdn.discordapp.com/attachments/1169468253920301177/1195917678783778956/RUST_2024.01.14_-_04.45.13.06_2.mp4",
                    bottleSetting = new BottleSetting(),
                    expeditionSettings = new ExpeditionSettings(),
                    PluginVersion = new VersionNumber(),
                   
                };
            }
        }


        public class CustomShopItems
        {
            [JsonProperty("Название предмета в UI")]
            public string Title;

            [JsonProperty("Выполняемая команда (Если это предмет оставь ПУСТЫМ! %STEAMID% - индификатор игрока)")]
            public List<string> Command = new List<string>();

            [JsonProperty("Кастомное изображение предмета (Если у игровой предмет можно не указывать)")]
            public string ImageURL;

            [JsonProperty("Нужное количество золота на покупку данного предмета")]
            public int NeedGold;

            [JsonProperty("Настройка предмета (Если не привилегия трогать не нужно)")]
            public DefaultItem defaultItem;
        }

        public class DefaultItem
        {
            [JsonProperty("Shortname предмета")]
            public string ShortName;
            [JsonProperty("Количество")]
            public int MinAmount;
            [JsonProperty("SkinID предмета")]
            public ulong SkinID;
            [JsonProperty("Имя предмета при создании (Оставте поле постым чтобы использовать стандартное название итема)")]
            public string Name;
            [JsonProperty("Это чертеж")]
            public bool IsBlueprnt;
        }

    

        internal class ItemsAddSetting
        {
            [JsonProperty("Количество очков за предмет")]
            public float amount;

            [JsonProperty("Максимальное количество предмета")]
            public int maxCount;
        }

        internal class ArtefactsItems
        {
            [JsonProperty("ShortName предмета")] public string ShortName;
            [JsonProperty("SkinID предмета")] public ulong SkinID;
            [JsonProperty("Ссылка на изображение")] public string ImageURL;
        }

        public class BottleSetting
        {
            [JsonProperty("Список предметов на обмен")]
            public List<CustomShopItems> CustomItemsShop = new List<CustomShopItems>();
        }
  
        public class ExpeditionSettings
        {
            [JsonProperty("Список предметов, которые игрок может положить")]
            public Dictionary<string, ItemsAddSetting> ItemsAdded;
            
        }
    
        [ChatCommand("say")]
        void cmdBotSay(BasePlayer player, string com, string[] args)
        {
            if (!player.IsAdmin) return;
            if (args.Length < 1) return;

            int count;
            if (!int.TryParse(args[1], out count)) return;

            var messages = Sounds[args[0]].Sounds[count];
            foreach (var f in messages)
            {
                SendToPlayer(player, newPlayer.net.ID.Value, f);
            }
        }

        #region TPBaraxolka
    
        private void GiveItem(BasePlayer player, Item item, BaseEntity.GiveItemReason reason = 0)
        {
            if (reason == BaseEntity.GiveItemReason.ResourceHarvested)
                //player.stats.Add(string.Format("harvest.{0}", item.info.shortname), item.amount, Stats.Server | Stats.Life);
                player.stats.Add(string.Format("harvest.{0}", item.info.shortname), item.amount, Stats.Server);

            int num = item.amount;
            if (!GiveItem(player.inventory, item, null))
            {
                item.Drop(player.inventory.containerMain.dropPosition, player.inventory.containerMain.dropVelocity, new Quaternion());
                return;
            }

            if (string.IsNullOrEmpty(item.name))
            {
                player.Command("note.inv", new object[] { item.info.itemid, num, string.Empty, (int)reason });
                return;
            }

            player.Command("note.inv", new object[] { item.info.itemid, num, item.name, (int)reason });
        }

        private bool GiveItem(PlayerInventory inv, Item item, ItemContainer container = null)
        {
            if (item == null)
                return false;

            int num = -1;
            GetIdealPickupContainer(inv, item, ref container, ref num);
            if (container != null && MoveToContainer(item, container, num, true))
                return true;

            if (MoveToContainer(item, inv.containerMain, -1, true))
                return true;

            if (MoveToContainer(item, inv.containerBelt, -1, true))
                return true;

            return false;
        }

        private static bool MoveToContainer(Item itemBase, ItemContainer newcontainer, int iTargetPos = -1, bool allowStack = true)
        {
            bool container;
            Quaternion quaternion;
            using (TimeWarning timeWarning = TimeWarning.New("MoveToContainer", 0))
            {
                var itemContainer = itemBase.parent;
                if (!itemBase.CanMoveTo(newcontainer, iTargetPos))
                    container = false;
                else
                    if (iTargetPos >= 0 && newcontainer.SlotTaken(itemBase, iTargetPos))
                {
                    Item slot = newcontainer.GetSlot(iTargetPos);

                    if (allowStack)
                    {
                        int num = slot.MaxStackable();
                        if (slot.CanStack(itemBase))
                        {
                            if (slot.amount < num)
                            {
                                slot.amount += itemBase.amount;
                                slot.MarkDirty();
                                itemBase.RemoveFromWorld();
                                itemBase.RemoveFromContainer();
                                itemBase.Remove(0f);
                                int num1 = slot.amount - num;
                                if (num1 > 0)
                                {
                                    Item item = slot.SplitItem(num1);
                                    if (item != null && !MoveToContainer(item, newcontainer, -1, false) && (itemContainer == null || !MoveToContainer(item, itemContainer, -1, true)))
                                    {
                                        Vector3 vector3 = newcontainer.dropPosition;
                                        Vector3 vector31 = newcontainer.dropVelocity;
                                        quaternion = new Quaternion();
                                        item.Drop(vector3, vector31, quaternion);
                                    }
                                    slot.amount = num;
                                }
                                container = true;
                                return container;
                            }
                            else
                            {
                                container = false;
                                return container;
                            }
                        }
                    }

                    if (itemBase.parent == null)
                        container = false;
                    else
                    {
                        ItemContainer itemContainer1 = itemBase.parent;
                        int num2 = itemBase.position;
                        if (slot.CanMoveTo(itemContainer1, num2))
                        {
                            itemBase.RemoveFromContainer();
                            slot.RemoveFromContainer();
                            MoveToContainer(slot, itemContainer1, num2, true);
                            container = MoveToContainer(itemBase, newcontainer, iTargetPos, true);
                        }
                        else
                            container = false;
                    }
                }
                else
                        if (itemBase.parent != newcontainer)
                {
                    if (iTargetPos == -1 & allowStack && itemBase.info.stackable > 1)
                    {
                        var item1 = newcontainer.itemList.Where(x => x != null && x.info.itemid == itemBase.info.itemid && x.skin == itemBase.skin).OrderBy(x => x.amount).FirstOrDefault();
                        if (item1 != null && item1.CanStack(itemBase))
                        {
                            int num3 = item1.MaxStackable();
                            if (item1.amount < num3)
                            {
                                var total = item1.amount + itemBase.amount;
                                if (total <= num3)
                                {
                                    item1.amount += itemBase.amount;
                                    item1.MarkDirty();
                                    itemBase.RemoveFromWorld();
                                    itemBase.RemoveFromContainer();
                                    itemBase.Remove(0f);
                                    container = true;
                                    return container;
                                }
                                else
                                {
                                    item1.amount = item1.MaxStackable();
                                    item1.MarkDirty();
                                    itemBase.amount = total - item1.MaxStackable();
                                    itemBase.MarkDirty();
                                    container = MoveToContainer(itemBase, newcontainer, iTargetPos, allowStack);
                                    return container;
                                }
                            }
                        }
                    }

                    if (newcontainer.maxStackSize > 0 && newcontainer.maxStackSize < itemBase.amount)
                    {
                        Item item2 = itemBase.SplitItem(newcontainer.maxStackSize);
                        if (item2 != null && !MoveToContainer(item2, newcontainer, iTargetPos, false) && (itemContainer == null || !MoveToContainer(item2, itemContainer, -1, true)))
                        {
                            Vector3 vector32 = newcontainer.dropPosition;
                            Vector3 vector33 = newcontainer.dropVelocity;
                            quaternion = new Quaternion();
                            item2.Drop(vector32, vector33, quaternion);
                        }
                        container = true;
                    }
                    else
                        if (newcontainer.CanAccept(itemBase))
                    {
                        itemBase.RemoveFromContainer();
                        itemBase.RemoveFromWorld();
                        itemBase.position = iTargetPos;
                        itemBase.SetParent(newcontainer);
                        container = true;
                    }
                    else
                        container = false;
                }
                else
                            if (iTargetPos < 0 || iTargetPos == itemBase.position || itemBase.parent.SlotTaken(itemBase, iTargetPos))
                    container = false;
                else
                {
                    itemBase.position = iTargetPos;
                    itemBase.MarkDirty();
                    container = true;
                }
            }

            return container;
        }

        private void GetIdealPickupContainer(PlayerInventory inv, Item item, ref ItemContainer container, ref int position)
        {
            if (item.info.stackable > 1)
            {
                if (inv.containerBelt != null && inv.containerBelt.FindItemByItemID(item.info.itemid) != null)
                {
                    container = inv.containerBelt;
                    return;
                }

                if (inv.containerMain != null && inv.containerMain.FindItemByItemID(item.info.itemid) != null)
                {
                    container = inv.containerMain;
                    return;
                }
            }

            if (!item.info.isUsable || item.info.HasFlag(ItemDefinition.Flag.NotStraightToBelt))
                return;

            container = inv.containerBelt;
        }

        public BasePlayer newPlayer = null;
        FatherComponent com = null;

        [PluginReference] Plugin IQKits, RustStore;

        private void SpawnNPC(Vector3 positon)
        {
            newPlayer = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", positon, new Quaternion()).ToPlayer();
            newPlayer.Spawn();
            com = newPlayer.gameObject.AddComponent<FatherComponent>();
            newPlayer.displayName = "БАТЯ";
            ItemManager.Create(ItemManager.FindItemDefinition("pants"), 1, 960252273).MoveToContainer(newPlayer.inventory.containerWear);
            ItemManager.Create(ItemManager.FindItemDefinition("hoodie"), 1, 959641236).MoveToContainer(newPlayer.inventory.containerWear);
            ItemManager.Create(ItemManager.FindItemDefinition("shoes.boots"), 1, 962503020).MoveToContainer(newPlayer.inventory.containerWear);
            newPlayer.SendNetworkUpdateImmediate();
            IQKits?.Call("ParseAndGive", newPlayer, "tpbaraxolka");
        }

        void Unload()
        {
            foreach (var ent in BaseEntityList)
            {
                ent.Kill();
            }
            BaseEntityList.Clear();
            if (newPlayer != null)
            {
                if (newPlayer.GetComponent<FatherComponent>() != null)
                {
                    newPlayer.GetComponent<FatherComponent>().SaveData();
                    UnityEngine.Component.Destroy(newPlayer.GetComponent<FatherComponent>());
                }
                newPlayer.AdminKill();
            }

            var objects = UnityEngine.Object.FindObjectsOfType<ExpeditionExceptionBox>();
            if (objects != null)
                foreach (var component in objects)
                    UnityEngine.Object.Destroy(component);

            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, External);
                CuiHelper.DestroyUi(player, "ExpeditionExceptionBox_UI");
                CuiHelper.DestroyUi(player, External + ".Mood1" + ".panel");
                CuiHelper.DestroyUi(player, Layer95);

            }
            WriteData();
        }

        string GetImageInMood()
        {
            switch (com.mood)
            {
                case FatherComponent.Mood.Neutral:
                    return "https://i.imgur.com/yLsGJrM.png";
                case FatherComponent.Mood.Kind:
                    return "https://i.imgur.com/CidcicJ.png";
                case FatherComponent.Mood.Evil:
                    return "https://i.imgur.com/ZS57k7Y.png";
            }
            return "https://i.imgur.com/yLsGJrM.png";
        }

        void RegisteredDataUser(UInt64 player)
        {
            if (!player.IsSteamId()) return;
            if (!DataObmen.ContainsKey(player))
                DataObmen.Add(player, new Dictionary<string, int>());
        }
       

        void OnPlayerConnected(BasePlayer player)
        {
            if (player == null) return;
            RegisteredDataUser(player.userID);

            if (player.IsReceivingSnapshot)
            {
                timer.Once(1f, () => OnPlayerConnected(player));
                return;
            }
            CuiHelper.DestroyUi(player, External + ".Mood1" + ".panel");

            if (com != null && com.EndExpeditions.ContainsKey(player.userID))
                CreateInfoPlayer(player, false);
        }
        public List<ulong> ArtefactsList = new List<ulong>();


        private void OnServerShutdown() => Unload();
        private void Init() => ReadData();

        [JsonProperty("Список обмена")] public Dictionary<ulong, Dictionary<string, int>> DataObmen = new Dictionary<ulong, Dictionary<string, int>>();
        void ReadData()
        {
            DataObmen = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, Dictionary<string, int>>>("TPBaraxolka/Obmen");
        }
        void WriteData() {
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("TPBaraxolka/Obmen", DataObmen);
        }


        void sendmoney(BasePlayer player, float money)
        {
            TPEconomic.Call("API_PUT_BALANCE_PLUS", player.userID, money);
        }

        class FatherComponent : FacepunchBehaviour
        {
            public BasePlayer player;
            SphereCollider sphereCollider;
            public BasePlayer target = null;
            public Dictionary<ulong, ExpeditionPlayer> CurrentExpeditions = new Dictionary<ulong, ExpeditionPlayer>();
            public Dictionary<ulong, float> EndExpeditions = new Dictionary<ulong, float>();


            public List<BasePlayer> OpenInterface = new List<BasePlayer>();


            public void SaveData()
            {
                Interface.Oxide.DataFileSystem.WriteObject("TPBaraxolka/CurrentExpeditions", CurrentExpeditions);
                Interface.Oxide.DataFileSystem.WriteObject("TPBaraxolka/EndExpeditions", EndExpeditions);
                Interface.Oxide.DataFileSystem.WriteObject("TPBaraxolka/Artefacts", ins.ArtefactsList);

            }

            public void LoadData()
            {
                try
                {
                    CurrentExpeditions = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, ExpeditionPlayer>>("TPBaraxolka/CurrentExpeditions");
                    EndExpeditions = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, float>>("TPBaraxolka/EndExpeditions");
                    ins.ArtefactsList = Interface.Oxide.DataFileSystem.ReadObject<List<ulong>>("TPBaraxolka/Artefacts");

                }
                catch
                {
                    CurrentExpeditions = new Dictionary<ulong, ExpeditionPlayer>();
                    EndExpeditions = new Dictionary<ulong, float>();
                    ins.ArtefactsList = new List<ulong>();
                }
            }

            public Mood mood;

            public class ExpeditionPlayer
            {
                public double EndTime;
                public float Points;
                public bool Ending;
            }

          
            void SendMessages(ulong Player)
            {
                var bsPlayer = BasePlayer.FindByID(Player);
                if (bsPlayer == null || !bsPlayer.IsConnected) return;
            }


            void ExpeditionHandler()
            {
                foreach (var player in CurrentExpeditions)
                {
                    player.Value.EndTime--;
                    if (player.Value.EndTime <= 0)
                    {
                        EndExpeditions.Add(player.Key, player.Value.Points);
                        ins.NextTick(() => CurrentExpeditions.Remove(player.Key));

                        if (BasePlayer.FindByID(player.Key) != null)
                            ins.CreateInfoPlayer(BasePlayer.FindByID(player.Key), OpenInterface.Contains(BasePlayer.FindByID(player.Key)));
                        continue;
                    }

                }

                foreach (var bsPLayer in OpenInterface)
                {
                    CuiHelper.DestroyUi(player, "UI_TPBaraxolka_External" + ".Mood1" + ".panel");
                    if (CurrentExpeditions.ContainsKey(bsPLayer.userID))
                    {

                        if (CurrentExpeditions[bsPLayer.userID].EndTime <= 0)
                        {
                            ins.CreateInfoPlayer(player, true);
                        }
                        else
                            CreateInfoPlayer(bsPLayer, CurrentExpeditions[bsPLayer.userID].EndTime);


                    }


                }
            }

            void CreateInfoPlayer(BasePlayer player, double time)
            {
                CuiElementContainer container = new CuiElementContainer();
                container.Add(new CuiElement
                {
                    Name = "UI_TPBaraxolka_External" + ".Mood1" + ".panel",
                    Parent = "Overlay",
                    Components =
                        {
                            new CuiImageComponent { Color =  "0.235 0.227 0.180 0.6" , Sprite = "assets/content/ui/ui.background.transparent.linear.psd"},
                            new CuiRectTransformComponent {AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-240 -81", OffsetMax = "-60 -30"}
                        }
                });



                container.Add(new CuiElement
                {
                    Parent = "UI_TPBaraxolka_External" + ".Mood1" + ".panel",
                    Name = "UI_TPBaraxolka_External" + ".Mood1",
                    Components =
                        {
                            new CuiRawImageComponent {Png = (string)ins.ImageLibrary?.Call("GetImage", "https://i.imgur.com/ghyCq0Q.png"), Color = "0.929 0.882 0.847 1"},
                            new CuiRectTransformComponent {AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-30 -60", OffsetMax = "50 20"}
                        }
                });



                container.Add(new CuiElement
                {
                    Parent = "UI_TPBaraxolka_External" + ".Mood1" + ".panel",
                    Components =
                        {
                            new CuiTextComponent { Color = "0.929 0.882 0.847 0.5", Text = $"<color=#EDE1D8>ОЖИДАНИЕ ПОСЫЛКИ</color>", Align = TextAnchor.UpperLeft /*,Font="robotocondensed-regular.ttf"*/},
                            new CuiRectTransformComponent {AnchorMin = "0.03 0", AnchorMax = "1 0.9"}
                        }
                });

                container.Add(new CuiElement
                {
                    Parent = "UI_TPBaraxolka_External" + ".Mood1" + ".panel",
                    Components =
                        {
                            new CuiTextComponent {Color = "0.929 0.882 0.847 0.4", Text = $"ОСТАЛОСЬ ВРЕМЕНИ: {FormatShortTime(TimeSpan.FromSeconds(time))}", Align = TextAnchor.MiddleLeft ,Font="robotocondensed-regular.ttf", FontSize = 12},
                            new CuiRectTransformComponent {AnchorMin = "0.03 0", AnchorMax = "1 0.8"}
                        }
                });


                CuiHelper.DestroyUi(player, "UI_TPBaraxolka_External" + ".Mood1" + ".panel");

                CuiHelper.AddUi(player, container);
            }


            public static string FormatShortTime(TimeSpan time)
            {
                if (time.Hours != 0)
                    return time.ToString(@"hh\:mm\:ss");
                if (time.Minutes != 0)
                    return time.ToString(@"mm\:ss");
                if (time.Seconds != 0)
                    return time.ToString(@"mm\:ss");
                return time.ToString(@"hh\:mm\:ss");
            }



            public enum Mood
            {
                Neutral,
                Kind,
                Evil
            }

            void Awake()
            {
                player = GetComponent<BasePlayer>();
                LoadData();
                sphereCollider = gameObject.AddComponent<SphereCollider>();
                sphereCollider.isTrigger = true;
                sphereCollider.radius = 2.5f;
                sphereCollider.gameObject.layer = (int)Layer.Reserved1;
                ChangeInMood();
                InvokeRepeating("ChangeInMood", 7200, 7200);
                InvokeRepeating("ExpeditionHandler", 1, 1);
            }

            void ChangeInMood()
            {
                var random = UnityEngine.Random.Range(-1, 3);
                switch (random)
                {
                    case 0:
                        mood = Mood.Neutral;
                        break;
                    case 1:
                        mood = Mood.Kind;
                        break;
                    case 2:
                        mood = Mood.Evil;
                        break;
                }
            }

            private void OnTriggerEnter(Collider other)
            {
                var otherPlayer = other.gameObject.GetComponent<BasePlayer>();
                if (otherPlayer == null || target != null)
                    return;

                if (player.IsVisible(otherPlayer.transform.position))
                    ins.GetSoundToPlayer(otherPlayer, player.net.ID.Value, "hi");

            }

            private void OnTriggerExit(Collider other)
            {
                var otherPlayer = other.gameObject.GetComponent<BasePlayer>();
                if (otherPlayer == null)
                    return;
                if (player.IsVisible(otherPlayer.transform.position))
                    ins.GetSoundToPlayer(otherPlayer, player.net.ID.Value, "buy");
            }

            void Puts(string messages) => ins.Puts(messages);
            public void Destroy() => Destroy(this);
        }
        #endregion

        #region Sound
        public Dictionary<string, SoundData> Sounds = new Dictionary<string, SoundData>();

        public class SoundData
        {
            public List<List<byte[]>> Sounds = new List<List<byte[]>>();

            public List<byte[]> RandomSound()
              => Sounds.GetRandom();
        }

        Dictionary<ulong, bool> status = new Dictionary<ulong, bool>();
        public List<byte[]> timed = new List<byte[]>();

        private void GetSoundToPlayer(BasePlayer player, ulong netid, string name)
        {
            if (!Sounds.ContainsKey(name))
            {
                PrintError($"Не могу найти звук с именем {name}");
            }
            else
            {
                if (player != null)
                {
                    foreach (var f in Sounds[name].RandomSound())
                    {
                        SendToPlayer(player, netid, f);
                    }
                }
            }
        }

        public void SendToPlayer(BasePlayer player, ulong netid, byte[] data)
        {
            if (!Net.sv.IsConnected())
                return;

            NetWrite netWrite = Net.sv.StartWrite();
            

            netWrite.PacketID(Network.Message.Type.VoiceData);
            netWrite.UInt32(Convert.ToUInt32(netid));
            netWrite.BytesWithSize(data);
            netWrite.Send(new Network.SendInfo(player.Connection) { priority = Network.Priority.Immediate });
        }

        void LoadSounds()
        {
            try
            {
                Sounds = Interface.GetMod().DataFileSystem.ReadObject<Dictionary<string, SoundData>>("TPBaraxolka/Sounds");
            }
            catch
            {
                Sounds = new Dictionary<string, SoundData>();
            }
        }
        private void SaveSoundData() => Interface.Oxide.DataFileSystem.WriteObject("TPBaraxolka/Sounds", Sounds);

        #endregion

        object OnPlayerVoice(BasePlayer player, byte[] data)
        {
            if (player != null && status.ContainsKey(player.userID))
            {
                timed.Add(data);
            }
            return null;
        }


        [ChatCommand("sound")]
        void startcmd(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin) return;
            switch (args[0].ToLower())
            {
                case "start":
                    {
                        if (!status.ContainsKey(player.userID))
                        {
                            status.Add(player.userID, true);
                            SendReply(player, "Запись включена говорите в микрофон");
                            return;
                        }

                        if (status.ContainsKey(player.userID))
                        {
                            SendReply(player, "Запись уже идёт");
                            return;
                        }

                        if (!status[player.userID])
                        {
                            SendReply(player, "Запись уже сделана сохраните её");
                        }

                        break;
                    }
                case "clear":
                    {
                        if (status.ContainsKey(player.userID))
                        {
                            timed.Clear();
                            SendReply(player, "Запись стёрта попробуйте ещё");
                        }
                        else
                        {
                            SendReply(player, "Вы не начали запись");
                        }
                        break;
                    }
                case "stop":
                    {
                        if (status.ContainsKey(player.userID))
                        {
                            status[player.userID] = false;
                            SendReply(player, "Запись остановлена вы можете сохранить её");
                        }
                        else
                        {
                            SendReply(player, "Вы не начали запись");
                        }

                        break;
                    }
                case "save":
                    {
                        if (args.Length < 2)
                        {
                            SendReply(player, "Введите название записи");
                            return;
                        }

                        if (!status.ContainsKey(player.userID))
                        {
                            SendReply(player, "Вы ничего не записали");
                            return;
                        }

                        if (!status[player.userID])
                        {
                            status.Remove(player.userID);
                            if (Sounds.ContainsKey(args[1]))
                            {
                                var sounds = Sounds[args[1]];
                                sounds.Sounds.Add(timed);
                            }
                            else
                            {
                                Sounds.Add(args[1], new SoundData());
                                Sounds[args[1]].Sounds.Add(timed);
                            }
                            SaveSoundData();
                            timed.Clear();
                            SendReply(player, "Запись успешно сохранена");
                        }
                        break;
                    }
                case "delete":
                    {
                        if (!Sounds.ContainsKey(args[1]))
                        {
                            SendReply(player, "Нету закой записи");
                            return;
                        }

                        Sounds.Remove(args[1]);
                        SendReply(player, $"Запись с названием {args[1]} была удалена");
                        break;
                    }
                case "play":
                    {
                        if (!Sounds.ContainsKey(args[1]))
                        {
                            SendReply(player, "Нету такой сохраненной записи");
                            return;
                        }
                        GetSoundToPlayer(player, player.net.ID.Value, args[1]);
                        break;
                    }
            }
        }


        class Position
        {
            public float Xmin;
            public float Xmax;
            public float Ymin;
            public float Ymax;

            public string AnchorMin =>
                $"{Math.Round(Xmin, 4).ToString(CultureInfo.InvariantCulture)} {Math.Round(Ymin, 4).ToString(CultureInfo.InvariantCulture)}";
            public string AnchorMax =>
                $"{Math.Round(Xmax, 4).ToString(CultureInfo.InvariantCulture)} {Math.Round(Ymax, 4).ToString(CultureInfo.InvariantCulture)}";

            public override string ToString()
            {
                return $"----------\nAmin:{AnchorMin}\nAmax:{AnchorMax}\n----------";
            }
        }

        [SuppressMessage("ReSharper", "CompareOfFloatsByEqualityOperator")]
        private static List<Position> GetPositions(int colums, int rows, float colPadding = 0, float rowPadding = 0, bool columsFirst = false)
        {
            if (colums == 0)
                throw new ArgumentException("Can't create positions for gui!", nameof(colums));
            if (rows == 0)
                throw new ArgumentException("Can't create positions for gui!", nameof(rows));
            List<Position> result = new List<Position>();
            result.Clear();
            var colsDiv = 1f / colums;
            var rowsDiv = 1f / rows;
            if (colPadding == 0) colPadding = colsDiv / 2;
            if (rowPadding == 0) rowPadding = rowsDiv / 2;
            if (!columsFirst)
                for (int j = rows; j >= 1; j--)
                {
                    for (int i = 1; i <= colums; i++)
                    {
                        Position pos = new Position
                        {
                            Xmin = (i - 1) * colsDiv + colPadding / 2f,
                            Xmax = i * colsDiv - colPadding / 2f,
                            Ymin = (j - 1) * rowsDiv + rowPadding / 2f,
                            Ymax = j * rowsDiv - rowPadding / 2f
                        };
                        result.Add(pos);
                    }
                }
            else
                for (int i = 1; i <= colums; i++)
                {
                    for (int j = rows; j >= 1; j--)
                    {
                        Position pos = new Position
                        {
                            Xmin = (i - 1) * colsDiv + colPadding / 2f,
                            Xmax = i * colsDiv - colPadding / 2f,
                            Ymin = (j - 1) * rowsDiv + rowPadding / 2f,
                            Ymax = j * rowsDiv - rowPadding / 2f
                        };
                        result.Add(pos);
                    }
                }
            return result;
        }


        #region Expedition

        private static string _(string i)
        {
            return !string.IsNullOrEmpty(i)
                ? new string(i.Select(x =>
                    x >= 'a' && x <= 'z' ? (char)((x - 'a' + 13) % 26 + 'a') :
                    x >= 'A' && x <= 'Z' ? (char)((x - 'A' + 13) % 26 + 'A') : x).ToArray())
                : i;
        }


        public class ExpeditionExceptionBox : MonoBehaviour
        {
            public StorageContainer storage;
            public BasePlayer player;
            public string UIPanel = "ExpeditionExceptionBox_UI";

            public void Init(StorageContainer storage, BasePlayer owner)
            {
                this.storage = storage;
                this.player = owner;
            }
            public static ExpeditionExceptionBox Spawn(BasePlayer player)
            {
                player.EndLooting();
                var storage = SpawnContainer(player);
                var box = storage.gameObject.AddComponent<ExpeditionExceptionBox>();
                box.Init(storage, player);
                return box;
            }

            public static StorageContainer SpawnContainer(BasePlayer player)
            {
                var storage = GameManager.server.CreateEntity("assets/prefabs/deployable/large wood storage/box.wooden.large.prefab", player.transform.position - new Vector3(0, 250f + UnityEngine.Random.Range(-25f, 25f), 0)) as StorageContainer;
                if (storage == null) return null;
                if (!storage) return null;
                storage.panelName = "mailboxcontents";
                storage.SendMessage("SetDeployedBy", player, (SendMessageOptions)1);
                UnityEngine.Object.Destroy(storage.GetComponent<DestroyOnGroundMissing>());
                UnityEngine.Object.Destroy(storage.GetComponent<GroundWatch>());
                storage.Spawn();
                storage.inventory.capacity = 12;
                return storage;
            }

            private void PlayerStoppedLooting(BasePlayer player)
            {
                if (ins.com != null && ins.com.OpenInterface.Contains(player))
                    ins.com.OpenInterface.Remove(player);

                CuiHelper.DestroyUi(player, "UI_TPBaraxolka_External" + ".Mood1" + ".panel");
                CuiHelper.DestroyUi(player, UIPanel);
                ReturnPlayerItems();
                Destroy(this);
            }

            public void Close()
            {
                SendItems();
            }

            public void StartLoot()
            {
                player.EndLooting();
                storage.SetFlag(BaseEntity.Flags.Open, true, false);
                player.inventory.loot.StartLootingEntity(storage, false);
                player.inventory.loot.AddContainer(storage.inventory);
                player.inventory.loot.SendImmediate();
                player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", storage.panelName);
                storage.DecayTouch();
                storage.SendNetworkUpdate();
                CreateUI();
                InvokeRepeating("UpdatePanels", 1f, 1f);
                InvokeRepeating("UpdateInfo", 1f, 1f);
            }

            bool disabledButton = false;

            void CreateUI()
            {
                CuiHelper.DestroyUi(player, UIPanel);
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "199 35", OffsetMax = "425 97" },
                    Image = { Color = "1 1 1 0" }
                }, "Overlay", UIPanel);

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Image = { Color = "0.77 0.74 0.71 0.05", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
                }, UIPanel, UIPanel + ".main");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.03 0.15", AnchorMax = "0.97 0.85" },
                    Button = { Command = disabledButton ? "UI_TPBaraxolka sendLoot" : "", Color = disabledButton ? "0.41 0.47 0.26 1.00" : "0.41 0.47 0.26 0.2" },
                    Text = { Text = $"", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 18, Color = disabledButton ? "0.59 0.69 0.42 0.7" : "0.59 0.69 0.42 0.2" }
                }, UIPanel + ".main", UIPanel + ".button");



             
                container.Add(new CuiElement
                {
                    Parent = UIPanel + ".button",

                    Components =
                    {
                        new CuiTextComponent { Text = $"ОТПРАВИТЬ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 20, Color = disabledButton ? "0.59 0.69 0.42 0.7" : "0.59 0.69 0.42 0.2"},
                        new CuiRectTransformComponent {AnchorMin = "0 0.1", AnchorMax = "1 1"}
                    }
                });

                CuiHelper.AddUi(player, container);
                UpdateInfo();
            }

            public void ReturnPlayerItems()
            {
                global::ItemContainer itemContainer = storage.inventory;
                if (itemContainer != null)
                {
                    for (int i = itemContainer.itemList.Count - 1; i >= 0; i--)
                    {
                        global::Item item = itemContainer.itemList[i];
                        player.GiveItem(item, global::BaseEntity.GiveItemReason.Generic);
                    }
                }
            }

            void UpdatePanels()
            {
                if (storage.inventory.itemList.Count > 0 && !disabledButton && PoitsInvectoryCount() >= 1)
                {
                    disabledButton = true;
                    CreateUI();
                    return;
                }
                if (storage.inventory.itemList.Count == 0 && disabledButton || PoitsInvectoryCount() < 1)
                {
                    disabledButton = false;
                    CreateUI();
                }
            }

            public float PoitsInvectoryCount()
            {
                float amount = 0;

                for (int i = 0; i < storage.inventory.itemList.Count; i++)
                {
                    var item = storage.inventory.itemList[i];
                    if (!ins.config.expeditionSettings.ItemsAdded.ContainsKey(item.info.shortname))
                        return amount;
                    var configItem = ins.config.expeditionSettings.ItemsAdded[item.info.shortname];
                    amount += configItem.amount * item.amount;
                }

                return amount;
            }

            void UpdateInfo()
            {
                CuiHelper.DestroyUi(player, UIPanel + ".text");

                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Parent = UIPanel + ".button",
                    Name = UIPanel + ".text",

                    Components =
                        {
                            new CuiTextComponent { Color = disabledButton? "0.59 0.69 0.42 1" : "0.59 0.69 0.42 0.2", Text = PoitsInvectoryCount() > 0 ?  $"Текущие очки: {PoitsInvectoryCount()}" : "Нету предметов" , Align = TextAnchor.LowerCenter , FontSize = 11},
                            new CuiRectTransformComponent {AnchorMin = "0 0.05", AnchorMax = "1 1"}
                        }
                });
                CuiHelper.AddUi(player, container);
            }


            public void SendItems()
            {
                ins.sendmoney(player, PoitsInvectoryCount());
                storage.inventory.itemList.Clear();
                player.EndLooting();
                Destroy(this);
            }

            public List<Item> GetItems => storage.inventory.itemList.Where(i => i != null).ToList();
            void OnDestroy()
            {
                ReturnPlayerItems();
                storage.Kill();
            }
        }

        object CanMoveItem(Item item, PlayerInventory playerLoot, ItemContainerId targetContainer, int targetSlot, int amount)
        {
            var player = playerLoot.GetComponent<BasePlayer>();
            if (player == null || playerLoot == null || targetContainer.Value == 0) return null;
            if(!config.expeditionSettings.ItemsAdded.ContainsKey(item.info.shortname)) return null;
            if (item.GetRootContainer() != null && item.GetRootContainer().entityOwner != null && item.GetRootContainer().entityOwner.GetComponent<ExpeditionExceptionBox>() != null)
            {
                var newContainer = playerLoot.FindContainer(targetContainer);
                if (newContainer == null) return null;
                var slot = newContainer.GetSlot(targetSlot);
                if (slot == null) return null;
                return false;
            }
            var container = playerLoot.FindContainer(targetContainer);
            if (container == null || container.entityOwner == null || container.entityOwner.GetComponent<ExpeditionExceptionBox>() == null) return null;
            if (!config.expeditionSettings.ItemsAdded.ContainsKey(item.info.shortname))
                return false;
            else
            {
                var configItem = config.expeditionSettings.ItemsAdded[item.info.shortname];
                var containsItem = container.itemList.Find(p => p.info.shortname == item.info.shortname);
                if (containsItem != null)
                {
                    if (configItem.maxCount == 1) return null;
                    if (containsItem.amount == configItem.maxCount) return false;
                    if ((containsItem.amount + amount) > configItem.maxCount)
                    {
                        var needAmount = configItem.maxCount - containsItem.amount;
                        item.UseItem(needAmount);

                        var newItem = ItemManager.CreateByItemID(item.info.itemid, needAmount);
                        newItem.MoveToContainer(container);
                        return false;
                    }
                }
                if (amount > configItem.maxCount)
                {
                    item.UseItem(configItem.maxCount);
                    var newItem = ItemManager.CreateByItemID(item.info.itemid, configItem.maxCount);
                    newItem.MoveToContainer(container);
                    return false;
                }
            }
            return null;
        }

        object OnEntityTakeDamage(BasePlayer entity, HitInfo info)
        {
            if (entity == null || info == null) return null;
            if (entity == newPlayer) return false;
            return null;
        }

        #endregion
    }
}

// --- End of file: TPBaraxolka.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/LimitAuthorization.cs ---
// --- Original Local Path: LimitAuthorization.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Mono.Security.X509;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using ProtoBuf;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("LimitAuthorization", "Own3r/Nericai", "1.1.3")]
    [Description(
        "Ограничивает лимит авторизаций и позволяет авторизовать в замках, шкафах, турелях,")]
    class LimitAuthorization : RustPlugin
    {
        #region Поля

        [PluginReference] private Plugin Clans, Friends, FriendSystem, ImageLibrary;

        private List<AuthManager> authManager = new List<AuthManager>
        {
            new AuthManager("https://rustlabs.com/img/items180/lock.code.png", "authCode"),
            new AuthManager("https://rustlabs.com/img/items180/autoturret.png", "authTurret"),
            new AuthManager("https://rustlabs.com/img/items180/cupboard.tool.png", "authCups")
        };

        private class AuthManager
        {
            public string PictureURL;
            public string Command;

            public AuthManager(string pictureUrl, string command)
            {
                PictureURL = pictureUrl;
                Command = command;
            }
        }

        #endregion

        #region Конфигурация

        private class AuthConfig
        {
            [JsonProperty("Лимит авторизаций в шкафу")]
            public int CupboardLimit;

            [JsonProperty("Лимит авторизаций в замках")]
            public int CodelockLimit;

            [JsonProperty("Лимит авторизаций в турелях")]
            public int TurretLimit;

            [JsonProperty("Разрешить авторизацию кланам")]
            public bool ClanAllow;

            [JsonProperty("Разрешить авторизацию друзьям")]
            public bool FriendsAllow;
        }

        private AuthConfig config;

        protected override void LoadDefaultConfig()
        {
            config = new AuthConfig
            {
                CodelockLimit = 3,
                CupboardLimit = 3,
                TurretLimit = 3,
                ClanAllow = true,
                FriendsAllow = true
            };
            SaveConfig();
            PrintWarning("Создаем дефолтный конфиг");
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        protected override void LoadConfig()
        {
            base.LoadConfig();

            config = Config.ReadObject<AuthConfig>();
        }

        #endregion

        #region Хуки Oxide

        private void OnServerInitialized()
        {
            if (!plugins.Exists("Clans"))
            {
                if (config.ClanAllow) PrintWarning("Плагин Clans не установлен.\nАвторизация сокланов отключена!");
                config.ClanAllow = false;
            }

            if (!plugins.Exists("Friends") && !plugins.Exists("FriendSystem"))
            {
                if (config.FriendsAllow) PrintWarning("Плагин Friends не установлен.\nАвторизация друзей отключена!");
                config.FriendsAllow = false;
            }

            foreach (var check in authManager.Select((i, t) => new
                {
                    row = i,
                    index = t
                })
                .Where(p => !string.IsNullOrWhiteSpace(p.row.PictureURL)))
                ImageLibrary?.Call("AddImage", check.row.PictureURL, $"Auth.{check.index}");

            timer.Every(5f, StartClanUpdate);
        }

        private Coroutine clanListUpdater;
        private Coroutine friendListUpdater;

        public void StartClanUpdate()
        {
            if (clanListUpdater != null) return;
            if (config.ClanAllow)
                clanListUpdater = ServerMgr.Instance.StartCoroutine(UpdateMemebers(GetClanMembers, currentClanMembers,
                    () => clanListUpdater = null));

            if (friendListUpdater != null) return;
            if (config.FriendsAllow)
                friendListUpdater =
                    ServerMgr.Instance.StartCoroutine(UpdateMemebers(GetFriends, currentFriends,
                        () => friendListUpdater = null));
        }

        public IEnumerator UpdateMemebers(Func<BasePlayer, List<string>> cb,
            Dictionary<ulong, List<string>> membersList, Action finalize)
        {
            var players = BasePlayer.activePlayerList.ToArray();

            foreach (var player in players.ToList())
            {
                var newList = cb(player);
                if (newList == null) yield return null;

                if (!membersList.ContainsKey(player.userID))
                {
                    membersList.Add(player.userID, new List<string>());
                    membersList[player.userID] = newList;
                    yield return null;
                }

                if (newList != null && membersList[player.userID] != null)
                {
                    var deletedList = membersList[player.userID].Except(newList).ToList();
                    DeAuthAll(player, deletedList);
                }

                membersList[player.userID] = newList;
                yield return null;
            }

            finalize();
            yield return null;
        }

        Dictionary<ulong, List<string>> currentClanMembers = new Dictionary<ulong, List<string>>();
        Dictionary<ulong, List<string>> currentFriends = new Dictionary<ulong, List<string>>();

        void Unload()
        {
            if (clanListUpdater != null) ServerMgr.Instance.StopCoroutine(clanListUpdater);
            if (friendListUpdater != null) ServerMgr.Instance.StopCoroutine(friendListUpdater);
        }

        object OnCupboardAuthorize(BuildingPrivlidge privilege, BasePlayer player)
        {
            if (privilege == null || player == null) return null;

            var count = privilege.authorizedPlayers.Count;
            if (count == 0) return null;

            if (count > config.CupboardLimit)
            {
                privilege.authorizedPlayers.RemoveRange(0, count - 1);
            }

            return null;
        }

        object OnCodeEntered(CodeLock codeLock, BasePlayer player, string code)
        {
            if (codeLock == null || player == null) return null;

            var count = codeLock.whitelistPlayers.Count + codeLock.guestPlayers.Count;
            if (count == 0) return null;

            if (!(code == codeLock.guestCode || code == codeLock.code)) return null;

            if (count > config.CodelockLimit)
            {
                codeLock.whitelistPlayers.RemoveRange(0, count - 1);
            }

            return null;
        }

        private object OnTurretTarget(AutoTurret turret, BaseCombatEntity targ)
        {
            if (!(targ is BasePlayer) || turret.OwnerID < 0) return null;
            var player = (BasePlayer) targ;
            if (turret == null || player == null) return null;
            var count1 = turret.authorizedPlayers.Count;
            if (count1 == 0) return null;
            if (count1 > config.TurretLimit)
            {
                turret.authorizedPlayers.RemoveRange(0, count1 - 1);
            }

            return null;
        }

        /*object OnTurretAuthorize(AutoTurret turret, BasePlayer player)
        {
            if (turret == null || player == null) return null;

            var count = turret.authorizedPlayers.Count;
            if (count == 0) return null;

            if (count > config.TurretLimit)
            {
                turret.authorizedPlayers.RemoveRange(0, count - config.TurretLimit);
            }

            return null;
        }*/

        #endregion

        #region Логика

        class ClanUModGetClanResult
        {
            public string tag;
            public string owner;
            public JArray moderators;
            public JArray members;
            public JArray invited;
            public JArray allies;
            public JArray invitedallies;
        }

        public List<string> GetClanMembersUmod(BasePlayer player)
        {
            var clanTag = Clans.Call<string>("GetClanOf", player.userID);
            if (clanTag == null) return null;

            var resultRaw = Clans.Call<JObject>("GetClan", clanTag);
            if (resultRaw == null) return null;

            var result = JsonConvert.DeserializeObject<ClanUModGetClanResult>(resultRaw.ToString());
            if (result == null) return null;

            var members = JsonConvert.DeserializeObject<Dictionary<string, string>>(result.members.ToString());
            return members != null ? new List<string>(members.Keys) : null;
        }

        public List<string> GetClanMembersOvh(BasePlayer player)
        {
            var result = Clans.Call<List<ulong>>("ApiGetClanMembers", player.userID);

            return result?.ConvertAll(i => i.ToString());
        }

        public List<string> GetFriendsOvh(BasePlayer player)
        {
            var result = (List<ulong>) Friends.CallHook("ApiGetFriends", player.userID);

            return result?.ConvertAll(i => i.ToString());
        }
		
		public List<string> GetFriendsOxide(BasePlayer player)
        {
            var result = (string[]) Friends.CallHook("GetFriends", player.userID);

            return result?.ToList();
        }
		
		public List<string> GetFriendsApi(BasePlayer player)
        {
            var result = (string[]) Friends.CallHook("GetFriendsS", player.userID.ToString());

            return result?.ToList();
        }
		
		public List<string> GetFriendsAp(BasePlayer player)
        {
            var result = (string[]) FriendSystem.CallHook("GetFriendsS", player.userID.ToString());

            return result?.ToList();
        }
    

        public List<string> GetFriends(BasePlayer player)
        {
            if (config.FriendsAllow && plugins.Exists("Friends"))
            {
                //Friends by Moscow.OVH
                if (Friends.Author.ToLower().Contains("sanlerus"))
                {
                    return GetFriendsOvh(player);
                }

                //Friends by Dcode
                if (Friends.Author.ToLower().Contains("dcode"))
                {
                    return GetFriendsOxide(player);
                }

                //Friends by Umod
                if (Friends.Author.ToLower().Contains("nogrod"))
                {
                    return GetFriendsApi(player);
                }

                return null;
            }

            if (config.FriendsAllow && plugins.Exists("FriendSystem"))
            {
                //FriendSystem A1M41K
                if (FriendSystem.Author.ToLower().Contains("a1m41k"))
                {
                    return GetFriendsAp(player);
                }

                return null;
            }

            return null;
        }

        public List<string> GetClanMembers(BasePlayer player)
        {
            if (!config.ClanAllow || !plugins.Exists("Clans")) return null;

            //Clans by k1lly0u (uMod/Oxide)
            if (Clans.Author.ToLower().Contains("k1lly0u"))
            {
                return GetClanMembersUmod(player);
            }

            //Clans by Moscow.OVH
            if (Clans.Author.ToLower().Contains("sanlerus"))
            {
                return GetClanMembersOvh(player);
            }

            //Clans reborn by Fujicura
            return Clans.Call<List<string>>("GetClanMembers", player.userID);
        }

        private void AuthOnEntity<T>(BasePlayer player, string where, bool deAuth, Action<T, BasePlayer> callback)
        {
            List<string> clanMembers = null;
            List<string> friends = null;

            if (config.ClanAllow)
            {
                clanMembers = GetClanMembers(player);

                if (clanMembers == null && !config.FriendsAllow)
                {
                    SendReply(player, "Вы не состоите в клане, либо в нем только вы");
                    return;
                }
            }

            if (config.FriendsAllow)
            {
                friends = GetFriends(player);

                if (friends == null && !config.ClanAllow)
                {
                    SendReply(player, "У вас нет друзей");
                    return;
                }
            }

            if (friends == null && clanMembers == null)
            {
                SendReply(player, "У вас нет друзей и вы не состоите в клане (или вы в клане один)");
                return;
            }

            if (friends == null) friends = new List<string>();
            if (clanMembers == null) clanMembers = new List<string>();

            var contragents = clanMembers.Union(friends).ToList();

            var playerEntities = GetPlayerEnitityByType<T>(player);

            foreach (var contragen in contragents)
            {
                var contragentBasePlayer = BasePlayer.Find(contragen);
                if (contragentBasePlayer == null) continue;

                foreach (var entity in playerEntities)
                {
                    callback(entity, contragentBasePlayer);
                }
            }

            var whatSuccess = config.ClanAllow && config.FriendsAllow
                ? "клан и друзей"
                : config.FriendsAllow
                    ? "друзей"
                    : "клан";

            SendReply(player, $"Вы успешно {(deAuth ? "де" : "")}авторизовали {whatSuccess} в {where}");
        }

        private static List<T> GetPlayerEnitityByType<T>(BasePlayer player)
        {
            var entities = UnityEngine.Object.FindObjectsOfType(typeof(T));
            var playerEntities = new List<T>();

            foreach (object entity in entities)
            {
                if (!(entity is BaseEntity)) continue;

                if ((entity as BaseEntity).OwnerID == player.userID)
                {
                    playerEntities.Add((T) entity);
                }
            }

            return playerEntities;
        }

        private static string parseColor(string where, int pos) =>
            (float) byte.Parse(@where.Substring(pos, 2), NumberStyles.HexNumber) / 255 + "";

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex)) hex = "#FFFFFF00";
            if (hex.IndexOf('#') != 0) return hex;

            var str = hex.Trim('#');																																				            var flag = 1622;
            if (str.Length == 3) str = $"{str[0]}0{str[1]}0{str[2]}0";
            if (str.Length == 6) str += "FF";
            if (str.Length == 4) str = $"{str[0]}0{str[1]}0{str[2]}0{str[3]}{str[3]}";
            if (str.Length != 8) throw new Exception(hex);

            return $"{parseColor(str, 0)} {parseColor(str, 2)} {parseColor(str, 4)} {parseColor(str, 6)}";
        }

        #endregion

        #region Команды

        [ChatCommand("auth")]
        private void auth(BasePlayer player)
        {
            if (player == null) return;

            if (!config.ClanAllow && !config.FriendsAllow)
            {
                SendReply(player, "Авторизация недоступна");
                return;
            }

            UI_DrawMainLayer(player);
        }

        private void DeAuthOnEntity<T>(BasePlayer player, List<string> contragents, Action<T, BasePlayer> callback)
        {
            var playerEntities = GetPlayerEnitityByType<T>(player);

            foreach (var contragen in contragents)
            {
                var contragentBasePlayer = BasePlayer.Find(contragen);
                if (contragentBasePlayer == null) continue;

                foreach (var entity in playerEntities)
                {
                    callback(entity, contragentBasePlayer);
                }
            }
        }

        private void DeAuthAll(BasePlayer player, List<string> contragents)
        {
            if (contragents == null || contragents.Count < 1 || player == null) return;

            DeAuthOnEntity<CodeLock>(player, contragents, (where, user) => where.whitelistPlayers.Remove(user.userID));
            DeAuthOnEntity<AutoTurret>(player, contragents, (where, user) =>
            {
                where.authorizedPlayers.RemoveAll(x => x.userid == user.userID);
                where.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            });


            DeAuthOnEntity<BuildingPrivlidge>(player, contragents, (where, user) =>
            {
                where.authorizedPlayers.RemoveAll(x => x.userid == user.userID);
                where.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            });
        }

        [ConsoleCommand("UI_LimitHandler")]
        private void cmdConsoleHandler(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null || !args.HasArgs() && !args.HasArgs(2)) return;

            var deAuth = args.HasArgs(2) && args.Args[1] == "deauth";

            switch (args.Args[0].ToLower())
            {
                case "authcode":
                {
                    AuthOnEntity<CodeLock>(player,
                        "замках",
                        deAuth,
                        (where, user) =>
                        {
                            if (!deAuth)
                                where.whitelistPlayers.Add(user.userID);
                            else
                                where.whitelistPlayers.Remove(user.userID);
                        });
                    break;
                }
                case "authturret":
                {
                    AuthOnEntity<AutoTurret>(player,
                        "турелях",
                        deAuth,
                        (where, user) =>
                        {
                            if (!deAuth)
                                where.authorizedPlayers.Add(new PlayerNameID
                                {
                                    userid = user.userID,
                                    username = user.displayName
                                });
                            else
                                where.authorizedPlayers.RemoveAll(x => x.userid == user.userID);
                            where.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                        });
                    break;
                }
                case "authcups":
                {
                    AuthOnEntity<BuildingPrivlidge>(player,
                        "шкафах",
                        deAuth,
                        (where, user) =>
                        {
                            if (!deAuth)
                                where.authorizedPlayers.Add(new PlayerNameID
                                {
                                    userid = user.userID,
                                    username = user.displayName
                                });
                            else
                                where.authorizedPlayers.RemoveAll(x => x.userid == user.userID);
                            where.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                        });
                    break;
                }
                default:
                {
                    PrintWarning("Ошибка в ГУИ");
                    return;
                }
            }
        }

        #endregion

        #region UI

        private const string MainLayer = "UI.LimitAuthorization";

        private void UI_DrawMainLayer(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, MainLayer);
            var container = new CuiElementContainer
            {
                {
                    new CuiPanel
                    {
                        CursorEnabled = true,
                        RectTransform =
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-211.5 -121.4",
                            OffsetMax = "211.5 121.4"
                        },
                        Image =
                        {
                            Color = "0 0 0 0"
                        }
                    },
                    "Hud", MainLayer
                },
                {
                    new CuiButton
                    {
                        RectTransform =
                        {
                            AnchorMin = "-100 -100",
                            AnchorMax = "100 100"
                        },
                        Button =
                        {
                            Color = "0 0 0 0",
                            Close = MainLayer
                        },
                        Text =
                        {
                            Text = ""
                        }
                    },
                    MainLayer
                }
            };

            for (var i = 0; i < 3; i++)
            {
                var currentAuth = authManager[i];

                container.Add(new CuiElement
                {
                    Name = MainLayer + $".{i}",
                    Parent = MainLayer,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat("#638964FF")
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = $"{0.07330071 + i * 0.28} 0.04789267",
                            AnchorMax = $"{0.32635 + i * 0.28} 0.7183909"
                        }
                    }
                });

                container.Add(new CuiButton
                    {
                        RectTransform =
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 0.1714286",
                            OffsetMax = "0 0"
                        },
                        Button =
                        {
                            Color = HexToRustFormat("#7c1200FF"),
                            Command = $"UI_LimitHandler {currentAuth.Command} deauth"
                        },
                        Text =
                        {
                            Text = "Деавторизовать",
                            FontSize = 15,
                            Font = "robotocondensed-bold.ttf",
                            Align = TextAnchor.MiddleCenter,
                            Color = HexToRustFormat("#c14832FF")
                        }
                    },
                    MainLayer + $".{i}");

                container.Add(new CuiButton
                    {
                        RectTransform =
                        {
                            AnchorMin = "0 0.1714286",
                            AnchorMax = "1 0.3428572",
                            OffsetMax = "0 0"
                        },
                        Button =
                        {
                            Color = HexToRustFormat("#3D563EFF"),
                            Command = $"UI_LimitHandler {currentAuth.Command}"
                        },
                        Text =
                        {
                            Text = "Авторизовать",
                            FontSize = 16,
                            Font = "robotocondensed-bold.ttf",
                            Align = TextAnchor.MiddleCenter,
                            Color = HexToRustFormat("#638964FF")
                        }
                    },
                    MainLayer + $".{i}");

                if (currentAuth.PictureURL != "")
                {
                    container.Add(new CuiElement
                    {
                        Parent = MainLayer + $".{i}",
                        Components =
                        {
                            new CuiRawImageComponent
                            {
                                Png = (string) ImageLibrary.Call("GetImage", $"Auth.{i}"),
                                Color = "1 1 1 1"
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 0.3428572",
                                AnchorMax = "1 1",
                                OffsetMax = "0 0"
                            }
                        }
                    });
                }
            }

            CuiHelper.AddUi(player, container);
        }

        #endregion
    }
}

// --- End of file: LimitAuthorization.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TeamGuard.cs ---
// --- Original Local Path: TeamGuard.cs ---

using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using Oxide.Core;
using UnityEngine;
using Formatter = Oxide.Core.Libraries.Covalence.Formatter;

namespace Oxide.Plugins
{
    [Info("TeamGuard", "RustShop.ru -Vlad-00003", "2.1.4")]
    [Description("Plugin allow admins to easier control player groups size.")]
    /*
     * Author info:
     * E-mail: Vlad-00003@mail.ru
     * Vk: vk.com/vlad_00003
     */
    internal class TeamGuard : RustPlugin
    {
        #region Checker

        private class TGChecker : TriggerBase
        {
            private readonly HashSet<BasePlayer> _players = new HashSet<BasePlayer>();
            private SphereCollider _collider = new SphereCollider();
            private Info _info;
            private bool _mainCuiCreated;
            private BasePlayer _player;

            private ChatMessage Message => _info.ShouldShock
                ? new ChatMessage("TextWhileDmg", _config.RadiusCheck.MaxPlayers, _config.RadiusCheck.DamagePerTime,
                    _config.RadiusCheck.DamageFrequencyString)
                : new ChatMessage("TextBeforeDmg", _config.RadiusCheck.MaxPlayers, _info.TimeBeforeShock);

            private void Awake()
            {
                _collider = GetComponent<SphereCollider>();
                _collider.radius = _config.RadiusCheck.Radius;
                _collider.isTrigger = true;
                interestLayers = 131072; // 17: Player (Server)
                if (_config.RadiusCheck.DamagePerTime > 0)
                    InvokeRepeating(DamageSequence, _config.RadiusCheck.DamageFrequency);
                if (_config.RadiusCheck.UseChat)
                    InvokeRepeating(ChatSequence, _config.RadiusCheck.ChatUpdateFrequency);
                if (_config.RadiusCheck.UseCui)
                    InvokeRepeating(CuiSequence, _config.RadiusCheck.CuiUpdateFrequency);
            }

            private TGChecker SetPlayer(BasePlayer player)
            {
                _player = player;
                return this;
            }

            private void InvokeRepeating(Action action, float time) => InvokeRepeating(action, time, time);

            private bool ShouldCount(BasePlayer player)
            {
				if (Interface.CallHook("OnShouldCount", player) != null)
					return false;
                return player.IsConnected && !InWhitelistedZone(player) && !InSafeZone(player) &&
                       !IsDuelPlayer(player) &&
                       !IsEventPlayer(player) && !HasAuth(player) &&
                       player.CanInteract() && CanSee(player, _player);
            }

            private IEnumerator DoShock()
            {
                _player.Hurt(_config.RadiusCheck.DamagePerTime, DamageType.ElectricShock, _player, false);
                foreach (var prefab in _config.RadiusCheck.Effects)
                {
                    EffectNetwork.Send(new Effect(prefab, _player, 0u, Vector3.zero, Vector3.forward),
                        _player.net.connection);
                    yield return CoroutineEx.waitForSeconds(0.3f);
                }
            }

            public void Kill()
            {
                DestroyCui();
                Destroy(gameObject);
            }

            private void FixedUpdate()
            {
                if (!ShouldCount(_player))
                {
                    _info.Clear();
                    return;
                }

                var playersInArea = _players.Count(ShouldCount);
                if (playersInArea < _config.RadiusCheck.MaxPlayers)
                {
                    _info.Remove(Time.deltaTime);
                    return;
                }

                _info.Add(Time.deltaTime);
            }

            private void Update()
            {
                if (_player == null) return;
                transform.rotation = _player.transform.rotation;
                transform.position = _player.transform.position;
            }

            private void CuiSequence()
            {
                if (!_info.OverLimit)
                {
                    DestroyCui();
                    return;
                }

                ShowCui(Message.Read(_player.UserIDString));
            }

            private void ChatSequence()
            {
                if (_info.OverLimit)
                    Message.SendToChat(_player);
            }

            private void DamageSequence()
            {
                if (_info.ShouldShock)
                    StartCoroutine(DoShock());
            }

            public static TGChecker Create(BasePlayer player)
            {
                var go = new GameObject($"TGChecker for {player.userID}", typeof(SphereCollider)) { layer = 18 };
                //go.transform.SetParent(player.transform, false);
                return go.AddComponent<TGChecker>().SetPlayer(player);
            }

            private struct Info
            {
                public float Time;
                public bool OverLimit;

                public void Add(float deltaTime)
                {
                    Time += deltaTime;
                    OverLimit = true;
                }

                public void Remove(float deltaTime)
                {
                    Time = Mathf.MoveTowards(Time, 0, deltaTime);
                    OverLimit = false;
                }

                public void Clear()
                {
                    if (Time <= 0)
                        return;
                    Time = 0;
                    OverLimit = false;
                }

                public bool ShouldShock => OverLimit && Time >= _config.RadiusCheck.DelayBeforeShock;
                public string TimeBeforeShock => (_config.RadiusCheck.DelayBeforeShock - Time).ToString("0");
            }

            #region Cui

            private void ShowCui(string text)
            {
                if (!_mainCuiCreated)
                {
                    _config.Cui.AddMain(_player);
                    _mainCuiCreated = true;
                }

                _config.Cui.UpdateText(_player, text);
            }

            private void DestroyCui()
            {
                if (!_mainCuiCreated)
                    return;
                _config.Cui.Destroy(_player);
                _mainCuiCreated = false;
            }

            #endregion

            #region Trigger

            public override GameObject InterestedInObject(GameObject obj)
            {
                obj = base.InterestedInObject(obj);
                if (obj == null)
                    return null;

                var baseEntity = obj.ToBaseEntity();
                if (baseEntity == null)
                    return null;

                if (baseEntity.isClient)
                    return null;

                var basePlayer = baseEntity as BasePlayer;
                if (!basePlayer || basePlayer.IsDead() || basePlayer == _player || IsNpc(basePlayer))
                    return null;

                return baseEntity.gameObject;
            }

            public override void OnEntityEnter(BaseEntity ent)
            {
                var basePlayer = ent as BasePlayer;
                if (!basePlayer)
                    return;
                _players.Add(basePlayer);
            }

            public override void OnEntityLeave(BaseEntity ent)
            {
                var basePlayer = ent as BasePlayer;
                if (!basePlayer)
                    return;
                _players.Remove(basePlayer);
            }

            #endregion
        }

        #endregion

        #region Vars

        private static PluginConfig _config;
        private static TeamGuard _inst;

        [PluginReference] Plugin Duel, EventManager, ZoneManager;

        private readonly Dictionary<BasePlayer, uint> _lastUsed = new Dictionary<BasePlayer, uint>();
        private readonly Dictionary<BasePlayer, TGChecker> _checkers = new Dictionary<BasePlayer, TGChecker>();

        #endregion

        #region Localization

        private class ChatMessage
        {
            public static readonly ChatMessage CodeLockName = new ChatMessage("CodeLock");
            public static readonly ChatMessage CupboardName = new ChatMessage("Cupboard");
            public static readonly ChatMessage TurretName = new ChatMessage("Turret");
            public static readonly ChatMessage ClearMode = new ChatMessage("Clear");
            public static readonly ChatMessage ReplaceMode = new ChatMessage("Replace");

            private readonly object[] _args;
            private readonly string _langKey;

            public ChatMessage(string langKey)
            {
                _langKey = langKey;
                _args = new object[0];
            }

            public ChatMessage(string langKey, params object[] args)
            {
                _langKey = langKey;
                _args = args;
            }

            public string Read(string userId = null)
            {
                var reply = 335;
                var format = GetMsg(_langKey, userId);
                if (_args.Length == 0)
                    return format;
                var args = new List<object>(_args.Length);
                foreach (var arg in _args)
                {
                    var message = arg as ChatMessage;
                    if (message == null)
                    {
                        args.Add(arg);
                        continue;
                    }

                    args.Add(message.Read(userId));
                }

                return string.Format(format, args.ToArray());
            }

            public void SendToChat(BasePlayer player)
            {
                player.ChatMessage(string.Format(_config.Generic.ChatFormat, Read(player.UserIDString)));
            }

            public void SendToConsole(BasePlayer player)
            {
                player.ConsoleMessage(string.Format(_config.Generic.ChatFormat, Read(player.UserIDString)));
            }
        }

        private static string GetMsg(string langKey, string userid = null)
        {
            return _inst.lang.GetMessage(langKey, _inst, userid);
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TextBeforeDmg"] =
                    "You have more players around then allowed (Allowed - {0}).\nYou have {1} seconds before you will start to get damage.",
                ["TextWhileDmg"] =
                    "You have more players around then allowed (Allowed - {0}).\nAll players in the area would get {1} damage every {2} seconds " +
                    "until redundant player will leave the area.",
                ["LogLimit"] =
                    "Player \"{0}\" attempted to auth in the {1} of the player \"{2}\"\nPlayer position: {3} | Target position: {4}",
                ["LogCleared"] =
                    "Player \"{0}\" has authorized and cleared auth list of {1} of the player \"{2}\"\nPlayer position: {3} | Target position: {4}",
                ["LogReplaced"] =
                    "Player \"{0}\" has replaced player \"{1}\" in the {2} of the player  \"{3}\"\nPlayer position: {4} | Target position: {5}",
                ["Replace"] = "replace first authorized player",
                ["Clear"] = "authorize and clear previously authorized players list",
                ["ChatLimit"] = "This {0} has it's auth limit. (Max - {1}).\nRetry to {2}.",
                ["CodeLock"] = "code lock",
                ["Cupboard"] = "cupboard",
                ["Turret"] = "turret"
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TextBeforeDmg"] =
                    "В зоне вокруг вас находится больше игроков, чем разрешено (Разрешено {0}).\nЧерез {1}с. все игроки в зоне начнут получать урон.",
                ["TextWhileDmg"] =
                    "В зоне вокруг вас находится больше игроков, чем разрешено (Разрешено {0}).\nВсем игрокам в зоне будет наносится урон " +
                    "в размере {1} каждые {2}с. до тех пор, пока лишние игроки не покинут зону проверки.",
                ["LogLimit"] =
                    "Игрок \"{0}\" попытался авторизоваться в {1} игрока \"{2}\"\nПозиция игрока: {3} | Позиция цели: {4}",
                ["LogCleared"] =
                    "Игрок \"{0}\" очистил список и авторизовался в {1} игрока \"{2}\"\nПозиция игрока: {3} | Позиция цели: {4}",
                ["LogReplaced"] =
                    "Игрок \"{0}\" заменил игрока \"{1}\" в списке авторизованных в {2} игрока \"{3}\"\nПозиция игрока: {4} | Позиция цели: {5}",
                ["Replace"] = "заменить первого авторизованно игрока",
                ["Clear"] = "авторизоваться и очистить список ранее авторизованных игроков",
                ["ChatLimit"] =
                    "Достигнут лимит авторизованных в {0}. (Максимально - {1})\nПовторите попытку для того, чтобы {2}.",
                ["CodeLock"] = "замке",
                ["Cupboard"] = "шкафу",
                ["Turret"] = "турели"
            }, this, "ru");
        }

        #endregion

        #region Config

        private class RadiusCheckConfig
        {
            [JsonProperty("Частота сообщений в чате")]
            public float ChatUpdateFrequency;

            [JsonProperty("Частота обновления UI")]
            public float CuiUpdateFrequency;

            [JsonProperty("Частота нанесения урона")]
            public float DamageFrequency;

            [JsonProperty("Наносимый урон за раз")]
            public float DamagePerTime;

            [JsonProperty("Разрешённое время нахождения рядом")]
            public float DelayBeforeShock;

            [JsonProperty("Отключить проверку по радиусу в безопасных зонах")]
            public bool DisableInSaveZone;

            [JsonProperty("Список эффектов, запускающихся при получении урона")]
            public List<string> Effects;

            [JsonProperty("Максимальное количество игроков в радиусе")]
            public int MaxPlayers;

            [JsonProperty("Радиус зоны проверки")]
            public float Radius;

            [JsonProperty("Использовать ли проверку по радиусу")]
            public bool Use;

            [JsonProperty("Выводить ли сообщения о нанесении урона в чат?")]
            public bool UseChat;

            [JsonProperty("Использовать ли графическую панель?")]
            public bool UseCui;

            [JsonIgnore]
            public string DamageFrequencyString;

            #region Default Config

            public static RadiusCheckConfig DefaultConfig => new RadiusCheckConfig
            {
                Use = true,
                DisableInSaveZone = true,
                MaxPlayers = 4,
                Radius = 10,
                DelayBeforeShock = 20,
                DamageFrequency = 5,
                DamagePerTime = 5,
                UseCui = true,
                CuiUpdateFrequency = 1,
                UseChat = false,
                ChatUpdateFrequency = 5,
                Effects = new List<string>
                {
                    "assets/prefabs/npc/autoturret/effects/targetacquired.prefab",
                    "assets/prefabs/weapons/hatchet/effects/strike_screenshake.prefab"
                }
            };

            #endregion

            [OnDeserialized]
            internal void OnDeserializedMethod(StreamingContext context)
            {
                DamageFrequencyString = DamageFrequency.ToString("0");
            }
        }

        private class GenericConfig
        {
            [JsonProperty("Формат сообщений в чате")]
            private string _chatFormat;

            [JsonIgnore]
            public string ChatFormat;

            [JsonProperty("Привилегия для просмотра логов")]
            public string LogPermission;

            [JsonProperty("Выводить лог в чат (false - в консоль)")]
            public bool LogToChat;

            #region Default Config

            public static GenericConfig DefaultConfig => new GenericConfig
            {
                LogPermission = "teamguard.log",
                LogToChat = true,
                _chatFormat = "[#f46600][TeamGuard][/#] {0}"
            };

            #endregion

            [OnDeserialized]
            internal void OnDeserializedMethod(StreamingContext context)
            {
                ChatFormat = Formatter.ToUnity(_chatFormat);
            }
        }

        private class CuiConfig
        {
            [JsonProperty("Цвет фона")]
            private string _color;

            [JsonProperty("Размер шрифта")]
            private int _fontSize;

            [JsonProperty("Максимальный отступ")]
            private string _max;

            [JsonProperty("Минимальный отступ")]
            private string _min;

            [JsonIgnore]
            private readonly string _textPanelName = CuiHelper.GetGuid();

            [JsonIgnore]
            private readonly string _mainPanelName = CuiHelper.GetGuid();

            #region Default Config

            public static CuiConfig DefaultConfig => new CuiConfig
            {
                _min = "0 0.355",
                _max = "1 0.655",
                _color = "0.30 0.01 0.01 0.80",
                _fontSize = 16
            };

            #endregion

            #region CUI

            private static readonly CuiElementContainer ReusableContainer = new CuiElementContainer();

            #region Elements

            [JsonIgnore]
            private CuiElement MainPanel => new CuiElement
            {
                Parent = "Overlay",
                Name = _mainPanelName,
                Components =
                {
                    new CuiImageComponent {Color = ToRustColor(_color)},
                    new CuiRectTransformComponent {AnchorMin = _min, AnchorMax = _max}
                }
            };

            private CuiElement GetTextPanel(string format, params object[] args)
            {
                var text = args.Length != 0 ? string.Format(format, args) : format;
                return new CuiElement
                {
                    Parent = _mainPanelName,
                    Name = _textPanelName,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = text, FontSize = _fontSize, Font = "robotocondensed-regular.ttf",
                            Align = TextAnchor.MiddleCenter
                        },
                        new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                    }
                };
            }

            #endregion

            public void AddMain(BasePlayer player)
            {
                if (!player || !player.IsConnected)
                    return;
                ReusableContainer.Clear();
                ReusableContainer.Add(MainPanel);
                CuiHelper.DestroyUi(player, _mainPanelName);
                CuiHelper.AddUi(player, ReusableContainer);
            }

            public void UpdateText(BasePlayer player, string format, params object[] args)
            {
                if (!player || !player.IsConnected)
                    return;
                ReusableContainer.Clear();
                ReusableContainer.Add(GetTextPanel(format, args));
                CuiHelper.DestroyUi(player, _textPanelName);
                CuiHelper.AddUi(player, ReusableContainer);
            }

            public void Destroy(BasePlayer player)
            {
                if (player?.IsConnected == true)
                    CuiHelper.DestroyUi(player, _mainPanelName);
            }

            #endregion
        }

        private class AdminsConfig
        {
            [JsonProperty("Необходимый уровень AuthLevel для игнорирования")]
            public int AuthLevel;

            [JsonProperty("Привилегия для игнорирования при проверке")]
            public string IgnorePermission;

            [JsonProperty("Игнорировать администраторов при проверке?")]
            public bool IgnoreAdmins;

            #region Default Config

            public static AdminsConfig DefaultConfig => new AdminsConfig
            {
                IgnoreAdmins = false,
                IgnorePermission = nameof(TeamGuard) + ".ignore",
                AuthLevel = 2
            };

            #endregion
        }

        private class EntityCheckConfig
        {
            [JsonProperty("Очищать список при превышении лимита")]
            public bool ClearAll;

            [JsonProperty("Максимум авторизаций")]
            public int PlayersLimit;

            [JsonProperty("Проверять авторизации")]
            public bool Use;

            #region Default Config

            public static EntityCheckConfig DefaultConfig => new EntityCheckConfig
            {
                Use = true,
                PlayersLimit = 4,
                ClearAll = false
            };

            #endregion

            public ChatMessage GetLimitMessage(ChatMessage entityName)
            {
                return new ChatMessage("ChatLimit", entityName, PlayersLimit,
                    ClearAll ? ChatMessage.ClearMode : ChatMessage.ReplaceMode);
            }
        }

        private class PluginConfig
        {
            [JsonProperty("Общие Настройки")]
            public GenericConfig Generic;

            [JsonProperty("Проверка администраторов")]
            public AdminsConfig Admins;

            [JsonProperty("Проверка игроков по радиусу")]
            public RadiusCheckConfig RadiusCheck;

            [JsonProperty("Настройки GUI")]
            public CuiConfig Cui;

            [JsonProperty("Авторизации в кодовых замках")]
            public EntityCheckConfig CodeLock;

            [JsonProperty("Авторизации в шкафах")]
            public EntityCheckConfig Cupboard;

            [JsonProperty("Авторизации в турелях")]
            public EntityCheckConfig Turret;

            [JsonProperty("Список зон ZoneManager, в которых не нужно вести проверку")]
            private List<string> _zonesList;

            #region Default Config

            public static PluginConfig DefaultConfig => new PluginConfig
            {
                Generic = GenericConfig.DefaultConfig,
                RadiusCheck = RadiusCheckConfig.DefaultConfig,
                Cui = CuiConfig.DefaultConfig,
                Admins = AdminsConfig.DefaultConfig,
                Cupboard = EntityCheckConfig.DefaultConfig,
                Turret = EntityCheckConfig.DefaultConfig,
                CodeLock = EntityCheckConfig.DefaultConfig,
                _zonesList = new List<string> { "zone1", "warzone", "safehouse" }
            };

            #endregion

            public bool InZone(Plugin zoneManager, BasePlayer player)
            {
                return zoneManager != null &&
                       _zonesList.Any(zoneId => (bool)zoneManager.Call("isPlayerInZone", zoneId, player));
            }

            public void Register(TeamGuard plugin)
            {
                plugin.permission.RegisterPermission(Generic.LogPermission, plugin);
                plugin.permission.RegisterPermission(Admins.IgnorePermission, plugin);
            }
        }

        #endregion

        #region Config initialization

        protected override void LoadDefaultConfig()
        {
            PrintWarning(
                "Благодарим за приобретение плагина на сайте RustShop.ru. Если вы приобрели этот плагин на другом ресурсе знайте - это лишает вас гарантированных обновлений!");
            _config = PluginConfig.DefaultConfig;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<PluginConfig>();

            if (ShouldUpdateConfig())
                SaveConfig();
            _config.Register(this);
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        private bool ShouldUpdateConfig()
        {
            var res = false;
            //version < 2.1.0
            if (!ConfigExists<string>("Проверка администраторов", "Привилегия для игнорирования при проверке"))
            {
                res = true;
                PrintWarning("New option added to the config file: Admin ignore permission");
                _config.Admins.IgnorePermission = nameof(TeamGuard) + ".ignore";
            }
            return res;
        }
        private bool ConfigExists<T>(params string[] path)
        {
            var value = Config.Get(path);
            return value is T;
        }

        #endregion

        #region Initialization and quiting

        private void Init()
        {
            _inst = this;
            if (!_config.RadiusCheck.Use)
            {
                Unsubscribe("OnPlayerConnected");
                Unsubscribe("OnPlayerDisconnected");
                Unsubscribe("OnServerInitialized");
                return;
            }
            if (!_config.CodeLock.Use)
                Unsubscribe("OnCodeEntered");
            if (!_config.Turret.Use)
                Unsubscribe("OnTurretAuthorize");
            if (!_config.Cupboard.Use)
                Unsubscribe("OnCupboardAuthorize");
        }

        private void OnServerInitialized()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }
        }

        private void Unload()
        {
            foreach (var checker in _checkers)
            {
                checker.Value.Kill();
            }
            _checkers.Clear();
            _config = null;
            _inst = null;
        }

        #endregion

        #region Oxide hooks (Player initialization)

        private void OnPlayerConnected(BasePlayer player)
        {
            TGChecker checker;
            if (_checkers.TryGetValue(player, out checker))
                checker.Kill();
            _checkers[player] = TGChecker.Create(player);
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            TGChecker checker;
            if (!_checkers.TryGetValue(player, out checker))
                return;
            checker.Kill();
            _checkers.Remove(player);
        }

        #endregion

        #region Oxide Hooks (Authorization)

        private object OnCodeEntered(CodeLock codeLock, BasePlayer player, string code)
        {
            if (HasAuth(player))
                return null;

            var isMainCode = code == codeLock.code;
            var isGuestCode = code == codeLock.guestCode;
            var canOpen = isMainCode || isGuestCode;
            if (!canOpen)
                return null;

            var parent = codeLock.GetParentEntity();
            var owner = GetName(parent.OwnerID);

            var whitelistPlayers = codeLock.whitelistPlayers.Where(x => !HasAuth(x)).ToList();
            var guestPlayers = codeLock.guestPlayers.Where(x => !HasAuth(x)).ToList();

            var count = guestPlayers.Count + whitelistPlayers.Count;
            if (count < _config.CodeLock.PlayersLimit)
                return null;

            uint lastUsedId;
            if (!_lastUsed.TryGetValue(player, out lastUsedId))
            {
                _config.CodeLock.GetLimitMessage(ChatMessage.CodeLockName).SendToChat(player);
                Log("LogLimit", player.displayName, ChatMessage.CodeLockName, owner, player.ServerPosition,
                    parent.ServerPosition);
                _lastUsed[player] = codeLock.net.ID;
                return false;
            }

            if (lastUsedId != codeLock.net.ID)
            {
                _lastUsed.Remove(player);
                return false;
            }

            if (_config.CodeLock.ClearAll)
            {
                Log("LogCleared", player.displayName, ChatMessage.CodeLockName, owner, player.ServerPosition,
                    parent.ServerPosition);
                if (isGuestCode)
                    codeLock.guestPlayers.Clear();
                else
                    codeLock.whitelistPlayers.Clear();
                codeLock.SendNetworkUpdate();
                return null;
            }

            ulong replaced;
            if (isGuestCode)
            {
                if (guestPlayers.Count == 0)
                {
                    _lastUsed.Remove(player);
                    return false;
                }

                replaced = codeLock.guestPlayers.FirstOrDefault(x => !HasAuth(x));

                if (replaced == 0)
                    return null;

                codeLock.guestPlayers.Remove(replaced);
            }
            else
            {
                if (whitelistPlayers.Count == 0)
                {
                    _lastUsed.Remove(player);
                    return false;
                }

                replaced = codeLock.whitelistPlayers.FirstOrDefault(x => !HasAuth(x));
                if (replaced == 0)
                    return null;

                codeLock.whitelistPlayers.Remove(replaced);
            }

            Log("LogReplaced", player.displayName, GetName(replaced), ChatMessage.CodeLockName, owner,
                player.ServerPosition, parent.ServerPosition);
            _lastUsed.Remove(player);
            return null;
        }

        private object OnCupboardAuthorize(BuildingPrivlidge privilege, BasePlayer player)
        {
            if (HasAuth(player))
                return null;
            var authorizedPlayers = privilege.authorizedPlayers.Where(x => !HasAuth(x.userid)).ToList();
            if (authorizedPlayers.Count < _config.Cupboard.PlayersLimit)
                return null;

            var owner = GetName(privilege.OwnerID);
            uint lastUsedId;
            if (!_lastUsed.TryGetValue(player, out lastUsedId))
            {
                _config.Cupboard.GetLimitMessage(ChatMessage.CupboardName).SendToChat(player);
                Log("LogLimit", player.displayName, ChatMessage.CupboardName, owner, player.ServerPosition,
                    privilege.ServerPosition);
                _lastUsed[player] = privilege.net.ID;
                return false;
            }

            if (_config.Cupboard.ClearAll)
            {
                Log("LogCleared", player.displayName, ChatMessage.CupboardName, owner, player.ServerPosition,
                    privilege.ServerPosition);
                privilege.authorizedPlayers.Clear();
                privilege.SendNetworkUpdate();
                return null;
            }

            var replaced = privilege.authorizedPlayers.FirstOrDefault(x => !HasAuth(x.userid));

            if (replaced == null)
                return null;

            privilege.authorizedPlayers.RemoveAt(0);
            Log("LogReplaced", player.displayName, GetName(replaced.userid), ChatMessage.CupboardName, owner,
                player.ServerPosition, privilege.ServerPosition);
            _lastUsed.Remove(player);
            return null;
        }

        private object OnTurretAuthorize(AutoTurret turret, BasePlayer player)
        {
            if (HasAuth(player))
                return null;
            var authorizedPlayers = turret.authorizedPlayers.Where(x => !HasAuth(x.userid)).ToList();

            if (authorizedPlayers.Count < _config.Turret.PlayersLimit)
                return null;

            var owner = GetName(turret.OwnerID);
            uint lastUsedId;
            if (!_lastUsed.TryGetValue(player, out lastUsedId))
            {
                _config.Turret.GetLimitMessage(ChatMessage.TurretName).SendToChat(player);
                Log("LogLimit", player.displayName, ChatMessage.TurretName, owner, player.ServerPosition,
                    turret.ServerPosition);
                _lastUsed[player] = turret.net.ID;
                return false;
            }

            if (_config.Turret.ClearAll)
            {
                Log("LogCleared", player.displayName, ChatMessage.TurretName, owner, player.ServerPosition,
                    turret.ServerPosition);
                turret.authorizedPlayers.Clear();
                turret.SendNetworkUpdate();
                return null;
            }

            var replaced = turret.authorizedPlayers.FirstOrDefault(x => !HasAuth(x.userid));

            if (replaced == null)
                return null;
            turret.authorizedPlayers.Remove(replaced);
            Log("LogReplaced", player.displayName, GetName(replaced.userid), ChatMessage.TurretName, owner,
                player.ServerPosition, turret.ServerPosition);
            _lastUsed.Remove(player);
            return null;
        }

        #endregion

        #region Checks

        private static bool InSafeZone(BasePlayer player, ulong playerid = 343040)
        {
            return _config.RadiusCheck.DisableInSaveZone && player.InSafeZone();
        }

        private static bool IsNpc(BasePlayer player)
        {
            //BotSpawn
            if (player is NPCPlayer)
                return true;
            return player.userID < 76560000000000000L;
        }

        private static bool HasAuth(BasePlayer player)
        {
            return _config.Admins.IgnoreAdmins && player?.net?.connection?.authLevel >= _config.Admins.AuthLevel;
        }

        private bool HasAuth(ulong playerid = 343040)
        {
            if (!_config.Admins.IgnoreAdmins)
                return false;
            if (permission.UserHasPermission(playerid.ToString(), _config.Admins.IgnorePermission))
                return true;
            if (ServerUsers.Is(playerid, ServerUsers.UserGroup.Moderator))
            {
                return _config.Admins.AuthLevel >= 1;
            }
            if (ServerUsers.Is(playerid, ServerUsers.UserGroup.Owner))
            {
                return _config.Admins.AuthLevel >= 2;
            }
            if (DeveloperList.Contains(playerid))
            {
                return _config.Admins.AuthLevel >= 3;
            }

            return false;
        }

        private static bool IsDuelPlayer(BasePlayer player)
        {
            var dueler = _inst.Duel?.Call("IsPlayerOnActiveDuel", player);
            if (dueler is bool)
                return (bool)dueler;
            return false;
        }

        private static bool InWhitelistedZone(BasePlayer player)
        {
            return _config.InZone(_inst.ZoneManager, player);
        }

        private static bool IsEventPlayer(BasePlayer player)
        {
            var check = _inst.EventManager?.Call("isPlaying", player);
            if (check is bool)
                return (bool)check;
            return false;
        }

        private static bool CanSee(BasePlayer player, BasePlayer target)
        {
            return GamePhysics.LineOfSight(player.eyes.center, player.eyes.position, 2162688) &&
                   (target.IsVisible(player.eyes.HeadRay(),1218519041,float.PositiveInfinity) || target.IsVisible(player.eyes.position));
        }
        
        #endregion

        #region Helpers

        private string GetName(ulong id)
        {
            var player = covalence.Players.FindPlayerById(id.ToString());
            return player == null ? id.ToString() : player.Name;
        }

        private void Log(string langKey, params object[] args)
        {
            var message = new ChatMessage(langKey, args);
            LogToFile("Log", $"({DateTime.Now.ToShortTimeString()}) {message.Read()}", this);

            foreach (var player in BasePlayer.activePlayerList)
            {
                if (!permission.UserHasPermission(player.UserIDString, _config.Generic.LogPermission))
                    continue;

                if (_config.Generic.LogToChat)
                    message.SendToChat(player);
                else
                    message.SendToConsole(player);
            }
        }

        private static string ToRustColor(string input)
        {
            Color color;
            if (ColorUtility.TryParseHtmlString(input, out color))
                return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";

            var split = input.Split(' ');
            for (var i = 0; i < 4; i++)
            {
                float num;
                if (!float.TryParse(split[i], out num)) return null;
                color[i] = num;
            }

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }

        #endregion
    }
}

// --- End of file: TeamGuard.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Skinner-2.1.5.cs ---
// --- Original Local Path: Skinner-2.1.5.cs ---

﻿/* Copyright (C) Whispers88 - All Rights Reserved
 * Unauthorized copying of this file, via any medium is strictly prohibited
 * Proprietary and confidential
 * Written by Whispers88 rustafarian.server@gmail.com, Jan 2025
 * Version 2.1.5
 *
 *You may not copy, modify, merge, publish, distribute, sublicense, or sell copies of This Software without the Developer’s consent

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
   BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
   LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Network;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using ProtoBuf;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Networking;
using UnityEngine.Pool;
using System.Text;
using Facepunch;



namespace Oxide.Plugins
{
    [Info("Skinner", "Whispers88", "2.1.5")]
    [Description("Brings automation and ease to skinning items")]
    public class Skinner : CovalencePlugin
    {
        static Skinner skinner;

        #region Perms
        private const string permdefault = "skinner.default";
        private const string permitems = "skinner.items";
        private const string permcraft = "skinner.craft";
        private const string permskininv = "skinner.skininv";
        private const string permskinteam = "skinner.skinteam";
        private const string permskinteamblock = "skinner.skinteamblock";
        private const string permskincon = "skinner.skincon";
        private const string permbypassauth = "skinner.bypassauth";
        private const string permimport = "skinner.import";
        private const string permskinbase = "skinner.skinbase";
        private const string permskinall = "skinner.skinall";
        private const string permskinauto = "skinner.skinauto";
        private const string permskinautotoggle = "skinner.skinautotoggled";
        private const string permskinrequest = "skinner.skinrequest";
        private const string permskintry = "skinner.permskintry";

        private List<string> permissions = new List<string>() { permdefault, permcraft, permitems, permbypassauth, permskincon, permskininv, permimport, permskinbase, permskinall, permskinteam, permskinteamblock, permskinrequest, permskintry, permskinauto, permskinautotoggle };

        #endregion Perms

        #region Init
        private void OnServerInitialized()
        {
            skinner = this;
            _skinNames = new Dictionary<ulong, string>();
            _cachedSkins = new Dictionary<int, List<ulong>>();
            _WaitForSecondsMore = CoroutineEx.waitForSeconds(1f);

            foreach (string perm in permissions)
                permission.RegisterPermission(perm, this);

            foreach (string perm in config.Cooldowns.Keys)
                permission.RegisterPermission($"skinner.{perm}", this);

            AddCovalenceCommand(config.cmdsskin, "SkinCMD");
            AddCovalenceCommand(config.cmdsskincraft, "DefaultSkinsCMD");
            AddCovalenceCommand(config.cmdsskinitems, "SkinItemCMD");
            AddCovalenceCommand(config.cmdsskininv, "SkinInvCMD");
            AddCovalenceCommand(config.cmdsskincon, "SkinConCMD");
            AddCovalenceCommand(config.cmdtoggleautoskin, "SkinAutoCMD");
            AddCovalenceCommand(config.cmdskinimport, "SkinImportCMD");
            AddCovalenceCommand(config.cmdcollectionimport, "SkinImportCollection");
            AddCovalenceCommand(config.cmdskinbase, "SkinBaseCMD");
            AddCovalenceCommand(config.cmdskinallitems, "SkinAllItemsCMD");
            AddCovalenceCommand(config.cmdskinteam, "SkinTeamCMD");
            AddCovalenceCommand(config.cmdskinrequest, "SkinRequestCMD");
            List<string> tempList = new List<string>(config.cmdskinset);
            tempList.Add("setSelectCMD");
            AddCovalenceCommand(tempList.ToArray(), "SetSelectCMD");
            AddCovalenceCommand(config.cmdskinrequests, "SkinRequestsCMD");

            AddCovalenceCommand(new[] { "sbNextPage" }, "SBNextPageCMD");
            AddCovalenceCommand(new[] { "sbBackPage" }, "SBBackPageCMD");
            AddCovalenceCommand(new[] { "searchCMD" }, "SearchCMD");
            AddCovalenceCommand(new[] { "requestSelectCMD" }, "RequestSelectCMD");

            foreach (var skin in config.ImportedSkinList)
            {
                if (!string.IsNullOrEmpty(skin.Value.itemDisplayname) && !string.IsNullOrEmpty(skin.Value.itemShortname))
                    continue;

                if (_WorkshopSkinIDCollectionList.Contains(skin.Key.ToString()))
                    continue;

                _WorkshopSkinIDCollectionList.Add(skin.Key.ToString());
            }

            if (!config.sprayCanOveride)
                Unsubscribe("OnActiveItemChanged");

            if (!config.useOnItemCraft)
                Unsubscribe("OnItemCraftFinished");

            //InitUI
            InitUI();

            if (getCollectionscouroutine != null)
            {
                Puts("getcollections already running!!");
            }
            else
            {
                getCollectionscouroutine = GetCollectionSkinIDS();
                ServerMgr.Instance.StartCoroutine(getCollectionscouroutine);
            }
        }

        private void Loaded()
        {
            _defaultSkins = Interface.Oxide.DataFileSystem.GetFile("Skinner/DefaultCraftSkins");
            _playerData = Interface.Oxide.DataFileSystem.GetFile("Skinner/PlayerUsageData");
            _skinRequestsData = Interface.Oxide.DataFileSystem.GetFile("Skinner/SkinsRequestData");

            LoadData();
        }
        private void Unload()
        {
            if (getCollectionscouroutine != null)
                ServerMgr.Instance.StopCoroutine(getCollectionscouroutine);
            if (getSteamWorkshopSkinData != null)
                ServerMgr.Instance.StopCoroutine(getSteamWorkshopSkinData);
            if (getSteamWorkshopRequestData != null)
                ServerMgr.Instance.StopCoroutine(getSteamWorkshopRequestData);
            if (notifyDiscordCoroutine != null)
                ServerMgr.Instance.StopCoroutine(notifyDiscordCoroutine);

            foreach (var player in BasePlayer.allPlayerList)
            {
                UI.DestroyUI(player, BSkinPageUI);
                UI.DestroyUI(player, BSkinSearchUI);
                UI.DestroyUI(player, BSkinSetsSelectUI);
                UI.DestroyUI(player, BSkinRequestsUI);

                if (_playerUsageData.TryGetValue(player.userID, out PlayerData playerData))
                    playerData.UpdateLastOnline();
            }

            foreach (var player in BasePlayer.allPlayerList)
            {
                if (player.TryGetComponent<BoxController>(out BoxController boxController))
                {
                    UnityEngine.Object.Destroy(boxController);
                }

                if (player.TryGetComponent<InventoryWatcher>(out InventoryWatcher inventoryWatcher))
                {
                    UnityEngine.Object.Destroy(inventoryWatcher);
                }

                if (player.TryGetComponent<SpraycanController>(out SpraycanController spraycanController))
                {
                    UnityEngine.Object.Destroy(spraycanController);
                }

            }

            SaveData();
            skinner = null;
            _WaitForSecondsMore = null;
        }

        public static Dictionary<ulong, string>? _skinNames;
        public static Dictionary<int, List<ulong>>? _cachedSkins;

        private static ulong maskID = (ulong)1 << 63;
        private ulong SetMask(ulong num)
        {
            return num | maskID;
        }

        public static ulong GetMask(ulong skinID, int itemID, bool redirectSkin = false)
        {
            return redirectSkin ? (ulong)itemID | maskID : skinID;
        }

        public static bool HasMask(ulong uID)
        {
            return (uID & maskID) == maskID;
        }

        public static ulong UnsetMask(ulong num)
        {
            return num & ~maskID;
        }

        private void AddSkin(ulong skinID, int itemID, string displayName, int redirectID = -1)
        {
            if (config.blacklistedskins.Contains(skinID) || config.blacklisteditems.Contains(itemID) || config.blacklisteditems.Contains(redirectID))
                return;

            if (!_cachedSkins.TryGetValue(itemID, out List<ulong> skinsList))
            {
                skinsList = new List<ulong>() { 0ul };
                _cachedSkins[itemID] = skinsList;
            }
            ulong uID = GetMask(skinID, redirectID, redirectID != -1);


            if (!skinsList.Contains(uID))
                skinsList.Add(uID);

            _skinNames[uID] = displayName;
        }

        private int totskins = 0;
        private void GetSkins()
        {
            if ((Steamworks.SteamInventory.Definitions?.Length ?? 0) == 0)
            {
                Puts("Waiting for Steamworks to update skin item definitions");
                Steamworks.SteamInventory.OnDefinitionsUpdated += GetSkins;
                return;
            }
            int sk = 0;
            Puts("Steamworks Updated, Updating Skins");
            Steamworks.SteamInventory.OnDefinitionsUpdated -= GetSkins;

            Dictionary<int, ItemCategory> catDefinitions = new Dictionary<int, ItemCategory>();

            foreach (ItemDefinition itemDef in ItemManager.GetItemDefinitions())
            {
                if (!catDefinitions.ContainsKey(itemDef.itemid))
                {
                    catDefinitions.Add(itemDef.itemid, itemDef.category);
                }

                if (!config.autoImportApproved)
                    break;

                if (itemDef.isRedirectOf != null)
                {
                    AddSkin(0ul, itemDef.isRedirectOf.itemid, string.Empty, itemDef.itemid);
                    continue;
                }

                foreach (var skin in ItemSkinDirectory.ForItem(itemDef))
                {
                    if (skin.id == 0) continue;

                    ItemSkin itemSkin = skin.invItem as ItemSkin;
                    if (itemSkin == null)
                        continue;

                    bool isredirect = itemSkin?.Redirect != null;
                    if (isredirect)
                        AddSkin((ulong)skin.id, itemDef.itemid, skin.invItem?.displayName?.english ?? itemDef.displayName.english, itemSkin.itemDefinition.itemid);
                    else
                        AddSkin((ulong)skin.id, itemDef.itemid, skin.invItem?.displayName?.english ?? itemDef.displayName.english);
                }
            }

            foreach (Steamworks.InventoryDef item in Steamworks.SteamInventory.Definitions)
            {
                if (!config.autoImportApproved)
                    break;

                string shortname = item.GetProperty("itemshortname") == "lr300.item"
                    ? "rifle.lr300"
                    : item.GetProperty("itemshortname");

                if (string.IsNullOrEmpty(shortname) || item.Id < 100)
                    continue;

                ulong skinid;

                if (!ulong.TryParse(item.GetProperty("workshopid"), out skinid))
                {
                    skinid = (ulong)item.Id;
                }

                if (skinid < 1000000) continue;
                ItemDefinition steamitemdef = ItemManager.FindItemDefinition(shortname);

                if (steamitemdef == null)
                    continue;

                if (_cachedSkins.TryGetValue(steamitemdef.itemid, out List<ulong> cachedskinsList))
                {
                    if (cachedskinsList.Contains((ulong)item.Id))
                        continue;
                }

                if (steamitemdef.isRedirectOf != null)
                    AddSkin(skinid, steamitemdef.isRedirectOf.itemid, item.Name, steamitemdef.itemid);
                else
                    AddSkin(skinid, steamitemdef.itemid, item.Name);
            }

            UpdateImportedSkins();

            List<int> skincachekeys = Pool.Get<List<int>>();
            skincachekeys.AddRange(new List<int>(_cachedSkins.Keys));
            for (int i = skincachekeys.Count - 1; i >= 0; i--)
            {
                var item2 = _cachedSkins[skincachekeys[i]];
                if (item2.Count == 1)
                {
                    _cachedSkins.Remove(skincachekeys[i]);
                    continue;
                }

                ItemDefinition itemdef = ItemManager.FindItemDefinition(skincachekeys[i]);
                if (itemdef == null || itemdef?.Blueprint == null)
                {
                    _cachedSkins.Remove(skincachekeys[i]);
                    continue;
                }
                sk += item2.Count;
            }
            Pool.FreeUnmanaged(ref skincachekeys);

            SaveConfig();

            //Re-order to look nice
            List<KeyValuePair<int, List<ulong>>> tempList = new List<KeyValuePair<int, List<ulong>>>(_cachedSkins);

            tempList.Sort((pair1, pair2) => catDefinitions[pair1.Key].CompareTo(catDefinitions[pair2.Key]));

            _cachedSkins.Clear();

            foreach (KeyValuePair<int, List<ulong>> pair in tempList)
            {
                _cachedSkins.Add(pair.Key, pair.Value);
            }

            _cachedSkinKeys = new List<int>(_cachedSkins.Keys);
            Interface.CallHook("OnSkinnerCacheUpdated", _cachedSkins);
            Puts($"{sk} skins were indexed, Skin indexing complete");

        }
        public static List<int>? _cachedSkinKeys;
        private void UpdateImportedSkins()
        {
            List<ulong> keys = Pool.Get<List<ulong>>();
            keys.AddRange(new List<ulong>(config.ImportedSkinList.Keys));

            for (int i = config.ImportedSkinList.Count - 1; i >= 0; i--)
            {
                var whitelistSkin = config.ImportedSkinList[keys[i]];
                if (string.IsNullOrEmpty(whitelistSkin.itemDisplayname) || string.IsNullOrEmpty(whitelistSkin.itemShortname))
                {
                    config.ImportedSkinList.Remove(keys[i]);
                    continue;
                }

                ItemDefinition itemdef = ItemManager.FindItemDefinition(whitelistSkin.itemShortname);

                if (itemdef == null)
                {
                    config.ImportedSkinList.Remove(keys[i]);
                    Puts($"Could not find item definition for {whitelistSkin.itemShortname} {keys[i]}");
                    continue;
                }
                AddSkin(keys[i], itemdef.itemid, whitelistSkin.itemDisplayname);
            }
            Pool.FreeUnmanaged(ref keys);
        }

        #endregion Init

        #region Configuration

        private Configuration config;

        public class Configuration
        {
            [JsonProperty("Skin Commands (skin items in you inventory")]
            public string[] cmdsskin = new[] { "skin", "s", "skinbox", "sb" };

            [JsonProperty("Skin Items Commands (skin items you have already placed")]
            public string[] cmdsskinitems = new[] { "skinitem", "si", "skindeployed", "sd" };

            [JsonProperty("Set default items to be skinned")]
            public string[] cmdsskincraft = new[] { "skincraft", "sc" };

            [JsonProperty("Automatically set all items in you inventory to your default skins")]
            public string[] cmdsskininv = new[] { "skininv", "sinv" };

            [JsonProperty("Automatically set all items a container to your default skins")]
            public string[] cmdsskincon = new[] { "skincon", "scon" };

            [JsonProperty("Automatically skin all deployables in your base")]
            public string[] cmdskinbase = new[] { "skinbase", "skinbuilding" };

            [JsonProperty("Automatically skin all items in your base")]
            public string[] cmdskinallitems = new[] { "skinall", "sa" };

            [JsonProperty("Automatically skin all items that are moved into you inventory")]
            public string[] cmdtoggleautoskin = new[] { "skinauto", "sauto" };

            [JsonProperty("Skin your teams inventories with your skin set")]
            public string[] cmdskinteam = new[] { "skinteam", "st" };

            [JsonProperty("Request workshop skins via workshop ID")]
            public string[] cmdskinrequest = new[] { "skinrequest", "sr" };

            [JsonProperty("Approve workshop skin requests")]
            public string[] cmdskinrequests = new[] { "skinrequests", "srs" };

            [JsonProperty("Set your selected skin set")]
            public string[] cmdskinset = new[] { "skinset", "ss" };

            [JsonProperty("Import Custom Skins")] public string[] cmdskinimport = new[] { "skinimport", "sip" };

            [JsonProperty("Import Workshop Collection Command")] public string[] cmdcollectionimport = new[] { "colimport", "cip" };

            [JsonProperty("Skin Request Notification Discord Webhook")]
            public string DiscordWebhook = "";

            [JsonProperty("Custom Page Change UI Positon anchor/offset 'min x, min y', 'max x', max y'")]
            public string[] uiposition = new[] { "0.5 0.0", "0.5 0.0", "198 60", "400 97" };

            [JsonProperty("Custom Searchbar UI Positon anchor/offset 'min x, min y', 'max x', max y'")]
            public string[] uisearchposition = new[] { "0.5 0.0", "0.5 0.0", "410 635", "572 660" };

            [JsonProperty("Custom Set Selection UI Positon anchor/offset 'min x, min y', 'max x', max y'")]
            public string[] uisetsposition = new[] { "0.5 0.0", "0.5 0.0", "250 610", "573 633" };

            [JsonProperty("Auto import approved skins")]
            public bool autoImportApproved = true;

            [JsonProperty("Remove player data after inactivity (days)")]
            public int removedataTime = 14;

            [JsonProperty("Apply names of skins to skinned items")]
            public bool applySkinNames = true;

            [JsonProperty("Add Search Bar UI")]
            public bool searchbar = true;

            [JsonProperty("Use on itemcraft hook (skin items after crafting - not required when using skinauto)")]
            public bool useOnItemCraft = false;

            [JsonProperty("Override spraycan behaviour")]
            public bool sprayCanOveride = false;

            [JsonProperty("Use spraycan effect when holding spraycan and skinning deployables")]
            public bool sprayCanEffect = true;

            [JsonProperty("Blacklisted Skins (skinID)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ulong> blacklistedskins = new List<ulong>();

            [JsonProperty("Blacklisted Items (itemID)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<int> blacklisteditems = new List<int>();

            [JsonProperty("Import Skin collections (steam workshop ID)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ulong> skinCollectionIDs = new List<ulong>();

            [JsonProperty("Command based cooldowns ('permission' : 'command' seconds")]
            public Dictionary<string, CoolDowns> Cooldowns = new Dictionary<string, CoolDowns>() { { "Default30CD", new CoolDowns() } };

            [JsonProperty("Imported Skins List", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<ulong, ImportedItem> ImportedSkinList = new Dictionary<ulong, ImportedItem>();

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        public struct ImportedItem
        {
            public string itemShortname;
            public string itemDisplayname;
        }

        public struct RequestItem
        {
            public ulong skinID;
            public int itemID;
            public string itemDisplayname;
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }
                var configDict = config.ToDictionary();
                Dictionary<string, object> defaultconObjects = new Dictionary<string, object>();
                foreach (var obj in Config)
                {
                    defaultconObjects.Add(obj.Key, obj.Value);
                }
                if (configDict.Count != defaultconObjects.Count)
                {
                    Puts("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
                else
                {
                    foreach (var key in configDict.Keys)
                    {
                        if (defaultconObjects.ContainsKey(key))
                            continue;

                        Puts("Configuration appears to be outdated; updating and saving");
                        SaveConfig();
                        break;

                    }
                }
            }
            catch
            {
                Puts($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Puts($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region Data
        private DynamicConfigFile _defaultSkins;
        private DynamicConfigFile _playerData;
        private DynamicConfigFile _skinRequestsData;

        private Dictionary<ulong, CoolDowns> _playercooldowns = new Dictionary<ulong, CoolDowns>();

        private Dictionary<ulong, int> _playerSelectedSet = new Dictionary<ulong, int>();

        private void LoadData()
        {
            List<ulong> skipdata = Pool.Get<List<ulong>>();

            try
            {
                _playerUsageData = new Dictionary<ulong, PlayerData>();
                long timenow = DateTimeOffset.UtcNow.ToUnixTimeSeconds();

                //need to read as dec and parse to ulong
                var temp = _playerData.ReadObject<Dictionary<ulong, PlayerDataDec>>();
                foreach (var pair in temp)
                {
                    //Not logged in for two weeks
                    if (timenow - pair.Value.lastonline > config.removedataTime * 86400)
                    {
                        skipdata.Add(pair.Key);
                        continue;
                    }

                    _playerUsageData.Add(pair.Key, new PlayerData() { lastonline = pair.Value.lastonline });

                    foreach (var innerDict in pair.Value.skinusage)
                    {
                        List<ulong> ulongList = new List<ulong>();
                        foreach (decimal d in innerDict.Value)
                        {
                            ulong id = decimal.ToUInt64(d);
                            if (HasMask(id) && config.blacklisteditems.Contains((int)UnsetMask(id)))
                                continue;
                            ulongList.Add(decimal.ToUInt64(d));

                        }
                        _playerUsageData[pair.Key].skinusage.TryAdd(innerDict.Key, ulongList);
                    }
                }
            }
            catch
            {
                _playerUsageData = new Dictionary<ulong, PlayerData>();
            }
            try
            {
                _playerDefaultSkins = new Dictionary<ulong, Dictionary<int, ulong>[]>();
                //need to read as dec and parse to ulong
                var temp = _defaultSkins.ReadObject<Dictionary<ulong, Dictionary<int, decimal>[]>>();
                foreach (var outerPair in temp)
                {
                    if (skipdata.Contains(outerPair.Key))
                        continue;

                    var innerDictArray = new Dictionary<int, ulong>[outerPair.Value.Length];
                    for (int i = 0; i < outerPair.Value.Length; i++)
                    {
                        var innerDict = new Dictionary<int, ulong>();
                        foreach (var innerPair in outerPair.Value[i])
                        {
                            if (HasMask((ulong)innerPair.Value) && config.blacklisteditems.Contains((int)UnsetMask((ulong)innerPair.Value)))
                                continue;
                            innerDict.Add(innerPair.Key, (ulong)innerPair.Value);
                        }
                        innerDictArray[i] = innerDict;
                    }
                    _playerDefaultSkins.Add(outerPair.Key, innerDictArray);
                }
            }
            catch
            {
                _playerDefaultSkins = new Dictionary<ulong, Dictionary<int, ulong>[]>();
            }
            try
            {
                _requestsData = _skinRequestsData.ReadObject<List<RequestItem>>();
            }
            catch
            {
                _requestsData = new List<RequestItem>();
            }
            Pool.FreeUnmanaged(ref skipdata);
        }

        private void SaveData()
        {
            Puts("DataSaved");
            _defaultSkins.WriteObject(_playerDefaultSkins);
            _playerData.WriteObject(_playerUsageData);
            _skinRequestsData.WriteObject(_requestsData);
        }

        private Dictionary<ulong, Dictionary<int, ulong>[]> _playerDefaultSkins;
        private Dictionary<ulong, PlayerData> _playerUsageData;
        private List<RequestItem> _requestsData;

        public class PlayerDataDec
        {
            public Dictionary<int, List<decimal>> skinusage = new Dictionary<int, List<decimal>>();
            public long lastonline { get; set; } = 0;
        }

        public class PlayerData
        {
            public Dictionary<int, List<ulong>> skinusage = new Dictionary<int, List<ulong>>();
            public long lastonline { get; set; } = 0;

            public void AddSkinUsage(ulong skinID, int itemID, int rItemID = 0)
            {
                if (skinID == 0 && rItemID == 0) return;

                if (!skinusage.TryGetValue(itemID, out var list))
                {
                    list = new List<ulong>(6);
                    skinusage[itemID] = list;
                }

                ulong uID = GetMask(skinID, rItemID, rItemID != 0);
                for (int i = list.Count - 1; i >= 0; i--)
                {
                    if (list[i] != uID)
                        continue;

                    list.RemoveAt(i);
                }

                if (list.Count >= 6)
                {
                    list.RemoveAt(0);
                }

                list.Add(uID);
            }

            public List<ulong>? GetSkinUsage(int itemID)
            {
                if (!skinusage.TryGetValue(itemID, out List<ulong>? usageList))
                {
                    return null;
                }
                return usageList;
            }

            public void UpdateLastOnline()
            {
                lastonline = DateTimeOffset.UtcNow.ToUnixTimeSeconds();
            }
        }

        public class CoolDowns
        {
            public float skin = 30f;
            public float skinitem = 30f;
            public float skincraft = 30f;
            public float skincon = 30f;
            public float skininv = 30f;
            public float skinteam = 30f;
            public float skinbase = 60f;
            public float skinall = 60f;
        }
        #endregion Data

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPerms"] = "You don't have permissions to use this command",
                ["NoBuildingAuth"] = "You must have building auth to use this",
                ["NoObjectsFound"] = "No object found",
                ["NoSkins"] = "No skins available",
                ["ImportSkinArgs"] = "Bad args, Required input skinid",
                ["ImportCollectionArgs"] = "Bad args, Required input collectionID",
                ["SkinIDError"] = "Cannot parse skinid {0}",
                ["NoShortname"] = "No item found for shortname : {0}",
                ["DuplicateSkin"] = "Duplicate Skin ID for : {0} {1}",
                ["SkinImported2"] = "Skin {0} has been imported and saved",
                ["SkinRequested"] = "Skin {0} has been requested",
                ["AlreadyRequesting"] = "Already updating requests data please wait...",
                ["RequestingData"] = "Updating requests data please wait...",
                ["CollectionImported2"] = "Steam Skin Collection {0} has been imported and saved",
                ["CommandCooldown"] = "You can not use this command for another {0}",
                ["CompletedInvSkin"] = "All items in your inventory have been set to your default skins",
                ["CompletedConSkin"] = "All items in {0} have been set to your default skins",
                ["CompletedBuildingSkin"] = "All {0} in your base have been set to your default skins",
                ["CompletedAllSkin"] = "All {0} items in your base have been set to your default skins",
                ["SkinSetSelected"] = "Skin set {0} selected",
                ["SkinSetSelectedArgs"] = "Bad args, Required input set No. 1, 2 or 3",
                ["AutoSkinEnabled"] = "Auto skins enabled",
                ["AutoSkinDisabled"] = "Auto skins disabled",
                ["CompletedTeamSkin"] = "All items in your team have been set skin set {0}",
                ["NoTeam"] = "You need to be in a team to use this feature",
                ["TeamSkinBlockEnabled"] = "You enabled team skins",
                ["TeamSkinBlockDisabled"] = "You disabled team skins"
            }, this);
        }

        #endregion Localization

        #region Commands
        private void SkinAutoCMD(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer? player = iplayer.Object as BasePlayer;
            if (player == null) return;

            if (!HasPerm(player.UserIDString, permskinauto))
            {
                ChatMessage(iplayer, "NoPerms");
                return;
            }

            if (!player.TryGetComponent<InventoryWatcher>(out InventoryWatcher inventoryWatcher))
            {
                player.gameObject.AddComponent<InventoryWatcher>();
                ChatMessage(iplayer, "AutoSkinEnabled");
                permission.GrantUserPermission(player.UserIDString, permskinautotoggle, this);
                return;
            }
            permission.RevokeUserPermission(player.UserIDString, permskinautotoggle);

            UnityEngine.Object.Destroy(inventoryWatcher);
            ChatMessage(iplayer, "AutoSkinDisabled");
        }

        private void SkinImportCMD(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer? player = iplayer.Object as BasePlayer;
            if (player != null)
            {
                if (!HasPerm(player.UserIDString, permimport))
                {
                    ChatMessage(iplayer, "NoPerms");
                    return;
                }
            }
            else if (!iplayer.IsServer)
                return;

            if (args.Length < 1)
            {
                ChatMessage(iplayer, "ImportSkinArgs");
                return;
            }

            ulong skinid = 0ul;
            if (!ulong.TryParse(args[0], out skinid))
            {
                ChatMessage(iplayer, "ImportSkinArgs", args[0]);
                return;
            }
            _WorkshopSkinIDCollectionList.Add(skinid.ToString());
            if (getSteamWorkshopSkinData != null)
            {
                Puts("getSteamWorkshopSkinData already running!!");
            }
            else
            {
                getSteamWorkshopSkinData = GetSteamWorkshopSkinData();
                ServerMgr.Instance.StartCoroutine(getSteamWorkshopSkinData);
            }
            ChatMessage(iplayer, "SkinImported2", args[0]);
        }

        private void SkinImportCollection(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = iplayer.Object as BasePlayer;
            if (player != null)
            {
                if (!HasPerm(player.UserIDString, permimport))
                {
                    ChatMessage(iplayer, "NoPerms");
                    return;
                }
            }
            else if (!iplayer.IsServer)
                return;

            if (args.Length < 1)
            {
                ChatMessage(iplayer, "ImportCollectionArgs");
                return;
            }

            ulong collectionid = 0ul;
            if (!ulong.TryParse(args[0], out collectionid))
            {
                ChatMessage(iplayer, "ImportCollectionArgs", args[0]);
                return;
            }

            config.skinCollectionIDs.Add(collectionid);

            if (getCollectionscouroutine != null)
            {
                Puts("getcollections already running!!");
            }
            else
            {
                getCollectionscouroutine = GetCollectionSkinIDS();
                ServerMgr.Instance.StartCoroutine(getCollectionscouroutine);
            }
            ChatMessage(iplayer, "CollectionImported2", args[0]);
        }

        private void SkinCMD(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = iplayer.Object as BasePlayer;
            if (player == null) return;

            if (!HasPerm(player.UserIDString, permdefault))
            {
                ChatMessage(iplayer, "NoPerms");
                return;
            }

            if (_viewingcon.TryGetValue(player.userID, out BoxController? boxController))
            {
                if (boxController != null)
                    UnityEngine.Object.Destroy(boxController);
                _viewingcon.Remove(player.userID);
                return;
            }

            //Check for cooldown
            float cdtime = 0;

            //Find shortest cd perm
            foreach (var cdperm in config.Cooldowns)
            {
                if (!HasPerm(player.UserIDString, $"skinner.{cdperm.Key}")) continue;
                if (cdtime == 0)
                    cdtime = cdperm.Value.skin;
                else if (cdtime > cdperm.Value.skin)
                    cdtime = cdperm.Value.skin;
            }

            if (cdtime > 0)
            {
                if (!_playercooldowns.TryGetValue(player.userID, out CoolDowns? coolDowns))
                    _playercooldowns.Add(player.userID, new CoolDowns() { skin = Time.time });
                else
                {
                    if (coolDowns.skin + cdtime > Time.time)
                    {
                        ChatMessage(iplayer, "CommandCooldown", TimeSpan.FromSeconds(coolDowns.skin + cdtime - Time.time).ToString("hh' hrs 'mm' mins 'ss' secs'"));
                        return;
                    }
                    coolDowns.skin = Time.time;
                }
            }

            ItemContainer itemContainer = CreateContainer();
            if (itemContainer == null)
                return;

            boxController = player.gameObject.AddComponent<BoxController>();
            boxController.inventory = itemContainer;
            boxController.StartAwake();

            boxController.StartItemSkin();

            _viewingcon.Add(player.userID, boxController);

            player.Invoke(() => StartLooting(player, itemContainer), 0.3f);
        }


        private void DefaultSkinsCMD(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = iplayer.Object as BasePlayer;
            if (player == null) return;

            if (!HasPerm(player.UserIDString, permcraft))
            {
                ChatMessage(iplayer, "NoPerms");
                return;
            }

            if (_viewingcon.TryGetValue(player.userID, out BoxController? boxController))
            {
                if (boxController != null)
                    UnityEngine.Object.Destroy(boxController);
                _viewingcon.Remove(player.userID);
                return;
            }

            //Check for cooldown
            float cdtime = 0;
            //Find shortest cd perm
            foreach (var cdperm in config.Cooldowns)
            {
                if (!HasPerm(player.UserIDString, $"skinner.{cdperm.Key}")) continue;
                if (cdtime == 0)
                    cdtime = cdperm.Value.skincraft;
                else if (cdtime > cdperm.Value.skincraft)
                    cdtime = cdperm.Value.skincraft;
            }

            if (cdtime > 0)
            {
                if (!_playercooldowns.TryGetValue(player.userID, out CoolDowns? coolDowns))
                    _playercooldowns.Add(player.userID, new CoolDowns() { skincraft = Time.time });
                else
                {
                    if (coolDowns.skincraft + cdtime > Time.time)
                    {
                        ChatMessage(iplayer, "CommandCooldown", TimeSpan.FromSeconds(coolDowns.skincraft + cdtime - Time.time).ToString("hh' hrs 'mm' mins 'ss' secs'"));
                        return;
                    }
                    coolDowns.skincraft = Time.time;
                }
            }

            if (!_playerDefaultSkins.ContainsKey(player.userID))
                _playerDefaultSkins.Add(player.userID, new Dictionary<int, ulong>[3]
                {
                    new Dictionary<int, ulong>(),
                    new Dictionary<int, ulong>(),
                    new Dictionary<int, ulong>()
                });

            ItemContainer itemContainer = CreateContainer();

            boxController = player.gameObject.AddComponent<BoxController>();
            boxController.inventory = itemContainer;

            boxController.StartAwake();
            boxController.SkinCraft();

            _viewingcon.TryAdd(player.userID, boxController);

            player.Invoke(() => StartLooting(player, itemContainer), 0.3f);
        }

        private void SkinRequestCMD(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = iplayer.Object as BasePlayer;
            if (player == null) return;

            if (!HasPerm(player.UserIDString, permskinrequest))
            {
                ChatMessage(iplayer, "NoPerms");
                return;
            }

            if (args.Length < 1)
            {
                ChatMessage(iplayer, "ImportSkinArgs");
                return;
            }

            if (!ulong.TryParse(args[0], out ulong skinidResult))
            {
                ChatMessage(iplayer, "ImportSkinArgs");
                return;
            }

            ChatMessage(iplayer, "SkinRequested", skinidResult);

            foreach (var a in _requestsData)
            {
                if (a.skinID == skinidResult)
                    return;
            }

            _requestsData.Add(new RequestItem { skinID = skinidResult });

            if (string.IsNullOrEmpty(config.DiscordWebhook))
                return;


            _discordData.Add(new DiscordData() { SkinID = skinidResult, player = player });
            if (notifyDiscordCoroutine != null)
            {
                Puts("getcollections already running!!");
            }
            else
            {
                notifyDiscordCoroutine = NotifyDiscord();
                ServerMgr.Instance.StartCoroutine(notifyDiscordCoroutine);
            }
        }

        private void SkinRequestsCMD(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = iplayer.Object as BasePlayer;
            if (player == null) return;

            if (!HasPerm(player.UserIDString, permimport))
            {
                ChatMessage(iplayer, "NoPerms");
                return;
            }

            if (_requestsData.Count == 0)
            {
                ChatMessage(iplayer, "NoRequests");
                return;
            }

            if (getSteamWorkshopRequestData != null)
            {
                ChatMessage(iplayer, "AlreadyRequesting");
                return;
            }
            else
            {
                ChatMessage(iplayer, "RequestingData");
                getSteamWorkshopRequestData = GetSteamWorkshopSkinRequests();
                ServerMgr.Instance.StartCoroutine(getSteamWorkshopRequestData);
            }


            if (_viewingcon.TryGetValue(player.userID, out BoxController? boxController))
            {
                if (boxController != null)
                    UnityEngine.Object.Destroy(boxController);
                _viewingcon.Remove(player.userID);
                return;
            }

            ItemContainer itemContainer = CreateContainer();

            boxController = player.gameObject.AddComponent<BoxController>();
            boxController.inventory = itemContainer;

            boxController.StartAwake();

            _viewingcon.TryAdd(player.userID, boxController);

            player.StartCoroutine(CheckforRequests(player, itemContainer, boxController));
        }

        private static WaitForSeconds _WaitForSecondsMore;

        private IEnumerator CheckforRequests(BasePlayer player, ItemContainer itemContainer, BoxController boxController)
        {
            yield return _WaitForSecondsMore;
            int i = 0;
            for (i = 0; i < 15; i++)
            {
                if (getSteamWorkshopRequestData == null)
                    break;
                ChatMessage(player.IPlayer, "Updating requests data please wait...");
                yield return _WaitForSecondsMore;
            }

            if (i >= 15)
            {
                ChatMessage(player.IPlayer, "Updating requests timed out try again later");
                UnityEngine.Object.Destroy(boxController);
            }
            else
            {
                boxController.SkinRequests();
                StartLooting(player, itemContainer);
            }
        }

        private static int Layermask = LayerMask.GetMask("Deployed", "Construction");
        private void SkinItemCMD(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = iplayer.Object as BasePlayer;
            if (player == null) return;

            if (!HasPerm(player.UserIDString, permitems))
            {
                ChatMessage(iplayer, "NoPerms");
                return;
            }

            if (player.inventory.loot.IsLooting())
            {
                player.EndLooting();
                return;
            }

            if (!player.CanBuild() && !HasPerm(player.UserIDString, permbypassauth))
            {
                ChatMessage(iplayer, "NoBuildingAuth");
                return;
            }

            RaycastHit raycastHit;
            if (!Physics.Raycast(player.eyes.HeadRay(), out raycastHit, 5f, Layermask))
            {
                ChatMessage(iplayer, "NoObjectsFound");
                return;
            }
            BaseCombatEntity entity = raycastHit.GetEntity() as BaseCombatEntity;
            ItemDefinition? itemDefinition = null;
            if (entity.pickup.itemTarget != null)
            {
                itemDefinition = entity.pickup.itemTarget;
            }
            else if (entity.repair.itemTarget != null)
            {

                itemDefinition = entity.repair.itemTarget;
            }

            if (itemDefinition == null)
            {
                ChatMessage(iplayer, "NoObjectsFound");
                return;
            }

            if (!_cachedSkins.ContainsKey(itemDefinition.isRedirectOf != null ? itemDefinition.isRedirectOf.itemid : itemDefinition.itemid))
            {
                ChatMessage(iplayer, "NoSkins");
                return;
            }

            if (_viewingcon.TryGetValue(player.userID, out BoxController? boxController))
            {
                if (boxController != null)
                    UnityEngine.Object.Destroy(boxController);
                _viewingcon.Remove(player.userID);
                return;
            }

            //Check for cooldown
            float cdtime = 0;
            //Find shortest cd perm
            foreach (var cdperm in config.Cooldowns)
            {
                if (!HasPerm(player.UserIDString, $"skinner.{cdperm.Key}")) continue;
                if (cdtime == 0)
                    cdtime = cdperm.Value.skinitem;
                else if (cdtime > cdperm.Value.skinitem)
                    cdtime = cdperm.Value.skinitem;
            }

            if (cdtime > 0)
            {
                if (!_playercooldowns.TryGetValue(player.userID, out CoolDowns? coolDowns))
                    _playercooldowns.Add(player.userID, new CoolDowns() { skinitem = Time.time });
                else
                {
                    if (coolDowns.skinitem + cdtime > Time.time)
                    {
                        ChatMessage(iplayer, "CommandCooldown", TimeSpan.FromSeconds(coolDowns.skinitem + cdtime - Time.time).ToString("hh' hrs 'mm' mins 'ss' secs'"));
                        return;
                    }
                    coolDowns.skinitem = Time.time;
                }
            }

            if (args.Length > 0 && int.TryParse(args[0], out int setselect))
            {
                Dictionary<int, ulong> cachedskins = GetCachedSkins(player, setselect);

                if (cachedskins.Count < 1)
                    return;

                int itemID = itemDefinition.isRedirectOf != null ? itemDefinition.isRedirectOf.itemid : itemDefinition.itemid;

                if (cachedskins.TryGetValue(itemID, out ulong uID))
                {
                    SkinDeployable(entity, uID);
                }
                return;
            }

            ItemContainer itemContainer = CreateContainer();

            boxController = player.gameObject.AddComponent<BoxController>();
            boxController.inventory = itemContainer;

            boxController.StartAwake();

            boxController.SkinDeplyoables(entity, itemDefinition);

            _viewingcon.TryAdd(player.userID, boxController);

            player.Invoke(() => StartLooting(player, itemContainer), 0.3f);
        }

        private void SkinInvCMD(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = iplayer.Object as BasePlayer;
            if (player == null) return;

            if (!HasPerm(player.UserIDString, permskininv))
            {
                ChatMessage(iplayer, "NoPerms");
                return;
            }

            int setselect = -1;
            if (args.Length > 0 && !int.TryParse(args[0], out setselect))
            {
                setselect = -1;
            }

            Dictionary<int, ulong> cachedskins = GetCachedSkins(player, setselect);

            if (cachedskins.Count < 1)
                return;

            if (player.inventory == null)
                return;

            //Check for cooldown
            float cdtime = 0;
            //Find shortest cd perm
            foreach (var cdperm in config.Cooldowns)
            {
                if (!HasPerm(player.UserIDString, $"skinner.{cdperm.Key}")) continue;
                if (cdtime == 0)
                    cdtime = cdperm.Value.skininv;
                else if (cdtime > cdperm.Value.skininv)
                    cdtime = cdperm.Value.skininv;
            }

            if (cdtime > 0)
            {
                if (!_playercooldowns.TryGetValue(player.userID, out CoolDowns? coolDowns))
                    _playercooldowns.Add(player.userID, new CoolDowns() { skininv = Time.time });
                else
                {
                    if (coolDowns.skininv + cdtime > Time.time)
                    {
                        ChatMessage(iplayer, "CommandCooldown", TimeSpan.FromSeconds(coolDowns.skininv + cdtime - Time.time).ToString("hh' hrs 'mm' mins 'ss' secs'"));
                        return;
                    }
                    coolDowns.skininv = Time.time;
                }
            }

            List<Item> itemstoSkin = Pool.Get<List<Item>>();
            player.inventory.GetAllItems(itemstoSkin);

            for (int i = 0; i < itemstoSkin.Count; i++)
            {
                Item item = itemstoSkin[i];
                if (item == null) continue;

                if (item.IsBackpack())
                {
                    if (item?.contents != null && !item.contents.itemList.IsNullOrEmpty()) //Fix for diving tanks
                    {
                        foreach (var bitem in item.contents.itemList)
                            itemstoSkin.Add(bitem);
                    }
                    continue;
                }


                if (cachedskins.TryGetValue(item.info.isRedirectOf != null ? item.info.isRedirectOf.itemid : item.info.itemid, out ulong uID))
                {
                    //skip blacklisted skin
                    if (config.blacklistedskins.Contains(item.skin) || config.blacklisteditems.Contains(item.info.itemid)) continue;

                    SkinItem(item, uID);
                }
            }

            Pool.FreeUnmanaged(ref itemstoSkin);

            player.SendNetworkUpdateImmediate();
            ChatMessage(iplayer, "CompletedInvSkin");
        }

        private void SkinTeamCMD(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = iplayer.Object as BasePlayer;
            if (player == null) return;

            if (!HasPerm(player.UserIDString, permskinteam))
            {
                ChatMessage(iplayer, "NoPerms");
                return;
            }

            if (args.Length > 0)
            {
                if (args[0].ToLower() == "toggle")
                {
                    if (HasPerm(player.UserIDString, permskinteamblock))
                    {
                        permission.RevokeUserPermission(player.UserIDString, permskinteamblock);
                        ChatMessage(iplayer, "TeamSkinBlockEnabled");

                    }
                    else
                    {
                        permission.GrantUserPermission(player.UserIDString, permskinteamblock, this);
                        ChatMessage(iplayer, "TeamSkinBlockDisabled");

                    }

                    return;
                }
            }

            int setselect = -1;
            if (args.Length > 0 && !int.TryParse(args[0], out setselect))
            {
                setselect = -1;
            }

            Dictionary<int, ulong> cachedskins = GetCachedSkins(player, setselect);

            if (cachedskins.Count < 1)
                return;

            if (player.Team == null)
            {
                ChatMessage(iplayer, "NoTeam");
                return;
            }

            if (player.inventory == null)
                return;

            RelationshipManager.ServerInstance.playerToTeam.TryGetValue(player.userID, out RelationshipManager.PlayerTeam playerTeam);

            if (playerTeam.members.Count == 0)
                return;

            //Check for cooldown
            float cdtime = 0;
            //Find shortest cd perm
            foreach (var cdperm in config.Cooldowns)
            {
                if (!HasPerm(player.UserIDString, $"skinner.{cdperm.Key}")) continue;
                if (cdtime == 0)
                    cdtime = cdperm.Value.skinteam;
                else if (cdtime > cdperm.Value.skinteam)
                    cdtime = cdperm.Value.skinteam;
            }

            if (cdtime > 0)
            {
                if (!_playercooldowns.TryGetValue(player.userID, out CoolDowns? coolDowns))
                    _playercooldowns.Add(player.userID, new CoolDowns() { skinteam = Time.time });
                else
                {
                    if (coolDowns.skinteam + cdtime > Time.time)
                    {
                        ChatMessage(iplayer, "CommandCooldown", TimeSpan.FromSeconds(coolDowns.skinteam + cdtime - Time.time).ToString("hh' hrs 'mm' mins 'ss' secs'"));
                        return;
                    }
                    coolDowns.skinteam = Time.time;
                }
            }


            List<Item> itemstoSkin = Pool.Get<List<Item>>();
            List<BasePlayer> teamplayersList = new List<BasePlayer>();
            foreach (var teamplayer in playerTeam.members)
            {
                BasePlayer? teamBasePlayer = null;
                foreach (var allPlayer in BasePlayer.allPlayerList)
                {
                    if (allPlayer == null || allPlayer.userID != teamplayer)
                        continue;
                    teamBasePlayer = allPlayer;
                    break;
                }

                if (teamBasePlayer == null || teamBasePlayer.inventory == null)
                    continue;

                teamplayersList.Add(teamBasePlayer);
                if (HasPerm(teamBasePlayer.UserIDString, permskinteamblock))
                    continue;

                if (teamBasePlayer.inventory.containerMain != null)
                    itemstoSkin.AddRange((IEnumerable<Item>)teamBasePlayer.inventory.containerMain.itemList);
                if (teamBasePlayer.inventory.containerBelt != null)
                    itemstoSkin.AddRange((IEnumerable<Item>)teamBasePlayer.inventory.containerBelt.itemList);
                if (teamBasePlayer.inventory.containerWear != null)
                    itemstoSkin.AddRange((IEnumerable<Item>)teamBasePlayer.inventory.containerWear.itemList);

            }

            for (int i = 0; i < itemstoSkin.Count; i++)
            {
                Item item = itemstoSkin[i];
                if (item == null) continue;

                if (item.IsBackpack())
                {
                    if (item?.contents != null && !item.contents.itemList.IsNullOrEmpty()) //Fix for diving tanks
                    {
                        foreach (var bitem in item.contents.itemList)
                            itemstoSkin.Add(bitem);
                    }
                    continue;
                }

                if (cachedskins.TryGetValue(item.info.isRedirectOf != null ? item.info.isRedirectOf.itemid : item.info.itemid, out ulong uID))
                {
                    //skip blacklisted skin
                    if (config.blacklistedskins.Contains(item.skin) || config.blacklisteditems.Contains(item.info.itemid)) continue;

                    SkinItem(item, uID);
                }
            }

            foreach (var teambp in teamplayersList)
            {
                if (!teambp.IsSleeping()) continue;
                SendNetworkUpdate(teambp);
            }

            Pool.FreeUnmanaged(ref itemstoSkin);

            ChatMessage(iplayer, "CompletedTeamSkin", setselect != -1 ? setselect : string.Empty);
        }

        private void SkinConCMD(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = iplayer.Object as BasePlayer;
            if (player == null) return;

            if (!HasPerm(player.UserIDString, permskincon))
            {
                ChatMessage(iplayer, "NoPerms");
                return;
            }
            if (!player.IsBuildingAuthed() && !HasPerm(player.UserIDString, permbypassauth))
            {
                ChatMessage(iplayer, "NoBuildingAuth");
                return;
            }

            int setselect = -1;
            if (args.Length > 0 && !int.TryParse(args[0], out setselect))
            {
                setselect = -1;
            }

            Dictionary<int, ulong> cachedskins = GetCachedSkins(player, setselect);

            if (cachedskins.Count < 1)
                return;

            RaycastHit raycastHit;
            if (!Physics.Raycast(player.eyes.HeadRay(), out raycastHit, 5f, Layermask))
            {
                ChatMessage(iplayer, "NoObjectsFound");
                return;
            }

            StorageContainer storage = raycastHit.GetEntity() as StorageContainer;
            if (storage == null || storage?.inventory == null)
            {
                ChatMessage(iplayer, "NoObjectsFound");
                return;
            }

            //Check for cooldown
            float cdtime = 0;
            //Find shortest cd perm
            foreach (var cdperm in config.Cooldowns)
            {
                if (!HasPerm(player.UserIDString, $"skinner.{cdperm.Key}")) continue;
                if (cdtime == 0)
                    cdtime = cdperm.Value.skincon;
                else if (cdtime > cdperm.Value.skincon)
                    cdtime = cdperm.Value.skincon;
            }

            if (cdtime > 0)
            {
                if (!_playercooldowns.TryGetValue(player.userID, out CoolDowns? coolDowns))
                    _playercooldowns.Add(player.userID, new CoolDowns() { skincon = Time.time });
                else
                {
                    if (coolDowns.skincon + cdtime > Time.time)
                    {
                        ChatMessage(iplayer, "CommandCooldown", TimeSpan.FromSeconds(coolDowns.skincon + cdtime - Time.time).ToString("hh' hrs 'mm' mins 'ss' secs'"));
                        return;
                    }
                    coolDowns.skincon = Time.time;
                }
            }

            foreach (Item item in storage.inventory.itemList)
            {
                if (item == null) continue;

                if (cachedskins.TryGetValue(item.info.isRedirectOf != null ? item.info.isRedirectOf.itemid : item.info.itemid, out ulong uID))
                {
                    //skip blacklisted skin
                    if (config.blacklistedskins.Contains(item.skin) || config.blacklisteditems.Contains(item.info.itemid)) continue;

                    SkinItem(item, uID);
                }
            }

            ChatMessage(iplayer, "CompletedConSkin", storage.ShortPrefabName);
        }

        private void SkinBaseCMD(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = iplayer.Object as BasePlayer;
            if (player == null) return;

            if (!HasPerm(player.UserIDString, permskinbase))
            {
                ChatMessage(iplayer, "NoPerms");
                return;
            }
            Dictionary<int, ulong> cachedskins = GetCachedSkins(player);

            if (cachedskins.Count < 1)
                return;

            if (!player.IsBuildingAuthed() && !HasPerm(player.UserIDString, permbypassauth))
            {
                ChatMessage(iplayer, "NoBuildingAuth");
                return;
            }
            BuildingPrivlidge buildingPrivlidge = player.GetBuildingPrivilege();
            if (buildingPrivlidge == null)
            {
                ChatMessage(iplayer, "NoBuildingAuth");
                return;
            }
            BuildingManager.Building buildingManager = buildingPrivlidge.GetBuilding();
            if (buildingManager == null)
            {
                ChatMessage(iplayer, "NoBuildingAuth");
                return;
            }

            //Check for cooldown
            float cdtime = 0;
            //Find shortest cd perm
            foreach (var cdperm in config.Cooldowns)
            {
                if (!HasPerm(player.UserIDString, $"skinner.{cdperm.Key}")) continue;
                if (cdtime == 0)
                    cdtime = cdperm.Value.skinbase;
                else if (cdtime > cdperm.Value.skinbase)
                    cdtime = cdperm.Value.skinbase;
            }

            if (cdtime > 0)
            {
                if (!_playercooldowns.TryGetValue(player.userID, out CoolDowns? coolDowns))
                    _playercooldowns.Add(player.userID, new CoolDowns() { skinbase = Time.time });
                else
                {
                    if (coolDowns.skinbase + cdtime > Time.time)
                    {
                        ChatMessage(iplayer, "CommandCooldown", TimeSpan.FromSeconds(coolDowns.skinbase + cdtime - Time.time).ToString("hh' hrs 'mm' mins 'ss' secs'"));
                        return;
                    }
                    coolDowns.skinbase = Time.time;
                }
            }

            string skinned = "all deployables";
            if (args.Length > 0)
            {
                skinned = $"{args[0]}s";
            }

            foreach (var decayent in buildingManager.decayEntities)
            {
                BaseCombatEntity? baseCombatEntity = decayent?.GetEntity() as BaseCombatEntity;
                if (baseCombatEntity == null || baseCombatEntity.pickup.itemTarget == null) continue;

                if (args.Length > 0)
                {
                    if (!baseCombatEntity.pickup.itemTarget.shortname.Contains(args[0]))
                        continue;
                }

                int itemID = baseCombatEntity.pickup.itemTarget.isRedirectOf != null ? baseCombatEntity.pickup.itemTarget.isRedirectOf.itemid : baseCombatEntity.pickup.itemTarget.itemid;
                if (cachedskins.TryGetValue(itemID, out ulong uID))
                {

                    SkinDeployable(baseCombatEntity, uID);

                }
            }
            ChatMessage(iplayer, "CompletedBuildingSkin", skinned);
        }

        private Dictionary<int, ulong> GetCachedSkins(BasePlayer player, int set = -1)
        {
            Dictionary<int, ulong>[] cachedskins;

            if (set == -1)
            {
                if (!_playerSelectedSet.TryGetValue(player.userID, out set))
                    set = 1;
            }

            if (!_playerDefaultSkins.TryGetValue(player.userID, out cachedskins))
            {
                cachedskins = new Dictionary<int, ulong>[3]
                {
                    new Dictionary<int, ulong>(),
                    new Dictionary<int, ulong>(),
                    new Dictionary<int, ulong>()
                };


                _playerDefaultSkins[player.userID] = cachedskins;
                ChatMessage(player.IPlayer, "NoDefaultSkins");
                return cachedskins[0];
            }

            switch (set)
            {
                case 2:
                    {
                        if (cachedskins[1] == null)
                            cachedskins[1] = new Dictionary<int, ulong>();
                        return cachedskins[1];
                    }
                case 3:
                    {
                        if (cachedskins[2] == null)
                            cachedskins[2] = new Dictionary<int, ulong>();
                        return cachedskins[2];
                    }
            }

            if (cachedskins[0] == null)
            {
                cachedskins[0] = new Dictionary<int, ulong>();
            }

            return cachedskins[0];
        }

        private void SkinAllItemsCMD(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = iplayer.Object as BasePlayer;
            if (player == null) return;
            if (!HasPerm(player.UserIDString, permskinall))
            {
                ChatMessage(iplayer, "NoPerms");
                return;
            }

            Dictionary<int, ulong> cachedskins = GetCachedSkins(player);

            if (cachedskins.Count < 1)
                return;

            if (!player.IsBuildingAuthed() && !HasPerm(player.UserIDString, permbypassauth))
            {
                ChatMessage(iplayer, "NoBuildingAuth");
                return;
            }
            BuildingPrivlidge buildingPrivlidge = player.GetBuildingPrivilege();
            if (buildingPrivlidge == null)
            {
                ChatMessage(iplayer, "NoBuildingAuth");
                return;
            }
            BuildingManager.Building buildingManager = buildingPrivlidge.GetBuilding();
            if (buildingManager == null)
            {
                ChatMessage(iplayer, "NoBuildingAuth");
                return;
            }

            //Check for cooldown
            float cdtime = 0;
            //Find shortest cd perm
            foreach (var cdperm in config.Cooldowns)
            {
                if (!HasPerm(player.UserIDString, $"skinner.{cdperm.Key}")) continue;
                if (cdtime == 0)
                    cdtime = cdperm.Value.skinall;
                else if (cdtime > cdperm.Value.skinall)
                    cdtime = cdperm.Value.skinall;
            }

            if (cdtime > 0)
            {
                if (!_playercooldowns.TryGetValue(player.userID, out CoolDowns? coolDowns))
                    _playercooldowns.Add(player.userID, new CoolDowns() { skinall = Time.time });
                else
                {
                    if (coolDowns.skinall + cdtime > Time.time)
                    {
                        ChatMessage(iplayer, "CommandCooldown", TimeSpan.FromSeconds(coolDowns.skinall + cdtime - Time.time).ToString("hh' hrs 'mm' mins 'ss' secs'"));
                        return;
                    }
                    coolDowns.skinall = Time.time;
                }
            }

            string skinned = "items";
            ItemDefinition itemdef = null;
            if (args.Length > 0)
            {
                itemdef = ItemManager.FindItemDefinition(args[0]);
                if (itemdef == null)
                {
                    ChatMessage(iplayer, "NoShortname", args[0]);
                    return;
                }
                skinned = itemdef.shortname;
            }

            foreach (var decayent in buildingManager.decayEntities)
            {
                StorageContainer storageContainer = decayent?.GetEntity() as StorageContainer;
                if (storageContainer == null) continue;
                foreach (var item in storageContainer.inventory.itemList)
                {
                    if (itemdef != null)
                    {
                        if (item.info.shortname != itemdef.shortname)
                            continue;
                    }

                    if (cachedskins.TryGetValue(item.info.itemid, out ulong uID))
                    {
                        SkinItem(item, uID);
                    }
                }
            }
            ChatMessage(iplayer, "CompletedAllSkin", skinned);
        }

        public Dictionary<BasePlayer, BoxController> _boxcontrollers = new Dictionary<BasePlayer, BoxController>();

        private void SBNextPageCMD(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer? player = iplayer.Object as BasePlayer;
            if (player == null) return;
            if (!_viewingcon.TryGetValue(player.userID, out BoxController? boxController)) return;

            if (boxController._fillingbox || boxController._clearingbox)
                return;
            boxController.NextPage();
        }

        private void SBBackPageCMD(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer? player = iplayer.Object as BasePlayer;
            if (player == null) return;
            if (!_viewingcon.TryGetValue(player.userID, out BoxController? boxController)) return;
            if (boxController._fillingbox || boxController._clearingbox)
                return;
            boxController.BackPage();
        }

        private void SearchCMD(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = iplayer.Object as BasePlayer;
            if (player == null) return;

            if (!_viewingcon.TryGetValue(player.userID, out BoxController? boxController)) return;

            if (boxController._fillingbox || boxController._clearingbox)
                return;

            string searchtxt = string.Join(",", args).Replace(",", " ");

            if (searchtxt.Trim().ToLower() == "search id or name")
                searchtxt = string.Empty;

            if (boxController.searchtxt == searchtxt) return;

            boxController.searchtxt = searchtxt;
            boxController.SearchUpdate();
        }

        private void SetSelectCMD(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = iplayer.Object as BasePlayer;
            if (player == null) return;
            if (args.Length != 1)
            {
                ChatMessage(iplayer, "SkinSetSelectedArgs");
                return;
            }
            int setselect = 0;

            if (!int.TryParse(args[0], out setselect))
            {
                ChatMessage(iplayer, "SkinSetSelectedArgs");
                return;
            }

            _playerSelectedSet[player.userID] = setselect;
            ChatMessage(iplayer, "SkinSetSelected", setselect);

            if (player.TryGetComponent<InventoryWatcher>(out InventoryWatcher inventoryWatcher))
            {
                inventoryWatcher.refreshSkins();
            }

            if (!_viewingcon.TryGetValue(player.userID, out BoxController? boxController)) return;

            if (boxController._fillingbox || boxController._clearingbox)
                return;

            boxController.setSelect = setselect;
            boxController.SetUpdate();
        }

        private void RequestSelectCMD(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer? player = iplayer.Object as BasePlayer;
            if (player == null) return;
            if (args.Length != 1)
            {
                return;
            }

            if (!_viewingcon.TryGetValue(player.userID, out BoxController boxController)) return;

            if (boxController._fillingbox || boxController._clearingbox)
                return;

            if (args[0] == "Try" || args[0] == "Approve" || args[0] == "Deny")
            {
                boxController.requestselected = args[0];
            }
            else
            {
                player.EndLooting();
                return;
            }

            boxController.SkinRequests();
        }

        #endregion Commands

        #region Hooks

        private Dictionary<ulong, BoxController> _viewingcon = new Dictionary<ulong, BoxController>();
        private void OnPlayerLootEnd(PlayerLoot instance)
        {
            if (!_viewingcon.TryGetValue(instance.baseEntity.userID, out BoxController? boxController)) return;
            if (boxController.boxtype == "craftskins")
            {
                if (instance.baseEntity.TryGetComponent<InventoryWatcher>(out InventoryWatcher inventoryWatcher))
                {
                    inventoryWatcher.refreshSkins();
                }
            }
            if (boxController != null)
                UnityEngine.Object.Destroy(boxController);
            _viewingcon.Remove(instance.baseEntity.userID);
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (!HasPerm(player.UserIDString, permskinautotoggle))
                return;
            if (!HasPerm(player.UserIDString, permskinauto))
                return;

            if (!player.TryGetComponent<InventoryWatcher>(out InventoryWatcher inventoryWatcher))
            {
                player.gameObject.AddComponent<InventoryWatcher>();
            }
        }

        private void OnPlayerDisconnected(BasePlayer player, string strReason)
        {
            if (player.TryGetComponent<SpraycanController>(out SpraycanController spraycanController))
            {
                UnityEngine.Object.Destroy(spraycanController);
            }
            if (player.TryGetComponent<InventoryWatcher>(out InventoryWatcher inventoryWatcher))
            {
                UnityEngine.Object.Destroy(inventoryWatcher);
            }

            if (_playerUsageData.TryGetValue(player.userID, out PlayerData playerData))
                playerData.UpdateLastOnline();
        }

        private void OnItemCraftFinished(ItemCraftTask task, Item item, ItemCrafter itemCrafter)
        {
            if (task.skinID != 0)
                return;

            BasePlayer player = itemCrafter.owner;

            if (player == null) return;

            if (!HasPerm(player.UserIDString, permdefault))
                return;

            Dictionary<int, ulong> cached = GetCachedSkins(player);

            if (cached.Count < 1)
                return;

            if (!cached.TryGetValue(item.info.itemid, out ulong uID))
                return;

            SkinItem(item, uID);
        }

        private object OnItemAction(Item item, string action, BasePlayer player)
        {
            if (item.text == "1")
            {
                item.RemoveFromContainer();
                item.Remove();
                return true;
            }
            return null;
        }

        #endregion Hooks

        #region Methods
        private static string _coffinPrefab = "assets/prefabs/misc/halloween/coffin/coffinstorage.prefab";
        private BaseEntity _limitedEntity = new BaseEntity() { _limitedNetworking = true };
        private ItemContainer CreateContainer()
        {
            ItemContainer itemContainer = new ItemContainer()
            {
                entityOwner = _limitedEntity,
                allowedContents = ItemContainer.ContentsType.Generic,
            };
            itemContainer.maxStackSize = 0;
            itemContainer.ServerInitialize(null, 48);
            itemContainer.GiveUID();
            return itemContainer;
        }

        private void StartLooting(BasePlayer player, ItemContainer itemContainer)
        {
            if (player == null || itemContainer == null || itemContainer.uid == default(ItemContainerId) || !player.IsAlive() || !_viewingcon.ContainsKey(player.userID)) return;
            player.inventory.loot.Clear();
            player.inventory.loot.AddContainer(itemContainer);
            player.inventory.loot.entitySource = RelationshipManager.ServerInstance;
            player.inventory.loot.PositionChecks = false;
            player.inventory.loot.MarkDirty();
            player.SendNetworkUpdateImmediate();

            RPCStartLooting(player);
        }

        private static readonly uint RPCOpenLootstr = StringPool.Get("RPC_OpenLootPanel");
        private static readonly byte[] RPCOpenLootbytes = Encoding.UTF8.GetBytes("generic_resizable");

        public static void RPCStartLooting(BasePlayer player)
        {
            RpcTarget result = default;
            result.Function = "RPC_OpenLootPanel";
            result.Connections = new SendInfo(player.net.connection);

            NetWrite netWrite = Net.sv.StartWrite();
            netWrite.PacketID(Message.Type.RPCMessage);
            netWrite.EntityID(player.net.ID);
            netWrite.UInt32(RPCOpenLootstr);

            netWrite.BytesWithSize(RPCOpenLootbytes);

            netWrite.Send(result.Connections);

            if (result.UsingPooledConnections)
            {
                Pool.FreeUnmanaged<Connection>(ref result.Connections.connections);
            }
        }
        public void SkinItem(Item item, ulong uID)
        {
            int redirectitemID = 0;
            if (item.info.isRedirectOf != null)
                redirectitemID = item.info.isRedirectOf.itemid;
            if (HasMask(uID))
                redirectitemID = (int)UnsetMask(uID);
            //redirect skins
            if (redirectitemID != 0)
            {
                Item redirectitem = ItemManager.CreateByItemID(redirectitemID, item.amount, !HasMask(uID) ? uID : 0ul);

                if (redirectitem == null) return;

                redirectitem.text = "1";
                redirectitem.maxCondition = item.maxCondition;
                redirectitem.condition = item.condition;

                if (item.contents?.itemList.Count > 0)
                {
                    foreach (var con in item.contents.itemList)
                    {
                        var newCon = ItemManager.Create(con.info, con.amount, con.skin);
                        newCon.condition = con.condition;
                        newCon.maxCondition = con.maxCondition;
                        newCon.MoveToContainer(redirectitem.contents);
                        newCon.MarkDirty();
                    }
                    redirectitem.contents.MarkDirty();
                }

                if (skinner.config.applySkinNames)
                {
                    if (redirectitem.skin != 0ul && _skinNames.TryGetValue(uID, out string displayName))
                        redirectitem.name = displayName;
                }

                BaseEntity held1 = redirectitem.GetHeldEntity();
                if (held1 != null)
                {
                    BaseEntity mainheld = item.GetHeldEntity();
                    if (mainheld != null)
                    {
                        BaseProjectile mainbaseProjectile = mainheld as BaseProjectile;
                        BaseProjectile baseProjectile = held1 as BaseProjectile;
                        if (baseProjectile != null && mainbaseProjectile != null)
                        {
                            baseProjectile.primaryMagazine.contents = mainbaseProjectile.primaryMagazine.contents;
                            baseProjectile.primaryMagazine.ammoType = mainbaseProjectile.primaryMagazine.ammoType;
                        }
                    }
                    held1.skinID = redirectitem.skin;
                    held1.SendNetworkUpdate();
                }

                //Swap item

                NextTick(() => {
                    int pos = item.position;
                    ItemContainer parent = item.parent;
                    if (parent == null || item == null)
                    {
                        redirectitem.Remove();
                        return;
                    }

                    DoRemove(item);
                    if (!redirectitem.MoveToContainer(parent, pos, false))
                        redirectitem.Drop(parent.dropPosition, parent.dropVelocity);
                    redirectitem.text = string.Empty;
                });
            }
            else
            {
                item.skin = uID;

                if (skinner.config.applySkinNames)
                {
                    if (_skinNames.TryGetValue(uID, out string displayName))
                        item.name = displayName;
                    //item.info.displayName.english = cachedSkin.displayName;
                }

                BaseEntity held = item.GetHeldEntity();
                if (held != null)
                {
                    held.skinID = uID;
                }
                item.MarkDirty();
            }
        }

        public BaseCombatEntity? SkinDeployable(BaseCombatEntity baseCombatEntity, ulong uID)
        {
            ItemDefinition? entDef = null;
            if (baseCombatEntity.pickup.itemTarget != null)
            {
                entDef = baseCombatEntity.pickup.itemTarget;
            }
            else if (baseCombatEntity.repair.itemTarget != null)
            {
                entDef = baseCombatEntity.repair.itemTarget;
            }

            if (entDef == null)
                return null;

            if (!HasMask(uID) && entDef.isRedirectOf == null)
            {
                if (uID == baseCombatEntity.skinID)
                    return baseCombatEntity;

                baseCombatEntity.skinID = uID;
                //Skin Deployable
                if (baseCombatEntity.skinID < 100000)
                {
                    SendNetworkUpdate(baseCombatEntity);
                }
                else
                {
                    baseCombatEntity.SendNetworkUpdateImmediate();
                }

                return baseCombatEntity;
            }
            //re-createentity for redirect skin

            if (HasMask(uID))
                entDef = ItemManager.FindItemDefinition((int)UnsetMask(uID));
            else if (entDef.isRedirectOf != null)
                entDef = entDef.isRedirectOf;

            if (entDef == null)
                return null;

            if (!GetEntityPrefabPath(entDef, out string respath))
                return null;

            Vector3 vector31 = baseCombatEntity.transform.localPosition;
            Quaternion quaternion = baseCombatEntity.transform.localRotation;
            BaseEntity parentEntity = baseCombatEntity.GetParentEntity();
            float single = baseCombatEntity._health;
            EntityRef[] slots = baseCombatEntity.GetSlots();
            ulong ownerID = baseCombatEntity.OwnerID;
            float single1 = (baseCombatEntity != null ? baseCombatEntity.lastAttackedTime : 0f);
            HashSet<PlayerNameID> playerNameIDs = null;

            BuildingPrivlidge buildingPrivlidge = baseCombatEntity.GetBuildingPrivilege();
            if (buildingPrivlidge != null)
            {
                playerNameIDs = new HashSet<PlayerNameID>(buildingPrivlidge.authorizedPlayers);
            }

            bool flag1 = (baseCombatEntity is Door || baseCombatEntity is BuildingPrivlidge);

            Dictionary<ContainerSet, List<Item>> containerSets = new Dictionary<ContainerSet, List<Item>>();
            SaveEntityStorage(baseCombatEntity, containerSets, 0);

            List<ChildPreserveInfo> list = Pool.Get<List<ChildPreserveInfo>>();
            if (!flag1)
            {
                for (int i = 0; i < baseCombatEntity.children.Count; i++)
                {
                    SaveEntityStorage(baseCombatEntity.children[i], containerSets, -1);
                }
            }
            else
            {
                foreach (BaseEntity child in baseCombatEntity.children)
                {
                    ChildPreserveInfo childPreserveInfo = new ChildPreserveInfo()
                    {
                        TargetEntity = child,
                        TargetBone = child.parentBone,
                        LocalPosition = child.transform.localPosition,
                        LocalRotation = child.transform.localRotation,
                    };
                    list.Add(childPreserveInfo);
                }

                foreach (ChildPreserveInfo childPreserveInfo1 in list)
                {
                    childPreserveInfo1.TargetEntity.SetParent(null, true, false);
                }
            }

            baseCombatEntity.Kill(BaseNetworkable.DestroyMode.None);
            BaseEntity newent = GameManager.server.CreateEntity(respath,
                (parentEntity != null ? parentEntity.transform.TransformPoint(vector31) : vector31),
                (parentEntity != null ? parentEntity.transform.rotation * quaternion : quaternion), true);
            newent.SetParent(parentEntity, false, false);
            newent.transform.localPosition = vector31;
            newent.transform.localRotation = quaternion;
            newent.OwnerID = ownerID;

            if (!HasMask(uID))
                newent.skinID = uID;

            DecayEntity decayEntity = newent as DecayEntity;
            if (decayEntity != null)
            {
                decayEntity.AttachToBuilding(null);
            }

            newent.Spawn();
            BaseCombatEntity baseCombatEntity1 = newent as BaseCombatEntity;
            if (baseCombatEntity1 != null)
            {
                baseCombatEntity1.SetHealth(single);
                baseCombatEntity1.lastAttackedTime = single1;
            }

            BuildingPrivlidge buildingPrivlidge1 = newent as BuildingPrivlidge;
            if (buildingPrivlidge1 != null && playerNameIDs != null)
            {
                buildingPrivlidge1.authorizedPlayers = playerNameIDs;
            }

            if (containerSets.Count > 0)
            {
                RestoreEntityStorage(newent, 0, containerSets);
                if (!flag1)
                {
                    for (int j = 0; j < newent.children.Count; j++)
                    {
                        RestoreEntityStorage(newent.children[j], -1, containerSets);
                    }
                }

                foreach (KeyValuePair<ContainerSet, List<Item>> containerSet in containerSets)
                {
                    foreach (Item value in containerSet.Value)
                    {
                        value.Remove(0f);
                    }
                }
            }

            if (flag1)
            {
                foreach (ChildPreserveInfo child in list)
                {
                    child.TargetEntity.SetParent(baseCombatEntity1, child.TargetBone, true, false);
                    child.TargetEntity.transform.localPosition = child.LocalPosition;
                    child.TargetEntity.transform.localRotation = child.LocalRotation;
                    child.TargetEntity.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                }

                baseCombatEntity1.SetSlots(slots);
            }

            Pool.FreeUnmanaged<ChildPreserveInfo>(ref list);

            return baseCombatEntity1;

        }

        #region Spraycan Code from Assembly
        private struct ChildPreserveInfo
        {
            public BaseEntity TargetEntity;

            public uint TargetBone;

            public Vector3 LocalPosition;

            public Quaternion LocalRotation;
        }

        private struct ContainerSet
        {
            public int ContainerIndex;

            public uint PrefabId;
        }

        private bool GetEntityPrefabPath(ItemDefinition def, out string resourcePath)
        {
            ItemModDeployable itemModDeployable;
            ItemModEntity itemModEntity;
            ItemModEntityReference itemModEntityReference;
            resourcePath = string.Empty;
            if (def.TryGetComponent<ItemModDeployable>(out itemModDeployable))
            {
                resourcePath = itemModDeployable.entityPrefab.resourcePath;
                return true;
            }
            if (def.TryGetComponent<ItemModEntity>(out itemModEntity))
            {
                resourcePath = itemModEntity.entityPrefab.resourcePath;
                return true;
            }
            if (!def.TryGetComponent<ItemModEntityReference>(out itemModEntityReference))
            {
                return false;
            }
            resourcePath = itemModEntityReference.entityPrefab.resourcePath;
            return true;
        }

        void SaveEntityStorage(BaseEntity baseEntity, Dictionary<ContainerSet, List<Item>> dictionary, int index)
        {
            uint num;
            IItemContainerEntity itemContainerEntity = baseEntity as IItemContainerEntity;
            if (itemContainerEntity != null)
            {
                ContainerSet containerSet = new ContainerSet()
                {
                    ContainerIndex = index
                };
                if (index == 0)
                {
                    num = 0;
                }
                else
                {
                    num = baseEntity.prefabID;
                }
                containerSet.PrefabId = num;
                ContainerSet containerSet1 = containerSet;
                if (dictionary.ContainsKey(containerSet1))
                {
                    return;
                }
                dictionary.Add(containerSet1, new List<Item>());
                foreach (Item item in itemContainerEntity.inventory.itemList)
                {
                    dictionary[containerSet1].Add(item);
                }
                foreach (Item item1 in dictionary[containerSet1])
                {
                    item1.RemoveFromContainer();
                }
            }
        }

        void RestoreEntityStorage(BaseEntity baseEntity, int index, Dictionary<ContainerSet, List<Item>> copy)
        {
            uint num;
            IItemContainerEntity itemContainerEntity = baseEntity as IItemContainerEntity;
            if (itemContainerEntity != null)
            {
                ContainerSet containerSet = new ContainerSet()
                {
                    ContainerIndex = index
                };
                if (index == 0)
                {
                    num = 0;
                }
                else
                {
                    num = baseEntity.prefabID;
                }
                containerSet.PrefabId = num;
                ContainerSet containerSet1 = containerSet;
                if (copy.ContainsKey(containerSet1))
                {
                    foreach (Item item in copy[containerSet1])
                    {
                        item.MoveToContainer(itemContainerEntity.inventory, -1, true, false, null, true);
                    }
                    copy.Remove(containerSet1);
                }
            }
        }
        #endregion Spraycan Code from Assembly

        #endregion Methods

        #region Inventory Watcher
        private class InventoryWatcher : FacepunchBehaviour
        {
            private BasePlayer player;
            bool _enabled = true;
            Dictionary<int, ulong> cachedSkins;

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                cachedSkins = skinner.GetCachedSkins(player);
                subContainerWatch();
            }

            private void subContainerWatch()
            {
                player.inventory.containerBelt.onItemAddedRemoved += skinWatch;
                player.inventory.containerWear.onItemAddedRemoved += skinWatch;
                player.inventory.containerMain.onItemAddedRemoved += skinWatch;
            }

            private void skinWatch(Item item, bool f)
            {
                if (!f || item.text == "1" || skinner._viewingcon.ContainsKey(player.userID)) return;

                if (cachedSkins.IsNullOrEmpty() || (item.info ?? null) == null) return;

                if (cachedSkins.TryGetValue(item.info?.isRedirectOf == null ? item.info.itemid : item.info.isRedirectOf.itemid, out ulong uID))
                {
                    skinner.SkinItem(item, uID);
                }
            }

            public void refreshSkins()
            {
                cachedSkins = skinner.GetCachedSkins(player);
            }

            private void OnDestroy()
            {
                player.inventory.containerBelt.onItemAddedRemoved -= skinWatch;
                player.inventory.containerWear.onItemAddedRemoved -= skinWatch;
                player.inventory.containerMain.onItemAddedRemoved -= skinWatch;
            }
        }
        #endregion Inventory Watcher

        #region Spraycan Controller

        private static int spraycanid = -596876839;
        void OnActiveItemChanged(BasePlayer player, Item oldItem, Item newItem)
        {
            if (newItem == null)
            {
                if (oldItem?.info?.itemid == spraycanid)
                {
                    SpraycanController spraycanController;
                    if (player.TryGetComponent<SpraycanController>(out spraycanController))
                    {
                        UnityEngine.Object.Destroy(spraycanController);
                    }
                }

                return;
            }

            if (newItem.info.itemid == spraycanid)
            {
                SpraycanController spraycanController;
                if (!player.TryGetComponent<SpraycanController>(out spraycanController))
                {
                    player.gameObject.AddComponent<SpraycanController>();
                    return;
                }
            }

            if (oldItem != null)
            {
                if (oldItem.info.itemid == spraycanid)
                {
                    SpraycanController spraycanController;
                    if (player.TryGetComponent<SpraycanController>(out spraycanController))
                    {
                        UnityEngine.Object.Destroy(spraycanController);
                    }
                }

            }
        }

        private class SpraycanController : FacepunchBehaviour
        {
            private BasePlayer player;
            private SprayCan sprayCan;
            private string skinitem = "SkinItem";
            BUTTON _fire2 = BUTTON.FIRE_SECONDARY;
            BaseEntity.Flags fbusy = BaseEntity.Flags.Busy;
            float lasttime = 0f;
            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                sprayCan = player.GetHeldEntity() as SprayCan;
                if (sprayCan == null)
                {
                    Destroy(this);
                    return;
                }
                sprayCan.SetFlag(fbusy, true, true, true);
            }

            private void FixedUpdate()
            {
                if (player == null || !player.serverInput.IsDown(_fire2) || !player.serverInput.WasDown(_fire2))
                    return;

                if (Time.time < lasttime + 0.5f)
                    return;

                lasttime = Time.time;
                player.serverInput.previous.buttons = 0;

                skinner.SkinItemCMD(player.IPlayer, skinitem, Array.Empty<string>());
            }
        }

        #endregion Spraycan Controller

        #region Box Controller
        //black magic
        public Queue<Item> itemPool = new Queue<Item>();
        public class BoxController : FacepunchBehaviour
        {
            public ItemContainer inventory;
            private BasePlayer player;
            private Item? mainitem = null;
            private Item? returnitem = null;
            private Item? returnitemplayer = null;

            private Vector3 ogpos;
            public bool _fillingbox = false;
            public bool _clearingbox = false;
            private ItemDefinition? itemselected = null;
            public BaseCombatEntity? maindeployable = null;
            public string searchtxt = string.Empty;
            public int setSelect = 1;
            public string requestselected = "Try";

            public Dictionary<int, ulong> setSkins;

            bool rebuildsearchUI = false;
            bool rebuildPageUI = false;

            bool fsearchUI = false;
            bool fpageUI = false;
            bool fskinSetsUI = false;
            bool fskinRequestsUI = false;

            public string boxtype = string.Empty;

            private int page = 0;
            private int scpage = 0;

            public void StartAwake()
            {
                player = GetComponent<BasePlayer>();

                ogpos = player.transform.position;

                //disable stacks
                inventory.maxStackSize = 1;
                inventory.onPreItemRemove = Preremove;
            }

            private void Preremove(Item item)
            {
                if (item.amount == 0)
                {
                    bool flag1 = false;

                    foreach (var item2 in inventory.itemList)
                    {
                        if (item2.amount <= 1)
                            continue;
                        flag1 = true;
                        item2.amount = 1;
                    }
                    if (!flag1)
                    {
                        List<Item>? items = GetPlayerItems(item.info.itemid);
                        if (items != null)
                        {
                            foreach (var item1 in items)
                            {
                                if (item1.skin != item.skin) continue;
                                item1.amount -= 1;
                                if (item1.amount < 1)
                                    DoRemove(item1);
                                else
                                    item1.MarkDirty();
                                flag1 = false;
                                break;
                            }

                            if (flag1 && items.Count > 0)
                            {
                                Item item2 = items[0];
                                item2.amount -= 1;
                                if (item2.amount < 1)
                                    DoRemove(item2);
                                else
                                    item2.MarkDirty();
                            }
                            Pool.FreeUnmanaged(ref items);
                        }
                    }
                }

                if (boxtype != "deployableskins" && boxtype != "itemskins")
                    return;

                int itempos = item.position;
                int usagecnt = usageskins == null ? 0 : usageskins.Count;

                if (cachedskins == null || item.position < 0)
                {
                    mainitem = null;
                    return;
                }

                // for inserting new item
                if (posWatchItem?.info != null && item.info.itemid != posWatchItem?.info?.itemid && posWatchItem?.parent == null && !posWatchItem.IsDroppedInWorld(true))
                {
                    return;
                }

                //block item insert
                if (item.text == "1")
                {
                    InsertItem(GetMask(item.skin, item.info.itemid, item.info.isRedirectOf != null), itemselected, 1, item.position);
                }

                posWatchItem = null;
                bool isredirect = item.info.isRedirectOf != null;
                if (item.skin != 0 || isredirect)
                {
                    if (!skinner._playerUsageData.TryGetValue(player.userID, out PlayerData? playerData))
                    {
                        skinner._playerUsageData[player.userID] = new PlayerData();
                    }
                    skinner._playerUsageData[player.userID].AddSkinUsage(item.skin, isredirect ? item.info.isRedirectOf.itemid : item.info.itemid, isredirect ? item.info.itemid : 0);
                }
            }

            #region Skin Deployables

            public void SkinDeplyoables(BaseCombatEntity entity, ItemDefinition itemDefinition)
            {
                boxtype = "deployableskins";

                inventory.onItemAddedRemoved = CheckforItemDply;
                inventory.SetFlag(ItemContainer.Flag.IsLocked, true);
                maindeployable = entity;
                rebuildsearchUI = true;
                itemselected = itemDefinition.isRedirectOf != null ? itemDefinition.isRedirectOf : itemDefinition;
                GetDeployableSkins();
            }

            private void CheckforItemDply(Item item, bool b)
            {
                //if item added
                if (b)
                {
                    if (_fillingbox)
                        return;

                    if (item == returnitem)
                    {
                        returnitem = null;
                        return;
                    }

                    returnitemplayer = item;
                    GiveItem(returnitemplayer);
                    return;
                }

                //item removed
                if (_clearingbox || _fillingbox)
                    return;

                searchtxt = string.Empty;
                if (maindeployable == null)
                {
                    item.Remove(0f);
                    player.EndLooting();
                    return;
                }

                if (item == returnitemplayer)
                {
                    returnitemplayer = null;
                    return;
                }

                bool isRedirect = item.info.isRedirectOf != null;
                ulong uID = GetMask(item.skin, item.info.itemid, isRedirect);
                maindeployable = skinner.SkinDeployable(maindeployable, uID);

                ////Spray Can Effects
                if (skinner.config.sprayCanEffect)
                {
                    SprayCan can = player.GetHeldEntity() as SprayCan;
                    if (can != null)
                        can.ClientRPC<int, ulong>(null, "Client_ReskinResult", 1, maindeployable.net.ID.Value);
                }

                returnitem = item;

                item.Remove(0f);
            }

            private void GetDeployableSkins(bool skipchecks = false)
            {
                if (!skipchecks || cachedskins == null)
                {
                    if (!PrepareSkins(itemselected))
                        return;
                }

                //Fill container
                FillSkins(itemselected);

                inventory.SetFlag(ItemContainer.Flag.IsLocked, false);
                inventory.SetFlag(ItemContainer.Flag.NoItemInput, false);

                inventory.MarkDirty();
            }

            private void FillSkins(ItemDefinition itemdef, bool bbreak = true)
            {
                _fillingbox = true;

                if (inventory.itemList.Count > 0)
                    ClearCon();

                int i = 0;
                int usagecnt = usageskins == null ? 0 : usageskins.Count;
                int maxIndex = Math.Min(48, cachedskins.Count + usagecnt - 48 * page);

                for (i = 0; i < maxIndex; i++)
                {
                    ulong cachedskin = i >= usagecnt ? cachedskins[i + (48 * page) - usagecnt] : usageskins[usagecnt - i - 1];
                    InsertItem(cachedskin, itemdef, 1, i);
                }
                _fillingbox = false;

            }

            #endregion Skin Deployables

            #region Skin Items

            private int olditempos;
            private ItemContainer oldcon;
            private Item? posWatchItem;
            private Item? backpack;
            public void StartItemSkin()
            {
                boxtype = "itemskins";
                //enable stacks
                inventory.maxStackSize = 0;

                inventory.onItemAddedRemoved = CheckforItem;

                inventory.onItemAddedToStack = OnItemAddedToStack;

                player.inventory.containerMain.onPreItemRemove += PosWatch;
                player.inventory.containerWear.onPreItemRemove += PosWatch;
                player.inventory.containerBelt.onPreItemRemove += PosWatch;

                backpack = player.inventory.containerWear?.GetSlot(ItemContainer.BackpackSlotIndex) ?? null;

                if (backpack?.contents == null || backpack.contents.itemList.IsNullOrEmpty())
                    return;

                backpack.contents.onPreItemRemove += PosWatch;
            }
            private Item SplitItem(Item item2, int split_Amount)
            {
                if (split_Amount <= 0)
                {
                    return null;
                }

                if (split_Amount >= item2.amount)
                {
                    return null;
                }

                item2.amount -= split_Amount;
                Item item = ItemManager.CreateByItemID(item2.info.itemid, 1, 0uL);
                item.amount = split_Amount;
                item.skin = item2.skin;
                if (item2.IsBlueprint())
                {
                    item.blueprintTarget = item2.blueprintTarget;
                }

                if (item2.info.amountType == ItemDefinition.AmountType.Genetics && item2.instanceData != null && item2.instanceData.dataInt != 0)
                {
                    item.instanceData = new ProtoBuf.Item.InstanceData();
                    item.instanceData.dataInt = item2.instanceData.dataInt;
                    item.instanceData.ShouldPool = false;
                }

                if (item2.instanceData != null && item2.instanceData.dataInt > 0 && item2.info != null && item2.info.Blueprint != null && item2.info.Blueprint.workbenchLevelRequired == 3)
                {
                    item.instanceData = new ProtoBuf.Item.InstanceData();
                    item.instanceData.dataInt = item2.instanceData.dataInt;
                    item.instanceData.ShouldPool = false;
                    item.SetFlag(Item.Flag.IsOn, item2.IsOn());
                }

                item2.MarkDirty();
                return item;

            }
            private void OnItemAddedToStack(Item item, int amount)
            {
                item.amount += amount;
                Item newitem = SplitItem(item, amount);
                skinner.NextTick(() => {
                    if (newitem.amount > 0)
                    {
                        mainitem = GiveItem(newitem);
                        rebuildsearchUI = true;
                    }
                    GetSkins();
                });
            }

            private void PosWatch(Item item)
            {
                if (item.text == "1")
                {
                    return;
                }

                if (backpack != null && item.parent == backpack?.contents)
                {
                    if (backpack.position != ItemContainer.BackpackSlotIndex || player.inventory.containerWear != backpack.parent)
                    {
                        backpack.contents.onPreItemRemove -= PosWatch;
                        backpack = null;
                        return;
                    }
                }
                olditempos = item.position;
                oldcon = item.parent;
                posWatchItem = item;
            }

            private void CheckforItem(Item item, bool b)
            {
                //if item removed
                if (!b)
                {
                    if (_clearingbox || _fillingbox || item.uid == mainitem?.uid)
                        return;

                    if (posWatchItem != null && posWatchItem.uid != mainitem?.uid)
                    {
                        item.Remove();
                        return;
                    }
                    if (mainitem?.info == null || (mainitem?.parent?.playerOwner ?? null) != player && !(backpack != null && mainitem?.parent == backpack?.contents))
                    {
                        item.Remove();
                        ResetCon();
                        return;
                    }

                    ItemRemoveCheck(item);
                    return;
                }

                //if item added
                if (_fillingbox)
                    return;

                if (item.text == "1")
                {
                    ClearCon();
                    GetSkins();
                    return;
                }

                if (mainitem?.info != null)
                {
                    rebuildPageUI = true;
                    if (item.uid != mainitem.uid)
                    {
                        if (item.info.itemid != mainitem.info.itemid)
                        {
                            if (!string.IsNullOrEmpty(searchtxt))
                                rebuildsearchUI = true;

                            page = 0;
                            searchtxt = string.Empty;
                            cachedskins = null;
                        }
                    }
                }
                else
                {
                    rebuildsearchUI = true;
                    page = 0;
                    searchtxt = string.Empty;
                    cachedskins = null;
                }

                mainitem = item;
                //if (!item.MoveToContainer(oldcon, olditempos))
                //    GiveItem(item);

                for (int i = 0; i < inventory.itemList.Count; i++)
                {
                    if (inventory.itemList[i].uid.Value != item.uid.Value)
                        continue;

                    inventory.itemList.RemoveAt(i);
                    break;
                }

                if (oldcon != null && posWatchItem?.uid == item.uid)
                {
                    item.position = olditempos;

                    oldcon.itemList.Add(item);
                    item.parent = oldcon;

                    item.MarkDirty();

                    oldcon.onItemAddedRemoved(item, true);
                }
                else
                {
                    mainitem = GiveItem(item);
                }
                //----------------------//

                //olditempos = -1;
                //oldcon = null;

                //if inv is full add extra slot
                if (player.inventory.containerMain.itemList.Count == player.inventory.containerMain.capacity && player.inventory.containerBelt.itemList.Count == player.inventory.containerBelt.capacity)
                {
                    player.inventory.containerMain.capacity = 25;
                }

                if (mainitem.info.stackable > 1 || mainitem.MaxStackable() > 1)
                    inventory.maxStackSize = 1;
                else
                    inventory.maxStackSize = 0;

                usageskins = null;

                inventory.capacity = 48;

                GetSkins();

            }

            private List<ulong>? cachedskins;
            private List<ulong>? usageskins;
            private void GetSkins(bool skipchecks = false)
            {
                if (mainitem == null)
                {
                    ClearCon();
                    return;
                }

                itemselected = mainitem.info.isRedirectOf == null ? mainitem.info : mainitem.info.isRedirectOf;

                if (!skipchecks || cachedskins == null)
                {
                    if (!PrepareSkins(itemselected))
                        return;
                }

                //Fill container
                FillSkins(itemselected);

                inventory.SetFlag(ItemContainer.Flag.IsLocked, false);
                inventory.SetFlag(ItemContainer.Flag.NoItemInput, false);

                inventory.MarkDirty();

                inventory.capacity = 49;
            }

            private void ResetCon()
            {
                //skinner.ChatMessage(player.IPlayer, "NoSkins");
                ClearCon();
                cachedskins = null;

                if (fsearchUI)
                    fsearchUI = UI.DestroyUI(player, BSkinSearchUI);

                if (fpageUI)
                    fpageUI = UI.DestroyUI(player, BSkinPageUI);

                inventory.SetFlag(ItemContainer.Flag.NoItemInput, false);
                inventory.SetFlag(ItemContainer.Flag.IsLocked, false);
                mainitem = null;
                inventory.maxStackSize = 0;
            }

            private bool searchtextwas = false;
            private bool PrepareSkins(ItemDefinition itemdef)
            {
                //Blacklisted Skin
                if (IsMainItemBlacklisted(mainitem) || IsMainDeployableBlacklisted(maindeployable))
                {
                    ResetCon();
                    return false;
                }

                //No Skins Found
                if (cachedskins == null)
                {
                    if (!_cachedSkins.TryGetValue(itemdef.itemid, out cachedskins))
                    {
                        ResetCon();
                        return false;
                    }

                    searchtextwas = false;
                }

                //Get Skins List
                if (!string.IsNullOrEmpty(searchtxt))
                {
                    if (searchtextwas)
                    {
                        _cachedSkins.TryGetValue(itemdef.itemid, out cachedskins);
                    }

                    List<ulong> cachedskins2 = new List<ulong>();

                    foreach (var cachedSkin in cachedskins)
                    {
                        if (!_skinNames.TryGetValue(cachedSkin, out string displayName))
                            continue;

                        if (displayName.Contains(searchtxt, StringComparison.CurrentCultureIgnoreCase) || cachedSkin.ToString().Contains(searchtxt))
                        {
                            cachedskins2.Add(cachedSkin);
                        }
                    }
                    if (cachedskins2.Count > 0)
                        cachedskins = cachedskins2;

                    searchtextwas = true;
                }

                //try sort skins here
                else if ((boxtype == "itemskins" || boxtype == "deployableskins") && skinner._playerUsageData.TryGetValue(player.userID, out PlayerData playerData))
                {
                    var a = playerData.GetSkinUsage(itemdef.itemid);
                    if (a != null)
                        usageskins = new List<ulong>(a);
                }

                if (page > (cachedskins.Count - 1) / 48)
                    page = 0;

                if (page < 0)
                    page = (cachedskins.Count - 1) / 48;

                //Search Bar UI
                if (skinner.config.searchbar && rebuildsearchUI)
                {
                    if (fsearchUI)
                        fsearchUI = UI.DestroyUI(player, BSkinSearchUI);

                    fsearchUI = UI.AddUI(player, skinner.AddSearchUI(searchtxt));
                    rebuildsearchUI = false;
                }

                //Add UI on first fill
                if (inventory.itemList.Count == 0 || rebuildPageUI)
                {
                    if (fpageUI)
                        fpageUI = UI.DestroyUI(player, BSkinPageUI);

                    //Check for UI
                    if (cachedskins.Count > 48)
                    {
                        fpageUI = UI.AddUI(player, skinner.AddPageUI(page + 1, (cachedskins.Count - 1) / 48 + 1));
                    }
                }
                return true;
            }

            public void QuickRemove(Item item)
            {
                if (item.parent != null)
                {
                    inventory.itemList.Remove(item);
                }
                item.parent = null;
                item.position = 0;

                skinner.itemPool.Enqueue(item);
            }


            private void ItemRemoveCheck(Item item)
            {
                if (mainitem?.parent == null)
                {
                    item.Remove(0);
                    ResetCon();
                    return;
                }

                //quick skin
                if (item.info.itemid == mainitem.info.itemid)
                {
                    mainitem.skin = item.skin;

                    if (skinner.config.applySkinNames)
                    {
                        mainitem.name = item.name;
                        //mainitem.info.displayName.english = item.info.displayName.english;
                    }
                    item.Remove(0f);

                    BaseEntity held1 = mainitem.GetHeldEntity();
                    if (held1 != null)
                    {
                        held1.skinID = mainitem.skin;
                        if (player.svActiveItemID == mainitem.uid)
                        {
                            UpdateActiveItem(player, mainitem);
                            //player.inventory.UpdatedVisibleHolsteredItems();
                            skinner.SendNetworkUpdate(held1);

                        }
                    }
                    mainitem.MarkDirty();

                    //update last used skins values here
                    if (!skinner._playerUsageData.ContainsKey(player.userID))
                    {
                        skinner._playerUsageData[player.userID] = new PlayerData();
                    }
                    return;
                }

                //logic
                if ((item.info.isRedirectOf != null ? item.info.isRedirectOf.itemid : item.info.itemid) != (mainitem.info.isRedirectOf != null ? mainitem.info.isRedirectOf.itemid : mainitem.info.itemid))
                {
                    item.Remove();
                    ResetCon();
                    return;
                }

                Item newitem = ItemManager.CreateByItemID(item.info.itemid, mainitem.amount, item.skin);

                newitem.maxCondition = mainitem.maxCondition;
                newitem.condition = mainitem.condition;
                newitem.info.name = name;

                item.Remove();

                if (mainitem.contents?.itemList.Count > 0)
                {
                    foreach (var con in mainitem.contents.itemList)
                    {
                        var newCon = ItemManager.Create(con.info, con.amount, con.skin);
                        newCon.condition = con.condition;
                        newCon.maxCondition = con.maxCondition;
                        newCon.MoveToContainer(newitem.contents);
                        newCon.MarkDirty();
                    }
                    newitem.contents.MarkDirty();
                }

                BaseEntity held = newitem.GetHeldEntity();
                if (held != null)
                {
                    BaseEntity mainheld = mainitem.GetHeldEntity();
                    if (mainheld != null)
                    {
                        BaseProjectile mainbaseProjectile = mainheld as BaseProjectile;
                        BaseProjectile baseProjectile = held as BaseProjectile;
                        if (baseProjectile != null && mainbaseProjectile != null)
                        {
                            baseProjectile.canUnloadAmmo = true;
                            baseProjectile.primaryMagazine.contents = mainbaseProjectile.primaryMagazine.contents;
                            baseProjectile.primaryMagazine.ammoType = mainbaseProjectile.primaryMagazine.ammoType;
                        }
                    }
                }

                var parContainer = mainitem.parent;
                var parPos = mainitem.position;
                bool flag1 = posWatchItem?.uid == mainitem.uid;

                mainitem.Remove(0f);
                inventory.SetLocked(true);
                posWatchItem = null;

                skinner.NextTick(() =>
                {
                    DoRemove(mainitem);
                    DoRemove(item);
                    if (parPos == 24 && parContainer == player.inventory.containerMain)
                    {
                        ResetCon();
                        newitem.Drop(player.eyes.position, player.eyes.HeadForward() * 2, player.eyes.rotation);
                    }
                    else
                    {
                        newitem.position = parPos;
                        newitem.parent = parContainer;
                        parContainer.itemList.Add(newitem);
                        newitem.MarkDirty();
                        parContainer.onItemAddedRemoved(newitem, true);
                    }
                    newitem.RecalulateParentEntity(true);
                    posWatchItem = null;
                    mainitem = newitem;
                });

                Invoke(() => {
                    inventory.SetLocked(false);
                }, 0.5f);
            }

            public void UpdateActiveItem(BasePlayer player, Item item)
            {
                Invoke(() =>
                {
                    if (player == null || player.IsDestroyed || player.IsDead())
                        return;

                    Item activeItem2 = player.GetActiveItem();
                    if (activeItem2 != null)
                    {
                        HeldEntity heldEntity2 = activeItem2.GetHeldEntity() as HeldEntity;
                        if (heldEntity2 != null)
                        {
                            heldEntity2.SetHeld(bHeld: true);
                        }
                    }
                    //player.inventory.UpdatedVisibleHolsteredItems();
                }, 0.1f);
            }
            #endregion Skin Items

            #region Set Default Skins

            public void SkinCraft()
            {
                boxtype = "craftskins";

                setSelect = skinner._playerSelectedSet.GetValueOrDefault(player.userID);

                setSkins = skinner.GetCachedSkins(player);

                //if inv is full add extra slot
                if (player.inventory.containerMain.itemList.Count == player.inventory.containerMain.capacity && player.inventory.containerBelt.itemList.Count == player.inventory.containerBelt.capacity)
                {
                    player.inventory.containerMain.capacity = 25;
                }

                GetDefaultSkins();
            }

            private void GetDefaultSkins()
            {
                if (fskinSetsUI)
                    fskinSetsUI = UI.DestroyUI(player, BSkinSetsSelectUI);
                fskinSetsUI = UI.AddUI(player, skinner.AddSetsUI(setSelect));

                if (fsearchUI)
                    fsearchUI = UI.DestroyUI(player, BSkinSearchUI);
                //inventory.SetFlag(ItemContainer.Flag.IsLocked, true);

                if (scpage > (_cachedSkins.Count - 1) / 48)
                    scpage = 0;

                if (scpage < 0)
                    scpage = (_cachedSkins.Count - 1) / 48;


                //Add UI on first fill
                if (inventory.itemList.Count == 0 || rebuildPageUI)
                {
                    if (fpageUI)
                        fpageUI = UI.DestroyUI(player, BSkinPageUI);
                    fpageUI = UI.AddUI(player,
                        skinner.AddPageUI(scpage + 1, (_cachedSkins.Count - 1) / 48 + 1));
                }

                int i = 0;
                _fillingbox = true;
                int maxIndex = Math.Min(48, _cachedSkins.Count - 48 * scpage);

                for (i = 0; i < 48 && i < _cachedSkins.Count - (48) * scpage; i++)
                {
                    if (!setSkins.TryGetValue(_cachedSkinKeys[i + 48 * scpage], out ulong cachedSkin))
                    {
                        cachedSkin = 0ul;
                    }

                    ItemDefinition itemDefinition = ItemManager.FindItemDefinition(_cachedSkinKeys[i + 48 * scpage]);
                    InsertItem(cachedSkin, itemDefinition, 1, i);
                }

                _fillingbox = false;

                //inventory.onItemAddedRemoved -= CheckforSkinSelect;
                inventory.onItemAddedRemoved = CheckforItemSelect;

                inventory.SetFlag(ItemContainer.Flag.IsLocked, false);
                inventory.SetFlag(ItemContainer.Flag.NoItemInput, true);

                inventory.MarkDirty();
            }

            private void CheckforItemSelect(Item item, bool b)
            {
                //if item added
                if (b)
                {
                    if (_fillingbox)
                        return;

                    if (item == returnitem)
                    {
                        returnitem = null;
                        return;
                    }

                    returnitemplayer = item;
                    GiveItem(returnitemplayer);
                    return;
                }

                //item removed
                if (_clearingbox || _fillingbox)
                    return;

                if (item == returnitemplayer)
                {
                    returnitemplayer = null;
                    return;
                }

                itemselected = item.info.isRedirectOf != null ? item.info.isRedirectOf : item.info;
                item.Remove(0f);

                cachedskins = null;
                rebuildsearchUI = true;

                if (!PrepareSkins(itemselected))
                {
                    player.ChatMessage("error in prepare skins");
                    player.EndLooting();
                    //error prepare skins
                    return;
                }

                //Fill container
                FillSkins(itemselected, false);

                inventory.onItemAddedRemoved = CheckforSkinSelect;
                inventory.SetFlag(ItemContainer.Flag.IsLocked, false);
                inventory.SetFlag(ItemContainer.Flag.NoItemInput, true);
                inventory.MarkDirty();
            }

            private void CheckforSkinSelect(Item item, bool b)
            {
                //if item added
                if (b)
                {
                    if (_fillingbox)
                        return;

                    if (item == returnitem)
                    {
                        returnitem = null;
                        return;
                    }

                    returnitemplayer = item;
                    GiveItem(returnitemplayer);
                    return;
                }

                //item removed
                if (_clearingbox || _fillingbox)
                    return;

                if (item == returnitemplayer)
                {
                    returnitemplayer = null;
                    return;
                }

                int itemID = item.info.isRedirectOf != null ? item.info.isRedirectOf.itemid : item.info.itemid;

                setSkins[itemID] = GetMask(item.skin, item.info.itemid, item.info.isRedirectOf != null);

                item.Remove(0f);
                ClearCon();
                itemselected = null;
                GetDefaultSkins();

            }

            #endregion  Set Default Skins

            #region SkinRequests
            public void SkinRequests()
            {
                boxtype = "skinrequests";

                inventory.onItemAddedRemoved = CheckforRequestSelect;

                inventory.SetFlag(ItemContainer.Flag.IsLocked, false);
                inventory.SetFlag(ItemContainer.Flag.NoItemInput, true);

                GetRequestSkins();
            }

            private void GetRequestSkins()
            {
                if (skinner._requestsData.Count == 0)
                {
                    player.EndLooting();
                    return;
                }

                if (inventory.itemList.Count > 0)
                    ClearCon();

                if (fskinRequestsUI)
                    fskinRequestsUI = UI.DestroyUI(player, BSkinRequestsUI);
                fskinRequestsUI = UI.AddUI(player, skinner.AddRequestsUI(requestselected));

                if (page > (skinner._requestsData.Count - 1) / 48)
                    page = 0;

                if (page < 0)
                    page = (skinner._requestsData.Count - 1) / 48;

                //Add UI on first fill
                if (inventory.itemList.Count == 0 || rebuildPageUI)
                {
                    if (fpageUI)
                        fpageUI = UI.DestroyUI(player, BSkinPageUI);

                    if (skinner._requestsData.Count > 48)
                        fpageUI = UI.AddUI(player, skinner.AddPageUI(page + 1, (skinner._requestsData.Count - 1) / 48 + 1));
                }

                int i = 0;
                _fillingbox = true;

                int maxIndex = Math.Min(48, skinner._requestsData.Count - 48 * page);

                for (i = 0; i < 48 && i < skinner._requestsData.Count - (48) * page; i++)
                {
                    RequestItem requestitem = skinner._requestsData[i + 48 * page];
                    ItemDefinition itemDef = ItemManager.FindItemDefinition(requestitem.itemID);
                    InsertItem(requestitem.skinID, itemDef, 1, i);
                }

                _fillingbox = false;

                inventory.MarkDirty();
            }

            private void CheckforRequestSelect(Item item, bool b)
            {
                //if item added
                if (b)
                {
                    if (_fillingbox)
                        return;

                    if (item == returnitem)
                    {
                        returnitem = null;
                        return;
                    }

                    returnitemplayer = item;
                    GiveItem(returnitemplayer);
                    return;
                }

                //item removed
                if (_clearingbox || _fillingbox)
                    return;

                if (item == returnitemplayer)
                {
                    returnitemplayer = null;
                    return;
                }

                itemselected = item.info.isRedirectOf != null ? item.info.isRedirectOf : item.info;
                ulong skinselected = item.skin;

                switch (requestselected)
                {
                    case "Try":
                        if (skinner.HasPerm(player.UserIDString, permskintry))
                        {
                            Item? tryitem = ItemManager.CreateByItemID(itemselected.itemid, 1, skinselected);
                            if (tryitem != null)
                            {
                                tryitem.name = item.name;
                                GiveItem(tryitem, false);
                            }
                        }
                        else
                        {
                            skinner.ChatMessage(player.IPlayer, "NoPerms");
                        }

                        break;
                    case "Approve":
                        skinner.config.ImportedSkinList[skinselected] = new ImportedItem()
                        { itemDisplayname = itemselected.displayName.translated, itemShortname = itemselected.shortname };
                        for (int i = skinner._requestsData.Count - 1; i >= 0; i--)
                        {
                            if (skinner._requestsData[i].skinID == skinselected)
                                skinner._requestsData.RemoveAt(i);
                        }
                        skinner.SaveConfig(); //for skin requests
                        break;
                    case "Deny":
                        for (int i = skinner._requestsData.Count - 1; i >= 0; i--)
                        {
                            if (skinner._requestsData[i].skinID == skinselected)
                                skinner._requestsData.RemoveAt(i);
                        }
                        break;
                }
                item.Remove(0f);
                itemselected = null;

                ClearCon();
                GetRequestSkins();
            }
            #endregion SkinRequests

            #region UI
            public void NextPage()
            {
                rebuildPageUI = true;
                inventory.SetFlag(ItemContainer.Flag.IsLocked, true);

                switch (boxtype)
                {
                    case "itemskins":
                        page += 1;
                        GetSkins();
                        return;
                    case "deployableskins":
                        page += 1;
                        GetDeployableSkins();
                        return;
                    case "skinrequests":
                        page += 1;
                        GetRequestSkins();
                        return;
                    case "craftskins":

                        if (itemselected == null)
                        {
                            scpage += 1;
                            ClearCon();
                            inventory.onItemAddedRemoved = null; // -= CheckforItemSelect;
                            GetDefaultSkins();
                            return;
                        }
                        page += 1;
                        Item dummy = new Item
                        {
                            isServer = true,
                            info = itemselected,
                            amount = 1,
                            uid = new ItemId(Net.sv.TakeUID())
                        };

                        inventory.onItemAddedRemoved = null;//CheckforSkinSelect;
                        CheckforItemSelect(dummy, false);
                        return;
                }
            }

            public void BackPage()
            {
                rebuildPageUI = true;

                inventory.SetFlag(ItemContainer.Flag.IsLocked, true);

                switch (boxtype)
                {
                    case "itemskins":
                        page -= 1;
                        GetSkins();
                        return;
                    case "deployableskins":
                        page -= 1;
                        GetDeployableSkins();
                        return;
                    case "skinrequests":
                        page -= 1;
                        GetRequestSkins();
                        return;
                    case "craftskins":

                        if (itemselected == null)
                        {
                            scpage -= 1;
                            ClearCon();
                            inventory.onItemAddedRemoved = null; // CheckforItemSelect;
                            GetDefaultSkins();
                            return;
                        }
                        page -= 1;
                        Item dummy = new Item
                        {
                            isServer = true,
                            info = itemselected,
                            amount = 1,
                            uid = new ItemId(Net.sv.TakeUID())
                        };

                        inventory.onItemAddedRemoved = null;// CheckforSkinSelect;
                        CheckforItemSelect(dummy, false);
                        return;
                }

            }

            public void SetUpdate()
            {
                if (boxtype != "craftskins") return;
                ClearCon();
                inventory.onItemAddedRemoved = null; //CheckforItemSelect;
                inventory.SetFlag(ItemContainer.Flag.IsLocked, true);
                inventory.SetFlag(ItemContainer.Flag.NoItemInput, true);

                setSkins = skinner.GetCachedSkins(player);
                GetDefaultSkins();
            }
            public void SearchUpdate()
            {
                rebuildsearchUI = true;
                page = 0;

                if (searchtextwas)
                    cachedskins = null;

                switch (boxtype)
                {
                    case "itemskins":
                        GetSkins();
                        return;
                    case "deployableskins":
                        GetDeployableSkins();
                        return;
                    case "craftskins":

                        if (itemselected == null)
                        {
                            ClearCon();
                            inventory.onItemAddedRemoved = null;//CheckforItemSelect;
                            GetDefaultSkins();
                            return;
                        }

                        Item dummy = new Item
                        {
                            isServer = true,
                            info = itemselected,
                            amount = 1,
                            uid = new ItemId(Net.sv.TakeUID())
                        };

                        inventory.onItemAddedRemoved = null; // CheckforSkinSelect;
                        CheckforItemSelect(dummy, false);
                        return;
                }
            }

            #endregion UI

            #region Helpers

            bool IsMainItemBlacklisted(Item mainitem)
            {
                return mainitem != null &&
                       (skinner.config.blacklistedskins.Contains(mainitem.skin) ||
                        skinner.config.blacklisteditems.Contains(mainitem.info.itemid));
            }

            bool IsMainDeployableBlacklisted(BaseCombatEntity maindeployable)
            {
                return maindeployable != null && skinner.config.blacklistedskins.Contains(maindeployable.skinID);
            }
            private Item GiveItem(Item item, bool drop = true)
            {
                List<Item> allitems = Pool.Get<List<Item>>();
                player.inventory.GetAllItems(allitems);

                for (int i = allitems.Count - 1; i >= 0; i--)
                {
                    Item invitem = allitems[i];
                    if (invitem == null) continue;

                    if (invitem.info.itemid != item.info.itemid || invitem.skin != item.skin)
                        continue;

                    //Should work for StackModifier(CanStack) and StackController
                    if (!invitem.CanStack(item))
                        continue;

                    invitem.amount += item.amount;
                    invitem.MarkDirty();

                    item.Remove();
                    Pool.FreeUnmanaged(ref allitems);
                    return invitem;

                }
                Pool.FreeUnmanaged(ref allitems);

                if (item.MoveToContainer(player.inventory.containerMain, -1))
                {
                    return item;
                }
                if (item.MoveToContainer(player.inventory.containerBelt, -1))
                {
                    return item;
                }
                if (drop)
                    item.Drop(player.IsAlive() ? player.eyes.position : ogpos, player.inventory.containerMain.dropVelocity, new Quaternion());
                else
                    item.Remove();

                return item;
            }

            private void Remove(Item item, bool nextTick = false)
            {
                if (item == null)
                {
                    //player.ChatMessage("mainitem null");
                    return;
                }
                if (nextTick)
                {
                    skinner.NextTick(() =>
                    {
                        Remove(item);
                    });
                    return;
                }
                DoRemove(item);
            }

            private void DoRemove(Item item)
            {
                if (item == null)
                {
                    return;
                }
                if (item.uid.Value > 0 && Net.sv != null)
                {
                    Net.sv.ReturnUID(item.uid.Value);
                    item.uid.Value = 0;
                }
                if (item.contents != null)
                {
                    item.contents.Kill();
                    item.contents = null;
                }

                item.RemoveFromWorld();

                if (item.parent != null)
                {
                    for (int i = item.parent.itemList.Count - 1; i >= 0; i--)
                    {
                        Item iteminList = item.parent.itemList[i];

                        if (iteminList.uid.Value != item.uid.Value)
                            continue;

                        item.parent.itemList.RemoveAt(i);
                        break;
                    }
                    item.parent.MarkDirty();
                    item.parent.onItemAddedRemoved(item, false);
                    item.parent = null;
                }

                BaseEntity heldEntity = item.GetHeldEntity();
                if (heldEntity != null)
                {
                    heldEntity.Kill();
                }

                if (item == mainitem)
                    mainitem = null;
            }
            private void ClearCon(bool nexttick = false)
            {
                if (nexttick)
                {
                    skinner.NextTick(() => ClearCon());
                    return;
                }

                if (_clearingbox)
                    return;

                inventory.SetFlag(ItemContainer.Flag.NoItemInput, true);
                inventory.SetFlag(ItemContainer.Flag.IsLocked, true);

                _clearingbox = true;

                for (int i = inventory.itemList.Count - 1; i >= 0; i--)
                {
                    Item item = inventory.itemList[i];

                    if (item == null)
                        continue;

                    if (item.removeTime > 0)
                    {
                        item.Remove();
                        continue;
                    }

                    item.parent = null;
                    item.position = 0;

                    skinner.itemPool.Enqueue(item);
                }

                inventory.itemList.Clear();

                inventory.MarkDirty();

                _clearingbox = false;
                inventory.SetFlag(ItemContainer.Flag.NoItemInput, false);
                inventory.SetFlag(ItemContainer.Flag.IsLocked, false);
            }


            private Item GetItemFromPool(ulong cachedSkin, ItemDefinition itemDef, int pos = -1)
            {
                bool hasmask = HasMask(cachedSkin);
                // Get redirect item
                if (hasmask)
                    itemDef = ItemManager.FindItemDefinition((int)UnsetMask(cachedSkin));

                if (!skinner.itemPool.TryDequeue(out Item item))
                {
                    item = new Item
                    {
                        isServer = true,
                        info = itemDef,
                        amount = 1,
                        skin = hasmask ? 0ul : cachedSkin,
                        text = "1",
                        uid = new ItemId(Net.sv.TakeUID()),
                        position = pos,
                        parent = inventory,
                    };

                    item.condition = (item.maxCondition = itemDef.condition.max);
                    return item;
                }

                item.amount = 1;
                item.info = itemDef;
                item.condition = (item.maxCondition = itemDef.condition.max);
                item.skin = hasmask ? 0ul : cachedSkin;
                item.position = pos;
                item.parent = inventory;
                item.name = string.Empty;

                return item;
            }

            private void InsertItem(ulong cachedSkin, ItemDefinition? itemDef, int amount = 1, int pos = -1)
            {
                Item item = GetItemFromPool(cachedSkin, itemDef, pos);
                //stops stacking

                //item.SetFlag(Item.Flag.IsOn, true);
                item.busyTime = Single.MaxValue;

                inventory.itemList.Add(item);
                if (skinner.config.applySkinNames && _skinNames.TryGetValue(cachedSkin, out string displayName))
                {
                    item.name = displayName;
                    //item.info.displayName.english = cachedSkin.displayName;
                }
            }

            private List<Item>? GetPlayerItems(int itemid = 0)
            {
                List<Item> items = Pool.Get<List<Item>>();
                player.inventory.GetAllItems(items);

                if (backpack?.contents != null && !backpack.contents.itemList.IsNullOrEmpty())
                    items.AddRange(backpack.contents.itemList);

                if (itemid != 0)
                    return items.FindAll(x => x.info.itemid == itemid);
                return items;
            }

            public void OnDestroy()
            {
                _clearingbox = true;

                player.inventory.containerMain.onPreItemRemove -= PosWatch;
                player.inventory.containerWear.onPreItemRemove -= PosWatch;
                player.inventory.containerBelt.onPreItemRemove -= PosWatch;
                if (backpack != null && backpack.contents != null)
                    backpack.contents.onPreItemRemove -= PosWatch;

                if (player.inventory.containerMain.capacity == 25)
                {
                    Item item25 = player.inventory.containerMain.GetSlot(24);

                    if (item25 != null)
                    {
                        if (item25.text != "1")
                        {
                            item25.DropAndTossUpwards(player.eyes.transform.position);
                        }
                        else
                        {
                            DoRemove(item25);
                        }
                    }

                    player.inventory.containerMain.capacity = 24;
                }

                ClearCon();

                inventory.Kill();

                if (fpageUI)
                    UI.DestroyUI(player, BSkinPageUI);
                if (fsearchUI)
                    UI.DestroyUI(player, BSkinSearchUI);
                if (fskinSetsUI)
                    UI.DestroyUI(player, BSkinSetsSelectUI);
                if (fskinRequestsUI)
                    UI.DestroyUI(player, BSkinRequestsUI);

                if (boxtype == "skinrequests")
                    skinner.UpdateImportedSkins();

                player.EndLooting();
                //Destroy(this);
            }
            #endregion Helpers
        }

        #endregion Controller

        #region UI Panel

        #region UI Class

        public string searchUIstring;
        public string pageUIstring;
        public string setsUIstring;
        public string requestsUIstring;

        public class UI
        {
            public static readonly uint AddUIstr = StringPool.Get("AddUI");

            public static bool AddUI(BasePlayer player, byte[] elements)
            {
                NetWrite netWrite = Net.sv.StartWrite();
                netWrite.PacketID(Message.Type.RPCMessage);
                netWrite.EntityID(CommunityEntity.ServerInstance.net.ID);
                netWrite.UInt32(AddUIstr);

                netWrite.BytesWithSize(elements);

                netWrite.Send(new SendInfo(player.net.connection));

                return true;
            }

            public static readonly uint DestroyUIstr = StringPool.Get("DestroyUI");

            public static bool DestroyUI(BasePlayer player, byte[] bytes)
            {
                NetWrite netWrite = Net.sv.StartWrite();
                netWrite.PacketID(Message.Type.RPCMessage);
                netWrite.EntityID(CommunityEntity.ServerInstance.net.ID);
                netWrite.UInt32(DestroyUIstr);

                netWrite.BytesWithSize(bytes);

                netWrite.Send(new SendInfo(player.net.connection));

                return false;
            }

            static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, string oMin, string oMax, bool useCursor = false, string parent = "Overlay")
            {
                var NewElement = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = { Color = color },
                            RectTransform = { AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax},
                            CursorEnabled = useCursor
                        },
                        new CuiElement().Parent = parent,
                        panelName
                    }
                };
                return NewElement;
            }

            static public void CreatePanel(ref CuiElementContainer container, string panel, string color, string sprite, string material, string anchorMin, string anchorMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color, Sprite = sprite, Material = material },
                    RectTransform = { AnchorMin = anchorMin, AnchorMax = anchorMax },
                    CursorEnabled = cursor
                },
                panel);
            }
            static public void CreateLabel(ref CuiElementContainer container, string panel, string text, int size, string anchorMin, string anchorMax, string colour, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { FontSize = size, Align = align, Text = text, Color = colour },
                    RectTransform = { AnchorMin = anchorMin, AnchorMax = anchorMax }
                },
                panel);

            }
            static public void CreateButton(ref CuiElementContainer container, string panel, string bgcolor, string textcolour, string text, int size, string anchorMin, string anchorMax, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = bgcolor, Command = command },
                    RectTransform = { AnchorMin = anchorMin, AnchorMax = anchorMax, OffsetMin = "0 0", OffsetMax = "0 0" },
                    Text = { Text = text, Color = textcolour, FontSize = size, Align = align }
                },
                panel);
            }

            static public void AddInputField(ref CuiElementContainer container, string panel, string bgcolor, string txtcolor, string text, int size, string command, string anchorMin, string anchorMax)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = bgcolor },
                    RectTransform = { AnchorMin = anchorMin, AnchorMax = anchorMax },
                },
                panel);
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                    {
                        new CuiInputFieldComponent
                        {
                            Align = TextAnchor.MiddleLeft,
                            Color = txtcolor,
                            Command = command,
                            FontSize = size,
                            IsPassword = false,
                            Text = text,
                            HudMenuInput = true
                        },
                        new CuiRectTransformComponent {AnchorMin = anchorMin, AnchorMax = anchorMax }
                    }
                });
            }
        }
        #endregion UI Class

        public const string SkinPageUI = "SkinPageUI";
        public const string SkinSearchUI = "SkinSearchUI";
        public const string SkinSetsSelectUI = "SkinSetsSelectUI";
        public const string SkinRequestsUI = "SkinRequestsUI";

        public static byte[] BSkinPageUI = Encoding.UTF8.GetBytes(SkinPageUI);
        public static byte[] BSkinSearchUI = Encoding.UTF8.GetBytes(SkinSearchUI);
        public static byte[] BSkinSetsSelectUI = Encoding.UTF8.GetBytes(SkinSetsSelectUI);
        public static byte[] BSkinRequestsUI = Encoding.UTF8.GetBytes(SkinRequestsUI);

        private void InitUI()
        {
            pageUIstring = EscapeBrackets(InitPageUI());
            searchUIstring = EscapeBrackets(InitSearchUI());
            cachedsearchUIDefault = Encoding.UTF8.GetBytes(string.Format(searchUIstring, " Search Name or ID"));

            setsUIstring = EscapeBrackets(InitSetsUI());
            requestsUIstring = EscapeBrackets(InitRequestsUI());
        }

        private static Dictionary<ValueTuple<int, int>, byte[]> cacheduiPageDictionary = new Dictionary<ValueTuple<int, int>, byte[]>();
        public byte[] AddPageUI(int minpage, int maxpage)
        {
            if (cacheduiPageDictionary.TryGetValue((minpage, maxpage), out byte[] UIbytes))
                return UIbytes;
            UIbytes = Encoding.UTF8.GetBytes(string.Format(pageUIstring, minpage, maxpage));
            cacheduiPageDictionary.Add((minpage, maxpage), UIbytes);
            return UIbytes;
        }

        private byte[] cachedsearchUIDefault;
        public byte[] AddSearchUI(string searchtxt)
        {
            return string.IsNullOrEmpty(searchtxt) ? cachedsearchUIDefault : Encoding.UTF8.GetBytes(string.Format(searchUIstring, searchtxt));
        }

        private static Dictionary<int, byte[]> cacheduiSetsDictionary = new Dictionary<int, byte[]>();

        public byte[] AddSetsUI(int selectedset)
        {
            if (cacheduiSetsDictionary.TryGetValue(selectedset, out byte[] UIbytes))
                return UIbytes;

            string color1 = "0.5 0.5 0.5 0.2";
            string color2 = "0.5 0.5 0.5 0.2";
            string color3 = "0.5 0.5 0.5 0.2";
            string highlighted = "0.345 0.8 0.192 0.78";
            switch (selectedset)
            {
                case 2:
                    color2 = highlighted;
                    break;
                case 3:
                    color3 = highlighted;
                    break;
                default:
                    color1 = highlighted;
                    break;
            }
            UIbytes = Encoding.UTF8.GetBytes(string.Format(setsUIstring, color1, color2, color3));
            cacheduiSetsDictionary.Add(selectedset, UIbytes);
            return UIbytes;
        }

        private static Dictionary<string, byte[]> cacheduiRequestsDictionary = new Dictionary<string, byte[]>();

        public byte[] AddRequestsUI(string requesttype)
        {
            if (cacheduiRequestsDictionary.TryGetValue(requesttype, out byte[] UIbytes))
                return UIbytes;

            string color1 = "0.5 0.5 0.5 0.2";
            string color2 = "0.5 0.5 0.5 0.2";
            string color3 = "0.5 0.5 0.5 0.2";
            string highlighted = "0.345 0.8 0.192 0.78";
            switch (requesttype)
            {
                case "Approve":
                    color2 = highlighted;
                    break;
                case "Deny":
                    color3 = highlighted;
                    break;
                default:
                    color1 = highlighted;
                    break;
            }
            UIbytes = Encoding.UTF8.GetBytes(string.Format(requestsUIstring, color1, color2, color3));
            cacheduiRequestsDictionary.Add(requesttype, UIbytes);
            return UIbytes;
        }

        private string InitPageUI()
        {
            var con = UI.CreateElementContainer(SkinPageUI, "0.5 0.5 0.5 0.3", config.uiposition[0], config.uiposition[1], config.uiposition[2], config.uiposition[3], false);
            UI.CreateLabel(ref con, SkinPageUI, "{0} of {1}", 14, "0.30 0.00", "0.70 1.0", "0.8 0.8 0.8 0.75", TextAnchor.MiddleCenter);
            UI.CreateButton(ref con, SkinPageUI, "0.5 0.5 0.5 0.0", "0.8 0.8 0.8 0.75", "←", 25, "0.00 0.00", "0.30 1.0", "sbBackPage", TextAnchor.MiddleCenter);
            UI.CreateButton(ref con, SkinPageUI, "0.5 0.5 0.5 0.0", "0.8 0.8 0.8 0.75", "→", 25, "0.70 0.00", "1.0 1.0", "sbNextPage", TextAnchor.MiddleCenter);
            return CuiHelper.ToJson(con);
        }

        public string InitSearchUI()
        {
            var con = UI.CreateElementContainer(SkinSearchUI, "0.5 0.5 0.5 0.5", config.uisearchposition[0], config.uisearchposition[1], config.uisearchposition[2], config.uisearchposition[3], false);
            UI.AddInputField(ref con, SkinSearchUI, "0 0 0 0", "#FFFFFF", "{0}", 14, "searchCMD", "0.00 0.00", "1.00 1.00");
            UI.CreateButton(ref con, SkinSearchUI, "0.9 0.1 0.1 1.0", "0.8 0.8 0.8 0.75", "x", 20, "0.85 0.00", "1.0 0.98", "searchCMD", TextAnchor.MiddleCenter);
            return CuiHelper.ToJson(con);
        }

        public static string EscapeBrackets(string input)
        {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < input.Length; i++)
            {
                if (input[i] == '{')
                {
                    if (i + 1 < input.Length && Char.IsDigit(input[i + 1]))
                    {
                        sb.Append(input[i]);
                    }
                    else
                    {
                        sb.Append(input[i]);
                        sb.Append(input[i]);
                    }
                }
                else if (input[i] == '}')
                {
                    if (i + 1 < input.Length && Char.IsDigit(input[i - 1]))
                    {
                        sb.Append(input[i]);
                    }
                    else
                    {
                        sb.Append(input[i]);
                        sb.Append(input[i]);
                    }
                }
                else
                {
                    sb.Append(input[i]);
                }
            }
            return sb.ToString();
        }

        public string InitSetsUI()
        {
            var con = UI.CreateElementContainer(SkinSetsSelectUI, "0.5 0.5 0.5 0.5", config.uisetsposition[0], config.uisetsposition[1], config.uisetsposition[2], config.uisetsposition[3], false);
            UI.CreateButton(ref con, SkinSetsSelectUI, "{0}", "0.8 0.8 0.8 0.75", "Set 1", 17, "0.00 0.00", "0.31 0.98", "setSelectCMD 1", TextAnchor.MiddleCenter);
            UI.CreateButton(ref con, SkinSetsSelectUI, "{1}", "0.8 0.8 0.8 0.75", "Set 2", 17, "0.34 0.00", "0.65 0.98", "setSelectCMD 2", TextAnchor.MiddleCenter);
            UI.CreateButton(ref con, SkinSetsSelectUI, "{2}", "0.8 0.8 0.8 0.75", "Set 3", 17, "0.68 0.00", "1.00 0.98", "setSelectCMD 3", TextAnchor.MiddleCenter);
            return CuiHelper.ToJson(con);
        }

        public string InitRequestsUI()
        {
            var con = UI.CreateElementContainer(SkinRequestsUI, "0.5 0.5 0.5 0.5", config.uisetsposition[0], config.uisetsposition[1], config.uisetsposition[2], config.uisetsposition[3], false);
            UI.CreateButton(ref con, SkinRequestsUI, "{0}", "0.8 0.8 0.8 0.75", "Try", 17, "0.00 0.00", "0.31 0.98", "requestSelectCMD Try", TextAnchor.MiddleCenter);
            UI.CreateButton(ref con, SkinRequestsUI, "{1}", "0.8 0.8 0.8 0.75", "Approve", 17, "0.34 0.00", "0.65 0.98", "requestSelectCMD Approve", TextAnchor.MiddleCenter);
            UI.CreateButton(ref con, SkinRequestsUI, "{2}", "0.8 0.8 0.8 0.75", "Deny", 17, "0.68 0.00", "1.00 0.98", "requestSelectCMD Deny", TextAnchor.MiddleCenter);
            return CuiHelper.ToJson(con);
        }

        #endregion GUI Panel

        #region Helpers
        private Message.Type RPCMessage = Message.Type.RPCMessage;
        private uint refreshSkin = StringPool.Get("RefreshSkin");
        private void SendNetworkUpdate(BaseEntity ent, SendInfo sendInfo = new SendInfo())
        {
            if (Net.sv.IsConnected())
            {
                if (sendInfo.connections?.Count < 1)
                    sendInfo = new SendInfo(ent.net.group.subscribers);
                NetWrite netWrite = Net.sv.StartWrite();
                netWrite.PacketID(Message.Type.EntityDestroy);
                netWrite.EntityID(ent.net.ID);
                netWrite.UInt8(0);
                netWrite.Send(new SendInfo(ent.net.group.subscribers));
            }

            foreach (var child in ent.children)
            {
                SendNetworkUpdate(child, sendInfo);
            }

            List<Connection> subscribers = Pool.Get<List<Connection>>();
            subscribers.AddRange(ent.net.group.subscribers);

            if (subscribers != null && subscribers.Count > 0)
            {
                for (int i = 0; i < subscribers.Count; i++)
                {
                    BasePlayer item = subscribers[i].player as BasePlayer;
                    if (!(item == null) && ent.ShouldNetworkTo(item))
                    {
                        item.QueueUpdate(0, ent);
                        item.SendEntityUpdate();
                    }
                }
            }
            foreach (var child in ent.children)
            {
                SendNetworkUpdate(child);
            }
            ent.gameObject.SendOnSendNetworkUpdate(ent);
        }
        private void DoRemove(Item item)
        {
            if (item.isServer && item.uid.Value > 0 && Net.sv != null)
            {
                Net.sv.ReturnUID(item.uid.Value);
                item.uid.Value = 0;
            }
            if (item.contents != null)
            {
                item.contents.Kill();
                item.contents = null;
            }
            if (item.isServer)
            {
                item.RemoveFromWorld();
                item.RemoveFromContainer();
            }
            BaseEntity heldEntity = item.GetHeldEntity();
            if (heldEntity.IsValid())
            {
                heldEntity.Kill();
            }
        }

        private bool HasPerm(string id, string perm) => permission.UserHasPermission(id, perm);

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }
        private void ChatMessage(IPlayer player, string langKey, params object[] args)
        {
            if (player.IsConnected)
                player.Message(GetLang(langKey, player.Id, args));
            else Puts(GetLang(langKey, player.Id, args));
        }
        #endregion Helpers

        #region SteamWorkshop WebRequests
        private IEnumerator getCollectionscouroutine;
        private List<string> _WorkshopSkinIDCollectionList = new List<string>();
        private IEnumerator GetCollectionSkinIDS()
        {
            string vurl = "https://steamcommunity.com/sharedfiles/filedetails/?id={0}";
            for (int i = 0; i < config.skinCollectionIDs.Count; i++)
            {
                var collectionid = config.skinCollectionIDs[i];
                string downloadHandler;
                UnityWebRequest www = UnityWebRequest.Get(string.Format(vurl, collectionid));
                www.SetRequestHeader("Content-Type", "application/json");
                yield return www.SendWebRequest();

                // Verify that the webrequest was succesful.
                if (www.result != UnityWebRequest.Result.Success)
                {
                    Puts($"waiting 30 seconds for {www.error}");
                    www.Dispose();
                    i--;
                    yield return new WaitForSeconds(30f);
                    continue;
                }
                downloadHandler = www.downloadHandler.text;
                string[] htmlslines = downloadHandler.Split('\n');
                foreach (string htmlline in htmlslines)
                {
                    string trimmed = htmlline.Trim();
                    if (!trimmed.StartsWith("SharedFileBindMouseHover")) continue;
                    string skinid = trimmed.Split('"')[1].Split('_')[1];
                    //Puts(skinid);
                    ulong skinuL;
                    if (ulong.TryParse(skinid, out skinuL))
                    {
                        if (!config.ImportedSkinList.ContainsKey(skinuL) && !_WorkshopSkinIDCollectionList.Contains(skinid))
                            _WorkshopSkinIDCollectionList.Add(skinid);
                    }
                }
                yield return new WaitForSeconds(0.5f);
            }
            getCollectionscouroutine = null;
            if (getSteamWorkshopSkinData != null)
            {
                Puts("getSteamWorkshopSkinData already running!!");
            }
            else
            {
                getSteamWorkshopSkinData = GetSteamWorkshopSkinData();
                ServerMgr.Instance.StartCoroutine(getSteamWorkshopSkinData);
            }
        }

        private IEnumerator getSteamWorkshopSkinData;
        private IEnumerator GetSteamWorkshopSkinData()
        {
            if (_WorkshopSkinIDCollectionList.Count > 500)
                Puts($"Warning over 500 skins are waiting for import, start up may take longer \n Skins to import - {_WorkshopSkinIDCollectionList.Count}");
            string vurl = "https://steamcommunity.com/sharedfiles/filedetails/?id={0}";
            for (int i = 0; i < _WorkshopSkinIDCollectionList.Count; i++)
            {
                var workshopid = _WorkshopSkinIDCollectionList[i];
                string downloadHandler;
                UnityWebRequest www = UnityWebRequest.Get(string.Format(vurl, workshopid));
                www.SetRequestHeader("Content-Type", "application/json");
                yield return www.SendWebRequest();

                // Verify that the webrequest was succesful.
                if (www.result != UnityWebRequest.Result.Success)
                {
                    Puts($"waiting 30 seconds for {www.error}");
                    www.Dispose();
                    i--;
                    yield return new WaitForSeconds(30f);
                    continue;
                }
                downloadHandler = www.downloadHandler.text;
                string[] htmlslines = downloadHandler.Split('\n');

                ValueTuple<string, string>? textreturn = htmllines2shortname(htmlslines, workshopid);

                if (textreturn == null)
                {
                    yield return new WaitForSeconds(0.001f);
                    continue;
                }

                ulong uworkshopid;
                if (ulong.TryParse(workshopid, out uworkshopid))
                {
                    config.ImportedSkinList[uworkshopid] = new ImportedItem()
                    { itemDisplayname = textreturn.Value.Item2, itemShortname = textreturn.Value.Item1 };
                }
                else
                {
                    Puts("Failed to parse workshop ID" + workshopid);
                }
                yield return new WaitForSeconds(0.001f);
            }
            getSteamWorkshopSkinData = null;
            _WorkshopSkinIDCollectionList.Clear();
            GetSkins();
        }

        private ValueTuple<string, string>? htmllines2shortname(string[] htmlslines, string workshopid)
        {
            string skinname = "";
            bool titlef = false;
            foreach (string htmlline in htmlslines)
            {
                string trimmed = htmlline.Trim();
                if (!titlef)
                {
                    if (trimmed.StartsWith("<title>"))
                    {
                        titlef = true;
                        skinname = trimmed.Split(':')[2].Split('<')[0];
                    }
                    continue;
                }

                string[] trimsplits = trimmed.Split('\"');
                if (trimsplits.Length < 6) continue;

                string skintype = string.Empty;
                string[] splitByGreater = trimmed.Split('>');

                if (trimsplits[1] == "workshopTags" || trimsplits[3] == "workshopTags")
                {
                    int startIndex = trimsplits[1] == "workshopTags" ? 6 : 4;
                    for (int index = startIndex; index < splitByGreater.Length; index += 2)
                    {
                        skintype = splitByGreater[index].Split('<')[0];
                        if (skintype != "Skin" && skintype != "Version3" && skintype != "version2")
                            break;
                    }
                }

                if (string.IsNullOrEmpty(skintype)) continue;

                //string shortname = string.Empty;
                if (!WorkshopSkinNameConversion.TryGetValue(skintype, out string shortname))
                {
                    Puts($"Cannot find item definition for id: {workshopid} type:{skintype}");
                    break;
                }

                return (shortname, skinname);
            }

            Puts($"Cannot find item definition for id: {workshopid}");

            return null;
        }

        private IEnumerator getSteamWorkshopRequestData;
        private IEnumerator GetSteamWorkshopSkinRequests()
        {
            string vurl = "https://steamcommunity.com/sharedfiles/filedetails/?id={0}";
            for (int i = 0; i < _requestsData.Count; i++)
            {
                RequestItem request = _requestsData[i];
                if (request.itemID != 0 && !string.IsNullOrEmpty(request.itemDisplayname))
                    continue;

                var workshopid = request.skinID.ToString();

                //Puts(string.Format(vurl, workshopid));
                string downloadHandler;
                UnityWebRequest www = UnityWebRequest.Get(string.Format(vurl, workshopid));
                www.SetRequestHeader("Content-Type", "application/json");
                yield return www.SendWebRequest();

                // Verify that the webrequest was succesful.
                if (www.isNetworkError || www.isHttpError)
                {
                    Puts($"waiting 30 seconds for {www.error}");
                    www.Dispose();
                    i--;
                    yield return CoroutineEx.waitForSeconds(30f);
                    continue;
                }
                downloadHandler = www.downloadHandler.text;
                string[] htmlslines = downloadHandler.Split('\n');

                ValueTuple<string, string>? textreturn = htmllines2shortname(htmlslines, workshopid);
                if (textreturn == null)
                {
                    _requestsData.RemoveAt(i);
                    yield return CoroutineEx.waitForSeconds(0.001f);
                    continue;
                }
                ItemDefinition itemDef = ItemManager.FindItemDefinition(textreturn.Value.Item1);
                if (itemDef == null)
                {
                    Puts($"Cannot find item definition for id: {workshopid}");
                    _requestsData.RemoveAt(i);

                    continue;
                }

                _requestsData[i] = new RequestItem { itemID = itemDef.itemid, skinID = request.skinID, itemDisplayname = textreturn.Value.Item2 };

                yield return CoroutineEx.waitForSeconds(0.001f);
            }

            getSteamWorkshopRequestData = null;
        }

        private struct DiscordData
        {
            public ulong SkinID;
            public BasePlayer player;
        }

        private List<DiscordData> _discordData = new List<DiscordData>();
        private IEnumerator notifyDiscordCoroutine;

        private IEnumerator NotifyDiscord()
        {
            int max = _discordData.Count;
            for (int i = _discordData.Count - 1; i >= 0; i--)
            {
                DiscordData discordData = _discordData[i];

                if (discordData.SkinID < 10000)
                    continue;

                string url = $"https://steamcommunity.com/sharedfiles/filedetails/?id={discordData.SkinID}";

                UnityWebRequest head = UnityWebRequest.Get(url);

                head.timeout = 5;

                yield return head.SendWebRequest();

                if (head.result != UnityWebRequest.Result.Success)
                {
                    PrintError(head.error + "Cannot get headers from:" + url);
                    head.Dispose();
                    continue;
                }
                string title = string.Empty;
                string image = string.Empty;

                foreach (var line in head.downloadHandler.text.Split('\n'))
                {
                    var trim = line.Trim();
                    if (trim.StartsWith("<meta property=\"twitter:title\""))
                    {
                        title = trim.Split(':')[3].Split('"')[0];
                    }
                    if (trim.StartsWith("<meta name=\"twitter:image\""))
                    {
                        image = trim.Split('"')[3];
                        break;
                    }
                }

                if (string.IsNullOrEmpty(title) || title == "Error")
                {
                    head.Dispose();
                    Puts($"Could not get content for skin {discordData.SkinID}");
                    for (i = _requestsData.Count - 1; i > 0; i--)
                    {
                        if (_requestsData[i].skinID == discordData.SkinID)
                        {
                            _requestsData.RemoveAt(i);
                            break;
                        }
                    }
                    continue;
                }

                Root root = new Root
                {
                    tts = false,
                    content = string.Empty,
                    username = "Skinner",
                    avatar_url = "https://codefling.com/uploads/monthly_2024_07/Skinner_Thumbnail2-0.png.97a301b396dbeae7f180d1f8002e02d3.png",
                    embeds = new List<Embed>
                    {
                        new Embed
                        {
                            fields = new List<Field>
                            {
                                new Field
                                {
                                    name = "Requested By",
                                    value = $"{discordData.player.displayName} - [{discordData.player.UserIDString}](https://steamcommunity.com/id/{discordData.player.UserIDString})"
                                },
                                new Field
                                {
                                    name = "Skin",
                                    value = $"{title} - [{discordData.SkinID}](https://steamcommunity.com/sharedfiles/filedetails/?id={discordData.SkinID})"
                                }
                            },
                            author = new Author
                            {
                                name = "Skinner",
                                icon_url = "https://codefling.com/uploads/monthly_2024_07/Skinner_Thumbnail2-0.png.97a301b396dbeae7f180d1f8002e02d3.png"
                            },
                            title = $"{server.Name} - New Skin Request",
                            image = new Image { url = image },
                            timestamp = DateTime.Now,
                        }
                    }
                };

                UnityWebRequest sendtoDiscord = UnityWebRequest.Post(config.DiscordWebhook, JsonConvert.SerializeObject(root).ToString(), "application/json");

                yield return sendtoDiscord.SendWebRequest();

                if (sendtoDiscord.result != UnityWebRequest.Result.Success)
                {
                    PrintError(sendtoDiscord.error + "Cannot send to discord:");
                    sendtoDiscord.Dispose();
                    continue;
                }
                head.Dispose();
                sendtoDiscord.Dispose();
            }
            _discordData.RemoveRange(0, max);
            notifyDiscordCoroutine = null;
        }


        #region Discord
        public class Root
        {
            public string content { get; set; }
            public bool tts { get; set; }
            public List<Embed> embeds { get; set; }

            public string avatar_url { get; set; }

            public string username { get; set; }

        }

        public class Embed
        {
            public int id { get; set; }
            public List<Field> fields { get; set; }
            public Author author { get; set; }
            public string title { get; set; }
            public Image image { get; set; }
            public DateTime timestamp { get; set; }
        }

        public class Field
        {
            public int id { get; set; }
            public string name { get; set; }
            public string value { get; set; }
        }

        public class Author
        {
            public string name { get; set; }
            public string icon_url { get; set; }
        }

        public class Image
        {
            public string url { get; set; }
        }

        #endregion Discord

        private Dictionary<string, string> WorkshopSkinNameConversion = new Dictionary<string, string>
        {
            {"Acoustic Guitar","fun.guitar"},
            {"AK47","rifle.ak"},
            {"AK47 Skin","rifle.ak"},
            {"Armored Double Door", "door.double.hinged.toptier"},
            {"Armored Door","door.hinged.toptier"},
            {"Large Backpack","largebackpack"},
            {"Balaclava","mask.balaclava"},
            {"Balaclava Skin","mask.balaclava"},
            {"Bandana","mask.bandana"},
            {"Bearskin Rug", "rug.bear"},
            {"Beenie Hat","hat.beenie"},
            {"Beenie Skin","hat.beenie"},
            {"Bolt Rifle","rifle.bolt"},
            {"BoltRifle Skin","rifle.bolt"},
            {"Bone Club","bone.club"},
            {"Bone Knife","knife.bone"},
            {"Boonie Skin","hat.boonie"},
            {"Boonie Hat","hat.boonie"},
            {"Bucket Helmet","bucket.helmet"},
            {"Burlap Headwrap","burlap.headwrap"},
            {"Burlap Pants","burlap.trousers"},
            {"Burlap Shirt","burlap.shirt"},
            {"Burlap Shoes","burlap.shoes"},
            {"Cap","hat.cap"},
            {"Chair", "chair"},
            {"Coffee Can Helmet","coffeecan.helmet"},
            {"Collared Shirt","shirt.collared"},
            {"Combat Knife","knife.combat"},
            {"Concrete Barricade","barricade.concrete"},
            {"Crossbow","crossbow"},
            {"Custom SMG","smg.2"},
            {"Deer Skull Mask","deer.skull.mask"},
            {"Double Barrel Shotgun","shotgun.double"},
            {"Eoka Pistol","pistol.eoka"},
            {"F1 Grenade","grenade.f1"},
            {"Furnace","furnace"},
            {"Fridge", "fridge"},
            {"Garage Door", "wall.frame.garagedoor"},
            {"Hammer","hammer"},
            {"Hatchet","hatchet"},
            {"Hide Halterneck","attire.hide.helterneck"},
            {"Hide Pants","attire.hide.pants"},
            {"Hide Poncho","attire.hide.poncho"},
            {"Hide Shirt","attire.hide.vest"},
            {"Hide Shoes","attire.hide.boots"},
            {"Hide Skirt","attire.hide.skirt"},
            {"Hoodie","hoodie"},
            {"Hunting Bow","bow.hunting"},
            {"Jacket Skin", "jacket"},
            {"Jackhammer", "jackhammer"},
            {"Large Wood Box","box.wooden.large"},
            {"Leather Gloves","burlap.gloves"},
            {"Long TShirt","tshirt.long"},
            {"Longsword","longsword"},
            {"LR300","rifle.lr300"},
            {"Locker","locker"},
            {"L96", "rifle.l96"},
            {"Metal Chest Plate","metal.plate.torso"},
            {"Metal Facemask","metal.facemask"},
            {"Miner Hat","hat.miner"},
            {"Mp5","smg.mp5"},
            {"M39", "rifle.m39"},
            {"M249", "lmg.m249"},
            {"Pants","pants"},
            {"Pants Skin","pants"},
            {"Pick Axe","pickaxe"},
            {"Pump Shotgun","shotgun.pump"},
            {"Python","pistol.python"},
            {"Reactive Target","target.reactive"},
            {"Revolver","pistol.revolver"},
            {"Riot Helmet","riot.helmet"},
            {"Roadsign Gloves", "roadsign.gloves"},
            {"Roadsign Pants","roadsign.kilt"},
            {"Roadsign Vest","roadsign.jacket"},
            {"Rock","rock"},
            {"Rock Skin","rock"},
            {"Rocket Launcher","rocket.launcher"},
            {"Rug", "rug"},
            {"Rug Bear Skin","rug.bear"},
            {"Salvaged Hammer","hammer.salvaged"},
            {"Salvaged Icepick","icepick.salvaged"},
            {"Sandbag Barricade","barricade.sandbags"},
            {"Satchel Charge","explosive.satchel"},
            {"Semi-Automatic Pistol","pistol.semiauto"},
            {"SemiAutoPistol Skin","pistol.semiauto"},
            {"Semi-Automatic Rifle","rifle.semiauto"},
            {"Sheet Metal Door","door.hinged.metal"},
            {"Sheet Metal Double Door","door.double.hinged.metal"},
            {"Shorts","pants.shorts"},
            {"Sleeping Bag","sleepingbag"},
            {"Snow Jacket","jacket.snow"},
            {"SnowJacket Skin","jacket.snow"},
            {"Spinning Wheel", "spinner.wheel"},
            {"Stone Hatchet","stonehatchet"},
            {"Stone Pick Axe","stone.pickaxe"},
            {"Sword","salvaged.sword"},
            {"Table", "table"},
            {"Tank Top","shirt.tanktop"},
            {"Thompson","smg.thompson"},
            {"TShirt","tshirt"},
            {"TShirt Skin","tshirt"},
            {"Vagabond Jacket","jacket"},
            {"Vending Machine","vending.machine"},
            {"Water Purifier","water.purifier"},
            {"Waterpipe Shotgun","shotgun.waterpipe"},
            {"Wood Storage Box","box.wooden"},
            {"WoodStorage Skin","box.wooden"},
            {"Wooden Door","door.hinged.wood"},
            {"Wooden Double Door", "door.double.hinged.wood" },
            {"Work Boots","shoes.boots"},
            {"Boots Skin","shoes.boots"}
        };

        #endregion SteamWorkshop WebRequests

        #region Public Helpers
        public Dictionary<int, List<ulong>> GetAllCachedSkins()
        {
            return _cachedSkins;
        }

        public bool IsRedirectID(ulong uID)
        {
            return HasMask(uID);
        }

        public int RedirectIDtoItemID(ulong uID)
        {
            return (int)UnsetMask(uID);
        }

        public List<ulong>? GetSkinsItemList(int itemid)
        {
            _cachedSkins.TryGetValue(itemid, out List<ulong>? cachedSkins);
            return cachedSkins;
        }

        #endregion Public Helpers
    }
}

// --- End of file: Skinner-2.1.5.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Airstrike.cs ---
// --- Original Local Path: Airstrike.cs ---

using System;
using System.Collections.Generic;
using UnityEngine;
using Rust;
using System.Reflection;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Airstrike", "k1lly0u", "0.2.32", ResourceId = 1489)]
    class Airstrike : RustPlugin
    {

        #region fields

        [PluginReference]
        Plugin Economics;

        private bool changed;
        private float rocketDrop = 0f;

        static FieldInfo TimeToTake;
        static FieldInfo StartPos;
        static FieldInfo EndPos;
        static FieldInfo DropPos;
        
        public Dictionary<ulong, bool> toggleList = new Dictionary<ulong, bool>();

        private List<StrikePlane> StrikePlanes = new List<StrikePlane>();

        PlayerCooldown pcdData;
        private DynamicConfigFile PCDDATA;
        #endregion

        #region Classes
        public class StrikePlane : MonoBehaviour
        {
            public CargoPlane Plane;
            public Vector3 TargetPosition;
            public int FiredRockets = 0;

            public void SpawnPlane(CargoPlane plane, Vector3 position, float speed, bool isSquad = false, Vector3 offset = new Vector3())
            {
                enabled = true;                
                Plane = plane;                
                TargetPosition = position;
                Plane.InitDropPosition(position);
                Plane.Spawn();
                if (isSquad)
                {
                    Vector3 SpawnPos = CalculateSpawnPos(offset);
                    StartPos.SetValue(Plane, SpawnPos);
                    EndPos.SetValue(Plane, SpawnPos - new Vector3(0, 0, TerrainMeta.Size.x));
                    Plane.transform.position = SpawnPos;
                    Plane.transform.rotation = new Quaternion(0, 180, 0, 0);
                }
                TimeToTake.SetValue(Plane, Vector3.Distance((Vector3)StartPos.GetValue(Plane), (Vector3)EndPos.GetValue(Plane)) / speed);
                InvokeRepeating("CheckDistance", 3, 3);
            }
            private Vector3 CalculateSpawnPos(Vector3 offset)
            {
                float mapSize = (TerrainMeta.Size.x / 2) + 150f;
                Vector3 spawnPos = new Vector3();
                spawnPos.x = TargetPosition.x + offset.x;
                spawnPos.z = mapSize + offset.z;
                spawnPos.y = 150;
                return spawnPos;
            }
            private void CheckDistance()
            {               
                var currentPos = Plane.transform.position;
                if (Vector3.Distance(currentPos, TargetPosition) < (currentPos.y + planeDistance))
                {
                    FireRockets(Plane, TargetPosition);
                    CancelInvoke("CheckDistance");                    
                }                
            }
            private void FireRockets(CargoPlane strikePlane, Vector3 targetPos)
            {
                InvokeRepeating("SpreadRockets", rocketInterval, rocketInterval);
            }
            private void SpreadRockets()
            {
                if (FiredRockets >= rocketAmount)
                {
                    CancelInvoke("SpreadRockets");
                    return;
                }
                Vector3 targetPos = Quaternion.Euler(UnityEngine.Random.Range((float)(-rocketSpread * 0.2), rocketSpread * 0.2f), UnityEngine.Random.Range((float)(-rocketSpread * 0.2), rocketSpread * 0.2f), UnityEngine.Random.Range((float)(-rocketSpread * 0.2), rocketSpread * 0.2f)) * TargetPosition;
                LaunchRocket(targetPos);
                FiredRockets++;
            }
            private void LaunchRocket(Vector3 targetPos)
            {
                var rocket = rocketType;
                if (useMixedRockets)                
                    if (UnityEngine.Random.Range(1, fireChance) == 1)
                        rocket = fireRocket;                
                var launchPos = Plane.transform.position;

                ItemDefinition projectileItem = ItemManager.FindItemDefinition(rocket);
                ItemModProjectile component = projectileItem.GetComponent<ItemModProjectile>();

                BaseEntity entity = GameManager.server.CreateEntity(component.projectileObject.resourcePath, launchPos, new Quaternion(), true);

                TimedExplosive rocketExplosion = entity.GetComponent<TimedExplosive>();
                ServerProjectile rocketProjectile = entity.GetComponent<ServerProjectile>();

                rocketProjectile.speed = rocketSpeed;
                rocketProjectile.gravityModifier = 0;
                rocketExplosion.timerAmountMin = 60;
                rocketExplosion.timerAmountMax = 60;
                for (int i = 0; i < rocketExplosion.damageTypes.Count; i++)
                    rocketExplosion.damageTypes[i].amount *= damageModifier;

                Vector3 newDirection = (targetPos - launchPos);                

                entity.SendMessage("InitializeVelocity", (newDirection));
                entity.Spawn();                
            }           
        }
        private CargoPlane CreatePlane() => (CargoPlane)GameManager.server.CreateEntity(cargoPlanePrefab, new Vector3(), new Quaternion(), true);
        #endregion

        #region Oxide Hooks        
        void Loaded() => PCDDATA = Interface.Oxide.DataFileSystem.GetFile("airstrike_data");
        void OnServerInitialized()
        {
            broadcastStrikeAll = true;
            //strikeCalled = false;
            
            RegisterPermissions();
            RegisterMessages();
            SetFieldInfo();
            CheckDependencies();
            LoadVariables();
            LoadData();
        }
        void Unload()
        {
            SaveData();
            DestroyAllPlanes();      
        }
        
        void OnExplosiveThrown(BasePlayer player, BaseEntity entity)
        {
            if (useSignalStrike && canSmokeStrike(player))
                if (toggleList.ContainsKey(player.userID) && toggleList[player.userID])
                    if (entity is SupplySignal)
                    {
                        entity.GetComponent<TimedExplosive>().timerAmountMin = 30f;                        
                        if (useCooldown)                        
                            if (!CheckPlayerData(player))
                                return;
                        var pos = entity.GetEstimatedWorldPosition();
                        timer.Once(2.8f, () => 
                        {                            
                            Effect.server.Run("assets/bundled/prefabs/fx/smoke_signal.prefab", pos);
                            strikeOnSmoke(player, pos);
                            if (entity != null)                                                            
                                entity.Kill(BaseNetworkable.DestroyMode.None);                            
                        });
                    }
        }
        void OnEntitySpawned(BaseEntity entity)
        {
            if (entity != null)
            {
                if (entity is SupplyDrop)
                    CheckStrikeDrop(entity as SupplyDrop);                          
            }
        }
        #endregion

        #region Plugin Init
        private void RegisterPermissions()
        {
            permission.RegisterPermission("airstrike.admin", this);
            permission.RegisterPermission("airstrike.canuse", this);
            permission.RegisterPermission("airstrike.buystrike", this);
            permission.RegisterPermission("airstrike.mass", this);
        }
        private void RegisterMessages() => lang.RegisterMessages(messages, this);
        private void SetFieldInfo()
        {
            StartPos = typeof(CargoPlane).GetField("startPos", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            EndPos = typeof(CargoPlane).GetField("endPos", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            TimeToTake = typeof(CargoPlane).GetField("secondsToTake", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            DropPos = typeof(CargoPlane).GetField("dropPosition", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
        }
        private void CheckDependencies()
        {
            if (Economics == null)
                if (useEconomics)
                {
                    PrintWarning($"Economics could not be found! Disabling money feature");
                    useEconomics = false;
                }
        }
        #endregion

        #region Core Functions       
        public const string cargoPlanePrefab = "assets/prefabs/npc/cargo plane/cargo_plane.prefab";    
        
        private void DestroyPlane(StrikePlane plane)
        {
            if (StrikePlanes.Contains(plane))
            {
                if (plane.Plane != null)                
                    plane.Plane.Kill();                
                StrikePlanes.Remove(plane);
                UnityEngine.Object.Destroy(plane);
            }    
        }

        private void DestroyAllPlanes()
        {
            foreach (var plane in StrikePlanes)
                DestroyPlane(plane);
        }

        public bool CheckStrikeDrop(SupplyDrop drop)
        {
            bool istrue = false;
            var supplyDrop = drop.GetComponent<LootContainer>();
            foreach (var plane in StrikePlanes)
            {
                if (plane.Plane == null) return false;
                float dropDistance = ((Vector3.Distance(plane.Plane.transform.position, supplyDrop.transform.position)));
                if (dropDistance < 100) supplyDrop.KillMessage();
                istrue = true;
            }
            return istrue;
        }
        private void MassSet(Vector3 position, Vector3 offset, int speed = -1)
        {
            if (speed == -1) speed = planeSpeed;
            CargoPlane plane = CreatePlane();            

            var strikePlane = plane.gameObject.AddComponent<StrikePlane>();
            StrikePlanes.Add(strikePlane);
            strikePlane.SpawnPlane(plane, position, speed, true, offset);
            
            float removePlane = ((Vector3.Distance((Vector3)StartPos.GetValue(plane), (Vector3)DropPos.GetValue(plane)) / speed) + 10);
            timer.Once(removePlane, () => DestroyPlane(strikePlane));
        }
        
        private Vector3 calculateEndPos(Vector3 pos, Vector3 offset)
        {
            float mapSize = (TerrainMeta.Size.x / 2);
            Vector3 endPos = new Vector3();
            endPos.x = pos.x + offset.x;
            endPos.z = -mapSize;
            endPos.y = 150;
            return endPos;
        }
        private void strikeOnPayment(BasePlayer player, string type)
        {
            int playerHQ = player.inventory.GetAmount(374890416);
            int playerFlare = player.inventory.GetAmount(97513422);
            int playerTC = player.inventory.GetAmount(1490499512);
            switch (type)
            {
                case "computer":
                    if (playerFlare >= buyFlare && playerTC >= buyTarget)
                    {
                        player.inventory.Take(null, 97513422, buyFlare);
                        player.inventory.Take(null, 1490499512, buyTarget);
                        callPaymentStrike(player);                        
                    }
                    return;
                case "metal":
                    if (playerHQ >= buyMetal)
                    {
                        player.inventory.Take(null, 374890416, buyMetal);
                        callPaymentStrike(player);
                    }
                    return;
                case "money":
                    callPaymentStrike(player);
                    return;
                default:
                    Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.denied.prefab", player.transform.position);
                    SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("buyCost", this, player.UserIDString));
                    SendReply(player, string.Format(lang.GetMessage("buyFlare", this, player.UserIDString), buyTarget.ToString(), buyFlare.ToString()));
                    SendReply(player, string.Format(lang.GetMessage("buyMetal", this, player.UserIDString), buyMetal.ToString()));
                    return;
            }
        }
        private void squadStrikeOnPayment(BasePlayer player, bool type)
        {
            int playerHQ = player.inventory.GetAmount(374890416);
            int playerFlare = player.inventory.GetAmount(97513422);
            int playerTC = player.inventory.GetAmount(1490499512);

            if (!type)
                if (playerFlare >= buyFlare && playerTC >= buyTarget)
                {
                    player.inventory.Take(null, 97513422, buyFlare * 3);
                    player.inventory.Take(null, 1490499512, buyTarget * 3);
                    callPaymentSquadStrike(player);
                    return;
                }
                else if (playerHQ >= buyMetal)
                {
                    player.inventory.Take(null, 374890416, buyMetal * 3);
                    callPaymentSquadStrike(player);
                    return;
                }            
            Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.denied.prefab", player.transform.position);
            SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("squadCost", this, player.UserIDString));
            SendReply(player, string.Format(lang.GetMessage("buyFlare", this, player.UserIDString), (buyTarget * 3).ToString(), (buyFlare * 3).ToString()));
            SendReply(player, string.Format(lang.GetMessage("buyMetal", this, player.UserIDString), (buyMetal * 3).ToString()));
        }
        private bool CheckPlayerMoney(BasePlayer player, int amount)
        {
            if (useEconomics)
            {
                double money = (double)Economics?.CallHook("GetPlayerMoney", player.userID);
                if (money >= amount)
                {
                    money = money - amount;
                    Economics?.CallHook("Set", player.userID, money);
                    return true;
                }
                return false;
            }
            return false;
        }

        private bool CheckPlayerData(BasePlayer player)
        {
            if (noAdminCooldown)
                if (player.net.connection.authLevel >= auth) return true;
            
            var d = pcdData.pCooldown;
            ulong ID = player.userID;
            double timeStamp = GrabCurrentTime();
            
            if (!d.ContainsKey(ID))
            {
                d.Add(ID, new PCDInfo((long)timeStamp + cooldownTime));
                SaveData();
                return true;
            }
            else
            {
                long time = d[ID].Cooldown;
                if (time > timeStamp && time != 0.0)
                {
                    SendReply(player, string.Format(lang.GetMessage("title", this) + lang.GetMessage("cdTime", this, player.UserIDString), (int)(time - timeStamp) / 60));
                    return false;
                }
                else
                {
                    d[ID].Cooldown = (long)timeStamp + cooldownTime;
                    SaveData();
                    return true;
                }
            }
        }
        static double GrabCurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;
        #endregion

        #region Callstrike Functions        
        private void strikeOnPlayer(BasePlayer player)
        {
            callStrike(player.transform.position);
            SendReply(player, string.Format(lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("strikeConfirmed", this, player.UserIDString), player.transform.position.ToString()));
            Puts(player.displayName.ToString() + lang.GetMessage("calledStrike", this, player.UserIDString) + player.transform.position.ToString());
        }
        private void squadStrikeOnPlayer(BasePlayer player)
        {
            massStrike(player.transform.position);
            SendReply(player, string.Format(lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("strikeConfirmed", this, player.UserIDString), player.transform.position.ToString()));
            Puts(player.displayName.ToString() + lang.GetMessage("calledMassStrike", this, player.UserIDString) + player.transform.position.ToString());
        }
        private void strikeOnSmoke(BasePlayer player, Vector3 strikePos)
        {
            if (changeSupplyStrike)
                massStrike(strikePos);
            else callStrike(strikePos);
            SendReply(player, string.Format(lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("strikeConfirmed", this, player.UserIDString), strikePos.ToString()));
            Puts(player.displayName.ToString() + lang.GetMessage("calledStrike", this, player.UserIDString) + strikePos.ToString());
        }
        private void callStrike(Vector3 position, int speed = -1)
        {
            if (speed == -1) speed = planeSpeed;
            if (broadcastStrikeAll)
                PrintToChat(lang.GetMessage("strikeInbound", this));

            Puts(string.Format(lang.GetMessage("calledTo", this), position.ToString()));

            CargoPlane plane = CreatePlane();            
            var strikePlane = plane.gameObject.AddComponent<StrikePlane>();
            if (strikePlane == null) Puts("null plane");
            StrikePlanes.Add(strikePlane);
            strikePlane.SpawnPlane(plane, position, speed);

            float removePlane = ((Vector3.Distance((Vector3)StartPos.GetValue(plane), (Vector3)DropPos.GetValue(plane)) / speed) + 10);
            timer.Once(removePlane, () => DestroyPlane(strikePlane));
        }
        private void massStrike(Vector3 position)
        {
            if (broadcastStrikeAll)
                PrintToChat(lang.GetMessage("strikeInbound", this));

            Puts(lang.GetMessage("calledTo", this), position.ToString());                        
                        
            MassSet(position, new Vector3(0, 0, 0));
            MassSet(position, new Vector3(-70, 0, 80));
            MassSet(position, new Vector3(70, 0, 80));            
        }       
        private void callPaymentStrike(BasePlayer player)
        {
            var pos = player.transform.position;
            Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.updated.prefab", pos);
            callStrike(pos);
            SendReply(player, string.Format(lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("strikeConfirmed", this, player.UserIDString), pos.ToString()));
            Puts(player.displayName.ToString() + lang.GetMessage("calledStrike", this, player.UserIDString) + pos.ToString());
            return;
        }
        private void callPaymentSquadStrike(BasePlayer player)
        {
            var pos = player.transform.position;
            Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.updated.prefab", pos);
            massStrike(pos);
            SendReply(player, string.Format(lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("squadConfirmed", this, player.UserIDString), pos.ToString()));
            Puts(player.displayName.ToString() + lang.GetMessage("calledMassStrike", this, player.UserIDString) + pos.ToString());
            return;
        }
        private void callRandomStrike(bool single)
        {
            float mapSize = (TerrainMeta.Size.x / 2) - 600f;

            float randomX = UnityEngine.Random.Range(-mapSize, mapSize);
            float randomY = UnityEngine.Random.Range(-mapSize, mapSize);

            Vector3 pos = new Vector3(randomX, 0f, randomY);

            if (single)callStrike(pos);
            if (!single) massStrike(pos);            
        }  
       
        List<BasePlayer> FindPlayer(string arg)
        {
            var foundPlayers = new List<BasePlayer>();

            ulong steamid;
            ulong.TryParse(arg, out steamid);
            string lowerarg = arg.ToLower();

            foreach (var player in BasePlayer.activePlayerList)
            {
                if (steamid != 0L)
                    if (player.userID == steamid)
                    {
                        foundPlayers.Clear();
                        foundPlayers.Add(player);
                        return foundPlayers;
                    }
                string lowername = player.displayName.ToLower();
                if (lowername.Contains(lowerarg))
                {
                    foundPlayers.Add(player);
                }
            }
            return foundPlayers;
        }        
        private bool isStrikePlane(CargoPlane plane)
        {
            if (plane.GetComponent<StrikePlane>() != null && StrikePlanes.Contains(plane.GetComponent<StrikePlane>())) return true;
            return false;
        }

        #endregion

        #region Chat/Console Commands and Perms       
        bool canChatStrike(BasePlayer player)
        {
            if (permission.UserHasPermission(player.userID.ToString(), "airstrike.admin")) return true;
            else if (player.net.connection.authLevel >= auth) return true;
            return false;
        }
        bool canSquadStrike(BasePlayer player)
        {
            if (permission.UserHasPermission(player.userID.ToString(), "airstrike.mass")) return true;
            else if (player.net.connection.authLevel >= auth) return true;
            return false;
        }
        bool canSmokeStrike(BasePlayer player)
        {
            if (permission.UserHasPermission(player.userID.ToString(), "airstrike.canuse")) return true;
            else if (player.net.connection.authLevel >= auth) return true;
            return false;
        }
        bool canBuyStrike(BasePlayer player)
        {
            if (permission.UserHasPermission(player.userID.ToString(), "airstrike.buystrike")) return true;
            else if (player.net.connection.authLevel >= auth) return true;
            return false;
        }
        bool isAuth(ConsoleSystem.Arg arg)
        {
            if (arg.connection != null)
            {
                if (arg.connection.authLevel < auth)
                {
                    SendReply(arg, lang.GetMessage("noPerms", this));
                    return false;
                }
            }
            return true;
        }

        [ChatCommand("callstrike")]
        private void chatStrike(BasePlayer player, string command, string[] args)
        {
            if (!canChatStrike(player)) return;

            if (useCooldown)
                if (!CheckPlayerData(player)) return;

            if (args.Length == 0)
            {
                strikeOnPlayer(player);                
                return;
            }           
            if (args.Length > 1)
            {
                SendReply(player, lang.GetMessage("badSyntax", this, player.UserIDString));
                SendReply(player, lang.GetMessage("callStrike", this, player.UserIDString));
                SendReply(player, lang.GetMessage("callStrikeName", this, player.UserIDString));
                return;
            }
            var fplayer = FindPlayer(args[0]);
            if (fplayer.Count == 0)
            {
                SendReply(player, lang.GetMessage("noPlayers", this, player.UserIDString));
                return;
            }
            if (fplayer.Count > 1)
            {
                SendReply(player, lang.GetMessage("multiplePlayers", this, player.UserIDString));
                return;
            }
            strikeOnPlayer(fplayer[0]);
            
        }
        [ChatCommand("squadstrike")]
        private void chatsquadStrike(BasePlayer player, string command, string[] args)
        {
            if (!canChatStrike(player)) return;
            if (args.Length == 0)
            {
                squadStrikeOnPlayer(player);
                return;
            }
            if (args.Length > 1)
            {
                SendReply(player, lang.GetMessage("badSyntax", this, player.UserIDString));
                SendReply(player, lang.GetMessage("callStrike", this, player.UserIDString));
                SendReply(player, lang.GetMessage("callStrikeName", this, player.UserIDString));
                return;
            }
            var fplayer = FindPlayer(args[0]);
            if (fplayer.Count == 0)
            {
                SendReply(player, lang.GetMessage("noPlayers", this, player.UserIDString));
                return;
            }
            if (fplayer.Count > 1)
            {
                SendReply(player, lang.GetMessage("multiplePlayers", this, player.UserIDString));
                return;
            }
            squadStrikeOnPlayer(fplayer[0]);
            
        }
        [ChatCommand("buystrike")]
        private void chatBuyStrike(BasePlayer player, string command, string[] args)
        {
            if (usePaymentStrike == true)
            {
                if (!canBuyStrike(player)) return;

                if (useCooldown)
                    if (!CheckPlayerData(player)) return;

                if (args.Length == 0)
                {
                    SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("selectPayment", this, player.UserIDString));
                    SendReply(player, lang.GetMessage("selectOptions", this, player.UserIDString));
                    if (Economics && useEconomics)
                    {
                        SendReply(player, lang.GetMessage("selectMoney", this, player.UserIDString));
                    }
                    return;
                }               

                if (args.Length == 1)
                {                   
                    if (args[0].ToLower() == "money")
                    {
                        if (CheckPlayerMoney(player, buyMoney))
                        {
                            strikeOnPayment(player, "money");
                                return;
                        }
                        SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("noMoney", this, player.UserIDString));
                        return;                        
                    }
                    if (args[0].ToLower() == "squad")
                    {
                        SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("squadSyntax", this, player.UserIDString));
                        return;
                    }
                    var paymentType = args[0].ToUpper();
                    if (paymentType != "METAL" && paymentType != "COMPUTER")
                    {
                        SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("validType", this, player.UserIDString));
                        return;
                    }
                    if (paymentType == "METAL")
                    {
                        strikeOnPayment(player, "metal");
                        return;
                    }
                    else if (paymentType == "COMPUTER")
                    {
                        strikeOnPayment(player, "computer");
                        return;
                    }
                }
                else if (args.Length == 2)
                {
                    if (args[0].ToLower() != "squad")
                    {
                        SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("squadSyntax", this, player.UserIDString));
                        return;
                    }
                    if (usePaymentSquad)
                    {
                        var paymentType = args[1].ToUpper();
                        if (paymentType != "METAL" && paymentType != "COMPUTER")
                        {
                            SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("validType", this, player.UserIDString));
                            return;
                        }
                        if (paymentType == "METAL")
                        {
                            squadStrikeOnPayment(player, true);
                            return;
                        }
                        else if (paymentType == "COMPUTER")
                        {
                            squadStrikeOnPayment(player, false);
                            return;
                        }
                    }
                }
                else
                {
                    SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("badSyntax", this, player.UserIDString));
                    SendReply(player, lang.GetMessage("selectOptions", this, player.UserIDString));
                    if (Economics && useEconomics)
                    {
                        SendReply(player, lang.GetMessage("selectMoney", this, player.UserIDString));
                    }
                    return;
                }
            }
        }
        [ChatCommand("togglestrike")]
        private void chatToggleStrike(BasePlayer player, string command, string[] args)
        {
            if (!canSmokeStrike(player)) return;
            if (!toggleList.ContainsKey(player.userID)) toggleList.Add(player.userID, false);

            string reply = "";
            if (toggleList[player.userID] == true) reply = "ON";
            else reply = "OFF";

            if (args.Length == 0)
            {
                SendReply(player, string.Format(lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("onOff", this, player.UserIDString), reply));
                return;
            }            
            else if (args.Length == 1)
            {
                var toggleString = args[0].ToUpper();
                if (toggleString != "ON")
                {
                    reply = "OFF";
                    toggleList[player.userID] = false;
                    SendReply(player, string.Format(lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("onOff", this, player.UserIDString), reply));
                    return;
                }
                if (toggleString == "ON")
                {
                    toggleList[player.userID] = true;
                    SendReply(player, string.Format(lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("onOff", this, player.UserIDString), toggleString));
                    return;
                }                
            }
            else if (args.Length > 1)
            {
                SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("badSyntax", this, player.UserIDString));
                SendReply(player, lang.GetMessage("toggleOn", this, player.UserIDString));
                return;
            }

        }
        [ConsoleCommand("airstrike")]
        void ccmdAirstrike(ConsoleSystem.Arg arg)
        {
            if (!isAuth(arg)) return;
            if (arg.Args == null || arg.Args.Length == 0)
            {
                callRandomStrike(true);
                return;
            }

            if (arg.Args.Length == 1)
            {
                var fplayer = FindPlayer(arg.Args[0]);
                if (fplayer.Count == 0)
                {
                    SendReply(arg, lang.GetMessage("noPlayers", this));
                    return;
                }
                if (fplayer.Count > 1)
                {
                    SendReply(arg, lang.GetMessage("multiplePlayers", this));
                    return;
                }
                strikeOnPlayer(fplayer[0]);
                return;                  
            }

            if (arg.Args.Length == 3)
            {
                float x;
                float y;
                float z;
                try
                {
                    x = Convert.ToSingle(arg.Args[0]);
                    y = Convert.ToSingle(arg.Args[1]);
                    z = Convert.ToSingle(arg.Args[2]);
                }
                catch (FormatException ex)
                {
                    SendReply(arg, lang.GetMessage("coordNum", this));
                    return;
                }
                Vector3 pos = new Vector3(x, y, z);
                callStrike(pos);
                return;
            }

            if (arg.Args.Length == 2 || arg.Args.Length >= 4)
            {
                SendReply(arg, lang.GetMessage("badSyntax", this));
                SendReply(arg, lang.GetMessage("airStrike", this));
                SendReply(arg, lang.GetMessage("airStrikeName", this));
                SendReply(arg, lang.GetMessage("airStrikeCoords", this));
                return;
            }
            
        }
        [ConsoleCommand("squadstrike")]
        void ccmdsquadstrike(ConsoleSystem.Arg arg)
        {
            if (!isAuth(arg)) return;
            if (arg.Args == null || arg.Args.Length == 0)
            {
                callRandomStrike(false);
                return;
            }

            if (arg.Args.Length == 1)
            {
                var fplayer = FindPlayer(arg.Args[0]);
                if (fplayer.Count == 0)
                {
                    SendReply(arg, lang.GetMessage("noPlayers", this));
                    return;
                }
                if (fplayer.Count > 1)
                {
                    SendReply(arg, lang.GetMessage("multiplePlayers", this));
                    return;
                }
                foreach (BasePlayer targetPlayer in fplayer)
                {
                    massStrike(targetPlayer.transform.position);
                    return;
                }
            }

            if (arg.Args.Length == 3)
            {
                float x;
                float y;
                float z;
                try
                {
                    x = Convert.ToSingle(arg.Args[0]);
                    y = Convert.ToSingle(arg.Args[1]);
                    z = Convert.ToSingle(arg.Args[2]);
                }
                catch (FormatException ex)
                {
                    SendReply(arg, lang.GetMessage("coordNum", this));
                    return;
                }
                Vector3 pos = new Vector3(x, y, z);
                massStrike(pos);
                return;
            }

            if (arg.Args.Length == 2 || arg.Args.Length >= 4)
            {
                SendReply(arg, lang.GetMessage("badSyntax", this));
                SendReply(arg, lang.GetMessage("airStrike", this));
                SendReply(arg, lang.GetMessage("airStrikeName", this));
                SendReply(arg, lang.GetMessage("airStrikeCoords", this));
                return;
            }

        }
        #endregion

        #region Classes and Data Management       
        class PlayerCooldown
        {
            public Dictionary<ulong, PCDInfo> pCooldown = new Dictionary<ulong, PCDInfo>();
            public PlayerCooldown() { }
        }
        class PCDInfo
        {
            public long Cooldown;
            public PCDInfo() { }
            public PCDInfo(long cd)
            {
                Cooldown = cd;
            }
        }
        void SaveData()
        {
            PCDDATA.WriteObject(pcdData);
        }
        void LoadData()
        {
            try
            {
                pcdData = Interface.GetMod().DataFileSystem.ReadObject<PlayerCooldown>("airstrike_data");
            }
            catch
            {
                Puts("Couldn't load Airstrike data, creating new datafile");
                pcdData = new PlayerCooldown();
            }
        }
        #endregion

        #region Config       
        private static bool broadcastStrikeAll = true;
        private static bool useSignalStrike = true;
        private static bool usePaymentStrike = true;
        private static bool usePaymentSquad = true;
        private static bool useEconomics = true;
        private static bool useCooldown = false;
        private static bool noAdminCooldown = true;
        private static bool useMixedRockets = false;
        private static bool changeSupplyStrike = false;

        private static float rocketSpeed = 110f;
        private static float rocketInterval = 0.6f;
        private static float damageModifier = 1.0f;
        private static float rocketSpread = 1.5f;

        private static int rocketAmount = 15;
        private static int planeSpeed = 105;
        private static int planeDistance = 900;
        private static int buyMetal = 1000;
        private static int buyFlare = 2;
        private static int buyTarget = 1;
        private static int buyMoney = 500;
        private static int cooldownTime = 3600;
        private static int auth = 1;
        private static int fireChance = 4;

        private static string normalRocket = "ammo.rocket.basic";
        private static string fireRocket = "ammo.rocket.fire";
        private static string rocketType = "ammo.rocket.basic";
        protected override void LoadDefaultConfig()
        {
            Puts("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        private void LoadConfigVariables()
        {
            CheckCfg("Messages - Broadcast strike to all players", ref broadcastStrikeAll);
            CheckCfg("Rockets - Use both rocket types", ref useMixedRockets);
            CheckCfg("Rockets - Chance of fire rocket - 1 in... ", ref fireChance);
            CheckCfg("Supply Signals - Change the supply strike to call a Squadstrike", ref changeSupplyStrike);
            CheckCfg("Supply Signals - Use supply signals to call strike", ref useSignalStrike);
            CheckCfg("Buy - Can purchase airstrike", ref usePaymentStrike);
            CheckCfg("Buy - Can purchase squadstrike", ref usePaymentSquad);
            CheckCfg("Buy - Use Economics", ref useEconomics);
            CheckCfg("Cooldown - Use Cooldown", ref useCooldown);
            CheckCfg("Cooldown - Admin exempt from cooldown", ref noAdminCooldown);
            CheckCfg("Options - Minimum Authlevel", ref auth);

            CheckCfgFloat("Rockets - Speed of rockets", ref rocketSpeed);
            CheckCfgFloat("Rockets - Interval between rockets (seconds)", ref rocketInterval);
            CheckCfgFloat("Rockets - Damage Modifier", ref damageModifier);
            CheckCfgFloat("Rockets - Accuracy of rockets", ref rocketSpread);

            CheckCfg("Rockets - Amount of rockets to fire", ref rocketAmount);
            CheckCfg("Plane - Plane speed", ref planeSpeed);
            CheckCfg("Plane - Plane distance before firing", ref planeDistance);
            CheckCfg("Buy - Buy strike cost - HQ Metal", ref buyMetal);
            CheckCfg("Buy - Buy strike cost - Flare", ref buyFlare);
            CheckCfg("Buy - Buy strike cost - Targeting Computer", ref buyTarget);
            CheckCfg("Buy - Buy strike cost - Economics", ref buyMoney);
            CheckCfg("Rockets - Default rocket type", ref rocketType);
            CheckCfg("Cooldown - Cooldown timer", ref cooldownTime);
        }
        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }
        private void CheckCfgFloat(string Key, ref float var)
        {

            if (Config[Key] != null)
                var = Convert.ToSingle(Config[Key]);
            else
                Config[Key] = var;
        }
        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                changed = true;
            }
            return value;
        }
        #endregion

        #region Localization       
        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"title", "<color=orange>Airstrike</color> : "},
            {"strikeConfirmed", "Airstrike confirmed at co-ords: {0}!"},
            {"squadConfirmed", "Squadstrike confirmed at co-ords: {0}!"},
            {"strikeInbound", "Airstrike Inbound!"},
            {"buyCost", "To purchase a airstrike you need either;"},
            {"squadCost", "To purchase a squadstrike you need either;"},
            {"buyFlare", "{0} Targeting Computer(s) and {1} Flare(s)"},
            {"noMoney", "You do not have enough money to buy a strike" },
            {"buyMetal", "-or- {0} High Quality Metal"},
            {"noPerms", "You dont not have permission to use this command."},
            {"badSyntax", "Incorrect syntax:"},
            {"callStrike", "\"callstrike\" will call a strike on your location."},
            {"callStrikeName", "callstrike \"PLAYERNAME\" will call a strike on a player"},
            {"noPlayers", "No players found."},
            {"multiplePlayers", "Multiple players found"},
            {"selectPayment", "You must select a payment type"},
            {"selectOptions", "/buystrike metal -or- /buystrike computer"},
            {"selectMoney", "-or- /buystrike money" },
            {"validType", "Enter a valid payment type"},
            {"squadSyntax", "/buystrike squad metal -or- /buystrike squad computer"},
            {"onOff", "Signal airstrike is {0}!"},
            {"toggleOn", "\"airstrike\" \"on\" -or- \"off\""},
            {"coordNum", "Co-ordinates must be numbers!"},
            {"airStrike", "\"airstrike\" will call a random strike."},
            {"airStrikeName", "airstrike \"PLAYERNAME\" will call a strike on a player"},
            {"airStrikeCoords", "airstrike \"x y z\" will call a strike on a co-ordinates"},
            {"calledStrike", " has called a airstrike at co-ords: "},
            {"calledMassStrike", " has called a squadron airstrike at co-ords: "},
            {"calledTo", "Airstrike called to {0}" },
            {"cdTime", "You must wait another {0} minutes before using this command again" },
            {"Only change this is your supply signal name is in a differant language", "supply" }
        };
        #endregion


    }
}


// --- End of file: Airstrike.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Notice.cs ---
// --- Original Local Path: Notice.cs ---

using System.Collections.Generic;
using System.Reflection;
using System;
using System.Data;
using UnityEngine;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Notice", "LaserHydra", "1.0.1", ResourceId = 1193)]
    [Description("Notice players anonymously")]
    class Notice : RustPlugin
    {
        void Loaded()
        {
            LoadDefaultConfig();
            if (!permission.PermissionExists("canNotice")) permission.RegisterPermission("canNotice", this);
        }

        protected override void LoadDefaultConfig()
        {
			if(Config["Prefix"] == null) Config["Prefix"] = "<color=red>ADMIN</color>";
			if(Config["Prefix"].ToString() != "<color=red>ADMIN</color>") return;
            SaveConfig();
        }
		
        [ChatCommand("notice")]
        void cmdNotice(BasePlayer player, string cmd, string[] args)
        {
            string uid = player.userID.ToString();
            if (!permission.UserHasPermission(uid, "canNotice"))
            {
                SendChatMessage(player, "NOTICE", "You have no permission to use this command!");
                return;
            }

            if (args.Length < 2)
            {
                SendChatMessage(player, "NOTICE", "Syntax: /notice <player> <message>");
                return;
            }

            string msg = ArrayToString(args, 1);
            string prefix = Config["Prefix"].ToString();
            BasePlayer targetPlayer = GetPlayer(args[0], player, "NOTICE");
            if (targetPlayer != null)
            {
                SendChatMessage(targetPlayer, prefix, msg);
                SendChatMessage(player, "NOTICE", "Message sent!");
            }
        }

        #region UsefulMethods
        //--------------------------->   Player finding   <---------------------------//

        BasePlayer GetPlayer(string searchedPlayer, BasePlayer executer, string prefix)
        {
            BasePlayer targetPlayer = null;
            List<string> foundPlayers = new List<string>();
            string searchedLower = searchedPlayer.ToLower();
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                string display = player.displayName;
                string displayLower = display.ToLower();

                if (!displayLower.Contains(searchedLower))
                {
                    continue;
                }
                if (displayLower.Contains(searchedLower))
                {
                    foundPlayers.Add(display);
                }
            }
            var matchingPlayers = foundPlayers.ToArray();

            if (matchingPlayers.Length == 0)
            {
                SendChatMessage(executer, prefix, "No matching players found!");
            }

            if (matchingPlayers.Length > 1)
            {
                SendChatMessage(executer, prefix, "Multiple players found:");
                string multipleUsers = "";
                foreach (string matchingplayer in matchingPlayers)
                {
                    if (multipleUsers == "")
                    {
                        multipleUsers = "<color=yellow>" + matchingplayer + "</color>";
                        continue;
                    }

                    if (multipleUsers != "")
                    {
                        multipleUsers = multipleUsers + ", " + "<color=yellow>" + matchingplayer + "</color>";
                    }

                }
                SendChatMessage(executer, prefix, multipleUsers);
            }

            if (matchingPlayers.Length == 1)
            {
                targetPlayer = BasePlayer.Find(matchingPlayers[0]);
            }
            return targetPlayer;
        }

        //---------------------------->   Converting   <----------------------------//

        string ArrayToString(string[] array, int first)
        {
            int count = 0;
            string output = array[first];
            foreach (string current in array)
            {
                if (count <= first)
                {
                    count++;
                    continue;
                }

                output = output + " " + current;
                count++;
            }
            return output;
        }

        //---------------------------->   Chat Sending   <----------------------------//

        void BroadcastChat(string prefix, string msg)
        {
            PrintToChat("<color=orange>" + prefix + "</color>: " + msg);
        }

        void SendChatMessage(BasePlayer player, string prefix, string msg)
        {
            SendReply(player, "<color=orange>" + prefix + "</color>: " + msg);
        }

        //---------------------------------------------------------------------------//
        #endregion
    }
}


// --- End of file: Notice.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PathFinding.cs ---
// --- Original Local Path: PathFinding.cs ---

using System;
using System.Collections.Generic;
using System.Reflection;
using Oxide.Core.Plugins;
using UnityEngine;
using static UnityEngine.Vector3;

namespace Oxide.Plugins
{
    [Info("PathFinding", "Reneb / Nogrod", "1.1.1")]
    public class PathFinding : RustPlugin
    {
        private static readonly Vector3 Up = up;
        public sealed class PathFinder
        {
            private static readonly sbyte[,] Direction = {{0, -1}, {1, 0}, {0, 1}, {-1, 0}, {1, -1}, {1, 1}, {-1, 1}, {-1, -1}};
            public static readonly Vector3 EyesPosition;
            public static readonly uint Size;
            public static PriorityQueue OpenList;
            public static PathFindNode[,] Grid;

            static PathFinder()
            {
                EyesPosition = new Vector3(0f, 1.6f, 0f);
                OpenList = new PriorityQueue(MaxDepth * Direction.GetLength(0)); // 8 directions for each node
                Size = World.Size;
                Grid = new PathFindNode[Size, Size];
                //Interface.Oxide.LogInfo("Queue: {0} Grid: {1} Size: {2}", OpenList.MaxSize, Grid.Length, Size);
            }

            public List<Vector3> FindPath(Vector3 sourcePos, Vector3 targetPos)
            {
                //Interface.Oxide.LogInfo("Queue: {0} Grid: {1}", OpenList.MaxSize, Grid.Length);
                var closedList = new HashSet<PathFindNode>();

                var targetNode = new PathFindNode(targetPos);
                if (targetNode.X < 0 || targetNode.X >= Size || targetNode.Z < 0 || targetNode.Z >= Size) return null;
                Grid[targetNode.X, targetNode.Z] = targetNode;

                var startNode = new PathFindNode(sourcePos);
                if (startNode.X < 0 || startNode.X >= Size || startNode.Z < 0 || startNode.Z >= Size) return null;
                Grid[startNode.X, startNode.Z] = startNode;
                OpenList.Enqueue(startNode);
                //PathFindNode closestNode = null;

                while (OpenList.Count > 0)
                {
                    var currentNode = OpenList.Dequeue();
                    if (currentNode == targetNode)
                    {
                        Clear();
                        return RetracePath(startNode, targetNode);
                    }
                    closedList.Add(currentNode);
                    for (var i = 0; i < 8; i++)
                    {
                        var dirX = Direction[i, 0];
                        var dirZ = Direction[i, 1];
                        var x = currentNode.X + dirX;
                        var z = currentNode.Z + dirZ;
                        if (x < 0 || x >= Size || z < 0 || z >= Size) continue;
                        var neighbour = FindPathNodeOrCreate(x, z, currentNode.Position.y);
                        //Interface.Oxide.LogInfo("Checking neighbour: {0} {1} {2} {3} {4}", x, z, neighbour.Position, closedList.Contains(neighbour), neighbour.Walkable);
                        if (!neighbour.Walkable) continue;
                        var newGScore = currentNode.G + GetDistance(currentNode, neighbour);
                        if (newGScore >= neighbour.G && closedList.Contains(neighbour)) continue;
                        if (newGScore < neighbour.G || !OpenList.Contains(neighbour))
                        {
                            //foreach (var player in BasePlayer.activePlayerList)
                            //    player.SendConsoleCommand("ddraw.sphere", 30f, Color.black, neighbour.Position, .25f);
                            neighbour.G = newGScore;
                            neighbour.H = GetDistance(neighbour, targetNode);
                            neighbour.F = newGScore + neighbour.H;
                            neighbour.Parent = currentNode;
                            if (!OpenList.Contains(neighbour))
                                OpenList.Enqueue(neighbour);
                            else
                                OpenList.Update(neighbour);
                            //if (closestNode == null || newGScore < closestNode.G)
                            //    closestNode = neighbour;
                        }
                    }
                    if (closedList.Count > MaxDepth)
                    {
                        //Interface.Oxide.LogWarning("[PathFinding] Hit MaxDepth!");
                        break;
                    }
                }
                Clear();
                //if (closestNode != null)
                //    return RetracePath(startNode, closestNode);
                return null;
            }

            private static void Clear()
            {
                OpenList.Clear();
                Array.Clear(Grid, 0, Grid.Length);
            }

            private static List<Vector3> RetracePath(PathFindNode startNode, PathFindNode endNode)
            {
                var path = new List<Vector3>();
                while (endNode != startNode)
                {
                    path.Add(endNode.Position);
                    endNode = endNode.Parent;
                }
                path.Reverse();
                //path.RemoveAt(0);
                return path;
            }

            private static int GetDistance(PathFindNode nodeA, PathFindNode nodeB)
            {
                var dstX = Math.Abs(nodeA.X - nodeB.X);
                var dstZ = Math.Abs(nodeA.Z - nodeB.Z);
                var dstY = Math.Abs(nodeA.Position.y - nodeB.Position.y);

                if (dstX > dstZ)
                    return 14*dstZ + 10*(dstX - dstZ) + (int)(10*dstY);
                return 14*dstX + 10*(dstZ - dstX) + (int)(10*dstY);
            }

            private static PathFindNode FindPathNodeOrCreate(int x, int z, float y)
            {
                var node = Grid[x, z];
                if (node != null) return node;
                var halfGrid = Size/2f;
                var groundPos = new Vector3(x - halfGrid, y, z - halfGrid);
                //groundPos.y = TerrainMeta.HeightMap.GetHeight(groundPos);
                FindRawGroundPosition(groundPos, out groundPos);
                Grid[x, z] = node = new PathFindNode(groundPos);
                return node;
            }
        }

        public sealed class PriorityQueue
        {
            private readonly PathFindNode[] nodes;
            private int numNodes;

            public PriorityQueue(int maxNodes)
            {
                numNodes = 0;
                nodes = new PathFindNode[maxNodes + 1];
            }

            public int Count => numNodes;

            public int MaxSize => nodes.Length - 1;

            public void Clear()
            {
                Array.Clear(nodes, 1, numNodes);
                numNodes = 0;
            }

            public bool Contains(PathFindNode node)
            {
                return nodes[node.QueueIndex] == node;
            }

            public void Update(PathFindNode node)
            {
                SortUp(node);
            }

            public void Enqueue(PathFindNode node)
            {
                nodes[++numNodes] = node;
                node.QueueIndex = numNodes;
                SortUp(node);
            }

            private void Swap(PathFindNode node1, PathFindNode node2)
            {
                nodes[node1.QueueIndex] = node2;
                nodes[node2.QueueIndex] = node1;

                var temp = node1.QueueIndex;
                node1.QueueIndex = node2.QueueIndex;
                node2.QueueIndex = temp;
            }

            private void SortUp(PathFindNode node)
            {
                var parent = node.QueueIndex/2;
                while (parent > 0)
                {
                    var parentNode = nodes[parent];
                    if (CompareTo(parentNode, node) >= 0)
                        break;

                    Swap(node, parentNode);

                    parent = node.QueueIndex/2;
                }
            }

            private void SortDown(PathFindNode node)
            {
                var finalQueueIndex = node.QueueIndex;
                while (true)
                {
                    var newParent = node;
                    var childLeftIndex = 2*finalQueueIndex;

                    if (childLeftIndex > numNodes)
                    {
                        node.QueueIndex = finalQueueIndex;
                        nodes[finalQueueIndex] = node;
                        break;
                    }

                    var childLeft = nodes[childLeftIndex];
                    if (CompareTo(childLeft, newParent) >= 0)
                    {
                        newParent = childLeft;
                    }

                    var childRightIndex = childLeftIndex + 1;
                    if (childRightIndex <= numNodes)
                    {
                        var childRight = nodes[childRightIndex];
                        if (CompareTo(childRight, newParent) >= 0)
                        {
                            newParent = childRight;
                        }
                    }

                    if (newParent != node)
                    {
                        nodes[finalQueueIndex] = newParent;

                        var temp = newParent.QueueIndex;
                        newParent.QueueIndex = finalQueueIndex;
                        finalQueueIndex = temp;
                    }
                    else
                    {
                        node.QueueIndex = finalQueueIndex;
                        nodes[finalQueueIndex] = node;
                        break;
                    }
                }
            }

            public PathFindNode Dequeue()
            {
                var node = nodes[1];
                Remove(node);
                return node;
            }

            public void Remove(PathFindNode node)
            {
                if (node.QueueIndex == numNodes)
                {
                    nodes[numNodes--] = null;
                    return;
                }

                var formerLastNode = nodes[numNodes];
                Swap(node, formerLastNode);
                nodes[numNodes--] = null;

                var parentIndex = formerLastNode.QueueIndex/2;
                var parentNode = nodes[parentIndex];

                if (parentIndex > 0 && CompareTo(formerLastNode, parentNode) >= 0)
                    SortUp(formerLastNode);
                else
                    SortDown(formerLastNode);
            }

            private static int CompareTo(PathFindNode node, PathFindNode other)
            {
                if (node.F == other.F)
                {
                    if (node.H == other.H)
                        return 0;
                    if (node.H > other.H)
                        return -1;
                    return 1;
                }
                if (node.F > other.F)
                    return -1;
                return 1;
            }
        }

        public sealed class PathFindNode
        {
            public readonly int X;
            public readonly int Z;
            public int QueueIndex;
            public float H;
            public float G;
            public float F;
            public PathFindNode Parent;
            public Vector3 Position;
            public bool Walkable;

            public PathFindNode(Vector3 position)
            {
                Position = position;
                X = (int) Math.Round(position.x + PathFinder.Size/2f);
                Z = (int) Math.Round(position.z + PathFinder.Size/2f);
                Walkable = !Physics.CheckSphere(position + PathFinder.EyesPosition, .801f, blockLayer);
            }

            public override int GetHashCode()
            {
                return X << 16 | Z;
            }
        }

        public static bool FindRawGroundPosition(Vector3 sourcePos, out Vector3 groundPos)
        {
            groundPos = sourcePos;
            RaycastHit hitinfo;
            if (Physics.Raycast(sourcePos + Up, down, out hitinfo, 50, groundLayer))
            {
                groundPos.y = Math.Max(hitinfo.point.y, TerrainMeta.HeightMap.GetHeight(groundPos));
                return true;
            }
            if (Physics.Raycast(sourcePos - Up, Up, out hitinfo, 1.5f, groundLayer))
            {
                groundPos.y = Math.Max(hitinfo.point.y, TerrainMeta.HeightMap.GetHeight(groundPos));
                return true;
            }
            return false;
        }

        private class PathFollower : MonoBehaviour
        {
            private readonly FieldInfo viewangles = typeof (BasePlayer).GetField("viewAngles", BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic);
            public List<Vector3> Paths = new List<Vector3>();
            public float secondsTaken;
            public float secondsToTake;
            public float waypointDone;
            public float speed;
            public Vector3 StartPos;
            public Vector3 EndPos;
            public Vector3 nextPos;
            public BaseEntity entity;
            public BasePlayer player;

            private void Awake()
            {
                entity = GetComponent<BaseEntity>();
                player = GetComponent<BasePlayer>() ?? player;
                speed = 4f;
            }

            private void Move()
            {
                if (secondsTaken == 0f) FindNextWaypoint();
                Execute_Move();
                if (waypointDone >= 1f) secondsTaken = 0f;
            }

            private void Execute_Move()
            {
                if (StartPos == EndPos) return;
                secondsTaken += Time.deltaTime;
                waypointDone = Mathf.InverseLerp(0f, secondsToTake, secondsTaken);
                nextPos = Lerp(StartPos, EndPos, waypointDone);
                entity.transform.position = nextPos;
                player?.ClientRPCPlayer(null, player, "ForcePositionTo", nextPos);
                entity.TransformChanged();
            }

            private void FindNextWaypoint()
            {
                if (Paths.Count == 0)
                {
                    StartPos = EndPos = zero;
                    enabled = false;
                    return;
                }
                SetMovementPoint(Paths[0], 4f);
            }

            public void SetMovementPoint(Vector3 endpos, float s)
            {
                StartPos = entity.transform.position;
                if (endpos != StartPos)
                {
                    EndPos = endpos;
                    secondsToTake = Distance(EndPos, StartPos)/s;
                    entity.transform.rotation = Quaternion.LookRotation(EndPos - StartPos);
                    if (player != null) SetViewAngle(player, entity.transform.rotation);
                    secondsTaken = 0f;
                    waypointDone = 0f;
                }
                Paths.RemoveAt(0);
            }

            private void SetViewAngle(BasePlayer player, Quaternion ViewAngles)
            {
                viewangles.SetValue(player, ViewAngles);
                player.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            }

            private void FixedUpdate()
            {
                Move();
            }
        }

        public static Vector3 jumpPosition = new Vector3(0f, 1f, 0f);
        public static int groundLayer;
        public static int blockLayer;
        private static int MaxDepth = 5000;
        private readonly FieldInfo serverinput = typeof (BasePlayer).GetField("serverInput", BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic);

        protected override void LoadDefaultConfig()
        {
        }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T) Config[Key];
            else
                Config[Key] = var;
        }

        private void Init()
        {
            CheckCfg("Max Depth", ref MaxDepth);
            SaveConfig();
        }


        /////////////////////////////////////////////
        /// OXIDE HOOKS
        /////////////////////////////////////////////
        private void OnServerInitialized()
        {
            groundLayer = LayerMask.GetMask("Terrain", "World", "Construction", "Deployed", "Default");
            blockLayer = LayerMask.GetMask("World", "Construction", "Tree", "Deployed", "Default");

            timer.Once(30f, ResetPathFollowers);
        }

        private void Unload()
        {
            var objects = UnityEngine.Object.FindObjectsOfType<PathFollower>();
            if (objects != null)
                foreach (var gameObj in objects)
                    UnityEngine.Object.Destroy(gameObj);
            PathFinder.OpenList = null;
            PathFinder.Grid = null;
        }

        /////////////////////////////////////////////
        /// Outside Plugin Calls
        /////////////////////////////////////////////
        private bool FindAndFollowPath(BaseEntity entity, Vector3 sourcePosition, Vector3 targetPosition)
        {
            //var curtime = Time.realtimeSinceStartup;
            var bestPath = FindBestPath(sourcePosition, targetPosition);
            //Debug.Log((Time.realtimeSinceStartup - curtime).ToString());
            if (bestPath == null) return false;
            FollowPath(entity, bestPath);
            return true;
        }

        private void FollowPath(BaseEntity entity, List<Vector3> pathpoints)
        {
            var pathfollower = entity.GetComponent<PathFollower>() ?? entity.gameObject.AddComponent<PathFollower>();
            pathfollower.Paths = pathpoints;
            pathfollower.enabled = true;
        }

        [HookMethod("FindBestPath")]
        public List<Vector3> FindBestPath(Vector3 sourcePosition, Vector3 targetPosition)
        {
            return FindLinePath(sourcePosition, targetPosition) ?? FindPath(sourcePosition, targetPosition);
        }

        public List<Vector3> Go(Vector3 source, Vector3 target)
        {
            return FindLinePath(source, target) ?? FindPath(source, target);
        }

        private List<Vector3> FindPath(Vector3 sourcePosition, Vector3 targetPosition)
        {
            //Puts("FindPath: {0} {1}", sourcePosition, targetPosition);
            return new PathFinder().FindPath(sourcePosition, targetPosition);
        }

        private List<Vector3> FindLinePath(Vector3 sourcePosition, Vector3 targetPosition)
        {
            var distance = (int) Math.Ceiling(Distance(sourcePosition, targetPosition));
            if (distance <= 0) return null;
            var straightPath = new List<Vector3>(new Vector3[distance]) {[distance - 1] = targetPosition};
            var currentPos = Lerp(sourcePosition, targetPosition, 1f / distance);
            Vector3 groundPosition;
            if (!FindRawGroundPosition(currentPos, out groundPosition)) return null;
            if (Distance(groundPosition, sourcePosition) > 2) return null;
            if (Physics.Linecast(sourcePosition + jumpPosition, groundPosition + jumpPosition, blockLayer)) return null;
            straightPath[0] = groundPosition;
            for (var i = 1; i < distance - 1; i++)
            {
                currentPos = Lerp(sourcePosition, targetPosition, (i + 1f)/distance);
                if (!FindRawGroundPosition(currentPos, out groundPosition)) return null;
                if (Distance(groundPosition, straightPath[i - 1]) > 2) return null;
                if (Physics.Linecast(straightPath[i - 1] + jumpPosition, groundPosition + jumpPosition, blockLayer)) return null;
                straightPath[i] = groundPosition;
            }
            if (Physics.Linecast((distance == 1 ? sourcePosition : straightPath[distance - 2]) + jumpPosition, targetPosition + jumpPosition, blockLayer)) return null;
            return straightPath;
        }

        /////////////////////////////////////////////
        /// Reset part of the plugin
        /////////////////////////////////////////////
        private void ResetPathFollowers()
        {
            var objects = UnityEngine.Object.FindObjectsOfType<PathFollower>();
            foreach (var gameObj in objects)
                if (gameObj.Paths.Count == 0)
                    UnityEngine.Object.Destroy(gameObj);
        }

        /////////////////////////////////////////////
        /// Debug Command
        /////////////////////////////////////////////
        [ChatCommand("path")]
        private void cmdChatPath(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel < 1) return;
            Quaternion currentRot;
            if (!TryGetPlayerView(player, out currentRot)) return;
            object closestEnt;
            Vector3 closestHitpoint;
            if (!TryGetClosestRayPoint(player.transform.position, currentRot, out closestEnt, out closestHitpoint)) return;

            FindAndFollowPath(player, player.transform.position, closestHitpoint);
        }

        private bool TryGetPlayerView(BasePlayer player, out Quaternion viewAngle)
        {
            viewAngle = new Quaternion(0f, 0f, 0f, 0f);
            var input = serverinput.GetValue(player) as InputState;
            if (input?.current == null) return false;
            viewAngle = Quaternion.Euler(input.current.aimAngles);
            return true;
        }

        private bool TryGetClosestRayPoint(Vector3 sourcePos, Quaternion sourceDir, out object closestEnt, out Vector3 closestHitpoint)
        {
            var sourceEye = sourcePos + PathFinder.EyesPosition;
            var ray = new Ray(sourceEye, sourceDir*forward);

            var hits = Physics.RaycastAll(ray);
            var closestdist = 999999f;
            closestHitpoint = sourcePos;
            closestEnt = false;
            for (var i = 0; i < hits.Length; i++)
            {
                var hit = hits[i];
                if (hit.collider.GetComponentInParent<TriggerBase>() == null && hit.distance < closestdist)
                {
                    closestdist = hit.distance;
                    closestEnt = hit.collider;
                    closestHitpoint = hit.point;
                }
            }

            if (closestEnt is bool) return false;
            return true;
        }
    }
}


// --- End of file: PathFinding.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/MasterKey.cs ---
// --- Original Local Path: MasterKey.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("MasterKey", "Wulf/lukespragg", "0.5.0", ResourceId = 1151)]
    [Description("Gain access to any locked object and/or build anywhere with permission")]

    class MasterKey : CovalencePlugin
    {
        #region Initialization

        readonly DynamicConfigFile dataFile = Interface.Oxide.DataFileSystem.GetFile("MasterKey");
        readonly string[] lockableTypes = { "box", "cell", "door", "gate", "shop", "hatch" };
        Dictionary<string, bool> playerPrefs = new Dictionary<string, bool>();

        const string permBuild = "masterkey.build";
        const string permCupboard = "masterkey.cupboard";

        bool logUsage;
        bool showMessages;

        protected override void LoadDefaultConfig()
        {
            // Options
            Config["Log Usage (true/false)"] = logUsage = GetConfig("Log Usage (true/false)", true);
            Config["Show Messages (true/false)"] = showMessages = GetConfig("Show Messages (true/false)", true);

            SaveConfig();
        }
        
        void Init()
        {
            LoadDefaultConfig();
            LoadDefaultMessages();
            playerPrefs = dataFile.ReadObject<Dictionary<string, bool>>();

            permission.RegisterPermission(permBuild, this);
            permission.RegisterPermission(permCupboard, this);
            foreach (var type in lockableTypes) permission.RegisterPermission($"{Title.ToLower()}.{type}", this);
        }

        #endregion

        #region Localization

        void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Disabled"] = "Master key access is now disabled",
                ["Enabled"] = "Master key access is now enabled",
                ["MasterKeyUsed"] = "{0} ({1}) used master key at {2}",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["UnlockedWith"] = "Unlocked {0} with master key!"
            }, this);
        }

        #endregion

        #region Chat Command

        [Command("masterkey", "mkey", "mk")]
        void ChatCommand(IPlayer player, string command, string[] args)
        {
            foreach (var type in lockableTypes)
            {
                if (player.HasPermission($"{Title.ToLower()}.{type}")) continue;
                player.Reply(Lang("NotAllowed", player.Id, command));
                return;
            }

            if (!playerPrefs.ContainsKey(player.Id)) playerPrefs.Add(player.Id, true);
            playerPrefs[player.Id] = !playerPrefs[player.Id];
            dataFile.WriteObject(playerPrefs);

            player.Reply(playerPrefs[player.Id] ? Lang("Enabled", player.Id) : Lang("Disabled"));
        }

        #endregion

        #region Lock Access

        object CanUseLock(BasePlayer player, BaseLock @lock)
        {
            var prefab = @lock.parentEntity.Get(true).ShortPrefabName;

            if (!@lock.IsLocked()) return null;
            if (playerPrefs.ContainsKey(player.UserIDString) && !playerPrefs[player.UserIDString]) return null;

            foreach (var type in lockableTypes)
            {
                if (!prefab.Contains(type)) continue;

                if (!permission.UserHasPermission(player.UserIDString, $"masterkey.{type}")) return null;
                if (showMessages) player.ChatMessage(Lang("UnlockedWith", player.UserIDString, type));
                if (logUsage) LogToFile(Lang("MasterKeyUsed", null, player.displayName, player.UserIDString, player.transform.position));
                return true;
            }

            return null;
        }

        #endregion

        #region Cupboard Access

        object OnCupboardAuthorize(BuildingPrivlidge priviledge, BasePlayer player)
        {
            if (playerPrefs.ContainsKey(player.UserIDString) && !playerPrefs[player.UserIDString]) return null;

            if (!permission.UserHasPermission(player.UserIDString, permCupboard)) return null;
            if (showMessages) player.ChatMessage(Lang("UnlockedWith", player.UserIDString, "cupboard"));
            if (logUsage) LogToFile(Lang("MasterKeyUsed", null, player.displayName, player.UserIDString, player.transform.position));
            return true;
        }

        #endregion

        #region Build Anywhere

        void OnEntityEnter(TriggerBase trigger, BaseEntity entity)
        {
            var player = entity as BasePlayer;
            if (player == null || !(trigger is BuildPrivilegeTrigger)) return;

            if (playerPrefs.ContainsKey(player.UserIDString) && !playerPrefs[player.UserIDString]) return;
            if (!permission.UserHasPermission(player.UserIDString, permBuild)) return;

            timer.Once(0.1f, () => player.SetPlayerFlag(BasePlayer.PlayerFlags.HasBuildingPrivilege, true));
            if (logUsage) LogToFile(Lang("MasterKeyUsed", null, player.displayName, player.UserIDString, player.transform.position));
        }

        #endregion

        #region Helpers

        T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        void LogToFile(string text) => ConVar.Server.Log($"oxide/logs/{Title.ToLower()}_{DateTime.Now.ToString("yyyy-MM-dd")}.txt", text);

        #endregion
    }
}


// --- End of file: MasterKey.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RTEvent.cs ---
// --- Original Local Path: RTEvent.cs ---

using Network;
using Newtonsoft.Json;
using Oxide.Core;
using System;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System.Collections.Generic;
using System.Linq;
using Steamworks.ServerList;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("RTEvent", "EcoSmile Сделал CUI - Deversive", "1.0.7")]
    class RTEvent : RustPlugin
    {
        [PluginReference] private Plugin ImageLibrary, NoteUI;
        private string mainui = "mainui5";
        static RTEvent ins;
        PluginConfig config;

        //[JsonConverter(typeof(StringEnumConverter))]
        //public enum EnumType { none }

        public class PluginConfig
        {
            [JsonProperty("Настройка спавна")]
            public Dictionary<string, RTSetting> zoneSettings;
            [JsonProperty("Радиус маркера")]
            public float MarkerRadius;
            [JsonProperty("Часы дня когд ивент стартует")]
            public string[] StartTimes;
            [JsonProperty("Время до открытия ящика после спвна в минутах")]
            public float OpenTime;
            [JsonProperty("Список предметов выпадаемых из ящика")]
            public List<CustomItem> dropList;
            [JsonProperty("Время через которое ящик будет удален если не залутали до конца (в сек)")]
            public float DeletTime;
            [JsonProperty("Цвет маркера")]
            public string MarkerColor;
            [JsonProperty("Сообщение о начале ивента")]
            public string StartMessage;

            [JsonProperty("Сообщение об разблокировании {rt}")]
            public string UnlockMessage;

            [JsonProperty("Сообщение об открытии ящика {player}, {rt}")]
            public string OpenMessage;
        }

        public class RTSetting
        {
            [JsonProperty("Спавнить ящик на этом РТ?")]
            public bool Enable;
            [JsonProperty("Координаты точки спавна (команда /pos)")]
            public string Offset;
        }

        public class CustomItem
        {
            [JsonProperty("Шортнейм предмета")]
            public string ShortName;
            [JsonProperty("Кастомное имя предмета")]
            public string CustomName;
            [JsonProperty("Количество предмета Min")]
            public int AmountMin;
            [JsonProperty("Количество предмета Max")]
            public int AmountMax;
            [JsonProperty("SkinID предмета")]
            public ulong SkinID;
        }

        protected override void LoadDefaultConfig()
        {
            config = new PluginConfig
            {
                zoneSettings = GetMonuments(),
                MarkerRadius = 50f,
                StartTimes = new string[]
                {
                    "12:00",
                    "14:00",
                    "16:00",
                    "18:00",
                    "20:00",
                },
                OpenTime = 10,
                DeletTime = 300,
                MarkerColor = "#942E1DFF",
                StartMessage = "Начался ивент МегаЯщик.\nМестоположение отмечено на карте",
                OpenMessage = "Мегаящик на {rt} был залутан игроком {player}",
                UnlockMessage = "Мегаящик на {rt} был разблокирован.",
                dropList = new List<CustomItem>()
                {
                    new CustomItem()
                    {
                        ShortName = "rifle.bolt",
                        AmountMin = 1,
                        AmountMax = 1,
                        SkinID = 0,
                        CustomName = ""
                    },
                    new CustomItem()
                    {
                        ShortName = "rifle.ak",
                        AmountMin = 1,
                        AmountMax = 1,
                        SkinID = 0,
                        CustomName = ""
                    },
                    new CustomItem()
                    {
                        ShortName = "sulfur",
                        AmountMin = 1000,
                        AmountMax = 2000,
                        SkinID = 0,
                        CustomName = ""
                    },
                }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            SaveConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
        Dictionary<string, RTSetting> GetMonuments()
        {
            var monumentList = new Dictionary<string, RTSetting>();
            var monuments = TerrainMeta.Path.Monuments;
            foreach (var mon in monuments)
            {
                string monumentname = mon.displayPhrase.english;
                monumentname = monumentname.Replace("\n", "");
                if (string.IsNullOrEmpty(monumentname)) continue;
                if (!monumentList.ContainsKey(monumentname))
                    monumentList.Add(monumentname, new RTSetting()
                    {
                        Enable = false,
                        Offset = "0 0 0",
                    });
            }
            return monumentList;
        }
        EventData data;
        public class EventData
        {
            public int EventCount = 0;
        }

        void LoadData()
        {
            if (Interface.Oxide.DataFileSystem.ExistsDatafile(Name + "/Data"))
                data = Interface.Oxide.DataFileSystem.ReadObject<EventData>(Name + "/Data");
            else
                Interface.Oxide.DataFileSystem.WriteObject(Name + "/Data", data = new EventData());
        }

        private DateTime NextStart;
        private Dictionary<DateTime, TimeSpan> CalcNextRestartDict = new Dictionary<DateTime, TimeSpan>();
        private List<DateTime> EventTimes = new List<DateTime>();
        private void OnServerInitialized()
        {
            ins = this;
            LoadData();
            LoadImage();

            EventTimes = config.StartTimes.ToList().Select(date => DateTime.Parse(date)).ToList();
            GetNextRestart(EventTimes);
            timer.Every(60f, CheckStart);

        }

        
        #region ImageLibrary

        private string mainui1 = "https://imgur.com/XmJ8VdI.png";
        private string close = "https://imgur.com/MFS0gCS.png";
        
        
        private string GetImage(string fileName, ulong skin = 0)
        {
            var imageId = (string)plugins.Find("ImageLibrary").CallHook("GetImage", fileName, skin);
            if (!string.IsNullOrEmpty(imageId))
                return imageId;
            return string.Empty;
        }
        public bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname, skin);
        
        

        void LoadImage()
        {
            AddImage(mainui1, "fon");
            AddImage(close, "close");
        }
        
        #endregion
        

        [ConsoleCommand("testgive")]
        void testGiveGameStores()
        {
            string userID = "76561199129000011";
            GameStoresGive(userID);
            Puts("Всё ок");
        }
        
        void GameStoresGive(string userID)
        {
            int shopID = 43024;

           string SecretKey = "5047e570403ad2d3dee9f2356fa4ae44";
            int serverID = 32533;
            int Balance = 15;
            string descriptions = "Вы получили баланс за ОГРОМНЫЙ ящик";
            webrequest.Enqueue($"https://gamestores.ru/api?shop_id={shopID}&secret={SecretKey}&server={serverID}&action=moneys&type=plus&steam_id={userID}&amount={Balance}&mess={descriptions}", null, (i, s) =>
            {
                BasePlayer player = BasePlayer.Find(userID);
                if (i != 200) { }
                if (s.Contains("success"))
                {
                    Puts($"Пользователю {userID} успешно зачислен баланс - {Balance}");
                    if (player == null) return;
                    return;
                }
                if (s.Contains("fail"))
                {
                    Puts($"Пользователь {userID} не авторизован в магазине");
                    if (player == null) return;
                }
            }, this);
        }


        void MainUi(BasePlayer player)
        {
            /*Puts("1");*/
            /*CuiHelper.DestroyUi(player, "mainui5");
            CuiHelper.DestroyUi(player, mainui);*/
            
            timer.Once(15f, () => { CuiHelper.DestroyUi(player, mainui); });
            timer.Once(15f, () => { CuiHelper.DestroyUi(player, "mainui5"); });
            
            CuiElementContainer container = new CuiElementContainer();
                
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.4379627", AnchorMax = "0.1723957 0.5490744" },
                Image = { FadeIn = 1f, Color = "0 0 0 0", }
            },  "Hud", mainui);
            
            container.Add(new CuiElement
            {
                Parent = "mainui5",
                FadeOut = 1f,
                //Name = mainui + "mainui5",
                Components =
                {
                    new CuiImageComponent { Png = GetImage("fon") , Material = "assets/icons/greyout.mat", },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });
            
            container.Add(new CuiElement
            {
                Parent = "mainui5",
                FadeOut = 1f,
                //Name = mainui + "mainui5",
                Components =
                {
                    new CuiTextComponent { Text = "ОГРОМНЫЙ ЯЩИК", Color = HexToRustFormat("#CAD5DF"),  Align = TextAnchor.UpperLeft, FontSize = 13, Font = "robotocondensed-bold.ttf" },
                    new CuiRectTransformComponent { AnchorMin = "0.07902735 0.5499993", AnchorMax = "0.8267483 0.833331" }
                }
            });
            
            container.Add(new CuiElement
            {
                Parent = "mainui5",
                FadeOut = 1f,
                //Name = mainui + "mainui5",
                Components =
                {
                    new CuiTextComponent { Text = "ВНИМАНИЕ! На сервере заспавнился ОГРОМНЫЙ ящик с ресурсами", Color = HexToRustFormat("#8E8E8E") ,Align = TextAnchor.UpperLeft, FontSize = 9, Font = "robotocondensed-regular.ttf" },
                    new CuiRectTransformComponent { AnchorMin = "0.07902735 0.2250011", AnchorMax = "0.7234047 0.6416651" }
                }
            });
            
            container.Add(new CuiElement
            {
                Parent = "mainui5",
                FadeOut = 1f,
                //Name = mainui + "mainui5",
                Components =
                {
                    new CuiTextComponent { Text = "МЕСТОПОЛОЖЕНИЕ ОТМЕЧЕНО НА КАРТЕ", Color = HexToRustFormat("#CAD5DF") ,Align = TextAnchor.UpperLeft, FontSize = 9, Font = "robotocondensed-regular.ttf" },
                    new CuiRectTransformComponent { AnchorMin = "0.02127674 0.01666876", AnchorMax = "0.8358668 0.1916654" }
                }
            });
            
            /*container.Add(new CuiElement
            {
                Parent = "mainui5",
                //Name = mainui + "mainui5",
                Components =
                {
                    new CuiImageComponent { Png = GetImage("close") , Material = "assets/icons/greyout.mat", Color = "0.5568628 0.4078431 0.454902 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.844985 0.7083331", AnchorMax = "0.9118547 0.8999998" }
                }
            });
            
            container.Add(new CuiButton()
            {
                Button = { Color = "0 0 0 0", Command = $"chat.say /closeui" },
                RectTransform = { AnchorMin = "0.844985 0.7083331", AnchorMax = "0.9118547 0.8999998" },
                Text = { Text = "" }
            }, "mainui5" );*/
            
            CuiHelper.AddUi(player, container);
        }
        
        private static string HexToRustFormat(string hex)
        { 
            Color color;
            ColorUtility.TryParseHtmlString(hex, out color);
            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }
        
        
        void Unload()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name + "/Data", data);

            //if (sphereEntity != null && !sphereEntity.IsDestroyed)
            //    sphereEntity?.Kill();
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, "mainui5");
                CuiHelper.DestroyUi(player, mainui);
            }

            if (crate != null && !crate.IsDestroyed)
                crate?.Kill();

            if (mapMarker != null && !mapMarker.IsDestroyed)
                mapMarker?.Kill();

            destroyCrate?.Destroy();
            downTimer?.Destroy();
        }

        void OnServerSave()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name + "/Data", data);
        }

        void OnNewSave()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name + "/Data", data = new EventData());
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (player == null) return;

            if (player.IsReceivingSnapshot)
            {
                timer.In(2f, () => OnPlayerConnected(player));
                return;
            }

            if (started)
            {
                mapMarker.SendUpdate();
            }
        }

        bool started = false;

        void CheckStart()
        {
            if (NextStart > DateTime.Now) return;
            if (started) return;
            StartEvent();
        }

        [ConsoleCommand("tst")]
        void tstCmd(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            StartEvent();
        }

        [ChatCommand("tst")]
        void Start(BasePlayer player)
        {
            if (!player.IsAdmin) return;
            StartEvent();
        }
         
        void StartEvent()
        {
            started = true;

            if (crate != null && !crate.IsDestroyed)
                crate?.Kill();

            if (mapMarker != null && !mapMarker.IsDestroyed)
                mapMarker?.Kill();

            destroyCrate?.Destroy();
            downTimer?.Destroy();

            var monumentConfig = config.zoneSettings.Where(x => x.Value.Enable && TerrainMeta.Path.Monuments.Any(y => y.displayPhrase.english.Replace("\n", "") == x.Key)).ToDictionary(x => x.Key, y => y.Value);
            if (monumentConfig.Count() <= 0)
            {
                started = false;
                PrintError($"НЕ НАЙДЕНО НЕ ОДНОГО ПОДХОДЯЩЕГО РТ ДЛЯ ЗАПУСКА ИВЕНТА");
                EventTimes = config.StartTimes.ToList().Select(date => DateTime.Parse(date)).ToList();
                GetNextRestart(EventTimes);
                return;
            }

            var monNames = monumentConfig.Keys.ToList().GetRandom();
            var mon = TerrainMeta.Path.Monuments.FirstOrDefault(x => x.displayPhrase.english.Replace("\n", "") == monNames);
            if (mon == null)
            {
                started = false;
                PrintError($"НЕ УДАЛОСЬ НАЙТИ РТ {monNames} НА КАРТЕ");
                EventTimes = config.StartTimes.ToList().Select(date => DateTime.Parse(date)).ToList();
                GetNextRestart(EventTimes);
                return;
            }
            data.EventCount++;
            Vector3 localPoint = config.zoneSettings[monNames].Offset.ToVector3();
            var pos = mon.transform.position + mon.transform.rotation * localPoint;
            RtName = monNames;
            PrintWarning($"Event Started on: {RtName}");
            SpawnCrate(pos);
        }

        string RtName = "";
        MapMarkerGenericRadius mapMarker;

        StorageContainer crate;

        void SpawnCrate(Vector3 pos)
        {
            if (crate != null && !crate.IsDestroyed)
                crate.Kill();

            crate = GameManager.server.CreateEntity("assets/bundled/prefabs/radtown/crate_underwater_advanced.prefab", pos) as StorageContainer;
            crate.globalBroadcast = true;
            crate.skinID = 12521454;
            crate.name = "RTEvent";
            
            crate.Spawn();
            crate.panelName = "largewoodbox";
            crate.inventory.Clear();
            crate.inventory.ServerInitialize(null, config.dropList.Count);

            mapMarker = (MapMarkerGenericRadius)GameManager.server.CreateEntity("assets/prefabs/tools/map/genericradiusmarker.prefab", pos, new Quaternion());
            mapMarker.enableSaving = false;
            mapMarker.globalBroadcast = true;
            mapMarker.Spawn();
            mapMarker.radius = config.MarkerRadius / 146.3f;
            mapMarker.alpha = 1f;
            UnityEngine.Color color = hexToColor(config.MarkerColor);
            UnityEngine.Color color2 = new UnityEngine.Color(0, 0, 0, 0);
            mapMarker.color1 = color;
            mapMarker.color2 = color2;
            mapMarker.SendUpdate();
             
            timer.In(1f, () =>
            {
                foreach (var item in config.dropList)
                {
                    var amount = UnityEngine.Random.Range(item.AmountMin, item.AmountMax + 1);
                    var it = ItemManager.CreateByName(item.ShortName, amount, item.SkinID);
                    if (!string.IsNullOrEmpty(item.CustomName))
                        it.name = item.CustomName;

                    it.MoveToContainer(crate.inventory);
                }
                crate.SetFlag(BaseEntity.Flags.Locked, true);
                lockedTime = (int)Math.Ceiling(config.OpenTime * 60);
                downTimer = timer.Every(1f, TimerDown);
                PrintToChat(config.StartMessage);
                //BasePlayer player = BasePlayer.activePlayerList.ToList();
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                MainUi(player);
                crate.SendNetworkUpdate();
            });
        }
        Timer destroyCrate;
        Timer downTimer;
        int lockedTime = 0;
        void TimerDown()
        {
            lockedTime--;
            if (lockedTime <= 0)
            {
                PrintToChat(config.UnlockMessage.Replace("{rt}", RtName));

                crate.SetFlag(BaseEntity.Flags.Locked, false);
                downTimer?.Destroy();
            } 
        }
        
        
        object CanLootEntity(BasePlayer player, StorageContainer container)
        {
            if (container == crate && container.HasFlag(BaseEntity.Flags.Locked))
            {
                SendReply(player, $"ОГРОМНЫЙ ящик закрыт! Он откроется через: {TimeSpan.FromSeconds(lockedTime).ToShortString()}");
                return null;
            }
            if (container == crate && !container.HasFlag(BaseEntity.Flags.Reserved10))
            {
                PrintToChat(config.OpenMessage.Replace("{rt}", RtName).Replace("{player}", player.displayName));
                GameStoresGive(player.UserIDString);
                BasePlayer.allPlayerList.Select(p => NoteUI?.Call("DrawInfoNote", p,
                    $"<color=#8e6874>ОГРОМНЫЙ</color> ящик на {RtName} был залутан игроком <color=#8e6874>{player.displayName}</color>"));
                CuiHelper.DestroyUi(player, "mainui5");
                container.SetFlag(BaseEntity.Flags.Reserved10, true);
            }
            return null;
        }

        [ChatCommand("testui")]
        void testui(BasePlayer player)
        {
            MainUi(player);
        }
        
        [ChatCommand("closeui")]
        void closeui(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "mainui5");
            CuiHelper.DestroyUi(player, mainui);
        }

        void OnLootEntityEnd(BasePlayer player, BaseCombatEntity container)
        {
            if (started && crate != null && container != null && container.GetComponent<StorageContainer>() != null && container.GetComponent<StorageContainer>() == crate)
            {
                var storage = container.GetComponent<StorageContainer>();
                NextTick(() => CheckRespawn(storage));
            }
        } 
         
        private void CheckRespawn(StorageContainer container)
        {
            var isEmpty = container == null || container.inventory?.itemList == null || container.inventory.itemList.Count <= 0;
              
            if (!isEmpty)
            {
                if (destroyCrate != null)
                    destroyCrate?.Destroy();

                destroyCrate = timer.In(config.DeletTime, EventEnd);
                return;
            }
            EventEnd();
             
        }
        void EventEnd()
        {
            PrintWarning($"ИВЕНТ ЗАКОНЧИЛСЯ.");
            started = false;

            if (crate != null && !crate.IsDestroyed)
                crate.Kill();

            if (mapMarker != null && !mapMarker.IsDestroyed)
                mapMarker.Kill();

            destroyCrate?.Destroy();
            downTimer?.Destroy();

            GetNextRestart(EventTimes);
        }

        void GetNextRestart(List<DateTime> DateTimes)
        {
            EventTimes = config.StartTimes.ToList().Select(date => DateTime.Parse(date)).ToList();
            CalcNextRestartDict.Clear();
            var e = DateTimes.GetEnumerator();
            for (var i = 0; e.MoveNext(); i++)
            {
                if (DateTime.Compare(DateTime.Now, e.Current) < 0)
                {
                    CalcNextRestartDict.Add(e.Current, e.Current.Subtract(DateTime.Now));
                }
                if (DateTime.Compare(DateTime.Now, e.Current) > 0)
                {
                    CalcNextRestartDict.Add(e.Current.AddDays(1), e.Current.AddDays(1).Subtract(DateTime.Now));
                }
            }
            NextStart = CalcNextRestartDict.Aggregate((l, r) => l.Value < r.Value ? l : r).Key;
            CalcNextRestartDict.Clear();
            PrintWarning("Следующий старт через " + NextStart.Subtract(DateTime.Now).ToShortString() + " в " + NextStart.ToLongTimeString());
        }

        [ChatCommand("poscrate")]
        void CheckPos(BasePlayer player)
        {
            if (!player.IsAdmin) return;

            var mon = TerrainMeta.Path.Monuments.Find(x => Vector3.Distance(player.transform.position, x.transform.position) < 100);
            string msg = $"{mon.displayPhrase.english} {mon.transform.worldToLocalMatrix.MultiplyPoint(player.transform.position)}\nСообщение дублируется в консоль.";
            SendReply(player, msg);
            Puts(msg);
        }

        public static UnityEngine.Color hexToColor(string hex)
        {
            hex = hex.Replace("0x", "");
            hex = hex.Replace("#", "");
            byte a = 160;
            byte r = byte.Parse(hex.Substring(0, 2), System.Globalization.NumberStyles.HexNumber);
            byte g = byte.Parse(hex.Substring(2, 2), System.Globalization.NumberStyles.HexNumber);
            byte b = byte.Parse(hex.Substring(4, 2), System.Globalization.NumberStyles.HexNumber);
            if (hex.Length == 8)
            {
                a = byte.Parse(hex.Substring(6, 2), System.Globalization.NumberStyles.HexNumber);
            }
            return new Color32(r, g, b, a);
        }
    }
}


// --- End of file: RTEvent.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SkillSystem (1).cs ---
// --- Original Local Path: SkillSystem (1).cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("SkillSystem", "Chibubrik", "1.2.0")]
    class SkillSystem : RustPlugin
    {
        #region Вар
        private string Layer = "Skill_UI";
        private string LayersAlert = "Alerts_UI";

        [PluginReference] private Plugin ImageLibrary;
        #endregion

        #region Класс
        public class SkillSettings
        {
            [JsonProperty("Название панельки")] public string Name;
            [JsonProperty("Информация")] public string Info;
            [JsonProperty("Название предмета")] public string DisplayName;
            [JsonProperty("Используемый предмет Glue")] public string ShortName;
            [JsonProperty("SkinId предмета")] public ulong SkinID;
            [JsonProperty("Шанс выпадения листка в %")] public float DropChance;
        }
        
        public class Settings
        {
            [JsonProperty("Название навыка")] public string DisplayName;
            [JsonProperty("Рейтинг увеличения навыка за уровень")] public float Rate;
            [JsonProperty("Сколько нужно листов с информацией, чтобы прокачать навык")] public int Price;
            [JsonProperty("Максимальный уровень прокачки навыка")] public int LevelMax;
            [JsonProperty("Изображение навыка")] public string Url;
            [JsonProperty("Короткое название предмета, на который будет действовать увеличенный рейтинг навыка")] public Dictionary<string, string> ShortName;
        }
        
        private Dictionary<ulong, Dictionary<string, SettingsData>> settingsData;
        public class SettingsData
        {
            [JsonProperty("Навык")] public int Level;
            [JsonProperty("Рейт")] public float Rate = 1;
        }
        #endregion

        #region Конфиг
        public Configuration config;
        public class Configuration
        {
            [JsonProperty("Настройки")] public SkillSettings skill = new SkillSettings();
            [JsonProperty("Список")] public List<Settings> settings;
            [JsonProperty("Список ящиков")] public List<string> container = new List<string>();
            public static Configuration GetNewCong()
            {
                return new Configuration
                {
                    skill = new SkillSettings()
                    {
                        DisplayName = "Листок с информацией",
                        ShortName = "glue",
                        SkinID = 1835496050,
                        DropChance = 100f
                    },
                    settings = new List<Settings>
                    {
                        new Settings()
                        {
                            DisplayName = "Гайд для лесоруба",
                            Rate = 0.1f,
                            Price = 100,
                            LevelMax = 10,
                            Url = "https://imgur.com/4q8snx9.png",
                            ShortName = new Dictionary<string, string>()
                                                         {
                                ["wood"] = "Дерево"
                            }
                        },                
                        new Settings()
                        {
                            DisplayName = "Дневник шахтера",
                            Rate = 0.1f,
                            Price = 100,
                            LevelMax = 10,
                            Url = "https://imgur.com/Lhyflw5.png",
                            ShortName = new Dictionary<string, string>()
                            {
                                ["stones"] = "Камень"
                            }
                        },        
                        new Settings()
                        {
                            DisplayName = "Добыча металла",
                            Rate = 0.1f,
                            Price = 100,
                            LevelMax = 10,
                            Url = "https://imgur.com/xAepxrq.png",
                            ShortName = new Dictionary<string, string>()
                            {
                                ["metal.ore"] = "Металл"
                            }
                        },   
                        new Settings()
                        {
                            DisplayName = "Серные камни",
                            Rate = 0.1f,
                            Price = 100,
                            LevelMax = 10,
                            Url = "https://imgur.com/6xqLfrQ.png",
                            ShortName = new Dictionary<string, string>()
                            {
                                ["sulfur.ore"] = "Сера"
                            }
                        },  
                        new Settings()
                        {
                            DisplayName = "Снятие шкур",
                            Rate = 0.1f,
                            Price = 100,
                            LevelMax = 10,
                            Url = "https://imgur.com/Nla51R6.png",
                            ShortName = new Dictionary<string, string>()
                            {
                                ["cloth"] = "Ткань"
                            }
                        },  
                        new Settings()
                        {
                            DisplayName = "Поиск предметов",
                            Rate = 0.1f,
                            Price = 100,
                            LevelMax = 10,
                            Url = "https://imgur.com/E46dylP.png",
                            ShortName = new Dictionary<string, string>()
                            {
                                ["Поиск"] = "Не трогать"
                            }
                        },
                    },
                    container = new List<string>()
                    {
                        { "crate_elite" },
                        { "supply_drop" },
                        { "crate_normal_2" }
                    }
                };
            }
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config?.container == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewCong();
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Команды
        [ChatCommand("skill")]
        private void CommandSkill(BasePlayer player)
        {
            SkillUI(player);
        }

        [ConsoleCommand("skill")]
        private void Command(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player != null && args.HasArgs(1))
            {
                if (args.Args[0] == "buy")
                {
                    var check = config.settings.ElementAt(int.Parse(args.Args[1]));
                    var items = player.inventory.GetAmount(ItemManager.FindItemDefinition(config.skill.ShortName).itemid);
                    if (items >= check.Price) {  } else { return; }
                    foreach (var item in check.ShortName)
                    {
                        var skills = AddPlayersData(player.userID, item.Key);
                        if (skills.Level != check.LevelMax)
                        {
                            skills.Rate += check.Rate;
                            skills.Level += 1;
                            AlertUI(player, check.DisplayName);
                            player.inventory.Take(null, ItemManager.FindItemDefinition(config.skill.ShortName).itemid, check.Price);
                            CuiHelper.DestroyUi(player, Layer);
                        }
                        else
                        {
                            SendReply(player, "Вы полностью изучили навык!");
                        }
                    }
                }
                if (args.Args[0] == "give")
                {
                    if (player != null && !player.IsAdmin) return;
                    if (args.Args == null || args.Args.Length < 2)
                    {
                        player.ConsoleMessage("Команда: skill give SteamID количество листков");
                        return;
                    }
                    BasePlayer target = BasePlayer.Find(args.Args[1]);
                    if (target == null)
                    {
                        player.ConsoleMessage($"Игрок {target} не найден");
                        return;
                    }
                    int change;
                    if (!int.TryParse(args.Args[2], out change))
                    {
                        player.ConsoleMessage("Вы не указали кол-во");
                        return;
                    }

                    player.ConsoleMessage($"Игроку {target}, были успешно выданы листки с информацией.\nВ размере: {change}");
                    Item item = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(config.skill.ShortName).itemid, change, config.skill.SkinID);
                    item.name = config.skill.DisplayName;
                    player.inventory.GiveItem(item);
                }
            }
        }
        #endregion

        #region Хуки
        private void Loaded()
        {
            settingsData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, Dictionary<string, SettingsData>>>("SkillSystem/Player");
        }
        
        private SettingsData AddPlayersData(ulong userID, string name)
        {
            if (!settingsData.ContainsKey(userID)) settingsData[userID] = new Dictionary<string, SettingsData>();

            if (!settingsData[userID].ContainsKey(name)) settingsData[userID][name] = new SettingsData();

            return settingsData[userID][name];
        }
        
        private void OnServerInitialized()
        {
            foreach (var check in config.settings)
            {
                ImageLibrary.Call("AddImage", check.Url, check.Url);
            }
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
                SaveData();
            }
        }
        
        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            SaveData();
        }
        
        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("SkillSystem/Player", settingsData);
        }
        
        private void OnDispenserGather(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            var playerData = AddPlayersData(player.userID, item.info.shortname);
            item.amount = (int) (item.amount * playerData.Rate);
        }
        
        private void OnDispenserBonus(ResourceDispenser disp, BasePlayer player, Item item)
        {
            var playerData = AddPlayersData(player.userID, item.info.shortname);
            item.amount = (int) (item.amount * playerData.Rate);
        }

        private void OnLootEntity(BasePlayer player, BaseEntity entity, Item item)
        {
            if (!(entity is LootContainer) || entity.OwnerID != 0)
                return;
            foreach (var check in ((LootContainer) entity).inventory.itemList.Where(p => p.MaxStackable() > 1 && !p.IsBlueprint()))
            {
                var playerData = AddPlayersData(player.userID, "Поиск");
                check.amount = (int) (check.amount * playerData.Rate);
            }
            entity.OwnerID = player.userID;
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (!(info?.Initiator is BasePlayer) || !(entity is LootContainer)) return;
            var inventory = entity.GetComponent<LootContainer>().inventory;
            foreach (var check in inventory.itemList.Where(p => p.MaxStackable() > 1 && !p.IsBlueprint()))
            {
                var playerData = AddPlayersData(info.InitiatorPlayer.userID, "Поиск");
                check.amount = (int) (check.amount * playerData.Rate);
            }
        }
        
        int GetList(BasePlayer player, string type)
        {
            int amount = 0;
            foreach (var item in player.inventory.FindItemIDs(ItemManager.FindItemDefinition(config.skill.ShortName).itemid))
            {
                if (type == "skill")
                {
                    if (item.info.itemid == ItemManager.FindItemDefinition(config.skill.ShortName).itemid)
                    {
                        amount += item.amount;
                    }
                }
            }
            return amount;
        }

        #region Спавн листочков
        private void OnLootSpawn(LootContainer lootContainer)
        {
            if (lootContainer == null) return;
            if (lootContainer.inventory == null) return;
            if (config.container.Contains(lootContainer.ShortPrefabName))
            {
                if (UnityEngine.Random.Range(0, 100) <= config.skill.DropChance)
                {
                    Item add = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(config.skill.ShortName).itemid, 1, config.skill.SkinID);
                    add.name = config.skill.DisplayName;
                    add.MoveToContainer(lootContainer.inventory);
                }
            }
        }

        object OnItemSplit(Item thisI, int split_Amount)
        {
            Item item = null;
            if (thisI.skin == 0uL) return null;
            if (thisI.skin == config.skill.SkinID)
            {
                thisI.amount -= split_Amount; item = ItemManager.CreateByItemID(thisI.info.itemid, split_Amount, thisI.skin);
                if (item != null)
                {
                    item.amount = split_Amount;
                    item.name = thisI.name;
                    item.OnVirginSpawn();
                    if (thisI.IsBlueprint()) item.blueprintTarget = thisI.blueprintTarget;
                    if (thisI.hasCondition) item.condition = thisI.condition;
                    item.MarkDirty();
                    return item;
                }
            }
            return null;
        }

        object CanStackItem(Item item, Item targetItem)
        {
            if (item.info.itemid == ItemManager.FindItemDefinition(config.skill.ShortName).itemid && targetItem.info.itemid == ItemManager.FindItemDefinition(config.skill.ShortName).itemid) if (item.skin == config.skill.SkinID || targetItem.skin == config.skill.SkinID) if (targetItem.skin != item.skin) return false;
            return null;
        }
        #endregion

        #endregion

        #region Интерфейс
        private void SkillUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, Layer);
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.9" },
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "-2 -2", AnchorMax = "2 2", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0.9", Close = Layer },
                Text = { Text = "" }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0.28", AnchorMax = "1 0.325", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0" },
                Text = { Text = $"ЛИСТКОВ С ИНФОРМАЦИЕЙ - {GetList(player, "skill").ToString()}", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-bold.ttf" }
            }, Layer);

            float gap = 0.01f, width = 0.155f, height = 0.4f, startxBox = 0.01f, startyBox = 0.73f - height, xmin = startxBox, ymin = startyBox;
            for (int i = 0; i < config.settings.Count(); i++)
            {
                container.Add(new CuiButton()
                {
                    RectTransform = { AnchorMin = xmin + " " + ymin, AnchorMax = (xmin + width) + " " + (ymin + height * 1), OffsetMax = "0 0" },
                    Button = { Color = "1 1 1 0.1" },
                    Text = { Text = "" }
                }, Layer, $"{i}");
                xmin += width + gap;
                if (xmin + width >= 1)
                {
                    xmin = startxBox;
                    ymin -= height + gap;
                }

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0.21", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0" },
                    Text = { Text = $"", Color = HexToUiColor("#FFFFFF5A"), Align = TextAnchor.UpperCenter, FontSize = 12, Font = "robotocondensed-regular.ttf" }
                }, $"{i}", "Skills");
                
                foreach (var check in config.settings.ElementAt(i).ShortName)
                {
                    var data = AddPlayersData(player.userID, check.Key);
                    var text = config.settings.ElementAt(i).LevelMax <= data.Level ? "ИЗУЧЕНО" : $"УРОВЕНЬ МАСТЕРСТВА {data.Level + "/" + config.settings.ElementAt(i).LevelMax}";
                    var color = config.settings.ElementAt(i).LevelMax <= data.Level ? "1 1 1 1" : $"1 1 1 0.3";
                    var colorbutton = config.settings.ElementAt(i).LevelMax <= data.Level ? "0 0 0 0" : $"0.43 0.81 0.53 0.6";

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0.21", AnchorMax = "1 1", OffsetMax = "0 0" },
                        Button = { Color = "0 0 0 0" },
                        Text = { Text = "" }
                    }, $"{i}", "Images");

                    container.Add(new CuiElement
                    {
                        Parent = $"Images",
                        Components =
                        {
                            new CuiRawImageComponent {Png = (string) ImageLibrary.Call("GetImage", config.settings.ElementAt(i).Url), Color = color},
                            new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "3 5", OffsetMax = "-3 -5"}
                        }
                    });

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.03 0.1", AnchorMax = "0.4 0.2", OffsetMax = "0 0" },
                        Button = { Color = "1 1 1 0.1" },
                        Text = { Text = $"Цена: {config.settings.ElementAt(i).Price}", Color = HexToUiColor("#FFFFFF5A"), Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-regular.ttf" }
                    }, $"{i}");

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.415 0.1", AnchorMax = "0.97 0.2", OffsetMax = "0 0" },
                        Button = { Color = "0.43 0.81 0.53 0.6", Command = $"skill buy {i}" },
                        Text = { Text = "ИЗУЧИТЬ", Color = HexToUiColor("#FFFFFF5A"), Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-bold.ttf" }
                    }, $"{i}");

                    container.Add(new CuiButton
                    {
                        RectTransform = {AnchorMin = "0.03 0.025", AnchorMax = "0.97 0.09", OffsetMax = "0 0"},
                        Button = {Color = "1 1 1 0.1"},
                        Text = {Text = ""}
                    }, $"{i}", "Progress");
                    
                    container.Add(new CuiButton
                    {
                        RectTransform = {AnchorMin = "0 0", AnchorMax = $"{(float) data.Level / config.settings.ElementAt(i).LevelMax} 1", OffsetMax = "0 0"},
                        Button = {Color = colorbutton },
                        Text = {Text = ""}
                    }, "Progress");

                    container.Add(new CuiButton
                    {
                        RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0"},
                        Button = {Color = "0 0 0 0"},
                        Text = {Text = text, Color = HexToUiColor("#FFFFFF5A"), Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-regular.ttf"}
                    }, "Progress");
                }
            }

            CuiHelper.AddUi(player, container);
        }

        private void AlertUI(BasePlayer player, string DisplayName)
        {
            CuiHelper.DestroyUi(player, LayersAlert);
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-400 180", OffsetMax = "400 280" },
                Image = { Color = "0 0 0 0" },
            }, "Hud", LayersAlert);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0" },
                Text = { Text = $"<color=#FFFFFF9A><size=20><b>НАВЫКИ</b></size>\nВы изучили навык: <b>{DisplayName.ToUpper()}</b></color>\nОткрыть меню <b>скилов</b> можно прописав команду <b>/skill</b>", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-regular.ttf" }
            }, LayersAlert);

            CuiHelper.AddUi(player, container);
            timer.Once(10, () => { CuiHelper.DestroyUi(player, LayersAlert); });
        }
        #endregion

        #region Хелпер
        private static string HexToUiColor(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }
        #endregion
    }
}

// --- End of file: SkillSystem (1).cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/VikingBoat.cs ---
// --- Original Local Path: VikingBoat.cs ---

using System;
using System.Linq;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Configuration;
using Rust;
using Network;
using System.Runtime.CompilerServices;
using System.Collections.Generic;
using Facepunch;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("VikingBoat", "Colon Blow", "1.0.7")]
    class VikingBoat : RustPlugin
    {

        #region Data

        BaseEntity newVikingBoat;
        static Dictionary<ulong, string> hasVikingBoat = new Dictionary<ulong, string>();

        static List<uint> storedVikingBoats = new List<uint>();
        private DynamicConfigFile data;
        private bool initialized;

        void Loaded()
        {
            LoadVariables();
            permission.RegisterPermission("vikingBoat.builder", this);
            lang.RegisterMessages(Messages, this);
            data = Interface.Oxide.DataFileSystem.GetFile("VikingBoat_data");
        }

        private void OnServerInitialized()
        {
            initialized = true;
            LoadData();
            timer.In(3, RestoreVikingBoats);
        }
        private void OnServerSave()
        {
            SaveData();
        }

        private void RestoreVikingBoats()
        {
            if (storedVikingBoats.Count > 0)
            {
                BaseEntity[] objects = BaseEntity.saveList.Where(x => x is BaseEntity).ToArray();
                if (objects != null)
                {
                    foreach (var obj in objects)
                    {
                        if (!obj.IsValid() || obj.IsDestroyed)
                            continue;

                        if (storedVikingBoats.Contains(obj.net.ID))
                        {
                            var spawnpos = obj.transform.position;
                            var spawnrot = obj.transform.rotation;
                            var userid = obj.OwnerID;
                            string codestr = "0";
                            string guestcodestr = "0";
                            foreach (Transform child in obj.GetComponent<Transform>())
                            {
                                if (child.name.Contains("keypad/lock.code"))
                                {
                                    CodeLock codelock = child.GetComponent<CodeLock>() ?? null;
                                    if (codelock != null) codestr = codelock.code;
                                    if (codelock != null) guestcodestr = codelock.guestCode;
                                }
                            }

                            storedVikingBoats.Remove(obj.net.ID);
                            obj.Invoke("KillMessage", 0.1f);
                            timer.Once(3f, () => RespawnVikingBoat(spawnpos, spawnrot, userid, codestr, guestcodestr));
                        }
                    }
                }
            }
        }

        void SaveData() => data.WriteObject(storedVikingBoats.ToList());
        void LoadData()
        {
            try
            {
                storedVikingBoats = data.ReadObject<List<uint>>();
            }
            catch
            {
                storedVikingBoats = new List<uint>();
            }
        }

        bool isAllowed(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);

        public void AddPlayerVikingBoat(ulong id)
        {
            if (!OnlyOneActiveVikingBoat) return;
            if (hasVikingBoat.ContainsKey(id)) return;
            hasVikingBoat.Add(id, "");
        }

        public void RemovePlayerVikingBoat(ulong id)
        {
            if (!OnlyOneActiveVikingBoat) return;
            if (!hasVikingBoat.ContainsKey(id)) return;
            hasVikingBoat.Remove(id);
        }

        #endregion

        #region Hooks

        public void BuildVikingBoat(BasePlayer player)
        {
            string prefabstr = "assets/prefabs/deployable/chair/chair.deployed.prefab";
            var waterheight = TerrainMeta.WaterMap.GetHeight(player.transform.position);
            var spawnpos = new Vector3(player.transform.position.x, waterheight, player.transform.position.z);
            newVikingBoat = GameManager.server.CreateEntity(prefabstr, spawnpos, new Quaternion(), true);
            var mount = newVikingBoat.GetComponent<BaseMountable>();
            mount.isMobile = true;
            newVikingBoat.enableSaving = true;
            newVikingBoat.OwnerID = player.userID;
            newVikingBoat?.Spawn();
            var addVikingBoat = newVikingBoat.gameObject.AddComponent<VikingBoatEntity>();
            AddPlayerVikingBoat(player.userID);
            storedVikingBoats.Add(newVikingBoat.net.ID);
            mount.MountPlayer(player);
            SaveData();
        }

        public void RespawnVikingBoat(Vector3 spawnpos, Quaternion spawnrot, ulong userid, string codestr, string guestcodestr)
        {
            string prefabstr = "assets/prefabs/deployable/chair/chair.deployed.prefab";
            newVikingBoat = GameManager.server.CreateEntity(prefabstr, spawnpos, spawnrot, true);
            var mount = newVikingBoat.GetComponent<BaseMountable>();
            mount.isMobile = true;
            newVikingBoat.enableSaving = true;
            newVikingBoat.OwnerID = userid;
            newVikingBoat?.Spawn();
            var addVikingBoat = newVikingBoat.gameObject.AddComponent<VikingBoatEntity>();
            if (codestr != "0")
            {
                var codelock = addVikingBoat.boatlock.GetComponent<CodeLock>() ?? null;
                if (codelock != null)
                {
                    codelock.whitelistPlayers.Add(userid);
                    codelock.code = codestr;
                    codelock.guestCode = guestcodestr;
                    codelock.SetFlag(BaseEntity.Flags.Locked, true, false);
                }
            }
            AddPlayerVikingBoat(userid);
            storedVikingBoats.Add(newVikingBoat.net.ID);
            SaveData();
        }

        bool CheckUpgradeMats(BasePlayer player, int itemID, int amount, string str)
        {
            int HasReq = player.inventory.GetAmount(itemID);
            if (HasReq >= amount)
            {
                player.inventory.Take(null, itemID, amount);
                player.Command("note.inv", itemID, -amount);
                return true;
            }
            ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemID);

            SendReply(player, "You need " + amount + " " + itemDefinition.shortname + " to build " + str);
            return false;
        }

        public bool IsStandingInWater(BasePlayer player)
        {
            var position = player.transform.position;
            var waterdepth = (TerrainMeta.WaterMap.GetHeight(position) - TerrainMeta.HeightMap.GetHeight(position));
            if (waterdepth >= 0.6f) return true;
            return false;
        }

        private void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (!player.isMounted) return;
            var activeVikingBoat = player.GetMounted().GetComponentInParent<VikingBoatEntity>() ?? null;
            if (activeVikingBoat == null) return;
            if (player.GetMounted() != activeVikingBoat.entity) return;
            if (!isAllowed(player, "vikingBoat.builder")) return;
            if (activeVikingBoat.boatlock.IsLocked() == true) return;
            if (input != null)
            {
                if (input.WasJustPressed(BUTTON.FORWARD)) { activeVikingBoat.moveforward = true; }
                if (input.WasJustReleased(BUTTON.FORWARD)) activeVikingBoat.moveforward = false;
                if (input.WasJustPressed(BUTTON.BACKWARD)) { activeVikingBoat.movebackward = true; }
                if (input.WasJustReleased(BUTTON.BACKWARD)) activeVikingBoat.movebackward = false;
                if (input.WasJustPressed(BUTTON.RIGHT)) activeVikingBoat.rotright = true;
                if (input.WasJustReleased(BUTTON.RIGHT)) activeVikingBoat.rotright = false;
                if (input.WasJustPressed(BUTTON.LEFT)) activeVikingBoat.rotleft = true;
                if (input.WasJustReleased(BUTTON.LEFT)) activeVikingBoat.rotleft = false;
                if (input.WasJustPressed(BUTTON.JUMP))
                {
                    activeVikingBoat.moveforward = false;
                    activeVikingBoat.movebackward = false;
                    activeVikingBoat.rotright = false;
                    activeVikingBoat.rotleft = false;
                }
                return;
            }
        }

        private object OnEntityGroundMissing(BaseEntity entity)
        {
            var VikingBoat = entity.GetComponentInParent<VikingBoatEntity>();
            if (VikingBoat != null) return false;
            return null;
        }

        private void OnEntityKill(BaseNetworkable networkable)
        {
            var VikingBoat = networkable.GetComponentInParent<VikingBoatEntity>();
            if (VikingBoat != null && storedVikingBoats.Contains(networkable.net.ID))
            {
                storedVikingBoats.Remove(networkable.net.ID);
                SaveData();
            }
        }

        private void OnEntityMounted(BaseMountable mountable, BasePlayer player)
        {
            if (mountable == null || player == null) return;
            var VikingBoatentity = mountable.GetComponentInParent<VikingBoatEntity>();
            if (VikingBoatentity == null) return;
            if (mountable != VikingBoatentity.entity) return;
            if (VikingBoatentity != null && VikingBoatentity.player == null)
            {
                SendReply(player, msg("captain", player.UserIDString));
            }
        }

        private object OnEntityTakeDamage(BaseCombatEntity entity1, HitInfo hitInfo)
        {
            if (entity1 == null || hitInfo == null) return null;
            var isboat = entity1.GetComponentInParent<VikingBoatEntity>();
            if (isboat)
            {
                if (entity1 == isboat.entity) return false;
                if (BlockDecay && hitInfo.damageTypes.GetMajorityDamageType().ToString().Contains("Decay")) return false;
            }
            return null;
        }

        private object CanPickupEntity(BaseCombatEntity entity, BasePlayer player)
        {
            if (entity == null || player == null) return null;
            if (entity.GetComponentInParent<VikingBoatEntity>()) return false;
            return null;
        }

        object CanPickupLock(BasePlayer player, BaseLock baseLock)
        {
            if (baseLock == null || player == null) return null;
            if (baseLock.GetComponentInParent<VikingBoatEntity>()) return false;
            return null;
        }

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (player.isMounted)
                {
                    var activeVikingBoat = player.GetMounted().GetComponentInParent<VikingBoatEntity>();
                    if (activeVikingBoat != null) player.DismountObject();
                }
            }
        }

        void DestroyAll<T>()
        {
            var objects = GameObject.FindObjectsOfType(typeof(T));
            if (objects != null)
                foreach (var gameObj in objects)
                    GameObject.Destroy(gameObj);
        }

        #endregion

        #region Commands

        [ChatCommand("vikingboat.build")]
        void cmdVikingBoatBuild(BasePlayer player, string command, string[] args)
        {
            if (OnlyOneActiveVikingBoat && hasVikingBoat.ContainsKey(player.userID)) { SendReply(player, msg("hasVikingBoatalready", player.UserIDString)); return; }
            if (!isAllowed(player, "vikingBoat.builder")) { SendReply(player, msg("notauthorized", player.UserIDString)); return; }
            if (!IsStandingInWater(player) || player.IsSwimming()) { SendReply(player, msg("notstandingwater", player.UserIDString)); return; }
            if (player.isMounted) return;
            if (CheckUpgradeMats(player, MaterialID, MaterialsForVikingBoat, "Base VikingBoat")) BuildVikingBoat(player);
        }

        [ConsoleCommand("vikingboat.build")]
        void cmdConsoleVikingBoatBuild(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (OnlyOneActiveVikingBoat && hasVikingBoat.ContainsKey(player.userID)) { SendReply(player, msg("hasVikingBoatalready", player.UserIDString)); return; }
            if (!isAllowed(player, "vikingBoat.builder")) { SendReply(player, msg("notauthorized", player.UserIDString)); return; }
            if (!IsStandingInWater(player) || player.IsSwimming()) { SendReply(player, msg("notstandingwater", player.UserIDString)); return; }
            if (player.isMounted) return;
            if (CheckUpgradeMats(player, MaterialID, MaterialsForVikingBoat, "Base VikingBoat")) BuildVikingBoat(player);
        }

        [ChatCommand("vikingboat.loc")]
        void cmdVikingBoatLoc(BasePlayer player, string command, string[] args)
        {
            if (!isAllowed(player, "vikingBoat.builder")) { SendReply(player, msg("notauthorized", player.UserIDString)); return; }
            string location = player.transform.position.x + " / " + player.transform.position.z;
            SendReply(player, "you position is : " + location);
        }

        [ConsoleCommand("vikingboat.loc")]
        void cmdConsoleVikingBoatLoc(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (!isAllowed(player, "vikingBoat.builder")) { SendReply(player, msg("notauthorized", player.UserIDString)); return; }
            string location = player.transform.position.x + " / " + player.transform.position.z;
            SendReply(player, "you position is : " + location);
        }

        [ChatCommand("vikingboat.destroy")]
        void cmdVikingBoatDestroy(BasePlayer player, string command, string[] args)
        {
            BaseEntity[] objects = BaseEntity.saveList.Where(x => x is BaseEntity).ToArray();
            if (objects != null)
            {
                foreach (var obj in objects)
                {
                    if (!obj.IsValid() || obj.IsDestroyed)
                        continue;

                    var isvikingboat = obj.GetComponent<VikingBoatEntity>();
                    if (isvikingboat && obj.OwnerID == player.userID)
                    {
                        storedVikingBoats.Remove(obj.net.ID);
                        SaveData();
                        isvikingboat.entity.Invoke("KillMessage", 0.1f);
                    }
                }
            }
        }

        #endregion

        #region VikingBoat Entity

        public class VikingBoatEntity : BaseEntity
        {
            VikingBoat VikingBoat;
            public BaseEntity entity;
            BaseEntity nosepoint;
            BaseEntity trianglefloor1;
            BaseEntity trianglefloor2;
            BaseEntity floor1;
            BaseEntity floor2;
            BaseEntity floor3;
            BaseEntity floor4;
            BaseEntity floor5;
            BaseEntity wall1;
            BaseEntity wall2;
            BaseEntity wall3;
            BaseEntity wall1r;
            BaseEntity wall2r;
            BaseEntity wall3r;
            BaseEntity wall4;
            BaseEntity wall4r;
            BaseEntity wall5;
            BaseEntity wall5r;
            BaseEntity wallback;
            BaseEntity wallfrontl;
            BaseEntity wallfrontr;
            BaseEntity chairleft1;
            BaseEntity chairleft2;
            BaseEntity chairleft3;
            BaseEntity chairleft4;
            BaseEntity chairleft5;
            BaseEntity chairright2;
            BaseEntity chairright3;
            BaseEntity chairright4;
            BaseEntity chairright5;
            BaseEntity sailfront;
            BaseEntity sailback;
            BaseEntity oarright1;
            BaseEntity oarright2;
            BaseEntity oarright3;
            BaseEntity oarright4;
            BaseEntity oarright5;
            BaseEntity oarleft1;
            BaseEntity oarleft2;
            BaseEntity oarleft3;
            BaseEntity oarleft4;
            BaseEntity oarleft5;
            BaseEntity oarcenter1;
            BaseEntity oarcenter2;
            BaseEntity oarcenter3;
            BaseEntity oarcenter4;
            BaseEntity oarcenter5;
            BaseEntity rudder;
            public BaseEntity boatlock;

            Vector3 entitypos;
            Quaternion entityrot;
            public BasePlayer player;
            ulong ownerid;
            int counter;
            public bool ismoving;
            public bool moveforward;
            public bool movebackward;
            public bool rotright;
            public bool rotleft;
            float waterheight;
            Vector3 movedirection;
            Vector3 rotdirection;
            Vector3 startloc;
            Vector3 startrot;
            Vector3 endloc;
            float steps;
            float incrementor;

            void Awake()
            {
                entity = GetComponent<BaseEntity>();
                entitypos = entity.transform.position;
                entityrot = Quaternion.identity;
                ownerid = entity.OwnerID;
                VikingBoat = new VikingBoat();
                counter = 0;
                incrementor = 0;
                ismoving = false;
                moveforward = false;
                movebackward = false;
                rotright = false;
                rotleft = false;
                startrot = entity.transform.eulerAngles;
                startloc = entity.transform.position;
                steps = DefaultVikingBoatMovementSpeed;

                SpawnVikingBoat();
                SpawnLock();
                SpawnSideWalls();
                SpawnSails();
                SpawnOars();
                SpawnPassengerChairs();
                RefreshAll();
            }

            void SpawnVikingBoat()
            {

                string testfloor = "assets/prefabs/building core/floor/floor.prefab";
                string testtrianglefloor = "assets/prefabs/building core/floor.triangle/floor.triangle.prefab";
                string prefabpillar = "assets/prefabs/deployable/signs/sign.post.single.prefab";
                string prefabskull = "assets/prefabs/misc/skull/skull.prefab";

                nosepoint = GameManager.server.CreateEntity(prefabpillar, entitypos, entityrot, false);
                nosepoint.transform.localEulerAngles = new Vector3(0, 270, 270);
                nosepoint.transform.localPosition = new Vector3(-1f, 0.9f, 2f);
                nosepoint?.Spawn();
                nosepoint.SetParent(entity);
                SpawnRefresh(nosepoint);

                trianglefloor1 = GameManager.server.CreateEntity(testtrianglefloor, entitypos, entityrot, false);
                trianglefloor1.transform.localEulerAngles = new Vector3(0, 0, 0);
                trianglefloor1.transform.localPosition = new Vector3(-1f, 0f, 1.5f);
                trianglefloor1?.Spawn();
                trianglefloor1.SetParent(entity);
                SpawnRefresh(trianglefloor1);

                trianglefloor2 = GameManager.server.CreateEntity(testtrianglefloor, entitypos, entityrot, false);
                trianglefloor2.transform.localEulerAngles = new Vector3(0, 0, 0);
                trianglefloor2.transform.localPosition = new Vector3(-1f, 0.9f, 1.5f);
                trianglefloor2?.Spawn();
                trianglefloor2.SetParent(entity);
                SpawnRefresh(trianglefloor2);

                floor1 = GameManager.server.CreateEntity(testfloor, entitypos, entityrot, false);
                floor1.transform.localEulerAngles = new Vector3(0, 0, 0);
                floor1.transform.localPosition = new Vector3(-1f, 0f, 0f);
                floor1?.Spawn();
                floor1.SetParent(entity);
                SpawnRefresh(floor1);

                floor2 = GameManager.server.CreateEntity(testfloor, entitypos, entityrot, false);
                floor2.transform.localEulerAngles = new Vector3(0, 90, 0);
                floor2.transform.localPosition = new Vector3(-1f, 0f, -3f);
                floor2?.Spawn();
                floor2.SetParent(entity);
                SpawnRefresh(floor2);

                floor3 = GameManager.server.CreateEntity(testfloor, entitypos, entityrot, false);
                floor3.transform.localEulerAngles = new Vector3(0, 90, 0);
                floor3.transform.localPosition = new Vector3(-1f, 0f, -6f);
                floor3?.Spawn();
                floor3.SetParent(entity);
                SpawnRefresh(floor3);

                floor4 = GameManager.server.CreateEntity(testfloor, entitypos, entityrot, false);
                floor4.transform.localEulerAngles = new Vector3(0, 90, 0);
                floor4.transform.localPosition = new Vector3(-1f, 0f, -9f);
                floor4?.Spawn();
                floor4.SetParent(entity);
                SpawnRefresh(floor4);

                floor5 = GameManager.server.CreateEntity(testfloor, entitypos, entityrot, false);
                floor5.transform.localEulerAngles = new Vector3(0, 90, 0);
                floor5.transform.localPosition = new Vector3(-1f, 0f, -12f);
                floor5?.Spawn();
                floor5.SetParent(entity);
                SpawnRefresh(floor5);
            }

            void SpawnLock()
            {
                string copterlockprefab = "assets/prefabs/locks/keypad/lock.code.prefab";

                boatlock = GameManager.server.CreateEntity(copterlockprefab, entitypos, entityrot, true);
                boatlock.transform.localEulerAngles = new Vector3(0, 0, 0);
                boatlock.transform.localPosition = new Vector3(0.4f, 0.8f, 1.2f);
                boatlock.OwnerID = ownerid;
                boatlock?.Spawn();
                boatlock.SetParent(entity, 0);
            }

            public void SpawnSideWalls()
            {
                string prefabtop = "assets/prefabs/building core/wall.low/wall.low.prefab";
                string prefabfloor = "assets/prefabs/building core/floor/floor.prefab";
                string prefabrudder = "assets/prefabs/deployable/signs/sign.post.single.prefab";

                wallfrontl = GameManager.server.CreateEntity(prefabtop, entitypos, entityrot, false);
                wallfrontl.transform.localEulerAngles = new Vector3(0, -30, 0);
                wallfrontl.transform.localPosition = new Vector3(-0.25f, 0f, 2.8f);
                wallfrontl?.Spawn();
                wallfrontl.SetParent(entity);
                SpawnRefresh(wallfrontl);

                wallfrontr = GameManager.server.CreateEntity(prefabtop, entitypos, entityrot, false);
                wallfrontr.transform.localEulerAngles = new Vector3(0, 210, 0);
                wallfrontr.transform.localPosition = new Vector3(-1.75f, 0f, 2.8f);
                wallfrontr?.Spawn();
                wallfrontr.SetParent(entity);
                SpawnRefresh(wallfrontr);

                wall1 = GameManager.server.CreateEntity(prefabtop, entitypos, entityrot, false);
                wall1.transform.localEulerAngles = new Vector3(0, 180, 0);
                wall1.transform.localPosition = new Vector3(-2.5f, 0f, 0f);
                wall1?.Spawn();
                wall1.SetParent(entity);
                SpawnRefresh(wall1);

                wall1r = GameManager.server.CreateEntity(prefabtop, entitypos, entityrot, false);
                wall1r.transform.localEulerAngles = new Vector3(0, 0, 0);
                wall1r.transform.localPosition = new Vector3(0.5f, 0f, 0f);
                wall1r?.Spawn();
                wall1r.SetParent(entity);
                SpawnRefresh(wall1r);

                wall2 = GameManager.server.CreateEntity(prefabtop, entitypos, entityrot, false);
                wall2.transform.localEulerAngles = new Vector3(0, 180, 0);
                wall2.transform.localPosition = new Vector3(-2.5f, 0f, -3f);
                wall2?.Spawn();
                wall2.SetParent(entity);
                SpawnRefresh(wall2);

                wall2r = GameManager.server.CreateEntity(prefabtop, entitypos, entityrot, false);
                wall2r.transform.localEulerAngles = new Vector3(0, 0, 0);
                wall2r.transform.localPosition = new Vector3(0.5f, 0f, -3f);
                wall2r?.Spawn();
                wall2r.SetParent(entity);
                SpawnRefresh(wall2r);

                wall3 = GameManager.server.CreateEntity(prefabtop, entitypos, entityrot, false);
                wall3.transform.localEulerAngles = new Vector3(0, 180, 0);
                wall3.transform.localPosition = new Vector3(-2.5f, 0f, -6f);
                wall3?.Spawn();
                wall3.SetParent(entity);
                SpawnRefresh(wall3);

                wall3r = GameManager.server.CreateEntity(prefabtop, entitypos, entityrot, false);
                wall3r.transform.localEulerAngles = new Vector3(0, 0, 0);
                wall3r.transform.localPosition = new Vector3(0.5f, 0f, -6f);
                wall3r?.Spawn();
                wall3r.SetParent(entity);
                SpawnRefresh(wall3r);

                wall4 = GameManager.server.CreateEntity(prefabtop, entitypos, entityrot, false);
                wall4.transform.localEulerAngles = new Vector3(0, 180, 0);
                wall4.transform.localPosition = new Vector3(-2.5f, 0f, -9f);
                wall4?.Spawn();
                wall4.SetParent(entity);
                SpawnRefresh(wall4);

                wall4r = GameManager.server.CreateEntity(prefabtop, entitypos, entityrot, false);
                wall4r.transform.localEulerAngles = new Vector3(0, 0, 0);
                wall4r.transform.localPosition = new Vector3(0.5f, 0f, -9f);
                wall4r?.Spawn();
                wall4r.SetParent(entity);
                SpawnRefresh(wall4r);

                wall5 = GameManager.server.CreateEntity(prefabtop, entitypos, entityrot, false);
                wall5.transform.localEulerAngles = new Vector3(0, 180, 0);
                wall5.transform.localPosition = new Vector3(-2.5f, 0f, -12f);
                wall5?.Spawn();
                wall5.SetParent(entity);
                SpawnRefresh(wall5);

                wall5r = GameManager.server.CreateEntity(prefabtop, entitypos, entityrot, false);
                wall5r.transform.localEulerAngles = new Vector3(0, 0, 0);
                wall5r.transform.localPosition = new Vector3(0.5f, 0f, -12f);
                wall5r?.Spawn();
                wall5r.SetParent(entity);
                SpawnRefresh(wall5r);

                wallback = GameManager.server.CreateEntity(prefabtop, entitypos, entityrot, false);
                wallback.transform.localEulerAngles = new Vector3(0, 90, 0);
                wallback.transform.localPosition = new Vector3(-1f, 0f, -13.5f);
                wallback?.Spawn();
                wallback.SetParent(entity);
                SpawnRefresh(wallback);

                rudder = GameManager.server.CreateEntity(prefabrudder, entitypos, entityrot, false);
                rudder.transform.localEulerAngles = new Vector3(0, 270, 130);
                rudder.transform.localPosition = new Vector3(-1f, 0.9f, -13f);
                var rudderstab = rudder.GetComponent<StabilityEntity>();
                if (rudderstab) rudderstab.grounded = true;
                rudder?.Spawn();
                rudder.SetParent(entity);
                SpawnRefresh(rudder);

            }

            void SpawnOars()
            {
                string prefabpillar = "assets/prefabs/deployable/signs/sign.post.single.prefab";

                oarright1 = GameManager.server.CreateEntity(prefabpillar, entitypos, entityrot, true);
                oarright1.transform.localEulerAngles = new Vector3(0, 0, 240);
                oarright1.transform.localPosition = new Vector3(0.5f, 0.75f, 0.7f);
                oarright1?.Spawn();
                oarright1.SetParent(entity);
                SpawnRefresh(oarright1);

                oarright2 = GameManager.server.CreateEntity(prefabpillar, entitypos, entityrot, true);
                oarright2.transform.localEulerAngles = new Vector3(0, 0, 240);
                oarright2.transform.localPosition = new Vector3(0.5f, 0.75f, -2.3f);
                oarright2?.Spawn();
                oarright2.SetParent(entity);
                SpawnRefresh(oarright2);

                oarright3 = GameManager.server.CreateEntity(prefabpillar, entitypos, entityrot, true);
                oarright3.transform.localEulerAngles = new Vector3(0, 0, 240);
                oarright3.transform.localPosition = new Vector3(0.5f, 0.75f, -5.3f);
                oarright3?.Spawn();
                oarright3.SetParent(entity);
                SpawnRefresh(oarright3);

                oarright4 = GameManager.server.CreateEntity(prefabpillar, entitypos, entityrot, true);
                oarright4.transform.localEulerAngles = new Vector3(0, 0, 240);
                oarright4.transform.localPosition = new Vector3(0.5f, 0.75f, -8.3f);
                oarright4?.Spawn();
                oarright4.SetParent(entity);
                SpawnRefresh(oarright4);

                oarright5 = GameManager.server.CreateEntity(prefabpillar, entitypos, entityrot, true);
                oarright5.transform.localEulerAngles = new Vector3(0, 0, 240);
                oarright5.transform.localPosition = new Vector3(0.5f, 0.75f, -11.3f);
                oarright5?.Spawn();
                oarright5.SetParent(entity);
                SpawnRefresh(oarright5);

                oarleft1 = GameManager.server.CreateEntity(prefabpillar, entitypos, entityrot, true);
                oarleft1.transform.localEulerAngles = new Vector3(0, 0, 120);
                oarleft1.transform.localPosition = new Vector3(-2.5f, 0.75f, 0.7f);
                oarleft1?.Spawn();
                oarleft1.SetParent(entity);
                SpawnRefresh(oarleft1);

                oarleft2 = GameManager.server.CreateEntity(prefabpillar, entitypos, entityrot, true);
                oarleft2.transform.localEulerAngles = new Vector3(0, 0, 120);
                oarleft2.transform.localPosition = new Vector3(-2.5f, 0.75f, -2.3f);
                oarleft2?.Spawn();
                oarleft2.SetParent(entity);
                SpawnRefresh(oarleft2);

                oarleft3 = GameManager.server.CreateEntity(prefabpillar, entitypos, entityrot, true);
                oarleft3.transform.localEulerAngles = new Vector3(0, 0, 120);
                oarleft3.transform.localPosition = new Vector3(-2.5f, 0.75f, -5.3f);
                oarleft3?.Spawn();
                oarleft3.SetParent(entity);
                SpawnRefresh(oarleft3);

                oarleft4 = GameManager.server.CreateEntity(prefabpillar, entitypos, entityrot, true);
                oarleft4.transform.localEulerAngles = new Vector3(0, 0, 120);
                oarleft4.transform.localPosition = new Vector3(-2.5f, 0.75f, -8.3f);
                oarleft4?.Spawn();
                oarleft4.SetParent(entity);
                SpawnRefresh(oarleft4);

                oarleft5 = GameManager.server.CreateEntity(prefabpillar, entitypos, entityrot, true);
                oarleft5.transform.localEulerAngles = new Vector3(0, 0, 120);
                oarleft5.transform.localPosition = new Vector3(-2.5f, 0.75f, -11.3f);
                oarleft5?.Spawn();
                oarleft5.SetParent(entity);
                SpawnRefresh(oarleft5);
            }

            void SpawnSails()
            {
                string prefabsail = "assets/prefabs/deployable/signs/sign.pole.banner.large.prefab";

                sailfront = GameManager.server.CreateEntity(prefabsail, entitypos, entityrot, true);
                sailfront.transform.localEulerAngles = new Vector3(0, 0, 0);
                sailfront.transform.localPosition = new Vector3(-1f, 0f, -2f);
                sailfront?.Spawn();
                sailfront.SetParent(entity);
                SpawnRefresh(sailfront);

                sailback = GameManager.server.CreateEntity(prefabsail, entitypos, entityrot, true);
                sailback.transform.localEulerAngles = new Vector3(0, 0, 0);
                sailback.transform.localPosition = new Vector3(-1f, 0f, -9f);
                sailback?.Spawn();
                sailback.SetParent(entity);
                SpawnRefresh(sailback);
            }

            public void SpawnPassengerChairs()
            {
                string prefabchair = "assets/prefabs/deployable/chair/chair.deployed.prefab";

                chairleft1 = GameManager.server.CreateEntity(prefabchair, entitypos, entityrot, true);
                chairleft1.transform.localEulerAngles = new Vector3(0, 0, 0);
                chairleft1.transform.localPosition = new Vector3(-2f, 0f, 0f);
                chairleft1?.Spawn();
                chairleft1.SetParent(entity);
                SpawnRefresh(chairleft1);

                chairleft2 = GameManager.server.CreateEntity(prefabchair, entitypos, entityrot, true);
                chairleft2.transform.localEulerAngles = new Vector3(0, 0, 0);
                chairleft2.transform.localPosition = new Vector3(-2f, 0f, -3);
                chairleft2?.Spawn();
                chairleft2.SetParent(entity);
                SpawnRefresh(chairleft2);

                chairleft3 = GameManager.server.CreateEntity(prefabchair, entitypos, entityrot, true);
                chairleft3.transform.localEulerAngles = new Vector3(0, 0, 0);
                chairleft3.transform.localPosition = new Vector3(-2f, 0f, -6);
                chairleft3?.Spawn();
                chairleft3.SetParent(entity);
                SpawnRefresh(chairleft3);

                chairleft4 = GameManager.server.CreateEntity(prefabchair, entitypos, entityrot, true);
                chairleft4.transform.localEulerAngles = new Vector3(0, 0, 0);
                chairleft4.transform.localPosition = new Vector3(-2f, 0f, -9);
                chairleft4?.Spawn();
                chairleft4.SetParent(entity);
                SpawnRefresh(chairleft4);

                chairleft5 = GameManager.server.CreateEntity(prefabchair, entitypos, entityrot, true);
                chairleft5.transform.localEulerAngles = new Vector3(0, 0, 0);
                chairleft5.transform.localPosition = new Vector3(-2f, 0f, -12);
                chairleft5?.Spawn();
                chairleft5.SetParent(entity);
                SpawnRefresh(chairleft5);

                chairright2 = GameManager.server.CreateEntity(prefabchair, entitypos, entityrot, true);
                chairright2.transform.localEulerAngles = new Vector3(0, 0, 0);
                chairright2.transform.localPosition = new Vector3(0f, 0f, -3);
                chairright2?.Spawn();
                chairright2.SetParent(entity);
                SpawnRefresh(chairright2);

                chairright3 = GameManager.server.CreateEntity(prefabchair, entitypos, entityrot, true);
                chairright3.transform.localEulerAngles = new Vector3(0, 0, 0);
                chairright3.transform.localPosition = new Vector3(0f, 0f, -6);
                chairright3?.Spawn();
                chairright3.SetParent(entity);
                SpawnRefresh(chairright3);

                chairright4 = GameManager.server.CreateEntity(prefabchair, entitypos, entityrot, true);
                chairright4.transform.localEulerAngles = new Vector3(0, 0, 0);
                chairright4.transform.localPosition = new Vector3(0f, 0f, -9);
                chairright4?.Spawn();
                chairright4.SetParent(entity);
                SpawnRefresh(chairright4);

                chairright5 = GameManager.server.CreateEntity(prefabchair, entitypos, entityrot, true);
                chairright5.transform.localEulerAngles = new Vector3(0, 0, 0);
                chairright5.transform.localPosition = new Vector3(0f, 0f, -12);
                chairright5?.Spawn();
                chairright5.SetParent(entity);
                SpawnRefresh(chairright5);

            }

            void SpawnRefresh(BaseNetworkable entity1)
            {
                var hasstab = entity1.GetComponent<StabilityEntity>();
                if (hasstab)
                {
                    hasstab.grounded = true;
                }
                var hasmount = entity1.GetComponent<BaseMountable>();
                if (hasmount)
                {
                    hasmount.isMobile = true;
                }
                var hasblock = entity1.GetComponent<BuildingBlock>();
                if (hasblock)
                {
                    hasblock.SetGrade(BuildingGrade.Enum.Wood);
                    hasblock.SetHealthToMax();
                    hasblock.UpdateSkin();
                    hasblock.ClientRPC(null, "RefreshSkin");
                }
            }

            bool hitSomething(Vector3 position)
            {
                var directioncheck = new Vector3();
                if (moveforward) directioncheck = position + (transform.forward * 4);
                if (movebackward) directioncheck = position - (transform.forward * 8);
                if (GamePhysics.CheckSphere(directioncheck, 1f, UnityEngine.LayerMask.GetMask("World", "Construction", "Default"), 0)) return true;
                return false;
            }

            bool isStillInWater(Vector3 position)
            {
                var waterdepth = (TerrainMeta.WaterMap.GetHeight(position) - TerrainMeta.HeightMap.GetHeight(position));
                if (waterdepth >= 0.5f) return true;
                return false;
            }

            bool PlayerIsMounted()
            {
                bool flag = entity.GetComponent<BaseMountable>().IsMounted();
                return flag;
            }

            void SplashEffect()
            {
                Effect.server.Run("assets/content/vehicles/boats/effects/splashloop.prefab", wall5.transform.position);
                Effect.server.Run("assets/content/vehicles/boats/effects/splashloop.prefab", wall5r.transform.position);
            }

            void CalculateSpeed()
            {
                if (chairleft1.GetComponent<BaseMountable>().IsMounted()) steps = steps + 1;
                if (chairleft2.GetComponent<BaseMountable>().IsMounted()) steps = steps + 1;
                if (chairleft3.GetComponent<BaseMountable>().IsMounted()) steps = steps + 1;
                if (chairleft4.GetComponent<BaseMountable>().IsMounted()) steps = steps + 1;
                if (chairleft5.GetComponent<BaseMountable>().IsMounted()) steps = steps + 1;
                if (entity.GetComponent<BaseMountable>().IsMounted()) steps = steps + 1;
                if (chairright2.GetComponent<BaseMountable>().IsMounted()) steps = steps + 1;
                if (chairright3.GetComponent<BaseMountable>().IsMounted()) steps = steps + 1;
                if (chairright4.GetComponent<BaseMountable>().IsMounted()) steps = steps + 1;
                if (chairright5.GetComponent<BaseMountable>().IsMounted()) steps = steps + 1;
            }

            void FixedUpdate()
            {
                if (!ismoving && !(moveforward || movebackward || rotright || rotleft)) return;
                if (!PlayerIsMounted()) { ResetMovement(); RefreshAll(); ismoving = false; return; }
                var currentloc = entity.transform.position;
                waterheight = TerrainMeta.WaterMap.GetHeight(currentloc);
                startloc = new Vector3(currentloc.x, waterheight, currentloc.z);
                startrot = entity.transform.eulerAngles;
                startrot.x = 0f;
                if (rotright) rotdirection = new Vector3(startrot.x, startrot.y + 1, startrot.z);
                else if (rotleft) rotdirection = new Vector3(startrot.x, startrot.y - 1, startrot.z);
                CalculateSpeed();
                if (moveforward) endloc = startloc + (transform.forward * steps) * Time.deltaTime;
                else if (movebackward) endloc = startloc + (transform.forward * -steps) * Time.deltaTime;

                if (hitSomething(endloc)) { endloc = startloc; ResetMovement(); RefreshAll(); return; }
                if (!isStillInWater(endloc)) { endloc = startloc; ResetMovement(); RefreshAll(); return; }
                if (endloc.x >= 3900 || endloc.x <= -3900 || endloc.z >= 3900 || endloc.z <= -3900) { endloc = startloc; ResetMovement(); RefreshAll(); return; }

                if (endloc == new Vector3(0f, 0f, 0f)) endloc = startloc;

                MoveOars();

                entity.transform.eulerAngles = rotdirection;
                entity.transform.localPosition = endloc;
                if (ShowWaterSplash) SplashEffect();
                RefreshAll();
                steps = DefaultVikingBoatMovementSpeed;
            }

            void MoveOars()
            {
                var rotorpos1r = oarright1.transform.eulerAngles;
                if (rotorpos1r.x >= 80f) rotorpos1r.x = 0f;
                oarright1.transform.eulerAngles = new Vector3(rotorpos1r.x + 5f, rotorpos1r.y, rotorpos1r.z);

                var rotorpos1l = oarleft1.transform.eulerAngles;
                if (rotorpos1l.x >= 80f) rotorpos1l.x = 0f;
                oarleft1.transform.eulerAngles = new Vector3(rotorpos1l.x + 5f, rotorpos1l.y, rotorpos1l.z);

                var rotorpos2r = oarright2.transform.eulerAngles;
                if (rotorpos2r.x >= 80f) rotorpos2r.x = 0f;
                oarright2.transform.eulerAngles = new Vector3(rotorpos2r.x + 5f, rotorpos2r.y, rotorpos2r.z);

                var rotorpos2l = oarleft2.transform.eulerAngles;
                if (rotorpos2l.x >= 80f) rotorpos2l.x = 0f;
                oarleft2.transform.eulerAngles = new Vector3(rotorpos2l.x + 5f, rotorpos2l.y, rotorpos2l.z);

                var rotorpos3r = oarright3.transform.eulerAngles;
                if (rotorpos3r.x >= 80f) rotorpos3r.x = 0f;
                oarright3.transform.eulerAngles = new Vector3(rotorpos3r.x + 5f, rotorpos3r.y, rotorpos3r.z);

                var rotorpos3l = oarleft3.transform.eulerAngles;
                if (rotorpos3l.x >= 80f) rotorpos3l.x = 0f;
                oarleft3.transform.eulerAngles = new Vector3(rotorpos3l.x + 5f, rotorpos3l.y, rotorpos3l.z);

                var rotorpos4r = oarright4.transform.eulerAngles;
                if (rotorpos4r.x >= 80f) rotorpos4r.x = 0f;
                oarright4.transform.eulerAngles = new Vector3(rotorpos4r.x + 5f, rotorpos4r.y, rotorpos4r.z);

                var rotorpos4l = oarleft4.transform.eulerAngles;
                if (rotorpos4l.x >= 80f) rotorpos4l.x = 0f;
                oarleft4.transform.eulerAngles = new Vector3(rotorpos4l.x + 5f, rotorpos4l.y, rotorpos4l.z);

                var rotorpos5r = oarright5.transform.eulerAngles;
                if (rotorpos5r.x >= 80f) rotorpos5r.x = 0f;
                oarright5.transform.eulerAngles = new Vector3(rotorpos5r.x + 5f, rotorpos5r.y, rotorpos5r.z);

                var rotorpos5l = oarleft5.transform.eulerAngles;
                if (rotorpos5l.x >= 80f) rotorpos5l.x = 0f;
                oarleft5.transform.eulerAngles = new Vector3(rotorpos5l.x + 5f, rotorpos5l.y, rotorpos5l.z);
            }

            void ResetMovement()
            {
                ismoving = false;
                moveforward = false;
                movebackward = false;
                rotright = false;
                rotleft = false;
            }

            public void RefreshAll()
            {
                if (!PlayerIsMounted()) { ResetMovement(); return; }
                entity.transform.hasChanged = true;
                var entitymount = entity.GetComponent<BaseMountable>() ?? null;
                if (entitymount != null)
                {
                    entitymount.isMobile = true;
                }
                entity.SendNetworkUpdateImmediate();
                entity.UpdateNetworkGroup();
                entity.GetComponent<DestroyOnGroundMissing>().enabled = false;
                entity.GetComponent<GroundWatch>().enabled = false;

                if (entity.children != null)
                    for (int i = 0; i < entity.children.Count; i++)
                    {
                        entity.children[i].transform.hasChanged = true;
                        var isblock = entity.children[i].GetComponent<BuildingBlock>() ?? null;
                        if (isblock != null)
                        {
                            isblock.UpdateSkin();
                            isblock.ClientRPC(null, "RefreshSkin");
                        }
                        var hasmount = entity.children[i].GetComponent<BaseMountable>() ?? null;
                        if (hasmount != null)
                        {
                            hasmount.isMobile = true;
                        }
                        entity.children[i].SendNetworkUpdateImmediate(false);
                        entity.children[i].UpdateNetworkGroup();
                    }
            }

            public void OnDestroy()
            {
                if (hasVikingBoat.ContainsKey(ownerid)) hasVikingBoat.Remove(ownerid);
                if (entity != null && !entity.IsDestroyed) { entity.Invoke("KillMessage", 0.1f); }
            }
        }

        #endregion

        #region Configuration

        static float DefaultVikingBoatMovementSpeed = 4f;
        bool OnlyOneActiveVikingBoat = true;
        static int MaterialsForVikingBoat = 10000;
        static int MaterialID = -151838493;
        bool BlockDecay = true;
        static bool ShowWaterSplash = false;

        bool Changed;

        bool isRestricted;
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        void LoadDefaultConfig()
        {
            Puts("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }

        private void LoadConfigVariables()
        {
            CheckCfg("Effect - Show water splash effect when moving ? ", ref ShowWaterSplash);
            CheckCfg("Decay - Block all decay damage to Viking Boat ? ", ref BlockDecay);
            CheckCfg("Usage - Only 1 Active VikingBoat per player ? ", ref OnlyOneActiveVikingBoat);
            CheckCfg("Materials - VikingBoat- Amount of Wood needed to build : ", ref MaterialsForVikingBoat);
            CheckCfg("Materials - Item ID of material needed (default is wood) : ", ref MaterialID);
            CheckCfgFloat("Speed - Default VikingBoat Movement Speed : ", ref DefaultVikingBoatMovementSpeed);
        }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        private void CheckCfgFloat(string Key, ref float var)
        {

            if (Config[Key] != null)
                var = Convert.ToSingle(Config[Key]);
            else
                Config[Key] = var;
        }

        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        #endregion

        #region Localization

        string msg(string key, string playerId = null) => lang.GetMessage(key, this, playerId);

        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["notauthorized"] = "You are not authorized to use that command !!",
            ["notowner"] = "You must be owner of boat to pilot it !!!",
            ["boatlocked"] = "Boat is locked, you cannot access it !!!",
            ["hasVikingBoatalready"] = "You already have a VikingBoat in the world !!!",
            ["captain"] = "You are now the Captain of this boat !!!",
            ["alreadyadded"] = "That part is already installed !!!",
            ["missingmaterials"] = "You are missing the required materials to uprade to that !! ",
            ["endofworld"] = "Movement blocked !!! You are at the end of the playable world !!!",
            ["notstandingwater"] = "You must be in deeper water but NOT swimming to build a VikingBoat !!"
        };

        #endregion

    }
}

// --- End of file: VikingBoat.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RustApp.cs ---
// --- Original Local Path: RustApp.cs ---

﻿#define RU

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Plugins;
using Oxide.Core.Plugins;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using JetBrains.Annotations;
using Oxide.Core.Libraries;
using Oxide.Game.Rust.Cui;
using System.Linq;
using UnityEngine;
using Network;
using UnityEngine.Networking;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.Networking;
using System.IO;
using ConVar;
using Oxide.Core.Database;
using Facepunch;
using Rust;
using Steamworks;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Text;
using UnityEngine;
using Color = System.Drawing.Color;
using Graphics = System.Drawing.Graphics;
using Star = ProtoBuf.PatternFirework.Star;

namespace Oxide.Plugins
{
  [Info("RustApp", "Hougan & Xacku & Olkuts", "1.7.0")]
  public class RustApp : RustPlugin
  {
    #region Classes 

    // From RustStats by Sanlerus  
    public static class EncodingBase64
    {
      public static string Encode(string text)
      {
        var textAsBytes = Encoding.UTF8.GetBytes(text);
        return Convert.ToBase64String(textAsBytes);
      }
      public static string Decode(string encodedText)
      {
        var textAsBytes = Convert.FromBase64String(encodedText);
        return Encoding.UTF8.GetString(textAsBytes);
      }
    }

    // Base code idea from RustStore by Sanlerus
    public class StableRequest<T>
    {
      private static Dictionary<string, string> DefaultHeaders(string secret)
      {
        return new Dictionary<string, string>
        {
          ["x-plugin-auth"] = secret,
          ["x-plugin-version"] = _RustApp.Version.ToString(),
          ["x-plugin-port"] = ConVar.Server.port.ToString()
        };
      }

      private string url;
      private RequestMethod method;

      private object data;
      public Dictionary<string, string> headers = new Dictionary<string, string>();

      public Action<string> onException;
      public Action<T, string> onComplete;

      public bool debug = true;
      public bool silent = true;

      private DateTime _created = DateTime.Now;

      public StableRequest(string url, RequestMethod method, object? data, string secret)
      {
        this.url = url;
        this.method = method;

        this.data = data;
        this.headers = DefaultHeaders(secret);

        this.onException += (a) =>
        {
          LastException.History.Insert(0, new LastException(url, data, a, secret));

          if (LastException.History.Count > 10)
          {
            LastException.History.RemoveRange(10, 1);
          }
        };
      }

      public double Elapsed()
      {
        return (DateTime.Now - _created).TotalMilliseconds;
      }

      public void Execute(Action<T, string> onComplete, Action<string> onException)
      {
        if (onComplete != null)
        {
          this.onComplete += onComplete;
        }
        if (onException != null)
        {
          this.onException += onException;
        }

        UnityWebRequest webRequest = null;

        var body = System.Text.Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(data != null ? data : new { }));

        switch (method)
        {
          case RequestMethod.GET:
            {
              webRequest = UnityWebRequest.Get(url);
              break;
            }
          case RequestMethod.PUT:
            {
              webRequest = UnityWebRequest.Put(url, "{}");

              webRequest.uploadHandler = (UploadHandler)new UploadHandlerRaw(body);
              webRequest.uploadHandler.contentType = "application/json";
              break;
            }
          case RequestMethod.POST:
            {
              webRequest = UnityWebRequest.Post(url, "{}");

              webRequest.uploadHandler = (UploadHandler)new UploadHandlerRaw(body);
              webRequest.uploadHandler.contentType = "application/json";
              break;
            }
          case RequestMethod.DELETE:
            {
              webRequest = UnityWebRequest.Delete(url);

              webRequest.uploadHandler = (UploadHandler)new UploadHandlerRaw(body);
              webRequest.uploadHandler.contentType = "application/json";
              break;
            }
        }

        if (webRequest == null)
        {
          throw new Exception("bad.request.type");
        }

        if (headers != null)
        {
          foreach (var chunk in headers)
          {
            webRequest.SetRequestHeader(chunk.Key, chunk.Value);
          }
        }

        webRequest.SetRequestHeader("Content-Type", "application/json");

        webRequest.timeout = 10;

        Rust.Global.Runner.StartCoroutine(this.WaitForRequest(webRequest));
      }

      private IEnumerator WaitForRequest(UnityWebRequest request)
      {
        yield return request.Send();

        bool isError = request.isHttpError || request.isNetworkError || request.error != null;
        var body = (request.downloadHandler?.text ?? "possible network errors, contact @rustapp_help if you see > 5 minutes").ToLower();

        if (body.Length == 0)
        {
          body = "possible network errors, contact @rustapp_help if you see > 5 minutes";
        }

        if (isError)
        {
          if (body.Contains("502 bad gateway") || body.Contains("cloudflare"))
          {
            onException?.Invoke("rustapp is restarting, wait please");
          }
          else
          {
            onException?.Invoke(body);
          }
        }
        else
        {
          try
          {
            if (typeof(T) == typeof(String))
            {
              onComplete?.Invoke((T)(object)request.downloadHandler?.text, request.downloadHandler?.text);
            }
            else
            {
              var obj = JsonConvert.DeserializeObject<T>(request.downloadHandler?.text);

              onComplete?.Invoke(obj, request.downloadHandler?.text);
            }
          }
          catch (Exception parseException)
          {
            var str = typeof(T).ToString();

            _RustApp.Error(
              $"Не удалось разобрать ответ от сервера ({request.method.ToUpper()} {request.url}): {parseException} (Response: {request.downloadHandler?.text})",
              $"Failed to parse server response: ({request.method.ToUpper()} {request.url}): {parseException} (Response: {request.downloadHandler?.text})"
            );
          }
        }
      }
    }

    private class LastException
    {
      public static List<LastException> History = new List<LastException>();

      public string module;
      public string secret;
      public string payload;
      public string response;
      public DateTime time = DateTime.Now;

      public LastException(string module, object payload, string response, string secret)
      {
        this.module = module;
        this.secret = secret;
        this.payload = JsonConvert.SerializeObject(payload ?? "No request payload");
        this.response = response;
      }
    }

    private static class CourtUrls
    {
      private static string Base = "https://court.rustapp.io";

      public static string Pair = $"{CourtUrls.Base}/plugin/pair";

      public static string Validate = $"{CourtUrls.Base}/plugin/";
      public static string SendContact = $"{CourtUrls.Base}/plugin/contact";
      public static string SendState = $"{CourtUrls.Base}/plugin/state";
      public static string SendChat = $"{CourtUrls.Base}/plugin/chat";
      public static string SendAlerts = $"{CourtUrls.Base}/plugin/alerts";
      public static string SendCustomAlert = $"{CourtUrls.Base}/plugin/custom-alert";
      public static string SendReports = $"{CourtUrls.Base}/plugin/reports";
      public static string SendDestroyedSignage = $"{CourtUrls.Base}/plugin/signage";
      public static string SendSignage = $"{CourtUrls.Base}/plugin/signage";
      public static string SendWipe = $"{CourtUrls.Base}/plugin/wipe";
      public static string BanCreate = $"{CourtUrls.Base}/plugin/ban";
      public static string BanDelete = $"{CourtUrls.Base}/plugin/unban";
    }

    private static class QueueUrls
    {
      private static string Base = "https://queue.rustapp.io";

      public static string Fetch = $"{QueueUrls.Base}/";
      public static string Response = $"{QueueUrls.Base}/";
    }

    private static class BanUrls
    {
      private static string Base = "https://ban.rustapp.io";

      public static string Fetch = $"{BanUrls.Base}/plugin/v2";
    }

    class PluginChatMessagesPayload
    {
      public List<PluginChatMessageEntry> messages = new List<PluginChatMessageEntry>();
    }

    public class PluginChatMessageEntry
    {
      public string steam_id;
      [CanBeNull]
      public string target_steam_id;

      public bool is_team;

      public string text;
    }

    class PluginReportsPayload
    {
      public List<PluginReportEntry> reports = new List<PluginReportEntry>();
    }

    public static class PlayerAlertType
    {
      public static readonly string join_with_ip_ban = "join_with_ip_ban";
      public static readonly string dug_up_stash = "dug_up_stash";
      public static readonly string custom_api = "custom_api";
    }

    public class PluginPlayerAlertEntry
    {
      public string type;
      public object meta;
    }

    public class PluginPlayerAlertJoinWithIpBanMeta
    {
      public string steam_id;
      public string ip;
      public int ban_id;
    }

    public class PluginPlayerAlertDugUpStashMeta
    {
      public string steam_id;
      public string owner_steam_id;
      public string position;
      public string square;
    }

    public class PluginReportEntry
    {
      public string initiator_steam_id;
      [CanBeNull]
      public string target_steam_id;

      public List<string> sub_targets_steam_ids;

      public string reason;

      [CanBeNull]
      public string message;
    }

    class PluginPairDto
    {
      [CanBeNull] public int ttl;
      [CanBeNull] public string token;
    }

    class PluginPlayerPayload
    {
      private static bool IsRaidBlocked(BasePlayer player)
      {
        if (_RustApp == null || !_RustApp.IsLoaded)
        {
          return false;
        }

        var plugins = new List<Plugin> {
          _RustApp.NoEscape,
          _RustApp.RaidZone,
          _RustApp.RaidBlock
        };

        var correct = plugins.Find(v => v != null);
        if (correct != null)
        {
          try
          {
            switch (correct.Name)
            {
              case "NoEscape":
                {
                  return (bool)correct.Call("IsRaidBlocked", player);
                }
              case "RaidZone":
                {
                  return (bool)correct.Call("HasBlock", player.userID);
                }
              case "RaidBlock":
                {
                  try
                  {
                    return (bool)correct.Call("IsInRaid", player);
                  }
                  catch
                  {
                    return (bool)correct.Call("IsRaidBlocked", player);
                  }
                }
            }
          }
          catch
          {
            /**
            _RustApp.Warning(
              "Обнаружен плагин NoEscape, но не удалось вызвать API",
              "Detected plugin NoEscape, but failed to call API"
            );
            */
          }
        }

        return false;
      }



      private static bool IsBuildingAuthed(BasePlayer player)
      {
        var list = new List<BuildingPrivlidge>();

        Vis.Entities(player.transform.position, 16f, list, Layers.PreventBuilding);

        return list.FirstOrDefault()?.IsAuthed(player) ?? false;
      }

      private static bool NoLicense(Network.Connection connection)
      {
        if (_RustApp.MultiFighting == null || !_RustApp.MultiFighting.IsLoaded)
        {
          return false;
        }

        try
        {
          var isSteam = (bool)_RustApp.MultiFighting.Call("IsSteam", connection);

          return !isSteam;
        }
        catch
        {
          return false;
        }
      }

      public static PluginPlayerPayload FromPlayer(BasePlayer player)
      {
        var payload = new PluginPlayerPayload();

        payload.position = player.transform.position.ToString();
        payload.rotation = player.eyes.rotation.ToString();
        payload.coords = GridReference(player.transform.position);

        payload.steam_id = player.UserIDString;
        payload.steam_name = player.displayName;
        payload.ip = player.Connection.IPAddressWithoutPort();

        payload.status = "active";

        payload.can_build = PluginPlayerPayload.IsBuildingAuthed(player);

        payload.is_raiding = PluginPlayerPayload.IsRaidBlocked(player);
        payload.no_license = PluginPlayerPayload.NoLicense(player.Connection);

        if (player.Team != null)
        {
          payload.team = player.Team.members
            .Select(v => v.ToString())
            .Where(v => v != player.UserIDString)
            .ToList();
        }

        return payload;
      }

      public static PluginPlayerPayload FromConnection(Network.Connection connection, string status)
      {
        var payload = new PluginPlayerPayload();

        payload.steam_id = connection.userid.ToString();
        payload.steam_name = connection.username;
        payload.ip = connection.IPAddressWithoutPort();

        payload.status = status;

        payload.no_license = PluginPlayerPayload.NoLicense(connection);

        var team = RelationshipManager.ServerInstance.FindPlayersTeam(connection.userid);
        if (team != null)
        {
          payload.team = team.members
            .Select(v => v.ToString())
            .Where(v => v != connection.userid.ToString())
            .ToList();
        }

        return payload;
      }
      public string steam_id;
      public string steam_name;
      public string ip;

      [CanBeNull] public string position;
      [CanBeNull] public string rotation;
      [CanBeNull] public string coords;

      public bool can_build = false;
      public bool is_raiding = false;
      public bool no_license = false;

      public string status;

      public List<string> team = new List<string>();
    }

    public class MetaInfo
    {
      public static MetaInfo Read()
      {
        if (!Interface.Oxide.DataFileSystem.ExistsDatafile("RustApp_Configuration"))
        {
          return null;
        }

        return Interface.Oxide.DataFileSystem.ReadObject<MetaInfo>("RustApp_Configuration");
      }

      public static void write(MetaInfo courtMeta)
      {
        Interface.Oxide.DataFileSystem.WriteObject("RustApp_Configuration", courtMeta);
      }

      [JsonProperty("It is access for RustApp Court, never edit or share it")]
      public string Value;
    }

    public class CheckInfo
    {
      public static CheckInfo Read()
      {
        if (!Interface.Oxide.DataFileSystem.ExistsDatafile("RustApp_CheckMeta"))
        {
          return new CheckInfo();
        }

        return Interface.Oxide.DataFileSystem.ReadObject<CheckInfo>("RustApp_CheckMeta");
      }

      public static void write(CheckInfo courtMeta)
      {
        // Clear checks > 30 days ago
        courtMeta.LastChecks = courtMeta.LastChecks.Where(v => _RustApp.CurrentTime() - v.Value < 30 * 24 * 60 * 60).ToDictionary(v => v.Key, v => v.Value);

        Interface.Oxide.DataFileSystem.WriteObject("RustApp_CheckMeta", courtMeta);
      }

      [JsonProperty("List of recent checks to show green-check on player")]
      public Dictionary<string, double> LastChecks = new Dictionary<string, double>();
    }

    public class PairWorker : BaseWorker
    {
      public string Code;

      public void EnterCode(string code)
      {
        @PairAssignData(code, (data) =>
        {
          Code = code;

          if (data.token != null && data.token.Length > 0)
          {
            Complete(data.token);
            return;
          }

          Notify(data.ttl);

          Invoke(nameof(PairWaitFinish), 1f);
        }, (err) =>
        {
          Destroy(this);
        });
      }

      public void Notify(int left)
      {
        _RustApp.Log(
          $"Соединение установлено, завершите подключение на сайте.",
          $"Connection established, complete pair on site."
        );
      }

      public void Complete(string token)
      {
        _RustApp.Log(
          "Соединение установлено, перезагрузка...",
          "Connection established, reloading..."
        );

        if (_RustApp != null && _RustApp._Worker != null)
        {
          MetaInfo.write(new MetaInfo { Value = token });

          _RustApp._Worker.Awake();
        }
      }

      public void PairWaitFinish()
      {
        if (Code == null)
        {
          Destroy(this);
          return;
        }

        @PairAssignData(Code, (data) =>
        {
          if (data.token == null || data.token.Length == 0)
          {
            Invoke(nameof(PairWaitFinish), 1f);
            Notify(data.ttl);
            return;
          }

          Complete(data.token);
        }, (err) =>
        {
          Invoke(nameof(PairWaitFinish), 1f);

          Interface.Oxide.LogError($"ошибка, {err}");
        });
      }

      private void @PairAssignData(string code, Action<PluginPairDto> onComplete, Action<string> onException)
      {
        var obj = new
        {
          name = ConVar.Server.hostname,
          level = SteamServer.MapName ?? ConVar.Server.level,
          description = ConVar.Server.description + " " + ConVar.Server.motd,

          avatar_big = ConVar.Server.logoimage,
          banner_url = ConVar.Server.headerimage,

          online = BasePlayer.activePlayerList.Count + ServerMgr.Instance.connectionQueue.queue.Count + ServerMgr.Instance.connectionQueue.joining.Count,
          slots = ConVar.Server.maxplayers,

          port = ConVar.Server.port,
          branch = ConVar.Server.branch,

          connected = _RustApp._Worker?.Ban.IsAuthed()
        };

        Request<PluginPairDto>(CourtUrls.Pair + $"?code={code}", RequestMethod.POST, obj)
          .Execute(
            (data, raw) =>
            {
              if (data.ttl != null)
              {
                data.ttl = (int)Math.Round((float)(data.ttl / 1000));
              }

              onComplete(data);
            },
            (err) =>
            {
              if (err.Contains("code not exists"))
              {
                _RustApp.Error(
                  "Ключ API более недействителен.",
                  "API key is no longer valid."
                );

                Destroy(this);
                return;
              }

              onException(err);
            }
          );
      }
    }

    public class CourtWorker : BaseWorker
    {
      public ActionWorker Action;
      public UpdateWorker Update;
      public QueueWorker Queue;
      public PairWorker Pair;
      public BanWorker Ban;

      private MetaInfo Meta;

      public void Awake()
      {
        OnDestroy();

        _RustApp.Log(
          "Добро пожаловать в RustApp! Подключение к серверам панели...",
          "Welcome to the RustApp! Connecting to servers..."
        );

        Action = gameObject.AddComponent<ActionWorker>();
        Update = gameObject.AddComponent<UpdateWorker>();
        Queue = gameObject.AddComponent<QueueWorker>();
        Ban = gameObject.AddComponent<BanWorker>();

        Meta = MetaInfo.Read();

        if (Meta != null)
        {
          Connect();
        }
        else
        {
          _RustApp.Warning(
            "Ваш плагин не настроен, создайте сервер на сайте и следуйте указаниям",
            "Your plugin is not configured, create server on site and follow instructions"
          );
        }
      }

      public void Connect()
      {
        Auth(Meta.Value);

        @ValidateSecret(
          () => EnableModules(),
          (err) =>
          {
            if (err.Contains("is lower than minimal"))
            {
              _RustApp.Warning(
                $"Ваша версия плагина слишком сильно устарела, необходимо скачать новую с сайта.",
                $"Your version of the plugin is too outdated, you need to download a new one from the website."
              );
              return;
            }

            if (err.Contains("Authorization secret is corrupted"))
            {
              _RustApp.Warning(
                $"Ваш ключ более недействителен.",
                $"Your key is no longer valid."
              );
              return;
            }

            if (err.Contains("Check server configuration, required ip") || err.Contains("Check server configuration, required port"))
            {
              _RustApp.Warning(
                $"Конфигурация вашего сервера изменилась, необходимо переподключить сервер через сайт.",
                $"Your server configuration has changed, you need to reconnect the server through the site."
              );
              return;
            }

            _RustApp.Error(
              $"Судя по всему RustApp временно недоступен, попробуем переподключиться через 10 секунд.",
              $"Apparently RustApp is temporarily unavailable, let's try reconnecting in 10 seconds."
            );

            Invoke(nameof(Connect), 10f);
          }
        );
      }

      public void EnableModules()
      {
        Action.Auth(Meta.Value);
        Update.Auth(Meta.Value);
        Queue.Auth(Meta.Value);
        Ban.Auth(Meta.Value);

        _RustApp.Log(
          "Соединение установлено, плагин готов к работе!",
          "Connection established, plugin is ready!"
        );

        _Settings.report_ui_commands.ForEach(v =>
        {
          _RustApp.cmd.AddChatCommand(v, _RustApp, nameof(_RustApp.ChatCmdReport));
        });

        _RustApp.cmd.AddChatCommand(_Settings.check_contact_command, _RustApp, nameof(_RustApp.CmdChatContact));
      }

      public void @ValidateSecret(Action? onComplete, Action<string>? onException)
      {
        Request<object>(CourtUrls.Validate, RequestMethod.GET)
          .Execute(
            (data, raw) => onComplete?.Invoke(),
            (err) => onException?.Invoke(err)
          );
      }

      public void StartPair(string code)
      {
        if (Pair != null)
        {
          _RustApp.Warning(
            "Вы уже подключаетесь, вы можете отменить запрос.",
            "You already connecting, you can reset state."
          );
          return;
        }

        Pair = gameObject.AddComponent<PairWorker>();

        Pair.EnterCode(code);
      }

      public void OnDestroy()
      {
        if (Action != null)
        {
          Destroy(Action);
        }

        if (Update != null)
        {
          Destroy(Update);
        }

        if (Queue != null)
        {
          Destroy(Queue);
        }

        if (Pair != null)
        {
          Destroy(Pair);
        }

        if (Ban != null)
        {
          Destroy(Ban);
        }
      }
    }

    public class ActionWorker : BaseWorker
    {
      public void @SendContact(string steam_id, string message, Action<bool> callback)
      {
        if (!IsReady())
        {
          return;
        }

        Request<object>(CourtUrls.SendContact, RequestMethod.POST, new { steam_id, message })
          .Execute(
            (data, raw) => callback(true),
            (err) => callback(false)
          );
      }
      public void @SendWipe(Action<bool> callback)
      {
        if (!IsReady())
        {
          return;
        }

        Request<object>(CourtUrls.SendWipe, RequestMethod.POST)
          .Execute(
            (data, raw) => callback(true),
            (err) => callback(false)
          );
      }

      public void @SendBan(string steam_id, string reason, string duration, bool global, bool ban_ip)
      {
        if (!IsReady())
        {
          return;
        }

        Request<object>(CourtUrls.BanCreate, RequestMethod.POST, new
        {
          target_steam_id = steam_id,
          reason = reason,
          global = global,
          ban_ip = ban_ip,
          duration = duration.Length > 0 ? duration : null,
        })
        .Execute(
          (data, raw) =>
          {
            _RustApp.Log(
              $"Игрок {steam_id} заблокирован за {reason}",
              $"Player {steam_id} banned for {reason}"
            );

            _RustApp.CloseConnection(steam_id, reason);
          },
          (err) => _RustApp.Log(
            $"Не удалось заблокировать {steam_id}. Причина: {err}",
            $"Failed to ban {steam_id}. Reason: {err}"
          )
        );
      }

      public void @SendBanDelete(string steam_id)
      {
        if (!IsReady())
        {
          return;
        }

        Request<object>(CourtUrls.BanDelete, RequestMethod.POST, new
        {
          target_steam_id = steam_id,
        })
        .Execute(
          (data, raw) =>
          {
            _RustApp.Log(
              $"Игрок {steam_id} разблокирован",
              $"Player {steam_id} unbanned"
            );
          },
          (err) => _RustApp.Log(
            $"Не удалось разблокировать {steam_id}. Причина: {err}",
            $"Failed to unban {steam_id}. Reason: {err}"
          )
        );
      }

      public void @SendCustomAlert(string message, [CanBeNull] object data)
      {
        if (!IsReady())
        {
          return;
        }

        Request<object>(CourtUrls.SendCustomAlert, RequestMethod.POST, new { msg = message, data })
          .Execute(
            null,
            (err) =>
            {
              _RustApp.Puts(err);
              _RustApp.Error(
                $"Не удалось отправить кастомное оповещение ({message})",
                $"Failed to send custom-alert ({message})"
              );
            }
          );
      }

      public void @SendSignage(BaseImageUpdate upload)
      {
        if (!IsReady())
        {
          return;
        }

        var obj = new
        {
          steam_id = upload.PlayerId.ToString(),
          net_id = upload.Entity.net.ID.Value,

          base64_image = Convert.ToBase64String(upload.GetImage()),

          type = upload.Entity.ShortPrefabName,
          position = upload.Entity.transform.position.ToString(),
          square = GridReference(upload.Entity.transform.position)
        };

        Request<string>(CourtUrls.SendSignage, RequestMethod.POST, obj)
          .Execute(
            (data, raw) =>
            {
            },
            (err) =>
            {
              _RustApp.Error(
                $"Не удалось отправить табличку ({err})",
                $"Failed to send signage ({err})"
              );
            }
          );
      }
    }

    public class BanWorker : BaseWorker
    {
      public class BanFetchResponse
      {
        public List<BanFetchEntry> entries;
      }

      public class BanFetchPayload
      {
        public string steam_id;
        public string ip;
      }

      public class BanFetchEntry : BanFetchPayload
      {
        public List<BanEntry> bans;
      }

      public class BanEntry
      {
        public int id;
        public string steam_id;
        public string ban_ip;
        public string reason;
        public long expired_at;
        public bool ban_ip_active;
        public bool computed_is_active;

        public int sync_project_id = 0;
        public bool sync_should_kick = false;
      }

      private Dictionary<string, string> PlayersCollection = new Dictionary<string, string>();

      public void Awake()
      {
        foreach (var player in BasePlayer.activePlayerList)
        {
          FetchBan(player);
        }

        foreach (var queued in ServerMgr.Instance.connectionQueue.queue)
        {
          FetchBan(queued.userid.ToString(), queued.IPAddressWithoutPort());
        }

        foreach (var loading in ServerMgr.Instance.connectionQueue.joining)
        {
          FetchBan(loading.userid.ToString(), loading.IPAddressWithoutPort());
        }
      }

      protected override void OnReady()
      {
        InvokeRepeating(nameof(FetchBans), 0f, 2f);
      }

      public void FetchBan(BasePlayer player)
      {
        FetchBan(player.UserIDString, player.Connection.IPAddressWithoutPort());
      }

      public void FetchBan(string steamId, string ip)
      {
        // Вызов хука на возможность игнорировать проверку
        var over = Interface.Oxide.CallHook("RustApp_CanIgnoreBan", steamId);
        if (over != null)
        {
          return;
        }

        if (!PlayersCollection.ContainsKey(steamId))
        {
          PlayersCollection.Add(steamId, ip);
          return;
        }

        PlayersCollection[steamId] = ip;
      }

      private void FetchBans()
      {
        if (!IsReady() || PlayersCollection.Count == 0)
        {
          return;
        }

        var banChecks = PlayersCollection.ToDictionary(v => v.Key, v => v.Value);

        @FetchBans(
          banChecks,
          (steamId, ban) =>
          {
            if (PlayersCollection.ContainsKey(steamId))
            {
              PlayersCollection.Remove(steamId);
            }

            if (ban != null)
            {
              if (ban.sync_project_id != 0 && !ban.sync_should_kick)
              {
                return;
              }

              if (ban.steam_id == steamId)
              {
                var format = ban.expired_at == 0 ? _Settings.ban_reason_format : _Settings.ban_reason_format_temporary;

                if (ban.sync_project_id != 0)
                {
                  format = ban.expired_at == 0 ? _Settings.ban_sync_reason_format : _Settings.ban_sync_reason_format;
                }

                var time = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc).AddMilliseconds(ban.expired_at + 3 * 60 * 60 * 1_000).ToString("dd.MM.yyyy HH:mm");

                var text = format.Replace("%REASON%", ban.reason).Replace("%TIME%", time);

                _RustApp.CloseConnection(steamId, text);
              }
              else
              {
                _RustApp.CloseConnection(steamId, _Settings.ban_reason_ip_format);

                CreateAlertForIpBan(ban, steamId);
              }

            }
          },
          () =>
          {
            _RustApp.Error(
              $"Ошибка проверки блокировок ({banChecks.Keys.Count} шт.), пытаемся снова...",
              $"Ban check error ({banChecks.Keys.Count} total), attempting again..."
            );

            // Возвращаем неудачно отправленные сообщения обратно в массив
            var resurrectCollection = new Dictionary<string, string>();

            foreach (var ban in banChecks)
            {
              if (resurrectCollection.ContainsKey(ban.Key))
              {
                continue;
              }

              resurrectCollection.Add(ban.Key, ban.Value);
            }
            foreach (var ban in PlayersCollection)
            {
              if (resurrectCollection.ContainsKey(ban.Key))
              {
                continue;
              }

              resurrectCollection.Add(ban.Key, ban.Value);
            }

            PlayersCollection = resurrectCollection;
          }
        );

        PlayersCollection = new Dictionary<string, string>();
      }

      public void CreateAlertForIpBan(BanEntry ban, string steamId)
      {
        if (ban.steam_id == steamId)
        {
          return;
        }

        if (!ban.ban_ip_active)
        {
          return;
        }

        _RustApp._Worker.Update.SaveAlert(new PluginPlayerAlertEntry
        {
          type = PlayerAlertType.join_with_ip_ban,
          meta = new PluginPlayerAlertJoinWithIpBanMeta
          {
            steam_id = steamId,
            ip = ban.ban_ip,
            ban_id = ban.id
          }
        });
      }

      public void @FetchBans(Dictionary<string, string> entries, Action<string, BanEntry> onBan, Action onException)
      {
        /*
        _RustApp.Log(
          $"Проверяем блокировки игроков ({entries.Keys.Count} шт)",
          $"Fetch players bans ({entries.Keys.Count} pc)"
        );
        */

        var players = new List<BanFetchPayload>();

        foreach (var entry in entries)
        {
          players.Add(new BanFetchPayload { steam_id = entry.Key, ip = entry.Value });
        }

        Request<BanFetchResponse>(BanUrls.Fetch, RequestMethod.POST, new { players })
          .Execute(
            (data, raw) =>
            {
              foreach (var player in players)
              {
                var exists = data.entries.Find(v => v.steam_id == player.steam_id);
                if (exists == null)
                {
                  _RustApp.Error(
                    $"Ответ бан-сервиса не содержит запрошенного игрока: {player.steam_id}",
                    $"The ban service response does not contain the requested player: {player.steam_id}"
                  );
                  return;
                }

                var active = exists.bans.FirstOrDefault(v => v.computed_is_active);

                onBan?.Invoke(player.steam_id, active);
              }
            },
            (err) =>
            {
              Interface.Oxide.LogWarning(err);
              onException?.Invoke();
            }
          );
      }
    }

    public class UpdateWorker : BaseWorker
    {
      private List<PluginPlayerAlertEntry> PlayerAlertCollection = new List<PluginPlayerAlertEntry>();
      private List<PluginReportEntry> ReportCollection = new List<PluginReportEntry>();
      private List<PluginChatMessageEntry> ChatCollection = new List<PluginChatMessageEntry>();
      private Dictionary<string, string> DisconnectHistory = new Dictionary<string, string>();
      private Dictionary<string, string> TeamChangeHistory = new Dictionary<string, string>();
      private List<string> DestroyedSignsCollection = new List<string>();

      protected override void OnReady()
      {
        CancelInvoke(nameof(SendChat));
        CancelInvoke(nameof(SendUpdate));
        CancelInvoke(nameof(SendReports));
        CancelInvoke(nameof(SendAlerts));
        CancelInvoke(nameof(SendDestroyedSigns));

        InvokeRepeating(nameof(SendChat), 0, 1f);
        InvokeRepeating(nameof(SendUpdate), 0, 5f);
        InvokeRepeating(nameof(SendReports), 0, 1f);
        InvokeRepeating(nameof(SendAlerts), 0, 5f);
        InvokeRepeating(nameof(SendDestroyedSigns), 0, 5f);
      }

      public void SaveChat(PluginChatMessageEntry message)
      {
        ChatCollection.Add(message);
      }

      public void SaveAlert(PluginPlayerAlertEntry playerAlert)
      {
        PlayerAlertCollection.Add(playerAlert);
      }

      public void SaveDestroyedSign(string net_id)
      {
        DestroyedSignsCollection.Add(net_id);
      }

      public void SaveDisconnect(BasePlayer player, string reason)
      {
        if (!DisconnectHistory.ContainsKey(player.UserIDString))
        {
          DisconnectHistory.Add(player.UserIDString, reason);
        }

        DisconnectHistory[player.UserIDString] = reason;
      }

      public void SaveTeamHistory(string initiator_steam_id, string target_steam_id)
      {
        if (!TeamChangeHistory.ContainsKey(target_steam_id))
        {
          TeamChangeHistory.Add(target_steam_id, initiator_steam_id);
        }

        TeamChangeHistory[target_steam_id] = initiator_steam_id;
      }

      public void SaveReport(PluginReportEntry report)
      {
        // Вызов хука на возможность игнорировать проверку
        var over = Interface.Oxide.CallHook("RustApp_CanIgnoreReport", report.target_steam_id, report.initiator_steam_id);
        if (over != null)
        {
          return;
        }

        ReportCollection.Add(report);
      }

      private void SendDestroyedSigns()
      {
        if (!IsReady() || DestroyedSignsCollection.Count == 0)
        {
          return;
        }

        var destroyed_signs = DestroyedSignsCollection.ToList();

        Request<string>(CourtUrls.SendDestroyedSignage, RequestMethod.DELETE, new { net_ids = destroyed_signs })
          .Execute(
            null,
            (err) =>
            {
              _RustApp.Puts(err);
              _RustApp.Error(
                $"Не удалось отправить удаленные картинки ({destroyed_signs.Count} шт)",
                $"Failed to send destroyed signs ({destroyed_signs.Count} pc)"
              );

              // Возвращаем неудачно отправленные сообщения обратно в массив
              var resurrectCollection = new List<string>();

              resurrectCollection.AddRange(destroyed_signs);
              resurrectCollection.AddRange(DestroyedSignsCollection);

              DestroyedSignsCollection = resurrectCollection;
            }
          );

        DestroyedSignsCollection = new List<string>();
      }

      private void SendAlerts()
      {
        if (!IsReady() || PlayerAlertCollection.Count == 0)
        {
          return;
        }

        var alerts = PlayerAlertCollection.ToList();

        Request<object>(CourtUrls.SendAlerts, RequestMethod.POST, new { alerts })
          .Execute(
            null,
            (err) =>
            {
              _RustApp.Puts(err);
              _RustApp.Error(
                $"Не удалось отправить алерты ({alerts.Count} шт)",
                $"Failed to send alerts for player ({alerts.Count} pc)"
              );

              // Возвращаем неудачно отправленные сообщения обратно в массив
              var resurrectCollection = new List<PluginPlayerAlertEntry>();

              resurrectCollection.AddRange(alerts);
              resurrectCollection.AddRange(PlayerAlertCollection);

              PlayerAlertCollection = resurrectCollection;
            }
          );

        PlayerAlertCollection = new List<PluginPlayerAlertEntry>();
      }

      private void SendChat()
      {
        if (!IsReady() || ChatCollection.Count == 0)
        {
          return;
        }

        var messages = ChatCollection.ToList();

        Request<object>(CourtUrls.SendChat, RequestMethod.POST, new { messages })
          .Execute(
            null,
            (err) =>
            {
              _RustApp.Error(
                $"Не удалось отправить сообщения из чата ({messages.Count} шт)",
                $"Failed to send messages from the chat ({messages.Count} pc)"
              );

              // Возвращаем неудачно отправленные сообщения обратно в массив
              var resurrectCollection = new List<PluginChatMessageEntry>();

              resurrectCollection.AddRange(messages);
              resurrectCollection.AddRange(ChatCollection);

              ChatCollection = resurrectCollection;
            }
          );

        ChatCollection = new List<PluginChatMessageEntry>();
      }
      public void SendReports()
      {
        if (!IsReady() || ReportCollection.Count == 0)
        {
          return;
        }

        var reports = ReportCollection.ToList();

        Request<object>(CourtUrls.SendReports, RequestMethod.POST, new { reports })
          .Execute(
            null,
            (err) =>
            {
              _RustApp.Error(
                $"Не удалось отправить жалобы ({reports.Count} шт)",
                $"Failed to send messages from the chat ({reports.Count} pc)"
              );

              // Возвращаем неудачно отправленные репорты обратно в массив
              var resurrectCollection = new List<PluginReportEntry>();

              resurrectCollection.AddRange(reports);
              resurrectCollection.AddRange(ReportCollection);

              ReportCollection = resurrectCollection;
            }
          );

        ReportCollection = new List<PluginReportEntry>();
      }

      public void SendUpdate()
      {
        if (!IsReady())
        {
          return;
        }

        var players = new List<PluginPlayerPayload>();

        foreach (var player in BasePlayer.activePlayerList)
        {
          try
          {
            players.Add(PluginPlayerPayload.FromPlayer(player));
          }
          catch (Exception exc)
          {
          }
        }

        foreach (var player in ServerMgr.Instance.connectionQueue.queue)
        {
          try
          {
            players.Add(PluginPlayerPayload.FromConnection(player, "queued"));
          }
          catch (Exception exc)
          {
          }
        }

        foreach (var player in ServerMgr.Instance.connectionQueue.joining)
        {
          try
          {
            players.Add(PluginPlayerPayload.FromConnection(player, "joining"));
          }
          catch (Exception exc)
          {
          }
        }

        var disconnected = DisconnectHistory.ToDictionary(v => v.Key, v => v.Value);
        var team_changes = TeamChangeHistory.ToDictionary(v => v.Key, v => v.Value);

        var payload = new
        {
          hostname = ConVar.Server.hostname,
          level = SteamServer.MapName ?? ConVar.Server.level,

          avatar_url = ConVar.Server.logoimage,
          banner_url = ConVar.Server.headerimage,

          slots = ConVar.Server.maxplayers,
          version = _RustApp.Version.ToString(),
          performance = _RustApp.TotalHookTime.ToString(),

          players,
          disconnected = disconnected,
          team_changes = team_changes
        };

        Request<object>(CourtUrls.SendState, RequestMethod.PUT, payload)
          .Execute(
            (data, raw) =>
            {
            },
            (err) =>
            {
              //_RustApp.Error(
              //  $"Не удалось отправить состояние сервера ({err})",
              //  $"Failed to send server status ({err})"
              //);

              /**
              Возвращаем неудачно отправленные дисконекты
              */

              var resurrectCollectionDisconnects = new Dictionary<string, string>();

              foreach (var disconnect in disconnected)
              {
                if (!resurrectCollectionDisconnects.ContainsKey(disconnect.Key))
                {
                  resurrectCollectionDisconnects.Add(disconnect.Key, disconnect.Value);
                }
              }

              foreach (var disconnect in DisconnectHistory)
              {
                if (!resurrectCollectionDisconnects.ContainsKey(disconnect.Key))
                {
                  resurrectCollectionDisconnects.Add(disconnect.Key, disconnect.Value);
                }
              }

              DisconnectHistory = resurrectCollectionDisconnects;

              /**
              Возвращаем неудачно отправленные изменения команды
              */

              var resurrectCollectionTeamChanges = new Dictionary<string, string>();

              foreach (var teamChange in team_changes)
              {
                if (!resurrectCollectionTeamChanges.ContainsKey(teamChange.Key))
                {
                  resurrectCollectionTeamChanges.Add(teamChange.Key, teamChange.Value);
                }
              }

              foreach (var teamChange in TeamChangeHistory)
              {
                if (!resurrectCollectionTeamChanges.ContainsKey(teamChange.Key))
                {
                  resurrectCollectionTeamChanges.Add(teamChange.Key, teamChange.Value);
                }
              }

              TeamChangeHistory = resurrectCollectionTeamChanges;
            }
          );

        DisconnectHistory = new Dictionary<string, string>();
        TeamChangeHistory = new Dictionary<string, string>();
      }
    }

    public class QueueWorker : BaseWorker
    {
      private List<string> ProcessedQueues = new List<string>();
      public Dictionary<string, bool> Notices = new Dictionary<string, bool>();

      public class QueueElement
      {
        public string id;

        public QueueRequest request;
      }

      public class QueueRequest
      {
        public string name;
        public JObject data;
      }

      private class QueueKickPayload
      {
        public string steam_id;
        public string reason;
        public bool announce;
      }

      private class QueueBanPayload
      {
        public string steam_id;
        public string name;
        public string reason;
      }

      private class QueueDebugLog
      {
        public string message;
      }

      private class QueuePaidAnnounceBan
      {
        public bool broadcast = false;

        public string suspect_name;
        public string suspect_id;

        public string reason;

        public List<string> targets = new List<string>();
      }

      private class QueuePaidAnnounceClean
      {
        public bool broadcast = false;

        public string suspect_name;
        public string suspect_id;

        public List<string> targets = new List<string>();
      }

      class QueueNoticeStateGetPayload
      {
        public string steam_id;
      }

      private class QueueNoticeStateSetPayload
      {
        public string steam_id;
        public bool value;
      }

      private class QueueChatMessage
      {
        public string initiator_name;
        public string initiator_steam_id;

        [CanBeNull] public string target_steam_id;

        public string message;

        public string mode;
      }

      private class QueueExecuteCommand
      {
        public List<string> commands;
      }

      private class QueueDeleteEntityPayload
      {
        public string net_id;
      }


      protected override void OnReady()
      {
        InvokeRepeating(nameof(QueueRetreive), 0f, 1f);
      }

      private void QueueRetreive()
      {
        if (!IsReady())
        {
          return;
        }

        @QueueRetreive((queues) =>
        {
          var responses = new Dictionary<string, object>();

          foreach (var queue in queues)
          {
            if (ProcessedQueues.Contains(queue.id))
            {
              return;
            }

            try
            {
              var response = QueueProcess(queue);

              responses.Add(queue.id, response);

              ProcessedQueues.Add(queue.id);
            }
            catch (Exception exc)
            {
              _RustApp.PrintWarning(
                "Не удалось обработать команду из очереди",
                "Failed to process queue command"
              );

              responses.Add(queue.id, $"!EXCEPTION!:{exc.ToString()}");
            }
          }

          if (responses.Keys.Count == 0)
          {
            return;
          }

          QueueProcess(responses);
        });
      }

      private void @QueueRetreive(Action<List<QueueElement>> callback)
      {
        Request<List<QueueElement>>(QueueUrls.Fetch, RequestMethod.GET, null)
          .Execute(
            (data, raw) => callback(data),
            (err) =>
            {
              //_RustApp.Error(
              //  "Не удалось загрузить задачи из очередей",
              //  "Failed to retreive queue"
              //);
            }
          );
      }

      public void QueueProcess(Dictionary<string, object> responses)
      {
        Request<List<QueueElement>>(QueueUrls.Fetch, RequestMethod.PUT, new { data = responses })
          .Execute(
            (data, raw) =>
            {
              ProcessedQueues = new List<string>();
            },
            (err) =>
            {
              ProcessedQueues = new List<string>();
            }
          );
      }

      private object OnQueueHealthCheck()
      {
        return true;
      }
      public object QueueProcess(QueueElement element)
      {
        switch (element.request.name)
        {
          case "court/health-check":
            {
              return OnQueueHealthCheck();
            }
          case "court/kick":
            {
              return OnQueueKick(JsonConvert.DeserializeObject<QueueKickPayload>(element.request.data.ToString()));
            }
          case "court/ban":
            {
              return OnQueueBan(JsonConvert.DeserializeObject<QueueBanPayload>(element.request.data.ToString()));
            }
          case "court/debug-log":
            {
              return OnQueueDebugLog(JsonConvert.DeserializeObject<QueueDebugLog>(element.request.data.ToString()));
            }
          case "court/notice-state-get":
            {
              return OnNoticeStateGet(JsonConvert.DeserializeObject<QueueNoticeStateGetPayload>(element.request.data.ToString()));
            }
          case "court/notice-state-set":
            {
              return OnNoticeStateSet(JsonConvert.DeserializeObject<QueueNoticeStateSetPayload>(element.request.data.ToString()));
            }
          case "court/chat-message":
            {
              return OnChatMessage(JsonConvert.DeserializeObject<QueueChatMessage>(element.request.data.ToString()));
            }
          case "court/execute-command":
            {
              return OnExecuteCommand(JsonConvert.DeserializeObject<QueueExecuteCommand>(element.request.data.ToString()));
            }
          case "court/delete-entity":
            {
              return OnDeleteEntity(JsonConvert.DeserializeObject<QueueDeleteEntityPayload>(element.request.data.ToString()));
            }

          // Работают только на платном тарифе
          case "court/paid-announce-ban":
            {
              return OnQueuePaidAnnounceBan(JsonConvert.DeserializeObject<QueuePaidAnnounceBan>(element.request.data.ToString()));
            }
          case "court/paid-announce-clean":
            {
              return OnQueuePaidAnnounceClean(JsonConvert.DeserializeObject<QueuePaidAnnounceClean>(element.request.data.ToString()));
            }
          // Конец платных событий

          default:
            {
              _RustApp.Log(
                $"Неизвестная команда из очередей: {element.request.name}",
                $"Unknown queue command: {element.request.name}"
              );
              break;
            }
        }

        return null;
      }

      private object OnDeleteEntity(QueueDeleteEntityPayload payload)
      {
        var ent = BaseNetworkable.serverEntities.ToList().Find(v => v.net.ID.Value.ToString() == payload.net_id);
        if (ent == null)
        {
          return false;
        }

        ent.Kill();

        return true;
      }

      private object OnNoticeStateGet(QueueNoticeStateGetPayload payload)
      {
        if (!Notices.ContainsKey(payload.steam_id))
        {
          return false;
        }

        return Notices[payload.steam_id];
      }

      private object OnNoticeStateSet(QueueNoticeStateSetPayload payload)
      {
        var player = BasePlayer.Find(payload.steam_id);
        if (player == null || !player.IsConnected)
        {
          return "Player not found or offline";
        }

        var over = Interface.Oxide.CallHook("RustApp_CanIgnoreCheck", player);
        if (over != null)
        {
          if (over is string)
          {
            return over;
          }

          return "Plugin declined notice change via hook";
        }

        if (!Notices.ContainsKey(payload.steam_id))
        {
          Notices.Add(payload.steam_id, payload.value);
        }

        Notices[payload.steam_id] = payload.value;

        return NoticeStateSet(player, payload.value);
      }
      private object OnQueueKick(QueueKickPayload payload)
      {
        var success = _RustApp.CloseConnection(payload.steam_id, payload.reason);
        if (!success)
        {
          _RustApp.Log(
            $"Не удалось кикнуть игрока {payload.steam_id}, игрок не найден или оффлайн",
            $"Failed to kick player {payload.steam_id}, player not found or disconnected"
          );
          return "Player not found or offline";
        }

        _RustApp.Log(
          $"Игрок {payload.steam_id} кикнут по причине {payload.reason}",
          $"Player {payload.steam_id} was kicked for {payload.reason}"
        );

        if (payload.announce)
        {
          // _RustApp.SendGlobalMessage("Игрок был кикнут");
        }

        return true;
      }

      private object OnQueueBan(QueueBanPayload payload)
      {
        // Вызов хука на возможность игнорировать проверку
        var over = Interface.Oxide.CallHook("RustApp_CanIgnoreBan", payload.steam_id);
        if (over != null)
        {
          return "Plugin overrided queue-ban";
        }

        if (_Settings.ban_enable_broadcast)
        {
          var msg = _Settings.ban_broadcast_format.Replace("%TARGET%", payload.name).Replace("%REASON%", payload.reason);

          _RustApp.SendGlobalMessage(msg);
        }

        // Ip doesnot matter in this context
        _RustApp._Worker.Ban.FetchBan(payload.steam_id, "1.1.1.1");

        return true;
      }

      private object OnQueueDebugLog(QueueDebugLog payload)
      {
        _RustApp.PrintWarning(payload.message);

        return true;
      }

      private object OnQueuePaidAnnounceBan(QueuePaidAnnounceBan payload)
      {
        int received = 0;
        int error = 0;

        Interface.Oxide.CallHook("RustApp_OnPaidAnnounceBan", payload.suspect_id, payload.targets);

        if (!payload.broadcast)
        {
          return new { received, error };
        }

        foreach (var check in payload.targets)
        {
          var player = BasePlayer.Find(check);
          if (player == null || !player.IsConnected)
          {
            error++;
            continue;
          }

          var msg = _RustApp.lang.GetMessage("Paid.Announce.Ban", _RustApp, player.UserIDString);

          msg = msg.Replace("%SUSPECT_NAME%", payload.suspect_name).Replace("%SUSPECT_ID%", payload.suspect_id).Replace("%REASON%", payload.reason);

          _RustApp.SoundErrorToast(player, msg);

          received++;
        }

        return new { received, error };
      }

      private object OnQueuePaidAnnounceClean(QueuePaidAnnounceClean payload)
      {
        int received = 0;
        int error = 0;

        if (!_Checks.LastChecks.ContainsKey(payload.suspect_id))
        {
          _Checks.LastChecks.Add(payload.suspect_id, _RustApp.CurrentTime());
        }
        else
        {
          _Checks.LastChecks[payload.suspect_id] = _RustApp.CurrentTime();
        }

        Interface.Oxide.CallHook("RustApp_OnPaidAnnounceClean", payload.suspect_id, payload.targets);

        CheckInfo.write(_Checks);

        if (!payload.broadcast)
        {
          return new { received, error };
        }

        foreach (var check in payload.targets)
        {
          var player = BasePlayer.Find(check);
          if (player == null || !player.IsConnected)
          {
            error++;
            continue;
          }

          var msg = _RustApp.lang.GetMessage("Paid.Announce.Clean", _RustApp, player.UserIDString);

          msg = msg.Replace("%SUSPECT_NAME%", payload.suspect_name).Replace("%SUSPECT_ID%", payload.suspect_id);

          _RustApp.SoundInfoToast(player, msg);

          received++;
        }

        return new { received, error };
      }

      private object OnExecuteCommand(QueueExecuteCommand payload)
      {
        var responses = new List<object>();

        var index = 0;

        payload.commands.ForEach((v) =>
        {
          if (_Settings.custom_actions_allow)
          {
            var res = ConsoleSystem.Run(ConsoleSystem.Option.Server, v);

            try
            {
              responses.Add(new
              {
                success = true,
                command = v,
                data = JsonConvert.DeserializeObject(res?.ToString() ?? "Command without response")
              });
            }
            catch
            {
              responses.Add(new
              {
                success = true,
                command = v,
                data = res
              });
            }
          }
          else
          {
            responses.Add(new
            {
              success = false,
              command = v,
              data = "Custom actions are disabled"
            });
          }

          index++;
        });

        return responses;
      }

      private object OnChatMessage(QueueChatMessage payload)
      {
        var format = payload.target_steam_id is string ? _Settings.chat_direct_format : _Settings.chat_global_format;

        var message = format.Replace("%CLIENT_TAG%", payload.initiator_name).Replace("%MSG%", payload.message);

        if (payload.target_steam_id is string)
        {
          var player = BasePlayer.Find(payload.target_steam_id);

          if (player == null || !player.IsConnected)
          {
            return "Player not found or offline";
          }

          _RustApp.SendMessage(player, message);
          _RustApp.SoundToast(player, _RustApp.lang.GetMessage("Chat.Direct.Toast", _RustApp, player.UserIDString), 2);
        }
        else
        {
          foreach (var player in BasePlayer.activePlayerList)
          {
            _RustApp.SendMessage(player, message);
          }
        }


        return true;
      }

      private object NoticeStateSet(BasePlayer player, bool value)
      {
        if (!value)
        {
          _RustApp.Log(
            $"С игрока {player.userID} снято уведомление о проверке",
            $"Notify about check was removed from player {player.userID}"
          );

          Interface.Oxide.CallHook("RustApp_OnCheckNoticeHidden", player);

          CuiHelper.DestroyUi(player, CheckLayer);
        }
        else
        {
          _RustApp.Log(
            $"Игрок {player.userID} уведомлён о проверке",
            $"Player {player.userID} was notified about check"
          );

          Interface.Oxide.CallHook("RustApp_OnCheckNoticeShowed", player);

          _RustApp.DrawInterface(player);
        }

        return true;
      }
    }

    public class BaseWorker : MonoBehaviour
    {
      protected string secret = string.Empty;

      public void Auth(string secret)
      {
        this.secret = secret;

        OnReady();
      }

      protected StableRequest<T> Request<T>(string url, RequestMethod method, object? data = null)
      {
        var request = new StableRequest<T>(url, method, data, this.secret);

        return request;
      }

      public bool IsReady()
      {
        if (_RustApp == null || !_RustApp.IsLoaded)
        {
          Destroy(this);
          return false;
        }

        if (secret == null)
        {
          Interface.Oxide.LogWarning("Unexpected exception, secret is missing. Contact support: https://vk.com/rustapp");
          return false;
        }

        return true;
      }

      public bool IsAuthed()
      {
        return _RustApp != null && _RustApp.IsLoaded && secret != null && secret.Length > 0;
      }

      protected virtual void OnReady() { }
    }

    #endregion

    #region Configuration

    private class Configuration
    {

      [JsonProperty("[UI] Chat commands")]
      public List<string> report_ui_commands = new List<string>();

      [JsonProperty("[UI] Report reasons")]
      public List<string> report_ui_reasons = new List<string>();

      [JsonProperty("[UI] Cooldown between reports (seconds)")]
      public int report_ui_cooldown = 300;

      [JsonProperty("[UI] Auto-parse reports from F7 (ingame reports)")]
      public bool report_ui_auto_parse = true;

      [JsonProperty("[UI • Starter Plan] Show 'recently checked' checkbox (amount of days)")]
      public int report_ui_show_check_in = 7;

      [JsonProperty("[Chat] SteamID for message avatar (default account contains RustApp logo)")]
      public string chat_default_avatar_steamid = "76561198134964268";

      [JsonProperty("[Chat] Global message format")]
      public string chat_global_format = "<size=12><color=#ffffffB3>Сообщение от Администратора</color></size>\n<color=#AAFF55>%CLIENT_TAG%</color>: %MSG%";

      [JsonProperty("[Chat] Direct message format")]
      public string chat_direct_format = "<size=12><color=#ffffffB3>ЛС от Администратора</color></size>\n<color=#AAFF55>%CLIENT_TAG%</color>: %MSG%";

      [JsonProperty("[Check] Command to send contact")]
      public string check_contact_command = "contact";

      [JsonProperty("[Ban] Enable broadcast server bans")]
      public bool ban_enable_broadcast = true;

      [JsonProperty("[Ban] Ban broadcast format")]
      public string ban_broadcast_format = "Игрок <color=#55AAFF>%TARGET%</color> <color=#bdbdbd></color>был заблокирован.\n<size=12>- причина: <color=#d3d3d3>%REASON%</color></size>";

      [JsonProperty("[Ban] Kick message format (%REASON% - ban reason)")]
      public string ban_reason_format = "Вы навсегда забанены на этом сервере причина: %REASON%";

      [JsonProperty("[Ban] Kick message format temporary (%REASON% - ban reason)")]
      public string ban_reason_format_temporary = "Вы забанены на этом сервере до %TIME% МСК, причина: %REASON%";

      [JsonProperty("[Ban] Message format when kicking due to IP")]
      public string ban_reason_ip_format = "Вам ограничен вход на сервер!";

      [JsonProperty("[Ban-Sync] Kick message format (%REASON% - ban reason)")]
      public string ban_sync_reason_format = "Обнаружена блокировка на другом проекте, причина: %REASON%";

      [JsonProperty("[Ban-Sync] Kick message format temporary (%REASON% - ban reason)")]
      public string ban_sync_reason_format_temporary = "Обнаружена блокировка на другом проекте до %TIME% МСК, причина: %REASON%";

      [JsonProperty("[Custom Actions] Allow custom actions")]
      public bool custom_actions_allow = true;

      public static Configuration Generate()
      {
        return new Configuration
        {
          report_ui_commands = new List<string> { "report", "reports" },
          report_ui_reasons = new List<string> { "Чит", "Макрос", "Багоюз" },
          report_ui_cooldown = 300,
          report_ui_auto_parse = true,
          report_ui_show_check_in = 7,

          chat_default_avatar_steamid = "76561198134964268",
          chat_global_format = "<size=12><color=#ffffffB3>Сообщение от Администратора</color></size>\n<color=#AAFF55>%CLIENT_TAG%</color>: %MSG%",
          chat_direct_format = "<size=12><color=#ffffffB3>ЛС от Администратора</color></size>\n<color=#AAFF55>%CLIENT_TAG%</color>: %MSG%",

          ban_enable_broadcast = true,
          ban_broadcast_format = "Игрок <color=#55AAFF>%TARGET%</color> <color=#bdbdbd></color>был заблокирован.\n<size=12>- причина: <color=#d3d3d3>%REASON%</color></size>",

          ban_reason_format = "Вы навсегда забанены на этом сервере, причина: %REASON%",
          ban_reason_format_temporary = "Вы забанены на этом сервере до %TIME% МСК, причина: %REASON%",
          ban_reason_ip_format = "Вам ограничен вход на сервер!",

          ban_sync_reason_format = "Обнаружена блокировка на другом проекте, причина: %REASON%",
          ban_sync_reason_format_temporary = "Обнаружена блокировка на другом проекте до %TIME% МСК, причина: %REASON%",

          custom_actions_allow = true
        };
      }
    }


    protected override void LoadConfig()
    {
      base.LoadConfig();
      try
      {
        _Settings = Config.ReadObject<Configuration>();
      }
      catch
      {
        PrintWarning($"Error reading config, creating one new config!");
        LoadDefaultConfig();
      }

      SaveConfig();
    }

    protected override void LoadDefaultConfig() => _Settings = Configuration.Generate();
    protected override void SaveConfig() => Config.WriteObject(_Settings);

    #endregion

    #region Interfaces

    private static string ReportLayer = "UI_RP_ReportPanelUI";
    private void DrawReportInterface(BasePlayer player, int page = 0, string search = "", bool redraw = false)
    {
      var lineAmount = 6;
      var lineMargin = 8;

      var size = (float)(700 - lineMargin * lineAmount) / lineAmount;
      var list = BasePlayer.activePlayerList
          .ToList();

      var finalList = list
          .FindAll(v => v.displayName.ToLower().Contains(search) || v.UserIDString.ToLower().Contains(search) || search == null)
          .Skip(page * 18)
          .Take(18);

      if (finalList.Count() == 0)
      {
        if (search == null)
        {
          DrawReportInterface(player, page - 1);
          return;
        }
      }

      CuiElementContainer container = new CuiElementContainer();

      if (!redraw)
      {
        container.Add(new CuiPanel
        {
          CursorEnabled = true,
          RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
          Image = { Color = "0 0 0 0.8", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
        }, "Overlay", ReportLayer, ReportLayer);

        container.Add(new CuiButton()
        {
          RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
          Button = { Color = HexToRustFormat("#343434"), Sprite = "assets/content/ui/ui.background.transparent.radial.psd", Close = ReportLayer },
          Text = { Text = "" }
        }, ReportLayer);
      }

      container.Add(new CuiPanel
      {
        RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-368 -200", OffsetMax = "368 142" },
        Image = { Color = "1 0 0 0" }
      }, ReportLayer, ReportLayer + ".C", ReportLayer + ".C");

      container.Add(new CuiPanel
      {
        RectTransform = { AnchorMin = "1 0", AnchorMax = "1 1", OffsetMin = "-36 0", OffsetMax = "0 0" },
        Image = { Color = "0 0 1 0" }
      }, ReportLayer + ".C", ReportLayer + ".R");

      //↓ ↑

      container.Add(new CuiButton()
      {
        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.5", OffsetMin = "0 0", OffsetMax = "0 -4" },
        Button = { Color = HexToRustFormat($"#{(list.Count > 18 && finalList.Count() == 18 ? "D0C6BD4D" : "D0C6BD33")}"), Command = list.Count > 18 && finalList.Count() == 18 ? $"UI_RP_ReportPanel search {page + 1}" : "" },
        Text = { Text = "↓", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 24, Color = HexToRustFormat($"{(list.Count > 18 && finalList.Count() == 18 ? "D0C6BD" : "D0C6BD4D")}") }
      }, ReportLayer + ".R", ReportLayer + ".RD");

      container.Add(new CuiButton()
      {
        RectTransform = { AnchorMin = "0 0.5", AnchorMax = "1 1", OffsetMin = "0 4", OffsetMax = "0 0" },
        Button = { Color = HexToRustFormat($"#{(page == 0 ? "D0C6BD33" : "D0C6BD4D")}"), Command = page == 0 ? "" : $"UI_RP_ReportPanel search {page - 1}" },
        Text = { Text = "↑", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 24, Color = HexToRustFormat($"{(page == 0 ? "D0C6BD4D" : "D0C6BD")}") }
      }, ReportLayer + ".R", ReportLayer + ".RU");

      container.Add(new CuiPanel
      {
        RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-250 8", OffsetMax = "0 43" },
        Image = { Color = HexToRustFormat("#D0C6BD33") }
      }, ReportLayer + ".C", ReportLayer + ".S");

      container.Add(new CuiElement
      {
        Parent = ReportLayer + ".S",
        Components =
            {
                new CuiInputFieldComponent { Text = $"{lang.GetMessage("Header.Search.Placeholder", this, player.UserIDString)}", FontSize = 14, Font = "robotocondensed-regular.ttf", Color = HexToRustFormat("#D0C6BD80"), Align = TextAnchor.MiddleLeft, Command = "UI_RP_ReportPanel search 0", NeedsKeyboard = true},
                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "10 0", OffsetMax = "-85 0"}
            }
      });

      container.Add(new CuiButton
      {
        RectTransform = { AnchorMin = "1 0", AnchorMax = "1 1", OffsetMin = "-75 0", OffsetMax = "0 0" },
        Button = { Color = HexToRustFormat("#D0C6BD"), Material = "assets/icons/greyout.mat" },
        Text = { Text = $"{lang.GetMessage("Header.Search", this, player.UserIDString)}", Font = "robotocondensed-bold.ttf", Color = HexToRustFormat("#443F3B"), FontSize = 14, Align = TextAnchor.MiddleCenter }
      }, ReportLayer + ".S", ReportLayer + ".SB");

      container.Add(new CuiPanel
      {
        RectTransform = { AnchorMin = "0 1", AnchorMax = "0.5 1", OffsetMin = "0 7", OffsetMax = "0 47" },
        Image = { Color = "0.8 0.8 0.8 0" }
      }, ReportLayer + ".C", ReportLayer + ".LT");

      container.Add(new CuiLabel()
      {
        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" },
        Text = { Text = $"{lang.GetMessage("Header.Find", this, player.UserIDString)} {(search != null && search.Length > 0 ? $"- {(search.Length > 20 ? search.Substring(0, 14).ToUpper() + "..." : search.ToUpper())}" : "")}", Font = "robotocondensed-bold.ttf", Color = HexToRustFormat("#D0C6BD"), FontSize = 24, Align = TextAnchor.UpperLeft }
      }, ReportLayer + ".LT");

      container.Add(new CuiLabel()
      {
        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" },
        Text = { Text = search == null || search.Length == 0 ? lang.GetMessage("Header.SubDefault", this, player.UserIDString) : finalList.Count() == 0 ? lang.GetMessage("Header.SubFindEmpty", this, player.UserIDString) : lang.GetMessage("Header.SubFindResults", this, player.UserIDString), Font = "robotocondensed-regular.ttf", Color = HexToRustFormat("#D0C6BD4D"), FontSize = 14, Align = TextAnchor.LowerLeft }
      }, ReportLayer + ".LT");


      container.Add(new CuiPanel
      {
        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "-40 0" },
        Image = { Color = "0 1 0 0" }
      }, ReportLayer + ".C", ReportLayer + ".L");

      for (var y = 0; y < 3; y++)
      {
        for (var x = 0; x < 6; x++)
        {
          var target = finalList.ElementAtOrDefault(y * 6 + x);
          if (target)
          {
            container.Add(new CuiPanel
            {
              RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = $"{x * size + lineMargin * x} -{(y + 1) * size + lineMargin * y}", OffsetMax = $"{(x + 1) * size + lineMargin * x} -{y * size + lineMargin * y}" },
              Image = { Color = HexToRustFormat("#D0C6BD33") }
            }, ReportLayer + ".L", ReportLayer + $".{target.UserIDString}");

            container.Add(new CuiElement
            {
              Parent = ReportLayer + $".{target.UserIDString}",
              Components =
                        {
                            new CuiRawImageComponent { Png = (string) plugins.Find("ImageLibrary").Call("GetImage", target.UserIDString), Sprite = "assets/icons/loading.png" },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" }
                        }
            });

            container.Add(new CuiPanel()
            {
              RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" },
              Image = { Sprite = "assets/content/ui/ui.background.transparent.linear.psd", Color = HexToRustFormat("#282828f2") }
            }, ReportLayer + $".{target.UserIDString}");

            string normaliseName = NormalizeString(target.displayName);

            string name = normaliseName.Length > 14 ? normaliseName.Substring(0, 15) + ".." : normaliseName;

            container.Add(new CuiLabel
            {
              RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "6 16", OffsetMax = "0 0" },
              Text = { Text = name, Align = TextAnchor.LowerLeft, Font = "robotocondensed-bold.ttf", FontSize = 13, Color = HexToRustFormat("#D0C6BD") }
            }, ReportLayer + $".{target.UserIDString}");

            container.Add(new CuiLabel
            {
              RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "6 5", OffsetMax = "0 0" },
              Text = { Text = target.UserIDString, Align = TextAnchor.LowerLeft, Font = "robotocondensed-regular.ttf", FontSize = 10, Color = HexToRustFormat("#D0C6BD80") }
            }, ReportLayer + $".{target.UserIDString}");

            container.Add(new CuiButton()
            {
              RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" },
              Button = { Color = "0 0 0 0", Command = $"UI_RP_ReportPanel show {target.UserIDString} {x * size + lineMargin * x} -{(y + 1) * size + lineMargin * y} {(x + 1) * size + lineMargin * x} -{y * size + lineMargin * y}  {x >= 3}" },
              Text = { Text = "" }
            }, ReportLayer + $".{target.UserIDString}");

            var was_checked = _Checks.LastChecks.ContainsKey(target.UserIDString) && CurrentTime() - _Checks.LastChecks[target.UserIDString] < _Settings.report_ui_show_check_in * 24 * 60 * 60;
            if (was_checked)
            {
              container.Add(new CuiPanel
              {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "5 -25", OffsetMax = "-5 -5" },
                Image = { Color = "0.239 0.568 0.294 1", Material = "assets/icons/greyout.mat" },
              }, ReportLayer + $".{target.UserIDString}", ReportLayer + $".{target.UserIDString}.Recent");

              container.Add(new CuiLabel
              {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" },
                Text = { Text = lang.GetMessage("UI.CheckMark", this, player.UserIDString), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "0.639 0.968 0.694 1" }
              }, ReportLayer + $".{target.UserIDString}.Recent");
            }
          }
          else
          {
            container.Add(new CuiPanel
            {
              RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = $"{x * size + lineMargin * x} -{(y + 1) * size + lineMargin * y}", OffsetMax = $"{(x + 1) * size + lineMargin * x} -{y * size + lineMargin * y}" },
              Image = { Color = HexToRustFormat("#D0C6BD33") }
            }, ReportLayer + ".L");
          }
        }
      }

      CuiHelper.AddUi(player, container);
    }

    private const string CheckLayer = "RP_PrivateLayer";

    private void DrawInterface(BasePlayer player)
    {
      CuiHelper.DestroyUi(player, CheckLayer);
      CuiElementContainer container = new CuiElementContainer();

      container.Add(new CuiButton
      {
        RectTransform = { AnchorMin = "0 0.5", AnchorMax = "1 1", OffsetMin = $"-500 -500", OffsetMax = $"500 500" },
        Button = { Color = HexToRustFormat("#1C1C1C"), Sprite = "assets/content/ui/ui.circlegradient.png" },
        Text = { Text = "", Align = TextAnchor.MiddleCenter }
      }, "Under", CheckLayer);

      string text = lang.GetMessage("Check.Text", this, player.UserIDString);

      container.Add(new CuiLabel
      {
        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
        Text = { Text = text, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 16 }
      }, CheckLayer);

      CuiHelper.AddUi(player, container);

      Effect effect = new Effect("ASSETS/BUNDLED/PREFABS/FX/INVITE_NOTICE.PREFAB".ToLower(), player, 0, new Vector3(), new Vector3());
      EffectNetwork.Send(effect, player.Connection);
    }

    private static string HexToRustFormat(string hex)
    {
      if (string.IsNullOrEmpty(hex))
      {
        hex = "#FFFFFFFF";
      }

      var str = hex.Trim('#');

      if (str.Length == 6)
        str += "FF";

      if (str.Length != 8)
      {
        throw new Exception(hex);
        throw new InvalidOperationException("Cannot convert a wrong format.");
      }

      var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
      var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
      var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
      var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

      UnityEngine.Color color = new Color32(r, g, b, a);

      return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
    }

    #endregion

    #region Variables

    private CourtWorker _Worker;
    private Dictionary<ulong, double> _Cooldowns = new Dictionary<ulong, double>();

    private static RustApp _RustApp;
    private static Configuration _Settings;
    private static CheckInfo _Checks = CheckInfo.Read();



    // References for RB plugins to get RB status
    [PluginReference] private Plugin NoEscape, RaidZone, RaidBlock, MultiFighting;

    #endregion 

    #region Initialization

    private void OnServerInitialized()
    {
      _RustApp = this;

      if (plugins.Find("RustAppLite") != null && plugins.Find("RustAppLite").IsLoaded)
      {
        Error(
          "Обнаружена 'Lite' версия плагина, для начала удалите RustAppLite.cs",
          "Detected 'Lite' version of plugin, delete RustAppLite.cs to start"
        );
        return;
      }

      if (plugins.Find("ImageLibrary") == null)
      {
        Error(
          "Для работы плагина необходим установленный ImageLibrary",
          "For plugin correct works need to install ImageLibrary"
        );
        return;
      }

      timer.Once(1, () =>
      {
        _Worker = ServerMgr.Instance.gameObject.AddComponent<CourtWorker>();
      });

      RegisterMessages();
    }

    private void RegisterMessages()
    {
      lang.RegisterMessages(new Dictionary<string, string>
      {
        ["Header.Find"] = "FIND PLAYER",
        ["Header.SubDefault"] = "Who do you want to report?",
        ["Header.SubFindResults"] = "Here are players, which we found",
        ["Header.SubFindEmpty"] = "No players was found",
        ["Header.Search"] = "Search",
        ["Header.Search.Placeholder"] = "Enter nickname/steamid",
        ["Subject.Head"] = "Select the reason for the report",
        ["Subject.SubHead"] = "For player %PLAYER%",
        ["Cooldown"] = "Wait %TIME% sec.",
        ["Sent"] = "Report succesful sent",
        ["Contact.Error"] = "You did not sent your Discord",
        ["Contact.Sent"] = "You sent:",
        ["Contact.SentWait"] = "If you sent the correct discord - wait for a friend request.",
        ["Check.Text"] = "<color=#c6bdb4><size=32><b>YOU ARE SUMMONED FOR A CHECK-UP</b></size></color>\n<color=#958D85>You have <color=#c6bdb4><b>3 minutes</b></color> to send discord and accept the friend request.\nUse the <b><color=#c6bdb4>/contact</color></b> command to send discord.\n\nTo contact a moderator - use chat, not a command.</color>",
        ["Chat.Direct.Toast"] = "Received a message from admin, look at the chat!",
        ["UI.CheckMark"] = "Checked",
        ["Paid.Announce.Clean"] = "Your complaint about \"%SUSPECT_NAME%\" has been checked!\n<size=12><color=#81C5F480>As a result of the check, no violations were found</color ></size>",
        ["Paid.Announce.Ban"] = "Your complaint about \"%SUSPECT_NAME%\" has been verified!\n<color=#F7D4D080><size=12>Player banned, reason: %REASON%</ size></color>",
      }, this, "en");

      lang.RegisterMessages(new Dictionary<string, string>
      {
        ["Header.Find"] = "НАЙТИ ИГРОКА",
        ["Header.SubDefault"] = "На кого вы хотите пожаловаться?",
        ["Header.SubFindResults"] = "Вот игроки, которых мы нашли",
        ["Header.SubFindEmpty"] = "Игроки не найдены",
        ["Header.Search"] = "Поиск",
        ["Header.Search.Placeholder"] = "Введите ник/steamid",
        ["Subject.Head"] = "Выберите причину репорта",
        ["Subject.SubHead"] = "На игрока %PLAYER%",
        ["Cooldown"] = "Подожди %TIME% сек.",
        ["Sent"] = "Жалоба успешно отправлена",
        ["Contact.Error"] = "Вы не отправили свой Discord",
        ["Contact.Sent"] = "Вы отправили:",
        ["Contact.SentWait"] = "<size=12>Если вы отправили корректный дискорд - ждите заявку в друзья.</size>",
        ["Check.Text"] = "<color=#c6bdb4><size=32><b>ВЫ ВЫЗВАНЫ НА ПРОВЕРКУ</b></size></color>\n<color=#958D85>У вас есть <color=#c6bdb4><b>3 минуты</b></color> чтобы отправить дискорд и принять заявку в друзья.\nИспользуйте команду <b><color=#c6bdb4>/contact</color></b> чтобы отправить дискорд.\n\nДля связи с модератором - используйте чат, а не команду.</color>",
        ["Chat.Direct.Toast"] = "Получено сообщение от админа, посмотрите в чат!",
        ["UI.CheckMark"] = "Проверен",
        ["Paid.Announce.Clean"] = "Ваша жалоба на \"%SUSPECT_NAME%\" была проверена!\n<size=12><color=#81C5F480>В результате проверки, нарушений не обнаружено</color></size>",
        ["Paid.Announce.Ban"] = "Ваша жалоба на \"%SUSPECT_NAME%\" была проверена!\n<color=#F7D4D080><size=12>Игрок заблокирован, причина: %REASON%</size></color>",
      }, this, "ru");
    }


    private void Unload()
    {
      UnityEngine.Object.Destroy(_Worker);

      foreach (var player in BasePlayer.activePlayerList)
      {
        CuiHelper.DestroyUi(player, CheckLayer);
        CuiHelper.DestroyUi(player, ReportLayer);
      }
    }

    #endregion

    #region API

    private void RA_DirectMessageHandler(string from, string to, string message)
    {
      _Worker?.Update.SaveChat(new PluginChatMessageEntry
      {
        steam_id = from,
        target_steam_id = to,
        is_team = false,

        text = message
      });
    }

    private void RA_ReportSend(string initiator_steam_id, string target_steam_id, string reason, string message = "")
    {
      _Worker?.Update.SaveReport(new PluginReportEntry
      {
        initiator_steam_id = initiator_steam_id,
        target_steam_id = target_steam_id,
        sub_targets_steam_ids = new List<string>(),
        message = message,
        reason = reason
      });
    }

    private void RA_CustomAlert(string message, object data = null)
    {
      _Worker?.Action.SendCustomAlert(message, data);
    }

    #endregion

    #region Interface



    #endregion

    #region Hooks

    private void OnPlayerReported(BasePlayer reporter, string targetName, string targetId, string subject, string message, string type)
    {
      if (!_Settings.report_ui_auto_parse)
      {
        return;
      }

      var target = BasePlayer.Find(targetId) ?? BasePlayer.FindSleeping(targetId);
      if (target == null)
      {
        return;
      }

      RA_ReportSend(reporter.UserIDString, targetId, type, message);
    }

    private void OnStashExposed(StashContainer stash, BasePlayer player)
    {
      if (stash == null)
      {
        return;
      }

      var team = player.Team;
      if (team != null)
      {
        if (team.members.Contains(stash.OwnerID))
        {
          return;
        }
      }

      var owner = stash.OwnerID;

      if (player.userID == stash.OwnerID || owner == 0)
      {
        return;
      }

      _Worker.Update.SaveAlert(new PluginPlayerAlertEntry
      {
        type = PlayerAlertType.dug_up_stash,
        meta = new PluginPlayerAlertDugUpStashMeta
        {
          owner_steam_id = owner.ToString(),
          position = player.transform.position.ToString(),
          square = GridReference(player.transform.position),
          steam_id = player.UserIDString
        }
      });
    }

    private void CanUserLogin(string name, string id, string ipAddress)
    {
      _Worker?.Ban.FetchBan(id, ipAddress);
    }

    private void OnPlayerDisconnected(BasePlayer player, string reason)
    {
      if (_Worker.Queue.Notices.ContainsKey(player.UserIDString))
      {
        _Worker.Queue.Notices.Remove(player.UserIDString);
      }

      _Worker?.Update.SaveDisconnect(player, reason);
    }

    private void OnTeamKick(RelationshipManager.PlayerTeam team, BasePlayer player, ulong target)
    {
      _Worker?.Update.SaveTeamHistory(player.UserIDString, target.ToString());
    }

    private void OnTeamDisband(RelationshipManager.PlayerTeam team)
    {
      team.members.ForEach(v => _Worker?.Update.SaveTeamHistory(v.ToString(), v.ToString()));
    }

    private void OnTeamLeave(RelationshipManager.PlayerTeam team, BasePlayer player)
    {
      if (team.members.Count == 1)
      {
        return;
      }

      _Worker?.Update.SaveTeamHistory(player.UserIDString, player.UserIDString);
    }

    private void OnPlayerChat(BasePlayer player, string message, ConVar.Chat.ChatChannel channel)
    {
      // Сохраняем только глобальный и командный чат
      if (channel != ConVar.Chat.ChatChannel.Team && channel != ConVar.Chat.ChatChannel.Global)
      {
        return;
      }

      _Worker?.Update.SaveChat(new PluginChatMessageEntry
      {
        steam_id = player.UserIDString,

        is_team = channel == ConVar.Chat.ChatChannel.Team,

        text = message
      });
    }

    private void OnEntityKill(BaseNetworkable entity)
    {
      if (entity?.net?.ID == null || entity?.net?.ID.Value == null || entity?.ShortPrefabName == null)
      {
        return;
      }

      var whiteList = new List<string> { "photoframe", "spinner.wheel" };

      if (!entity.ShortPrefabName.StartsWith("sign.") || whiteList.Any(v => entity.ShortPrefabName.Contains(v)))
      {
        return;
      }

      if (_Worker?.Update == null || !_Worker.Update.IsReady())
      {
        return;
      }

      _Worker.Update.SaveDestroyedSign(entity.net.ID.Value.ToString());
    }

    private void OnNewSave(string saveName)
    {
      timer.Once(10, () =>
      {
        _Worker.Action.SendWipe((a) => { });
      });
    }

    #endregion

    #region UX

    private void CmdChatContact(BasePlayer player, string command, string[] args)
    {
      if (args.Length == 0)
      {
        SendMessage(player, lang.GetMessage("Contact.Error", this, player.UserIDString));
        return;
      }

      _Worker?.Action.SendContact(player.UserIDString, String.Join(" ", args), (accepted) =>
      {
        if (!accepted)
        {
          return;
        }

        SendMessage(player, lang.GetMessage("Contact.Sent", this, player.UserIDString) + $"<color=#8393cd> {String.Join(" ", args)}</color>");
        SendMessage(player, lang.GetMessage("Contact.SentWait", this, player.UserIDString));
      });
    }

    #endregion

    #region Commands

    [ConsoleCommand("UI_RP_ReportPanel")]
    private void CmdConsoleReportPanel(ConsoleSystem.Arg args)
    {
      var player = args.Player();
      if (player == null || !args.HasArgs(1))
      {
        return;
      }

      switch (args.Args[0].ToLower())
      {
        case "search":
          {
            int page = args.HasArgs(2) ? int.Parse(args.Args[1]) : 0;
            string search = args.HasArgs(3) ? args.Args[2] : "";

            Effect effect = new Effect("assets/prefabs/tools/detonator/effects/unpress.prefab", player, 0, new Vector3(), new Vector3());
            EffectNetwork.Send(effect, player.Connection);

            DrawReportInterface(player, page, search, true);
            break;
          }
        case "show":
          {
            string targetId = args.Args[1];
            BasePlayer target = BasePlayer.Find(targetId) ?? BasePlayer.FindSleeping(targetId);

            Effect effect = new Effect("assets/prefabs/tools/detonator/effects/unpress.prefab", player, 0, new Vector3(), new Vector3());
            EffectNetwork.Send(effect, player.Connection);

            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, ReportLayer + $".T");

            container.Add(new CuiPanel
            {
              RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = $"{args.Args[2]} {args.Args[3]}", OffsetMax = $"{args.Args[4]} {args.Args[5]}" },
              Image = { Color = "0 0 0 1" }
            }, ReportLayer + $".L", ReportLayer + $".T");


            container.Add(new CuiButton()
            {
              RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"-500 -500", OffsetMax = $"500 500" },
              Button = { Close = $"{ReportLayer}.T", Color = "0 0 0 1", Sprite = "assets/content/ui/ui.circlegradient.png" }
            }, ReportLayer + $".T");


            bool leftAlign = bool.Parse(args.Args[6]);
            container.Add(new CuiButton()
            {
              RectTransform = { AnchorMin = $"{(leftAlign ? -1 : 2)} 0", AnchorMax = $"{(leftAlign ? -2 : 3)} 1", OffsetMin = $"-500 -500", OffsetMax = $"500 500" },
              Button = { Close = $"{ReportLayer}.T", Color = HexToRustFormat("#343434"), Sprite = "assets/content/ui/ui.circlegradient.png" }
            }, ReportLayer + $".T");

            container.Add(new CuiButton()
            {
              RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"-1111111 -1111111", OffsetMax = $"1111111 1111111" },
              Button = { Close = $"{ReportLayer}.T", Color = "0 0 0 0.5", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            }, ReportLayer + $".T");


            container.Add(new CuiLabel
            {
              RectTransform = { AnchorMin = $"{(leftAlign ? "0" : "1")} 0", AnchorMax = $"{(leftAlign ? "0" : "1")} 1", OffsetMin = $"{(leftAlign ? "-350" : "20")} 0", OffsetMax = $"{(leftAlign ? "-20" : "350")} -5" },
              Text = { FadeIn = 0.4f, Text = lang.GetMessage("Subject.Head", this, player.UserIDString), Font = "robotocondensed-bold.ttf", Color = HexToRustFormat("#D0C6BD"), FontSize = 24, Align = leftAlign ? TextAnchor.UpperRight : TextAnchor.UpperLeft }
            }, ReportLayer + ".T");

            container.Add(new CuiLabel
            {
              RectTransform = { AnchorMin = $"{(leftAlign ? "0" : "1")} 0", AnchorMax = $"{(leftAlign ? "0" : "1")} 1", OffsetMin = $"{(leftAlign ? "-250" : "20")} 0", OffsetMax = $"{(leftAlign ? "-20" : "250")} -35" },
              Text = { FadeIn = 0.4f, Text = $"{lang.GetMessage("Subject.SubHead", this, player.UserIDString).Replace("%PLAYER%", $"<b>{target.displayName}</b>")}", Font = "robotocondensed-regular.ttf", Color = HexToRustFormat("#D0C6BD80"), FontSize = 14, Align = leftAlign ? TextAnchor.UpperRight : TextAnchor.UpperLeft }
            }, ReportLayer + ".T");

            container.Add(new CuiElement
            {
              Parent = ReportLayer + $".T",
              Components =
              {
                  new CuiRawImageComponent { Png = (string) plugins.Find("ImageLibrary").Call("GetImage", target.UserIDString), Sprite = "assets/icons/loading.png" },
                  new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" }
              }
            });

            var was_checked = _Checks.LastChecks.ContainsKey(target.UserIDString) && CurrentTime() - _Checks.LastChecks[target.UserIDString] < _Settings.report_ui_show_check_in * 24 * 60 * 60;
            if (was_checked)
            {
              container.Add(new CuiPanel
              {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "5 -25", OffsetMax = "-5 -5" },
                Image = { Color = "0.239 0.568 0.294 1", Material = "assets/icons/greyout.mat" },
              }, ReportLayer + $".T", ReportLayer + $".T.Recent");

              container.Add(new CuiLabel
              {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" },
                Text = { Text = lang.GetMessage("UI.CheckMark", this, player.UserIDString), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "0.639 0.968 0.694 1" }
              }, ReportLayer + $".T.Recent");
            }

            for (var i = 0; i < _Settings.report_ui_reasons.Count; i++)
            {
              var offXMin = (20 + (i * 5)) + i * 80;
              var offXMax = 20 + (i * 5) + (i + 1) * 80;

              container.Add(new CuiButton()
              {
                RectTransform = { AnchorMin = $"{(leftAlign ? 0 : 1)} 0", AnchorMax = $"{(leftAlign ? 0 : 1)} 0", OffsetMin = $"{(leftAlign ? -offXMax : offXMin)} 15", OffsetMax = $"{(leftAlign ? -offXMin : offXMax)} 45" },
                Button = { FadeIn = 0.4f + i * 0.2f, Color = HexToRustFormat("#D0C6BD4D"), Command = $"UI_RP_ReportPanel report {target.UserIDString} {_Settings.report_ui_reasons[i].Replace(" ", "0")}" },
                Text = { FadeIn = 0.4f + i * 0.2f, Text = $"{_Settings.report_ui_reasons[i]}", Align = TextAnchor.MiddleCenter, Color = HexToRustFormat("#D0C6BD"), Font = "robotocondensed-bold.ttf", FontSize = 16 }
              }, ReportLayer + $".T");
            }

            CuiHelper.AddUi(player, container);
            break;
          }
        case "report":
          {
            if (!_Cooldowns.ContainsKey(player.userID))
            {
              _Cooldowns.Add(player.userID, 0);
            }

            if (_Cooldowns[player.userID] > CurrentTime())
            {
              var msg = lang.GetMessage("Cooldown", this, player.UserIDString).Replace("%TIME%",
                  $"{(_Cooldowns[player.userID] - CurrentTime()).ToString("0")}");

              SoundToast(player, msg, 1);
              return;
            }

            string targetId = args.Args[1];
            string reason = args.Args[2].Replace("0", "");

            BasePlayer target = BasePlayer.Find(targetId) ?? BasePlayer.FindSleeping(targetId);

            RA_ReportSend(player.UserIDString, target.UserIDString, reason, "");
            CuiHelper.DestroyUi(player, ReportLayer);

            SoundToast(player, lang.GetMessage("Sent", this, player.UserIDString), 2);

            if (!_Cooldowns.ContainsKey(player.userID))
            {
              _Cooldowns.Add(player.userID, 0);
            }

            _Cooldowns[player.userID] = CurrentTime() + _Settings.report_ui_cooldown;
            break;
          }
      }
    }

    private void ChatCmdReport(BasePlayer player)
    {
      var over = Interface.Oxide.CallHook("RustApp_CanOpenReportUI", player);
      if (over != null)
      {
        return;
      }

      if (!_Cooldowns.ContainsKey(player.userID))
      {
        _Cooldowns.Add(player.userID, 0);
      }

      if (_Cooldowns[player.userID] > CurrentTime())
      {
        var msg = lang.GetMessage("Cooldown", this, player.UserIDString).Replace("%TIME%",
            $"{(_Cooldowns[player.userID] - CurrentTime()).ToString("0")}");

        SoundToast(player, msg, 1);
        return;
      }

      DrawReportInterface(player);
    }

    [ConsoleCommand("ra.help")]
    private void CmdConsoleHelp(ConsoleSystem.Arg args)
    {
      if (args.Player() != null)
      {
        return;
      }

      Log(
        "Помощь по командам RustApp",
        "Command help for RustApp"
      );
      Log(
        "ra.debug - показать список последних ошибок",
        "ra.debug - show list of recent errors"
      );
      Log(
        "ra.pair <key> - подключение сервера (ключ можно получить на сайте)",
        "ra.pair <key> - connect server (key can be obtained on the website)"
      );
    }

    [ConsoleCommand("ra.debug")]
    private void CmdConsoleStatus(ConsoleSystem.Arg args)
    {
      if (!args.IsAdmin)
      {
        return;
      }

      if (LastException.History.Count == 0)
      {
        Log(
          "Ни одной ошибки не найдено",
          "No errors found"
        );
        return;
      }

      Log(
        "Список последних ошибок в запросах:",
        "List of recent errors in requests:"
      );


      foreach (var value in LastException.History)
      {
        var diff = (DateTime.Now - value.time).TotalSeconds;

        string diffText = diff.ToString("F2") + Msg("сек. назад", "secs ago");

        Puts($"{value.module} ({diffText})");

        if (args.Args?.Length >= 1)
        {
          Puts($"> {value.payload} [{value.secret}]");
        }
        Puts($"< {value.response}");
      }
    }

    [ConsoleCommand("ra.ban_server")]
    private void CmdConsoleBanServerDeprecated(ConsoleSystem.Arg args)
    {
      if (args.Player() != null && !args.Player().IsAdmin)
      {
        return;
      }

      Log(
        "Команда 'ra.ban_server' устарела и скоро будет удалена",
        "Command 'ra.ban_server' deprecated and will be deleted soon"
      );

      if (!args.HasArgs(2))
      {
        Log(
          "ra.ban_server <steam_id> <reason> <duration?>\n<duration> - необязателен, заполняется в формате 2d5h",
          "ra.ban_server <steam_id> <причина> <время?>\n<duration> - optional, use as 2d10h"
        );
        return;
      }

      var steam_id = args.Args[0];
      var reason = args.Args[1];
      var duration = args.HasArgs(3) ? args.Args[2] : "";

      _Worker.Action.SendBan(steam_id, reason, duration, false, true);
    }

    [ConsoleCommand("ra.ban_global")]
    private void CmdConsoleBanGlobalDeprecated(ConsoleSystem.Arg args)
    {
      if (args.Player() != null && !args.Player().IsAdmin)
      {
        return;
      }

      Log(
        "Команда 'ra.ban_global' устарела и скоро будет удалена",
        "Command 'ra.ban_global' deprecated and will be deleted soon"
      );

      if (!args.HasArgs(2))
      {
        Log(
          "ra.ban_global <steam_id> <reason> <duration?>\n<duration> - необязателен, заполняется в формате 2d5h",
          "ra.ban_global <steam_id> <причина> <время?>\n<duration> - optional, use as 2d10h"
        );
        return;
      }

      var steam_id = args.Args[0];
      var reason = args.Args[1];
      var duration = args.HasArgs(3) ? args.Args[2] : "";

      _Worker.Action.SendBan(steam_id, reason, duration, true, true);
    }

    [ConsoleCommand("ra.ban")]
    private void CmdConsoleBan(ConsoleSystem.Arg args)
    {
      if (args.Player() != null && !args.Player().IsAdmin)
      {
        return;
      }

      var clearArgs = (args.Args ?? new string[0]).Where(v => v != "--ban-ip" && v != "--global").ToList();

      if (clearArgs.Count() < 2)
      {
        Log(
          "Неверный формат команды!\nПравильный формат: ra.ban <steam-id> <причина> <время (необяз)>\n\nВозможны дополнительные опции:\n'--ban-ip' - заблокирует IP\n'--global' - заблокирует на всех серверах\n\nПример блокировки с IP, на всех серверах: ra.ban 7656119812110397 \"cheat\" 7d --ban-ip --global",
          "Incorrect command format!\nCorrect format: ra.ban <steam-id> <reason> <time (optional)>\n\nAdditional options are available:\n'--ban-ip' - bans IP\n'--global' - bans globally\n\nExample of banning with IP, globally: ra.ban 7656119812110397 \"cheat\" 7d --ban-ip --global"
        );
        return;
      }

      var steam_id = clearArgs[0];
      var reason = clearArgs[1];
      var duration = clearArgs.Count() == 3 ? clearArgs[2] : "";


      var global_bool = args.FullString.Contains("--global");
      var ip_bool = args.FullString.Contains("--ban-ip");

      _Worker.Action.SendBan(steam_id, reason, duration, global_bool, ip_bool);
    }

    [ConsoleCommand("ra.unban")]
    private void CmdConsoleBanDelete(ConsoleSystem.Arg args)
    {
      if (args.Player() != null && !args.Player().IsAdmin)
      {
        return;
      }

      var clearArgs = (args.Args ?? new string[0]).ToList();

      if (clearArgs.Count() != 1)
      {
        Log(
          "Неверный формат команды!\nПравильный формат: ra.unban <steam-id>",
          "Incorrect command format!\nCorrect format: ra.unban <steam-id>"
        );
        return;
      }

      var steam_id = clearArgs[0];

      _Worker.Action.SendBanDelete(steam_id);
    }

    [ConsoleCommand("ra.pair")]
    private void CmdConsoleCourtSetup(ConsoleSystem.Arg args)
    {
      if (args.Player() != null)
      {
        return;
      }

      if (!args.HasArgs(1))
      {
        return;
      }

      _Worker?.StartPair(args.Args[0]);
    }

    #endregion

    #region User Manipulation 

    private void SendGlobalMessage(string message)
    {
      foreach (var player in BasePlayer.activePlayerList)
      {
        SendMessage(player, message);
      }
    }

    private bool SendMessage(string steamId, string message)
    {
      var player = BasePlayer.Find(steamId);
      if (player == null || !player.IsConnected)
      {
        return false;
      }

      SendMessage(player, message);

      return true;
    }

    private void SendMessage(BasePlayer player, string message, string initiator_steam_id = "")
    {
      if (initiator_steam_id.Length == 0)
      {
        initiator_steam_id = _Settings.chat_default_avatar_steamid;
      }

      player.SendConsoleCommand("chat.add", 0, initiator_steam_id, message);
    }

    private void SoundInfoToast(BasePlayer player, string text)
    {
      SoundToast(player, text, 2);
    }

    private void SoundErrorToast(BasePlayer player, string text)
    {
      SoundToast(player, text, 1);
    }

    private void SoundToast(BasePlayer player, string text, int type)
    {
      Effect effect = new Effect("assets/bundled/prefabs/fx/notice/item.select.fx.prefab", player, 0, new Vector3(), new Vector3());
      EffectNetwork.Send(effect, player.Connection);

      player.Command("gametip.showtoast", type, text);
    }

    private bool CloseConnection(string steamId, string reason)
    {
      Log(
        $"Закрываем соединение с {steamId}: {reason}",
        $"Closing connection with {steamId}: {reason}"
      );

      var player = BasePlayer.Find(steamId);
      if (player != null && player.IsConnected)
      {
        player.Kick(reason);
        return true;
      }

      var connection = ConnectionAuth.m_AuthConnection.Find(v => v.userid.ToString() == steamId);
      if (connection != null)
      {
        Network.Net.sv.Kick(connection, reason);
        return true;
      }

      var loading = ServerMgr.Instance.connectionQueue.joining.Find(v => v.userid.ToString() == steamId);
      if (loading != null)
      {
        Network.Net.sv.Kick(loading, reason);
        return true;
      }

      var queued = ServerMgr.Instance.connectionQueue.queue.Find(v => v.userid.ToString() == steamId);
      if (queued != null)
      {
        Network.Net.sv.Kick(queued, reason);
        return true;
      }

      return false;
    }

    #endregion

    #region Utils

    private double CurrentTime() => DateTime.Now.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;

    private static List<char> Letters = new List<char> { '☼', 's', 't', 'r', 'e', 'т', 'ы', 'в', 'о', 'ч', 'х', 'а', 'р', 'u', 'c', 'h', 'a', 'n', 'z', 'o', '^', 'm', 'l', 'b', 'i', 'p', 'w', 'f', 'k', 'y', 'v', '$', '+', 'x', '1', '®', 'd', '#', 'г', 'ш', 'к', '.', 'я', 'у', 'с', 'ь', 'ц', 'и', 'б', 'е', 'л', 'й', '_', 'м', 'п', 'н', 'g', 'q', '3', '4', '2', ']', 'j', '[', '8', '{', '}', '_', '!', '@', '#', '$', '%', '&', '?', '-', '+', '=', '~', ' ', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'а', 'б', 'в', 'г', 'д', 'е', 'ё', 'ж', 'з', 'и', 'й', 'к', 'л', 'м', 'н', 'о', 'п', 'р', 'с', 'т', 'у', 'ф', 'х', 'ц', 'ч', 'ш', 'щ', 'ь', 'ы', 'ъ', 'э', 'ю', 'я' };

    private static string NormalizeString(string text)
    {
      string name = "";

      foreach (var @char in text)
      {
        if (Letters.Contains(@char.ToString().ToLower().ToCharArray()[0]))
          name += @char;
      }

      return name;
    }

    private static string GridReference(Vector3 position)
    {
      var chars = new string[] { "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "AA", "AB", "AC", "AD", "AE", "AF", "AG", "AH", "AI", "AJ", "AK", "AL", "AM", "AN", "AO", "AP", "AQ", "AR", "AS", "AT", "AU", "AV", "AW", "AX", "AY", "AZ" };

      const float block = 146;

      float size = ConVar.Server.worldsize;
      float offset = size / 2;

      float xpos = position.x + offset;
      float zpos = position.z + offset;

      int maxgrid = (int)(size / block);

      float xcoord = Mathf.Clamp(xpos / block, 0, maxgrid - 1);
      float zcoord = Mathf.Clamp(maxgrid - (zpos / block), 0, maxgrid - 1);

      string pos = string.Concat(chars[(int)xcoord], (int)zcoord);

      return (pos);
    }

    private long getUnixTime()
    {
      return ((DateTimeOffset)DateTime.UtcNow).ToUnixTimeSeconds();
    }

    private Network.Connection? getPlayerConnection(string steamId)
    {
      var player = BasePlayer.Find(steamId);
      if (player != null && player.IsConnected)
      {
        return player.Connection;
      }

      var joining = ServerMgr.Instance.connectionQueue.joining.Find(v => v.userid.ToString() == steamId);
      if (joining != null)
      {
        return joining;
      }

      var queued = ServerMgr.Instance.connectionQueue.queue.Find(v => v.userid.ToString() == steamId);
      if (queued != null)
      {
        return queued;
      }

      return null;
    }

    #endregion

    #region Messages

    public string Msg(string ru, string en)
    {
#if RU
      return ru;
#else
      return en;
#endif
    }

    public void Log(string ru, string en)
    {
#if RU
      Puts(ru);
#else
      Puts(en);
#endif
    }

    public void Warning(string ru, string en)
    {
#if RU
      PrintWarning(ru);
#else
      PrintWarning(en);
#endif
    }

    public void Error(string ru, string en)
    {
#if RU
      PrintError(ru);
#else
      PrintError(en);
#endif
    }

    #endregion

    #region SignFeed

    // A lot of code references at Discord Sign Logger by MJSU
    // Original author and plugin on UMod: https://umod.org/plugins/discord-sign-logger

    public abstract class BaseImageUpdate
    {
      public BasePlayer Player { get; }
      public ulong PlayerId { get; }
      public string DisplayName { get; }
      public BaseEntity Entity { get; }
      public int ItemId { get; protected set; }

      public uint TextureIndex { get; protected set; }
      public abstract bool SupportsTextureIndex { get; }

      protected BaseImageUpdate(BasePlayer player, BaseEntity entity)
      {
        Player = player;
        DisplayName = player.displayName;
        PlayerId = player.userID;
        Entity = entity;
      }

      public abstract byte[] GetImage();
    }

    public class FireworkUpdate : BaseImageUpdate
    {
      static readonly Hash<UnityEngine.Color, Brush> FireworkBrushes = new Hash<UnityEngine.Color, Brush>();

      public override bool SupportsTextureIndex => false;
      public PatternFirework Firework => (PatternFirework)Entity;

      public FireworkUpdate(BasePlayer player, PatternFirework entity) : base(player, entity)
      {

      }

      public override byte[] GetImage()
      {
        PatternFirework firework = Firework;
        List<Star> stars = firework.Design.stars;

        using (Bitmap image = new Bitmap(250, 250))
        {
          using (Graphics g = Graphics.FromImage(image))
          {
            for (int index = 0; index < stars.Count; index++)
            {
              Star star = stars[index];
              int x = (int)((star.position.x + 1) * 125);
              int y = (int)((-star.position.y + 1) * 125);
              g.FillEllipse(GetBrush(star.color), x, y, 19, 19);
            }

            return GetImageBytes(image);
          }
        }
      }

      private Brush GetBrush(UnityEngine.Color color)
      {
        Brush brush = FireworkUpdate.FireworkBrushes[color];
        if (brush == null)
        {
          brush = new SolidBrush(FromUnityColor(color));
          FireworkUpdate.FireworkBrushes[color] = brush;
        }

        return brush;
      }

      private Color FromUnityColor(UnityEngine.Color color)
      {
        int red = FromUnityColorField(color.r);
        int green = FromUnityColorField(color.g);
        int blue = FromUnityColorField(color.b);
        int alpha = FromUnityColorField(color.a);

        return Color.FromArgb(alpha, red, green, blue);
      }

      private int FromUnityColorField(float color)
      {
        return (int)(color * 255);
      }

      private byte[] GetImageBytes(Bitmap image)
      {
        MemoryStream stream = Facepunch.Pool.Get<MemoryStream>();
        image.Save(stream, ImageFormat.Png);
        byte[] bytes = stream.ToArray();
        Facepunch.Pool.FreeMemoryStream(ref stream);
        return bytes;
      }
    }

    public class PaintedItemUpdate : BaseImageUpdate
    {
      private readonly byte[] _image;

      public PaintedItemUpdate(BasePlayer player, PaintedItemStorageEntity entity, Item item, byte[] image) : base(player, entity)
      {
        _image = image;
        ItemId = item.info.itemid;
      }

      public override bool SupportsTextureIndex => false;
      public override byte[] GetImage()
      {
        return _image;
      }
    }

    public class SignageUpdate : BaseImageUpdate
    {
      public string Url { get; }
      public override bool SupportsTextureIndex => true;
      public ISignage Signage => (ISignage)Entity;

      public SignageUpdate(BasePlayer player, ISignage entity, uint textureIndex, string url = null) : base(player, (BaseEntity)entity)
      {
        TextureIndex = textureIndex;
        Url = url;
      }

      public override byte[] GetImage()
      {
        ISignage sign = Signage;
        uint crc = sign.GetTextureCRCs()[TextureIndex];

        return FileStorage.server.Get(crc, FileStorage.Type.png, sign.NetworkID, TextureIndex);
      }
    }

    private void OnImagePost(BasePlayer player, string url, bool raw, ISignage signage, uint textureIndex)
    {
      _Worker.Action.SendSignage(new SignageUpdate(player, signage, textureIndex, url));
    }

    private void OnSignUpdated(ISignage signage, BasePlayer player, int textureIndex = 0)
    {
      if (player == null)
      {
        return;
      }

      if (signage.GetTextureCRCs()[textureIndex] == 0)
      {
        return;
      }

      _Worker.Action.SendSignage(new SignageUpdate(player, signage, (uint)textureIndex));
    }

    private void OnItemPainted(PaintedItemStorageEntity entity, Item item, BasePlayer player, byte[] image)
    {
      if (entity._currentImageCrc == 0)
      {
        return;
      }

      PaintedItemUpdate update = new PaintedItemUpdate(player, entity, item, image);

      _Worker.Action.SendSignage(new PaintedItemUpdate(player, entity, item, image));
    }

    private void OnFireworkDesignChanged(PatternFirework firework, ProtoBuf.PatternFirework.Design design, BasePlayer player)
    {
      if (design?.stars == null || design.stars.Count == 0)
      {
        return;
      }

      _Worker.Action.SendSignage(new FireworkUpdate(player, firework));
    }

    private object CanUpdateSign(BasePlayer player, BaseEntity entity)
    {
      // TODO: Logic to protect user from sign-usage

      //Client side the sign will still be updated if we block it here. We destroy the entity client side to force a redraw of the image.
      NextTick(() =>
      {
        entity.DestroyOnClient(player.Connection);
        entity.SendNetworkUpdate();
      });

      return null;
    }

    private object OnFireworkDesignChange(PatternFirework firework, ProtoBuf.PatternFirework.Design design, BasePlayer player)
    {
      // TODO: Logic to protect user from sign-usage

      return null;
    }

    #endregion

    private void OnEntityBuilt(Planner plan, GameObject go)
    {
      var player = plan.GetOwnerPlayer();
      var ent = go.ToBaseEntity();

      if (player == null || ent == null) return;

      string shortName = go.ToBaseEntity().ShortPrefabName;
      if (!shortName.Contains("sign"))
      {
        return;
      }

      var signage = go.ToBaseEntity().GetComponent<Signage>();

      NextTick(() =>
      {
        if (signage == null)
        {
          return;
        }

        if (signage.GetTextureCRCs()[0] == 0)
        {
          return;
        }

        _Worker.Action.SendSignage(new SignageUpdate(player, signage, 0));
      });
    }
  }
}

// --- End of file: RustApp.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/EventRandomizer.cs ---
// --- Original Local Path: EventRandomizer.cs ---

using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using ConVar;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Event Randomizer", "Frizen", "0.0.1")]
    [Description("Set random timers for server events")]
    class EventRandomizer : RustPlugin
    {
        private float heliInterval;
        private float chinookInterval;
        private float cargoInterval;
        private float airdropInterval;

        private int lastHeli;
        private int lastChinook;
        private int lastCargo;
        private int lastAirdrop;

        private string permSpawnChinook = "eventrandomizer.spawn.ch47";
        private string permSpawnHeli = "eventrandomizer.spawn.heli";
        private string permSpawnCargo = "eventrandomizer.spawn.cargo";
        private string permSpawnAirdrop = "eventrandomizer.spawn.airdrop";
		
        private string permCheckTimer = "eventrandomizer.check";
		
		private bool initialized = false;

        private class EventTimer
        {
            public float Min;
            public float Max;
        }

        private void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NextHeliIn"] = "Следующий Патрульный Вертолёт заспавнится через {0}",
                ["NextChinookIn"] = "Следующий Вертолёт с чинуком заспавнится через {0}",
                ["NextCargoIn"] = "Следующий Военный Корабль заспавнится через {0}",
                ["NextAirdropIn"] = "Следующий Аирдроп заспавнится {0}",

                ["CargoSpawned"] = "Военный корабль был успешно заспавнен",
                ["PatrolHelicopterSpawned"] = "Патрульный вертолёт был успешно заспавнен",
                ["ChinookSpawned"] = "Вертолёт с чинуком был успешно заспавнен",
                ["AirdropSpawned"] = "Аирдроп был успешно заспавнен",

                ["FormatTime"] = "{0} Hours {1} Minutes",

                ["EventNotEnabled"] = "The Min and Max timer for {0} is less than or equal to 0 so this event has been disabled.",

                ["Warning: MinGreaterThanMax"] = "The minimum value ({0}) for {1} is greater than the maximum value ({2})!",

                ["Error: NoPermission"] = "You do not have permission to use this command.",
            }, this);
        }

        private void OnServerInitialized()
        {
            permission.RegisterPermission(permSpawnChinook, this);
            permission.RegisterPermission(permSpawnHeli, this);
            permission.RegisterPermission(permSpawnCargo, this);
            permission.RegisterPermission(permSpawnAirdrop, this);
            permission.RegisterPermission(permCheckTimer, this);

            LoadVariables();

            foreach (var entry in configData.EventTimers)
            {
                if (entry.Value.Min > entry.Value.Max)
                {
                    PrintWarning(Lang("Warning: MinGreaterThanMax", null, entry.Value.Min, entry.Key, entry.Value.Max));
                }
            }

            if (configData.EventTimers["Helicopter"].Min > 0 && configData.EventTimers["Helicopter"].Max > 0)
            {
                heliInterval = UnityEngine.Random.Range(configData.EventTimers["Helicopter"].Min, configData.EventTimers["Helicopter"].Max);
                timer.Once(heliInterval, SpawnHeliRandom);
                PrintWarning(Lang("NextHeliIn", null, FormatTime(heliInterval)));
            }
            else
            {
                PrintWarning(Lang("EventNotEnabled", null, "Helicopter"));
            }

            if (configData.EventTimers["Chinook"].Min > 0 && configData.EventTimers["Chinook"].Max > 0)
            {
                chinookInterval = UnityEngine.Random.Range(configData.EventTimers["Chinook"].Min, configData.EventTimers["Chinook"].Max);
                timer.Once(chinookInterval, SpawnChinookRandom);
                PrintWarning(Lang("NextChinookIn", null, FormatTime(chinookInterval)));
            }
            else
            {
                PrintWarning(Lang("EventNotEnabled", null, "Chinook"));
            }

            if (configData.EventTimers["Cargo"].Min > 0 && configData.EventTimers["Cargo"].Max > 0)
            {
                cargoInterval = UnityEngine.Random.Range(configData.EventTimers["Cargo"].Min, configData.EventTimers["Cargo"].Max);
                timer.Once(cargoInterval, SpawnCargoRandom);
                PrintWarning(Lang("NextCargoIn", null, FormatTime(cargoInterval)));
            }
            else
            {
                PrintWarning(Lang("EventNotEnabled", null, "Cargo"));
            }

            if (configData.EventTimers["Airdrop"].Min > 0 && configData.EventTimers["Airdrop"].Max > 0)
            {
                airdropInterval = UnityEngine.Random.Range(configData.EventTimers["Airdrop"].Min, configData.EventTimers["Airdrop"].Max);
                timer.Once(airdropInterval, SpawnAirdropRandom);
                PrintWarning(Lang("NextAirdropIn", null, FormatTime(airdropInterval)));
            }
            else
            {
                PrintWarning(Lang("EventNotEnabled", null, "Airdrop"));
            }

            var currentTime = GetUnix();

            lastHeli = currentTime;
            lastChinook = currentTime;
            lastCargo = currentTime;
            lastAirdrop = currentTime;
			
			initialized = true;
        }

        private void OnEntitySpawned(BaseNetworkable entity)
        {
			if (!initialized) return;			
            
            /*if (configData.blockServerAirdrops && entity is CargoPlane)
            {
                entity.KillMessage();
            }
            else*/ if (configData.blockServerCargoShips && entity is CargoShip)
            {
                entity.KillMessage();
            }
            else if (configData.blockServerChinooks && (entity is CH47Helicopter || entity is CH47HelicopterAIController))
            {
                //entity.KillMessage();
            }
            else if (configData.blockServerPatrolHelicopters && entity is PatrolHelicopterAI)
            {
                entity.KillMessage();
            }
        }

        [ChatCommand("heli")]
        private void CmdHeli(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, permCheckTimer))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            player.ChatMessage(Lang("NextHeliIn", player.UserIDString, FormatTime(heliInterval + lastHeli - GetUnix())));
        }

        [ChatCommand("chinook")]
        private void CmdChinook(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, permCheckTimer))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            player.ChatMessage(Lang("NextChinookIn", player.UserIDString, FormatTime(chinookInterval + lastChinook - GetUnix())));
        }

        [ChatCommand("cargo")]
        private void CmdCargo(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, permCheckTimer))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            player.ChatMessage(Lang("NextCargoIn", player.UserIDString, FormatTime(cargoInterval + lastCargo - GetUnix())));
        }

        [ConsoleCommand("ch47.spawn")]
        private void ConsoleCmdSpawnCh47(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player();

            if (arg?.Connection != null && player && !permission.UserHasPermission(player.UserIDString, permSpawnChinook))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            SpawnChinook();
        }

        [ConsoleCommand("heli.spawn")]
        private void ConsoleCmdSpawnHeli(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player();

            if (arg?.Connection != null && player && !permission.UserHasPermission(player.UserIDString, permSpawnHeli))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            SpawnHeli();
        }

        [ConsoleCommand("cargo.spawn")]
        private void ConsoleCmdSpawnCargo(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player();

            if (arg?.Connection != null && player && !permission.UserHasPermission(player.UserIDString, permSpawnCargo))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            SpawnCargo();
        }

        [ConsoleCommand("airdrop.spawn")]
        private void ConsoleCmdSpawnAirdrop(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player();

            if (arg?.Connection != null && player && !permission.UserHasPermission(player.UserIDString, permSpawnAirdrop))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            SpawnAirdrop();
        }

        private void SpawnCargoRandom()
        {
            SpawnCargo();
            lastCargo = GetUnix();

            cargoInterval = UnityEngine.Random.Range(configData.EventTimers["Cargo"].Min, configData.EventTimers["Cargo"].Max);
            timer.Once(cargoInterval, SpawnCargoRandom);
        }

        private void SpawnHeliRandom()
        {
            SpawnHeli();
            lastHeli = GetUnix();

            heliInterval = UnityEngine.Random.Range(configData.EventTimers["Helicopter"].Min, configData.EventTimers["Helicopter"].Max);
            timer.Once(heliInterval, SpawnHeliRandom);
        }

        private void SpawnChinookRandom()
        {
            SpawnChinook();
            lastChinook = GetUnix();

            chinookInterval = UnityEngine.Random.Range(configData.EventTimers["Chinook"].Min, configData.EventTimers["Chinook"].Max);
            timer.Once(chinookInterval, SpawnChinookRandom);
        }

        private void SpawnAirdropRandom()
        {
            SpawnAirdrop();
            lastAirdrop = GetUnix();

            airdropInterval = UnityEngine.Random.Range(configData.EventTimers["Airdrop"].Min, configData.EventTimers["Airdrop"].Max);
            timer.Once(airdropInterval, SpawnAirdropRandom);
        }

        private string FormatTime(float seconds)
        {
            TimeSpan time = TimeSpan.FromSeconds(seconds);

            return Lang("FormatTime", null, time.Hours, time.Minutes);
        }

        private void SpawnAirdrop()
        {
            var entity = GameManager.server.CreateEntity("assets/prefabs/npc/cargo plane/cargo_plane.prefab", new Vector3());
            entity?.Spawn();

            PrintWarning(Lang("AirdropSpawned"));
        }

        private void SpawnCargo()
        {
            Unsubscribe(nameof(OnEntitySpawned));
            var cargoShip = GameManager.server.CreateEntity("assets/content/vehicles/boats/cargoship/cargoshiptest.prefab") as CargoShip;
            if (cargoShip == null) return;
            cargoShip.TriggeredEventSpawn();
            cargoShip.Spawn();

            PrintWarning(Lang("CargoSpawned"));
            Subscribe(nameof(OnEntitySpawned));
        }

        private void SpawnHeli()
        {
            Unsubscribe(nameof(OnEntitySpawned));
            var heli = GameManager.server.CreateEntity("assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab");
            if (heli == null) return;
            heli.Spawn();

            PrintWarning(Lang("PatrolHelicopterSpawned"));
            Subscribe(nameof(OnEntitySpawned));
        }

        private void SpawnChinook()
        {
            Unsubscribe(nameof(OnEntitySpawned));
            var ch47 = (CH47HelicopterAIController)GameManager.server.CreateEntity("assets/prefabs/npc/ch47/ch47scientists.entity.prefab", new Vector3(0, 200, 0));
            if (ch47 == null) return;
            ch47.Spawn();

            PrintWarning(Lang("ChinookSpawned"));
            Subscribe(nameof(OnEntitySpawned));
        }

        private int GetUnix() => (int)(DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1))).TotalSeconds;

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #region Config        
        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Event Timers in seconds")]
            public Dictionary<string, EventTimer> EventTimers { get; set; }

            [JsonProperty(PropertyName = "Block Airdrops spawned by the server")]
            public bool blockServerAirdrops;

            [JsonProperty(PropertyName = "Block Cargo Ships spawned by the server")]
            public bool blockServerCargoShips;

            [JsonProperty(PropertyName = "Block Chinooks spawned by the server")]
            public bool blockServerChinooks;

            [JsonProperty(PropertyName = "Block Patrol Helicopters spawned by the server")]
            public bool blockServerPatrolHelicopters;
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                EventTimers = new Dictionary<string, EventTimer>()
                {
                    { "Helicopter", new EventTimer(){ Min = 3600, Max = 7200 } },
                    { "Chinook", new EventTimer(){ Min = 7200, Max = 14400 } },
                    { "Cargo", new EventTimer(){ Min = 7200, Max = 10800 } },
                    { "Airdrop", new EventTimer(){ Min = 3600, Max = 3600 } }
                },
                blockServerPatrolHelicopters = true,
                blockServerChinooks =  true,
                blockServerAirdrops = true,
                blockServerCargoShips = true
            };

            SaveConfig(config);
        }

        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();

        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion
    }
}

// --- End of file: EventRandomizer.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/EasyMute.cs ---
// --- Original Local Path: EasyMute.cs ---

using Oxide.Core;
//using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
//using System.Reflection;
//using System.Linq;
using UnityEngine;
using System.Linq;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
	[Info("EasyMute", "4seti [Lunatiq] for Rust Planet", "0.2.0", ResourceId = 730)]
	class EasyMute : RustPlugin
	{
		#region Utility Methods
		private void Log(string message) => Puts("{0}: {1}", Title, message);
		private void Warn(string message) => PrintWarning("{0}: {1}", Title, message);
		private void Error(string message) => PrintError("{0}: {1}", Title, message);		
		void ReplyChat(BasePlayer player, string msg) => player.ChatMessage(string.Format("<color=#81D600>{0}</color>: {1}", ReplyName, msg));
		void Loaded() => Log("Loaded");
		void Unload() => SaveData();
		private T GetConfig<T>(string name, T defaultValue)
		{
			if (Config[name] == null)
				return defaultValue;
			return (T)Convert.ChangeType(Config[name], typeof(T));
		}
		#endregion

		#region Vars
		IDictionary<ulong, Muted> MuteList = new Dictionary<ulong, Muted>();
		Oxide.Core.Libraries.Time time = new Oxide.Core.Libraries.Time();
		string ReplyName = "EasyMute";
		string DefaultReason = "Bad Language";

        private Dictionary<string, string> Messages = new Dictionary<string, string>();
        private Dictionary<string, string> defMsg = new Dictionary<string, string>()
		{
			["mutedReply"] = "You are muted for: <color=#F23F3F>{0}</color> time left: <color=#F23F3F>{1}</color>",
			["playerMuted"] = " <color=#81F23F>{0}</color> was muted for <color=#81F23F>{1}</color> in case of <color=#81F23F>{2}</color>",
			["playerUnMuted"] = "<color=#81F23F>{0}</color> was unmuted",
			["playerNotMuted"] = "Player <color=#81F23F>{0}</color> wasn't muted at all",
			["noOneFound"] = "No players with that name found",
			["tooMuchFound"] = "Too much matches for that name:",
			["alreadyMuted"] = "Player <color=#F23F3F>{0}</color> muted already!",
			["usage"] = "USAGE: <color=#81F23F>/mute <Name> <time:#D#H#M> <Reason:Optional></color>",
			["usageUn"] = "USAGE: <color=#81F23F>/unmute <Name></color>",
			["listEntry"] = "<color=#F5D400>{0}[{1}]</color> for <color=#F23F3F>{2}</color>  time left: <color=#81F23F>{3}</color> ({4})"
		};
		#endregion


		void OnServerInitialized()
		{
			LoadConfig();
			var version = GetConfig<Dictionary<string, object>>("version", null);
			VersionNumber verNum = new VersionNumber(Convert.ToUInt16(version["Major"]), Convert.ToUInt16(version["Minor"]), Convert.ToUInt16(version["Patch"]));
			permission.RegisterPermission("canmute", this);

			Messages = new Dictionary<string, string>();
			var cfgMessages = GetConfig<Dictionary<string, object>>("messages", null);
			if (cfgMessages != null)
				foreach (var pair in cfgMessages)
					Messages[pair.Key] = Convert.ToString(pair.Value);

			if (verNum < Version || defMsg.Count > Messages.Count)
			{
				//placeholder for future version updates
				foreach (var pair in defMsg)
					if (!Messages.ContainsKey(pair.Key))
						Messages[pair.Key] = pair.Value;

				Config["messages"] = Messages;
				Config["version"] = Version;
				Warn("Config version updated to: " + Version.ToString() + " please check it");
				SaveConfig();
			}

			ReplyName = GetConfig<string>("ReplyName", ReplyName);
			DefaultReason = GetConfig<string>("DefaultReason", DefaultReason);
			LoadData();
        }
		protected override void LoadDefaultConfig()
		{
			Log("Creating a new config file");
			Config.Clear();
			LoadVariables();
		}
		void LoadVariables()
		{
			Config["messages"] = defMsg;
			Config["version"] = Version;
			Config["ReplyName"] = ReplyName;		
			Config["DefaultReason"] = DefaultReason;
		}
		object OnPlayerChat(ConsoleSystem.Arg arg)
		{
			BasePlayer player = null;
			string msg = "";
			try
			{
				if (arg == null) return null;
				if (arg.connection.player == null) return null;

				if (arg.connection.player is BasePlayer)
				{
					player = arg.connection.player as BasePlayer;
					if (player.net.connection.authLevel > 0) return null;
				}
				else return null;

				msg = arg.GetString(0, "text").ToLower();

				if (msg == null) return null;
				else if (msg == "") return null;
				else if (msg.Substring(0, 1).Equals("/") || msg.Substring(0, 1).Equals("!")) return null;

				if (player == null) return null;
			}
			catch
			{
				return null;
			}
			uint stamp = time.GetUnixTimestamp();
            if (MuteList.ContainsKey(player.userID))
			{
				if (MuteList[player.userID].EndTime > stamp)
				{
					ReplyChat(player, string.Format(Messages["mutedReply"], MuteList[player.userID].Reason, getUnixTimeToString(MuteList[player.userID].EndTime - stamp)));
					return false;
				}
				else
					MuteList.Remove(player.userID);
			}
			return null;
		}

		private string getUnixTimeToString(uint timeDif)
		{
			string strTime = string.Empty;
			if (timeDif >= 86400)
			{
				strTime += ((timeDif - timeDif % 86400) / 86400) + "D";
				timeDif = timeDif % 86400;
            }
			if (timeDif >= 3600)
			{
				strTime += ((timeDif - timeDif % 3600) / 3600) + "H";
				timeDif = timeDif % 3600;
			}
			if (timeDif >= 60)
			{
				strTime += ((timeDif - timeDif % 60) / 60) + "M";
				timeDif = timeDif % 60;
			}
			if (timeDif > 0)
			{
				strTime += timeDif + "S";
			}

			return strTime;
		}

		private bool stringTimeToUnixTimeStapm(string timeString, ref uint stamp)
		{
			string patern = @"(\d*)[dhm]";
			Regex regex = new Regex(patern, RegexOptions.IgnoreCase);
			Match match = regex.Match(timeString);
			stamp = time.GetUnixTimestamp();
            if (match.Success)
			{
				while (match.Success)
				{
					if (match.ToString().ToLower().Replace(match.Groups[1].Value, string.Empty) == "d")
					{
						stamp += uint.Parse(match.Groups[1].Value) * 24 * 60 * 60;
                    }
					else if (match.ToString().ToLower().Replace(match.Groups[1].Value, string.Empty) == "h")
					{
						stamp += uint.Parse(match.Groups[1].Value) * 60 * 60;
					}
					else if (match.ToString().ToLower().Replace(match.Groups[1].Value, string.Empty) == "m")
					{
						stamp += uint.Parse(match.Groups[1].Value) * 60;
					}
					match = match.NextMatch();
                }
                return true;
			}
			return false;
		}

		private List<BasePlayer> FindPlayerByName(string playerName = "")
		{
			// Check if a player name was supplied.
			if (playerName == "") return null;

			// Set the player name to lowercase to be able to search case insensitive.
			//playerName = playerName.ToLower();

			// Setup some variables to save the matching BasePlayers with that partial
			// name.

			List<BasePlayer> entityArray = BaseEntity.Util.FindTargets(playerName, true).Cast<BasePlayer>().ToList();

			// Iterate through the online player list and check for a match.
			//foreach (var player in entityArray)
			//{
			//	// Get the player his/her display name and set it to lowercase.
			//	string displayName = player.displayName.ToLower();

			//	// Look for a match.
			//	if (displayName.Contains(playerName))  //&& player.net.connection.authLevel == 0
   //             {
			//		matches.Add(player);
			//	}
			//}



			// Return all the matching players.
			return entityArray;
		}

		[ChatCommand("mute")]
		void cmdMute(BasePlayer player, string cmd, string[] args)
		{
			if (!HasPerm(player, "canmute")) return;
			if (args.Length < 2)
			{
				ReplyChat(player, Messages["usage"]);
                return;
			}
			
			string reason = args.Length > 2 ? args[2] : DefaultReason;

			DoMute(player, args[0], args[1], reason);
		}

		[ConsoleCommand("mute")]
		void cmdConsoleMute(ConsoleSystem.Arg arg)
		{
			if (arg.connection != null)
			{
				if (arg.connection.authLevel < 1)
				{
					SendReply(arg, "You dont have access to this command");
					return;
				}
			}
			if (arg.Args.Length < 2)
			{
				SendReply(arg, Messages["usage"]);
				return;
			}

			string reason = arg.Args.Length > 2 ? arg.Args[2] : DefaultReason;

			DoMute(null, arg.Args[0], arg.Args[1], reason, false, arg);
		}

		void DoMute(BasePlayer player, string name, string time, string reasonGiven, bool chat = true, ConsoleSystem.Arg console = null)
		{
			BasePlayer target;
			var pList = FindPlayerByName(name);
			if (pList.Count == 0)
			{
				if (chat)
					ReplyChat(player, Messages["noOneFound"]);
				else
					SendReply(console, Messages["noOneFound"]);
				return;
			}
			else if (pList.Count > 1)
			{
				if (chat)
					ReplyChat(player, Messages["tooMuchFound"]);
				else
					SendReply(console, Messages["tooMuchFound"]);

				int i = 0;
				foreach (var p in pList)
				{
					if (chat)
						ReplyChat(player, string.Format("<color=#F5D400>[{0}]</color> - {1}", i, p.displayName));
					else
						SendReply(console, string.Format("<color=#F5D400>[{0}]</color> - {1}", i, p.displayName));
					i++;
				}
				return;
			}
			else
			{
				target = pList.First();
			}
			uint muteTime = 0;
			if (MuteList.ContainsKey(target.userID))
			{
				if (chat)
					ReplyChat(player, string.Format(Messages["alreadyMuted"], target.displayName));
				else
					SendReply(console, string.Format(Messages["alreadyMuted"], target.displayName));
				return;
			}
			else
			{
				if (stringTimeToUnixTimeStapm(time, ref muteTime))
				{
					MuteList.Add(target.userID, new Muted(target.displayName, muteTime, reasonGiven, player == null ? "Console" : player.displayName));
					if (chat)
						ReplyChat(player, string.Format(Messages["playerMuted"], target.displayName, time, reasonGiven));
					else
						SendReply(console, string.Format(Messages["playerMuted"], target.displayName, time, reasonGiven));
				}
			}
		}
		
		[ChatCommand("unmute")]
		void cmdUnMute(BasePlayer player, string cmd, string[] args)
		{
			if (!HasPerm(player, "canmute")) return;
			if (args.Length < 1)
			{
				ReplyChat(player, Messages["usageUn"]);
				return;
			}
			DoUnmute(player, args[0]);
		}

		[ConsoleCommand("unmute")]
		void cmdConsoleUnMute(ConsoleSystem.Arg arg)
		{
			if (arg.connection != null)
			{
				if (arg.connection.authLevel < 1)
				{
					SendReply(arg, "You dont have access to this command");
					return;
				}
			}
			if (arg.Args.Length == 0)
			{
				SendReply(arg, Messages["usageUn"]);
				return;
			}

			DoUnmute(null, arg.Args[0], false, arg);
		}

		void DoUnmute(BasePlayer player, string name, bool chat = true, ConsoleSystem.Arg console = null)
		{
			KeyValuePair<ulong, string> target;
			var pList = MuteList.Where(x => x.Value.Name.Contains(name, System.Globalization.CompareOptions.IgnoreCase)).ToDictionary(k => k.Key, k => k.Value.Name);
			if (pList.Count == 0)
			{
				if (chat)
					ReplyChat(player, Messages["noOneFound"]);
				else
					SendReply(console, Messages["noOneFound"]);
				return;
			}
			else if (pList.Count > 1)
			{
				if (chat)
					ReplyChat(player, Messages["tooMuchFound"]);
				else
					SendReply(console, Messages["tooMuchFound"]);
				int i = 0;
				foreach (var p in pList)
				{
					if (chat)
						ReplyChat(player, string.Format("<color=#F5D400>[{0}]</color> - {1}", i, p.Value));
					else
						SendReply(console, string.Format("<color=#F5D400>[{0}]</color> - {1}", i, p.Value));
					i++;
				}
				return;
			}
			else
			{
				target = pList.First();
			}
			if (MuteList.ContainsKey(target.Key))
			{
				MuteList.Remove(target.Key);
				if (chat)
					ReplyChat(player, string.Format(Messages["playerUnMuted"], target.Value));
				else
					SendReply(console, string.Format(Messages["playerUnMuted"], target.Value));
				return;
			}
			else
			{
				if (chat)
					ReplyChat(player, string.Format(Messages["playerNotMuted"], target.Value));
				else
					SendReply(console, string.Format(Messages["playerNotMuted"], target.Value));
				return;
			}
		}
		bool HasPerm(BasePlayer p, string pe)
		{
			if (p.net.connection.authLevel > 0) return true;
			else return permission.UserHasPermission(p.userID.ToString(), pe);

		}

		[ChatCommand("mutesave")]
		void cmdSave(BasePlayer player, string cmd, string[] args)
		{
			if (player.net.connection.authLevel == 0) return;
			SaveData();
			ReplyChat(player, "Data Saved!");
		}

		[ChatCommand("mutelist")]
		void cmdList(BasePlayer player, string cmd, string[] args)
		{
			if (!HasPerm(player, "canmute")) return;
			List<ulong> cleaningList = new List<ulong>();
			if (MuteList.Count > 0)
			{
				uint stamp = time.GetUnixTimestamp();
				foreach (var entry in MuteList)
				{
					if (stamp < entry.Value.EndTime)
						ReplyChat(player, string.Format(Messages["listEntry"], entry.Value.Name, entry.Key, entry.Value.Reason, getUnixTimeToString(entry.Value.EndTime - stamp), entry.Value.By));
					else
						cleaningList.Add(entry.Key);
                }
				foreach (var key in cleaningList)
				{
					MuteList.Remove(key);
                }
			}
			else
				ReplyChat(player, "NoEntry");
        }

		private void LoadData()
		{
			try
			{
				MuteList = Interface.GetMod().DataFileSystem.ReadObject<IDictionary<ulong, Muted>>("mute-data");
				Log("Old EasyMute data loaded!");
				List<ulong> cleaningList = new List<ulong>();
				if (MuteList.Count > 0)
				{
					uint stamp = time.GetUnixTimestamp();
					foreach (var entry in MuteList)
					{
						if (stamp > entry.Value.EndTime)
							cleaningList.Add(entry.Key);
					}
					if (cleaningList.Count > 0)
					{
						foreach (var key in cleaningList)
						{
							MuteList.Remove(key);
						}
						SaveData();
					}
				}
			}
			catch
			{
				MuteList = new Dictionary<ulong, Muted>();
				Warn("New EasyMute Data file initiated!");
				SaveData();
			}			
		}

		void SaveData()
		{
			Interface.GetMod().DataFileSystem.WriteObject<IDictionary<ulong, Muted>>("mute-data", MuteList);
			Log("Data saved!");
		}


		private class Muted
		{
			public uint EndTime = 0;
			public string Reason = string.Empty;
			public string Name = string.Empty;
			public string By = string.Empty;
			public Muted(string name, uint endTime, string reason, string by)
			{
				Name = name;
				EndTime = endTime;
				Reason = reason;
				By = by;
			}
		}

	}
}

// --- End of file: EasyMute.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XDWipeReward.cs ---
// --- Original Local Path: XDWipeReward.cs ---

using System.Collections.Generic;
using System;
using ConVar;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using Rust;

namespace Oxide.Plugins
{
    [Info("XDWipeReward", "TopPlugin.ru", "1.2.3")]
    [Description("Награда первым N игрокам после вайпа")]
    public class XDWipeReward : RustPlugin
    {

        private void LoadPlayerData() => playersInfo = Interface.GetMod().DataFileSystem.ReadObject<Dictionary<ulong, bool>>(Name);

        void OnNewSave(string filename)
        {
            playersInfo.Clear();
            Wipe = true;
        }



                public static string WipeR = "WipeR_CUI";

        public class Setings
        {

            [JsonProperty("Команда для выдачи приза (если не нужно то оставить поля пустым)")]
            public string CommandPrize;

            [JsonProperty("У вас магазин ОВХ?")]
            public bool OVHStore;
            [JsonProperty("API KEY Магазина(GameStore. Если OVH оставить пустым)")]
            public string Store_Key;
		   		 		  						  	   		  		 			  	 	 		  	 	 		  	  	
            [JsonProperty("Бонус в виде баланса GameStores или OVH (если не нужно оставить пустым)")]
            public string GameStoreBonus;

            [JsonProperty("Id Магазина(GameStore. Если OVH оставить пустым)")]
            public string Store_Id;
            [JsonProperty("Количество игроков")]
            public int PlayersIntConnect;

            [JsonProperty("Лог сообщения(Показывается в магазине после выдачи в истории. Если OVH оставить пустым)")]
            public string GameStoreMSG;
        }
                public Configuration config;
        private void Unload()
        {
            SavePlayerData();
            foreach (BasePlayer player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, WipeR);
        }
        bool Wipe = false;
		   		 		  						  	   		  		 			  	 	 		  	 	 		  	  	
        
                private Dictionary<ulong, bool> playersInfo = new Dictionary<ulong, bool>();
        
        
        public void WipeRewardGui(BasePlayer p)
        {
            CuiHelper.DestroyUi(p, WipeR);
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-175 -340", OffsetMax = "-1 -280" },
                Image = { Color = "0 0 0 0.4", Material = "assets/content/ui/uibackgroundblur.mat", Sprite = "assets/content/ui/ui.background.tiletex.psd" }
            }, "Overlay", WipeR);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.1973175 0.011111457", AnchorMax = "0.7988508 0.3999999" },
                Button = { Command = "giveprize", Color = HexToRustFormat("#71FF9A9A") },
                Text = { Text = "Забрать награду", Align = TextAnchor.MiddleCenter, FontSize = 13 }
            }, WipeR);
		   		 		  						  	   		  		 			  	 	 		  	 	 		  	  	
                        container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.4444442", AnchorMax = "1 1" },
                Text = { Text = $"Вы {Players.Count} из {config.setings.PlayersIntConnect}\n Поэтому получаете награду", FontSize = 13, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }

            }, WipeR);

            
            CuiHelper.AddUi(p, container);
        }

        
        
        List<ulong> Players = new List<ulong>();

        public void SendChat(BasePlayer player, string Message, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            if (IQChat)
                IQChat?.Call("API_ALERT_PLAYER", player, Message, "");
            else player.SendConsoleCommand("chat.add", channel, 0, Message);
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (Wipe)
            {
                if (playersInfo.Count >= config.setings.PlayersIntConnect)
                {
                    Wipe = false;
                    return;
                }
                if (!playersInfo.ContainsKey(player.userID))
                {
                    playersInfo.Add(player.userID, false);
                    WipeRewardGui(player);
                }
            }
        }

        void GiveReward(ulong ID)
        {
            if (!config.setings.OVHStore)
            {
                string url = $"https://gamestores.ru/api?shop_id={config.setings.Store_Id}&secret={config.setings.Store_Key}&action=moneys&type=plus&steam_id={ID}&amount={config.setings.GameStoreBonus}&mess={config.setings.GameStoreMSG}";
                webrequest.Enqueue(url, null, (i, s) =>
                {
                    if (i != 200) { }
                    if (s.Contains("success"))
                    {
                        PrintWarning($"Игрок [{ID}] зашел 1 из первых, и получил бонус в нашем магазине. В виде [{config.setings.GameStoreBonus} руб]");
                    }
                    else
                    {
                        PrintWarning($"Игрок {ID} проголосовал за сервер, но не авторизован в магазине.");
                    }
                }, this);
            }
            else
            {
                plugins.Find("RustStore").CallHook("APIChangeUserBalance", ID, config.setings.GameStoreBonus, new Action<string>((result) =>
                {
                    if (result == "SUCCESS")
                    {
                        PrintWarning($"Игрок [{ID}] зашел 1 из первых, и получил бонус в нашем магазине. В виде [{config.setings.GameStoreBonus} руб]");
                        return;
                    }
                    PrintWarning($"Игрок {ID} проголосовал за сервер, но не авторизован в магазине. Ошибка: {result}");
                }));
            }
        }
        
        private void Init() => LoadPlayerData();
        [PluginReference] Plugin IQChat;


        protected override void LoadDefaultConfig()
        {
            config = new Configuration()
            {
                setings = new Setings
                {
                    PlayersIntConnect = 100,
                    CommandPrize = "say %STEAMID%",
                    OVHStore = false,
                    GameStoreBonus = "",
                    GameStoreMSG = "За заход после вайпа:3",
                    Store_Id = "ID",
                    Store_Key = "KEY"

                }
            };
            SaveConfig(config);
        }

        [ConsoleCommand("giveprize")]
        void GivePrize(ConsoleSystem.Arg arg)
        {
            BasePlayer p = arg.Player();
            CuiHelper.DestroyUi(p, WipeR);
            if (!playersInfo.ContainsKey(p.userID))
                return;
            if (playersInfo[p.userID] == false)
            {
                if (!string.IsNullOrEmpty(config.setings.CommandPrize))
                {
                    Server.Command(config.setings.CommandPrize.Replace("%STEAMID%", p.UserIDString));
                }
                if (!string.IsNullOrEmpty(config.setings.GameStoreBonus))
                {
                    GiveReward(p.userID);
                }
                playersInfo[p.userID] = true;
                SendChat(p, "Вы успешно <color=#A1FF919A>забрали награду</color>!");
            }          
        }

        public class Configuration
        {
            [JsonProperty("Настройки")]
            public Setings setings;
        }

        public void LoadConfigVars()
        {
            config = Config.ReadObject<Configuration>();
            Config.WriteObject(config, true);
        }
        private void SavePlayerData() => Interface.GetMod().DataFileSystem.WriteObject(this.Name, playersInfo);
        private void OnServerInitialized()
        {
            LoadConfigVars();

            if (!string.IsNullOrEmpty(config.setings.GameStoreBonus) && !config.setings.OVHStore)
            {
                if (config.setings.Store_Id == "ID" || config.setings.Store_Key == "KEY")
                {
                    NextTick(() =>
                    {
                        PrintError("Вы не настроили ID И KEY от магазина GameStores");
                        Interface.Oxide.UnloadPlugin(Name);
                    });
                    return;
                }
            }
            foreach (BasePlayer player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
        }
        private static string HexToRustFormat(string hex)
        {
            Color color;
            ColorUtility.TryParseHtmlString(hex, out color);
            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        void SaveConfig(Configuration config)
        {
            Config.WriteObject(config, true);
            SaveConfig();
        }
            }
}


// --- End of file: XDWipeReward.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ESPBlocker.cs ---
// --- Original Local Path: ESPBlocker.cs ---

﻿using Oxide.Core;
using System.Collections.Generic;
using System.Linq;
using System;
using System.Collections;
using UnityEngine;
using Network;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using System.Diagnostics;

namespace Oxide.Plugins
{
    [Info("ESPBlocker", "RustPlugin.RU", "1.0.0")]
    class ESPBlocker : RustPlugin
    {
        class ESPPlayer : MonoBehaviour
        {
            private static int blockedLayer = LayerMask.GetMask("Deployed","Player (Server)", "Prevent Building");

            Transform transform;
            BasePlayer player;
            List<BaseEntity> blockedEntities = new List<BaseEntity>();
            int current = 0;
            bool init = true;
            
            void Awake()
            {
                transform = GetComponent<Transform>();
                player = GetComponent<BasePlayer>();
            }

            float nextTick = 0;
            float nextUpdaterStorages = 0;
            Vector3 lastPosition = Vector3.zero;
            bool IsTimerBlock()
            {
                var time = Time.time;
                if (time < nextTick) return true;
                nextTick = time + 0.1f;        
                return false;
            }

            void UpdateBlockedEntities()
            {
                var time = Time.time;
                if (time < nextUpdaterStorages) return;
                nextUpdaterStorages = time + UnityEngine.Random.Range(2, 5);
                blockedEntities.RemoveAll(s => s.IsDestroyed || s.net == null);
                blockedEntities.Clear();
                Vis.Entities(transform.position, instance.storageRadius, blockedEntities, blockedLayer,
                    QueryTriggerInteraction.Collide);
                foreach (var entity in blockedEntities)
                {
                    if (!instance.whitelists.ContainsKey(entity.net.ID))
                        instance.whitelists[entity.net.ID] = new List<ulong>();
                }
                blockedEntities.RemoveAll(e => e?.net?.ID == null || instance.whitelists[e.net.ID].Contains(player.userID) || !instance.IsBlockEntity(e));
                if (init)
                {
                    init = false;
                    foreach (var storage in blockedEntities)
                        instance.DestroyClientEntity(player,storage);
                }
            }

            bool IsAFK()
            {
                if (lastPosition == transform.position || (transform.position - lastPosition).magnitude < 0.0001f)
                {
                    return true;
                }
                lastPosition = transform.position;
                return false;
            }

            void FixedUpdate()
            {
                if (IsTimerBlock()) return;
                UpdateBlockedEntities();

                if (current == 0 && IsAFK()) return;

                if (blockedEntities.Count <= 0||--current < 0 || current > blockedEntities.Count-1)
                {
                    current = blockedEntities.Count;
                    return;
                }

                

                var entity = blockedEntities[current];
                if (entity == null || entity.net?.ID == null)
                {
                    blockedEntities.RemoveAt(current);
                    return;
                }
                Vector3 entityPosition = entity.CenterPoint();
                if (CanVisible(entityPosition))
                {

                    instance.SetVisibleEntity(entity, player.userID);
                    blockedEntities.RemoveAt(current);
                    entity.SendNetworkUpdate();
                }
            }
            public bool ContainsAny( string value, params string[] args )
            {
                return args.Any( value.Contains );
            }
            bool CanVisible(Vector3 pos)
            {
                RaycastHit[] hits = new RaycastHit[50];
                Vector3 pos1 = pos;
                Vector3 pos2 = player.eyes.position;
                var length = Physics.RaycastNonAlloc(new Ray(pos1, (pos2 - pos1)), hits, instance.storageRadius,
                    LayerMask.GetMask("Construction", "World", "Terrain", "Player (Server)"),
                    QueryTriggerInteraction.Collide);
                var objhits = new RaycastHit[length];
                for (int i = 0; i < length; i++)
                    objhits[i] = hits[i];

                var results = objhits.OrderBy(h => h.distance).Select(p => p.GetEntity()).Where(p => p).ToList();
                results.RemoveAll(p => p.ShortPrefabName != "wall" &&
                !ContainsAny(p.ShortPrefabName, "foundation", "door", "player", "floor"));

                if (results.Count > 0)
                {
                    var result = results[0];
                    if (player.IsAdmin)
                    {
                        foreach (var p in BasePlayer.activePlayerList)
                            if (p.GetCenter() == pos)
                        instance.Arrow(player, pos1, pos2);
                    }
                    if (result == player)
                    {
                        return true;
                    }
                }

                return false;
            }
        }

        float storageRadius;
        bool adminIgnore;
        bool clansSupport;

        protected override void LoadDefaultConfig()
        {
            Config[ "Радиус видимости ящиков" ] = storageRadius =  GetConfig( "Радиус видимости ящиков", 50f);
            Config[ "Игнорирование админов" ] = adminIgnore =  GetConfig( "Игнорирование админов", true );
            Config[ "Поддержка кланов(Уменьшает нагрузку если есть игроки, играющие вместе)" ] = clansSupport = GetConfig( "Поддержка кланов(Уменьшает нагрузку если есть игроки, играющие вместе)", true );            
			
			SaveConfig();
			        }
        T GetConfig<T>( string name, T defaultValue )
            => Config[ name ] == null ? defaultValue : (T) Convert.ChangeType( Config[ name ], typeof( T ) );
        static ESPBlocker instance;
        static int PlayerLayer = LayerMask.NameToLayer("Player (Server)");
        
        Dictionary<BasePlayer, ESPPlayer> players = new Dictionary<BasePlayer, ESPPlayer>();
             Dictionary<uint, List<ulong>> whitelists;
        
        void Loaded()
        {
            instance = this;
            LoadData();
        }

        bool init = false;

        int raycastCount = 0;
        void OnServerInitialized()
        {
            LoadDefaultConfig();
			
            CommunityEntity.ServerInstance.StartCoroutine(InitCore());
        }

        void Unload()
        {
            SaveData();
            foreach (var p in players)
                UnityEngine.Object.Destroy(p.Value);
        }
        

        void OnEntityKill(BaseNetworkable entity)
        {
            if (entity?.net?.ID == null || !init) return;
            var box = entity as BoxStorage;
            if (box == null) return;
            whitelists.Remove(box.net.ID);
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            if (players.ContainsKey(player))
            {
                UnityEngine.Object.Destroy(players[player]);
                players.Remove(player);
            }
        }

        void OnPlayerInit(BasePlayer player)
        {
            AddEspPlayer(player);
        }
        
        object CanNetworkTo(BaseNetworkable entity, BasePlayer target)
        {
            if (!init) return null;
            BaseEntity baseEntity = entity as BaseEntity;
            if (baseEntity == null || !IsBlockEntity(baseEntity)) return null;
            if (baseEntity.net?.ID == null) return null;
            if (adminIgnore && target.IsAdmin) return null;
            List<ulong> whitelistPlayers;
            if (whitelists.TryGetValue(baseEntity.net.ID, out whitelistPlayers))
                return whitelistPlayers.Contains(target.userID);
            else if (baseEntity.OwnerID == target.userID)
            {
                SetVisibleEntity(baseEntity,target.userID);
                return true;
            }
            return false;
        }

        bool IsBlockEntity(BaseEntity entity)
        {
            return entity.ShortPrefabName == "shelves" || entity is BoxStorage || entity is BuildingPrivlidge || (entity is BaseOven && entity.ShortPrefabName == "furnace") || (entity is BasePlayer && ((BasePlayer)entity).IsSleeping()) || entity is SleepingBag;
        }


        void SetVisibleEntity(BaseEntity entity, ulong userID)
        {
            var whitelist = instance.whitelists[entity.net.ID] = new List<ulong>();
            if (!whitelist.Contains(userID))
                whitelist.Add(userID);
            if (instance.clansSupport)
            {
                var members = instance.GetClanMembers(userID);
                if (members != null && members.Count > 0)
                {
                    foreach (var member in members)
                        if (!whitelist.Contains(member))
                            whitelist.Add(member);
                }
            }
        }

        [ChatCommand("clear")]
        void cmdClear(BasePlayer player)
        {
            if (player.IsAdmin)
                UnityEngine.Object.FindObjectOfType<BoxStorage>().SendNetworkUpdate();
        }
 
        

        ESPPlayer GetEspPlayer(BasePlayer player)
        {
            ESPPlayer espPlayer;
            if (players.TryGetValue(player, out espPlayer))
                return espPlayer;
            AddEspPlayer(player);
            return GetEspPlayer(player);
        }

        void AddEspPlayer(BasePlayer player)
        {
            if (!players.ContainsKey(player))
            players.Add(player, player.gameObject.AddComponent<ESPPlayer>());
        }

        void DestroyClientEntity(BasePlayer player, BaseEntity entity)
        {
            if (Net.sv.write.Start())
            {
                Net.sv.write.PacketID(Message.Type.EntityDestroy);
                Net.sv.write.EntityID(entity.net.ID);
                Net.sv.write.UInt8((byte)BaseNetworkable.DestroyMode.None);
                Net.sv.write.Send(new SendInfo(player.net.connection));
            }   
        }

        IEnumerator InitCore()
        {
            var objs = UnityEngine.Object.FindObjectsOfType<BoxStorage>();
            int i = 0;
            int lastpercent = -1;
            StopwatchUtils.StopwatchStart("ESPBlocker.InitCore");
            
            foreach (var player in BasePlayer.activePlayerList)
            {
                i++;
                int percent = (int) (i/(float)BasePlayer.activePlayerList.Count*100);
                if (StopwatchUtils.StopwatchElapsedMilliseconds("ESPBlocker.InitCore") > 10 || percent != lastpercent)
                {
                    StopwatchUtils.StopwatchStart("ESPBlocker.InitCore");
                    if (percent != lastpercent)
                    {
                        if (percent%20 == 0)
                        {
                            Puts($"Идёт загрузка ESPPlayer: {percent}%");
                        }
                        lastpercent = percent;
                    }
                    if (Performance.report.frameTime < 100)
                    {
                        yield return new WaitForEndOfFrame();
                    }
                }
                AddEspPlayer(player);
            }
            init = true;
        }
        public static class StopwatchUtils
        {
            static Dictionary<string, Stopwatch> watches = new Dictionary<string, Stopwatch>();

            /// <summary>
            /// Start Stopwatch
            /// </summary>
            /// <param name="name">KEY</param>
            public static void StopwatchStart( string name )
            {
                watches[ name ] = Stopwatch.StartNew();
            }

            /// <summary>
            /// Get Elapsed Milliseconds
            /// </summary>
            /// <param name="name">KEY</param>
            /// <returns></returns>
            public static long StopwatchElapsedMilliseconds( string name ) => watches[ name ].ElapsedMilliseconds;

            /// <summary>
            /// Remove StopWatch
            /// </summary>
            /// <param name="name"></param>
            public static void StopwatchStop( string name )
            {
                watches.Remove( name );
            }
        }
        public void Arrow(BasePlayer player, Vector3 from, Vector3 to)
        {
            player.SendConsoleCommand("ddraw.arrow", 5, Color.magenta, from, to, 0.1f);
        }
        [PluginReference]
        Plugin Clans;

        List<ulong> GetClanMembers(ulong uid)
        {
            return Clans?.Call("GetClanMembers", uid) as List<ulong>;
        }

        DynamicConfigFile whitelistFile = Interface.Oxide.DataFileSystem.GetFile("ESPBlockerWhitelist");

        void OnServerSave()
        {
            if (!init) return;
            SaveData();
        }

        void LoadData()
        {
            whitelists = whitelistFile.ReadObject<Dictionary<string, List<ulong>>>().ToDictionary(p=>uint.Parse(p.Key), p=>p.Value);
        }

        void SaveData()
        {
            Dictionary<string, List<ulong>> data = whitelists.ToDictionary(p => p.Key.ToString(), p => p.Value);
            whitelistFile.WriteObject(data);
        }
    }
}


// --- End of file: ESPBlocker.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ComfortBed (1).cs ---
// --- Original Local Path: ComfortBed (1).cs ---

﻿using ConVar;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("ComfortBed", "Sempai#3239", "0.0.2")]
    [Description("Самый лучший пионер Sempai#3239")]
    class ComfortBed : RustPlugin
    {
        [PluginReference] Plugin IQChat;

        #region Vars
        string ShortnameBed = "bed";
        #endregion

        #region Configuration

        private static Configuration config = new Configuration();
        private class Configuration
        {
            [JsonProperty("SkinID для кровати")]
            public ulong SkinID;
            [JsonProperty("DisplayName для кровати")]
            public string DisplayName;
            [JsonProperty("Ломать кровать при возрождении(Сделать ее одноразовой)")]
            public bool KillBed;
            [JsonProperty("Настройки пользователя при возрождении")]
            public MetabolismUser metabolismUser = new MetabolismUser();

            internal class MetabolismUser
            {
                [JsonProperty("Кол-во ХП при возраждении на кровати")]
                public int Health;
                [JsonProperty("Кол-во ЖАЖДЫ при возраждении на кровати")]
                public int Water;
                [JsonProperty("Кол-во СЫТНОСТИ при возраждении на кровати")]
                public int Hungry;
            }
            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    SkinID = 1957274032,
                    DisplayName = "Комфортная шконка",
                    KillBed = false,
                    metabolismUser = new MetabolismUser
                    {
                        Health = 100,
                        Hungry = 500,
                        Water = 500
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning("Ошибка #3413" + $"чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Metods
        void CreateItem(BasePlayer player)
        {
            Item item = ItemManager.CreateByName(ShortnameBed, 1, config.SkinID);
            item.name = config.DisplayName;
            player.GiveItem(item);
        }

        #endregion

        #region Hooks
        private object OnPlayerRespawn(BasePlayer player, SleepingBag bag)
        {
            if(bag.skinID == config.SkinID)
                if(bag.OwnerID == player.userID)
                {
                    var MetabolismConfig = config.metabolismUser;
                    string MessageChat = config.KillBed ? "BED_KILL" : "BED_USED";
                    NextTick(() =>
                    {
                        player.health = MetabolismConfig.Health;
                        player.metabolism.calories.value = MetabolismConfig.Hungry;
                        player.metabolism.hydration.value = MetabolismConfig.Water;
                    });

                    if(config.KillBed)
                        bag.Kill();
                    SendChat(lang.GetMessage(MessageChat, this, player.UserIDString), player);
                }
            return null;
        }

        void OnEntitySpawned(BaseNetworkable entity)
        {
            SleepingBag bed = entity.GetComponent<SleepingBag>();
            if (bed == null) return;
            if (bed.skinID == config.SkinID)
                bed.niceName = config.DisplayName;
        }
        #endregion

        #region Command

        [ConsoleCommand("cb")]
        void ComfortBedCommand(ConsoleSystem.Arg arg)
        {
            BasePlayer player = BasePlayer.FindByID(ulong.Parse(arg.Args[0]));
            if (player == null) return;
            CreateItem(player);
            SendChat($"Вы успешно получили {config.DisplayName}", player);
            Puts("Игроку успешно выдана кровать!");
        }

        #endregion

        #region Helps
        public void SendChat(string Message, BasePlayer player, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            if (IQChat)
                IQChat?.Call("API_ALERT_PLAYER", player, Message);
            else player.SendConsoleCommand("chat.add", channel, 0, Message);
        }
        #endregion

        #region Lang
        private new void LoadDefaultMessages()
        {
            PrintWarning("Языковой файл загружается...");
            Dictionary<string, string> Lang = new Dictionary<string, string>
            {
                ["BED_USED"] = "Вы успешно появились на комфортной шконке",
                ["BED_KILL"] = "Ваша комфортная шконка разрушена",
            };

            lang.RegisterMessages(Lang, this);
            PrintWarning("Языковой файл загружен успешно");
        }
        #endregion
    }
}


// --- End of file: ComfortBed (1).cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ClearDoors.cs ---
// --- Original Local Path: ClearDoors.cs ---

using System;
using UnityEngine;
using System.Globalization;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("Удаление дверей с РТ", "poof.", "1.0.0")]
    class ClearDoors : RustPlugin
    {
		private void clearallchest() 
		{ 

		var ents = UnityEngine.Object.FindObjectsOfType<BaseEntity>(); 
		foreach(var ent in ents) 
		{ 
		if(ent.PrefabName.Contains("door.hinged.industrial_a") || ent.PrefabName.Contains("door.hinged.garage_a") || ent.PrefabName.Contains("door.hinged.bunker.door") || ent.PrefabName.Contains("door.hinged.security") || ent.PrefabName.Contains("door.hinged.vent.prefab")) 
			{ 
			ent.Kill(); 
			} 
		} 
		}
 
		void OnServerInitialized() 
		{
		clearallchest();
        PrintWarning("Плагин разработан специально для сервера SnyxCloud [Автор плагина: poof.]");
        PrintWarning("Группа разработчика: vk.com/poof.rust");
		}

        #region Helpers

        private static string HexToCuiColor(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }

        private void GetConfig<T>(string menu, string Key, ref T var)
        {
            if (Config[menu, Key] != null)
            {
                var = (T) Convert.ChangeType(Config[menu, Key], typeof(T));
            }

            Config[menu, Key] = var;
        }

        #endregion
    }
}


// --- End of file: ClearDoors.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TeamDeathmatch.cs ---
// --- Original Local Path: TeamDeathmatch.cs ---

// Requires: EventManager
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;

namespace Oxide.Plugins
{
    [Info("Team Deathmatch", "k1lly0u", "0.2.21", ResourceId = 1484)]
    class TeamDeathmatch : RustPlugin
    {
        #region Fields        
        [PluginReference]
        EventManager EventManager;

        [PluginReference]
        Plugin Spawns;

        private bool UseTDM;
        private bool Started;
        private bool Changed;

        public string Kit;

        public int TeamAKills;
        public int TeamBKills;

        private List<TDMPlayer> TDMPlayers = new List<TDMPlayer>();
        private ConfigData configData;
        #endregion

        #region Oxide Hooks       
        void Loaded()
        {
            lang.RegisterMessages(messages, this);
            UseTDM = false;
            Started = false;
        }
        void OnServerInitialized()
        {
            if (EventManager == null)
            {
                Puts("Event plugin doesn't exist");
                return;
            }
            LoadVariables();
            RegisterGame();
        }
        void RegisterGame()
        {
            var success = EventManager.RegisterEventGame(configData.EventName);
            if (success == null)
            {
                Puts("Event plugin doesn't exist");
                return;
            }
        }        
        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList) DestroyUI(player);
            if (UseTDM && Started)            
                EventManager.EndEvent();

            var objects = UnityEngine.Object.FindObjectsOfType<TDMPlayer>();
            if (objects != null)
                foreach (var gameObj in objects)
                    UnityEngine.Object.Destroy(gameObj);
        }
        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitinfo)
        {
            if (UseTDM && Started)
            {
                if (entity is BasePlayer && hitinfo?.Initiator is BasePlayer)
                {
                    var victim = entity.GetComponent<TDMPlayer>();
                    var attacker = hitinfo.Initiator.GetComponent<TDMPlayer>();
                    if (victim != null && attacker != null && victim.player.userID != attacker.player.userID)
                    {
                        if (victim.team == attacker.team)
                        {
                            if (configData.FF_Damage_Modifier <= 0)
                            {
                                hitinfo.damageTypes = new DamageTypeList();
                                hitinfo.DoHitEffects = false;
                            }
                            else
                                hitinfo.damageTypes.ScaleAll(configData.FF_Damage_Modifier);
                            SendReply(attacker.player, TitleM() + lang.GetMessage("ff", this, attacker.player.UserIDString));
                        }
                    }
                }
            }
        }
        #endregion

        #region EventManager Hooks       
        void OnSelectEventGamePost(string name)
        {
            if (configData.EventName.Equals(name))
            {
                if (!string.IsNullOrEmpty(configData.TeamA_Spawnfile) && !string.IsNullOrEmpty(configData.TeamB_Spawnfile))
                {
                    UseTDM = true;
                    EventManager.SelectSpawnfile(configData.TeamA_Spawnfile);
                }
                else Puts("Check your config for valid spawn entries");
            }
            else
                UseTDM = false;
        }
        void OnEventPlayerSpawn(BasePlayer player)
        {
            if (UseTDM && Started)
            {
                if (player.IsSleeping()) player.EndSleeping();
                timer.Once(3, () =>
                {                    
                    if (!player.GetComponent<TDMPlayer>()) return;
                    GiveTeamGear(player);
                    CreateScoreboard(player);
                });
            }
        }
        private void GiveTeamGear(BasePlayer player)
        {
            player.health = configData.StartingHealth;
            EventManager.GivePlayerKit(player, Kit);
            if (!EventManager.UseClassSelection)
                GiveTeamShirts(player);
        }
        private void GiveTeamShirts(BasePlayer player)
        {
            if (player.GetComponent<TDMPlayer>().team == Team.A)
            {
                Item shirt = ItemManager.CreateByPartialName(configData.TeamA_Shirt);
                shirt.skin = configData.TeamA_SkinID;
                shirt.MoveToContainer(player.inventory.containerWear);
            }
            else if (player.GetComponent<TDMPlayer>().team == Team.B)
            {
                Item shirt = ItemManager.CreateByPartialName(configData.TeamB_Shirt);
                shirt.skin = configData.TeamB_SkinID;
                shirt.MoveToContainer(player.inventory.containerWear);
            }
        }
        object OnSelectSpawnFile(string name)
        {
            if (UseTDM)
            {
                if (name.EndsWith("_a"))
                {
                    configData.TeamA_Spawnfile = name;
                    configData.TeamB_Spawnfile = name.Replace("_a", "_b");
                    return true;
                }
            }
            return null;
        }        
        private object CanEventOpen()
        {
            if (UseTDM)
            {
                if (!CheckSpawnfiles()) return "error";
                return true;
            }
            return null;
        }
        private bool CheckSpawnfiles()
        {
            object success = Spawns.Call("GetSpawnsCount", configData.TeamA_Spawnfile);
            if (success is string)
            {                
                Puts("Error finding the Team A spawn file");
                return false;
            }
            success = Spawns.Call("GetSpawnsCount", configData.TeamB_Spawnfile);
            if (success is string)
            {
                Puts("Error finding the Team B spawn file");
                return false;
            }
            return true;
        }
        object CanEventStart()
        {
            return null;
        }
        object OnEventOpenPost()
        {
            if (!UseTDM) return null;
            PrintToChat(TitleM() + lang.GetMessage("OpenMsg", this));
            return null;
        }
        object OnEventClosePost()
        {
            return null;
        }
        object OnEventEndPre()
        {
            if (!UseTDM) return null;
            CheckScores(true);
            foreach (TDMPlayer p in TDMPlayers)
            {
                p.team = Team.NONE;
                DestroyUI(p.player);
                UnityEngine.Object.Destroy(p);
            }

            Started = false;
            TDMPlayers.Clear();
            TeamAKills = 0;
            TeamBKills = 0;
            return null;
        }
        void OnPlayerSelectClass(BasePlayer player)
        {
            if (UseTDM && Started)
                GiveTeamShirts(player);
        }
        object OnEventCancel()
        {
            CheckScores(true);
            return null;
        }

        object OnEventEndPost()
        {
            var objects = UnityEngine.Object.FindObjectsOfType<TDMPlayer>();
            if (objects != null)
                foreach (var gameObj in objects)
                    UnityEngine.Object.Destroy(gameObj);
            return null;
        }
        object OnEventStartPre()
        {
            if (UseTDM)
            {
                Started = true;
            }
            return null;
        }
        object OnEventStartPost()
        {
            RefreshSB();
            return null;
        }
        object CanEventJoin(BasePlayer player)
        {
            if (player.GetComponent<TDMPlayer>())
                player.GetComponent<TDMPlayer>().team = Team.NONE;
            return null;
        }
        object OnSelectKit(string kitname)
        {
            if (UseTDM)
            {
                Kit = kitname;
                return true;
            }
            return null;
        }
        object OnEventJoinPost(BasePlayer player)
        {
            if (UseTDM)
            {
                if (player.GetComponent<TDMPlayer>())
                    UnityEngine.Object.Destroy(player.GetComponent<TDMPlayer>());
                TDMPlayers.Add(player.gameObject.AddComponent<TDMPlayer>());
                if (Started)
                {
                    TeamAssign(player);
                    //OnEventPlayerSpawn(player);
                }
            }
            return null;
        }
        object OnEventLeavePost(BasePlayer player)
        {
            if (UseTDM)
            {
                DestroyUI(player);
                var tDMPlayer = player.GetComponent<TDMPlayer>();
                if (tDMPlayer)
                {                    
                    TDMPlayers.Remove(tDMPlayer);
                    UnityEngine.Object.Destroy(tDMPlayer);
                    if (Started)
                        CheckScores();
                }
            }
            return null;
        }
        void OnEventPlayerAttack(BasePlayer attacker, HitInfo hitinfo)
        {
            if (UseTDM)
            {
                if (!(hitinfo.HitEntity is BasePlayer))
                {
                    hitinfo.damageTypes = new DamageTypeList();
                    hitinfo.DoHitEffects = false;
                }
            }
        }
        void OnEventPlayerDeath(BasePlayer vic, HitInfo hitinfo)
        {
            if (UseTDM && Started)
            {                
                if (hitinfo.Initiator != null && vic != null)
                {
                    if (vic.GetComponent<TDMPlayer>())
                    {
                        var victim = vic.GetComponent<TDMPlayer>();
                        DestroyUI(vic);
                        if (hitinfo.Initiator is BasePlayer)
                        {

                            var attacker = hitinfo.Initiator.GetComponent<TDMPlayer>();
                            if ((victim.player.userID != attacker.player.userID) && (attacker.team != victim.team))
                            {
                                AddKill(attacker.player, victim.player);
                            }
                        }
                    }
                }
            }
            return;
        }
        private void RefreshSB()
        {
            foreach (TDMPlayer p in TDMPlayers)            
                CreateScoreboard(p.player);            
        }
        object EventChooseSpawn(BasePlayer player, Vector3 destination)
        {
            if (UseTDM)
            {
                if (!CheckForTeam(player))
                {
                    TeamAssign(player);
                    return false;
                }
                Team team = player.GetComponent<TDMPlayer>().team;
                object newpos = null;
                if (team == Team.A) newpos = Spawns.Call("GetRandomSpawn", configData.TeamA_Spawnfile);
                else if (team == Team.B) newpos = Spawns.Call("GetRandomSpawn", configData.TeamB_Spawnfile);
                if (!(newpos is Vector3))
                {
                    Puts("Error finding a spawn point, spawnfile corrupt or invalid");
                    return null;
                }
                return (Vector3)newpos;
            }
            return null;
        }  
        object OnRequestZoneName()
        {
            if (UseTDM)
                if (!string.IsNullOrEmpty(configData.ZoneName))
                    return configData.ZoneName;
            return null;
        }
        #endregion

        #region team funtions
        enum Team
        {
            A,
            B,
            NONE
        }
        private bool CheckForTeam(BasePlayer player)
        {
            if (!player.GetComponent<TDMPlayer>())
                TDMPlayers.Add(player.gameObject.AddComponent<TDMPlayer>());
            if (player.GetComponent<TDMPlayer>().team == Team.NONE)
                return false;
            return true;
        }
        private void TeamAssign(BasePlayer player)
        {
            if (UseTDM && Started)
            {
                Team team = CountForBalance();
                if (player.GetComponent<TDMPlayer>().team == Team.NONE)
                {
                    player.GetComponent<TDMPlayer>().team = team;
                    string color = string.Empty;
                    if (team == Team.A) color = configData.TeamA_Color;
                    else if (team == Team.B) color = configData.TeamB_Color;
                    SendReply(player, string.Format(lang.GetMessage("AssignTeam", this, player.UserIDString), GetTeamName(team, player), color));
                    Puts("Player " + player.displayName + " assigned to Team " + team);
                    player.Respawn();                    
                }
            }
        }

        private string GetTeamName(Team team, BasePlayer player = null)
        {
            switch (team)
            {
                case Team.A:
                    return lang.GetMessage("TeamA", this, player?.UserIDString);
                case Team.B:
                    return lang.GetMessage("TeamB", this, player?.UserIDString);
                default:
                    return lang.GetMessage("TeamNone", this, player?.UserIDString);
            }
        }
        private Team CountForBalance()
        {
            Team PlayerNewTeam;
            int aCount = Count(Team.A);
            int bCount = Count(Team.B);

            if (aCount > bCount) PlayerNewTeam = Team.B;
            else PlayerNewTeam = Team.A;

            return PlayerNewTeam;
        }
        private int Count(Team team)
        {
            int count = 0;
            foreach (var player in TDMPlayers)
            {
                if (player.team == team) count++;
            }
            return count;
        }
        #endregion

        #region UI Scoreboard

        private void CreateScoreboard(BasePlayer player)
        {
            string GUIMin = $"{configData.GUIPosX} {configData.GUIPosY}";
            string GUIMax = $"{configData.GUIPosX + configData.GUIDimX} {configData.GUIPosY + configData.GUIDimY}";
            DestroyUI(player);
            var panelName = "TDMScoreboard";
            var element = EventManager.UI.CreateElementContainer(panelName, "0.3 0.3 0.3 0.7", GUIMin, GUIMax, false);
            EventManager.UI.CreateLabel(ref element, panelName, "", $"<color={configData.TeamA_Color}>{TeamAKills} : Team A</color>   ||   Limit : {configData.KillLimit}   ||   <color={configData.TeamB_Color}>Team B : {TeamBKills}</color>", configData.GUI_TextSize, "0 0", "1 1");           
            CuiHelper.AddUi(player, element);
        }
        #endregion

        #region Functions
        private void DestroyUI(BasePlayer player) => CuiHelper.DestroyUi(player, "TDMScoreboard");
        private void MessagePlayers(string msg)
        {
            if (UseTDM && Started)
            {
                foreach (var p in TDMPlayers)
                {
                    SendReply(p.player, msg);
                }
            }
        }
       

        List<TDMPlayer> FindPlayer(string arg)
        {
            var foundPlayers = new List<TDMPlayer>();

            ulong steamid;
            ulong.TryParse(arg, out steamid);
            string lowerarg = arg.ToLower();

            foreach (var p in TDMPlayers)
            {
                if (steamid != 0L)
                    if (p.player.userID == steamid)
                    {
                        foundPlayers.Clear();
                        foundPlayers.Add(p);
                        return foundPlayers;
                    }
                string lowername = p.player.displayName.ToLower();
                if (lowername.Contains(lowerarg))
                {
                    foundPlayers.Add(p);
                }
            }
            return foundPlayers;
        }
        #endregion

        #region Commands
        [ConsoleCommand("tdm.spawns.a")]
        void ccmdSpawnsA(ConsoleSystem.Arg arg)
        {
            if (!isAuth(arg)) return;
            if (arg.Args == null || arg.Args.Length == 0)
            {
                SendReply(arg, "tdm.spawns.a \"filename\"");
                return;
            }
            object success = Spawns.Call("GetSpawnsCount", arg.Args[0]);
            if (success is string)
            {
                SendReply(arg, (string)success);
                return;
            }
            configData.TeamA_Spawnfile = arg.Args[0];
            SaveConfig();
            SendReply(arg, string.Format("Team A spawnfile is now {0} .", configData.TeamA_Spawnfile));
        }

        [ConsoleCommand("tdm.spawns.b")]
        void ccmdSpawnsB(ConsoleSystem.Arg arg)
        {
            if (!isAuth(arg)) return;
            if (arg.Args == null || arg.Args.Length == 0)
            {
                SendReply(arg, "tdm.spawns.b \"filename\"");
                return;
            }
            object success = Spawns.Call("GetSpawnsCount", arg.Args[0]);
            if (success is string)
            {
                SendReply(arg, (string)success);
                return;
            }
            configData.TeamB_Spawnfile = arg.Args[0];
            SaveConfig();
            SendReply(arg, string.Format("Team B spawnfile is now {0} .", configData.TeamB_Spawnfile));
        }

        [ConsoleCommand("tdm.kills")]
        void ccmdKills(ConsoleSystem.Arg arg)
        {
            if (!isAuth(arg)) return;
            if (arg.Args == null || arg.Args.Length == 0)
            {
                SendReply(arg, "tdm.kills XX ");
                return;
            }
            int KillLimit;
            if (!int.TryParse(arg.Args[0], out KillLimit))
            {
                SendReply(arg, "The kill count needs to be a number");
                return;
            }
            configData.KillLimit = KillLimit;
            SaveConfig();
            SendReply(arg, string.Format("Kill count to win event is now {0} .", configData.KillLimit));
        }

        [ConsoleCommand("tdm.team")]
        private void cmdTeam(ConsoleSystem.Arg arg)
        {
            if (!UseTDM) return;
            if (!isAuth(arg)) return;
            if (arg.Args == null || arg.Args.Length != 2)
            {
                SendReply(arg, "Format: tdm.team \"playername\" \"A\" or \"B\"");
                return;
            }
            var fplayer = FindPlayer(arg.Args[0]);
            if (fplayer.Count == 0)
            {
                SendReply(arg, "No players found.");
                return;
            }
            if (fplayer.Count > 1)
            {
                SendReply(arg, "Multiple players found.");
                return;
            }
            var newTeamArg = arg.Args[1].ToUpper();
            var newTeam = Team.NONE;
            switch (newTeamArg)
            {
                case "A":
                    newTeam = Team.A;
                    break;

                case "B":
                    newTeam = Team.B;
                    break;
                default:
                    return;
            }
            var p = fplayer[0].GetComponent<TDMPlayer>();
            var currentTeam = p.team;

            if (newTeam == currentTeam)
            {
                SendReply(arg, p.player.displayName + " is already on " + currentTeam);
                return;
            }
            p.team = newTeam;
            p.player.Hurt(300, DamageType.Bullet, null, true);

            string color = string.Empty;
            if (p.team == Team.A) color = configData.TeamA_Color;
            else if (p.team == Team.B) color = configData.TeamB_Color;

            SendReply(p.player, string.Format(TitleM() + "You have been moved to <color=" + color + ">Team {0}</color>", newTeam.ToString().ToUpper()));
            SendReply(arg, string.Format("{0} has been moved to Team {1}", p.player.displayName, newTeam.ToString().ToUpper()));
        }
        bool isAuth(ConsoleSystem.Arg arg)
        {
            if (arg.connection?.authLevel < 1)
            {
                SendReply(arg, "You dont not have permission to use this command.");
                return false;
            }
            return true;
        }
        #endregion

        #region Scoring
        
        void AddKill(BasePlayer player, BasePlayer victim)
        {
            var p = player.GetComponent<TDMPlayer>();
            if (!p) return;

            if (p.team == Team.A) TeamAKills++;
            else if (p.team == Team.B) TeamBKills++;
            RefreshSB();

            EventManager.AddTokens(player.UserIDString, configData.Tokens_Kill);
            string color = string.Empty;
            if (p.team == Team.A) color = configData.TeamA_Color;
            else if (p.team == Team.B) color = configData.TeamB_Color;
            MessagePlayers(string.Format(TitleM() + "<color=" + color + ">" + lang.GetMessage("KillMsg", this) + "</color>", player.displayName, victim.displayName));
            CheckScores();
        }
        void CheckScores(bool timelimitreached = false)
        {
            if (TDMPlayers.Count <= 1)
            {
                MessagePlayers(TitleM() + lang.GetMessage("NoPlayers", this));
                EventManager.CloseEvent();
                EventManager.EndEvent();
                return;
            }
            Team winner = Team.NONE;
            if (EventManager.EventMode == EventManager.GameMode.Normal)
            {
                if (TeamAKills >= configData.KillLimit) winner = Team.A;
                else if (TeamBKills >= configData.KillLimit) winner = Team.B;
            }
            if (timelimitreached)
            {
                if (TeamAKills > TeamBKills) winner = Team.A;
                else if (TeamBKills > TeamAKills) winner = Team.B;                
            }
            if (winner != Team.NONE)
                Winner(winner);
        }
        void Winner(Team winner)
        {
            foreach (TDMPlayer p in TDMPlayers)
            {
                if (p.team == winner)
                    EventManager.AddTokens(p.player.UserIDString, configData.Tokens_Win);                    
            }
            MessagePlayers(string.Format(TitleM() + lang.GetMessage("WinMsg", this), GetTeamName(winner)));
            EventManager.CloseEvent();
            timer.Once(2, () => EventManager.EndEvent());
        }
        #endregion

        #region Class      
        class TDMPlayer : MonoBehaviour
        {
            public BasePlayer player;
            public Team team;            

            void Awake()
            {
                player = GetComponent<BasePlayer>();
                enabled = false;
                team = Team.NONE;
            }
        }

        #endregion

        #region Config     
        class ConfigData
        {
            public string DefaultKit { get; set; }
            public string EventName { get; set; }
            public string TeamA_Spawnfile { get; set; }
            public string TeamB_Spawnfile { get; set; }
            public string TeamA_Color { get; set; }
            public string TeamB_Color { get; set; }
            public string TeamA_Shirt { get; set; }
            public string TeamB_Shirt { get; set; }
            public int TeamA_SkinID { get; set; }
            public int TeamB_SkinID { get; set; }
            public float GUIPosX { get; set; }
            public float GUIPosY { get; set; }
            public float GUIDimX { get; set; }
            public float GUIDimY { get; set; }
            public int GUI_TextSize { get; set; }
            public float FF_Damage_Modifier { get; set; }
            public float StartingHealth { get; set; }
            public int KillLimit { get; set; }
            public int Tokens_Kill { get; set; }
            public int Tokens_Win { get; set; }
            public string ZoneName { get; set; }
        }  
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        
        private void LoadConfigVariables()
        {
            configData = Config.ReadObject<ConfigData>();
        }
        protected override void LoadDefaultConfig()
        {
            Puts("Creating a new config file");
            var config = new ConfigData
            {
                DefaultKit = "tdm_kit",
                EventName = "TeamDeathmatch",
                TeamA_Spawnfile = "tdmspawns_a",
                TeamB_Spawnfile = "tdmspawns_b",
                TeamA_Color = "#33CC33",
                TeamB_Color = "#003366",
                TeamA_Shirt = "tshirt",
                TeamA_SkinID = 0,
                TeamB_Shirt = "tshirt",
                TeamB_SkinID = 14177,
                GUIPosX = 0.3f,
                GUIPosY = 0.92f,
                GUIDimX = 0.4f,
                GUIDimY = 0.06f,
                GUI_TextSize = 20,
                KillLimit = 10,
                FF_Damage_Modifier = 0,
                StartingHealth = 100,
                Tokens_Kill = 1,
                Tokens_Win = 5,
                ZoneName = ""
            };
            SaveConfig(config);
        }
        void SaveConfig(ConfigData config)
        {
            Config.WriteObject(config, true);
        }
        object GetEventConfig(string configname)
        {
            if (!UseTDM) return null;
            return Config[configname];
        }
        #endregion

        #region messages
        private string TitleM() => $"<color=orange>{Title}: </color>";
        Dictionary<string, string> messages = new Dictionary<string, string>
        {
            {"WinMsg", "Team {0} has won the game!" },
            {"NoPlayers", "Not enough players to continue. Ending event" },
            {"KillMsg", "{0} killed {1}" },
            {"OpenMsg", "Use tactics and work together to defeat the enemy team" },
            {"skillTime", "{0} {1} left to kill the slasher!" },
            {"ff", "Don't shoot your team mates!"},
            {"AssignTeam", "You have been assigned to <color={1}>Team {0}</color>"},
            {"TeamA", "A" },
            {"TeamB", "B" },
            {"TeamNone", "None" }
        };
        #endregion
    }
}



// --- End of file: TeamDeathmatch.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Vending.cs ---
// --- Original Local Path: Vending.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System.Collections;
using System.Drawing;
using System.IO;
using System.Drawing.Imaging;
using Newtonsoft.Json.Converters;
using Facepunch;
using VLB;

using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Oxide.Core.Configuration;

namespace Oxide.Plugins
{
    [Info("Vending", "Frizen", "1.0.0")]
    class Vending : RustPlugin
    {
        static Vending ins;
        PluginConfig config;
        
        public class PluginConfig
        {
            [JsonProperty("Настройка торговых автоматов")]
            public Dictionary<string, Dictionary<string, VendinSetting>> Vending { get; set; }
        }

        public class VendinSetting
        {
            [JsonProperty("Время через которое будет выполняться завоз предметов (в секундах)")]
            public float refillTime;
            [JsonProperty("Настройка товаров")]
            public List<VendingOrder> orders;
        }
         
        public class VendingOrder
        {
            [JsonProperty("Добавить товар?")]
            public bool AddItem;
            [JsonProperty("Название покупаемого товара")]
            public string ItemToBuy { get; set; }
            [JsonProperty("Максимальный стак покупаемого предмета за один раз")]
            public int BuyngItemMaxAmount { get; set; }
            [JsonProperty("Количество покупаемого товара за раз")]
            public ulong BuyngItemSkinID { get; set; }
            [JsonProperty("SKINID покупаемого предмета")]
            public int BuyngItemAmount { get; set; }
            [JsonProperty("Покупаемый товар это чертёж")]
            public bool BuyngItemIsBP { get; set; }
            [JsonProperty("Название платёжного товара")]
            public string PayItemShortName { get; set; }
            [JsonProperty("Количество платёжного товара за раз")]
            public int PayItemAmount { get; set; }
            [JsonProperty("Платёжный товар это чертёж")]
            public bool PayItemIsBP { get; set; }
        }

        protected override void LoadDefaultConfig()
        {
            config = new PluginConfig
            {
                Vending = GetVendingList(),
            };
        }


        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            if (config.Vending.Count == 0)
            {
                LoadDefaultConfig();
                SaveConfig();
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        private void OnServerInitialized()
        {
            ins = this;
            VendingInit();
        }

        void Unload()
        {
            foreach (var vending in BaseNetworkable.serverEntities.OfType<NPCVendingMachine>().Where(x => x != null && x.OwnerID == 0).ToList())
            {
                vending.InstallFromVendingOrders();
            }
        }

        public Dictionary<string, Dictionary<string, VendinSetting>> GetVendingList()
        {
            Dictionary<string, Dictionary<string, VendinSetting>> vendings = new Dictionary<string, Dictionary<string, VendinSetting>>();
            var vendingList = BaseNetworkable.serverEntities.OfType<NPCVendingMachine>().Where(x => x != null && x.OwnerID == 0).ToList();
            foreach (var vending in vendingList)
            {
                var shopName = vending.shopName;
                if (!vendings.ContainsKey(vending.ShortPrefabName) || !vendings[vending.ShortPrefabName].ContainsKey(shopName))
                {
                    if (!vendings.ContainsKey(vending.ShortPrefabName))
                        vendings.Add(vending.ShortPrefabName, new Dictionary<string, VendinSetting>());
                    vending.InstallFromVendingOrders();
                    if (!vendings[vending.ShortPrefabName].ContainsKey(shopName))
                    {
                        vendings[vending.ShortPrefabName].Add(shopName, new VendinSetting());
                        vendings[vending.ShortPrefabName][shopName].refillTime = 1;
                        vendings[vending.ShortPrefabName][shopName].orders = new List<VendingOrder>();

                        List<VendingOrder> orderlist = new List<VendingOrder>();
                        foreach (var item in vending.vendingOrders.orders)
                        {
                            VendingOrder order = new VendingOrder();
                            order.BuyngItemMaxAmount = 999999;
                            order.ItemToBuy = item.sellItem.shortname;
                            order.BuyngItemAmount = item.sellItemAmount;
                            order.BuyngItemIsBP = item.sellItemAsBP;
                            order.PayItemShortName = item.currencyItem.shortname;
                            order.BuyngItemSkinID = 0;
                            order.PayItemAmount = item.currencyAmount;
                            order.PayItemIsBP = item.currencyAsBP;
                            order.AddItem = true;
                            orderlist.Add(order);
                        }
                        vendings[vending.ShortPrefabName][shopName].orders = orderlist;
                    }
                }

            }

            return vendings;
        }

        void VendingInit()
        {
            var vendingList = BaseNetworkable.serverEntities.OfType<NPCVendingMachine>().Where(x => x != null && x.OwnerID == 0).ToList();

            foreach (var vending in vendingList)
            {
                if (config.Vending.ContainsKey(vending.ShortPrefabName) && config.Vending[vending.ShortPrefabName].ContainsKey(vending.shopName))
                {
                    vending.CancelInvoke(vending.InstallFromVendingOrders);
                    vending.CancelInvoke(vending.Refill);
                    vending.ClearSellOrders();
                    vending.inventory.itemList.Clear();
                    foreach (var item in config.Vending[vending.ShortPrefabName][vending.shopName].orders)
                    {
                        if (!item.AddItem) continue;
                        ItemDefinition itemDefinition = ItemManager.FindItemDefinition(item.ItemToBuy);
                        if (itemDefinition == null)
                        {
                            PrintError($"ItemDefinition from BuyItem ShortName {item.ItemToBuy} not found.");
                            continue;
                        }
                        ItemDefinition x = ItemManager.FindItemDefinition(item.PayItemShortName);
                        if (x == null)
                        {
                            PrintError($"ItemDefinition from PayItem ShortName {item.PayItemAmount} not found.");
                            continue;
                        }
                        AddItemForSale(vending, itemDefinition.itemid, item.BuyngItemAmount, x.itemid, item.PayItemAmount, vending.GetBPState(item.BuyngItemIsBP, item.PayItemIsBP), item.BuyngItemMaxAmount, item.BuyngItemSkinID);
                    }

                    vending.InvokeRepeating(vending.Refill, config.Vending[vending.ShortPrefabName][vending.shopName].refillTime, config.Vending[vending.ShortPrefabName][vending.shopName].refillTime);
                }
            }
        }

        public void AddItemForSale(VendingMachine vending, int itemID, int amountToSell, int currencyID, int currencyPerTransaction, byte bpState, int maxByStack, ulong SkinID)
        {
            vending.AddSellOrder(itemID, amountToSell, currencyID, currencyPerTransaction, bpState);
            vending.transactionActive = true;
            if (bpState == 1 || bpState == 3)
            {
                for (int i = 0; i < maxByStack; i++)
                {
                    global::Item item = ItemManager.CreateByItemID(vending.blueprintBaseDef.itemid, 1, 0UL);
                    item.blueprintTarget = itemID;
                    vending.inventory.Insert(item);
                }
            }   
            else
            {
                var item = ItemManager.Create(ItemManager.FindItemDefinition(itemID), amountToSell * maxByStack, SkinID);
                item.MoveToContainer(vending.inventory);
                //vending.inventory.AddItem(ItemManager.FindItemDefinition(itemID), amountToSell * maxByStack, SkinID);
            }
            vending.transactionActive = false;
            vending.RefreshSellOrderStockLevel(null);
        }
    }
}


// --- End of file: Vending.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ChopperSurvival.cs ---
// --- Original Local Path: ChopperSurvival.cs ---

// Requires: EventManager
using System.Collections.Generic;
using System;
using System.Reflection;
using UnityEngine;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System.Linq;
using Rust;


namespace Oxide.Plugins
{
    [Info("ChopperSurvival", "k1lly0u", "0.2.42", ResourceId = 1590)]
    class ChopperSurvival : RustPlugin
    {        
        [PluginReference] EventManager EventManager;
        [PluginReference] Plugin Spawns;

        private bool isCurrent;
        private bool Active;
		
		private static ChopperSurvival chopperSurvival;
        private static ConfigData config;
        private FieldInfo _spawnTime = typeof(PatrolHelicopterAI).GetField("spawnTime", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));

        private float adjHeliHealth;
        private float adjHeliBulletDamage;
        private float adjMainRotorHealth;
        private float adjEngineHealth;
        private float adjTailRotorHealth;
        private float adjHeliAccuracy;

        private int WaveNumber;

        private string EventSpawnFile;
        private string MainColor;
        private string MSGColor;        

        private List<CS_Player> CSPlayers = new List<CS_Player>();
        private List<Timer> GameTimers = new List<Timer>();
        private List<CS_Helicopter> CSHelicopters = new List<CS_Helicopter>();

        public string CurrentKit;
        #region Classes
        class CS_Player : MonoBehaviour
        {
            public BasePlayer player;
            public int deaths;
            public int points;

            void Awake()
            {
                player = GetComponent<BasePlayer>();
                enabled = false;
                deaths = 0;
                points = 0;
            }
        } 
		class CS_Helicopter : MonoBehaviour
        {
            public BaseHelicopter Helicopter;
            public PatrolHelicopterAI AI;
            public Vector3 Destination;
            public float MainHealth;
            public float MaxMain;
            public float EngineHealth;
            public float MaxEngine;
            public float TailHealth;
            public float MaxTail;
            public float BodyHealth;
            public float MaxBody;
            public int UIHealth;

            void Awake()
            {
                Helicopter = GetComponent<BaseHelicopter>();                
                AI = Helicopter.GetComponent<PatrolHelicopterAI>();
                Helicopter.maxCratesToSpawn = 0;
                enabled = true;         
				chopperSurvival.timer.Once(config.HelicopterSettings.CheckDistanceTimer , () => {
				if (this != null)
					CheckDistance(GetComponent<BaseEntity>());
				});
            }

            public int DealDamage(HitInfo info)
            {
                int pointValue = 0;
                bool hitWeakSpot = false;
                
                BaseHelicopter.weakspot[] weakspotArray = Helicopter.weakspots;
                for (int i = 0; i < (int)weakspotArray.Length; i++)
                {
                    BaseHelicopter.weakspot _weakspot = weakspotArray[i];
                    string[] strArrays = _weakspot.bonenames;
                    for (int j = 0; j < strArrays.Length; j++)
                    {
                        string str = strArrays[j];
                        if (info.HitBone == StringPool.Get(str))
                        {
                            switch (str)
                            {
                                case "engine_col":
                                    hitWeakSpot = true;
                                    EngineHealth -= info.damageTypes.Total();
                                    pointValue = config.Scoring.HeliHitPoints;
                                    break;
                                case "tail_rotor_col":
                                    hitWeakSpot = true;
                                    TailHealth -= info.damageTypes.Total();
                                    pointValue = config.Scoring.RotorHitPoints;
                                    if (TailHealth < 50)
                                        Helicopter.weakspots[i].WeakspotDestroyed();
                                    break;
                                case "main_rotor_col":
                                    hitWeakSpot = true;
                                    MainHealth -= info.damageTypes.Total();
                                    pointValue = config.Scoring.RotorHitPoints;
                                    if (MainHealth < 50)
                                        Helicopter.weakspots[i].WeakspotDestroyed();
                                    break;
                            }                            
                        }
                    }
                }                
                if (!hitWeakSpot)
                {
                    pointValue = 1;
                    BodyHealth -= info.damageTypes.Total();
                }
                if (BodyHealth < 1 || EngineHealth < 1 || (TailHealth < 1 && MainHealth < 1))
                    AI.CriticalDamage();
                return pointValue;
            }
            public void SetDestination(Vector3 destination)
            {
                Destination = destination;
                AI.State_Move_Enter(Destination + new Vector3(0.0f, config.HelicopterSettings.DestinationHeightAdjust, 0.0f));
            }
            public void SetStats(int health, float main, float engine, float tail, float damage)
            {
                MainHealth = main;
                MaxMain = main;
                TailHealth = tail;
                MaxTail = tail;
                EngineHealth = engine;
                MaxEngine = engine;
                BodyHealth = health;
                MaxBody = health;
                Helicopter.bulletDamage = damage;
            }
            
			private void CheckDistance(BaseEntity entity)
            {
                if (entity == null) return;
                var currentPos = entity.transform.position;
                if (Destination != null)
                {
                    AI.SetTargetDestination(Destination + new Vector3(0.0f, config.HelicopterSettings.DestinationHeightAdjust, 0.0f));
                    if (Vector3Ex.Distance2D(currentPos, Destination) < 60)
                    {
                        if (config.HelicopterSettings.UseRockets)
                        {
                            int num = UnityEngine.Random.Range(1, 3);
                            if (num == 2)
                                AI.State_Strafe_Think(0);                            
                        }
                        else AI.State_Orbit_Think(40f);
                    }
                    else
                        AI.State_Move_Enter(Destination + new Vector3(0.0f, config.HelicopterSettings.DestinationHeightAdjust, 0.0f));
                                    
                }
				chopperSurvival.timer.Once(config.HelicopterSettings.CheckDistanceTimer , () => CheckDistance(entity));
            }
        }		
        class LeaderBoard
        {
            public string Name;
            public int Kills;
        }        
        #endregion

        #region UI Scoreboard
        private List<CS_Player> SortScores() => CSPlayers.OrderByDescending(pair => pair.points).ToList();
        private string PlayerMsg(int key, CS_Player player) => $"|  <color=#FF8C00>{key}</color>.  <color=#FF8C00>{player.player.displayName}</color> <color=#939393>--</color> <color=#FF8C00>{player.points}</color>  |";
        
        private CuiElementContainer CreateScoreboard(BasePlayer player)
        {
            DestroyUI(player);
            string panelName = "CSScoreBoard";
            var element = EventManager.UI.CreateElementContainer(panelName, "0.3 0.3 0.3 0.6", "0.1 0.95", "0.9 1", false);

            var scores = SortScores();
            var index = scores.FindIndex(a => a.player == player);

            var scoreMessage = PlayerMsg(index + 1, scores[index]);
            int amount = 3;
            for (int i = 0; i < amount; i++)
            {
                if (scores.Count >= i + 1)
                {
                    if (scores[i].player == player)
                    {
                        amount++;
                        continue;
                    }
                    scoreMessage = scoreMessage + PlayerMsg(i + 1, scores[i]);
                }
            }
            EventManager.UI.CreateLabel(ref element, panelName, "", scoreMessage, 18, "0 0", "1 1");
            return element;
        }
        private CuiElementContainer CreateHealthIndicator(CS_Helicopter heli)
        {            
            var panelName = $"csHeli_{heli.UIHealth}";
            var pos = CalcHealthPos(heli.UIHealth);
            var element = EventManager.UI.CreateElementContainer(panelName, "0.1 0.1 0.1 0.7", $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", false);

            CreateHealthElement(ref element, panelName, "Body Health", heli.MaxBody, heli.BodyHealth, 0.75f);
            CreateHealthElement(ref element, panelName, "Main Rotor", heli.MaxMain, heli.MainHealth, 0.5f);
            CreateHealthElement(ref element, panelName, "Tail Rotor", heli.MaxTail, heli.TailHealth, 0.25f);
            CreateHealthElement(ref element, panelName, "Engine Health", heli.MaxEngine, heli.EngineHealth, 0f);
                       
            return element;
        }
        private void CreateHealthElement(ref CuiElementContainer element, string panelName, string name, float maxHealth, float currentHealth, float minY)
        {
            var percent = System.Convert.ToDouble((float)currentHealth / (float)maxHealth);
            var yMax = 0.98 * percent;
            string color = "0.2 0.6 0.2 0.9";
            if (percent <= 0.5)
                color = "1 0.5 0 0.9";
            if (percent <= 0.15)
                color = "0.698 0.13 0.13 0.9";
            EventManager.UI.CreatePanel(ref element, panelName, color, $"0.01 {minY + 0.005}", $"{yMax} {minY + 0.24}");
            EventManager.UI.CreateLabel(ref element, panelName, "", name, 8, $"0 {minY}", $"1 {minY + 0.25}");
        }
        private void DestroyHealthUI(int number)
        {
            foreach (var entry in CSPlayers)
                CuiHelper.DestroyUi(entry.player, $"csHeli_{number}");
        }
        private void DestroyAllHealthUI(BasePlayer player)
        {
            for (int i = 0; i < config.EventSettings.MaximumHelicopters; i++)
                CuiHelper.DestroyUi(player, $"csHeli_{i}");
        }
        private void RefreshUI()
        {
            foreach (var entry in CSPlayers)
            {                
                AddUI(entry.player);
            }
        }
        private void RefreshHealthUI(CS_Helicopter heli)
        {
            if (!heli) return;
            if (config.EventSettings.ShowHeliHealthUI)
            {
                foreach (var entry in CSPlayers)
                {
                    CuiHelper.DestroyUi(entry.player, $"csHeli_{heli.UIHealth}");
                    CuiHelper.AddUi(entry.player, CreateHealthIndicator(heli));
                }
            }
        }
        private void RefreshPlayerHealthUI(BasePlayer player)
        {
            if (config.EventSettings.ShowHeliHealthUI)
            {
                foreach (var heli in CSHelicopters)
                {
                    CuiHelper.DestroyUi(player, $"csHeli_{heli.UIHealth}");
                    CuiHelper.AddUi(player, CreateHealthIndicator(heli));
                }
            }
        }
        private void AddUI(BasePlayer player) => CuiHelper.AddUi(player, CreateScoreboard(player));
        private void DestroyUI(BasePlayer player) => CuiHelper.DestroyUi(player, "CSScoreBoard");
        private float[] CalcHealthPos(int number)
        {
            Vector2 position = new Vector2(0.1f, 0.86f);
            Vector2 dimensions = new Vector2(0.13f, 0.08f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 6)
            {
                offsetX = (0.0033f + dimensions.x) * number;
            }
            if (number > 5 && number < 12)
            {
                offsetX = (0.0033f + dimensions.x) * (number - 6);
                offsetY = (-0.005f - dimensions.y) * 1;
            }
            if (number > 11 && number < 18)
            {
                offsetX = (0.0033f + dimensions.x) * (number - 12);
                offsetY = (-0.005f - dimensions.y) * 2;
            }            

            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }
        #endregion

        #region Oxide hooks
        void OnServerInitialized()
        {
            isCurrent = false;
            Active = false;
            if (EventManager == null)
            {
                Puts(MSG("noEvent"));
                return;
            }
            LoadVariables();
            chopperSurvival = this;
            config = configData;
            EventSpawnFile = config.EventSettings.DefaultSpawnfile;
            MainColor = config.Messaging.MainColor;
            MSGColor = config.Messaging.MSGColor;
            RegisterMessages();
            RegisterGame();
        }    
        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList) { DestroyUI(player); DestroyAllHealthUI(player); }
            if (isCurrent && Active)                                    
                EventManager.EndEvent(); 
				DestroyEvent();
        }        
		void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
			if (isCurrent && Active && entity != null)
            {
				if (entity.GetComponent<CS_Helicopter>() && hitInfo.Initiator != null && hitInfo.Initiator is BasePlayer && !hitInfo.Initiator.GetComponent<CS_Player>())
				{	
					hitInfo.damageTypes = new DamageTypeList();
					return;
				}
				if (hitInfo.Initiator != null && hitInfo.Initiator is BasePlayer && hitInfo.Initiator.GetComponent<CS_Player>())
				{
					var attacker = hitInfo.Initiator as BasePlayer;
					if (entity is BasePlayer)
					{
						if (entity.ToPlayer() == null || hitInfo == null) return;
						if (entity.ToPlayer().userID != hitInfo.Initiator.ToPlayer().userID)                            
							if (entity.GetComponent<CS_Player>())
							{
								hitInfo.damageTypes.ScaleAll(config.PlayerSettings.FFDamageScale);
								MessagePlayer(attacker, "", MSG("fFire"));
							}
					}
					if (entity.GetComponent<CS_Helicopter>())
					{
						int points = entity.GetComponent<CS_Helicopter>().DealDamage(hitInfo);
                        RefreshHealthUI(entity.GetComponent<CS_Helicopter>());
						hitInfo.damageTypes = new DamageTypeList();
						hitInfo.HitMaterial = 0;
						hitInfo.PointStart = Vector3.zero;
						attacker.GetComponent<CS_Player>().points += points;
					}
				}
			}
        } 		
        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (isCurrent && Active)
            {
                if (entity is BaseEntity)
                {
                    var entityName = entity.ShortPrefabName;

					
                    if (entityName.Contains("napalm"))
                        if (!config.HelicopterSettings.UseRockets)
                            KillEntity(entity as BaseEntity);

                    if (entityName.Contains("servergibs_patrolhelicopter"))
                        entity.KillMessage();
                }
            }
        }
        object CanBeTargeted(BaseCombatEntity target, MonoBehaviour turret)
        {
            if (isCurrent && Active && target is BasePlayer && turret is HelicopterTurret)
            {
                if ((turret as HelicopterTurret)._heliAI && (turret as HelicopterTurret)._heliAI.GetComponent<CS_Helicopter>())
                {
                    if ((target as BasePlayer).GetComponent<CS_Player>())
                        return null;
                    else
                        return false;
                }
                else
                {
                    return null;
                }
            }
            return null;
        }        
        void OnEntityDeath(BaseEntity entity, HitInfo hitinfo)
        {
            if (isCurrent && Active)            
                if (entity.GetComponent<BaseHelicopter>())                
                    if (entity.GetComponent<CS_Helicopter>())
                    {
                        DestroyHealthUI(entity.GetComponent<CS_Helicopter>().UIHealth);
                        DestroyFires(entity.transform.position);
                        CSHelicopters.Remove(entity.GetComponent<CS_Helicopter>());
                        UnityEngine.Object.Destroy(entity.GetComponent<CS_Helicopter>());                        
                        MessageAllPlayers(MSG("heliDest"), "", true);

                        if (CSHelicopters.Count == 0)
                            NextRound();
                    }
        }
        #endregion
		
        #region Chopper Survival
        private void StartRounds()
        {
            if (isCurrent && Active)
            {
                WaveNumber = 1;
                MessageAllPlayers(string.Format(MSG("firstWave"), config.HelicopterSettings.SpawnBeginTimer), "", true);
                SetPlayers();
                GameTimers.Add(timer.Once(config.HelicopterSettings.SpawnBeginTimer, () => SpawnWave()));
                
				GameTimers.Add(timer.Repeat(5, 0, () => RefreshUI()));
            }
        }
        private void NextRound()
        {
            if (isCurrent && Active)
            {
                DestroyTimers();
                GameTimers.Add(timer.Repeat(5, 0, () => RefreshUI()));
                WaveNumber++;
                AddPoints();
                if (EventManager.EventMode == EventManager.GameMode.Normal)
                {
                    if (WaveNumber > config.EventSettings.MaximumWaves)
                    {
                        FindWinner();
                        return;
                    }
                }               
                SetPlayers();
                MessageAllPlayers(string.Format(MSG("nextWave"), config.HelicopterSettings.SpawnWaveTimer), "", true);
                GameTimers.Add(timer.Once(config.HelicopterSettings.SpawnWaveTimer, () => SpawnWave()));
            }
        }
        private void SetPlayers()
        {
            foreach (CS_Player hs in CSPlayers)
            {
                EventManager.GivePlayerKit(hs.player, CurrentKit);
                hs.player.health = config.PlayerSettings.StartHealth;
            }
        }
        private void SpawnWave()
        {
            if (isCurrent && Active)
            {
                var num = System.Math.Ceiling(((float)WaveNumber / (float)config.EventSettings.MaximumWaves) * (float)config.EventSettings.MaximumHelicopters);
                if (num < 1) num = 1;
                if (WaveNumber == 1) InitStatModifiers();
                else SetStatModifiers();
                SpawnHelicopter((int)num);
                SetHelicopterStats();
                if (config.EventSettings.ShowHeliHealthUI)
                {
                    foreach(var heli in CSHelicopters)
                    {
                        RefreshHealthUI(heli);
                    }
                }
                MessageAllPlayers("", string.Format(MSG("waveInbound"), WaveNumber));
            }
        }
		private void SpawnHelicopter(int num)
        {
            bool lifetime = false;
			if (ConVar.PatrolHelicopter.lifetimeMinutes == 0)
			{
				ConVar.PatrolHelicopter.lifetimeMinutes = 1;
				lifetime = true;
			}
			
			for (int i = 0; i < num; i++)
            {
                BaseEntity entity = GameManager.server.CreateEntity("assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab", new Vector3(), new Quaternion(), true);
                if (entity)
                {
                    BaseHelicopter heli = entity.GetComponent<BaseHelicopter>();
					entity.Invoke("CS_Helicopter", 3600f);
					entity.Spawn();
                    var csHeli = heli.gameObject.AddComponent<CS_Helicopter>();
                    CSHelicopters.Add(csHeli);
                    csHeli.UIHealth = CSHelicopters.Count - 1;
                    
                    heli.GetComponent<CS_Helicopter>().enabled = true;
                    MoveToArena(entity);
					_spawnTime.SetValue(entity.GetComponent<PatrolHelicopterAI>(), UnityEngine.Time.realtimeSinceStartup* 10);					
                }
            }			
			if(lifetime)
				timer.Once(5f, () => ConVar.PatrolHelicopter.lifetimeMinutes = 0);
        }

        private void InitStatModifiers()
        {
            adjHeliBulletDamage = config.HelicopterSettings.HeliBulletDamage;
            adjHeliHealth = config.HelicopterSettings.HeliHealth;
            adjMainRotorHealth = config.HelicopterSettings.MainRotorHealth;
            adjEngineHealth = config.HelicopterSettings.EngineHealth;
            adjTailRotorHealth = config.HelicopterSettings.TailRotorHealth;
            adjHeliAccuracy = config.HelicopterSettings.HeliAccuracy;
            if (config.EventSettings.ShowStatsInConsole) ShowHeliStats();
        }
        private void SetStatModifiers()
        {
            if (isCurrent)
            {
                var HeliModifier = config.HelicopterSettings.HeliModifier;
                adjHeliBulletDamage *= HeliModifier;
                adjHeliHealth *= HeliModifier;
                adjMainRotorHealth *= HeliModifier;
                adjEngineHealth *= HeliModifier;
                adjTailRotorHealth = adjTailRotorHealth * HeliModifier;
                adjHeliAccuracy = adjHeliAccuracy - (HeliModifier / 1.5f);
                if (config.EventSettings.ShowStatsInConsole) ShowHeliStats();
            }
        }
        private void ShowHeliStats()
        {
            Puts("---- CS Heli Stats ----");
            Puts("Modifier: " + config.HelicopterSettings.HeliModifier);
            Puts("Damage: " + adjHeliBulletDamage);
            Puts("Health: " + adjHeliHealth);
            Puts("Main rotor: " + adjMainRotorHealth);
            Puts("Engine: " + adjEngineHealth);
            Puts("Tail rotor: " + adjTailRotorHealth);
            Puts("Accuracy: " + adjHeliAccuracy);
        }       
        private void SetHelicopterStats()
        {
            foreach (var heli in CSHelicopters)            
                heli.SetStats((int)adjHeliHealth, adjMainRotorHealth, adjEngineHealth, adjTailRotorHealth, adjHeliBulletDamage);
            ConVar.PatrolHelicopter.bulletAccuracy = adjHeliAccuracy;
        }
        private void MoveToArena(BaseEntity entity)
        {
            Vector3 spawnPos = FindSpawnPosition(GetDestination());
            entity.transform.position = spawnPos;
            entity.GetComponent<CS_Helicopter>().SetDestination(GetDestination());
        }
        private Vector3 GetDestination() => (Vector3)Spawns.Call("GetRandomSpawn", new object[] { EventSpawnFile });
        private Vector3 FindSpawnPosition(Vector3 arenaPos)
        {
            float x = 0;
            float y = 0;
            float angleRadians = 0;
            Vector2 circleVector;
            angleRadians = UnityEngine.Random.Range(0, 180) * Mathf.PI / 180.0f;
            x = config.HelicopterSettings.SpawnDistance * Mathf.Cos(angleRadians);
            y = config.HelicopterSettings.SpawnDistance * Mathf.Sin(angleRadians);
            circleVector = new Vector2(x, y);           
            Vector3 finalPos = FindGround(new Vector3(circleVector.x + arenaPos.x, 0, circleVector.y + arenaPos.z));
            if (finalPos.y < 1) finalPos.y = 5;
            finalPos.y = finalPos.y + 50;

            return finalPos;
        }         
        private void DestroyEvent()
        {
            Active = false;            
				DestroyTimers();
				DestroyHelicopters();
				DestroyPlayers();
        }		
        private void DestroyHelicopters()
        {
            if (CSHelicopters != null)
            {
                foreach (var heli in CSHelicopters)
                {
					if(heli.Helicopter != null)
						if(heli.Helicopter.transform != null)
							DestroyFires(heli.Helicopter.transform.position);
						if(heli.Helicopter != null)
							heli.Helicopter.DieInstantly();
						UnityEngine.Object.Destroy(heli);
                }
                CSHelicopters.Clear();
            }
        }
        private void DestroyFires(Vector3 pos)
        {
			timer.Once(5, () =>
            {
                if(pos == null) return;
				var allobjects = Physics.OverlapSphere(pos, 150);
				foreach (var gobject in allobjects)
                {                   
                    if (gobject.name.ToLower().Contains("oilfireballsmall") || gobject.name.ToLower().Contains("napalm"))
                    {                       
                        var fire = gobject.GetComponent<BaseEntity>();                        
                        KillEntity(fire);
                        UnityEngine.Object.Destroy(gobject);                       
                    }
                }
            });
        }
        void KillEntity(BaseEntity entity)
        {
            if (BaseEntity.saveList.Contains(entity))
                BaseEntity.saveList.Remove(entity);
            entity.KillMessage();
        }
        private void DestroyTimers()
        {
            if (GameTimers != null)
            {
                foreach (var time in GameTimers)
                    time.Destroy();
                GameTimers.Clear();
            }
        }
      
        private void DestroyPlayers()
        {
            if (CSPlayers != null)
            {
                foreach (var player in CSPlayers)
                {
                    DestroyUI(player.player);
                    DestroyAllHealthUI(player.player);
                    UnityEngine.Object.Destroy(player);
                }
                CSPlayers.Clear();
            }       
        }

        static Vector3 FindGround(Vector3 sourcePos) // credit Wulf & Nogrod
        {
            RaycastHit hitInfo;
            if (Physics.Raycast(sourcePos, Vector3.down, out hitInfo, LayerMask.GetMask("Terrain", "World", "Construction")))            
                sourcePos.y = hitInfo.point.y;            
            sourcePos.y = Mathf.Max(sourcePos.y, TerrainMeta.HeightMap.GetHeight(sourcePos));
            return sourcePos;
        }

        #endregion

        #region EventManager hooks
        void RegisterGame()
        {
            var success = EventManager.RegisterEventGame(Title);//, config.EventSettings.DefaultSpawnfile, config.EventSettings.DefaultKit, config.EventSettings.DefaultZoneID, true, true, true, 2, 0, false, true, true, false);
            if (success == null)
                Puts(MSG("noEvent"));
        }
        void OnSelectEventGamePost(string name)
        {
            if (Title == name)
            {
                isCurrent = true;
                if (EventSpawnFile != null && EventSpawnFile != "")
                    EventManager.SelectSpawnfile(EventSpawnFile);
            }
            else
                isCurrent = false;
        }
        void OnEventPlayerSpawn(BasePlayer player)
        {
            if (isCurrent && Active)
            {                
                player.inventory.Strip();
                EventManager.GivePlayerKit(player, CurrentKit);
                //PATCH >>> some more player options
				player.metabolism.hydration.value = config.PlayerSettings.StartHydration;
				player.metabolism.calories.value = config.PlayerSettings.StartCalories;
				player.InitializeHealth(config.PlayerSettings.StartHealth, config.PlayerSettings.StartHealth);
				timer.Once(3, ()=> { AddUI(player); RefreshPlayerHealthUI(player); });
            }
        }       
        object OnEventOpenPost()
        {
            if (isCurrent)
            {
                MessageAll(MSG("openBroad"), "", true);
            }
            return null;
        }

        object OnEventCancel()
        {
            FindWinner();
            return null;
        }
        object OnEventEndPre()
        {
            if (isCurrent)
            {
					DestroyTimers();
					FindWinner();
					DestroyEvent();
            }           
            return null;
        }    
        object OnEventEndPost()
        {
            var objPlayers = UnityEngine.Object.FindObjectsOfType<CS_Player>();
            if (objPlayers != null)
                foreach (var gameObj in objPlayers)
                    UnityEngine.Object.Destroy(gameObj);
            var objHelis = UnityEngine.Object.FindObjectsOfType<CS_Helicopter>();
            if (objHelis != null)
                foreach (var gameObj in objHelis)
                    UnityEngine.Object.Destroy(gameObj);
            return null;
        }       
        object OnEventStartPre()
        {
            if (isCurrent)
            {
                Active = true;                
            }          
            return null;
        }        
        object OnSelectKit(string kitname)
        {
            if (isCurrent)
            {
                CurrentKit = kitname;
                return true;
            }
            return null;
        }
        
        object OnEventJoinPost(BasePlayer player)
        {
            if (isCurrent)
            {
                if (player.GetComponent<CS_Player>())
                    UnityEngine.Object.Destroy(player.GetComponent<CS_Player>());
                CSPlayers.Add(player.gameObject.AddComponent<CS_Player>());
                if (Active)
                OnEventPlayerSpawn(player);                              
            }
            return null;
        }       
        object OnEventLeavePost(BasePlayer player)
        {
            if (isCurrent)            
                if (player.GetComponent<CS_Player>())
                {
                    CSPlayers.Remove(player.GetComponent<CS_Player>());
                    UnityEngine.Object.Destroy(player.GetComponent<CS_Player>());
					DestroyUI(player);
                    DestroyAllHealthUI(player);
                }            
            if (isCurrent && Active)            
                if (CSPlayers.Count == 0)
                    EventManager.EndEvent();                           
            return null;
        }        
        void OnEventPlayerDeath(BasePlayer victim, HitInfo hitinfo)
        {
            if (Active)
            {
                DestroyUI(victim);
                DestroyAllHealthUI(victim);
                victim.GetComponent<CS_Player>().deaths++;
                int LivesLeft = (config.PlayerSettings.DeathLimit - victim.GetComponent<CS_Player>().deaths);

                MessageAll(string.Format(MSG("eventDeath"), victim.displayName, victim.GetComponent<CS_Player>().deaths, config.PlayerSettings.DeathLimit), "", true);               
                MessagePlayer(victim, string.Format(MSG("livesLeft"), LivesLeft), "", true);

                if (victim.GetComponent<CS_Player>().deaths >= config.PlayerSettings.DeathLimit)
                {
                    if (CSPlayers.Count == 1)
                    {
                        Winner(victim);
                        return;
                    }
                    EventManager.LeaveEvent(victim);                    
                }
            }
            return;
        }    
        object OnRequestZoneName()
        {
            if (isCurrent) 
                if (!string.IsNullOrEmpty(config.EventSettings.DefaultZoneID))          
                    return config.EventSettings.DefaultZoneID;            
            return null;
        }
        object OnSelectSpawnFile(string name)
        {
            if (isCurrent)
            {
                EventSpawnFile = name;
                return true;
            }
            return null;
        }        
        object OnEventStartPost()
        {            
            StartRounds();            
            return null;
        }
        #endregion

        #region Messaging
        private string MSG(string msg) => lang.GetMessage(msg, this);
        private void MessageAll(string msg, string keyword = "", bool title = false)
        {
            string titlestring = "";
            if (title) titlestring = lang.GetMessage("title", this);
            PrintToChat(MainColor + titlestring + keyword + "</color>" + MSGColor + msg + "</color>");
        }
        private void MessageAllPlayers(string msg, string keyword = "", bool title = false)
        {
            string titlestring = "";
            if (title) titlestring = lang.GetMessage("title", this);
            foreach (var csplayer in CSPlayers)
                SendReply(csplayer.player, MainColor + titlestring + keyword + "</color>" + MSGColor + msg + "</color>");
        }
        private void MessagePlayer(BasePlayer player, string msg, string keyword = "", bool title = false)
        {
            string titlestring = "";
            if (title) titlestring = lang.GetMessage("title", this);
            SendReply(player, MainColor + titlestring + keyword + "</color>" + MSGColor + msg + "</color>");
        }
        private void RegisterMessages() => lang.RegisterMessages(new Dictionary<string, string>()
        {
            {"noEvent", "Event plugin doesn't exist" },
            {"noConfig", "Creating a new config file" },
            {"title", "ChopperSurvival : "},
            {"fFire", "Friendly Fire!"},
            {"nextWave", "Next wave in {0} seconds!"},
            {"noPlayers", "The event has no more players, auto-closing."},
            {"openBroad", "Fend off waves of attacking helicopters! Each hit gives you a point, Rotor hits are worth more. The last player standing, or the player with the most points wins!"},
            {"eventWon", "{0} has won the event with {1} points!"},
            {"eventDeath", "{0} has died {1}/{2} times!"},
            {"waveInbound", "Wave {0} inbound!"},
            {"firstWave", "You have {0} seconds to prepare for the first wave!"},
            {"heliDest", "Helicopter Destroyed!"},
            {"livesLeft", "You have {0} lives remaining!"},
            {"notEnough", "Not enough players to start the event"}
        },this);
        #endregion

        #region Config        
        private ConfigData configData;
        class EventSettings
        {
            public string DefaultKit { get; set; }
            public string DefaultSpawnfile { get; set; }
            public string DefaultZoneID { get; set; }
            public int MaximumWaves { get; set; }
            public int MaximumHelicopters { get; set; }
            public bool ShowStatsInConsole { get; set; }
            public bool ShowHeliHealthUI { get; set; }
        }
        class PlayerSettings
        {
            public float StartHealth { get; set; }
            public float StartHydration { get; set; }
            public float StartCalories { get; set; }  
            public int DeathLimit { get; set; }  
            public float FFDamageScale { get; set; }    
        }
        class HeliSettings
        {
            public float HeliBulletDamage { get; set; }
            public float HeliHealth { get; set; }
            public float MainRotorHealth { get; set; }
            public float TailRotorHealth { get; set; }
            public float EngineHealth { get; set; }
            public float HeliSpeed { get; set; }
            public float HeliAccuracy { get; set; }
            public float HeliModifier { get; set; }
            public float SpawnDistance { get; set; }
            public float CheckDistanceTimer { get; set; }
            public float DestinationHeightAdjust { get; set; }
            public float SpawnWaveTimer { get; set; }
            public float SpawnBeginTimer { get; set; }
            
            public bool UseRockets { get; set; }
        }
        class Messaging
        {
            public string MainColor { get; set; }
            public string MSGColor { get; set; }
        }
        class ConfigData
        {
            public EventSettings EventSettings { get; set; }
            public HeliSettings HelicopterSettings { get; set; }
            public PlayerSettings PlayerSettings { get; set; }
            public Messaging Messaging { get; set; }
            public Scoring Scoring { get; set; }
        }
        class Scoring
        {
            public int RotorHitPoints { get; set; }
            public int HeliHitPoints { get; set; }
            public int SurvivalTokens { get; set; }
            public int WinnerTokens { get; set; }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                EventSettings = new EventSettings
                {                    
                    DefaultKit = "cskit",
                    DefaultSpawnfile = "csspawns",
                    DefaultZoneID = "cszone",
                    MaximumHelicopters = 4,
                    MaximumWaves = 10,
                    ShowHeliHealthUI = true,
                    ShowStatsInConsole = true
                },
                HelicopterSettings = new HeliSettings
                {
                    CheckDistanceTimer = 10f,
                    DestinationHeightAdjust = 10f,
                    EngineHealth = 800f,
                    HeliAccuracy = 8f,
                    HeliBulletDamage = 4f,
                    HeliHealth = 3800f,
                    HeliModifier = 1.22f,
                    HeliSpeed = 24f,
                    MainRotorHealth = 420f,
                    SpawnBeginTimer = 20f,
                    SpawnDistance = 500f,
                    SpawnWaveTimer = 10f,
                    TailRotorHealth = 300f,
                    UseRockets = true
                },
                Messaging = new Messaging
                {                    
                    MainColor = "<color=#FF8C00>",
                    MSGColor = "<color=#939393>"
                },
                PlayerSettings = new PlayerSettings
                {                    
                    DeathLimit = 10,
                    FFDamageScale = 0,
                    StartCalories = 500f,
                    StartHealth = 100f,
                    StartHydration = 250f
                },
                Scoring = new Scoring
                {
                    HeliHitPoints = 1,
                    RotorHitPoints = 3,
                    SurvivalTokens = 1,
                    WinnerTokens = 10
                }
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion
       
        #region Scoring
        void AddPoints()
        {
            foreach (CS_Player helisurvivalplayer in CSPlayers)            
                EventManager.AddTokens(helisurvivalplayer.player.UserIDString, config.Scoring.SurvivalTokens);
        }
        void FindWinner()
        {            
            AddPoints();
            int i = 0;
            BasePlayer winner = null;
            foreach (var player in CSPlayers)            
                if (player.GetComponent<CS_Player>().points > i)
                {
                    i = player.GetComponent<CS_Player>().points;
                    winner = player.player;
                }            
            if (winner != null)
                Winner(winner);
        }
        void Winner(BasePlayer player)
        {
            EventManager.AddTokens(player.UserIDString, config.Scoring.WinnerTokens);
            MessageAllPlayers(string.Format(MSG("eventWon"), player.displayName, player.GetComponent<CS_Player>().points), "", true);
            var emptobject = new object[] { };
            EventManager.CloseEvent();
            EventManager.EndEvent();
        }
        #endregion
    }
}



// --- End of file: ChopperSurvival.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SimpleKillFeed.cs ---
// --- Original Local Path: SimpleKillFeed.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using System.Text;
using Facepunch;
using Facepunch.Math;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using UnityEngine;
using ProtoBuf;

/**********************************************************************
*
*   2.1.0   -   Npc displaynames will now be propperly used
*           -   Npc without names will use their translated prefab name or custom name
*           -   Fixed -1 notification when blown up
*           -   When blown up will show what explosive is used
*           -   Removed old Blownup sequence and using the regular kill messages,
*               since the weaponcheck check is updated with explosives
*           -   Added Animal kills to the feed (by example of crazyR17)
*   2.1.1   -   Removed obsolete Blown messages from language file
*           -   Reverted distance check
*           -   Hotfix
*   2.1.2   -   More checks in GetWeaponName
*           -   Added Bradley shell kills and feed
*           -   Added direct falling deaths to the feed
*           -   For animals : instead of entity prefab check on each death it just checks for BaseAnimalNPC
*               then does the check listed in cfg (this should improve performance when animal feed is used)
*           -   Added SimpleShark to the feed
*           -   Fixed occasional error on suicide
*           -   Possible fix for npc suicides
*           +   "MsgFeedKillFall", "<color=#ff686b>{0}</color> died by <color=orange>Fall</color>"
*           +   "MsgFeedKillBrad", "<color=#ff686b>{0}</color> was killed by a <color=orange>Shell</color>"
*   2.2.0   -   Disabled showing npc killing eachother
*           -   Fix for console spamm
*   2.2.1   -   Possible fix for unknown animal/npc kill trigger
*           -   Removed Catch
*   2.2.2   -   Added nullcheck if attacker is somehow null
*           -   Added a check for turrets killing npc
*   2.2.3   -   Fixed Npc kills showing when disabled in cfg
*           -   Added Damagetype events for Cold/Drowning/Fall/Hunger & Thirst/Electricshock
*           -   Added messages in language file for the new Damagetypes
*           -   Added kill triggers to the cfg (backup and delete the old cfg file before updating)
*   2.2.4   -   Added Killed by outpost checks
*           -   Returns when deaths are generic
*           -   Kills by entities should display better (was blocked in certain cases)
*           -   Trap triggers are moved earlyer inside the check queue
*           -   Killfeed wil now display traps and outpost sentry kills seperatly
*           -   Npc kills will display explosives again
*           -   Cactus deaths no longer throw errors and are displayed in the feed
*           -   new language file entries for MsgFeedKillSentry/MsgFeedKillCactus
*   2.2.5   -   Added API SendKillfeedmessage(string msg)
*               SimpleKillFeed?.Call("SendKillfeedmessage", "Test message for killfeed api");
*               Catching when target has invalid requirements
*               Removed Generic
*   2.2.6   -   Possible fix for double clan tag using Clans by Mevent
*           -   Seperated animal kils and death by animals (cfg)
*   2.2.7   -   Added MLRS
*               Added ZombieHorde npc support
*               Fix for animal deaths showing when disabled
*               Changed from Hud to Under as suggested
*               Modular Cars are now shown as weapon
*               Fixed kill Distance when using a car
*   2.2.8       Hotfix
*           
***********************************************************************/
namespace Oxide.Plugins
{
    [Info("Simple Kill Feed", "Krungh Crow", "2.2.8")]
    [Description("A kill feed, that displays various kill events in the top right corner.")]
    public class SimpleKillFeed : RustPlugin
    {
        #region Fields

        [PluginReference] private Plugin Clans;
        private bool _isClansReborn;
        private bool _isClansIo;
        private bool _isClansMevent;
        private readonly Dictionary<uint, string> _itemNameMapping = new Dictionary<uint, string>();
        private GameObject _holder;
        private KillQueue _killQueue;
        private static SKFConfig configdata;
        private static SimpleKillFeedData _data;

        #endregion

        #region Config

        private class SKFConfig
        {
            [JsonProperty("Show Traps and Entitys in Kill Feed")]
            public bool EnableEntityFeed;
            [JsonProperty("Show Animals kills (default true)")]
            public bool EnableAnimalFeed;
            [JsonProperty("Show Npcs kills (Default true)")]
            public bool EnableNpcFeed;
            [JsonProperty("Show suicides (Default: true)")]
            public bool EnableSuicides;
            [JsonProperty("Show Deaths by Animals (Default: true)")]
            public bool EnableAnimal;
            [JsonProperty("Show Deaths by Cold (Default: true)")]
            public bool EnableCold;
            [JsonProperty("Show deaths by Drowning (Default: true)")]
            public bool EnableDrowning;
            [JsonProperty("Show Deaths by Fall (Default: true)")]
            public bool EnableFall;
            [JsonProperty("Show Deaths by Hunger (Default: true)")]
            public bool EnableHunger;
            [JsonProperty("Show Deaths by Electricution (Default: true)")]
            public bool EnableElectricution;
            [JsonProperty("Show Deaths by Radiation (Default: true)")]
            public bool EnableRadiationKills;
            [JsonProperty("Chat Icon Id (Steam profile ID)")]
            public ulong IconId;
            [JsonProperty("Max messages in feed (Default: 5)")]
            public int MaxFeedMessages;
            [JsonProperty("Max player name length in feed (Default: 18)")]
            public int MaxPlayerNameLength;
            [JsonProperty("Feed message TTL in seconds (Default: 7)")]
            public int FeedMessageTtlSec;
            [JsonProperty("Allow kill messages in chat along with kill feed")]
            public bool EnableChatFeed;
            [JsonProperty("Log PvP Kill events")]
            public bool EnableLogging;
            [JsonProperty("Height ident (space between messages). Default: 0.0185")]
            public float HeightIdent;
            [JsonProperty("Feed Position - Anchor Max. (Default: 0.995 0.986")]
            public string AnchorMax;
            [JsonProperty("Feed Position - Anchor Min. (Default: 0.723 0.964")]
            public string AnchorMin;
            [JsonProperty("Font size of kill feed (Default: 12)")]
            public int FontSize;
            [JsonProperty("Outline Text Size (Default: 0.5 0.5)")]
            public string OutlineSize;
            [JsonProperty("Default color for distance (if too far from any from the list). Default: #FF8000")]
            public string DefaultDistanceColor;
            [JsonProperty("Distance Colors List (Certain color will apply if distance is <= than specified)")]
            public DistanceColor[] DistanceColors;
            [JsonProperty("Custom Entity Names, you can remove or add more!")]
            public Dictionary<string, string> Ents = new Dictionary<string, string>();
            [JsonProperty("Custom Animal Names, you can remove or add more!")]
            public Dictionary<string, string> Animal = new Dictionary<string, string>();
            [JsonProperty("Custom Weapon Names, you can add more!")]
            public Dictionary<string, string> Weapons = new Dictionary<string, string>();
            [JsonProperty("Custom Npc Names, you can add more!")]
            public Dictionary<string, string> Npcs = new Dictionary<string, string>();

            [OnDeserialized]
            internal void OnDeserialized(StreamingContext ctx) => Array.Sort(DistanceColors, (o1, o2) => o1.DistanceThreshold.CompareTo(o2.DistanceThreshold));

            public class DistanceColor
            {
                public int DistanceThreshold;
                public string Color;
                public bool TestDistance(int distance) => distance <= DistanceThreshold;
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configdata = Config.ReadObject<SKFConfig>();
        }

        protected override void LoadDefaultConfig()
        {
            configdata = new SKFConfig
            {
                EnableEntityFeed = true,
                EnableAnimalFeed = true,
                EnableNpcFeed = true,
                EnableFall = true ,
                EnableHunger = true ,
                EnableElectricution = true,
                EnableSuicides = true,
                EnableAnimal = true ,
                EnableCold = true ,
                EnableDrowning = true,
                EnableRadiationKills = true,
                IconId = 76561197960839785UL,
                MaxFeedMessages = 5,
                MaxPlayerNameLength = 18,
                FeedMessageTtlSec = 7,
                EnableChatFeed = true,
                EnableLogging = false,
                HeightIdent = 0.0185f,
                AnchorMax = "0.995 0.986",
                AnchorMin = "0.723 0.964",
                FontSize = 12,
                OutlineSize = "0.5 0.5",
                DefaultDistanceColor = "#FF8000",
                DistanceColors = new[]
                {
                    new SKFConfig.DistanceColor
                    {
                        Color = "#FFFFFF",
                        DistanceThreshold = 50
                    },
                    new SKFConfig.DistanceColor
                    {
                        Color = "#91D6FF",
                        DistanceThreshold = 100
                    },
                    new SKFConfig.DistanceColor
                    {
                        Color = "#FFFF00",
                        DistanceThreshold = 150
                    }
                },
                Ents = new Dictionary<string, string>()
                {
                    { "autoturret_deployed","Auto Turret" },
                    { "flameturret.deployed","Flame Turret"},
                    { "guntrap.deployed","Gun Trap"},
                    { "landmine","Landmine"},
                    { "beartrap","Bear Trap"},
                    { "sam_site_turret_deployed","Sam Site Turret"},
                    { "patrolhelicopter","Helicopter"},
                    { "bradleyapc","Bradley APC"}
                },
                Animal = new Dictionary<string, string>()
                {
                    { "bear","Bear" },
                    { "polarbear","PolarBear" },
                    { "wolf","Wolf" },
                    { "stag","Stag"},
                    { "boar","Boar" },
                    { "chicken","Chicken" },
                    { "horse","Horse"},
                    { "simpleshark","Shark" }
                },
                Weapons = new Dictionary<string, string>()
                {
                    { "Assault Rifle","Ak-47" },
                    { "LR-300 Assault Rifle","LR-300" },
                    { "L96 Rifle","L96" },
                    { "Bolt Action Rifle","Bolt" },
                    { "Semi-Automatic Rifle","Semi-AR" },
                    { "Semi-Automatic Pistol","Semi-AP" },
                    { "Spas-12 Shotgun","Spas-12" },
                    { "M92 Pistol","M92" }
                },
                Npcs = new Dictionary<string, string>()
                {
                    { "scientist","Scientist Npc" }
                }
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configdata);

        #endregion

        #region Data (ProtoBuf)

        [ProtoContract(ImplicitFields = ImplicitFields.AllPublic)]
        private class SimpleKillFeedData
        {
            public HashSet<ulong> DisabledUsers = new HashSet<ulong>();
        }

        private void LoadData()
        {
            _data = ProtoStorage.Load<SimpleKillFeedData>(nameof(SimpleKillFeed)) ?? new SimpleKillFeedData();
        }

        private void SaveData()
        {
            if (_data == null) return;
            ProtoStorage.Save(_data, nameof(SimpleKillFeed));
        }

        #endregion

        #region ChatCommand

        [ChatCommand("feed")]
        private void ToggleFeed(BasePlayer player)
        {
            if (!_data.DisabledUsers.Contains(player.userID))
            {
                _data.DisabledUsers.Add(player.userID);
                Player.Message(player, _("Disabled", player), null, configdata.IconId);
            }
            else
            {
                _data.DisabledUsers.Remove(player.userID);
                Player.Message(player, _("Enabled", player), null, configdata.IconId);
            }
        }

        #endregion

        #region Oxide Hooks

        private void OnServerInitialized()
        {
            _isClansReborn = Clans != null && Clans.Author.Contains("k1lly0u");
            _isClansIo = Clans != null && Clans.Author.Contains("playrust.io / dcode");
            _isClansMevent = Clans != null && Clans.Author.Contains("mevent");
            foreach (var blueprint in ItemManager.bpList.Where(bp => bp.targetItem.category == ItemCategory.Weapon || bp.targetItem.category == ItemCategory.Tool))
            {
                var md = blueprint.targetItem.GetComponent<ItemModEntity>();
                if (!md)
                    continue;
                if (!_itemNameMapping.ContainsKey(md.entityPrefab.resourceID))
                    _itemNameMapping.Add(md.entityPrefab.resourceID, blueprint.targetItem.displayName.english);
            }
            _holder = new GameObject("SKFHolder");
            UnityEngine.Object.DontDestroyOnLoad(_holder);
            _killQueue = _holder.AddComponent<KillQueue>();
            Pool.ResizeBuffer<KillEvent>(configdata.MaxFeedMessages);
        }

        private void Init() => LoadData();

        private void Unload()
        {
            _killQueue = null;
            UnityEngine.Object.Destroy(_holder);
            _holder = null;
            for (var i = 0; i < configdata.MaxFeedMessages; i++)
                KillQueue.RemoveKillCui($"kf-{i}");
            configdata = null;
            Pool.IPoolCollection value;
            Pool.Directory.TryRemove(typeof(KillEvent), out value);
            SaveData();
            _data = null;
        }

        #endregion

        #region Oxide Hooks (Deaths)

        private void OnEntityDeath(BaseAnimalNPC victim, HitInfo hitInfo)
        {
            if (victim == null || victim is BasePlayer || !IsAnimal(victim)) return;
            BasePlayer attacker = hitInfo.InitiatorPlayer;
            if (attacker == null || attacker.IsNpc || IsAnimal(attacker) || IsZombieHorde(attacker)) return;
            if (!attacker.userID.IsSteamId()) return;
            if (!configdata.EnableAnimalFeed) return;

            string VictimName = configdata.Animal[victim.ShortPrefabName];
            string AttackerName = SanitizeName(GetClan(attacker) + attacker.displayName);
            string WeaponName = GetCustomWeaponName(hitInfo);
            var distance = (int)Vector3.Distance(attacker.transform.position, victim.transform.position);
            _killQueue.OnDeath(attacker, null, string.Format(_("MsgFeedKillAnimalFromPlayer"), AttackerName, VictimName, WeaponName, GetDistanceColor(distance), distance));
        }

        private void OnEntityDeath(SimpleShark victim, HitInfo hitInfo)
        {
            if (victim == null || victim is BasePlayer || !IsAnimal(victim)) return;
            BasePlayer attacker = hitInfo.InitiatorPlayer;

            if (attacker == null || attacker.IsNpc || IsAnimal(attacker) || IsZombieHorde(attacker)) return;
            if (!configdata.EnableAnimalFeed) return;

            string VictimName = configdata.Animal[victim.ShortPrefabName];
            string AttackerName = SanitizeName(GetClan(attacker) + attacker.displayName);
            string WeaponName = GetCustomWeaponName(hitInfo);
            var distance = (int)Vector3.Distance(attacker.transform.position, victim.transform.position);
            _killQueue.OnDeath(attacker, null, string.Format(_("MsgFeedKillAnimalFromPlayer"), AttackerName, VictimName, WeaponName, GetDistanceColor(distance), distance));

        }

        private void OnPlayerDeath(BasePlayer victim, HitInfo hitInfo)
        {
            try
            {
                if (victim == null) return;

                var wAttacker = victim.lastAttacker?.ToPlayer();
                if (!victim.userID.IsSteamId() && !configdata.EnableNpcFeed)
                {
                    return;
                }
                if (hitInfo.Initiator is BaseAnimalNPC && victim.IsWounded())
                {
                    if (!configdata.EnableAnimal) return;
                    OnKilledByAnimal(hitInfo.Initiator , victim); return;
                }

                if (IsTrap(hitInfo.Initiator))
                {
                    if (!configdata.EnableEntityFeed) return;
                    OnKilledByEnt(hitInfo.Initiator , victim); return;
                }
                if (victim.lastAttacker is NPCAutoTurret)
                {
                    if (!configdata.EnableEntityFeed) return;
                    OnSentry(victim);
                    return;
                }

                if (victim.lastAttacker.ToString().Contains("cactus"))
                {
                    if (!victim.userID.IsSteamId() && !configdata.EnableNpcFeed) return;
                    OnCactus(victim); return;
                }

                if (!wAttacker.userID.IsSteamId() && !victim.userID.IsSteamId())
                {
                    //Puts($"Npc kill : {wAttacker} Killed {victim}");
                    return;
                }
                if ((wAttacker.userID.IsSteamId() && !victim.userID.IsSteamId()) && !configdata.EnableNpcFeed)
                {
                    return;
                }

             