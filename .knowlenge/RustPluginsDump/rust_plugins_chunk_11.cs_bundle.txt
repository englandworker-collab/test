   if (hitInfo == null && (wAttacker != null && victim.IsWounded()))
                {
                    OnDeathFromWounds(wAttacker , victim);
                    return;
                }

                if (victim.lastAttacker?.ToPlayer() == victim)
                {
                    if (!configdata.EnableSuicides) return;
                    OnSuicide(victim); return;
                    return;
                }

                if (!victim.userID.IsSteamId() && hitInfo.Initiator is HotAirBalloon) return;

                if (hitInfo.WeaponPrefab.prefabID == 3032863244)//Cannon Shell prefab id
                {
                    if (!configdata.EnableEntityFeed) return;
                    OnKilledByBradley(victim); return;
                }

                if (IsRadiation(hitInfo))
                {
                    if (!configdata.EnableRadiationKills) return;
                    OnKilledByRadiation(victim); return;
                }

                if (IsFall(hitInfo) && victim.IsWounded())
                {
                    if (!configdata.EnableFall) return;
                    DeathByFall(victim); return;
                }

                if (IsCold(hitInfo))
                {
                    if (!configdata.EnableCold) return;
                    OnFrozen(victim); return;
                }

                if (IsDrowning(hitInfo))
                {
                    if (!configdata.EnableDrowning) return;
                    OnDrowning(victim); return;
                }

                if (IsHunger(hitInfo) || IsThirst(hitInfo) || IsPoison(hitInfo))
                {
                    if (!configdata.EnableHunger) return;
                    OnHunger(victim); return;
                }

                if (IsShock(hitInfo))
                {
                    if (!configdata.EnableElectricution) return;
                    OnShock(victim); return;
                    return;
                }
                var distance = !hitInfo.IsProjectile() ? (int)Vector3.Distance(hitInfo.PointStart , hitInfo.HitPositionWorld) : (int)hitInfo.ProjectileDistance;
                if (IsCar(hitInfo)) distance = 0;
                var attacker = hitInfo.InitiatorPlayer;

                if (attacker == null) return;

                else if (IsFlame(hitInfo))
                {
                    OnBurned(attacker , victim);
                }
                //if (victim.IsNpc && IsExplosion(hitInfo)) return;//BotRespawn npc's can explode throwing errors
                else if (!IsDrowning(hitInfo))
                {
                    OnKilled(attacker , victim , hitInfo , distance);
                    return;
                }
                return;
            }
            catch
            {
                Puts("invalid target");
                return;
            }
        }

        #endregion

        #region LanguageAPI

        protected override void LoadDefaultMessages() => lang.RegisterMessages(new Dictionary<string, string>
        {
            {"MsgAttacker", "You killed <color=#ff686b>{0}</color> from {1}m in <color=#ff686b>{2}</color>."},
            {"MsgVictim", "<color=#ff686b>{0}</color> killed you from {1}m with their {2} to <color=#ff686b>{3}</color>."},
            {"MsgFeedKill", "<color=#00ff00>{0}</color> killed <color=#ff686b>{1}</color>, <color=#ff686b>{2}</color>, <color=#ff686b>{3}</color><color={4}>({5}m)</color>"},
            {"MsgFeedKillNpc", "<color=#00ff00>{0}</color> killed <color=#ff686b>{1}</color>, <color={2}>({3}m)</color>"},
            {"MsgFeedKillAnimalFromPlayer", "<color=#00ff00>{0}</color> killed a <color=#ff686b>{1}</color>, <color=#ff686b>{2}</color>, <color={3}>({4}m)</color>"},

            {"MsgAtkWounded", "You wounded <color=#ff686b>{0}</color> till death."},
            {"MsgVictimWounded", "<color=#ff686b>{0}</color> has wounded you till death."},
            {"MsgFeedWounded", "<color=#00ff00>{0}</color> finished <color=#ff686b>{1}</color>"},

            {"MsgAtkBurned", "You burned <color=#ff686b>{0}</color> alive!"},
            {"MsgVictimBurned", "<color=#ff686b>{0}</color> has burned you alive!"},
            {"MsgFeedBurned", "<color=#00ff00>{0}</color> burned <color=#ff686b>{1}</color>!"},

            {"MsgFeedKillBrad", "<color=#ff686b>{0}</color> was killed by a <color=orange>Shell</color>"},
            {"MsgFeedKillEnt", "<color=#ff686b>{0}</color> was killed by <color=orange>{1}</color>"},
            {"MsgFeedKillAnimal", "<color=#ff686b>{0}</color> was killed by <color=orange>{1}</color>"},

            {"MsgFeedKillSuicide", "<color=#ff686b>{0}</color> committed <color=orange>Suicide</color>"},
            {"MsgFeedKillRadiation", "<color=#ff686b>{0}</color> died to <color=orange>Radiation</color>"},
            {"MsgFeedKillFall", "<color=#ff686b>{0}</color> died by <color=orange>Fall</color>"},
            {"MsgFeedKillCold", "<color=#ff686b>{0}</color> died by <color=orange>Cold</color>"},
            {"MsgFeedKillDrowned", "<color=#ff686b>{0}</color> <color=orange>Drowned</color>"},
            {"MsgFeedKillHunger", "<color=#ff686b>{0}</color> <color=orange>Starved</color>"},
            {"MsgFeedKillShock", "<color=#ff686b>{0}</color> got <color=orange>Electrocuted</color>"},
            {"MsgFeedKillSentry", "<color=#ff686b>{0}</color> got killed by <color=orange>Outpost</color>"},
            {"MsgFeedKillCactus", "<color=#ff686b>{0}</color> died to a <color=orange>Cactus</color>"},

            {"Enabled", "KillFeed Enabled"},
            {"Disabled", "KillFeed Disabled"}
        }, this);

        #endregion

        #region API for other plugins to use the feed

        private void SendKillfeedmessage(string msg)
        {
            _killQueue.OnDeath(null , null , string.Format(_(msg)));
        }

        #endregion

        #region Kill Events

        private void OnKilled(BasePlayer attacker, BasePlayer victim, HitInfo hitInfo, int dist)
        {
            var HitBone = hitInfo.boneArea.ToString();
            if (HitBone == "-1") HitBone = "Body";
            if (IsCar(hitInfo)) dist = 0;

            if ((IsZombieHorde(attacker) || attacker.IsNpc) && configdata.EnableNpcFeed)
            {
                var npc = attacker;
                _killQueue.OnDeath(victim, null, string.Format(_("MsgFeedKillNpc"), CustomNpcName(npc), SanitizeName(GetClan(victim) + victim.displayName), GetDistanceColor(dist), dist));
                return;
            }

            if ((victim.IsNpc || IsZombieHorde(victim)) && configdata.EnableNpcFeed)
            {
                var npc = victim;
                _killQueue.OnDeath(attacker, null, string.Format(_("MsgFeedKill"), SanitizeName(GetClan(attacker) + attacker.displayName), CustomNpcName(npc), GetCustomWeaponName(hitInfo), HitBone, GetDistanceColor(dist), dist));
                return;
            }

            if (configdata.EnableChatFeed)
            {
                if (!_data.DisabledUsers.Contains(attacker.userID))
                    Player.Message(attacker, _("MsgAttacker", attacker), null, configdata.IconId, GetClan(victim) + victim.displayName, dist, HitBone);
                if (!_data.DisabledUsers.Contains(victim.userID))
                    Player.Message(victim, _("MsgVictim", victim), null, configdata.IconId, GetClan(attacker) + attacker.displayName, dist, GetCustomWeaponName(hitInfo), HitBone);
            }
            _killQueue.OnDeath(victim, attacker, string.Format(_("MsgFeedKill"), SanitizeName(GetClan(attacker) + attacker.displayName), SanitizeName(GetClan(victim) + victim.displayName), GetCustomWeaponName(hitInfo), HitBone, GetDistanceColor(dist), dist));

            if (!configdata.EnableLogging) return;
            var sfkLog = new StringBuilder($"{DateTime.Now}: ({attacker.UserIDString}){attacker.displayName} killed ({victim.UserIDString}){victim.displayName} from {dist}m in {HitBone}");
            LogToFile("SimpleKillFeed", sfkLog.ToString(), this);
        }

        private void OnSuicide(BasePlayer victim) => _killQueue.OnDeath(victim , null , string.Format(_("MsgFeedKillSuicide") , SanitizeName(GetClan(victim) + victim.displayName)));

        private void OnKilledByRadiation(BasePlayer victim) => _killQueue.OnDeath(victim, null, string.Format(_("MsgFeedKillRadiation"), SanitizeName(GetClan(victim) + victim.displayName)));

        private void OnKilledByEnt(BaseEntity attacker , BasePlayer victim) => _killQueue.OnDeath(victim , null , string.Format(_("MsgFeedKillEnt") , SanitizeName(GetClan(victim) + victim.displayName) , CustomEntName(attacker)));

        private void OnKilledByBradley(BasePlayer victim) => _killQueue.OnDeath(victim, null, string.Format(_("MsgFeedKillBrad"), SanitizeName(GetClan(victim) + victim.displayName)));

        private void OnKilledByAnimal(BaseEntity attacker, BasePlayer victim) => _killQueue.OnDeath(victim, null, string.Format(_("MsgFeedKillAnimal"), SanitizeName(GetClan(victim) + victim.displayName), CustomAnimalName(attacker)));

        private void DeathByFall(BasePlayer victim) => _killQueue.OnDeath(victim, null, string.Format(_("MsgFeedKillFall"), SanitizeName(GetClan(victim) + victim.displayName)));

        private void OnDeathFromWounds(BasePlayer attacker, BasePlayer victim)
        {
            if (configdata.EnableChatFeed)
            {
                if (!_data.DisabledUsers.Contains(attacker.userID) && attacker.userID.IsSteamId())
                    Player.Message(attacker, _("MsgAtkWounded", attacker), null, configdata.IconId, GetClan(victim) + victim.displayName);
                if (!_data.DisabledUsers.Contains(victim.userID))
                    Player.Message(victim, _("MsgVictimWounded", victim), null, configdata.IconId, GetClan(attacker) + attacker.displayName);
            }
            _killQueue.OnDeath(victim, attacker, string.Format(_("MsgFeedWounded"), SanitizeName(GetClan(attacker) + attacker.displayName), SanitizeName(GetClan(victim) + victim.displayName)));

            if (!configdata.EnableLogging) return;
            var sfkLog = new StringBuilder($"{DateTime.Now}: ({attacker.UserIDString}){attacker.displayName} finished ({victim.UserIDString}){victim.displayName}");
            LogToFile("SimpleKillFeed", sfkLog.ToString(), this);
        }

        private void OnBurned(BasePlayer attacker, BasePlayer victim)
        {
            if (victim.IsNpc)
            {
                if (!configdata.EnableNpcFeed) return;
                var npc = victim;
                _killQueue.OnDeath(victim, attacker, string.Format(_("MsgFeedBurned"), SanitizeName(GetClan(attacker) + attacker.displayName), CustomNpcName(npc)));
                return;
            }

            if (attacker.IsNpc)
            {
                if (!configdata.EnableNpcFeed) return;
                var npc = attacker;
                _killQueue.OnDeath(victim, attacker, string.Format(_("MsgFeedBurned"), CustomNpcName(npc), SanitizeName(GetClan(victim) + victim.displayName)));
                return;
            }
            if (configdata.EnableChatFeed)
            {
                if (!_data.DisabledUsers.Contains(attacker.userID))
                    Player.Message(attacker, _("MsgAtkBurned", attacker), null, configdata.IconId, GetClan(victim) + victim.displayName);
                if (!_data.DisabledUsers.Contains(victim.userID))
                    Player.Message(victim, _("MsgVictimBurned", victim), null, configdata.IconId, GetClan(attacker) + attacker.displayName);
            }
            _killQueue.OnDeath(victim, attacker, string.Format(_("MsgFeedBurned"), SanitizeName(GetClan(attacker) + attacker.displayName), SanitizeName(GetClan(victim) + victim.displayName)));

            if (!configdata.EnableLogging) return;
            var sfkLog = new StringBuilder($"{DateTime.Now}: ({attacker.UserIDString}){attacker.displayName} burned ({victim.UserIDString}){victim.displayName}");
            LogToFile("SimpleKillFeed", sfkLog.ToString(), this);
        }

        private void OnDrowning(BasePlayer victim) => _killQueue.OnDeath(victim , null , string.Format(_("MsgFeedKillDrowned") , SanitizeName(GetClan(victim) + victim.displayName)));
        private void OnFrozen(BasePlayer victim) => _killQueue.OnDeath(victim , null , string.Format(_("MsgFeedKillCold") , SanitizeName(GetClan(victim) + victim.displayName)));
        private void OnHunger(BasePlayer victim) => _killQueue.OnDeath(victim , null , string.Format(_("MsgFeedKillHunger") , SanitizeName(GetClan(victim) + victim.displayName)));
        private void OnShock(BasePlayer victim) => _killQueue.OnDeath(victim , null , string.Format(_("MsgFeedKillShock") , SanitizeName(GetClan(victim) + victim.displayName)));
        private void OnSentry(BasePlayer victim) => _killQueue.OnDeath(victim , null , string.Format(_("MsgFeedKillSentry") , SanitizeName(GetClan(victim) + victim.displayName)));
        private void OnCactus(BasePlayer victim) => _killQueue.OnDeath(victim , null , string.Format(_("MsgFeedKillCactus") , SanitizeName(GetClan(victim) + victim.displayName)));

        #endregion

        #region UI

        private class KillEvent : Pool.IPooled
        {
            public int DisplayUntil;
            public string Text;

            public KillEvent Init(string text, int displayUntil)
            {
                Text = text;
                DisplayUntil = displayUntil;
                return this;
            }

            public void EnterPool()
            {
                Text = null;
                DisplayUntil = 0;
            }

            public void LeavePool() { }
        }

        private class KillQueue : MonoBehaviour
        {
            private readonly WaitForSeconds _secondDelay = new WaitForSeconds(1f);
            private readonly Queue<KillEvent> _queue = new Queue<KillEvent>(configdata.MaxFeedMessages);
            private readonly CuiOutlineComponent _outlineStatic = new CuiOutlineComponent { Distance = configdata.OutlineSize, Color = "0 0 0 1" };
            private readonly CuiRectTransformComponent[] _rectTransformStatic = new CuiRectTransformComponent[configdata.MaxFeedMessages];
            private readonly CuiTextComponent[] _textStatic = new CuiTextComponent[configdata.MaxFeedMessages];
            private readonly CuiElementContainer _cui = new CuiElementContainer();
            private bool _needsRedraw;
            private int _currentlyDrawn;

            public void OnDeath(BasePlayer victim, BasePlayer attacker, string text)
            {
                if (_queue.Count == configdata.MaxFeedMessages)
                    DequeueEvent(_queue.Dequeue());
                PushEvent(Pool.Get<KillEvent>().Init(text, Epoch.Current + configdata.FeedMessageTtlSec));
            }

            private void PushEvent(KillEvent evt)
            {
                _queue.Enqueue(evt);
                _needsRedraw = true;
                DoProccessQueue();
            }

            private void Start()
            {
                for (var i = 0; i < configdata.MaxFeedMessages; i++)
                {
                    _rectTransformStatic[i] = new CuiRectTransformComponent
                    {
                        AnchorMax =
                            $"{configdata.AnchorMax.Split(Convert.ToChar(' '))[0]} {float.Parse(configdata.AnchorMax.Split(Convert.ToChar(' '))[1]) - (configdata.HeightIdent * i)}",
                        AnchorMin =
                            $"{configdata.AnchorMin.Split(Convert.ToChar(' '))[0]} {float.Parse(configdata.AnchorMin.Split(Convert.ToChar(' '))[1]) - (configdata.HeightIdent * i)}"
                    };
                    _textStatic[i] = new CuiTextComponent { Align = TextAnchor.MiddleRight, FontSize = configdata.FontSize, Text = string.Empty };
                }
                StartCoroutine(ProccessQueue());
            }

            private void DequeueEvent(KillEvent evt)
            {
                Pool.Free(ref evt);
                _needsRedraw = true;
            }

            private void DoProccessQueue()
            {
                while (_queue.Count > 0 && _queue.Peek().DisplayUntil < Epoch.Current)
                    DequeueEvent(_queue.Dequeue());

                if (!_needsRedraw)
                    return;
                var toBeRemoved = _currentlyDrawn;
                _currentlyDrawn = 0;
                foreach (var killEvent in _queue)
                {
                    var cuiText = _textStatic[_currentlyDrawn];
                    cuiText.Text = killEvent.Text;
                    _cui.Add(new CuiElement
                    {
                        Name = $"kf-{_currentlyDrawn}",
                        Parent = "Under",
                        Components =
                        {
                            cuiText,
                            _rectTransformStatic[_currentlyDrawn],
                            _outlineStatic
                        }
                    });
                    if (++_currentlyDrawn == configdata.MaxFeedMessages)
                        break;
                }
                _needsRedraw = false;
                SendKillCui(_cui, toBeRemoved);
                _cui.Clear();
            }

            private IEnumerator ProccessQueue()
            {
                while (!Interface.Oxide.IsShuttingDown)
                {
                    DoProccessQueue();
                    yield return _secondDelay;
                }
            }

            private static void SendKillCui(CuiElementContainer cui, int toBeRemoved)
            {
                var json = cui.ToJson();
                foreach (var plr in BasePlayer.activePlayerList)
                {
                    for (var i = toBeRemoved; i > 0; i--)
                        CuiHelper.DestroyUi(plr, $"kf-{i - 1}");
                    if (!_data.DisabledUsers.Contains(plr.userID))
                        CuiHelper.AddUi(plr, json);
                }
            }

            public static void RemoveKillCui(string name)
            {
                foreach (var plr in BasePlayer.activePlayerList) 
                    CuiHelper.DestroyUi(plr, name);
            }
        }

        #endregion

        #region Helpers

        private string _(string msg, BasePlayer player = null) => lang.GetMessage(msg, this, player?.UserIDString);

        private string GetCustomWeaponName(HitInfo hitInfo)
        {
            var name = GetWeaponName(hitInfo);
            if (string.IsNullOrEmpty(name))
                return null;

            string translatedName;
            if (configdata.Weapons.TryGetValue(name, out translatedName))
                return translatedName;

            configdata.Weapons.Add(name, name);
            Config.WriteObject(configdata);
            return name;
        }

        private string CustomNpcName(BasePlayer npc)
        {
            var name = npc.ShortPrefabName;
            if (string.IsNullOrEmpty(name))
                return null;
            if (npc.displayName != npc.userID.ToString())
                return npc.displayName;
            string translatedName;
            if (configdata.Npcs.TryGetValue(name, out translatedName))
                return translatedName;

            configdata.Npcs.Add(name, name);
            Config.WriteObject(configdata);
            return name;
        }

        private string CustomEntName(BaseEntity attacker)
        {
            var name = attacker.ShortPrefabName;
            if (string.IsNullOrEmpty(name))
                return null;
            string translatedName;
            if (configdata.Ents.TryGetValue(name, out translatedName))
                return translatedName;

            configdata.Npcs.Add(name, name);
            Config.WriteObject(configdata);
            return name;
        }

        private string CustomAnimalName(BaseEntity attacker)
        {
            var name = attacker.ShortPrefabName;
            if (string.IsNullOrEmpty(name))
                return null;
            string translatedName;
            if (configdata.Animal.TryGetValue(name, out translatedName))
                return translatedName;

            configdata.Npcs.Add(name, name);
            Config.WriteObject(configdata);
            return name;
        }

        private string GetWeaponName(HitInfo hitInfo)
        {
            var _WeaponName = "??Unknown??";
            if (hitInfo.Weapon == null)
            {
                if (hitInfo.WeaponPrefab.prefabID == 3898309212) _WeaponName = "C4";//3898309212
                if (hitInfo.WeaponPrefab.prefabID == 3046924118) _WeaponName = "Rocket";//3046924118
                if (hitInfo.WeaponPrefab.prefabID == 1217937936) _WeaponName = "HV Rocket";//1217937936
                if (hitInfo.WeaponPrefab.prefabID == 2742759844) _WeaponName = "Satchel";//1217937936
                if (hitInfo.WeaponPrefab.prefabID == 2144399804) _WeaponName = "Beancan";//2144399804
                if (hitInfo.WeaponPrefab.prefabID == 1859672190) _WeaponName = "Shell";//1217937936
                if (hitInfo.WeaponPrefab.prefabID == 1128089209) _WeaponName = "Grenade";//1128089209
                if (hitInfo.WeaponPrefab.prefabID == 3717106868) _WeaponName = "Flamethrower";//3717106868
                if (hitInfo.WeaponPrefab.prefabID == 3032863244) _WeaponName = "Cannon Shell";//3032863244

                if (hitInfo.Initiator is GunTrap) _WeaponName = "GunTrap";
                if (hitInfo.Initiator is FlameTurret) _WeaponName = "FlameTurret";
                if (hitInfo.Initiator is AutoTurret) _WeaponName = "AutoTurret";
                else if (hitInfo.damageTypes.GetMajorityDamageType() == DamageType.Heat) _WeaponName = "Fire";
                else if (hitInfo.damageTypes.GetMajorityDamageType() == DamageType.Fun_Water) _WeaponName = "WaterGun";
                if (hitInfo.WeaponPrefab.ToString().Contains("car_")) _WeaponName = "Car";
                //Puts(hitInfo.WeaponPrefab.prefabID.ToString());
                return _WeaponName;
            }

            if (hitInfo.Weapon != null)
            {
                var _Weapon = hitInfo.Weapon;
                var item = _Weapon.GetItem();
                if (item != null)
                    _WeaponName = item.info.displayName.english;
                if (hitInfo.WeaponPrefab.prefabID == 1233562048) _WeaponName = "Grenade Launcher";
            }
            if (hitInfo.Initiator is GunTrap) _WeaponName = "GunTrap";
            if (hitInfo.Initiator is FlameTurret) _WeaponName = "FlameTurret";
            if (hitInfo.Initiator is AutoTurret) _WeaponName = "AutoTurret";
            if (hitInfo.Initiator is HotAirBalloon) _WeaponName = "Hot Air Balloon";
            if (hitInfo.WeaponPrefab is MLRSRocket) _WeaponName = "MLRS";
            return _WeaponName;
        }

        private static bool IsExplosion(HitInfo hit) => (hit.WeaponPrefab != null && (hit.WeaponPrefab.ShortPrefabName.Contains("grenade") || hit.WeaponPrefab.ShortPrefabName.Contains("explosive")))
                                                        || hit.damageTypes.GetMajorityDamageType() == DamageType.Explosion || (!hit.damageTypes.IsBleedCausing() && hit.damageTypes.Has(DamageType.Explosion));

        private static bool IsFlame(HitInfo hit) => hit.damageTypes.GetMajorityDamageType() == DamageType.Heat || (!hit.damageTypes.IsBleedCausing() && hit.damageTypes.Has(DamageType.Heat));

        private static bool IsRadiation(HitInfo hit) => hit.damageTypes.GetMajorityDamageType() == DamageType.Radiation || (!hit.damageTypes.IsBleedCausing() && hit.damageTypes.Has(DamageType.Radiation));

        private static bool IsCold(HitInfo hit) => hit.damageTypes.GetMajorityDamageType() == DamageType.Cold || (!hit.damageTypes.IsBleedCausing() && hit.damageTypes.Has(DamageType.Cold));
        private static bool IsHunger(HitInfo hit) => hit.damageTypes.GetMajorityDamageType() == DamageType.Hunger || (!hit.damageTypes.IsBleedCausing() && hit.damageTypes.Has(DamageType.Hunger));
        private static bool IsThirst(HitInfo hit) => hit.damageTypes.GetMajorityDamageType() == DamageType.Thirst || (!hit.damageTypes.IsBleedCausing() && hit.damageTypes.Has(DamageType.Thirst));
        private static bool IsDrowning(HitInfo hit) => hit.damageTypes.GetMajorityDamageType() == DamageType.Drowned /* || (!hit.damageTypes.IsBleedCausing() && hit.damageTypes.Has(DamageType.Drowned))*/;
        private static bool IsPoison(HitInfo hit) => hit.damageTypes.GetMajorityDamageType() == DamageType.Poison || (!hit.damageTypes.IsBleedCausing() && hit.damageTypes.Has(DamageType.Poison));
        private static bool IsShock(HitInfo hit) => hit.damageTypes.GetMajorityDamageType() == DamageType.ElectricShock || (!hit.damageTypes.IsBleedCausing() && hit.damageTypes.Has(DamageType.ElectricShock));
        private static bool IsFall(HitInfo hit) => hit.damageTypes.GetMajorityDamageType() == DamageType.Fall || (!hit.damageTypes.IsBleedCausing() && hit.damageTypes.Has(DamageType.Fall));
        private static bool IsCar(HitInfo hit) => hit.WeaponPrefab.ToString().Contains("car_");

        private static bool IsTrap(BaseEntity ent) => ent != null && configdata.Ents.ContainsKey(ent.ShortPrefabName);

        private static bool IsAnimal(BaseEntity animal) => animal?.ShortPrefabName != null && configdata.Animal.ContainsKey(animal.ShortPrefabName);

        private static bool IsZombieHorde(BasePlayer player) => player.GetType().Name.Equals("ZombieNPC");

        private static string GetDistanceColor(int dist)
        {
            foreach (var distanceColor in configdata.DistanceColors)
            {
                if (distanceColor.TestDistance(dist))
                    return distanceColor.Color;
            }
            return configdata.DefaultDistanceColor ?? "white";
        }

        private string GetClan(BasePlayer player)
        {
            if (_isClansReborn || _isClansIo ||_isClansMevent || Clans == null) return null;
            var clan = (string)Clans.Call("GetClanOf", player.UserIDString);
            if (clan == null) return null;
            var format = string.Format("[" + clan + "] ");
            return format;
        }

        private static string SanitizeName(string name)
        {
            if (name.Length > configdata.MaxPlayerNameLength)
                name = name.Substring(0, configdata.MaxPlayerNameLength).Trim();
            return name.Replace("\"", "''");
        }
        #endregion
    }
}


// --- End of file: SimpleKillFeed.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RustTanic.cs ---
// --- Original Local Path: RustTanic.cs ---

// Plugin formatted by redBDGR's Plugin Formatting Tool
 using Oxide.Core; using Rust; using System; using System.Collections; using System.Collections.Generic; using UnityEngine; using System.Reflection; using Oxide.Core.Configuration; namespace Oxide.Plugins { [Info("RustTanic", "redBDGR", "1.0.3")] [Description("Server event for the Cargo Ship")] class RustTanic : RustPlugin { private bool Changed = false; private static RustTanic plugin; private TitanicManager manager; private int worldLayer = LayerMask.GetMask("World"); private int defaultLayer = LayerMask.GetMask("Default"); private FieldInfo tooHotUntil = typeof(HelicopterDebris).GetField("tooHotUntil", (BindingFlags.Instance | BindingFlags.NonPublic)); private const string permissionNameADMIN = "rusttanic.admin"; private List<ItemInfo> floatingCrateTable = new List<ItemInfo>(); private List<ItemInfo> icebergCrateTable = new List<ItemInfo>(); private class ConfigFile { public static float sequencingGaps = 60f; public static float spawnDistance = 3f; public static float boatSpeed = 1f; public static bool disableIcebergsWithCupboard = true; public static bool disableIcebergsWithBuilding = true; public static bool debugMode = false; public static int floatingCratesToSpawn = 7; public static float floatingCratesRadius = 30f; public static float floatingCrateDespawnTime = 900f; public static int floatingCrateMinItems = 3; public static int floatingCrateMaxItems = 6; public static int debisToSpawn = 4; public static int lootPerDebris = 1; public static float hackableCrateSeconds = 60f; public static bool spawnIcebergCrates = true; public static int icebergCratesToSpawn = 3; public static float icebergCratesSpawnRadius = 6f; public static string icebergCratePrefab = "assets/bundled/prefabs/radtown/crate_elite.prefab"; public static int icebergCrateMinItems = 3; public static int icebergCrateMaxItems = 5; public static bool killBoatScientists = true; public static int icebergNPCToSpawn = 5; public static float icebergNPCSpawnRadius = 10f; public static string icebergNPCType = "assets/prefabs/npc/scientist/scientist.prefab"; public static string icebergNPCNames = "Pirate"; public static bool boatExhaustFlames = true; public static bool boatRotatingLights = true; public static bool disableExtraEffects = false; public static float boatHornInterval = 20f; public static bool randomEventEnabled = true; public static float minRandomEventTime = 7200f; public static float maxRandomEventTime = 10800; public static int minPlayersForEvent = 1; public static bool targetIcebergMarkerEnabled = true; public static float targetIcebergMarkerRadius = 20f; public static string targetIcerbergText = "Cargo ship crash site"; } private void LoadVariables() { ConfigFile.sequencingGaps = Convert.ToSingle(GetConfig("Settings", "Time between sinking stages", 60f)); ConfigFile.spawnDistance = Convert.ToSingle(GetConfig("Settings", "Spawn distance", 2f)); ConfigFile.boatSpeed = Convert.ToSingle(GetConfig("Settings", "Boat speed", 1f)); ConfigFile.debugMode = Convert.ToBoolean(GetConfig("Settings", "DebugMode", false)); ConfigFile.disableIcebergsWithCupboard = Convert.ToBoolean(GetConfig("Settings", "Disable icebergs with cupboard", true)); ConfigFile.disableIcebergsWithBuilding = Convert.ToBoolean(GetConfig("Settings", "Disable icebergs with buildings", true)); ConfigFile.hackableCrateSeconds = Convert.ToSingle(GetConfig("General Loot", "Onboard hackable crate timer", 60f)); ConfigFile.spawnIcebergCrates = Convert.ToBoolean(GetConfig("Iceberg Loot", "Spawn iceberg crates", true)); ConfigFile.icebergCratesToSpawn = Convert.ToInt16(GetConfig("Iceberg Loot", "Crates to spawn", 3)); ConfigFile.icebergCratesSpawnRadius = Convert.ToSingle(GetConfig("Iceberg Loot", "Crate spawn radius", 6f)); ConfigFile.icebergCratePrefab = Convert.ToString(GetConfig("Iceberg Loot", "Crate prefab", "assets/bundled/prefabs/radtown/crate_elite.prefab")); ConfigFile.icebergCrateMinItems = Convert.ToInt32(GetConfig("Iceberg Loot", "Min items per crate", 3)); ConfigFile.icebergCrateMaxItems = Convert.ToInt32(GetConfig("Iceberg Loot", "Max items per crate", 5)); ConfigFile.floatingCratesToSpawn = Convert.ToInt32(GetConfig("Floating Crates", "Amount of floating crates", 7)); ConfigFile.floatingCratesRadius = Convert.ToSingle(GetConfig("Floating Crates", "Floating crate radius", 30f)); ConfigFile.floatingCrateDespawnTime = Convert.ToSingle(GetConfig("Floating Crates", "Floating crate despawn time", 900f)); ConfigFile.floatingCrateMinItems = Convert.ToInt32(GetConfig("Floating Crates", "Min items per crate", 4)); ConfigFile.floatingCrateMaxItems = Convert.ToInt32(GetConfig("Floating Crates", "Max items per crate", 6)); ConfigFile.debisToSpawn = Convert.ToInt32(GetConfig("Debris", "Debris to spawn", 4)); ConfigFile.lootPerDebris = Convert.ToInt32(GetConfig("Debris", "Loot per debris", 1)); ConfigFile.icebergNPCToSpawn = Convert.ToInt32(GetConfig("NPCs", "Amount of iceberg NPC", 5)); ConfigFile.killBoatScientists = Convert.ToBoolean(GetConfig("NPCs", "Kill boat scientists", true)); ConfigFile.icebergNPCSpawnRadius = Convert.ToSingle(GetConfig("NPCs", "Iceberg NPCs spawn radius", 10f)); ConfigFile.icebergNPCType = Convert.ToString(GetConfig("NPCs", "Iceberg NPC type", "assets/prefabs/npc/scientist/scientist.prefab")); ConfigFile.icebergNPCNames = Convert.ToString(GetConfig("NPCs", "Iceberg NPC name", "Pirate")); ConfigFile.boatExhaustFlames = Convert.ToBoolean(GetConfig("Visuals", "Exhaust flames", true)); ConfigFile.boatRotatingLights = Convert.ToBoolean(GetConfig("Visuals", "Rotating lights", true)); ConfigFile.disableExtraEffects = Convert.ToBoolean(GetConfig("Visuals", "Disable extra effects", false)); ConfigFile.boatHornInterval = Convert.ToSingle(GetConfig("Visuals", "Horn interval", 20f)); ConfigFile.minRandomEventTime = Convert.ToSingle(GetConfig("Timer Settings", "Minimum random event time", 7200f)); ConfigFile.maxRandomEventTime = Convert.ToSingle(GetConfig("Timer Settings", "Maximum random event time", 10800f)); ConfigFile.randomEventEnabled = Convert.ToBoolean(GetConfig("Timer Settings", "Random event enabled", true)); ConfigFile.minPlayersForEvent = Convert.ToInt32(GetConfig("Timer Settings", "Minimum players for event", 1)); ConfigFile.targetIcebergMarkerEnabled = Convert.ToBoolean(GetConfig("Marker Settings", "Target iceberg marker enabled", true)); ConfigFile.targetIcebergMarkerRadius = Convert.ToSingle(GetConfig("Marker Settings", "Target iceberg marker radius", 20f)); ConfigFile.targetIcerbergText = Convert.ToString(GetConfig("Marker Settings", "Target iceberg text", "Cargo ship crash site")); if (!Changed) return; SaveConfig(); Changed = false; } protected override void LoadDefaultConfig() { Config.Clear(); LoadVariables(); } private DynamicConfigFile floatingCrateFile; private DynamicConfigFile icebergCrateFile; StoredData storedData; private class StoredData { public List<ItemInfo> lootTable = new List<ItemInfo>(); } private class ItemInfo { public string itemName; public int minItemAmount; public int maxItemAmount; public float chance; public ulong skinID; } void SaveData() { storedData.lootTable = floatingCrateTable; floatingCrateFile.WriteObject(storedData); storedData.lootTable = icebergCrateTable; icebergCrateFile.WriteObject(storedData); } void LoadData() { try { bool dataChanged = false; floatingCrateFile = Interface.Oxide.DataFileSystem.GetFile("RustTanic/FloatingCrates"); storedData = floatingCrateFile.ReadObject<StoredData>(); floatingCrateTable = storedData.lootTable; if (floatingCrateTable.Count == 0) { floatingCrateTable = new List<ItemInfo> { new ItemInfo { itemName = "rope", minItemAmount = 2 , maxItemAmount = 4, chance = 1f }, new ItemInfo { itemName = "metalblade", minItemAmount = 1, maxItemAmount = 3, chance = 1f }, new ItemInfo { itemName = "metalspring", minItemAmount = 1, maxItemAmount = 2, chance = 0.8f }, new ItemInfo { itemName = "scrap", minItemAmount = 10, maxItemAmount = 15, chance = 1f }, new ItemInfo { itemName = "sheetmetal", minItemAmount = 1, maxItemAmount = 2, chance = 1f }, new ItemInfo { itemName = "sewingkit", minItemAmount = 2, maxItemAmount = 4, chance = 1f }, new ItemInfo { itemName = "propanetank", minItemAmount = 1, maxItemAmount = 1, chance = 1f }, new ItemInfo { itemName = "pistol.revolver", minItemAmount = 1, maxItemAmount = 1, chance = 0.5f }, new ItemInfo { itemName = "gears", minItemAmount = 1, maxItemAmount = 3, chance = 0.8f }, new ItemInfo { itemName = "roadsigns", minItemAmount = 2, maxItemAmount = 5, chance = 1f }, }; dataChanged = true; } icebergCrateFile = Interface.Oxide.DataFileSystem.GetFile("RustTanic/IcebergCrates"); storedData = icebergCrateFile.ReadObject<StoredData>(); icebergCrateTable = storedData.lootTable; if (icebergCrateTable.Count == 0) { icebergCrateTable = new List<ItemInfo> { new ItemInfo { itemName = "targeting.computer", minItemAmount = 1, maxItemAmount = 1, chance = 0.7f }, new ItemInfo { itemName = "techparts", minItemAmount = 1, maxItemAmount = 2, chance = 0.8f }, new ItemInfo { itemName = "scrap", minItemAmount = 20, maxItemAmount = 25, chance = 1f }, new ItemInfo { itemName = "metal.refined", minItemAmount = 10, maxItemAmount = 20, chance = 1f }, new ItemInfo { itemName = "metalpipe", minItemAmount = 1, maxItemAmount = 3, chance = 1f }, new ItemInfo { itemName = "heavy.plate.helmet", minItemAmount = 1, maxItemAmount = 1, chance = 0.5f }, new ItemInfo { itemName = "heavy.plate.jacket", minItemAmount = 1, maxItemAmount = 1, chance = 0.5f }, new ItemInfo { itemName = "heavy.plate.pants", minItemAmount = 1, maxItemAmount = 1, chance = 0.5f }, new ItemInfo { itemName = "largemedkit", minItemAmount = 1, maxItemAmount = 3, chance = 1f }, new ItemInfo { itemName = "shotgun.waterpipe", minItemAmount = 1, maxItemAmount = 1, chance = 0.8f }, new ItemInfo { itemName = "axe.salvaged", minItemAmount = 1, maxItemAmount = 1, chance = 0.8f }, new ItemInfo { itemName = "icepick.salvaged", minItemAmount = 1, maxItemAmount = 1, chance = 0.8f }, new ItemInfo { itemName = "smgbody", minItemAmount = 1, maxItemAmount = 2, chance = 1f }, new ItemInfo { itemName = "semibody", minItemAmount = 1, maxItemAmount = 2, chance = 1f }, new ItemInfo { itemName = "riflebody", minItemAmount = 1, maxItemAmount = 2, chance = 0.7f }, new ItemInfo { itemName = "pistol.semiauto", minItemAmount = 1, maxItemAmount = 1, chance = 0.7f }, new ItemInfo { itemName = "ammo.rifle", minItemAmount = 10, maxItemAmount = 25, chance = 1f }, new ItemInfo { itemName = "weapon.mod.holosight", minItemAmount = 1, maxItemAmount = 1, chance = 0.7f }, new ItemInfo { itemName = "rifle.bolt", minItemAmount = 1, maxItemAmount = 1, chance = 0.5f }, new ItemInfo { itemName = "rifle.semiauto", minItemAmount = 1, maxItemAmount = 1, chance = 0.7f }, new ItemInfo { itemName = "wall.external.high.stone", minItemAmount = 1, maxItemAmount = 3, chance = 0.9f }, }; dataChanged = true; } if (dataChanged) { Puts("Blank spawntables were found... Generating new ones"); SaveData(); } } catch { Puts("Failed to load data, creating new file"); storedData = new StoredData(); } } private void OnServerInitialized() { plugin = this; LoadVariables(); LoadData(); permission.RegisterPermission(permissionNameADMIN, this); manager = new GameObject().AddComponent<TitanicManager>(); lang.RegisterMessages(new Dictionary<string, string> { ["No Permission"] = "You are not allowed to use this command", ["ETA Message"] = "A hijacked cargo ship has been spotted off the coast and is on a collision course with an iceberg. ETA ~ {0}s", ["Collide Message 1"] = "The hijacked cargo ship has collided with an icerberg and is sinking! Get to the crash site marked on the map to secure the loot", ["Collider Message 2"] = "The hijacked cargo ship has collided with an icerberg and is sinking! Get to the crash site to secure the loot", }, this); } private void Unload() { UnityEngine.Object.Destroy(manager.gameObject); } private class TitanicManager : FacepunchBehaviour { private List<GameObject> allIcebergs = new List<GameObject>(); public List<GameObject> targetIcebergs = new List<GameObject>(); public List<Titanic> currentTitanics = new List<Titanic>(); private Dictionary<CargoShip, GameObject> setIcebergs = new Dictionary<CargoShip, GameObject>(); private void Awake() { plugin.Puts("Finding all icebergs..."); PopulateAllIcebergs(); if (allIcebergs.Count == 0) { plugin.PrintError("No icebergs were found on the map... This plugin is useless and will be disabled until a map with icebergs is found"); Interface.Oxide.UnloadPlugin(plugin.Name); } if (ConfigFile.randomEventEnabled) Invoke(TimedEvent, UnityEngine.Random.Range(ConfigFile.minRandomEventTime, ConfigFile.maxRandomEventTime)); plugin.Puts("Marking all viable icebergs..."); StartCoroutine(UpdateViableIcebergs()); InvokeRepeating(() => { UpdateViableIcebergs(); }, 300f, 300f); } private void OnDestroy() { foreach (Titanic ship in FindObjectsOfType<Titanic>()) { ship.GetComponent<BaseEntity>()?.Kill(); } } private void PopulateAllIcebergs() { foreach (GameObject obj in FindObjectsOfType<GameObject>()) { if (obj.name.Contains("iceberg") && !obj.name.Contains(".")) { allIcebergs.Add(obj); } } } private IEnumerator UpdateViableIcebergs() { targetIcebergs.Clear(); foreach (GameObject berg in allIcebergs) { yield return new WaitForSeconds(0.01f); bool viable = true; RaycastHit[] hits = UnityEngine.Physics.BoxCastAll(berg.transform.position, berg.GetComponent<Collider>().bounds.extents, Vector3.up); foreach (RaycastHit hit in hits) { yield return new WaitForSeconds(0.01f); if (ConfigFile.disableIcebergsWithCupboard) { if (hit.collider?.GetComponent<BuildingPrivlidge>()) { viable = false; break; } } if (ConfigFile.disableIcebergsWithBuilding) { if (hit.collider?.GetComponent<BuildingBlock>()) { viable = false; break; } } } if (viable == true) targetIcebergs.Add(berg); if (ConfigFile.debugMode) { foreach (BasePlayer player in BasePlayer.activePlayerList) { yield return new WaitForSeconds(0.01f); if (player.IsAdmin) { if (viable == true) player.SendConsoleCommand("ddraw.text", 60f, Color.green, berg.transform.position + new Vector3(0, 50, 0), $"{berg.name} (Viable)"); else player.SendConsoleCommand("ddraw.text", 60f, Color.red, berg.transform.position + new Vector3(0, 50, 0), $"{berg.name} (Not Viable)"); } } } } plugin.Puts($"{targetIcebergs.Count} viable icebergs were found"); } public void TimedEvent() { if (BasePlayer.activePlayerList.Count < ConfigFile.minPlayersForEvent) return; SpawnTitanic(); Invoke(TimedEvent, UnityEngine.Random.Range(ConfigFile.minRandomEventTime, ConfigFile.maxRandomEventTime)); } public void SpawnNearestIceberg(Vector3 pos) { GameObject nearest = null; float currentDistance = float.PositiveInfinity; foreach(GameObject obj in targetIcebergs) { float dist = Vector3.Distance(obj.transform.position, pos); if (dist < currentDistance) { nearest = obj; currentDistance = dist; } } SpawnTitanic(nearest); } public void SpawnTitanic(GameObject targetIceberg = null) { CargoShip ship = GameManager.server.CreateEntity("assets/content/vehicles/boats/cargoship/cargoshiptest.prefab", new Vector3(ConVar.Server.worldsize, 0f, ConVar.Server.worldsize), default(Quaternion), true).GetComponent<CargoShip>(); if (targetIceberg != null) setIcebergs.Add(ship, targetIceberg); ship.Spawn(); ship.gameObject.AddComponent<Titanic>(); } public GameObject GetTargetIceberg(CargoShip ship) { if (ship != null) { GameObject targetBerg = null; if (setIcebergs.TryGetValue(ship, out targetBerg)) { setIcebergs.Remove(ship); return targetBerg; } } int random = UnityEngine.Random.Range(0, targetIcebergs.Count); if (random >= targetIcebergs.Count) random = targetIcebergs.Count - 1; if (random < 0) random = 0; return targetIcebergs[random]; } } private class Titanic : FacepunchBehaviour { private CargoShip ship; public GameObject targetIceberg; private MapMarkerGenericRadius radiusMarker; private VendingMachineMapMarker textMarker; private Transform nosePosition; private Transform exhaust1; private Transform exhaust2; private Vector3 collisionPoint; private Vector3 startSinkingPosition; private Vector3 halfSinkingPosition; private Vector3 finishedSinkingPosition; private List<Vector3> deckExplosionPositions = new List<Vector3> { { new Vector3(-1.9f, 9.5f, 75f) }, { new Vector3(3.6f, 9.5f, 67.4f) }, { new Vector3(-5.8f, 9.5f, 68.7f) }, { new Vector3(-1.2f, 10.8f, 59.7f) }, { new Vector3(7.4f, 9.5f, 58.3f) }, { new Vector3(-1.2f, 9.5f, 56.7f) }, { new Vector3(-7.4f, 9.5f, 58.5f) }, { new Vector3(-1.7f, 9.5f, 46.4f) }, { new Vector3(-9.3f, 6.5f, 49.7f) }, { new Vector3(7.0f, 6.5f, 50.4f) }, { new Vector3(2.1f, 9.5f, 32.7f) }, { new Vector3(-9.9f, 6.5f, 24.8f) }, { new Vector3(-1.7f, 9.5f, 24.4f) }, { new Vector3(5.8f, 6.5f, 22.8f) }, { new Vector3(-0.9f, 9.5f, 16.5f) }, { new Vector3(-0.4f, 9.5f, 4.8f) }, { new Vector3(6.1f, 6.5f, -1.7f) }, { new Vector3(-8.6f, 6.5f, -3.0f) }, { new Vector3(-2.6f, 9.5f, -9.6f) }, { new Vector3(-2.9f, 9.5f, -20.9f) }, { new Vector3(-1.6f, 9.5f, -27.2f) }, { new Vector3(-8.6f, 6.5f, -28.4f) }, { new Vector3(5.6f, 6.5f, -28.3f) }, { new Vector3(4.4f, 9.5f, -34.9f) }, { new Vector3(-6.9f, 9.5f, -34.7f) }, { new Vector3(5.5f, 9.5f, -55.3f) }, { new Vector3(-10.3f, 9.8f, -54.5f) }, { new Vector3(-9.0f, 12.1f, -49.6f) }, { new Vector3(6.2f, 12.5f, -49.6f) }, { new Vector3(8.7f, 24.5f, -45.5f) }, { new Vector3(-12.0f, 25.6f, -45.2f) }, { new Vector3(-7.5f, 27.5f, -42.8f) }, { new Vector3(3.8f, 27.5f, -44.2f) }, { new Vector3(-1.2f, 31.2f, -45.4f) }, { new Vector3(-1.5f, 36.5f, -45.6f) }, }; private List<Vector3> searchLightPositions = new List<Vector3> { { new Vector3(0f, 17.5f, 69.6f) }, { new Vector3(-9.8f, 27.5f, -40.5f) }, { new Vector3(9.8f, 27.5f, -40.5f) }, { new Vector3(-10.7f, 12.5f, -38.8f) }, { new Vector3(10.7f, 12.5f, -38.8f) }, }; private List<BaseEntity> searchLights = new List<BaseEntity>(); private List<BaseEntity> npcs = new List<BaseEntity>(); private List<Transform> shipTransforms = new List<Transform>(); private Coroutine exhaustFireRoutine; private float tippingSpeed = 0f; public bool hasCollided; public bool isTipping = false; public bool isSinking = false; public bool isReverseTipping = false; public bool isFinalSinking = false; public bool isPaused = false; private float finalSinkStartTime; private float pauseEndTime; private float startTime; private float startDistance; private void Awake() { ship = GetComponent<CargoShip>(); targetIceberg = plugin.manager.GetTargetIceberg(ship); InitializeSpawnPosition(); ship.enabled = false; InitializeTransform(ref nosePosition, new Vector3(0f, 0.5f, 74.1f)); InitializeTransform(ref exhaust1, new Vector3(-2.5f, 32.4f, -53.8f)); InitializeTransform(ref exhaust2, new Vector3(-2.2f, 33f, -52.4f)); transform.LookAt(new Vector3(collisionPoint.x, transform.position.y, collisionPoint.z)); Invoke(SetCollisionPoint, 0.5f); CancelInvoke(new Action(ship.RespawnLoot)); StartCoroutine(SetHackableCrateTimers()); if (ship.crateSpawns == null || ship.crateSpawns.Count == 0) plugin.PrintError("A CargoShips crateSpawns was null. If you are seeing this error, please report it to redBDGR via the plugin support thread"); SetInitExtraEffects(); startDistance = Vector3.Distance(targetIceberg.transform.position, transform.position); startTime = UnityEngine.Time.time; if (targetIceberg == null) { plugin.PrintError("Event CargoShip couldn't find a target iceberg. It has been despawned"); ship.Kill(); return; } Broadcast(string.Format(plugin.msg("ETA Message"), Mathf.Round(Vector3.Distance(targetIceberg.transform.position, transform.position) / 6.7f))); if (ConfigFile.targetIcebergMarkerEnabled) { radiusMarker = GameManager.server.CreateEntity("assets/prefabs/tools/map/genericradiusmarker.prefab", targetIceberg.transform.position, default(Quaternion), true).GetComponent<MapMarkerGenericRadius>(); radiusMarker.radius = ConfigFile.targetIcebergMarkerRadius; radiusMarker.color1 = Color.red; radiusMarker.alpha = 0.4f; radiusMarker.Spawn(); radiusMarker.SendUpdate(); textMarker = GameManager.server.CreateEntity("assets/prefabs/deployable/vendingmachine/vending_mapmarker.prefab", targetIceberg.transform.position, default(Quaternion), true).GetComponent<VendingMachineMapMarker>(); textMarker.markerShopName = ConfigFile.targetIcerbergText; textMarker.Spawn(); } } private void OnDestroy() { Destroy(nosePosition.gameObject); foreach (BaseEntity light in searchLights) light.Kill(); if (radiusMarker) radiusMarker.Kill(); if (textMarker) textMarker.Kill(); foreach (BaseEntity ent in npcs) ent.Kill(); } private void FixedUpdate() { if (hasCollided == false) { transform.position = Vector3.MoveTowards(transform.position, new Vector3(collisionPoint.x, transform.position.y, collisionPoint.z), 0.2f * ConfigFile.boatSpeed); if (Vector3.Distance(nosePosition.position, new Vector3(collisionPoint.x, nosePosition.position.y, collisionPoint.z)) < 1f) OnCollideWithIceberg(); return; } if (isPaused) { if (UnityEngine.Time.time >= pauseEndTime) isPaused = false; else return; } if (isTipping == true) { if (exhaust1.position.y < ship.waterLine.position.y) { StopCoroutine(exhaustFireRoutine); } if (transform.rotation.eulerAngles.z < 20f) { transform.Rotate(Quaternion.Euler(0f, 0f, tippingSpeed).eulerAngles); if (tippingSpeed < 0.1f) tippingSpeed += 0.0001f; } if (transform.rotation.eulerAngles.x < 5f) { transform.Rotate(Quaternion.Euler(0f, tippingSpeed, 0f).eulerAngles); } if (transform.rotation.eulerAngles.z >= 20f && transform.rotation.eulerAngles.y >= 5f) OnFinishTipping(); } if (isSinking) { transform.position = Vector3.MoveTowards(transform.position, halfSinkingPosition, UnityEngine.Time.deltaTime * 0.1f); if (Vector3.Distance(transform.position, halfSinkingPosition) < 0.1f) OnFinishSinking(); } if (isReverseTipping) { if (transform.rotation.eulerAngles.z > 0f) { transform.Rotate(Quaternion.Euler(0f, 0f, -tippingSpeed).eulerAngles); if (tippingSpeed < 0.1f) tippingSpeed += 0.0001f; } if (transform.rotation.eulerAngles.z <= 1f) OnFinishReverseTipping(); } if (isFinalSinking) { if (UnityEngine.Time.time < finalSinkStartTime) { } transform.position = Vector3.MoveTowards(transform.position, finishedSinkingPosition, UnityEngine.Time.deltaTime * 0.5f); if (Vector3.Distance(transform.position, finishedSinkingPosition) < 0.5f) StartCoroutine(FinalExplosion()); } } private void SetInitExtraEffects() { InvokeRepeating(() => ship.ClientRPC(null, "DoHornSound"), ConfigFile.boatHornInterval, ConfigFile.boatHornInterval); if (ConfigFile.boatExhaustFlames) exhaustFireRoutine = StartCoroutine(FireFromExhaust()); if (ConfigFile.boatRotatingLights) InitSearchLights(); } private void InitSearchLights() { foreach(Vector3 pos in searchLightPositions) { BaseEntity ent = GameManager.server.CreateEntity("assets/prefabs/deployable/search light/searchlight.deployed.prefab", ship.transform.TransformPoint(pos), new Quaternion(), true); ent.Spawn(); ent.SetParent(ship); ent.transform.localPosition = pos; ent.gameObject.AddComponent<TitanicSpinningLight>(); searchLights.Add(ent); } } private IEnumerator FireFromExhaust() { while(true) { yield return new WaitForSeconds(UnityEngine.Random.Range(0.3f, 0.6f)); BaseEntity ent = GameManager.server.CreateEntity("assets/bundled/prefabs/napalm.prefab", exhaust1.position, new Quaternion(), true); ent.Spawn(); ent.GetComponent<Rigidbody>().AddForce(UnityEngine.Random.Range(-4, 4), UnityEngine.Random.Range(3, 6), UnityEngine.Random.Range(-4, 4), ForceMode.Impulse); ent.Invoke(() => { if (ent) ent.Kill(); }, 5f); } } private IEnumerator ExplodeDeck() { foreach(Vector3 pos in deckExplosionPositions) { if (pos == null) continue; yield return new WaitForSeconds(0.01f); Vector3 _pos = transform.TransformPoint(pos); Effect.server.Run("assets/prefabs/tools/c4/effects/c4_explosion.prefab", _pos); if (ConfigFile.disableExtraEffects == false) { for (int i = 0; i <= 3; i++) { yield return new WaitForSeconds(0.01f); string type = UnityEngine.Random.Range(0f, 1f) > 0.5f ? "assets/bundled/prefabs/napalm.prefab" : "assets/bundled/prefabs/oilfireballsmall.prefab"; BaseEntity ent = GameManager.server.CreateEntity(type, _pos, new Quaternion(), true); ent.Spawn(); ent.GetComponent<Rigidbody>().AddForce(UnityEngine.Random.Range(-4, 4), UnityEngine.Random.Range(3, 6), UnityEngine.Random.Range(-4, 4), ForceMode.Impulse); ent.Invoke(() => { if (ent) ent.Kill(); }, 7f); } BaseEntity ent2 = GameManager.server.CreateEntity("assets/bundled/prefabs/oilfireballsmall.prefab", _pos, new Quaternion(), true); ent2.Spawn(); } } } private void SetCollisionPoint() { RaycastHit[] hits = UnityEngine.Physics.RaycastAll(nosePosition.position, transform.forward, Vector3.Distance(transform.position, targetIceberg.transform.position), plugin.worldLayer); foreach(RaycastHit hit in hits) { Collider col = hit.GetCollider(); if (!col) continue; if (col.gameObject == targetIceberg) collisionPoint = new Vector3(hit.point.x, nosePosition.position.y, hit.point.z); } if (collisionPoint == null || Vector3.Distance(collisionPoint, targetIceberg.transform.position) > 30f) if (collisionPoint == null || collisionPoint == Vector3.zero) collisionPoint = targetIceberg.GetComponent<Collider>().ClosestPointOnBounds(nosePosition.position); } private void OnCollideWithIceberg() { hasCollided = true; isTipping = true; isSinking = true; startSinkingPosition = transform.position; halfSinkingPosition = startSinkingPosition - new Vector3(0f, 20f, 0f); PauseToLoot(ConfigFile.sequencingGaps); if (ConfigFile.targetIcebergMarkerEnabled) Broadcast(plugin.msg("Collide Message 1")); else Broadcast(plugin.msg("Collide Message 2")); ship.CancelInvoke("DelayedDestroy"); ship.scientistSpawnPoints = new Transform[0]; StartCoroutine(ExplodeDeck()); HandleLoot(); StartCoroutine(HandleNPCs()); ship.StartEgress(); ship.CancelInvoke("UpdateRadiation"); ship.radiation.SetActive(false); } private void OnFinishTipping() { isTipping = false; if (isTipping == false && isSinking == false) { StartTipCorrection(); } } private void OnFinishSinking() { isSinking = false; if (isTipping == false && isSinking == false) { StartTipCorrection(); } } private void StartTipCorrection() { tippingSpeed = 0f; isReverseTipping = true; finalSinkStartTime = UnityEngine.Time.time + 120f; StopCoroutine(exhaustFireRoutine); } private void OnFinishReverseTipping() { PauseToLoot(ConfigFile.sequencingGaps); isReverseTipping = false; isFinalSinking = true; CancelInvoke(() => ship.ClientRPC(null, "DoHornSound")); ship.CancelInvoke(ship.PlayHorn); RaycastHit hit; if (UnityEngine.Physics.Raycast(transform.position, Vector3.down, out hit, float.PositiveInfinity, 1274232599)) finishedSinkingPosition = hit.point; else finishedSinkingPosition = transform.position - new Vector3(0, 30f, 0); } private IEnumerator FinalExplosion() { isFinalSinking = false; yield return new WaitForSeconds(ConfigFile.sequencingGaps); yield return StartCoroutine(ExplodeDeck()); for (int i = 0; i < ConfigFile.debisToSpawn; i++) { yield return new WaitForSeconds(0.01f); Vector3 spawnPos = transform.position + (UnityEngine.Random.insideUnitSphere * 10f); spawnPos.y = TerrainMeta.HeightMap.GetHeight(spawnPos) + 2f; BaseCombatEntity ent = GameManager.server.CreateEntity("assets/prefabs/npc/m2bradley/bradleyapc.prefab", spawnPos, UnityEngine.Random.rotation, true).GetComponent<BaseCombatEntity>(); ent.Spawn(); ent.GetComponent<BradleyAPC>().maxCratesToSpawn = ConfigFile.lootPerDebris; ent.Hurt(9999999f, DamageType.Explosion); } foreach (RaycastHit entry in UnityEngine.Physics.SphereCastAll(transform.position, 10f, Vector3.up, 10f, plugin.defaultLayer)) { yield return new WaitForSeconds(0.01f); BaseEntity ent = entry.GetEntity(); if (!ent) continue; HelicopterDebris debris = ent.GetComponent<HelicopterDebris>(); if (debris == null) continue; plugin.tooHotUntil.SetValue(debris, 0f); } if (ship) ship.Kill(); } private IEnumerator HandleNPCs() { if (ConfigFile.killBoatScientists) foreach (HTNPlayer entry in ship.GetComponentsInChildren<HTNPlayer>()) { yield return new WaitForSeconds(0.01f); entry.SetParent(null); entry.Hurt(entry.health); } for (int i = 0; i < ConfigFile.icebergNPCToSpawn; i++) { yield return new WaitForSeconds(0.01f); RaycastHit hit; if (UnityEngine.Physics.Raycast(targetIceberg.transform.position + (UnityEngine.Random.insideUnitSphere * ConfigFile.icebergNPCSpawnRadius) + new Vector3(0, 50f, 0), Vector3.down, out hit, float.PositiveInfinity, 1274232599)) { Vector3 spawnPos = hit.point; BaseEntity ent = GameManager.server.CreateEntity(ConfigFile.icebergNPCType, spawnPos, default(Quaternion), true); ent.Spawn(); npcs.Add(ent); ent.SetParent(null); BasePlayer _npcPlayer = ent.GetComponent<BasePlayer>(); if (_npcPlayer) _npcPlayer.displayName = ConfigFile.icebergNPCNames; } } } private void HandleLoot() { ship.RespawnLoot(); StartCoroutine(SetHackableCrateTimers()); StartCoroutine(SpawnIcebergCrates()); StartCoroutine(SpawnFloatingCrates()); ship.CancelInvoke(new Action(ship.PlayHorn)); } private IEnumerator SpawnIcebergCrates() { for (int i = 0; i < ConfigFile.icebergCratesToSpawn; i++) { yield return new WaitForSeconds(0.01f); RaycastHit hit; if (UnityEngine.Physics.Raycast(targetIceberg.transform.position + (UnityEngine.Random.insideUnitSphere * ConfigFile.icebergCratesSpawnRadius) + new Vector3(0, 50f, 0), Vector3.down, out hit, float.PositiveInfinity, 1274232599)) { if (hit.GetEntity()) { i--; continue; } BaseEntity ent = GameManager.server.CreateEntity(ConfigFile.icebergCratePrefab, hit.point, Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0)); if (ent) ent.Spawn(); StartCoroutine(SpawnItems(ent.GetComponent<StorageContainer>().inventory, plugin.icebergCrateTable, ConfigFile.icebergCrateMinItems, ConfigFile.icebergCrateMaxItems)); ent.Invoke(() => { if (ent) ent.Kill(); }, 600f); } } } private IEnumerator SpawnFloatingCrates() { for (int i = 0; i < ConfigFile.floatingCratesToSpawn; i++) { yield return new WaitForSeconds(0.1f); Vector3 randomPos = GetRandomOceanRadiusPosition(transform.position, ConfigFile.floatingCratesRadius); Vector3 spawnPos = new Vector3(randomPos.x, randomPos.y - 30f, randomPos.z); BaseEntity ent = GameManager.server.CreateEntity("assets/bundled/prefabs/radtown/crate_underwater_advanced.prefab", spawnPos, UnityEngine.Random.rotation, true); ent.Spawn(); StartCoroutine(SpawnItems(ent.GetComponent<StorageContainer>().inventory, plugin.floatingCrateTable, ConfigFile.floatingCrateMinItems, ConfigFile.floatingCrateMaxItems)); FreeableLootContainer freeable = ent.GetComponent<FreeableLootContainer>(); freeable.GetRB().isKinematic = false; freeable.buoyancy.enabled = true; freeable.buoyancy.buoyancyScale = 1f; freeable.SetFlag(BaseEntity.Flags.Reserved8, false, false); freeable.Invoke(() => { if (freeable) freeable.Kill(); }, ConfigFile.floatingCrateDespawnTime); } } private IEnumerator SpawnItems(ItemContainer container, List<ItemInfo> table, int min, int max) { container.Clear(); int itemsCreated = 0; int targetAmount = UnityEngine.Random.Range(min, max); while (itemsCreated < targetAmount) { yield return new WaitForSeconds(0.01f); ItemInfo data = table[UnityEngine.Random.Range(0, table.Count - 1)]; if (UnityEngine.Random.Range(0, 1) > data.chance) { continue; } yield return new WaitForSeconds(0.01f); Item newItem = ItemManager.CreateByName(data.itemName, UnityEngine.Random.Range(data.minItemAmount, data.maxItemAmount), data.skinID); if (newItem == null) { plugin.PrintError($"Item {data.itemName} could not be created"); continue; } newItem.MoveToContainer(container, -1, false); itemsCreated += 1; } } private IEnumerator SetHackableCrateTimers() { foreach(HackableLockedCrate entry in GetComponentsInChildren<HackableLockedCrate>()) { yield return new WaitForSeconds(0.01f); entry.hackSeconds = HackableLockedCrate.requiredHackSeconds - ConfigFile.hackableCrateSeconds; } } public void PauseToLoot(float pauseTime) { isPaused = true; pauseEndTime = UnityEngine.Time.time + pauseTime; } private Vector3 GetRandomOceanRadiusPosition(Vector3 centre, float radius) { Vector3 rand = centre + UnityEngine.Random.insideUnitSphere * radius; Vector3 randPos = new Vector3(rand.x, centre.y + 50f, rand.z); return new Vector3(randPos.x, TerrainMeta.WaterMap.GetHeight(randPos), randPos.z); } private void InitializeSpawnPosition() { Vector3 spawnCenter = targetIceberg.transform.position; spawnCenter.x = Mathf.Min(spawnCenter.x * ConfigFile.spawnDistance, ConVar.Server.worldsize); spawnCenter.z = Mathf.Min(spawnCenter.z * ConfigFile.spawnDistance, ConVar.Server.worldsize); Vector3 randomSphere = spawnCenter + (UnityEngine.Random.insideUnitSphere * 200f); transform.position = new Vector3(spawnCenter.x, TerrainMeta.WaterMap.GetHeight(spawnCenter), spawnCenter.z); } private Transform InitializeTransform(ref Transform trans, Vector3 offset) { trans = new GameObject().transform; trans.position = transform.position; trans.parent = transform; trans.localPosition = offset; shipTransforms.Add(trans); return trans; } private void TransformDebug() { foreach(BasePlayer player in BasePlayer.activePlayerList) { player.SendConsoleCommand("ddraw.box", 1f, Color.red, nosePosition.position, 0.1f); player.SendConsoleCommand("ddraw.box", 1f, Color.red, collisionPoint, 0.1f); foreach (Transform trans in shipTransforms) { player.SendConsoleCommand("ddraw.box", 1f, Color.red, trans.position, 3f); player.SendConsoleCommand("ddraw.box", 1f, Color.red, trans.position, 0.1f); player.SendConsoleCommand("ddraw.line", 1f, Color.red, trans.position, trans.position + new Vector3(0f, 50f, 0f)); } foreach (Vector3 trans in deckExplosionPositions) { player.SendConsoleCommand("ddraw.box", 1f, Color.red, transform.TransformPoint(trans), 3f); player.SendConsoleCommand("ddraw.box", 1f, Color.red, transform.TransformPoint(trans), 0.1f); player.SendConsoleCommand("ddraw.line", 1f, Color.red, transform.TransformPoint(trans), transform.TransformPoint(trans) + new Vector3(0f, 50f, 0f)); } } } private void DebugPos(Vector3 pos) { foreach (BasePlayer player in BasePlayer.activePlayerList) { player.SendConsoleCommand("ddraw.box", 30f, Color.red, pos, 3f); player.SendConsoleCommand("ddraw.box", 30f, Color.red, pos, 0.1f); player.SendConsoleCommand("ddraw.line", 30f, Color.red, pos, pos + new Vector3(0f, 50f, 0f)); player.Teleport(pos); } } private void DebugRay(Vector3 pos1, Vector3 pos2) { foreach (BasePlayer player in BasePlayer.activePlayerList) { player.SendConsoleCommand("ddraw.line", 30f, Color.red, pos1, pos2); } } private void DebugHit(RaycastHit hit) { Vector3 pos = hit.point; foreach (BasePlayer player in BasePlayer.activePlayerList) { player.SendConsoleCommand("ddraw.box", 30f, Color.red, pos, 3f); player.SendConsoleCommand("ddraw.box", 30f, Color.red, pos, 0.1f); player.SendConsoleCommand("ddraw.line", 30f, Color.red, pos, pos + new Vector3(0f, 50f, 0f)); player.SendConsoleCommand("ddraw.text", 30f, Color.red, pos, hit.GetCollider()?.name); } } private void Broadcast(string text) { plugin.PrintToChat(text); } } private class TitanicSpinningLight : FacepunchBehaviour { private SearchLight light; private float rotation; private void Awake() { light = GetComponent<SearchLight>(); light.enabled = false; light.SetFlag(BaseEntity.Flags.On, true); } private void FixedUpdate() { light.SetTargetAimpoint(NewLookPosition()); light.SendNetworkUpdateImmediate(); if (rotation >= 360f) rotation = rotation - 360f; } private Vector3 NewLookPosition() { float ang = rotation; rotation += 20f; Vector3 pos; pos.x = light.transform.position.x + 5f * Mathf.Cos(ang * Mathf.Deg2Rad); pos.y = light.transform.position.y; pos.z = light.transform.position.z + 5f * Mathf.Sin(ang * Mathf.Deg2Rad); return pos; } } [ChatCommand("calltitanic")] private void SpawnTitanicCMD(BasePlayer player, string command, string[] args) { if (!permission.UserHasPermission(player.UserIDString, permissionNameADMIN)) { player.ChatMessage(msg("No Permission")); return; } switch(args.Length) { case 0: manager.SpawnTitanic(); player.ChatMessage("Titanic event was triggered"); break; case 1: switch(args[0]) { case "random": manager.SpawnTitanic(); player.ChatMessage("Titanic event was triggered"); break; case "closest": manager.SpawnNearestIceberg(player.transform.position); player.ChatMessage("Titanic event was triggered"); break; } break; } } [ConsoleCommand("calltitanic")] private void SpawnTitanicConsoleCMD(ConsoleSystem.Arg arg) { if (arg.Connection != null) return; manager.SpawnTitanic(); Puts("Titanic event was triggered"); } [ConsoleCommand("rusttanic.updatedata")] private void UpdateTableDataConsoleCMD(ConsoleSystem.Arg arg) { if (arg.Connection != null) return; Puts("Attempting to load the latest data version"); LoadData(); Puts("Data was loaded succesfully"); } private object GetConfig(string menu, string datavalue, object defaultValue) { var data = Config[menu] as Dictionary<string, object>; if (data == null) { data = new Dictionary<string, object>(); Config[menu] = data; Changed = true; } object value; if (!data.TryGetValue(datavalue, out value)) { value = defaultValue; data[datavalue] = value; Changed = true; } return value; } private string msg(string key, string id = null) => lang.GetMessage(key, this, id); } } 
// If you wish to view this code in a formatted state, please contact redBDGR on discord @ redBDGR #0001


// --- End of file: RustTanic.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PanelV2.cs ---
// --- Original Local Path: PanelV2.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Random = UnityEngine.Random;
using System;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("PanelV2", "fermenspwnz", "2.1.6")]
    [Description("Красивая панель с отображением онлайна, времени, вертолета, аирдропа, челнока, танка и корабля.")]
    class PanelV2 : RustPlugin
    {
        static int downloaded;
        Plugin ImageLibrary => Interface.Oxide.RootPluginManager.GetPlugin("ImageLibrary");
        public string GetImage(string shortname, ulong skin = 0) => (string)ImageLibrary.Call("GetImage", shortname, skin);
        public bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname, skin);
        void gettimage(string url, string name)
        {
            string img = GetImage(name);
            string none = GetImage("NONE");
            string loading = GetImage("LOADING");
            if (string.IsNullOrEmpty(img) || string.IsNullOrEmpty(none) || none == img || string.IsNullOrEmpty(loading) || loading == img)
            {
                AddImage(url, name);
                timer.Once(1f, () => gettimage(url, name));
                return;
            }
            downloaded++;
            if (downloaded.Equals(config.imagelist.Count))
            {
                Debug.Log("Подгрузили все картинки! >>PANELV2<<");
                Subscribe(nameof(OnPlayerConnected));
                if (config.messages != null && config.messages.Count() > 0)
                {
                    new PluginTimers(this).Every(config.infotimer, () => FarmGUI(TypeGui.Message));
                }
                new PluginTimers(this).Every(5f, () => FarmGUI(TypeGui.Time));
                FarmGUI(TypeGui.All);
            }
        }
        List<ulong> _players = new List<ulong>();

        #region Config
        static Dictionary<string, string> _imagelist = new Dictionary<string, string>
        {
            {"https://gspics.org/images/2019/03/11/mUaUn.png","chelnok"},
            {"https://gspics.org/images/2019/03/11/mUSE7.png","heli"},
            {"https://gspics.org/images/2019/03/11/mUR8K.png","plane"},
            {"https://gspics.org/images/2019/03/11/mUOGE.png","cargo"},
            {"https://gspics.org/images/2019/03/24/UCU8o.png","tank"}
        };

        static List<string> _messages = new List<string>
        {
          "Настроить <color=#ffff99>Информационную строку</color> можно в конфиге плагина <color=#ffff66>PanelV2</color>",
          "Настроить <color=#ffff99>Infoрмационную строку</color> можно в конфиге плагина <color=#ffff66>PanelV2</color>",
          "Настроить <color=#ffff99>'Информационную строку'</color> можно в конфиге плагина <color=#ffff66>PanelV2</color>"
        };

        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        private class PluginConfig
        {
            [JsonProperty("Накрутка онлайна")]
            public int onliner = 0;

            [JsonProperty("Информационная строка (если пусто, то выключена)")]
            public List<string> messages;

            [JsonProperty("Информационная строка | Частота обновлений в секундах")]
            public float infotimer;

            [JsonProperty("Сообщение | Онлайн")]
            public string message;

            [JsonProperty("Онлайн - размер текста")]
            public string onlinesize;

            [JsonProperty("Время - размер текста")]
            public string timersize;

            [JsonProperty("Картинки")]
            public Dictionary<string, string> imagelist;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    onliner = 0,
                    messages = _messages,
                    infotimer = 60f,
                    imagelist = _imagelist,
                    message = "Онлайн {players} из {maxplayers}",
                    onlinesize = "13",
                    timersize = "13",
                };
            }
        }
        #endregion

        #region Function
        string[] panels = { "timer", "boat", "tank", "FarmGUI3", "online", "plane", "helis", "chelnok" };
        void DestroyUI(Network.Connection player)
        {
            foreach (var z in panels) CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player }, null, "DestroyUI", z);
        }
        #endregion

        #region Hooks
        void Unload()
        {
            foreach (var z in panels) CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", z);
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", "message");
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            NextTick(() =>
            {
                FarmGUI(TypeGui.Online);
            });
        }

        static string GUIjsontimer = "";
        static string GUIjsononline = "";

        private void Init()
        {
            Unsubscribe(nameof(OnPlayerConnected));
        }

        void OnServerInitialized()
        {
            AddImage("http://i.imgur.com/sZepiWv.png", "NONE", 0);
            AddImage("http://i.imgur.com/lydxb0u.png", "LOADING", 0);
            if (config.timersize == null)
            {
                config.timersize = "13";
                config.onlinesize = "13";
                SaveConfig();
            }
            if (config.message == null)
            {
                config.imagelist = _imagelist;
                config.message = "Онлайн {players} из {maxplayers}";
                SaveConfig();
            }
            if (!ImageLibrary)
            {
                PrintWarning("Image Library не обнаружен, отгружаем Панель.");
                Interface.Oxide.UnloadPlugin(Name);
                return;
            }
            GUIjsontimer = "[{\"name\":\"timer\",\"parent\":\"Hud\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"fontSize\":\"{timesize}\",\"color\":\"1 1 1 0.5\",\"text\":\"{text}\",\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"0 29.976\",\"offsetmax\":\"55.8 55.7\"}]}]".Replace("{timesize}", config.timersize);
            GUIjsononline = "[{\"name\":\"online\",\"parent\":\"Hud\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"fontSize\":\"{onlinesize}\",\"color\":\"1 1 1 0.5\",\"text\":\"{text}\",\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"0 5.09\",\"offsetmax\":\"120 25.19\"}]}]".Replace("{onlinesize}", config.onlinesize);
            foreach (var z in config.imagelist) gettimage(z.Key, z.Value);
            ships = UnityEngine.Object.FindObjectsOfType<CargoShip>().Count();
            planes = UnityEngine.Object.FindObjectsOfType<CargoPlane>().Count();
            helicopters = UnityEngine.Object.FindObjectsOfType<BaseHelicopter>().Count();
            tanks = UnityEngine.Object.FindObjectsOfType<BradleyAPC>().Count();
            chinooks = UnityEngine.Object.FindObjectsOfType<CH47HelicopterAIController>().Count();
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.Once(2, () => OnPlayerConnected(player));
                return;
            }
            NextTick(() =>
            {
                if (player == null || !player.IsConnected) return;
                if (!_players.Contains(player.userID)) FarmGUI(TypeGui.All, new List<Network.Connection> { player.net.connection });
                FarmGUI(TypeGui.Online);
            });
        }



        int helicopters = 0;
        int planes = 0;
        int ships = 0;
        int tanks = 0;
        int chinooks = 0;

        void OnEntityKill(BaseNetworkable Entity)
        {
            if (Entity == null) return;
            if (Entity is BaseHelicopter)
            {
                helicopters--;
                if (helicopters == 0) FarmGUI(TypeGui.Heli);
            }
            else if (Entity is CargoPlane)
            {
                planes--;
                if (planes == 0) FarmGUI(TypeGui.Plane);
            }
            else if (Entity is CargoShip)
            {
                ships--;
                if (ships == 0) FarmGUI(TypeGui.Ship);
            }
            else if (Entity is BradleyAPC)
            {
                tanks--;
                if (tanks == 0) FarmGUI(TypeGui.Tank);
            }
            else if (Entity is CH47HelicopterAIController)
            {
                chinooks--;
                if (chinooks == 0) FarmGUI(TypeGui.Chinook);
            }
        }

        private void OnEntitySpawned(BaseNetworkable Entity)
        {
            if (Entity == null) return;
            if (Entity is BaseHelicopter)
            {
                helicopters++;
                if (helicopters == 1) FarmGUI(TypeGui.Heli);
            }
            else if (Entity is CargoPlane)
            {
                planes++;
                if (planes == 1) FarmGUI(TypeGui.Plane);
            }
            else if (Entity is CargoShip)
            {
                ships++;
                if (ships == 1) FarmGUI(TypeGui.Ship);
            }
            else if (Entity is BradleyAPC)
            {
                tanks++;
                if (tanks == 1) FarmGUI(TypeGui.Tank);
            }
            else if (Entity is CH47HelicopterAIController)
            {
                chinooks++;
                if (chinooks == 1) FarmGUI(TypeGui.Chinook);
            }
        }
        #endregion

        [ConsoleCommand("gategui")]
        void gategui(ConsoleSystem.Arg arg)
        {
            ulong userid = arg.Connection.userid;
            if (cooldown.ContainsKey(userid) && cooldown[userid] > DateTime.Now)
            {
                arg.Player().Command("chat.add", 2, 0, "Не так часто!");
                return;
            }
            if (!_players.Contains(userid))
            {
                _players.Add(userid);
                CloseGUI(arg.Connection);
            }
            else
            {
                _players.Remove(userid);
                if (!_players.Contains(userid)) FarmGUI(TypeGui.All, new List<Network.Connection> { arg.Connection });
                cooldown[userid] = DateTime.Now.AddSeconds(10);
            }
        }

        #region GUI
        enum TypeGui
        {
            Message, All, Online, Time, Heli, Tank, Chinook, Plane, Ship
        }

        void CloseGUI(Network.Connection connect)
        {
            DestroyUI(connect);
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = connect }, null, "AddUI", GUIjsondisable);
        }

        Dictionary<ulong, DateTime> cooldown = new Dictionary<ulong, DateTime>();


        const string GUIjsonmessage = "[{\"name\":\"message\",\"parent\":\"Hud\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"fontSize\":\"13\",\"color\":\"1 1 1 0.5\",\"text\":\"{text}\",\"align\":\"LowerCenter\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.495 0\",\"anchormax\":\"0.495 0\",\"offsetmin\":\"-500 0\",\"offsetmax\":\"500 20\"}]}]";
        const string GUIjsonfon = "[{\"name\":\"FarmGUI3\", \"parent\":\"Hud\", \"components\":[{\"type\":\"UnityEngine.UI.Image\", \"color\":\"0 0 0 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\"}]},{\"name\":\"7a37bb60454b43e995e914a1ccc042e8\",\"parent\":\"FarmGUI3\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"material\":\"assets/content/ui/namefontmaterial.mat\",\"color\":\"0.95 0.95 0.95 0.025\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"57.6 29.976\",\"offsetmax\":\"86.4 55.7\"}]},{\"name\":\"538cf01fbd6842298dbbc3addec341e8\",\"parent\":\"FarmGUI3\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"material\":\"assets/content/ui/namefontmaterial.mat\",\"color\":\"0.95 0.95 0.95 0.025\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"88.2 29.976\",\"offsetmax\":\"117 55.7\"}]},{\"name\":\"5db1aeebf0294093a77b0e72194c6946\",\"parent\":\"FarmGUI3\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"material\":\"assets/content/ui/namefontmaterial.mat\",\"color\":\"0.95 0.95 0.95 0.025\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"118.8 29.976\",\"offsetmax\":\"147.6 55.7\"}]},{\"name\":\"c6a8a5f3882649b8ae89392faf557f20\",\"parent\":\"FarmGUI3\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"material\":\"assets/content/ui/namefontmaterial.mat\",\"color\":\"0.95 0.95 0.95 0.025\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"149.4 29.976\",\"offsetmax\":\"178.2 55.7\"}]},{\"name\":\"1b31e40057534d32a978915563513fa1\",\"parent\":\"FarmGUI3\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"material\":\"assets/content/ui/namefontmaterial.mat\",\"color\":\"0.95 0.95 0.95 0.025\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"0 29.976\",\"offsetmax\":\"55.7 55.7\"}]},{\"name\":\"f6d9849bec0d4b15a757e986bdfdda4c\",\"parent\":\"FarmGUI3\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"material\":\"assets/content/ui/namefontmaterial.mat\",\"color\":\"0.95 0.95 0.95 0.025\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"118.8 2.171\",\"offsetmax\":\"147.6 28.056\"}]},{\"name\":\"402c08c95caa484f94a848e7dfdb2b37\",\"parent\":\"FarmGUI3\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"material\":\"assets/content/ui/namefontmaterial.mat\",\"color\":\"0.95 0.95 0.95 0.025\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"0 2.171\",\"offsetmax\":\"117 28.056\"}]},{\"name\":\"c92e68d80c68458885a5c487f497b9f8\",\"parent\":\"FarmGUI3\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"gategui\",\"material\":\"assets/content/ui/namefontmaterial.mat\",\"color\":\"0.95 0.95 0.95 0.025\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"149.4 2.171\",\"offsetmax\":\"178.2 28.056\"}]},{\"parent\":\"c92e68d80c68458885a5c487f497b9f8\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"↴\",\"fontSize\":20,\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\"}]}]";
        static string GUIjsondisable = "[{\"name\":\"FarmGUI3\", \"parent\":\"Hud\", \"components\":[{\"type\":\"UnityEngine.UI.Image\", \"color\":\"0 0 0 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\"}]},{\"name\":\"c92e68d80c68458885a5c487f497b9f8\",\"parent\":\"FarmGUI3\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"gategui\",\"material\":\"assets/content/ui/namefontmaterial.mat\",\"color\":\"0.95 0.95 0.95 0.025\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"149.4 2.171\",\"offsetmax\":\"178.2 28.056\"}]},{\"parent\":\"c92e68d80c68458885a5c487f497b9f8\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"↰\",\"fontSize\":20,\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\"}]}]";
        static string GUIjsononplane = "[{\"name\":\"plane\",\"parent\":\"Hud\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"color\":\"{color}\",\"png\":\"{png}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"61.2 32.9\",\"offsetmax\":\"82.8 53\"}]}]";
        static string GUIjsononship = "[{\"name\":\"boat\",\"parent\":\"Hud\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"color\":\"{color}\",\"png\":\"{png}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"153 32.9\",\"offsetmax\":\"174.6 53\"}]}]";
        static string GUIjsonontank = "[{\"name\":\"tank\",\"parent\":\"Hud\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"color\":\"{color}\",\"png\":\"{png}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"122.4 5.09\",\"offsetmax\":\"144 25.19\"}]}]";
        static string GUIjsononheli = "[{\"name\":\"helis\",\"parent\":\"Hud\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"color\":\"{color}\",\"png\":\"{png}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"91.8 32.9\",\"offsetmax\":\"113.4 53\"}]}]";
        static string GUIjsononchinook = "[{\"name\":\"chelnok\",\"parent\":\"Hud\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"color\":\"{color}\",\"png\":\"{png}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.69 0.0195\",\"anchormax\":\"0.69 0.0195\",\"offsetmin\":\"122.4 32.9\",\"offsetmax\":\"144 53\"}]}]";

        private void FarmGUI(TypeGui funct = TypeGui.All, List<Network.Connection> sendto = null)
        {
            if (sendto == null) sendto = Network.Net.sv.connections.Where(x => !_players.Contains(x.userid)).ToList();
            if (funct == TypeGui.All)
            {
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "DestroyUI", "FarmGUI3");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "AddUI", GUIjsonfon);
            }
            if (funct == TypeGui.All || funct == TypeGui.Message)
            {
                string text = GUIjsonmessage.Replace("{text}", config.messages[Random.Range(0, config.messages.Count)]);
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "DestroyUI", "message");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "AddUI", text);
            }
            if (funct == TypeGui.All || funct == TypeGui.Time)
            {
                string text = GUIjsontimer.Replace("{text}", TOD_Sky.Instance.Cycle.DateTime.ToString("HH:mm", CultureInfo.InvariantCulture));
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "DestroyUI", "timer");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "AddUI", text);
            }
            if (funct == TypeGui.All || funct == TypeGui.Online)
            {
                string text = GUIjsononline.Replace("{text}", config.message.Replace("{players}", (BasePlayer.activePlayerList.Count + config.onliner).ToString()).Replace("{maxplayers}", ConVar.Server.maxplayers.ToString()));
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "DestroyUI", "online");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "AddUI", text);
            }
            if (funct == TypeGui.All || funct == TypeGui.Plane)
            {
                string gui = GUIjsononplane.Replace("{png}", GetImage("plane")).Replace("{color}", planes > 0 ? "0.5 1 0.5 0.7" : "1 1 1 0.7");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "DestroyUI", "plane");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "AddUI", gui);
            }
            if (funct == TypeGui.All || funct == TypeGui.Ship)
            {
                string gui = GUIjsononship.Replace("{png}", GetImage("cargo")).Replace("{color}", ships > 0 ? "0 0.7 1 0.7" : "1 1 1 0.7");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "DestroyUI", "boat");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "AddUI", gui);
            }
            if (funct == TypeGui.All || funct == TypeGui.Tank)
            {
                string gui = GUIjsonontank.Replace("{png}", GetImage("tank")).Replace("{color}", tanks > 0 ? "0.7 0.9 0.5 0.7" : "1 1 1 0.7");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "DestroyUI", "tank");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "AddUI", gui);
            }
            if (funct == TypeGui.All || funct == TypeGui.Heli)
            {
                string gui = GUIjsononheli.Replace("{png}", GetImage("heli")).Replace("{color}", helicopters > 0 ? "1 0.5 0.5 0.7" : "1 1 1 0.7");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "DestroyUI", "helis");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "AddUI", gui);
            }
            if (funct == TypeGui.All || funct == TypeGui.Chinook)
            {
                string gui = GUIjsononchinook.Replace("{png}", GetImage("chelnok")).Replace("{color}", chinooks > 0 ? "0.2 0.8 0.4 0.7" : "1 1 1 0.7");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "DestroyUI", "chelnok");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "AddUI", gui);
            }

        }
        #endregion
    }
}

// --- End of file: PanelV2.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BetterVanish-1.7.4.cs ---
// --- Original Local Path: BetterVanish-1.7.4.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Facepunch;
using Network;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using Rust;
using Rust.Ai;
using Rust.Registry;
using UnityEngine;
using QueryGrid = BaseEntity.Query;
using Human_Npc = global::HumanNPC;

namespace Oxide.Plugins
{
    [Info("BetterVanish", "Def", "1.7.4")]
    [Description("Customized & Optimized \"Vanish\"")]
    public class BetterVanish : RustPlugin
    {
        // Hooks: OnVanishDisappear(BasePlayer), OnVanishReappear(BasePlayer)
        // API: _IsInvisible(BasePlayer), _IsInvisible(IPlayer), _Disappear(BasePlayer), _Reappear(BasePlayer)

        #region Constants

        private const string PermUse = "bettervanish.allowed";
        private const string PermUseOther = "bettervanish.allowedother";
        private const string PermPermanent = "bettervanish.perma";
        private const string PermUnvanish = "bettervanish.unvanish";
        private const string PermInvSpy = "bettervanish.invspy";
        private const string PermSkipLocks = "bettervanish.skiplocks";
        private const string CuiName = "VanishIcon";
        private const string PlayerPrefab = "assets/prefabs/player/player.prefab";
        private const string PlayerCorpsePrefab = "assets/prefabs/player/player_corpse.prefab";
        private const string EffectDisappear = "assets/bundled/prefabs/fx/gestures/cameratakescreenshot.prefab";
        private const string EffectAppear = "assets/bundled/prefabs/fx/gestures/drink_vomit.prefab";
        private static readonly Effect EffectInstance = new Effect();
        private static readonly DamageTypeList EmptyDmgList = new DamageTypeList();
        private static readonly GameObjectRef EmptyObjRef = new GameObjectRef();
        private static readonly object FalseObj = false;
        private static readonly object TrueObj = true;
        //
        private enum VanishEvent { Disappear, Reappear, Disconnect, Unload }
        //
        private static readonly List<string> HooksLst = new List<string>
        {
            nameof(OnEntityMarkHostile), nameof(OnEntityTakeDamage), nameof(OnPlayerDisconnected), nameof(CanUseLockedEntity), nameof(OnPlayerViolation), 
            nameof(OnTeamInvite), nameof(OnPlayerColliderEnable)
        };

        #endregion

        #region Fields

        private static BetterVanish _instance;
        private static CuiElementContainer _cui;
        private GameObjectRef _fallDmgEff = EmptyObjRef, _drownEff = EmptyObjRef;
        private bool _isShutdown;
        private bool _lastHooksState = true;

        #endregion

        #region Configuration

        private const int CfgRev = 4;
        private static Configuration _config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "Show visual indicator (true/false)")]
            public bool ShowIndicator;

            [JsonProperty(PropertyName = "Visual indicator image address")]
            public string IndicatorAddress;

            [JsonProperty(PropertyName = "Visual indicator anchor min")]
            public string IndicatorAnchorMin;

            [JsonProperty(PropertyName = "Visual indicator anchor max")]
            public string IndicatorAnchorMax;

            [JsonProperty(PropertyName = "Visual indicator color")]
            public string IndicatorColor;

            [JsonProperty("Depth of an underground teleport (upon disconnection)")]
            public float UndergroundTeleportDepth;

            [JsonProperty(PropertyName = "Block all incoming damage while vanished (true/false)")]
            public bool BlockAllIncomingDamage;

            [JsonProperty(PropertyName = "Block all outgoing damage while vanished (true/false)")]
            public bool BlockAllOutgoingDamage;

            [JsonProperty(PropertyName = "Auto vanish on connect (true/false)")]
            public bool AutoVanish;

            [JsonProperty(PropertyName = "Auto noclip on connect (true/false)")]
            public bool AutoNoclip;
            
            [JsonProperty(PropertyName = "Auto noclip on vanish (true/false)")]
            public bool AutoNoclipOnVanish;
            
            [JsonProperty(PropertyName = "Turn off noclip on reappear (true/false)")]
            public bool TurnOffNoclipOnReappear;

            [JsonProperty(PropertyName = "Persist vanish (don't unhide upon leave & restore after restart)")]
            public bool PersistVanish;

            [JsonProperty(PropertyName = "Use sound effects (true/false)")]
            public bool SoundEffects;
            
            [JsonProperty(PropertyName = "Enable safepoints (true/false)")]
            public bool SafePoints;

            [JsonProperty(PropertyName = "Remove all safepoints after wipe (true/false)")]
            public bool SafePointsRemoval;

            [JsonProperty(PropertyName = "Config revision (do not edit)")]
            public int ConfigRev;

            public static Configuration DefaultConfig()
            {
                return new Configuration
                {
                    ShowIndicator = true,
                    IndicatorAddress = "https://i.imgur.com/dOvX4uA.png",
                    IndicatorColor = "0.7 0 0 1",
                    IndicatorAnchorMin = "0.1 0.001",
                    IndicatorAnchorMax = "0.17 0.10",
                    UndergroundTeleportDepth = 15,
                    BlockAllIncomingDamage = true,
                    BlockAllOutgoingDamage = true,
                    AutoVanish = true,
                    AutoNoclip = true,
                    AutoNoclipOnVanish = true,
                    TurnOffNoclipOnReappear = true, 
                    PersistVanish = true,
                    SoundEffects = true,
                    SafePoints = true,
                    SafePointsRemoval = true,
                    ConfigRev = CfgRev
                };
            }
        }

        private void MigrateConfig()
        {
            switch (_config.ConfigRev)
            {
                case 1:
                case 2:
                case 3:
                    _config.ConfigRev = CfgRev;
                    break;
            }
            SaveConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if(_config.ConfigRev != CfgRev)
                    MigrateConfig();
            }
            catch
            {
                PrintWarning($"Could not read oxide/config/{Name}.json, creating new config file");
                LoadDefaultConfig();
                SaveConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = Configuration.DefaultConfig();

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion

        #region Data
        
        private readonly ListHashSet<ulong> _hiddenPlayers = new ListHashSet<ulong>();
        private readonly ListHashSet<ulong> _hiddenPlayersPersist = new ListHashSet<ulong>();
        private Dictionary<ulong, string> _safePoints;

        private void LoadSafePoints() =>
            _safePoints = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, string>>($"{nameof(BetterVanish)}-SafePoints");

        private void SaveSafePoints() => Interface.Oxide.DataFileSystem.WriteObject($"{nameof(BetterVanish)}-SafePoints", _safePoints);

        private void LoadPersistPlayers()
        {
            var lst = Interface.Oxide.DataFileSystem.ReadObject<List<ulong>>($"{nameof(BetterVanish)}-PersistPlr");
            _hiddenPlayersPersist.Clear();
            _hiddenPlayersPersist.AddRange(lst);
        }

        private void SavePersistPlayers() =>
            Interface.Oxide.DataFileSystem.WriteObject($"{nameof(BetterVanish)}-PersistPlr", new List<ulong>(_hiddenPlayersPersist));

        private void LoadData()
        {
            LoadSafePoints();
            LoadPersistPlayers();
        }

        private void SaveData()
        {
            SaveSafePoints();
            SavePersistPlayers();
        }
        
        #endregion

        #region Classes
        
        private class VanishComponent : MonoBehaviour, IEntity
        {
            private BasePlayer _owner;
            private GameObject _dummyObj;

            private static readonly ListHashSet<Type> InterestedTriggers = new ListHashSet<Type>
            {
                typeof(TriggerWorkbench), typeof(TriggerLadder), typeof(TriggerParent), typeof(TriggerParentEnclosed), typeof(TriggerParentExclusion),
                typeof(TriggerMount)
            };

            private void Awake()
            {
                _owner = GetComponent<BasePlayer>();
                if(_owner.IsConnected)
                    StartNetworkGroupsUpdate();
                SetupDummyCollider();
            }

            private void UpdateNetworkGroups()
            {
                if (_owner.IsConnected && !_owner.IsSpectating())
                    _owner.net.UpdateGroups(_owner.transform.position);
            }

            public void StopNetworkGroupsUpdate() => CancelInvoke(nameof(UpdateNetworkGroups));
            
            public void StartNetworkGroupsUpdate() => InvokeRepeating(nameof(UpdateNetworkGroups), 3f, 3f);
            
            private void OnDestroy()
            {
                Entity.Unregister(_dummyObj);
                _owner.RemoveFromTriggers();
                Destroy(_dummyObj);
                _dummyObj = null;
                _owner = null;
            }

            #region Trigger Subsystem

            public bool IsDestroyed => _owner.IsDestroyed;

            private void SetupDummyCollider()
            {
                _dummyObj = _owner.gameObject.CreateChild();
                _dummyObj.name = "VanishTrig";
                _dummyObj.tag = "DeployVolumeIgnore";
                Entity.Register(_dummyObj, this);
                _dummyObj.layer = (int)Layer.Player_Server;
                _dummyObj.AddComponent<SphereCollider>().isTrigger = true;
            }

            private IEnumerable<TriggerBase> GetValidTriggers(Collider collider) => collider.GetComponentsInParent<TriggerBase>().
                Where(t=>t.InterestedInObject(_owner.gameObject) && InterestedTriggers.Contains(t.GetType()));

            private void OnTriggerEnter(Collider collider)
            {
				if(_owner.IsSpectating())
					return;
                foreach (var trigger in GetValidTriggers(collider)) 
                    trigger.OnTriggerEnter(_owner.playerCollider);
            }

            private void OnTriggerExit(Collider collider)
            {
				if(_owner.IsSpectating())
					return;
                foreach (var trigger in GetValidTriggers(collider)) 
                    trigger.OnTriggerExit(_owner.playerCollider);
            }

            #endregion
            
        }

        private class LootProxyController : FacepunchBehaviour
        {
            public BasePlayer lootsrc;
            public BasePlayer looter;
            public PlayerCorpse proxy;

            public void Init(BasePlayer lootSource, BasePlayer looterPlayer)
            {
                lootsrc = lootSource;
                looter = looterPlayer;
            }

            private void Awake()
            {
                proxy = GetComponent<PlayerCorpse>();
                InvokeRepeating(LifeCheck, 1f, .65f);
            }

            private void PlayerStoppedLooting(BasePlayer player) => Destroy(this);

            private void LifeCheck()
            {
                if (lootsrc && looter && looter.IsConnected)
                    return;
                Destroy(this);
            }

            private void OnDestroy()
            {
                proxy.containers = null;
                proxy.Kill();
            }
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandVanish"] = "vanish",
                ["CommandSetVanish"] = "setvanish",
                ["CommandUnvanishAll"] = "unvanishall",
                ["CommandInvSpy"] = "invspy",
                ["VanishDisabled"] = "<color=#FF686B>Vanish disabled</color>",
                ["VanishEnabled"] = "<color=#91D6FF>Vanish enabled</color>",
                ["VanishDisabledOther"] = "<color=#FF686B>You disabled vanish on {0}</color>",
                ["VanishEnabledOther"] = "<color=#91D6FF>You enabled vanish on {0}</color>",
                ["VanishPermanent"] = "<color=#FF686B>You have no rights to disable vanish!</color>",
                ["UnvanishedPlayers"] = "<color=#FF686B>You unvanished {0} players!</color>",
                ["SetVanishHelp"] = "Syntax: /setvanish PlayerName",
                ["SafePointNotSet"] = "You haven\'t set your <color=#F7B267>Safe Point</color>!\nType <color=#FF686B>/vanish safepoint</color> to save your current position.\nYou will be automatically teleported there upon disconnection.",
                ["SafePointSaved"] = "Your current position is saved as a Safe Point!",
                ["MultiplePlayers"] = "Multiple players found!\nRefine your search or use Steam ID.",
                ["NothingInSight"] = "No players in sight",
                ["NoSuchPlayer"] = "No such player found ({0})",
                ["InvSpyLooting"] = "Looting: {0} ({1}).",
            }, this);
        }

        #endregion

        #region Initialization

        private void Init()
        {
            _instance = this;
            permission.RegisterPermission(PermUse, this);
            permission.RegisterPermission(PermUseOther, this);
            permission.RegisterPermission(PermPermanent, this);
            permission.RegisterPermission(PermUnvanish, this);
            permission.RegisterPermission(PermInvSpy, this);
            permission.RegisterPermission(PermSkipLocks, this);
            AddCommandAliases("CommandVanish", nameof(VanishCommand));
            AddCommandAliases("CommandSetVanish", nameof(SetVanishCommand));
            AddCommandAliases("CommandUnvanishAll", nameof(UnvanishAllCommand));
            AddCommandAliases("CommandInvSpy", nameof(InvSpyCommand));
            if (!_config.AutoNoclip && !_config.AutoVanish && !_config.PersistVanish)
                Unsubscribe(nameof(OnPlayerConnected));
            LoadData();
            ManageHooks();
            _cui = new CuiElementContainer
            {
                new CuiElement
                {
                    Name = CuiName,
                    Parent = "Hud.Menu",
                    Components =
                    {
                        new CuiRawImageComponent { Color = _config.IndicatorColor, Url = _config.IndicatorAddress, Sprite = "assets/icons/refresh.png" },
                        new CuiRectTransformComponent { AnchorMin = _config.IndicatorAnchorMin, AnchorMax = _config.IndicatorAnchorMax }
                    }
                }
            };
        }
        
        private void OnServerInitialized()
        {
            var pp = GameManager.server.FindPrefab(PlayerPrefab).GetComponent<BaseEntity>().ToPlayer();
            _drownEff = pp.drownEffect;
            _fallDmgEff = pp.fallDamageEffect;
            DisappearAll();
        }

        private void OnNewSave(string _)
        {
            if (_config.SafePointsRemoval) 
                _safePoints.Clear();
            _hiddenPlayersPersist.Clear();
            SaveData();
        }

        #endregion

        #region De-initialization

        private void OnServerShutdown() => _isShutdown = true;

        private void Unload()
        {
            foreach (var uid in _hiddenPlayers.ToArray())
            {
                var plr = FindPlayerById(uid);
                if(plr)
                    HandleEvent(plr, VanishEvent.Unload);
            }
            SaveData();
            if (!_isShutdown) 
                ReappearAll();
            _config = null;
            _cui = null;
            _instance = null;
        }

        #endregion

        #region Commands

        private void VanishCommand(IPlayer iplayer, string command, string[] args)
        {
            var player = (BasePlayer)iplayer.Object;
            if (!player.IsAdmin && !HasPerm(player.UserIDString, PermUse))
                return;
            if (args.Length > 0 && args[0].Equals("safepoint") && _config.SafePoints)
            {
                _safePoints[player.userID] = $"{player.transform.position.x} {player.transform.position.y} {player.transform.position.z}";
                Player.Message(player, Lang("SafePointSaved", player.UserIDString));
                return;
            }
            var isVanished = IsPlayerVanished(player);
            if (isVanished && IsPlayerPermanent(player))
            {
                Player.Message(player, Lang("VanishPermanent", player.UserIDString));
                return;
            }
            HandleEvent(player, isVanished ? VanishEvent.Reappear : VanishEvent.Disappear);
        }

        private void SetVanishCommand(IPlayer iplayer, string command, string[] args)
        {
            var player = (BasePlayer)iplayer.Object;
            if (!player.IsAdmin && !HasPerm(player.UserIDString, PermUseOther))
                return;
            if (args.Length > 0)
            {
                var playerName = string.Join(" ", args);
                var result = FindPlayer(playerName);
                var target = result as BasePlayer;
                if (target == null && result != null)
                {
                    Player.Message(player, Lang("MultiplePlayers", player.UserIDString));
                    return;
                }

                if (target == null)
                {
                    Player.Message(player, Lang("NoSuchPlayer", player.UserIDString, playerName));
                    return;
                }

                var isVanished = IsPlayerVanished(target);
                HandleEvent(target, isVanished ? VanishEvent.Reappear : VanishEvent.Disappear);
                Player.Message(player, Lang(isVanished ? "VanishDisabledOther" : "VanishEnabledOther", player.UserIDString, target.displayName));
            }
            else
                Player.Message(player, Lang("SetVanishHelp", player.UserIDString));
        }

        private void UnvanishAllCommand(IPlayer iplayer, string command, string[] args)
        {
            var player = (BasePlayer)iplayer.Object;
            if (!player.IsAdmin && !HasPerm(player.UserIDString, PermUnvanish))
                return;
            var count = 0;
            ReappearAll(_=>count++);
            Player.Message(player, Lang("UnvanishedPlayers", player.UserIDString, count));
        }

        private void InvSpyCommand(IPlayer iplayer, string command, string[] args)
        {
            var player = (BasePlayer)iplayer.Object;
            if (!player.IsAdmin && (!HasPerm(player.UserIDString, PermInvSpy)))
                return;
            timer.In(.15f, () => InvSpyShowLoot(player, args));
        }

        #endregion

        #region Vanishing Act

        private void Disappear(BasePlayer player, bool showGui = true)
        {
            if (IsPlayerVanished(player))
                return;
            if (player.IsConnected)
            {
                if (!_hiddenPlayers.Contains(player.userID))
                    _hiddenPlayers.Add(player.userID);
                _hiddenPlayersPersist.Remove(player.userID);
            }
            else
                player.SetServerFall(false);
            player.syncPosition = false;
            player.limitNetworking = true;
            player.fallDamageEffect = EmptyObjRef;
            player.drownEffect = EmptyObjRef;
            player.GetHeldEntity()?.SetHeld(false);
            player.DisablePlayerCollider();
            VanishComponent vc;
            if (player.gameObject.TryGetComponent(out vc))
                vc.StartNetworkGroupsUpdate();
            else
                player.gameObject.AddComponent<VanishComponent>();
            SimpleAIMemory.AddIgnorePlayer(player);
            QueryGrid.Server.RemovePlayer(player);
            RemoveFromTargets(player);
            if (player.IsConnected)
            {
                if (showGui)
                    VanishGui(player);
                Player.Message(player, Lang("VanishEnabled", player.UserIDString));
                if (_config.SoundEffects)
                    SendEffectTo(EffectDisappear, player);
            }
            if(_config.AutoNoclipOnVanish && !player.isMounted && !player.IsFlying)
                player.SendConsoleCommand("noclip");
            ManageHooks();
            plugins.CallHook("OnVanishDisappear", player);
        }

        #endregion

        #region Reappearing Act

        private void Reappear(BasePlayer player)
        {
            if (!IsPlayerVanished(player) && !IsPlayerPersisted(player))
                return;
            _hiddenPlayers.Remove(player.userID);
            _hiddenPlayersPersist.Remove(player.userID);
            player.syncPosition = true;
            player.limitNetworking = false;
            UnityEngine.Object.Destroy(player.GetComponent<VanishComponent>());
            player.UpdateNetworkGroup();
            player.SendNetworkUpdate();
            player.GetHeldEntity()?.UpdateVisibility_Hand();
            player.EnablePlayerCollider();
            QueryGrid.Server.AddPlayer(player);
            SimpleAIMemory.RemoveIgnorePlayer(player);
            player.drownEffect = _drownEff;
            player.fallDamageEffect = _fallDmgEff;
            player.ForceUpdateTriggers();
            if (player.IsConnected)
            {
                DestroyVanishGui(player);
                Player.Message(player, Lang("VanishDisabled", player.UserIDString));
                if (_config.SoundEffects)
                    SendEffectTo(EffectAppear, player);
            }
            if(_config.TurnOffNoclipOnReappear && !player.isMounted && player.IsFlying)
                player.SendConsoleCommand("noclip");
            ManageHooks();
            plugins.CallHook("OnVanishReappear", player);
        }

        #endregion

        #region Hooks

        private object OnEntityTakeDamage(BaseEntity victim, HitInfo info)
        {
            var attacker = info?.InitiatorPlayer;
            if (victim == null && attacker == null)
                return null;
            var victimInvis = IsPlayerVanished(victim.ToPlayer());
            var attackerInvis = IsPlayerVanished(attacker);
            if (!victimInvis && !attackerInvis)
                return null;
            if (victimInvis && !_config.BlockAllIncomingDamage)
                return null;
            if (attackerInvis && !victimInvis && !_config.BlockAllOutgoingDamage)
                return null;
            if (info == null)
                return this;
            info.damageTypes = EmptyDmgList;
            info.HitMaterial = 0;
            info.DoHitEffects = false;
            info.PointStart = Vector3.zero;
            info.HitEntity = null;
            return this;
        }

        private object OnEntityMarkHostile(BasePlayer player) => IsPlayerVanished(player) ? this : null;

        private object OnPlayerColliderEnable(BasePlayer player, CapsuleCollider _) => IsPlayerVanished(player) ? this : null;

        private object CanUseLockedEntity(BasePlayer player, BaseLock baseLock)
        {
            if (!IsPlayerVanished(player))
                return null;
            if(player.IsAdmin || permission.UserHasPermission(player.UserIDString, PermSkipLocks))
                return TrueObj;
            var cl = baseLock as CodeLock;
            if (cl != null)
                return cl.whitelistPlayers.Contains(player.userID) || cl.guestPlayers.Contains(player.userID) ? TrueObj : FalseObj;
            return null;
        }

        private object OnPlayerViolation(BasePlayer player, AntiHackType type, float amount) => IsPlayerVanished(player) ? FalseObj : null;

        private object OnTeamInvite(BasePlayer inviter, BasePlayer target) => IsPlayerVanished(inviter) ? FalseObj : null;
        
        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null || !player.IsConnected)
                return;
            if(!player.IsAdmin && !HasPerm(player.UserIDString, PermUse))
                return;
            if((_config.PersistVanish && IsPlayerPersisted(player)) || _config.AutoVanish || IsPlayerPermanent(player))
                HandleEvent(player, VanishEvent.Disappear);
            if (_config.AutoNoclip)
                player.SendConsoleCommand("noclip");
        }
        
        private void OnPlayerDisconnected(BasePlayer player)
        {
            if (!_hiddenPlayers.Contains(player.userID))
                return;
            HandleEvent(player, VanishEvent.Disconnect);
        }

        #endregion

        #region GUI Indicator

        private static void VanishGui(BasePlayer player)
        {
            if (!_config.ShowIndicator)
                return;
            DestroyVanishGui(player);
            CuiHelper.AddUi(player, _cui);
        }

        private static void DestroyVanishGui(BasePlayer player)
        {
            if (!_config.ShowIndicator)
                return;
            CuiHelper.DestroyUi(player, CuiName);
        }

        #endregion

        #region Inventory Spy Logic

        private void InvSpyShowLoot(BasePlayer player, string[] args)
        {
            if (player.inventory.loot.IsLooting() || player.IsDead())
                return;
            BasePlayer target = null;
            var playerName = args != null ? string.Join(" ", args) : null;
            if (string.IsNullOrWhiteSpace(playerName))
            {
                var hits = Pool.GetList<RaycastHit>();
                GamePhysics.TraceAll(player.eyes.HeadRay(), .1f, hits, 5f, Layers.Server.Players);
                var hit = hits.FirstOrDefault(h => h.collider.gameObject != player.gameObject);
                if (hit.collider != null)
                    target = hit.transform.ToBaseEntity().ToPlayer();
                Pool.FreeList(ref hits);
            }
            else
            {
                var result = FindPlayer(playerName);
                target = result as BasePlayer;
                if (target == null && result != null)
                {
                    Player.Message(player, Lang("MultiplePlayers", player.UserIDString));
                    return;
                }
            }
            if (target == null)
            {
                Player.Message(player,
                    $"{(string.IsNullOrWhiteSpace(playerName) ? Lang("NothingInSight", player.UserIDString) : Lang("NoSuchPlayer", player.UserIDString, playerName))}.");
                return;
            }
            var proxyCorpse = InvSpyCreateProxy(player, target);
            player.inventory.loot.StartLootingEntity(proxyCorpse, false);
            player.inventory.loot.AddContainer(target.inventory.containerMain);
            player.inventory.loot.AddContainer(target.inventory.containerWear);
            player.inventory.loot.AddContainer(target.inventory.containerBelt);
            player.inventory.loot.SendImmediate();
            player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", "player_corpse");
            Player.Message(player, Lang("InvSpyLooting", player.UserIDString, GetPrettyPlayerName(target), target.UserIDString));
        }

        private static PlayerCorpse InvSpyCreateProxy(BasePlayer receiver, BasePlayer target)
        {
            var prx = (PlayerCorpse) GameManager.server.CreateEntity(PlayerCorpsePrefab, TerrainMeta.LowestPoint);
            prx.enableSaving = false;
            prx.syncPosition = false;
            prx.playerSteamID = receiver.userID;
            prx.playerName = GetPrettyPlayerName(target);
            prx.parentEnt = null;
            prx.Spawn();
            prx.InitializeHealth(float.MaxValue, float.MaxValue);
            prx.gameObject.AddComponent<LootProxyController>().Init(target, receiver);
            UnityEngine.Object.Destroy(prx.GetComponent<Buoyancy>());
            UnityEngine.Object.Destroy(prx.GetComponent<Rigidbody>());
            prx.CancelInvoke(prx.RemoveCorpse);
            prx.SetFlag(BaseEntity.Flags.Busy, true);
            SendEntitySnapshotEx(receiver, prx);
            return prx;
        }

        #endregion

        #region Logic

        private void HandleEvent(BasePlayer player, VanishEvent evt)
        {
            switch (evt)
            {
                case VanishEvent.Disappear:
                    Disappear(player);
                    if (_config.SafePoints && !HasSafePoint(player) && player.IsConnected && !player.IsSleeping()
                        && (player.IsAdmin || HasPerm(player.UserIDString, PermUse))) 
                        Player.Message(player, Lang("SafePointNotSet", player.UserIDString));
                    break;
                case VanishEvent.Reappear:
                    Reappear(player);
                    break;
                case VanishEvent.Disconnect:
                    NextTick(()=>player.SetServerFall(false));
                    if (((player.IsAdmin && _config.UndergroundTeleportDepth != 0f) || (_config.SafePoints && HasSafePoint(player)))) 
                        player.Teleport(GetSafePoint(player));
                    var vanishStay = false;
                    if (CanPersistPlayer(player))
                    {
                        AddPersistPlayer(player);
                        vanishStay = true;
                    }
                    if (IsPlayerPermanent(player))
                        vanishStay = true;
                    if (vanishStay)
                    {
                        _hiddenPlayers.Remove(player.userID);
                        player.GetComponent<VanishComponent>()?.StopNetworkGroupsUpdate();
                        NextTick(()=>player.DisablePlayerCollider());
                        ManageHooks();
                    }
                    else
                        Reappear(player);
                    break;
                case VanishEvent.Unload:
                    if (CanPersistPlayer(player)) 
                        AddPersistPlayer(player);
                    break;
            }
        }

        private static void RemoveFromTargets(BasePlayer player)
        {
            var hits = QueryGrid.Server.GetInSphere(player.GetNetworkPosition(), 64f, AIBrainSenses.queryResults,
                ent => ent is Human_Npc || ent is BaseAnimalNPC || ent is BaseFishNPC || ent is BradleyAPC);
            for (var i = 0; i < hits; i++)
            {
                var ent = AIBrainSenses.queryResults[i];
                if(ent is BradleyAPC)
                {
                    var apc = ((BradleyAPC)ent);
                    var ti = apc.targetList.FirstOrDefault(t => t.entity == player);
                    if (ti != null)
                    {
                        apc.targetList.Remove(ti);
                        Pool.Free(ref ti);
                        apc.UpdateTargetList();
                    }
                }
                else
                    RemoveFromTargets0(player, ent.GetComponent<BaseAIBrain>());
            }
        }

        private static void RemoveFromTargets0(BasePlayer player, BaseAIBrain brain)
        {
            if(brain == null)
                return;
            try
            {
                if(brain.Events != null && brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot) == player)
                    brain.Events.Memory.Entity.Remove(brain.Events.CurrentInputMemorySlot);
                brain.Senses.Memory.Players.Remove(player);
                brain.Senses.Memory.Targets.Remove(player);
                brain.Senses.Memory.Threats.Remove(player);
                brain.Senses.Memory.LOS.Remove(player);
                brain.Senses.Memory.All.RemoveAll(si => si.Entity == player);
            }
            catch (Exception e)
            {
                _instance.PrintError(
                    $"RemoveFromTargets failure ({e.GetType()})! Brain: {brain.GetType().FullName}. [E:{brain.Events != null};S:{brain.Senses != null};SM:{brain.Senses?.Memory != null}]. Please report to us!");
            }
        }

        private void ReappearAll(Action<BasePlayer> onReappear = null)
        {
            var results = _hiddenPlayers.AsEnumerable();
            if (_config.PersistVanish)
                results = results.Concat(_hiddenPlayersPersist);
            foreach (var hiddenPlayer in results.Distinct().Select(uid => FindPlayerById(uid)))
            {
                if (!hiddenPlayer)
                    continue;
                Reappear(hiddenPlayer);
                onReappear?.Invoke(hiddenPlayer);
            }
        }

        private void DisappearAll(Action<BasePlayer> onDisappear = null)
        {
            var results = BasePlayer.allPlayerList.Where(p => IsPlayerPermanent(p) && !IsPlayerVanished(p));
            if (_config.PersistVanish)
                results = results.Concat(_hiddenPlayersPersist.Select(uid=> FindPlayerById(uid)).Where(p=>p));
            foreach (var hiddenPlayer in results.Distinct())
            {
                if (!hiddenPlayer || (!hiddenPlayer.IsAdmin && !HasPerm(hiddenPlayer.UserIDString, PermUse)))
                    continue;
                Disappear(hiddenPlayer);
                onDisappear?.Invoke(hiddenPlayer);
            }
        }
        
        private void AddPersistPlayer(BasePlayer player)
        {
            if(!_hiddenPlayersPersist.Contains(player.userID))
                _hiddenPlayersPersist.Add(player.userID);
            _hiddenPlayers.Remove(player.userID);
            ManageHooks();
        }

        #endregion

        #region Helpers

        private void AddCommandAliases(string key, string command)
        {
            foreach (var language in lang.GetLanguages(this))
            {
                var messages = lang.GetMessages(language, this);
                foreach (var message in messages.Where(m => m.Key.Equals(key)))
                    AddCovalenceCommand(message.Value, command);
            }
        }

        private void SubscribeToHooks()
        {
            foreach (var hook in HooksLst)
                Subscribe(hook);
        }

        private void UnSubscribeFromHooks()
        {
            foreach (var hook in HooksLst)
                Unsubscribe(hook);
        }

        private static void SendEffectTo(string effect, BasePlayer player)
        {
            EffectInstance.Init(Effect.Type.Generic, player, 0, Vector3.up, Vector3.zero);
            EffectInstance.pooledstringid = StringPool.Get(effect);
            var nw = Net.sv.StartWrite();
            nw.PacketID(Message.Type.Effect);
            EffectInstance.WriteToStream(nw);
            nw.Send(new SendInfo(player.net.connection));
            EffectInstance.Clear();
        }

        private bool HasSafePoint(BasePlayer player) => _config.SafePoints && _safePoints.ContainsKey(player.userID);

        private Vector3 GetSafePoint(BasePlayer player)
        {
            try
            {
                if (HasSafePoint(player))
                    return Vector3Ex.Parse(_safePoints[player.userID]);
            }
            catch { }
            return new Vector3(player.transform.position.x, TerrainMeta.HeightMap.GetHeight(player.transform.position) - _config.UndergroundTeleportDepth, player.transform.position.z);
        }

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        private bool HasPerm(string id, string perm) => permission.UserHasPermission(id, perm);

        private bool IsPlayerVanished(BasePlayer player) => player != null && _hiddenPlayers.Contains(player.userID);
        
        private bool IsPlayerVanished(ulong playerId) => _hiddenPlayers.Contains(playerId);

        private bool IsPlayerPersisted(BasePlayer player) => player != null && _hiddenPlayersPersist.Contains(player.userID);

        private bool IsPlayerPermanent(BasePlayer player) => HasPerm(player.UserIDString, PermPermanent) && HasPerm(player.UserIDString, PermUse);
        
        private bool CanPersistPlayer(BasePlayer player) =>
            _config.PersistVanish && !IsPlayerPermanent(player) && (player.IsAdmin || HasPerm(player.UserIDString, PermUse));

        private static object FindPlayer(string name, bool sleeping = true)
        {
            var player = BasePlayer.Find(name) ?? BasePlayer.FindSleeping(name);
            if (player != null)
                return player;
            var list = BasePlayer.activePlayerList.ToArray();
            if (sleeping)
                list = list.Concat(BasePlayer.sleepingPlayerList.Values).ToArray();
            var result = list.Where(p =>
                p.displayName.StartsWith(name, StringComparison.InvariantCultureIgnoreCase) || p.displayName.Contains(name, CompareOptions.IgnoreCase));
            var players = result as BasePlayer[] ?? result.ToArray();
            if (players.Length == 0)
                return null;
            if (players.Length > 1)
                return players;
            return players[0];
        }
        
        private static BasePlayer FindPlayerById(ulong uid) => BasePlayer.FindByID(uid) ?? BasePlayer.FindSleeping(uid);

        private static void SendEntitySnapshotEx(BaseNetworkable receiver, BaseNetworkable ent)
        {
            if (ent == null || ent.net == null)
                return;
            ++receiver.net.connection.validate.entityUpdates;
            var saveInfo = new BaseNetworkable.SaveInfo
            {
                forConnection = receiver.net.connection,
                forDisk = false
            };
            var nw = Net.sv.StartWrite();
            nw.PacketID(Message.Type.Entities);
            nw.UInt32(receiver.net.connection.validate.entityUpdates);
            ent.ToStreamForNetwork(nw, saveInfo);
            nw.Send(new SendInfo(receiver.net.connection));
        }

        private static string GetPrettyPlayerName(BasePlayer player)
        {
            if (player.IsNpc)
                return $"*NPC* {player.ShortPrefabName}";
            else if (!player.IsConnected)
                return $"*Offline* {player.displayName}";
            else if (player.IsSleeping())
                return $"*Sleeping* {player.displayName}";
            return $"{player.displayName}";
        }
        
        private void ManageHooks()
        {
            var newState = _hiddenPlayers.Count > 0;
            if(newState == _lastHooksState)
                return;
            if(newState)
                SubscribeToHooks();
            else
                UnSubscribeFromHooks();
            _lastHooksState = newState;
        }
    
        #endregion

        #region API

        private bool _IsInvisible(BasePlayer player) => IsPlayerVanished(player);
        
        private bool _IsInvisible(IPlayer player) => IsPlayerVanished((BasePlayer)player.Object);

        private void _Disappear(BasePlayer player) => HandleEvent(player, VanishEvent.Disappear);

        private void _Reappear(BasePlayer player) => HandleEvent(player, VanishEvent.Reappear);

        #endregion

    }
}


// --- End of file: BetterVanish-1.7.4.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/DMPlayers.cs ---
// --- Original Local Path: DMPlayers.cs ---

using System.Collections.Generic;
using System;

using Rust;

namespace Oxide.Plugins
{
     [Info("DMPlayers", "ColonBlow", "1.2.3", ResourceId = 1238)]
     internal class DMPlayers : RustPlugin
     {
         private const int DamageTypeMax = (int) DamageType.LAST;
         private readonly float[] _modifiers = new float[DamageTypeMax];
         private bool _didConfigChange;

         private void Loaded() => LoadConfigValues();
         protected override void LoadDefaultConfig() => Puts("New configuration file created.");

         private void LoadConfigValues()
         {
             foreach (DamageType val in Enum.GetValues(typeof(DamageType)))
             {
                 if (val == DamageType.LAST) continue;
                 _modifiers[(int) val] = Convert.ToSingle(GetConfigValue("Player_Multipliers", val.ToString(), 1.0));
             }

             if (!_didConfigChange) return;
             Puts("Configuration file updated.");
             SaveConfig();
         }

         private object GetConfigValue(string category, string setting, object defaultValue)
         {
             var data = Config[category] as Dictionary<string, object>;
             object value;
             if (data == null)
             {
                 data = new Dictionary<string, object>();
                 Config[category] = data;
                 _didConfigChange = true;
             }

             if (data.TryGetValue(setting, out value)) return value;
             value = defaultValue;
             data[setting] = value;
             _didConfigChange = true;
             return value;
         }

         private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
         {
             if (entity as BasePlayer == null || hitInfo == null) return;
             for (var i = 0; i < DamageTypeMax; i++)
             {
                 hitInfo.damageTypes.Scale((DamageType) i, _modifiers[i]);
             }
         }
     }
}

// --- End of file: DMPlayers.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CommercialNick.cs ---
// --- Original Local Path: CommercialNick.cs ---

using Oxide.Core.Plugins;
using System.Collections.Generic;
using ConVar;
using System;
using Newtonsoft.Json;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("CommercialNick+", "Sempai#3239", "2.6.0")]
    [Description("Плагин позволяющий давать награду за приставку в нике , например название вашего сервера")]
    internal class CommercialNick : RustPlugin
    {

        private void SaveConfig(Configuration config)
        {
            Config.WriteObject(config, true);
            SaveConfig();
        }
		   		 		  						  	   		  	 	 		  	   		  	  			  	 		
        private void OnPlayerConnected(BasePlayer player)
        {
            if (!ConnectedPlayers.ContainsKey(player.userID))
            {
                ConnectedPlayers.Add(player.userID, false);
                Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("CommercialNick/PlayerInfo", ConnectedPlayers);
            }

            NextTick(() =>
            {
                NickName(player);
            });
        }
        private void Unload()
        {
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("CommercialNick/PlayerInfo", ConnectedPlayers);
        }

                private Configuration config;
		   		 		  						  	   		  	 	 		  	   		  	  			  	 		
        public class setings
        {
            [JsonProperty("Использовать выдачу баланса ?")]
            public bool GameStore;
            [JsonProperty("Бонус в виде баланса GameStores или OVH (если не нужно оставить пустым)")]
            public string GameStoreBonus;
            [JsonProperty("У вас магазин ОВХ?")]
            public bool OVHStore;
            [JsonProperty("[GameStores] ID магазина")]
            public string ShopID = "ShopID";
            [JsonProperty("[GameStores] ID сервера")]
            public string ServerID = "";
            [JsonProperty("[GameStores] Секретный ключ")]
            public string SecretKey = "SecretKey";
            [JsonProperty("Лог сообщения(Показывается в магазине после выдачи в истории. Если OVH оставить пустым)")]
            public string GameStoreMSG;
            [JsonProperty("Использовать выдачу привилегии")]
            public bool commands;
            [JsonProperty("Команда для выдачи")]
            public string commandsgo;
            [JsonProperty("Названия того что он получит от команды")]
            public string commandprize;
            [JsonProperty("Время которое нужно отыграть игроку с приставкой в нике что бы получить награду (секунды)")]
            public int timeplay;
            [JsonProperty("Разршить после вайпа получить приз заново")]
            public bool wipeclear;
        }
        
        private void OnNewSave(string filename)
        {
            if (config.seting.wipeclear)
            {
                ConnectedPlayers.Clear();
                PrintWarning("Обнаружен WIPE . Дата игроков сброшена");
            }
        }

        public void LoadConfigVars()
        {
            config = Config.ReadObject<Configuration>();
            Config.WriteObject(config, true);
        }


        
        
        public void SendChat(string Message, BasePlayer player, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            if (IQChat)
            {
                IQChat?.Call("API_ALERT_PLAYER", player, Message);
            }
            else
            {
                player.SendConsoleCommand("chat.add", channel, 0, Message);
            }
        }
        [PluginReference] private readonly Plugin IQChat;

        public class Configuration
        {
            [JsonProperty("Настройки")]
            public setings seting;
            [JsonProperty("Наградить за что то в нике:")]
            public List<string> CONF_BlockedParts;
        }

        
                private Dictionary<ulong, bool> ConnectedPlayers = new Dictionary<ulong, bool>();

        protected override void LoadDefaultConfig()
        {
            config = new Configuration()
            {
                CONF_BlockedParts = new List<string>()
                {
                    "PONYLAND",
                    "PONY LAND",
                    "pony land",
                    "ponyland",
                    "DURACHOCK",
                    "Pony Land",
                },
                seting = new setings
                {
                    GameStore = false,
                    GameStoreBonus = "",
                    OVHStore = false,
                    ServerID = "",
                    ShopID = "ShopID",
                    SecretKey = "SecretKey",
                    GameStoreMSG = "За заход после вайпа:3",
                    commands = true,
                    commandsgo = "addgroup %STEAMID% vip 3972d",
                    commandprize = "vip",
                    timeplay = 500,
                    wipeclear = true,
                },
            };
            SaveConfig(config);
        }
		   		 		  						  	   		  	 	 		  	   		  	  			  	 		
        private void OnServerSave()
        {
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("CommercialNick/PlayerInfo", ConnectedPlayers);

        }
        public void PrizeGive(ulong id)
        {
            if (ConnectedPlayers[id])
            {
                return;
            }

            BasePlayer player = BasePlayer.FindByID(id);
            if (config.seting.commands)
            {
                ConnectedPlayers[player.userID] = true;
                Server.Command(config.seting.commandsgo.Replace("%STEAMID%", player.userID.ToString()));
                LogToFile("ConnectPlayer", $" [{player.userID}] получил {config.seting.commandsgo}", this);
                SendChat($"Вы получили награду в виде {config.seting.commandprize}. Награда за приставку в нике", player);
            }
            try
            {
                if (!config.seting.OVHStore)
                {
                    string uri = $"https://gamestores.ru/api?shop_id={config.seting.ShopID}&secret={config.seting.SecretKey}&server={config.seting.ServerID}&action=moneys&type=plus&steam_id={id}&amount={config.seting.GameStoreBonus}&mess={config.seting.GameStoreMSG}";
                    webrequest.Enqueue(uri, null, (i, s) =>
                    {
                        if (i != 200)
                        {
                        }
                        if (s.Contains("success"))
                        {
                            ConnectedPlayers[id] = true;
                            LogToFile("ConnectPlayer", $" [{id}] получил {config.seting.GameStoreBonus} рублей", this);
                            SendChat($"Вы получили награду в виде {config.seting.GameStoreBonus} рублей. Награда за приставку в нике", player);
                        }
                        if (s.Contains("fail"))
                        {
                            SendChat("Вы не получили приз за приставку в ники т.к не авторизованы в магазине.", player);
                            return;
                        }
                    }, this);
                }
                else if (config.seting.OVHStore)
                {
                    plugins.Find("RustStore").CallHook("APIChangeUserBalance", id, config.seting.GameStoreBonus, new Action<string>((result) =>
                    {
                        if (result == "SUCCESS")
                        {
                            ConnectedPlayers[id] = true;
                            LogToFile("ConnectPlayer", $" [{id}] получил {config.seting.GameStoreBonus} рублей", this);
                            SendChat($"Вы получили награду в виде {config.seting.GameStoreBonus} рублей. Награда за приставку в нике", player);
                        }
                        else
                        {
                            SendChat("Вы не получили приз за приставку в ники т.к не авторизованы в магазине.", player);
                            return;
                        }
                    }));
                }
            }
            catch (Exception ex)
            {
                LogToFile(Title, ex.ToString(), this);
            }

        }
        
        private bool ContainsAny(string input, List<string> check)
        {
            foreach (string str in check)
            {
                string word = str.ToLower();
                if (input.ToLower().Contains(word))
                {
                    return true;
                }
            }
            return false;
        }
        
        private void OnServerInitialized()
        {
                        LoadConfigVars();
            
            if (Interface.Oxide.DataFileSystem.ExistsDatafile("CommercialNick/PlayerInfo"))
            {
                ConnectedPlayers = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, bool>>("CommercialNick/PlayerInfo");
            }

            for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                OnPlayerConnected(BasePlayer.activePlayerList[i]);
            }

            
            if (!string.IsNullOrEmpty(config.seting.GameStoreBonus) && !config.seting.OVHStore)
            {
                if (config.seting.ShopID == "ShopID" || config.seting.SecretKey == "SecretKey")
                {
                    PrintError("Вы не настроили ID И KEY от магазина GameStores");
                }
            }
                    }

        private void NickName(BasePlayer player)
        {
            if (!ConnectedPlayers.ContainsKey(player.userID))
            {
                OnPlayerConnected(player);
                return;
            }
            if (ContainsAny(player.displayName, config.CONF_BlockedParts) && ConnectedPlayers[player.userID] == false)
            {
                timer.Once(config.seting.timeplay, () =>
                {
                    PrizeGive(player.userID);
                });
            }
        }
            }
}


// --- End of file: CommercialNick.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TimeOfDay.cs ---
// --- Original Local Path: TimeOfDay.cs ---

//
//    The zlib/libpng License
//    ===========================
//
//    Copyright (C) 2015 Sin (sin.oxide.service@gmail.com)
//
//    This software is provided 'as-is', without any express or implied
//    warranty.  In no event will the authors be held liable for any damages
//    arising from the use of this software.
//
//    Permission is granted to anyone to use this software for any purpose,
//    including commercial applications, and to alter it and redistribute it
//    freely, subject to the following restrictions:
//
//    1. The origin of this software must not be misrepresented; you must not
//        claim that you wrote the original software. If you use this software
//        in a product, an acknowledgement in the product documentation would be
//        appreciated but is not required.
//
//    2. Altered source versions must be clearly marked as such, and must not be
//        misrepresented as being the original software.
//
//    3. This notice may not be removed or altered from any source distribution.
//
#region Using Directives
using Oxide.Core.Plugins;
using System;
using System.Text;
#endregion

namespace Oxide.Plugins
{
    /// <summary>
    /// A plugin class which provides tools for managing time. It can also alter day and night duration.
    /// </summary>
    [Info("TimeOfDay", "Sin", "1.0.1", ResourceId = 1355)]
    [Description("Provides tools for managing time. It can also alter day and night duration.")]
    public class TimeOfDay : RustPlugin
    {
        #region Fields
        /// <summary>
        /// The hour at which it is considered day.
        /// </summary>
        public float SunriseHour
        {
            get
            {
                return TOD_Sky.Instance.SunriseTime;
            }
        }

        /// <summary>
        /// The hour at which it is considered night.
        /// </summary>
        public float SunsetHour
        {
            get
            {
                return TOD_Sky.Instance.SunsetTime;
            }
        }

        /// <summary>
        /// The length of the day in  minutes.
        /// </summary>
        public uint Daylength
        {
            get;
            private set;
        }

        /// <summary>
        /// The length of the night in  minutes.
        /// </summary>
        public uint Nightlength
        {
            get;
            private set;
        }

        /// <summary>
        /// Returns true if it is currently day time.
        /// </summary>
        public bool IsDay
        {
            get
            {
                return ((TOD_Sky.Instance.Cycle.Hour > this.SunriseHour) && (TOD_Sky.Instance.Cycle.Hour < this.SunsetHour)) == true ? true : false;
            }
        }

        /// <summary>
        /// Returns true if it is currently night time.
        /// </summary>
        public bool IsNight
        {
            get
            {
                return ((TOD_Sky.Instance.Cycle.Hour > this.SunriseHour) && (TOD_Sky.Instance.Cycle.Hour < this.SunsetHour)) == true ? false : true;
            }
        }

        /// <summary>
        /// Represents the number of restarted timers which try to find the TOD_Time component.
        /// </summary>
        private uint componentSearchAttempts = 0;

        /// <summary>
        /// When found it holds a reference to the TOD_Time component.
        /// </summary>
        private TOD_Time timeComponent = null;
        #endregion

        #region Methods
        /// <summary>
        /// Called when the plugin gets loaded. We are 
        /// starting the timer for the time component fetch function.
        /// </summary>
        private void Loaded()
        {
            timer.Once(3, GetTimeComponent);
        }

        /// <summary>
        /// Called when the plugin gets loaded for the first time.
        /// We are creating the default configuration file here.
        /// </summary>
        private void LoadDefaultConfig()
        {
            this.Daylength = 30;
            this.Nightlength = 30;

            Config.Clear();

            Config["ConfigVersion"] = "1.0.0";
            
            Config["Settings", "Daylength"] = this.Daylength;
            Config["Settings", "Nightlength"] = this.Nightlength;

            SaveConfig();
        }

        /// <summary>
        /// Fetches the TOD_Time component of the GameObject. It is initialized with the conig values afterwards and loads the config values.
        /// </summary>
        private void GetTimeComponent()
        {
            if (TOD_Sky.Instance == null)
            {
                ++this.componentSearchAttempts;

                if (this.componentSearchAttempts < 10)
                {
                    Puts("Restarting timer for GetTimeComponent(). Attempt " + this.componentSearchAttempts + "/10.");
                    timer.Once(3, GetTimeComponent);
                }
                else
                {
                    RaiseError("Could not find required component after 10 attempts. Plugin will not work without it.");
                }

                return;
            }

            if (TOD_Sky.Instance != null && this.componentSearchAttempts > 0)
            {
                Puts("Found TOD_Time component after attempt " + this.componentSearchAttempts + ".");
            }

            this.timeComponent = TOD_Sky.Instance.Components.Time;

            if (this.timeComponent == null)
            {
                RaiseError("Could not fetch time component. Plugin will not work without it.");

                return;
            }

            this.Daylength = 30;
            this.Nightlength = 30;

            this.Daylength = Convert.ToUInt32(Config["Settings", "Daylength"]);
            this.Nightlength = Convert.ToUInt32(Config["Settings", "Nightlength"]);

            this.timeComponent.ProgressTime = true;
            this.timeComponent.UseTimeCurve = false;

            this.timeComponent.OnSunrise += UpdateTimeOnSunrise;
            this.timeComponent.OnSunset += UpdateTimeOnSunset;

            if (TOD_Sky.Instance.IsDay == true)
            {
                UpdateTimeOnSunrise();
            }
            else
            {
                UpdateTimeOnSunset();
            }
        }

        /// <summary>
        /// Updates the daylength on sunrise.
        /// </summary>
        private void UpdateTimeOnSunrise()
        {
            float num1 = TOD_Sky.Instance.SunsetTime - TOD_Sky.Instance.SunriseTime;
            float num2 = 24.0f / num1;
            float num3 = this.Daylength * num2;

            this.timeComponent.DayLengthInMinutes = num3;
        }

        /// <summary>
        /// Updates the daylength on sunset.
        /// </summary>
        private void UpdateTimeOnSunset()
        {
            float num1 = TOD_Sky.Instance.SunsetTime - TOD_Sky.Instance.SunriseTime;
            float num2 = 24.0f - num1;
            float num3 = 24.0f / num2;
            float num4 = this.Nightlength * num3;

            this.timeComponent.DayLengthInMinutes = num4;
        }
        #endregion

        #region Commands
        /// <summary>
        /// This function is being called when the chat command /tod has been typed in.
        /// It then goes trough a switch statement and acts accordingly.
        /// </summary>
        /// <param name="Player">The player who issued the command.</param>
        /// <param name="Command">The command which should be executed.</param>
        /// <param name="Args">The arguments supplied with ne command.</param>
        [ChatCommand("tod")]
        private void TodCommand(BasePlayer Player, string Command, string[] Args)
        {
            if (Args.Length < 1)
            {
                PrintPluginMessageToChat(Player, FormNeutralMessage("Current Time: ") + TOD_Sky.Instance.Cycle.DateTime.ToString("HH:mm:ss") + ".");

                return;
            }

            StringBuilder stringBuilder = new StringBuilder();

            switch (Args[0])
            {
                // Prints all available commands to the player's chat.
                case "help":
                    stringBuilder.Append(FormNeutralMessage("-------------------- Available Commands --------------------\n"));

                    if (CheckForPermission(Player) == true)
                    {
                        stringBuilder.Append(FormNeutralMessage("/tod") + " - Shows current Time Of Day.\n");
                        //stringBuilder.Append(FormNeutralMessage("/tod sunrise <hour>") + " - Sets the sunrise hour.\n");
                        //stringBuilder.Append(FormNeutralMessage("/tod sunset <hour>") + " - Sets the sunset hour.\n");
                        stringBuilder.Append(FormNeutralMessage("/tod set <hour>") + " - Sets the time to the given hour.\n");
                        stringBuilder.Append(FormNeutralMessage("/tod daylength <length>") + " - Sets the daylength in minutes.\n");
                        stringBuilder.Append(FormNeutralMessage("/tod nightlength <length>") + " - Sets the nightlength in minutes.\n");
                        stringBuilder.Append(FormNeutralMessage("/tod info") + " - Shows all available commands.");
                    }
                    else
                    {
                        stringBuilder.Append(FormNeutralMessage("/tod") + " - Shows current Time Of Day.\n");
                        stringBuilder.Append(FormNeutralMessage("/tod info") + " - Shows all available commands.");
                    }

                    PrintPluginMessageToChat(Player, stringBuilder.ToString());
                    break;

                // Sets the current time of the day to the given value.
                case "set":
                    if (CheckForPermission(Player) == false)
                        return;

                    if (Args.Length < 2)
                    {
                        PrintPluginMessageToChat(Player, FormErrorMessage("Could not change the time. You did not supply a number."));

                        return;
                    }

                    uint newTime = 6;

                    if (uint.TryParse(Args[1], out newTime) == true)
                    {
                        if (newTime < 0 || newTime > 24)
                        {
                            PrintPluginMessageToChat(Player, FormErrorMessage("Could not change the time to " + Args[1] + ". Number must be between 0 and 24."));

                            return;
                        }

                        TOD_Sky.Instance.Cycle.Hour = newTime;
                        Puts("The time has been set to " + TOD_Sky.Instance.Cycle.DateTime.ToString("HH:mm:ss") + ". (By Player: " + Player.displayName + ")");
                        PrintPluginMessageToChat(Player, "The time has been set to " + newTime + ".");

                        if (newTime > TOD_Sky.Instance.SunriseTime && newTime < TOD_Sky.Instance.SunsetTime)
                        {
                            UpdateTimeOnSunrise();
                        }
                        else
                        {
                            UpdateTimeOnSunset();
                        }
                    }
                    else
                    {
                        PrintPluginMessageToChat(Player, FormErrorMessage("Could not change the time to " + Args[1] + "."));
                    }
                    break;

                // Sets the sunrise hour to the given value and alters the TOD_Sky instance.
                //case "sunrise":
                //    if (CheckForPermission(Player) == false)
                //        return;

                //    if (Args.Length < 2)
                //    {
                //        PrintPluginMessageToChat(Player, FormErrorMessage("Could not change sunrise hour. You did not supply a number."));

                //        return;
                //    }

                //    uint newSunriseHour = 6;

                //    if (uint.TryParse(Args[1], out newSunriseHour) == true)
                //    {
                //        if (newSunriseHour >= this.SunsetHour)
                //        {
                //            PrintPluginMessageToChat(Player, FormErrorMessage("Could not change sunrise hour. Number must be less than the sunset hour."));

                //            return;
                //        }

                //        this.SunriseHour = newSunriseHour;
                //        Puts("The sunrise hour has been set to " + this.SunriseHour + ". (By Player: " + Player.displayName + ")");
                //        PrintPluginMessageToChat(Player, "The sunrise time has been set to " + this.SunriseHour + ".");

                //        Config["Settings", "SunriseHour"] = this.SunriseHour;
                //        SaveConfig();
                //    }
                //    else
                //    {
                //        PrintPluginMessageToChat(Player, FormErrorMessage("Could not set the sunrise hour to " + Args[1] + "."));
                //    }
                //    break;

                // Sets the sunset hour to the given value and alters the TOD_Sky instance.
                //case "sunset":
                //    if (CheckForPermission(Player) == false)
                //        return;

                //    if (Args.Length < 2)
                //    {
                //        PrintPluginMessageToChat(Player, FormErrorMessage("Could not change sunset hour. You did not supply a number."));

                //        return;
                //    }

                //    uint newSunsetHour = 6;

                //    if (uint.TryParse(Args[1], out newSunsetHour) == true)
                //    {
                //        if (newSunsetHour <= this.SunriseHour)
                //        {
                //            PrintPluginMessageToChat(Player, FormErrorMessage("Could not change sunset hour. Number must be greater than the sunrise hour."));

                //            return;
                //        }

                //        if (newSunsetHour > 24)
                //        {
                //            PrintPluginMessageToChat(Player, FormErrorMessage("Could not change sunset hour. Number must be less than or equal to 24."));

                //            return;
                //        }

                //        this.SunsetHour = newSunsetHour;
                //        Puts("The sunset hour has been set to " + this.SunsetHour + ". (By Player: " + Player.displayName + ")");
                //        PrintPluginMessageToChat(Player, "The sunset time has been set to " + this.SunsetHour + ".");

                //        Config["Settings", "SunsetHour"] = this.SunsetHour;
                //        SaveConfig();
                //    }
                //    else
                //    {
                //        PrintPluginMessageToChat(Player, FormErrorMessage("Could not set the sunset hour to " + Args[1] + "."));
                //    }
                //    break;

                // Sets the daylength to the given value and alters the TOD_Sky instance.
                case "daylength":
                    if (CheckForPermission(Player) == false)
                        return;

                    if (Args.Length < 2)
                    {
                        PrintPluginMessageToChat(Player, FormErrorMessage("Incorrect syntax!") + "\n/tod daylength <length>");

                        return;
                    }

                    uint newDaylength = 30;

                    if (uint.TryParse(Args[1], out newDaylength) == true)
                    {
                        if (newDaylength <= 0)
                        {
                            PrintPluginMessageToChat(Player, FormErrorMessage("Could not change daylength. Length must be greater than 0."));

                            return;
                        }

                        this.Daylength = newDaylength;
                        Puts("The daylength has been set to " + this.Daylength + ". (By Player: " + Player.displayName + ")");
                        PrintPluginMessageToChat(Player, "The daylength has been set to " + this.Daylength + ".");

                        if (TOD_Sky.Instance.IsDay == true)
                        {
                            UpdateTimeOnSunrise();
                        }
                        else
                        {
                            UpdateTimeOnSunset();
                        }

                        Config["Settings", "Daylength"] = this.Daylength;
                        SaveConfig();
                    }
                    else
                    {
                        PrintPluginMessageToChat(Player, FormErrorMessage("Could not set the daylength to " + Args[1] + "."));
                    }
                    break;

                // Sets the nightlength to the given value and alters the TOD_Sky instance.
                case "nightlength":
                    if (CheckForPermission(Player) == false)
                        return;

                    if (Args.Length < 2)
                    {
                        PrintPluginMessageToChat(Player, FormErrorMessage("Incorrect syntax!") + "\n/tod nightlength <length>");

                        return;
                    }

                    uint newNightlength = 30;

                    if (uint.TryParse(Args[1], out newNightlength) == true)
                    {
                        if (newNightlength <= 0)
                        {
                            PrintPluginMessageToChat(Player, FormErrorMessage("Could not change nightlength. Length must be greater than 0."));

                            return;
                        }

                        this.Nightlength = newNightlength;
                        Puts("The nightlength has been set to " + this.Nightlength + ". (By Player: " + Player.displayName + ")");
                        PrintPluginMessageToChat(Player, "The nightlength has been set to " + this.Nightlength + ".");

                        if (TOD_Sky.Instance.IsDay == true)
                        {
                            UpdateTimeOnSunrise();
                        }
                        else
                        {
                            UpdateTimeOnSunset();
                        }

                        Config["Settings", "Nightlength"] = this.Nightlength;
                        SaveConfig();
                    }
                    else
                    {
                        PrintPluginMessageToChat(Player, FormErrorMessage("Could not set the nightlength to " + Args[1] + "."));
                    }
                    break;

                // Display the current settings of the plugin to the player's chat.
                case "info":
                    stringBuilder.Append(FormNeutralMessage("-------- Settings --------\n"));
                    stringBuilder.Append(FormNeutralMessage("Current Time") + ":\t" + TOD_Sky.Instance.Cycle.DateTime.ToString("HH:mm:ss") + "\n");
                    stringBuilder.Append(FormNeutralMessage("Sunrise Hour") + ":\t" + TOD_Sky.Instance.SunriseTime.ToString("0.0") + "\n");
                    stringBuilder.Append(FormNeutralMessage("Sunset Hour") + ":\t" + TOD_Sky.Instance.SunsetTime.ToString("0.0") + "\n");
                    stringBuilder.Append(FormNeutralMessage("Daylength") + ":\t\t" + this.Daylength.ToString() + " minutes\n");
                    stringBuilder.Append(FormNeutralMessage("Nightlength") + ":\t\t" + this.Nightlength.ToString() + " minutes");

                    PrintPluginMessageToChat(Player, stringBuilder.ToString());
                    break;

                // No command has been found. Print an error message.
                default:
                    stringBuilder.Append(FormErrorMessage("This command does not exist.") + " (Command: " + Args[0] + ")\n");
                    stringBuilder.Append("Type /tod help for a list of availbale commands.");

                    PrintPluginMessageToChat(Player, stringBuilder.ToString());
                    break;
            }
        }

        /// <summary>
        /// Hook for the HelpText plugin. (ResourceID: 676)
        /// It will display help information when typing /help
        /// </summary>
        /// <param name="Player">The player who called for help.</param>
        [HookMethod("SendHelpText")]
        private void SendHelpText(BasePlayer Player)
        {
            StringBuilder stringBuilder = new StringBuilder();

            stringBuilder.Append(FormNeutralMessage("-------------------- Available Commands --------------------\n"));

            if (CheckForPermission(Player) == true)
            {
                stringBuilder.Append(FormNeutralMessage("/tod") + " - Shows current Time Of Day.\n");
                //stringBuilder.Append(FormNeutralMessage("/tod sunrise <hour>") + " - Sets the sunrise hour.\n");
                //stringBuilder.Append(FormNeutralMessage("/tod sunset <hour>") + " - Sets the sunset hour.\n");
                stringBuilder.Append(FormNeutralMessage("/tod set <hour>") + " - Sets the time to the given hour.\n");
                stringBuilder.Append(FormNeutralMessage("/tod daylength <length>") + " - Sets the daylength in minutes.\n");
                stringBuilder.Append(FormNeutralMessage("/tod nightlength <length>") + " - Sets the nightlength in minutes.\n");
                stringBuilder.Append(FormNeutralMessage("/tod info") + " - Shows all available commands.");
            }
            else
            {
                stringBuilder.Append(FormNeutralMessage("/tod") + " - Shows current Time Of Day.\n");
                stringBuilder.Append(FormNeutralMessage("/tod info") + " - Shows all available commands.");
            }

            PrintPluginMessageToChat(Player, stringBuilder.ToString());
        }

        /// <summary>
        /// Helper function for printing a message to specified player's chat with additional plugin information.
        /// </summary>
        /// <param name="Player">The target player.</param>
        /// <param name="Message">The message to send.</param>
        private void PrintPluginMessageToChat(BasePlayer Player, string Message)
        {
            PrintToChat(Player, "<b><size=16>[<color=#ffa500ff>" + this.Name + "</color>] [<color=#ffa500ff>" + this.Version.ToString() + "</color>]</size></b>\n" + Message);
        }

        /// <summary>
        /// Helper function for printing a message to the chat with additional plugin information.
        /// </summary>
        /// <param name="Message">The message to send.</param>
        private void PrintPluginMessageToChat(string Message)
        {
            PrintToChat("<b><size=16>[<color=#ffa500ff>" + this.Name + "</color>] [<color=#ffa500ff>" + this.Version.ToString() + "</color>]</size></b>\n" + Message);
        }

        /// <summary>
        /// Helper function for coloring neutral messages.
        /// </summary>
        /// <param name="Message">The message to alter.</param>
        /// <returns>The message with the neutral color code.</returns>
        private string FormNeutralMessage(string Message)
        {
            return "<color=#c0c0c0ff>" + Message + "</color>";
        }

        /// <summary>
        /// Helper function for coloring warning messages.
        /// </summary>
        /// <param name="Message">The message to alter.</param>
        /// <returns>The message with the warning color code.</returns>
        private string FormWarningMessage(string Message)
        {
            return "<color=#ffff00ff>" + Message + "</color>";
        }

        /// <summary>
        /// Helper function for coloring error messages.
        /// </summary>
        /// <param name="Message">The message to alter.</param>
        /// <returns>The message with the error color code.</returns>
        private string FormErrorMessage(string Message)
        {
            return "<color=#ff0000ff>" + Message + "</color>";
        }

        /// <summary>
        /// Checks if a player is considered admin on the server.
        /// </summary>
        /// <param name="Player">The player to check.</param>
        /// <returns>True if the authentication level is above one. (Admin)</returns>
        private bool CheckForPermission(BasePlayer Player)
        {
            if (Player.net.connection.authLevel > 1)
            {
                return true;
            }

            return false;
        }
        #endregion
    }
}


// --- End of file: TimeOfDay.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CustomDropChanger.cs ---
// --- Original Local Path: CustomDropChanger.cs ---

﻿using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;

namespace Oxide.Plugins {
	[Info("CustomDropChanger", "Server-Rust.ru", "1.1.4")]
	[Description("Позволяет добавить лут во все ящики, скачано с Server-Rust.ru")]
	class CustomDropChanger : RustPlugin {
		#region Поля

		private List<string> containerNames = new List<string> {
			"crate_basic",
			"crate_elite",
			"crate_mine",
			"crate_tools",
			"crate_normal",
			"crate_normal_2",
			"crate_normal_2_food",
			"crate_normal_2_medical",
			"crate_underwater_advanced",
			"crate_underwater_basic",
			"foodbox",
			"loot_barrel_1",
			"loot_barrel_2",
			"loot-barrel-1",
			"loot-barrel-2",
			"loot_trash",
			"minecart",
			"bradley_crate",
			"oil_barrel",
			"heli_crate",
			"codelockedhackablecrate",
			"supply_drop",
			"trash-pile-1"
		};

		private Dictionary<uint, int> conditionPendingList = new Dictionary<uint, int>();
		private Dictionary<ItemContainer, List<Item>> spawnedLoot = new Dictionary<ItemContainer, List<Item>>();
		private List<LootContainer> affectedContainers = new List<LootContainer>();
		private bool isReady = false;

		#endregion

		#region Конфиг

		private NewDropItemConfig config;

		private class ItemDropConfig {
			[JsonProperty("Название предмета (ShortName)")]
			public string ItemShortName;

			[JsonProperty("Минимальное количество предмета")]
			public int MinCount;

			[JsonProperty("Максимальное количество предмета")]
			public int MaxCount;

			[JsonProperty("Шанс выпадения предмета (0 - отключить)")]
			public int Chance;

			[JsonProperty("Это чертеж?")] public bool IsBluePrint;

			[JsonProperty("Имя предмета (оставьте пустым для стандартного)")]
			public string Name;

			[JsonProperty("Описание предмета (оставьте пустым для стандартного)")]
			public string Description;

			[JsonProperty("ID Скина (0 - стандартный)")]
			public ulong Skin;

			[JsonProperty("Целостность предмета в % от 1 до 100 (0 - стандартная)")]
			public int Condition;
		}

		private class NewDropItemConfig {
			[JsonProperty("Добавляем лут в ученых?")]
			public bool EnableScientistLoot { get; set; }

			[JsonProperty("Оставить стандартный лут в контейнерах и ученых?")]
			public bool EnableStandartLoot { get; set; }

			[JsonProperty("Список лута ученых:")]
			public List<ItemDropConfig> ScientistLootSettings { get; set; }

			[JsonProperty("Настройка контейнеров:")]
			public Dictionary<string, List<ItemDropConfig>> ChestSettings { get; set; }
		}

		protected override void LoadDefaultConfig() {
			var chestSettings = new Dictionary<string, List<ItemDropConfig>>();

			foreach (var container in containerNames) {
				chestSettings.Add(container,
					new List<ItemDropConfig> {
						new ItemDropConfig {
								MinCount = 1,
								MaxCount = 2,
								Chance = 40,
								ItemShortName = "researchpaper",
								IsBluePrint = false,
								Name = "",
								Description = "",
								Skin = 0,
								Condition = 0
							}
					});
			}

			config = new NewDropItemConfig {
				EnableScientistLoot = true,
				EnableStandartLoot  = true,
				ScientistLootSettings = new List<ItemDropConfig> {
					new ItemDropConfig {
								MinCount = 1,
								MaxCount = 2,
								Chance = 40,
								ItemShortName = "researchpaper",
								IsBluePrint = false,
								Name = "",
								Description = "",
								Skin = 0,
								Condition = 0
							}
				},
				ChestSettings = chestSettings
			};
			SaveConfig();
			PrintWarning("Creating default config");
		}

		protected override void LoadConfig() {
			base.LoadConfig();

			config = Config.ReadObject<NewDropItemConfig>();
		}

		protected override void SaveConfig() => Config.WriteObject(config);

		#endregion

		#region Загрузка и выгрузка

		private void Loaded() {
			var containers = UnityEngine.Object.FindObjectsOfType<LootContainer>();
			var count      = 0;

			foreach (var container in containers) {
				ProcessContainer(container);
				count++;
			}

			isReady = true;
			PrintWarning(
				$"Обновлено {count} контейнеров. Спасибо за приобретение плагина на https://DarkPlugins.ru. Использование с других сайтов, не гарантирует корректную работу");
		}

		void Unload() {
			foreach (var row in spawnedLoot)
			foreach (var loot in row.Value) {
				row.Key.Remove(loot);
			}

			foreach (var container in affectedContainers) {
				container.SpawnLoot();
			}
		}

		#endregion

		#region Логика

		private List<ItemDropConfig> GetItemListByChest(string chestname) {
			if (!config.ChestSettings.ContainsKey(chestname)) {
				PrintWarning($"Ящик с именем '{chestname}' не найден в конфиге!");
				return new List<ItemDropConfig>();
			}

			return config.ChestSettings[chestname];
		}

		private void AddToContainer(ItemDropConfig item, ItemContainer container) {
			var amount  = UnityEngine.Random.Range(item.MinCount, item.MaxCount);
			var newItem = item.IsBluePrint ? ItemManager.CreateByName("blueprintbase") : ItemManager.CreateByName(item.ItemShortName, amount, item.Skin);

			if (newItem == null) {
				PrintError($"Предмет {item.ItemShortName} не найден!");
				return;
			}

			if (item.IsBluePrint) {
				var bpItemDef = ItemManager.FindItemDefinition(item.ItemShortName);

				if (bpItemDef == null) {
					PrintError($"Предмет {item.ItemShortName} для создания чертежа не найден!");
					return;
				}

				newItem.blueprintTarget = bpItemDef.itemid;
			}

			if (!item.IsBluePrint && item.Condition != 0) {
				conditionPendingList.Add(newItem.uid, item.Condition);
			}

			if (item.Name != "") newItem.name = item.Name;
			if (item.Description != "") newItem.name += "\n <size=20>"+item.Description+"</size>";

			if (!spawnedLoot.ContainsKey(container)) spawnedLoot.Add(container, new List<Item>());
			spawnedLoot[container].Add(newItem);

			newItem.MoveToContainer(container);
		}

		private void ProcessScientist(ItemContainer container) {
			if (!config.EnableScientistLoot) return;

			if (!config.EnableStandartLoot) {
				container.Clear();
				var flag = 193;
				ItemManager.DoRemoves();
			}

			foreach (var item in config.ScientistLootSettings) {
				if (UnityEngine.Random.Range(1, 100) > item.Chance) continue;

				AddToContainer(item, container);
			} 
		}

		private void ProcessContainer(LootContainer container) {
			NextTick(() => {
				if (container == null || container.inventory == null) return;

				if (!config.EnableStandartLoot) {
					if (!affectedContainers.Contains(container)) affectedContainers.Add(container);
					container.inventory.itemList.Clear();
					ItemManager.DoRemoves();
				}

				foreach (var item in GetItemListByChest(container.ShortPrefabName)) {
					if (UnityEngine.Random.Range(1, 100) > item.Chance) continue;

					AddToContainer(item, container.inventory);
				}
			});
		}

		#endregion

		


		
		
		

		#region Хуки Oxide

		private void OnLootSpawn(LootContainer lootContainer) {
			if (!isReady) return;

			//if (!containerNames.Any(f => f == lootContainer.ShortPrefabName)) return;
			ProcessContainer(lootContainer);
		}

		private void OnEntitySpawned(BaseNetworkable entity) {
			NextTick(() => {
				if (entity == null || !(entity is NPCPlayerCorpse)) return;

				var npc = entity as NPCPlayerCorpse;
				var inv = npc.containers[0];

				ProcessScientist(inv);
			});
		}

		void OnItemAddedToContainer(ItemContainer container, Item item) {
			NextTick(() => {
				if (item == null) return;
				if (!conditionPendingList.ContainsKey(item.uid)) return;

				item.condition = item.info.condition.max / 100 * conditionPendingList[item.uid];

				conditionPendingList.Remove(item.uid);
			});
		}

		#endregion
	}
}


// --- End of file: CustomDropChanger.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RustLax.cs ---
// --- Original Local Path: RustLax.cs ---

using System.Linq;
using UnityEngine;
using Newtonsoft.Json;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Rust Lax", "Colon Blow", "1.0.3")]
    [Description("Control when Horses drop dung in minutes")]

    public class RustLax : CovalencePlugin
    {

        #region Load

        private const string permAdmin = "rustlax.admin";
        private const string permMounted = "rustlax.mounted";

        private void Init()
        {
            permission.RegisterPermission(permAdmin, this);
            permission.RegisterPermission(permMounted, this);
            config = Config.ReadObject<PluginConfig>();
        }

        private void OnServerInitialized()
        {
            ProcessExistingAnimals(config.dungTimeGlobal);
        }

        #endregion

        #region Configuration

        private PluginConfig config;

        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Dung Time - Number of Minutes between dung drops : ")] public float dungTimeGlobal { get; set; }
            [JsonProperty(PropertyName = "Dung Time Mounted - Mounted players with rustlax.mounted perms, will change dung drop time to (Minutes) : ")] public float dungTimeMounted { get; set; }
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                dungTimeGlobal = 15f,
                dungTimeMounted = 1f
            };
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private void SaveConfig()
        {
            Config.WriteObject(config, true);
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["notallowed"] = "You are not authorized to do that.",
                ["resettxt"] = "All dung droppings have been reset to Rust Defualts"
            }, this);
        }

        #endregion

        #region Commands

        [Command("rustlax.reset")]
        private void cmdRustLaxReset(IPlayer player, string command, string[] args)
        {
            if (player.HasPermission(permAdmin))
            {
                ProcessExistingAnimals(600f);
                player.Message(lang.GetMessage("resettxt", this, player.Id));
                return;
            }
            player.Message(lang.GetMessage("notallowed", this, player.Id));
        }

        #endregion

        #region Hooks

        private void OnEntitySpawned(BaseRidableAnimal animal)
        {
            ProcessAnimal(animal, config.dungTimeGlobal);
        }

        private void OnEntityMounted(BaseMountable entity, BasePlayer player)
        {
            var animal = entity.GetComponentInParent<BaseRidableAnimal>() ?? null;
            if (animal != null && permission.UserHasPermission(player.UserIDString, permMounted)) ProcessAnimal(animal, config.dungTimeMounted);
        }

        private void OnEntityDismounted(BaseMountable entity, BasePlayer player)
        {
            var animal = entity.GetComponentInParent<BaseRidableAnimal>() ?? null;
            if (animal != null && permission.UserHasPermission(player.UserIDString, permMounted)) ProcessAnimal(animal, config.dungTimeGlobal);
        }

        private void ProcessExistingAnimals(float dungAdjustment)
        {
            var animalList = BaseNetworkable.serverEntities.OfType<BaseRidableAnimal>();
            foreach (var ridableAnimal in animalList)
            {
                ProcessAnimal(ridableAnimal, dungAdjustment);
            }
        }

        private void ProcessAnimal(BaseRidableAnimal animal, float dungAdjustment)
        {
            animal.DungProducedPerCalorie = (0.6f / dungAdjustment);
        }

        #endregion
    }
}


// --- End of file: RustLax.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RaidProtector.cs ---
// --- Original Local Path: RaidProtector.cs ---

using System;
using Oxide.Core.Plugins;
using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Game.Rust.Libraries;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("RaidProtector", "Vlad-00003", "1.0.0")]
    [Description("Decrese damage based on permissions, time and online state of the owner.")]
	 /*
	 * Author info:
	 *   E-mail: Vlad-00003@mail.ru
	 *   Vk: vk.com/vlad_00003
	 */
    class RaidProtector : RustPlugin
    {
        #region Vars
        private PluginConfig config;
        private Dictionary<BasePlayer, Timer> Informed = new Dictionary<BasePlayer, Timer>();
        #endregion

        #region Config 
        private class TimeConfig
        {
            [JsonProperty("Использовать защиту в указанный промежуток времени")]
            public bool UseTime;
            [JsonProperty("Час начала защиты")]
            public int Start;
            [JsonProperty("Час снятия защиты")]
            public int End;
        }
        private class PermisssionConfig
        {
            [JsonProperty("Множитель урона по постройкам")]
            public float modifier;
            [JsonProperty("Настройка времени")]
            public TimeConfig timeConfig;
            [JsonProperty("Защищать постройки когда игрок вне сети")]
            public bool Offline;
        }
        private class ProtectionSetup
        {
            [JsonProperty("Чат-команда для получения короткого имени префаба предмета, на который вы смотрите")]
            public string ChatCommand;
            [JsonProperty("Защищать строительные блоки(Стены, фундаменты, каркасы...)")]
            public bool BuildingBlock;
            [JsonProperty("Защищать двери(обычные, двойные, высокие)")]
            public bool Door;
            [JsonProperty("Защищать простые строительные блоки(высокие стены)")]
            public bool SimpleBuildingBlock;
            [JsonProperty("Список префабов, которые необходимо защищать(короткое или полное имя префаба)")]
            public List<string> Prefabs;
        }
        private class PluginConfig
        {
            [JsonProperty("Настройка привилегий")]
            public Dictionary<string, PermisssionConfig> Custom;
            [JsonProperty("Стандартные настройки для всех игроков")]
            public PermisssionConfig Default;
            [JsonProperty("Настройки защиты")]
            public ProtectionSetup Protection;
            [JsonProperty("Формат сообщений в чате")]
            public string ChatFormat;
            [JsonProperty("Задержка между сообщениями в чат о блокировке")]
            public float MessageCooldown;
            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    ChatFormat = "<color=#f4c842>[RaidProtector]</color> <color=#969696>{0}</color>",
                    MessageCooldown = 15f,
                    Default = new PermisssionConfig()
                    {
                        modifier = 0.7f,
                        Offline = false,
                        timeConfig = new TimeConfig()
                        {
                            UseTime = true,
                            Start = 23,
                            End = 10
                        }
                    },
                    Custom = new Dictionary<string, PermisssionConfig>()
                    {
                        ["raidprotector.pro"] = new PermisssionConfig()
                        {
                            modifier = 0.5f,
                            Offline = false,
                            timeConfig = new TimeConfig()
                            {
                                UseTime = true,
                                Start = 20,
                                End = 12
                            }
                        },
                        ["raidprotector.vip"] = new PermisssionConfig()
                        {
                            modifier = 0.3f,
                            Offline = true,
                            timeConfig = new TimeConfig()
                            {
                                UseTime = false,
                                Start = 23,
                                End = 10
                            }
                        }
                    },
                    Protection = new ProtectionSetup()
                    {
                        ChatCommand = "/shortname",
                        BuildingBlock = true,
                        Door = true,
                        SimpleBuildingBlock = true,
                        Prefabs = new List<string>()
                        {
                            "mining_quarry",
                            "vendingmachine.deployed",
                            "furnace.large",
                            "cupboard.tool.deployed",
                            "refinery_small_deployed"
                        }
                    }
                };
            }
        }
        #endregion

        #region Config initialization
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Благодарим за приобритение плагина на сайте RustPlugin.ru. Если вы приобрели этот плагин на другом ресурсе знайте - это лишает вас гарантированных обновлений!");
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            foreach (var priv in config.Custom.Keys)
            {
                permission.RegisterPermission(priv, this);
            }
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
        #endregion

        #region Localization
        private void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                ["Protected"] = "This building <color=#770000>is protected</color>  and will recive only <color=#777700>{0}%</color> of damage",
                ["Protected anti"] = "Damage for this building <color=#007700>is increased</color> to <color=#777700>{0}%</color>",
                ["Name found"] = "Shortname for entity \"{0}\"",
                ["No item found"] = "No entity can be found in front of you!"
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                ["Protected"] = "Эта постройка <color=#770000>защищена</color> и будет получать только <color=#777700>{0}%</color> от урона",
                ["Protected anti"] = "Урон по данной постройке <color=#007700>увеличен</color> на <color=#777700>{0}%</color>",
                ["Name found"] = "Короткое имя предмета \"{0}\"",
                ["No item found"] = "Перед вам не обнаружено предмета!"
            }, this, "ru");
        }
        private string GetMsg(string key, BasePlayer player) => lang.GetMessage(key, this, player == null ? null : player.UserIDString);
        #endregion

        #region Chat commands
        private void GetShortName(BasePlayer player, string command, string[] args)
        {
            RaycastHit RayHit;
            bool flag1 = Physics.Raycast(player.eyes.HeadRay(), out RayHit, 100);
            var TargetEntity = flag1 ? RayHit.GetEntity() : null;
            if (TargetEntity)
            {
                string message = string.Format(GetMsg("Name found", player), TargetEntity.ShortPrefabName);
                player.ChatMessage(message);
                player.ConsoleMessage(message);
                return;
            }
            player.ChatMessage(GetMsg("No item found", player));
        }
        #endregion

        #region Oxide Hooks
        void Loaded()
        {
            LoadMessages();
            var command = Interface.Oxide.GetLibrary<Command>();
            command.AddChatCommand(config.Protection.ChatCommand.Replace("/", string.Empty), this, GetShortName);
        }
        void Unloaded()
        {
            var timers = Informed.Select(p => p.Value).ToArray();
            Informed.Clear();
            foreach(var t in timers)
            {
                t?.Destroy(); 
            }
        }
        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (hitInfo.damageTypes.Has(Rust.DamageType.Decay)) return;
            if (CheckEntity(entity, hitInfo))
            {
                var perm = GetPerm(entity.OwnerID);
                if (perm.modifier == 1f) return;
                if(CheckTime(perm) || CheckOffline(entity.OwnerID, perm))
                {
                    var dec = perm.modifier < 1 ? true : false;
                    if (hitInfo.InitiatorPlayer)
                    {
                        hitInfo.damageTypes.ScaleAll(perm.modifier);
                        if (Informed.ContainsKey(hitInfo.InitiatorPlayer)) return;
                        if (dec)
                        {
                            Reply(hitInfo.InitiatorPlayer, "Protected", perm.modifier * 100f);
                        }
                        else
                        {
                            Reply(hitInfo.InitiatorPlayer, "Protected anti", (perm.modifier - 1f) * 100f);
                        }
                        Informed.Add(hitInfo.InitiatorPlayer, timer.Once(config.MessageCooldown, () =>
                        {
                            Informed.Remove(hitInfo.InitiatorPlayer);
                        }));
                        return;
                    }
                    if(hitInfo.Initiator?.name == "assets/bundled/prefabs/fireball_small.prefab")
                    {
                        hitInfo.damageTypes.ScaleAll(perm.modifier);
                    }
                }
            }
        }
        #endregion

        #region Helpers
        private void Reply(BasePlayer player, string langkey, params object[] args)
        {
            SendReply(player, string.Format(config.ChatFormat, GetMsg(langkey, player)), args);
        }
        private bool CheckEntity(BaseCombatEntity ent, HitInfo info)
        {
            if (ent.OwnerID == 0)
                return false;
            if (ent.OwnerID == info.InitiatorPlayer?.userID)
                return false;
            if (ent is BuildingBlock && config.Protection.BuildingBlock)
                return true;
            if (ent is Door && config.Protection.Door)
                return true;
            if (ent is SimpleBuildingBlock && config.Protection.SimpleBuildingBlock)
                return true;
            if (config.Protection.Prefabs.Contains(ent.ShortPrefabName))
                return true;
            return false;
        }
        private bool CheckTime(PermisssionConfig perm)
        {
            TimeConfig time = perm.timeConfig;
            if (!time.UseTime) return false;
            var Now = DateTime.Now.TimeOfDay;
            var Start = new TimeSpan(time.Start, 0, 0);
            var End = new TimeSpan(time.End, 0, 0);
            if (Start < End)
                return Start <= Now && Now <= End;
            return !(End < Now && Now < Start);
        }
        private bool CheckOffline(ulong UserID, PermisssionConfig perm)
        {
            if (!perm.Offline) return false;
            if (!BasePlayer.FindByID(UserID)) return true;
            return false;
        }
        private PermisssionConfig GetPerm(ulong userID)
        {
            var perms = config.Custom.Where(p => permission.UserHasPermission(userID.ToString(), p.Key)).Select(p => p.Value);
            return perms.Count() > 0 ? perms.Aggregate((i1, i2) => i1.modifier < i2.modifier ? i1 : i2) : config.Default;
        }
        #endregion
    }
}

// --- End of file: RaidProtector.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RustTanic-2.0.10.cs ---
// --- Original Local Path: RustTanic-2.0.10.cs ---

﻿using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Ext.ChaosNPC;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine;

using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("RustTanic", "k1lly0u", "2.0.10")]
    class RustTanic : RustPlugin, IChaosNPCPlugin
    {
        #region Fields
        private static RustTanic Instance;

        private static RaycastHit RaycastHit;

        private const string HELI_EXPLOSION = "assets/prefabs/npc/patrol helicopter/effects/heli_explosion.prefab";
        private const string C4_EXPLOSION = "assets/prefabs/tools/c4/effects/c4_explosion.prefab";
               
        private const string FLOATING_CRATE_PREFAB = "assets/bundled/prefabs/radtown/crate_underwater_advanced.prefab";

        private const string ICEBERG_NAME = "iceberg";

        private const string PERMISSION_ADMIN = "rusttanic.admin";
        #endregion

        #region Oxide Hooks  
        private void OnServerInitialized()
        {
            Instance = this;

            permission.RegisterPermission(PERMISSION_ADMIN, this);

            WorldSize = Mathf.Clamp(TerrainMeta.Size.x * 1.5f, 1000f, 6000f);
            BottomLeft = new Vector3(-WorldSize, 0f, -WorldSize) * 0.5f;
            TopLeft = new Vector3(-WorldSize, 0f, WorldSize) * 0.5f;
            BottomRight = new Vector3(WorldSize, 0f, -WorldSize) * 0.5f;
            TopRight = new Vector3(WorldSize, 0f, WorldSize) * 0.5f;

            Iceberg.FindAll();  
            
            if (!Iceberg.IsValid)
            {
                Debug.LogError($"[RustTanic] - No valid icebergs were found on the map. Unable to run this event");
                return;
            }

            AutomationCycle();
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Notification.Spawned"] = "A <color=#ce422b>hijacked cargo ship</color> has been spotted off the coast and is on a collision course with an iceberg\n<color=#ce422b>ETA ~ {0}s</color>",
                ["Notification.Collided"] = "The <color=#ce422b>hijacked cargo ship</color> has collided with an icerberg and is sinking!\nGet to the crash site at <color=#ce422b>{0}</color> to secure the loot",
            }, this);
        }

        private void OnEntityEnter(TriggerParent triggerParent, BasePlayer player)
        {
            Titanic titanic = triggerParent?.GetComponentInParent<Titanic>();
            if (titanic != null && player != null)
                player.PauseFlyHackDetection(1.1f);
        }

        private void Unload()
        {
            Titanic[] t = UnityEngine.Object.FindObjectsOfType<Titanic>();
            for (int i = 0; i < t.Length; i++)
            {
                Titanic titanic = t[i];
                if (titanic && !titanic.IsDestroyed)
                    titanic.Kill(BaseNetworkable.DestroyMode.None);
            }
            
            Instance = null;
            Configuration = null;
        }
        #endregion

        #region Spawning
        private void AutomationCycle()
        {
            if (!Configuration.Automation.Enabled)
                return;

            timer.In(Mathf.Max(Configuration.Automation.RandomTime, 60), () =>
            {
                if (BasePlayer.activePlayerList.Count >= Configuration.Automation.RequiredPlayers)
                {
                    string failReason = null;

                    for (int i = 0; i < 3; i++)
                    {
                        if (SpawnCargoShip(Vector3.zero, out failReason))
                            goto TRIGGER_NEXT_CYCLE;
                    }

                    if (!string.IsNullOrEmpty(failReason))
                    {
                        Debug.Log($"[RustTanic] - Failed to run automated event : {failReason}");
                    }
                }

                TRIGGER_NEXT_CYCLE:
                AutomationCycle();
            });
        }

        private bool SpawnCargoShip(Vector3 nearestTo, out string failReason)
        {
            Iceberg iceberg = nearestTo == Vector3.zero ? Iceberg.GetRandom() : Iceberg.FindClosestIceberg(nearestTo);

            if (iceberg == null)
            {
                failReason = "Failed to find a iceberg that meets requirements";
                return false;
            }

            if (CalculateSpawnPosition2D(iceberg, out Vector3 intersection))
            {                
                Vector3 destination = iceberg.Transform.position.XZ3D();

                int attempts = 0;

                RECAST_RAY:
                if (Physics.Raycast(intersection, (destination - intersection).normalized, out RaycastHit, Vector3.Distance(destination, intersection), 1 << 23 | 1 << 29, QueryTriggerInteraction.Collide))
                {     
                    intersection = RotateAroundPoint(intersection, destination, 10f);
                    attempts++;

                    if (attempts > 3)
                    {
                        failReason = RaycastHit.collider is TerrainCollider ? "Terrain is blocking the path" : "Failed to get a clear path to the selected iceberg";
                        return false;
                    }

                    goto RECAST_RAY;
                }

                SpawnCargoShip(intersection, iceberg);

                failReason = string.Empty;
                return true;
            }

            failReason = "Failed to calculate an appropriate spawn position";
            return false;
        }

        private void SpawnCargoShip(Vector3 spawnPosition, Iceberg iceberg)
        {
            const string CARGOSHIP_PREFAB = "assets/content/vehicles/boats/cargoship/cargoshiptest.prefab";

            Debug.Log(spawnPosition);
            CargoShip cargoShip = GameManager.server.CreateEntity(CARGOSHIP_PREFAB, spawnPosition, Quaternion.identity) as CargoShip;

            Titanic titanic = cargoShip.gameObject.AddComponent<Titanic>();
            titanic.Iceberg = iceberg;

            CopySerializeableFields<CargoShip>(cargoShip, titanic);
            
            titanic.enableSaving = false;

            UnityEngine.Object.DestroyImmediate(cargoShip, true);

            titanic.Spawn();
        }

        private static void CopySerializeableFields<T>(T src, T dst)
        {
            FieldInfo[] srcFields = typeof(T).GetFields(BindingFlags.Public | BindingFlags.Instance);

            foreach (FieldInfo field in srcFields)
            {
                object value = field.GetValue(src);
                field.SetValue(dst, value);
            }
        }
        #endregion

        #region CustomNPC
        public bool InitializeStates(BaseAIBrain customNPCBrain) => false;

        public bool WantsToPopulateLoot(CustomScientistNPC customNpc, NPCPlayerCorpse npcplayerCorpse) => false;
        
        public byte[] GetCustomDesign() => null;
        #endregion

        #region Helpers
        private Vector3 RotateAroundPoint(Vector3 point, Vector3 origin, float degrees) => Quaternion.Euler(Vector3.up * degrees) * (point - origin) + origin;

        private static Quaternion RandomUpRotation() => Quaternion.Euler(0f, Random.Range(0f, 360f), 0f);

        private static void ReleaseFreeableLootContainer(FreeableLootContainer freeableLootContainer)
        {
            if (freeableLootContainer.IsTiedDown())
            {
                freeableLootContainer.GetRB().isKinematic = false;
                freeableLootContainer.buoyancy.enabled = true;
                freeableLootContainer.buoyancy.buoyancyScale = 1f;
                freeableLootContainer.SetFlag(BaseEntity.Flags.Reserved8, false, false, true);
            }
        }

        private static void Broadcast(string key, params object[] args)
        {
            foreach(BasePlayer player in BasePlayer.activePlayerList)
            {
                if (args != null && args.Length > 0)
                    player.ChatMessage(string.Format(Instance.lang.GetMessage(key, Instance, player.UserIDString), args));
                else player.ChatMessage(Instance.lang.GetMessage(key, Instance, player.UserIDString));
            }
        }        
        #endregion

        #region Map Edge Spawn Point Calculation
        private float WorldSize;

        private Vector3 BottomLeft;
        private Vector3 TopLeft;
        private Vector3 BottomRight;
        private Vector3 TopRight;

        private bool CalculateSpawnPosition2D(Iceberg iceberg, out Vector3 intersection)
        {
            Vector3 targetPosition = iceberg.Transform.position.XZ3D();

            Vector3 direction = targetPosition.normalized;

            Vector3 projectedPosition = targetPosition + (direction * WorldSize);

            if (IntersectsLine(targetPosition, projectedPosition, TopLeft, BottomLeft, out intersection))
                return true;

            if (IntersectsLine(targetPosition, projectedPosition, BottomLeft, BottomRight, out intersection))
                return true;

            if (IntersectsLine(targetPosition, projectedPosition, BottomRight, TopRight, out intersection))
                return true;

            if (IntersectsLine(targetPosition, projectedPosition, TopRight, TopLeft, out intersection))
                return true;

            return false;
        }

        private bool IntersectsLine(Vector3 from, Vector3 to, Vector3 lineStart, Vector3 lineEnd, out Vector3 intersection)
        {
            intersection = Vector3.zero;

            float d = (to.x - from.x) * (lineEnd.z - lineStart.z) - (to.z - from.z) * (lineEnd.x - lineStart.x);

            if (d == 0f)            
                return false;

            float u = ((lineStart.x - from.x) * (lineEnd.z - lineStart.z) - (lineStart.z - from.z) * (lineEnd.x - lineStart.x)) / d;
            float v = ((lineStart.x - from.x) * (to.z - from.z) - (lineStart.z - from.z) * (to.x - from.x)) / d;

            if (u < 0f || u > 1f || v < 0f || v > 1f)            
                return false;
            
            intersection.x = from.x + u * (to.x - from.x);
            intersection.z = from.z + u * (to.z - from.z);

            return true;
        }    
        #endregion

        #region Icebergs       
        private partial class Iceberg
        {
            public Transform Transform { get; private set; }

            public Collider Collider { get; private set; }

            public bool HasBuildingBlocks { get; private set; }

            public bool HasToolCupboard { get; private set; }


            private float validationExpireTime;


            public Iceberg(Transform transform)
            {
                Transform = transform;
                Collider = transform.GetComponent<Collider>();

                Validate();
            }

            public void Validate()
            {
                validationExpireTime = Time.time + 1800;

                HasBuildingBlocks = false;
                HasToolCupboard = false;

                int hits = Physics.BoxCastNonAlloc(Collider.bounds.center, Collider.bounds.extents, Transform.up, buffer, Transform.rotation, 1f, 1 << (int)Rust.Layer.Construction);
                for (int i = 0; i < hits; i++)
                {
                    RaycastHit raycastHit = buffer[i];

                    BaseEntity baseEntity = raycastHit.GetEntity();
                    if (baseEntity != null)
                    {
                        if (baseEntity is BuildingBlock)
                        {
                            HasBuildingBlocks = true;

                            if ((baseEntity as BuildingBlock).GetBuildingPrivilege() != null)
                            {
                                HasToolCupboard = true;
                                break;
                            }
                        }
                    }
                }                
            }
        }

        private partial class Iceberg
        {            
            private static readonly RaycastHit[] buffer = new RaycastHit[512];

            private static readonly List<Iceberg> icebergs = new List<Iceberg>();

            public static bool IsValid => icebergs.Count > 0;

            public static void FindAll()
            {
                icebergs.Clear();

                Transform root = HierarchyUtil.GetRoot("Decor").transform;

                const string ICEBERG_PATH = "assets/bundled/prefabs/autospawn/decor/iceberg/";

                for (int i = 0; i < root.childCount; i++)
                {
                    Transform child = root.GetChild(i);

                    if (child.name.StartsWith(ICEBERG_PATH))
                    {
                        for (int y = 0; y < child.childCount; y++)
                        {
                            Transform c = child.GetChild(y);
                            if (c.name.StartsWith(ICEBERG_NAME))
                            {
                                Iceberg iceberg = new Iceberg(c);
                                icebergs.Add(iceberg);
                            }
                        }
                    }
                }

                Debug.Log($"[RustTanic] Found {icebergs.Count} Icebergs");
            }

            public static Iceberg FindClosestIceberg(Vector3 position)
            {
                Iceberg closest = null;
                float distance = float.MaxValue;

                for (int i = 0; i < icebergs.Count; i++)
                {
                    Iceberg iceberg = icebergs[i];

                    if (iceberg.validationExpireTime < Time.time)
                        iceberg.Validate();

                    if ((Configuration.Iceberg.DisableWithBases && iceberg.HasBuildingBlocks) || (Configuration.Iceberg.DisableWithCupboards && iceberg.HasToolCupboard))
                        continue;

                    float d = Vector3.Distance(position, iceberg.Transform.position);
                    if (d < distance)
                    {
                        closest = iceberg;
                        distance = d;
                    }
                }

                return closest;
            }

            public static Iceberg GetRandom()
            {
                Iceberg closest = null;

                List<Iceberg> list = Facepunch.Pool.Get<List<Iceberg>>();
                list.AddRange(icebergs);

                for (int i = 0; i < icebergs.Count; i++)
                {
                    Iceberg iceberg = list.GetRandom();

                    if (iceberg.validationExpireTime < Time.time)
                        iceberg.Validate();

                    if ((Configuration.Iceberg.DisableWithBases && iceberg.HasBuildingBlocks) || (Configuration.Iceberg.DisableWithCupboards && iceberg.HasToolCupboard))
                        continue;

                    closest = iceberg;
                    break;
                }

                Facepunch.Pool.FreeUnmanaged(ref list);
                return closest;
            }
        }
        #endregion

        #region Component
        private class Titanic : CargoShip
        {
            private Transform Transform;

            internal Iceberg Iceberg;

            private Vector3 destination;

            private bool isSinking;

            private float timeToTake;
            private float timeTaken;

            private SinkingPhase Phase = SinkingPhase.Phase1;

            private SinkPhase Phase0;
            private SinkPhase Phase1;
            private SinkPhase Phase2;
            private SinkPhase Phase3;

            private bool isWithinProximity;

            private const float HALF_LENGTH = 80f;

            private enum SinkingPhase { Phase1, Phase2, Phase3 }

            public override void ServerInit()
            {
                Transform = transform;

                serverEntities.RegisterID(this);
                if (net != null)                
                    net.handler = this;
                                
                if (flags != 0)                
                    OnFlagsChanged(0, flags);
                
                if (syncPosition && PositionTickRate >= 0f)
                {
                    if (!PositionTickFixedTime)                    
                        InvokeRandomized(NetworkPositionTick, PositionTickRate, PositionTickRate - PositionTickRate * 0.05f, PositionTickRate * 0.05f);                    
                    else InvokeRepeatingFixedTime(NetworkPositionTick);
                }

                IcebergDetectionTrigger.Create(this);

                Query.Server.Add(this);
               
                InvokeRepeating(BuildingCheck, 1f, 5f);

                Invoke(SpawnInitialLoot, 10f);

                float waterlineOffset = WaterLevel.GetWaterSurface(Transform.position, false, false) - Transform.InverseTransformPoint(waterLine.transform.position).z;

                destination = Iceberg.Transform.position;
                destination.y = waterlineOffset;

                Transform.position = new Vector3(Transform.position.x, waterlineOffset, Transform.position.z);
                Transform.rotation = Quaternion.LookRotation(Vector3Ex.Direction2D(destination, Transform.position), Vector3.up);

                Debug.Log($"[RustTanic] - Spawned ship at {Transform.position} with destination {destination}");

                Broadcast("Notification.Spawned", Mathf.RoundToInt((Vector3.Distance(Transform.position, destination) - HALF_LENGTH) / Configuration.Boat.Speed));
               
                CreateMapMarker();
            }

            public override void DestroyShared()
            {
                if (explosionMarker != null && !explosionMarker.IsDestroyed)
                    explosionMarker.Kill();

                base.DestroyShared();
            }

            private new void FixedUpdate()
            {
                if (isSinking)
                {
                    timeTaken += Time.fixedDeltaTime;

                    if (timeTaken >= timeToTake)
                    {
                        if (Phase < SinkingPhase.Phase3)
                        {
                            Phase = (SinkingPhase)((int)Phase + 1);
                            timeTaken = 0;

                            if (Phase == SinkingPhase.Phase2)
                            {
                                timeToTake = Configuration.Boat.SinkTime2;

                                PlayHorn();
                                ExecuteSmallExplosion();
                            }

                            if (Phase == SinkingPhase.Phase3)
                            {
                                timeToTake = Configuration.Boat.SinkTime3;
                                base.SetFlag(Flags.Reserved8, false);
                            }
                        }
                        else 
                        {
                            CreateGibs();

                            enabled = false;

                            ReleaseLootContainers();

                            Invoke(DelayedDestroy, Configuration.Boat.DespawnTime);

                            CancelInvoke(PauseFlyhackLoop);
                            return;
                        }
                    }


                    float delta = Mathf.InverseLerp(0, timeToTake, timeTaken);

                    SinkPhase from = Phase == SinkingPhase.Phase1 ? Phase0 : Phase == SinkingPhase.Phase2 ? Phase1 : Phase2;
                    SinkPhase to = Phase == SinkingPhase.Phase1 ? Phase1 : Phase == SinkingPhase.Phase2 ? Phase2 : Phase3;

                    Transform.position = Vector3.Lerp(from.position, to.position, delta);
                    Transform.localEulerAngles = Vector3.Lerp(from.euler, to.euler, delta);                    
                }
                else
                {
                    Vector3 direction = (destination - Transform.position).normalized;

                    float dotForward = Vector3.Dot(transform.forward, direction);

                    float targetSpeedDelta = Mathf.InverseLerp(0f, 1f, dotForward);

                    currentThrottle = Mathf.Lerp(currentThrottle, targetSpeedDelta, Time.deltaTime * 0.2f);
                    currentVelocity = Transform.forward * (Configuration.Boat.Speed * currentThrottle);
                    Transform.position += currentVelocity * Time.deltaTime;

                    if (!isWithinProximity && Vector3.Distance(Transform.position, Iceberg.Transform.position) < Configuration.Boat.Effects.ProximityDistance + HALF_LENGTH)
                        ProximityTriggerEvents();
                }
            }

            #region Sinking
            private static readonly Transform[] EMPTY_SCIENTIST_SPAWNS = new Transform[0];

            private BaseEntity explosionMarker;

            private void ProximityTriggerEvents()
            {
                isWithinProximity = true;

                if (Configuration.Boat.Effects.AlarmProximity)
                    base.SetFlag(Flags.Reserved8, true);

                if (Configuration.Boat.Effects.NapalmLaunchers)
                    ServerMgr.Instance.StartCoroutine(ExecuteNapalmLaunchers());

                PlayHorn();
            }

            internal void OnStruckIceberg()
            {
                Broadcast("Notification.Collided", PhoneController.PositionToGridCoord(Iceberg.Transform.position));

                CreateExplosionMarker();

                StartSinking();

                PauseFlyhackLoop();

                ServerMgr.Instance.StartCoroutine(ProcessChildren());

                ServerMgr.Instance.StartCoroutine(SpawnLoot());
                ServerMgr.Instance.StartCoroutine(SpawnNPCs());

                if (Configuration.Boat.Effects.LargeExplosion)
                    ServerMgr.Instance.StartCoroutine(ExecuteLargeExplosions());
                else ExecuteSmallExplosion();
            }

            private void StartSinking()
            {
                SetupSinkingPhases();
               
                isSinking = true;
                timeToTake = Configuration.Boat.SinkTime1;

                CancelInvoke(PlayHorn);

                scientistSpawnPoints = EMPTY_SCIENTIST_SPAWNS;
            }

            private void SetupSinkingPhases()
            {
                Phase0 = new SinkPhase
                {
                    position = Transform.position,
                    euler = Transform.localEulerAngles
                };

                Phase1 = new SinkPhase
                {
                    position = Transform.position - (Vector3.up * 2),
                    euler = Transform.localEulerAngles + new Vector3(5f, 0f, 0f)
                };

                Phase2 = new SinkPhase
                {
                    position = Transform.position - (Vector3.up * 10),
                    euler = Transform.localEulerAngles + new Vector3(10f, 0f, 15f)
                };

                Vector3 finalPosition = Transform.position;
                finalPosition.y = TerrainMeta.HeightMap.GetHeight(finalPosition) + 15f;
                Phase3 = new SinkPhase
                {
                    position = finalPosition,
                    euler = new Vector3(0f, 0f, 90f)
                };
            }

            private void CreateExplosionMarker()
            {
                const string MARKER_PREFAB = "assets/prefabs/tools/map/explosionmarker.prefab";

                explosionMarker = GameManager.server.CreateEntity(MARKER_PREFAB, Transform.position);
                explosionMarker.enableSaving = false;
                explosionMarker.Spawn();
            }

            private IEnumerator ProcessChildren()
            {
                TriggerParent parent = GetComponentInChildren<TriggerParent>();
                parent.interestLayers.value = 1 << (int)Rust.Layer.Player_Server;
                parent.ParentNPCPlayers = false;

                for (int i = children.Count - 1; i >= 0; i--)
                {
                    BaseEntity entity = children[i];

                    if (entity is LootContainer && (entity as LootContainer).inventory != null)                    
                        ProcessParentedLootContainer(entity as LootContainer);                        
                    
                    else if (entity is BasePlayer && (entity as BasePlayer).IsNpc)
                        ProcessParentedNPC(entity as BasePlayer);

                    yield return null;
                }
            }

            private void PauseFlyhackLoop()
            {
                for (int i = children.Count - 1; i >= 0; i--)
                {
                    BasePlayer player = children[i] as BasePlayer;
                    if (!player || player.IsNpc)
                        continue;

                    player.PauseFlyHackDetection(1.1f);
                }

                Invoke(PauseFlyhackLoop, 1f);
            }

            private struct SinkPhase
            {
                public Vector3 position;
                public Vector3 euler;
            }
            #endregion

            #region Effects           
            private void ExecuteSmallExplosion()
            {
                InvokedEffect(HELI_EXPLOSION, new Vector3(0f, 7f, 78f), 0.1f);

                InvokedEffect(C4_EXPLOSION, new Vector3(9.8f, 6.5f, -20.9f), Random.Range(0.2f, 0.8f));

                InvokedEffect(HELI_EXPLOSION, new Vector3(0.0f, 9.7f, 61.7f), Random.Range(0.9f, 1.2f));

                InvokedEffect(C4_EXPLOSION, new Vector3(-9.6f, 6.5f, 41.8f), Random.Range(1.3f, 1.8f));

                InvokedEffect(HELI_EXPLOSION, new Vector3(0.0f, 9.7f, 61.7f), Random.Range(1.9f, 2.2f));
            }

            private IEnumerator ExecuteLargeExplosions()
            { 
                const string FIREBALL_PREFAB = "assets/bundled/prefabs/oilfireballsmall.prefab";

                foreach (Vector3 position in DECK_EXPLOSION_POSITIONS)
                {
                    Vector3 worldPosition = Transform.TransformPoint(position);

                    float r = Random.value;

                    Effect.server.Run(r < 0.5f ? HELI_EXPLOSION : C4_EXPLOSION, worldPosition);

                    for (int i = 0; i < 2; i++)
                    {
                        if (Random.Range(0f, 1f) > 0.4f)
                        {
                            CreateAndLaunchFireball(FIREBALL_PREFAB, worldPosition);
                            yield return CoroutineEx.waitForSeconds(0.1f);
                        }
                    }

                    yield return CoroutineEx.waitForSeconds(0.1f);
                }
            }

            private IEnumerator ExecuteNapalmLaunchers()
            {
                const string NAPALM_PREFAB = "assets/bundled/prefabs/napalm.prefab";
                
                float waterMapHeight = WaterLevel.GetWaterSurface(Transform.TransformPoint(-2.5f, 32.4f, -53.8f), false, false);

                while (true)
                {
                    Vector3 position = Transform.TransformPoint(-2.5f, 32.4f, -53.8f);

                    if (position.y <= waterMapHeight)
                        yield break;

                    CreateAndLaunchFireball(NAPALM_PREFAB, position);

                    yield return new WaitForSeconds(Random.Range(0.4f, 0.8f));
                }
            }
                       
            private void CreateAndLaunchFireball(string prefab, Vector3 position)
            {
                BaseEntity baseEntity = GameManager.server.CreateEntity(prefab, position);
                baseEntity.enableSaving = false;
                baseEntity.Spawn();

                baseEntity.GetComponent<Rigidbody>().AddForce(Random.Range(-4, 4), Random.Range(3, 6), Random.Range(-4, 4), ForceMode.Impulse);
            }

            private void InvokedEffect(string effect, Vector3 localOffset, float time) => Invoke(() => Effect.server.Run(effect, this, 0, localOffset, Vector3.up, null, true), time);

            private static readonly List<Vector3> DECK_EXPLOSION_POSITIONS = new List<Vector3> 
            {
                new Vector3(-1.9f, 9.5f, 75f),
                new Vector3(3.6f, 9.5f, 67.4f),
                new Vector3(-5.8f, 9.5f, 68.7f),
                new Vector3(-1.2f, 10.8f, 59.7f),
                new Vector3(7.4f, 9.5f, 58.3f),
                new Vector3(-1.2f, 9.5f, 56.7f),
                new Vector3(-7.4f, 9.5f, 58.5f),
                new Vector3(-1.7f, 9.5f, 46.4f),
                new Vector3(-9.3f, 6.5f, 49.7f),
                new Vector3(7.0f, 6.5f, 50.4f),
                new Vector3(2.1f, 9.5f, 32.7f),
                new Vector3(-9.9f, 6.5f, 24.8f),
                new Vector3(-1.7f, 9.5f, 24.4f),
                new Vector3(5.8f, 6.5f, 22.8f),
                new Vector3(-0.9f, 9.5f, 16.5f),
                new Vector3(-0.4f, 9.5f, 4.8f),
                new Vector3(6.1f, 6.5f, -1.7f),
                new Vector3(-8.6f, 6.5f, -3.0f),
                new Vector3(-2.6f, 9.5f, -9.6f),
                new Vector3(-2.9f, 9.5f, -20.9f),
                new Vector3(-1.6f, 9.5f, -27.2f),
                new Vector3(-8.6f, 6.5f, -28.4f),
                new Vector3(5.6f, 6.5f, -28.3f),
                new Vector3(4.4f, 9.5f, -34.9f),
                new Vector3(-6.9f, 9.5f, -34.7f),
                new Vector3(5.5f, 9.5f, -55.3f),
                new Vector3(-10.3f, 9.8f, -54.5f),
                new Vector3(-9.0f, 12.1f, -49.6f),
                new Vector3(6.2f, 12.5f, -49.6f),
                new Vector3(8.7f, 24.5f, -45.5f),
                new Vector3(-12.0f, 25.6f, -45.2f),
                new Vector3(-7.5f, 27.5f, -42.8f),
                new Vector3(3.8f, 27.5f, -44.2f),
                new Vector3(-1.2f, 31.2f, -45.4f),
                new Vector3(-1.5f, 36.5f, -45.6f)
            };
            #endregion

            #region Loot
            private List<LootContainer> shipLootContainers;

            private void SpawnInitialLoot()
            {
                InvokeRepeating(PlayHorn, 0f, 8f);

                if (Configuration.Loot.ShipLoot == ConfigData.LootSettings.ShipLootMode.Despawn)
                    return;

                SpawnCrate(lockedCratePrefab.resourcePath);
                SpawnCrate(eliteCratePrefab.resourcePath);

                for (int i = 0; i < 4; i++)
                    SpawnCrate(militaryCratePrefab.resourcePath);

                for (int j = 0; j < 4; j++)
                    SpawnCrate(junkCratePrefab.resourcePath);
            }
                        
            private void ProcessParentedLootContainer(LootContainer lootContainer)
            {
                if (Configuration.Loot.ShipLoot == ConfigData.LootSettings.ShipLootMode.FloatToSurface)
                {
                    if (shipLootContainers == null)
                        shipLootContainers = Pool.Get<List<LootContainer>>();

                    shipLootContainers.Add(lootContainer);
                }                
            }

            private void ReleaseLootContainers()
            {
                if (shipLootContainers == null || shipLootContainers.Count == 0)
                    return;

                for (int i = 0; i < shipLootContainers.Count; i++)
                {
                    LootContainer lootContainer = shipLootContainers[i];
                    if (!lootContainer || lootContainer.IsDestroyed)
                        continue;
                    
                    Vector3 position = lootContainer.transform.position;
                    position.x += Random.Range(-10f, 10f);
                    position.y = WaterLevel.GetWaterSurface(lootContainer.transform.position, false, false) - 1f;
                    position.z += Random.Range(-10f, 10f);
                    
                    FreeableLootContainer freeableLootContainer = GameManager.server.CreateEntity(FLOATING_CRATE_PREFAB, position, lootContainer.transform.rotation, true) as FreeableLootContainer;

                    if (freeableLootContainer)
                    {
                        freeableLootContainer.enableSaving = false;
                        freeableLootContainer.inventorySlots = lootContainer.inventory.itemList.Count;
                        freeableLootContainer.initialLootSpawn = false;
                        freeableLootContainer.Spawn();

                        for (int y = lootContainer.inventory.itemList.Count - 1; y >= 0; y--)
                        {
                            Item item = lootContainer.inventory.itemList[y];
                            if (!item.MoveToContainer(freeableLootContainer.inventory, -1, true, false))
                                item.Remove();
                        }

                        freeableLootContainer.inventory.SetFlag(ItemContainer.Flag.NoItemInput, true);
                        freeableLootContainer.Invoke(freeableLootContainer.RemoveMe, 1800f);
                    }

                    lootContainer.inventory.Clear();
                    lootContainer.Kill(DestroyMode.None);
                }

                Pool.FreeUnmanaged(ref shipLootContainers);
            }

            private IEnumerator SpawnLoot()
            {
                if (Configuration.Loot.Floating.Enabled)                
                    yield return ServerMgr.Instance.StartCoroutine(Configuration.Loot.Floating.SpawnInWater(Transform.position, 40f));
                
                if (Configuration.Loot.Iceberg.Enabled)
                    yield return ServerMgr.Instance.StartCoroutine(Configuration.Loot.Iceberg.SpawnOnIceberg(Iceberg));
            }

            private void CreateGibs()
            {
                if (Configuration.Loot.GibsToSpawn <= 0)
                    return;

                const string GIB_RESOURCE_PATH = "assets/prefabs/npc/m2bradley/servergibs_bradley.prefab";

                GameObject gibSource = GameManager.server.FindPrefab(GIB_RESOURCE_PATH).GetComponent<ServerGib>()._gibSource;

                for (int i = 0; i < Configuration.Loot.GibsToSpawn; i++)
                {
                    Vector3 position = Transform.position;
                    position.x += Random.Range(-40, 40);
                    position.z += Random.Range(-40, 40);

                    CreateGibs(GIB_RESOURCE_PATH, gibSource, position, Configuration.Loot.GibsSpread);
                }
            }

            private void CreateGibs(string resourcePath, GameObject source, Vector3 position, float spread)
            {
                List<ServerGib> serverGibs = Pool.Get<List<ServerGib>>();

                foreach (MeshRenderer meshRenderer in source.GetComponentsInChildren<MeshRenderer>(true))
                {
                    MeshFilter component = meshRenderer.GetComponent<MeshFilter>();                    
                    BaseEntity baseEntity = GameManager.server.CreateEntity(resourcePath, position, meshRenderer.transform.localRotation, true);
                    if (baseEntity)
                    {
                        ServerGib serverGib = baseEntity.GetComponent<ServerGib>();                        
                        serverGib._gibName = meshRenderer.name;

                        MeshCollider component3 = meshRenderer.GetComponent<MeshCollider>();
                        Mesh physicsMesh = (component3 != null) ? component3.sharedMesh : component.sharedMesh;
                        serverGib.PhysicsInit(physicsMesh);

                        Vector3 velocity = meshRenderer.transform.localPosition.normalized * spread;

                        Rigidbody rb = serverGib.GetComponent<Rigidbody>();
                        rb.velocity = velocity;
                        rb.angularVelocity = Vector3Ex.Range(-1f, 1f).normalized * 1f;
                        rb.WakeUp();

                        serverGib.Spawn();
                        serverGibs.Add(serverGib);
                    }
                }

                foreach (ServerGib serverGib in serverGibs)
                {
                    foreach (ServerGib serverGib2 in serverGibs)
                    {
                        if (!(serverGib == serverGib2))
                        {
                            Physics.IgnoreCollision(serverGib2.GetCollider(), serverGib.GetCollider(), true);
                        }
                    }
                }
                Pool.FreeUnmanaged(ref serverGibs);
            }
            #endregion

            #region NPCs 
            private static readonly LootContainer.LootSpawnSlot[] EMPTY_LOOT_SPAWNS = new LootContainer.LootSpawnSlot[0];

            private void ProcessParentedNPC(BasePlayer player)
            {
                if (!Configuration.NPC.ShipNPCs.ShipNPCDropLoot)
                    (player as ScientistNPC).LootSpawnSlots = EMPTY_LOOT_SPAWNS;

                if (Configuration.NPC.ShipNPCs.Kill == ConfigData.NPCSettings.ShipNPCSettings.KillMode.KillInstantly)
                {
                    if (Configuration.NPC.ShipNPCs.Corpse == ConfigData.NPCSettings.ShipNPCSettings.CorpseMode.DropCorpse)                    
                        player.Die(new HitInfo(player, player, Rust.DamageType.Drowned, 1000f));                    
                    else
                    {
                        player.EnableSaving(false);
                        player.Kill(BaseNetworkable.DestroyMode.None);
                    }
                }
                else player.gameObject.AddComponent<DrownWhenUnderWater>();
            }

            private IEnumerator SpawnNPCs()
            {
                yield return CoroutineEx.waitForSeconds(5f);
                Vector3 position = Iceberg.Collider.bounds.center + (Vector3.up * Iceberg.Collider.bounds.extents.y);

                for (int i = 0; i < Configuration.NPC.AmountToSpawn; i++)
                {
                    ChaosNPC.SpawnNPC(Instance, position, Configuration.NPC.Settings);

                    yield return CoroutineEx.waitForSeconds(0.5f);
                }
            }
            #endregion
        }

        private class IcebergDetectionTrigger : MonoBehaviour
        {
            private Titanic titanic;

            private BoxCollider boxCollider;

            private void Awake()
            {
                gameObject.name = "CollisionTrigger";
                gameObject.transform.localRotation = Quaternion.Euler(24f, 0f, 0f);
                gameObject.layer = (int)Rust.Layer.Reserved1;

                Rigidbody rigidbody = gameObject.AddComponent<Rigidbody>();
                rigidbody.useGravity = false;
                rigidbody.isKinematic = true;
                rigidbody.detectCollisions = true;
                rigidbody.collisionDetectionMode = CollisionDetectionMode.Discrete;

                boxCollider = gameObject.AddComponent<BoxCollider>();
                boxCollider.center = new Vector3(0f, 33f, 66f);
                boxCollider.size = new Vector3(10f, 10f, 5);
                boxCollider.isTrigger = true;
            }

            private void OnTriggerEnter(Collider col)
            {
                if (col.gameObject.name.Contains(ICEBERG_NAME))
                {
                    titanic.OnStruckIceberg();
                    Destroy(gameObject);
                }
            }

            internal static void Create(Titanic titanic) => titanic.gameObject.CreateChild().AddComponent<IcebergDetectionTrigger>().titanic = titanic;
        }

        private class DrownWhenUnderWater : MonoBehaviour
        {
            private BasePlayer player;

            private void Awake()
            {
                enabled = false;
                player = GetComponent<BasePlayer>();
                InvokeHandler.Invoke(player, CheckWaterLevel, Random.Range(0.2f, 1f));
            }

            private void CheckWaterLevel()
            {
                if (player.eyes.position.y < 0)
                {
                    if (Configuration.NPC.ShipNPCs.Corpse == ConfigData.NPCSettings.ShipNPCSettings.CorpseMode.DropCorpse)                    
                        player.Die(new HitInfo(player, player, Rust.DamageType.Drowned, 1000f));                    
                    else
                    {
                        player.EnableSaving(false);
                        player.Kill(BaseNetworkable.DestroyMode.None);
                    }
                }
                else InvokeHandler.Invoke(player, CheckWaterLevel, Random.Range(0.2f, 1f));
            }
        }
        #endregion

        #region Commands
        [ChatCommand("titanic")]
        private void SpawnTitanicCommand(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_ADMIN))
            {
                player.ChatMessage("You do not have permission to run this command");
                return;
            }

            if (!Iceberg.IsValid)
            {
                player.ChatMessage("No valid icebergs were found on the map. Unable to run this event");
                return;
            }

            if (args.Length < 1)
            {
                player.ChatMessage("/titanic random - Spawn a titanic cargo ship targeting a random iceberg");
                player.ChatMessage("/titanic closest - Spawn a titanic cargo ship targeting the nearest iceberg to you");
                return;
            }

            string failed;
            switch (args[0].ToLower())
            {
                case "random":

                    if (!SpawnCargoShip(Vector3.zero, out failed))
                        player.ChatMessage($"Failed to run event : {failed}");
                    else player.ChatMessage("Event triggered successfully");
                    break;

                case "closest":

                    if (!SpawnCargoShip(player.transform.position, out failed))
                        player.ChatMessage($"Failed to run event : {failed}");
                    else player.ChatMessage("Event triggered successfully");
                    break;

                default:
                    player.ChatMessage("Invalid syntax. Type /titanic to view available commands");
                    break;
            }
        }

        [ConsoleCommand("titanic")]
        private void SpawnTitanicConsoleCommand(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
            {
                if (!permission.UserHasPermission(arg.Connection.userid.ToString(), PERMISSION_ADMIN))
                {
                    SendReply(arg, "You do not have permission to use this command");
                    return;
                }
            }

            if (!Iceberg.IsValid)
            {
                SendReply(arg, "No valid icebergs were found on the map. Unable to run this event");
                return;
            }

            if (!SpawnCargoShip(Vector3.zero, out string failed))
                SendReply(arg, $"Failed to run event : {failed}");
            else SendReply(arg, "Event triggered successfully");
        }
        #endregion

        #region Config        
        private static ConfigData Configuration;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Event Automation Settings")]
            public AutomationSettings Automation { get; set; }

            [JsonProperty(PropertyName = "Iceberg Selection")]
            public IcebergSelection Iceberg { get; set; }

            [JsonProperty(PropertyName = "Boat Settings")]
            public BoatSettings Boat { get; set; }

            [JsonProperty(PropertyName = "NPC Settings")]
            public NPCSettings NPC { get; set; }

            [JsonProperty(PropertyName = "Loot Options")]
            public LootSettings Loot { get; set; }

            public class AutomationSettings
            {
                [JsonProperty(PropertyName = "Enable event automation")]
                public bool Enabled { get; set; }

                [JsonProperty(PropertyName = "Minimum time between events (seconds)")]
                public int Minimum { get; set; }

                [JsonProperty(PropertyName = "Maximum time between events (seconds)")]
                public int Maximum { get; set; }
                
                [JsonProperty(PropertyName = "Minimum required players to trigger the event")]
                public int RequiredPlayers { get; set; }

                [JsonIgnore]
                public int RandomTime => Random.Range(Minimum, Maximum);
            }

            public class BoatSettings
            {
                [JsonProperty(PropertyName = "Movement speed")]
                public float Speed { get; set; }

                [JsonProperty(PropertyName = "Amount of time it takes to sink - Phase 1 (seconds)")]
                public float SinkTime1 { get; set; }

                [JsonProperty(PropertyName = "Amount of time it takes to sink - Phase 2 (seconds)")]
                public float SinkTime2 { get; set; }

                [JsonProperty(PropertyName = "Amount of time it takes to sink - Phase 3 (seconds)")]
                public float SinkTime3 { get; set; }

                [JsonProperty(PropertyName = "Cargo ship despawn time once sunk (seconds)")]
                public int DespawnTime { get; set; }

                [JsonProperty(PropertyName = "Effect Settings")]
                public EffectSettings Effects { get; set; }
                
                public class EffectSettings
                {
                    [JsonProperty(PropertyName = "Large explosion enabled")]
                    public bool LargeExplosion { get; set; }

                    [JsonProperty(PropertyName = "Napalm launchers enabled")]
                    public bool NapalmLaunchers { get; set; }

                    [JsonProperty(PropertyName = "Alarm sound on proximity enabled")]
                    public bool AlarmProximity { get; set; }

                    [JsonProperty(PropertyName = "Proximity distance to trigger effects")]
                    public float ProximityDistance { get; set; }
                }
            }

            public class IcebergSelection
            {
                [JsonProperty(PropertyName = "Don't target icebergs that have player construction on them")]
                public bool DisableWithBases { get; set; }

                [JsonProperty(PropertyName = "Don't target icebergs that have tool cupboards on them")]
                public bool DisableWithCupboards { get; set; }
            }

            public class NPCSettings
            {
                [JsonProperty(PropertyName = "Cargo Ship NPC Options")]
                public ShipNPCSettings ShipNPCs { get; set; }

                [JsonProperty(PropertyName = "Amount of NPCs to spawn on the iceberg")]
                public int AmountToSpawn { get; set; }

                [JsonProperty(PropertyName = "NPC Options")]
                public Oxide.Ext.ChaosNPC.NPCSettings Settings { get; set; }               

                public class ShipNPCSettings
                {                    
                    [JsonProperty(PropertyName = "Cargo Ship NPCs drop loot")]
                    public bool ShipNPCDropLoot { get; set; }

                    [JsonProperty(PropertyName = "Cargo Ship NPC kill mode ( KillInstantly, DieByDrowning )")]
                    public KillMode Kill { get; set; }

                    [JsonProperty(PropertyName = "Cargo Ship corpse mode ( NoCorpse, DropCorpse )")]
                    public CorpseMode Corpse { get; set; }

                    [JsonConverter(typeof(StringEnumConverter))]
                    public enum KillMode { KillInstantly, DieByDrowning }

                    [JsonConverter(typeof(StringEnumConverter))]
                    public enum CorpseMode { NoCorpse, DropCorpse }                    
                }
            }

            public class LootSettings
            {
                [JsonProperty(PropertyName = "Cargo ship loot mode ( Despawn, LeaveOnShip, FloatToSurface )")]
                public ShipLootMode ShipLoot { get; set; }

                [JsonProperty(PropertyName = "Amount of mine-able debris to spawn")]
                public int GibsToSpawn { get; set; }

                [JsonProperty(PropertyName = "Debris spread amount")]
                public float GibsSpread { get; set; }

                [JsonProperty(PropertyName = "Iceberg loot crates")]
                public LootTable Iceberg { get; set; }

                [JsonProperty(PropertyName = "Floating loot crates")]
                public LootTable Floating { get; set; }

                public class LootTable
                {
                    [JsonProperty(PropertyName = "Drop loot crates")]
                    public bool Enabled { get; set; }

                    [JsonProperty(PropertyName = "Amount of crates to spawn")]
                    public int Amount { get; set; }

                    [JsonProperty(PropertyName = "Use custom loot table")]
                    public bool UseCustomLoot { get; set; }

                    [JsonProperty(PropertyName = "Minimum number of items per crate")]
                    public int Minimum { get; set; }

                    [JsonProperty(PropertyName = "Maximum number of items per crate")]
                    public int Maximum { get; set; }

                    [JsonProperty(PropertyName = "Despawn time (seconds)")]
                    public int DespawnTime { get; set; }

                    public List<LootItem> Table { get; set; }

                    public class LootItem
                    {
                        public string Shortname { get; set; }

                        public int Minimum { get; set; }

                        public int Maximum { get; set; }

                        public ulong Skin { get; set; }

                        [JsonProperty(PropertyName = "Minimum condition (0.0 - 1.0)")]
                        public float MinCondition { get; set; } = 1f;

                        [JsonProperty(PropertyName = "Maximum condition (0.0 - 1.0)")]
                        public float MaxCondition { get; set; } = 1f;

                        public float Probability { get; set; }

                        public LootItem() { }

                        public LootItem(string shortname, int minimum, int maximum, float probability)
                        {
                            Shortname = shortname;
                            Minimum = minimum;
                            Maximum = maximum;
                            Probability = probability;
                            MinCondition = MaxCondition = 1f;
                        }

                        private int GetAmount()
                        {
                            if (Maximum <= 0f || Maximum <= Minimum)
                                return Minimum;

                            return Random.Range(Minimum, Maximum);
                        }

                        public void Create(ItemContainer container)
                        {
                            Item item = ItemManager.CreateByName(Shortname, GetAmount(), Skin);
                            if (item != null)
                            {
                                item.conditionNormalized = Random.Range(Mathf.Clamp01(MinCondition), Mathf.Clamp01(MaxCondition));

                                item.OnVirginSpawn();

                                if (!item.MoveToContainer(container, -1, true))
                                    item.Remove(0f);
                            }
                        }
                    }

                    public IEnumerator SpawnInWater(Vector3 position, float radius)
                    {
                        for (int i = 0; i < Amount; i++)
                        {
                            const int SPAWN_ATTEMPTS = 5;
                            for (int y = 0; y < SPAWN_ATTEMPTS; y++)
                            {
                                Vector2 random = Random.insideUnitCircle * radius;
                                position.x += random.x;
                                position.z += random.y;

                                if (Physics.Raycast(position + (Vector3.up * 100f), Vector3.down, out RaycastHit, 150f, 1 << (int)Rust.Layer.Water | 1 << (int)Rust.Layer.World))
                                {
                                    if (RaycastHit.IsOnLayer(Rust.Layer.Water))
                                    {
                                        FreeableLootContainer freeableLootContainer = SpawnContainer(FLOATING_CRATE_PREFAB, RaycastHit.point, RandomUpRotation()) as FreeableLootContainer;
                                        ReleaseFreeableLootContainer(freeableLootContainer);

                                        break;
                                    }
                                }

                                yield return null;
                            }

                            yield return null;
                        }
                    }

                    public IEnumerator SpawnOnIceberg(Iceberg iceberg)
                    {
                        const string ICESHEET_NAME = "ice_sheet";
                        const string ELITE_CRATE_PREFAB = "assets/bundled/prefabs/radtown/crate_elite.prefab";

                        Bounds bounds = iceberg.Collider.bounds;
                        Vector3 localCenter = iceberg.Transform.InverseTransformPoint(bounds.center);
                        for (int i = 0; i < Amount; i++)
                        {
                            const int SPAWN_ATTEMPTS = 5;
                            for (int y = 0; y < SPAWN_ATTEMPTS; y++)
                            {
                                Vector3 random = new Vector3(Random.Range(-bounds.extents.x, bounds.extents.x), bounds.extents.y, Random.Range(-bounds.extents.z, bounds.extents.z)); 
                                Vector3 position = iceberg.Transform.TransformPoint(localCenter + random);

                                if (Physics.Raycast(position + (Vector3.up * 50f), Vector3.down, out RaycastHit, 150f, 1 << (int)Rust.Layer.Water | 1 << (int)Rust.Layer.World))
                                {
                                    if (RaycastHit.transform.name.Contains(ICEBERG_NAME) || RaycastHit.transform.name.Contains(ICESHEET_NAME))
                                    {
                                        SpawnContainer(ELITE_CRATE_PREFAB, RaycastHit.point, Quaternion.LookRotation(Vector3.forward, RaycastHit.normal) * RandomUpRotation());
                                        break;
                                    }
                                }

                                yield return null;
                            }

                            yield return null;
                        }
                    }

                    private LootContainer SpawnContainer(string prefabPath, Vector3 position, Quaternion rotation)
                    {
                        LootContainer lootContainer = GameManager.server.CreateEntity(prefabPath, position, rotation) as LootContainer;
                        lootContainer.enableSaving = false;
                        lootContainer.Spawn();

                        if (UseCustomLoot)
                            PopulateLoot(lootContainer);

                        if (DespawnTime > 0)
                            lootContainer.Invoke(lootContainer.RemoveMe, DespawnTime);

                        return lootContainer;
                    }

                    private void PopulateLoot(LootContainer lootContainer)
                    {
                        lootContainer.inventory.Clear();

                        int count = Random.Range(Minimum, Maximum);

                        int spawnedCount = 0;
                        int loopCount = 0;

                        while (true)
                        {
                            loopCount++;

                            if (loopCount > 3)
                                return;

                            float probability = Random.Range(0f, 1f);

                            List<LootItem> definitions = Pool.Get<List<LootItem>>();
                            definitions.AddRange(Table);

                            for (int i = 0; i < Table.Count; i++)
                            {
                                LootItem lootItem = definitions.GetRandom();

                                definitions.Remove(lootItem);

                                if (lootItem.Probability >= probability)
                                {
                                    lootItem.Create(lootContainer.inventory);

                                    spawnedCount++;

                                    if (spawnedCount >= count)
                                        return;
                                }
                            }
                        }
                    }
                }

                [JsonConverter(typeof(StringEnumConverter))]
                public enum ShipLootMode { Despawn, LeaveOnShip, FloatToSurface }
            }
                        
            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Configuration = Config.ReadObject<ConfigData>();

            if (Configuration.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(Configuration, true);
        }

        protected override void LoadDefaultConfig() => Configuration = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Automation = new ConfigData.AutomationSettings
                {
                    Enabled = true,
                    Minimum = 7200,
                    Maximum = 10800,
                    RequiredPlayers = 1
                },
                Boat = new ConfigData.BoatSettings()
                {
                    Speed = 8f,
                    SinkTime1 = 90,
                    SinkTime2 = 90,
                    SinkTime3 = 60,
                    DespawnTime = 900,
                    Effects = new ConfigData.BoatSettings.EffectSettings
                    {
                        LargeExplosion = true,
                        NapalmLaunchers = true,
                        AlarmProximity = true,
                        ProximityDistance = 200f
                    }
                },
                Iceberg = new ConfigData.IcebergSelection
                {
                    DisableWithBases = false,
                    DisableWithCupboards = true
                },
                NPC = new ConfigData.NPCSettings
                {                    
                    ShipNPCs = new ConfigData.NPCSettings.ShipNPCSettings
                    {
                        ShipNPCDropLoot = false,
                        Kill = ConfigData.NPCSettings.ShipNPCSettings.KillMode.DieByDrowning,
                        Corpse = ConfigData.NPCSettings.ShipNPCSettings.CorpseMode.NoCorpse
                    },
                    AmountToSpawn = 5,
                    Settings = new Oxide.Ext.ChaosNPC.NPCSettings
                    {
                        DisplayNames = new string[] { "Pirate" },
                        Types = new NPCType[] { NPCType.TunnelDweller }, 
                        WoundedRecoveryChance = 80,
                        WoundedChance = 15,
                        RoamRange = 30                        
                    }
                },
                Loot = new ConfigData.LootSettings
                {
                    ShipLoot = ConfigData.LootSettings.ShipLootMode.FloatToSurface,
                    GibsToSpawn = 3,
                    GibsSpread = 10f,
                    Floating = new ConfigData.LootSettings.LootTable
                    {
                        Enabled = false,
                        Amount = 7,
                        Minimum = 3,
                        Maximum = 6,
                        UseCustomLoot = false,
                        DespawnTime = 1800,
                        Table = new List<ConfigData.LootSettings.LootTable.LootItem>
                        {
                            new ConfigData.LootSettings.LootTable.LootItem("rope", 2, 4, 1f),
                            new ConfigData.LootSettings.LootTable.LootItem("gears", 1, 2, 1f),
                            new ConfigData.LootSettings.LootTable.LootItem("scrap", 20, 25, 1f),
                            new ConfigData.LootSettings.LootTable.LootItem("metalblade", 1, 3, 1f),
                            new ConfigData.LootSettings.LootTable.LootItem("metalspring", 1, 2, 1f),
                            new ConfigData.LootSettings.LootTable.LootItem("sheetmetal", 1, 2, 1f),
                            new ConfigData.LootSettings.LootTable.LootItem("propanetank", 1, 1, 1f),
                        }
                    },
                    Iceberg = new ConfigData.LootSettings.LootTable
                    {
                        Enabled = true,
                        Amount = 3,
                        Minimum = 3,
                        Maximum = 5,
                        UseCustomLoot = false,
                        DespawnTime = 1800,
                        Table = new List<ConfigData.LootSettings.LootTable.LootItem>
                        {
                            new ConfigData.LootSettings.LootTable.LootItem("targeting.computer", 1, 1, 0.7f),
                            new ConfigData.LootSettings.LootTable.LootItem("techparts", 1, 2, 0.8f),
                            new ConfigData.LootSettings.LootTable.LootItem("scrap", 20, 25, 1f),
                            new ConfigData.LootSettings.LootTable.LootItem("metal.refined", 10, 20, 0.8f),
                            new ConfigData.LootSettings.LootTable.LootItem("supply.signal", 1, 1, 0.7f),
                            new ConfigData.LootSettings.LootTable.LootItem("flamethrower", 1, 1, 0.5f),
                            new ConfigData.LootSettings.LootTable.LootItem("shotgun.double", 1, 1, 0.5f),
                        }
                    }
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(Configuration, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (Configuration.Version < new Core.VersionNumber(2, 0, 0))
                Configuration = baseConfig;

            Configuration.Version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion
    }
}


// --- End of file: RustTanic-2.0.10.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Christmas.cs ---
// --- Original Local Path: Christmas.cs ---

﻿using System;
using System.Linq;
using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Christmas", "", "1.0.0")]
    [Description("")]

    public class Christmas : RustPlugin
    {
        private const string PLAYER_PERM = "christmas.use";
        private static Christmas ins { get; set; }
        #region Functions
        private void Init()
        {
            ins = this;
            permission.RegisterPermission(PLAYER_PERM, this);

            ConVar.XMas.enabled = true;
            ConVar.XMas.spawnRange = configData.Automation.playerDistance;
            ConVar.XMas.giftsPerPlayer = configData.Automation.giftsPerPlayer;

            timer.Every(configData.Automation.refillTime * 60, () =>
            {
                RefillPresents();
                if (configData.Automation.messagesEnabled)
                    PrintWarning("PresentPizdec");
            });
        }

        private void Unload()
        {
            Puts("Disabling the Christmas event...");
            ConVar.XMas.enabled = false;
            ins = null;
        }

        public void RefillPresents() => ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), "xmas.refill");

        #endregion

        

        [ConsoleCommand("giftwqdwqwqdwqdwq")]
        private void GiftsConsole(ConsoleSystem.Arg arg)
        {
            RefillPresents();
        }

        private static ConfigData configData;
        private class ConfigData
        {
            [JsonProperty(PropertyName = "Event Automation Settings")]
            public AutomationOptions Automation { get; set; }

            public class AutomationOptions
            {
                [JsonProperty(PropertyName = "Time in-between presents and stocking refills (minutes)")]
                public int refillTime { get; set; }
                [JsonProperty(PropertyName = "Distance a player in which to spawn")]
                public int playerDistance { get; set; }
                [JsonProperty(PropertyName = "Gifts per player")]
                public int giftsPerPlayer { get; set; }
                [JsonProperty(PropertyName = "Broadcast Message enabled to players when gifts sent (true/false)")]
                public bool messagesEnabled { get; set; }
            }


            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Automation = new ConfigData.AutomationOptions
                {
                    refillTime = 50,
                    playerDistance = 50,
                    giftsPerPlayer = 1,
                    messagesEnabled = true
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new Core.VersionNumber(2, 0, 0))
                configData = baseConfig;

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null) return defaultValue;
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

      
    }
}

// --- End of file: Christmas.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AutoGrades.cs ---
// --- Original Local Path: AutoGrades.cs ---

/*
	Created By AlexALX (c) 2015-2017
	Special thanks to: recon, freaky
	for keep plugin work with latest rust updates
*/
using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Automatic Build Grades", "AlexALX", "0.0.18", ResourceId = 921)]
    [Description("Auto update grade on build to what you need")]
    public class AutoGrades : CovalencePlugin
    {
        #region Initialization

        private Dictionary<string, Timer> CheckTimer = new Dictionary<string, Timer>();
        private Dictionary<string, PlayerGrades> playerGrades;
        private bool LoadDefault = false;
        private bool block = true;
        private string cmdname = "bgrade";
        private bool allow_timer = true;
        private int def_timer = 30;

        private class PlayerGrades
        {
            public int Grade { get; set; }
            public int Timer { get; set; }

            public PlayerGrades(int grade = 0, int timer = 0)
            {
                Grade = grade;
                Timer = timer;
            }
        }

        protected override void LoadDefaultConfig()
        {
            LoadDefault = true;
        }

        private void OnServerInitialized()
        {
            permission.RegisterPermission("autogrades.all", this);
            permission.RegisterPermission("autogrades.1", this);
            permission.RegisterPermission("autogrades.2", this);
            permission.RegisterPermission("autogrades.3", this);
            permission.RegisterPermission("autogrades.4", this);
            permission.RegisterPermission("autogrades.nores", this);

            ReadFromConfig("Block Construct and Refund", ref block);
            ReadFromConfig("Command", ref cmdname);
            ReadFromConfig("AllowTimer", ref allow_timer);
            ReadFromConfig("DefaultTimer", ref def_timer);
            SaveConfig();

            AddCovalenceCommand(cmdname, "BuildGradeCommand");

            playerGrades = new Dictionary<string, PlayerGrades>();
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["BGRADE_NOPERM"] = "You have no access to this command.",
                ["BGRADE_NORES"] = "Not enough resources for construct and upgrade.",
                ["BGRADE_NORES2"] = "Not enough resources for upgrade.",
                ["BGRADE_HELP"] = "Automatic Build Grade command usage:",
                ["BGRADE_1"] = "/{0} 1 - auto update to wood",
                ["BGRADE_2"] = "/{0} 2 - auto update to stone",
                ["BGRADE_3"] = "/{0} 3 - auto update to metal",
                ["BGRADE_4"] = "/{0} 4 - auto update to armored",
                ["BGRADE_0"] = "/{0} 0 - disable auto update",
                ["BGRADE_CUR"] = "Current mode: {0}",
                ["BGRADE_SET"] = "You successfully set auto update to {0}.",
                ["BGRADE_DIS"] = "You successfully disabled auto update.",
                ["BGRADE_INV"] = "Invalid building grade.",
                ["Disabled"] = "Disabled",
                ["Wood"] = "Wood",
                ["Stone"] = "Stone",
                ["Metal"] = "Metal",
                ["TopTier"] = "TopTier",
                ["BGRADE_T"] = "/{0} t sec - timer to auto turn off, use 0 to disable",
                ["BGRADE_CURT"] = ", timer: {0}",
                ["BGRADE_TIME"] = "Auto turn off timer: {0}.",
                ["BGRADE_SET_TIMER"] = "You successfully set auto turn off timer to {0}.",
                ["BGRADE_DIS_TIMER"] = "You successfully disabled auto turn off timer.",
                ["BGRADE_DIS_TIMED"] = "Auto update automatically disabled.",
                ["BGRADE_SEC"] = "seconds",
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["BGRADE_NOPERM"] = "Недостаточно прав для использования данной команды.",
                ["BGRADE_NORES"] = "Недостаточно ресурсов для постройки и обновления.",
                ["BGRADE_NORES2"] = "Недостаточно ресурсов для обновления.",
                ["BGRADE_HELP"] = "Автоматическое обновление конструкции, использование:",
                ["BGRADE_1"] = "/{0} 1 - авто обновление до дерева",
                ["BGRADE_2"] = "/{0} 2 - авто обновление до камня",
                ["BGRADE_3"] = "/{0} 3 - авто обновление до метала",
                ["BGRADE_4"] = "/{0} 4 - авто обновление до бронированого",
                ["BGRADE_0"] = "/{0} 0 - отключить авто обновление",
                ["BGRADE_CUR"] = "Текущий режим: {0}",
                ["BGRADE_SET"] = "Вы успешно установили авто обновление до: {0}.",
                ["BGRADE_DIS"] = "Вы успешно выключили авто обновление.",
                ["BGRADE_INV"] = "Неверный класс постройки.",
                ["Disabled"] = "Отключено",
                ["Wood"] = "Дерево",
                ["Stone"] = "Камень",
                ["Metal"] = "Метал",
                ["TopTier"] = "Бронированый",
                ["BGRADE_T"] = "/{0} t сек - таймер до авто-отключения, 0 - отключить",
                ["BGRADE_CURT"] = ", таймер: {0}",
                ["BGRADE_TIME"] = "Время до авто отключения: {0}.",
                ["BGRADE_SET_TIMER"] = "Вы успешно установили таймер авто отключения на {0}.",
                ["BGRADE_DIS_TIMER"] = "Вы успешно выключили таймер авто отключения.",
                ["BGRADE_DIS_TIMED"] = "Авто обновление автоматически отключено.",
                ["BGRADE_SEC"] = "секунд",
            }, this, "ru");
        }

        #endregion

        #region Helpers

        private void ReadFromConfig<T>(string Key, ref T var)
        {
            if (Config[Key] != null) var = (T)Convert.ChangeType(Config[Key], typeof(T));
            Config[Key] = var;
        }

        private bool HasPerm(string steamId, string perm) => permission.UserHasPermission(steamId, "autogrades." + perm);

        private bool HasAnyPerm(BasePlayer player)
        {
            var steamId = player.UserIDString;
            return (HasPerm(steamId, "all") || HasPerm(steamId, "1") || HasPerm(steamId, "2") || HasPerm(steamId, "3") || HasPerm(steamId, "4"));
        }

        private string GetMessage(string name, string steamId = null) => lang.GetMessage(name, this, steamId);

        #endregion

        private int PlayerTimer(string steamId, bool cache = true)
        {
            if (!allow_timer) return 0;
            if (playerGrades.ContainsKey(steamId)) return playerGrades[steamId].Timer;
            if (!cache) return def_timer;
            playerGrades[steamId] = new PlayerGrades(0, def_timer);
            return playerGrades[steamId].Timer;
        }

        private void UpdateTimer(BasePlayer player)
        {
            var steamId = player.UserIDString;
            var ptimer = PlayerTimer(steamId, false);

            if (ptimer > 0)
            {
                if (CheckTimer.ContainsKey(steamId))
                {
                    CheckTimer[steamId].Destroy();
                    CheckTimer.Remove(steamId);
                }
                CheckTimer[steamId] = timer.Once(ptimer, () =>
                {
                    if (CheckTimer.ContainsKey(steamId)) CheckTimer.Remove(steamId);
                    if (playerGrades.ContainsKey(steamId)) playerGrades[steamId].Grade = 0;
                    player?.ChatMessage(GetMessage("BGRADE_DIS_TIMED", steamId));
                });
            }
        }

        private int PlayerGrade(string steamId, bool cache = true)
        {
            if (playerGrades.ContainsKey(steamId)) return playerGrades[steamId].Grade;
            if (!cache) return 0;
            playerGrades[steamId] = new PlayerGrades(0, def_timer);
            return playerGrades[steamId].Grade;
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            var steamId = player.UserIDString;
            if (CheckTimer.ContainsKey(steamId))
            {
                CheckTimer[steamId].Destroy();
                CheckTimer.Remove(steamId);
            }
            if (playerGrades.ContainsKey(steamId)) playerGrades.Remove(steamId);
        }

        private bool CanAffordToUpgrade(BasePlayer player, int grade, BuildingBlock buildingBlock)
        {
            var flag = true;
            var enumerator = buildingBlock.blockDefinition.grades[(int)buildingBlock.grade].costToBuild.GetEnumerator();

            // Add cost of build grade 0
            var costs = new Dictionary<int, float>();
            while (enumerator.MoveNext())
            {
                var current = enumerator.Current;
                costs[current.itemid] = current.amount;
            }

            enumerator = buildingBlock.blockDefinition.grades[grade].costToBuild.GetEnumerator();

            // Calculate needed costs for upgrade
            while (enumerator.MoveNext())
            {
                var current = enumerator.Current;
                var cost = 0f;
                if (costs.ContainsKey(current.itemid))
                {
                    cost = costs[current.itemid];
                    costs.Remove(current.itemid);
                }
                if (player.inventory.GetAmount(current.itemid) >= current.amount + cost) continue;
                flag = false;
                return flag;
            }

            // Check for build grade 0 and needed cost (additional resources)
            if (costs.Count > 0)
            {
                foreach (var kvp in costs)
                {
                    if (player.inventory.GetAmount(kvp.Key) >= kvp.Value) continue;
                    flag = false;
                    return flag;
                }
            }

            return flag;
        }

        /* Example of hook usage
        private int CanAutoGrade(BasePlayer player, int grade, BuildingBlock buildingBlock, Planner planner)
        {
            //return -1; // Block upgrade, but create twig part
            //return 0; // Obey plugin settings (block on construct if enabled or not)
            //return 1; // Block upgrade and block build
            return; // allow upgrade
        }*/

        private void OnEntityBuilt(Planner planner, UnityEngine.GameObject gameObject)
        {
            var player = planner.GetOwnerPlayer();
            if (player != null && !player.CanBuild() || !HasAnyPerm(player)) return;

            var buildingBlock = gameObject.GetComponent<BuildingBlock>();
            if (buildingBlock == null) return;

            var steamId = player.UserIDString;
            var pgrade = PlayerGrade(steamId, false);
            var buildingGrade = (int)buildingBlock.grade;

            if (pgrade > 0)
            {
                if (!HasPerm(steamId, "all") && !HasPerm(steamId, pgrade.ToString())) return;

                var result = Interface.CallHook("CanAutoGrade", player, pgrade, buildingBlock, planner);
                if (result is int)
                {
                    if ((int)result == 0 && !block || (int)result < 0) return;
                    if (buildingBlock.blockDefinition.grades[buildingGrade])
                    {
                        var items = buildingBlock.blockDefinition.grades[buildingGrade].costToBuild;
                        foreach (var itemAmount in items)
                        {
                            player.Command("note.inv", itemAmount.itemid, (int)itemAmount.amount);
                            player.inventory.GiveItem(ItemManager.CreateByItemID(itemAmount.itemid, (int)itemAmount.amount), player.inventory.containerMain);
                        }
                    }
                    gameObject.GetComponent<BaseEntity>().KillMessage();
                    return;
                }

                if (!HasPerm(steamId, "nores"))
                {
                    var amount = 0;
                    if (pgrade > buildingGrade && buildingBlock.blockDefinition.grades[pgrade])
                    {
                        var items = buildingBlock.blockDefinition.grades[buildingGrade].costToBuild;
                        if (!CanAffordToUpgrade(player, pgrade, buildingBlock))
                        {
                            if (!block)
                            {
                                player.ChatMessage(GetMessage("BGRADE_NORES2", steamId));
                                return;
                            }

                            foreach (var itemAmount in items)
                            {
                                player.Command("note.inv", itemAmount.itemid, (int)itemAmount.amount);
                                player.inventory.GiveItem(ItemManager.CreateByItemID(itemAmount.itemid, (int)itemAmount.amount), player.inventory.containerMain);
                            }
                            gameObject.GetComponent<BaseEntity>().KillMessage();
                            player.ChatMessage(GetMessage("BGRADE_NORES", steamId));
                        }
                        else
                        {
                            buildingBlock.SetGrade((BuildingGrade.Enum)pgrade);
                            buildingBlock.UpdateSkin();
                            buildingBlock.SetHealthToMax();
                            buildingBlock.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                            Interface.CallHook("OnStructureUpgrade", buildingBlock, player, (BuildingGrade.Enum)pgrade);
                            UpdateTimer(player);

                            var items2 = buildingBlock.blockDefinition.grades[pgrade].costToBuild;
                            var items3 = new List<Item>();

                            foreach (var itemAmount in items2)
                            {
                                amount = (int)Math.Ceiling(itemAmount.amount);
                                player.inventory.Take(items3, itemAmount.itemid, amount);
                                player.Command("note.inv", itemAmount.itemid, amount * -1f);
                            }
                        }
                    }
                }
                else
                {
                    buildingBlock.SetGrade((BuildingGrade.Enum)pgrade);
                    buildingBlock.UpdateSkin();
                    buildingBlock.SetHealthToMax();
                    buildingBlock.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                    UpdateTimer(player);
                }
            }
        }

        #region Commands

        private void BuildGradeCommand(IPlayer player, string command, string[] args)
        {
            var basePlayer = player.Object as BasePlayer;
            if (basePlayer == null)
            {
                player.Reply($"Command '{command}' can only be used by players", command);
                return;
            }

            if (!basePlayer.CanBuild() || !HasAnyPerm(basePlayer))
            {
                player.Reply(GetMessage("BGRADE_NOPERM", player.Id));
                return;
            }

            var chatmsg = new List<string>();
            if (args.Length > 0)
            {
                switch (args[0])
                {
                    case "1":
                    case "2":
                    case "3":
                    case "4":
                        if (!HasPerm(player.Id, "all") && !HasPerm(player.Id, args[0]))
                        {
                            player.Reply(GetMessage("BGRADE_NOPERM", player.Id));
                            return;
                        }

                        var pgrade = PlayerGrade(player.Id);
                        playerGrades[player.Id].Grade = Convert.ToInt32(args[0]);
                        chatmsg.Add(string.Format(GetMessage("BGRADE_SET", player.Id), GetMessage(((BuildingGrade.Enum)playerGrades[player.Id].Grade).ToString(), player.Id)));
                        if (allow_timer)
                        {
                            var ptimer = PlayerTimer(player.Id);
                            if (ptimer > 0)
                            {
                                chatmsg.Add(string.Format(GetMessage("BGRADE_TIME", player.Id), ptimer + " " + GetMessage("BGRADE_SEC", player.Id)));
                                UpdateTimer(basePlayer);
                            }
                        }
                        break;

                    case "0":
                        playerGrades.Remove(player.Id);
                        chatmsg.Add(GetMessage("BGRADE_DIS", player.Id));
                        break;

                    case "t":
                        if (args.Length > 1 && allow_timer)
                        {
                            var vtimer = Convert.ToInt32(args[1]);
                            if (vtimer < 0) vtimer = 0;
                            var ptimer = PlayerGrade(player.Id);
                            playerGrades[player.Id].Timer = vtimer;
                            if (vtimer > 0)
                                chatmsg.Add(string.Format(GetMessage("BGRADE_SET_TIMER", player.Id), vtimer + " " + GetMessage("BGRADE_SEC", player.Id)));
                            else
                                chatmsg.Add(GetMessage("BGRADE_DIS_TIMER", player.Id));
                        }
                        else
                            chatmsg.Add(GetMessage("BGRADE_INV", player.Id));
                        break;

                    default:
                        chatmsg.Add(GetMessage("BGRADE_INV", player.Id));
                        break;
                }
            }
            else
            {
                var pgrade = PlayerGrade(player.Id, false);
                chatmsg.Add(GetMessage("BGRADE_HELP", player.Id) + "\n");
                var all = HasPerm(player.Id, "all");
                if (all || HasPerm(player.Id, "1")) chatmsg.Add(string.Format(GetMessage("BGRADE_1", player.Id), cmdname));
                if (all || HasPerm(player.Id, "2")) chatmsg.Add(string.Format(GetMessage("BGRADE_2", player.Id), cmdname));
                if (all || HasPerm(player.Id, "3")) chatmsg.Add(string.Format(GetMessage("BGRADE_3", player.Id), cmdname));
                if (all || HasPerm(player.Id, "4")) chatmsg.Add(string.Format(GetMessage("BGRADE_4", player.Id), cmdname));
                chatmsg.Add(string.Format(GetMessage("BGRADE_0", player.Id), cmdname));
                if (allow_timer) chatmsg.Add(string.Format(GetMessage("BGRADE_T", player.Id), cmdname));
                var curtxt = ((BuildingGrade.Enum)pgrade).ToString();
                if (pgrade == 0) curtxt = "Disabled";
                var msg = string.Format(GetMessage("BGRADE_CUR", player.Id), GetMessage(curtxt, player.Id));
                if (allow_timer)
                {
                    var ptimer = PlayerTimer(player.Id, false);
                    curtxt = (ptimer > 0 ? ptimer + " " + GetMessage("BGRADE_SEC", player.Id) : "Disabled");
                    msg += string.Format(GetMessage("BGRADE_CURT", player.Id), GetMessage(curtxt, player.Id));
                }
                chatmsg.Add("\n" + msg);
            }
            player.Reply(string.Join("\n", chatmsg.ToArray()));
        }

        #endregion
    }
}


// --- End of file: AutoGrades.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Recycle.cs ---
// --- Original Local Path: Recycle.cs ---

﻿using System;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core;
using System.Text;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Recycle", "Calytic", "2.0.8", ResourceId = 1296)]
    [Description("Recycle crafted items to base resources")]
    class Recycle : RustPlugin
    {
        #region Configuration

        private float cooldownMinutes;
        private float refundRatio;
        private string box;
        private bool npconly;
        private List<object> npcids;
        private float radiationMax;

        #endregion

        #region State

        private Dictionary<string, DateTime> recycleCooldowns = new Dictionary<string, DateTime>();

        class OnlinePlayer
        {
            public BasePlayer Player;
            public BasePlayer Target;
            public StorageContainer View;
            public List<BasePlayer> Matches;

            public OnlinePlayer(BasePlayer player)
            {
            }
        }

        public Dictionary<ItemContainer, ulong> containers = new Dictionary<ItemContainer,ulong>();

        [OnlinePlayers]
        Hash<BasePlayer, OnlinePlayer> onlinePlayers = new Hash<BasePlayer, OnlinePlayer>();

        #endregion

        #region Initialization

        protected override void LoadDefaultConfig()
        {
            Config["Settings","box"] = "assets/prefabs/deployable/woodenbox/woodbox_deployed.prefab";
            Config["Settings","cooldownMinutes"] = 5;
            Config["Settings","refundRatio"] = 0.5f;
            Config["Settings", "radiationMax"] = 1;
            Config["Settings", "NPCOnly"] = false;
            Config["Settings", "NPCIDs"] = new List<object>();
            Config["VERSION"] = Version.ToString();
        }

        void Unloaded()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                OnlinePlayer onlinePlayer;
                if (onlinePlayers.TryGetValue(player, out onlinePlayer) && onlinePlayer.View != null)
                {
                    CloseBoxView(player, onlinePlayer.View);
                }
            }
        }

        void Init()
        {
            Unsubscribe(nameof(CanNetworkTo));
        }

        void Loaded()
        {
            permission.RegisterPermission("recycle.use", this);
            LoadMessages();
            CheckConfig();

            cooldownMinutes = GetConfig("Settings","cooldownMinutes", 5f);
            box = GetConfig("Settings","box", "assets/prefabs/deployable/woodenbox/box_wooden.item.prefab");
            refundRatio = GetConfig("Settings", "refundRatio", 0.5f);
            radiationMax = GetConfig("Settings", "radiationMax", 1f);

            npconly = GetConfig("Settings", "NPCOnly", false);
            npcids = GetConfig("Settings", "NPCIDs", new List<object>());
        }

        void CheckConfig()
        {
            if (Config["VERSION"] == null)
            {
                // FOR COMPATIBILITY WITH INITIAL VERSIONS WITHOUT VERSIONED CONFIG
                ReloadConfig();
            }
            else if (GetConfig<string>("VERSION", "") != Version.ToString())
            {
                // ADDS NEW, IF ANY, CONFIGURATION OPTIONS
                ReloadConfig();
            }
        }

        protected void ReloadConfig()
        {
            Config["VERSION"] = Version.ToString();

            // NEW CONFIGURATION OPTIONS HERE
            Config["Settings", "NPCOnly"] = false;
            Config["Settings", "NPCIDs"] = new List<object>();
            Config["Settings", "radiationMax"] = GetConfig("Settings", "radiationMax", 1f);
            // END NEW CONFIGURATION OPTIONS

            PrintToConsole("Upgrading configuration file");
            SaveConfig();
        }

        void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Recycle: Complete", "Recycling <color=lime>{0}</color> to {1}% base materials:"},
                {"Recycle: Item", "    <color=lime>{0}</color> X <color=yellow>{1}</color>"},
                {"Recycle: Invalid", "Cannot recycle that!"},
                {"Denied: Permission", "You lack permission to do that"},
                {"Denied: Privilege", "You lack permission to do that"},
                {"Denied: Swimming", "You cannot do that while swimming"},
                {"Denied: Falling", "You cannot do that while falling"},
                {"Denied: Wounded", "You cannot do that while wounded"},
                {"Denied: Irradiated", "You cannot do that while irradiated"},
                {"Denied: Generic", "You cannot do that right now"},
                {"Cooldown: Seconds", "You are doing that too often, try again in a {0} seconds(s)."},
                {"Cooldown: Minutes", "You are doing that too often, try again in a {0} minute(s)."},
            }, this);
        }

        private bool IsBox(BaseNetworkable entity)
        {
            foreach (KeyValuePair<BasePlayer, OnlinePlayer> kvp in onlinePlayers)
            {
                if (kvp.Value.View != null && kvp.Value.View.net.ID == entity.net.ID)
                {
                    return true;
                }
            }

            return false;
        }

        #endregion

        #region Oxide Hooks

        object CanNetworkTo(BaseNetworkable entity, BasePlayer target)
        {
            if (entity == null || target == null || entity == target) return null;
            if (target.IsAdmin) return null;

            OnlinePlayer onlinePlayer;
            bool IsMyBox = false;
            if (onlinePlayers.TryGetValue(target, out onlinePlayer))
            {
                if (onlinePlayer.View != null && onlinePlayer.View.net.ID == entity.net.ID)
                {
                    IsMyBox = true;
                }
            }

            if (IsBox(entity) && !IsMyBox) return false;

            return null;
        }

        void OnPlayerInit(BasePlayer player)
        {
            onlinePlayers[player].View = null;
            onlinePlayers[player].Target = null;
            onlinePlayers[player].Matches = null;
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            if (onlinePlayers[player].View != null) {
                CloseBoxView(player, onlinePlayers[player].View);
            }
        }

        void OnPlayerLootEnd(PlayerLoot inventory) {
            BasePlayer player;
            if ((player = inventory.GetComponent<BasePlayer>()) == null)
                return;

            OnlinePlayer onlinePlayer;
            if (onlinePlayers.TryGetValue(player, out onlinePlayer) && onlinePlayer.View != null)
            {
                if (onlinePlayer.View == inventory.entitySource)
                {
                    CloseBoxView(player, (StorageContainer)inventory.entitySource);
                }
            }
        }

        void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            if (container.playerOwner is BasePlayer)
            {
                if (onlinePlayers.ContainsKey(container.playerOwner))
                {
                    BasePlayer owner = container.playerOwner;
                    if (containers.ContainsKey(container))
                    {
                        if (SalvageItem(owner, item))
                        {
                            item.Remove(0f);
                            item.RemoveFromContainer();
                        }
                        else
                        {
                            ShowNotification(owner, GetMsg("Recycle: Invalid", owner));
                            item.MoveToContainer(owner.inventory.containerMain);
                        }
                    }
                }
            }
        }

        void OnUseNPC(BasePlayer npc, BasePlayer player)
        {
            if (!npcids.Contains(npc.UserIDString)) return;
            ShowBox(player, player);
        }

        #endregion

        #region Commands

        [ConsoleCommand("rec")]
        void ccRec(ConsoleSystem.Arg arg)
        {
            cmdRec(arg.Connection.player as BasePlayer, arg.cmd.Name, arg.Args);
        }

        [ChatCommand("rec")]
        void cmdRec(BasePlayer player, string command, string[] args)
        {
            if (npconly) return;
            
            ShowBox(player, player);
        }

        #endregion

        #region Core Methods

        void ShowBox(BasePlayer player, BaseEntity target)
        {
            string playerID = player.userID.ToString();

            if (!CanPlayerRecycle(player))
                return;

            if (cooldownMinutes > 0 && !player.IsAdmin)
            {
                DateTime startTime;

                if (recycleCooldowns.TryGetValue(playerID, out startTime))
                {
                    DateTime endTime = DateTime.Now;

                    TimeSpan span = endTime.Subtract(startTime);
                    if (span.TotalMinutes > 0 && span.TotalMinutes < Convert.ToDouble(cooldownMinutes))
                    {
                        double timeleft = System.Math.Round(Convert.ToDouble(cooldownMinutes) - span.TotalMinutes, 2);
                        if (span.TotalSeconds < 0)
                        {
                            recycleCooldowns.Remove(playerID);
                        }

                        if (timeleft < 1)
                        {
                            double timelefts = System.Math.Round((Convert.ToDouble(cooldownMinutes) * 60) - span.TotalSeconds);
                            SendReply(player, string.Format(GetMsg("Cooldown: Seconds", player), timelefts.ToString()));
                            return;
                        }
                        else
                        {
                            SendReply(player, string.Format(GetMsg("Cooldown: Minutes", player), System.Math.Round(timeleft).ToString()));
                            return;
                        }
                    }
                    else
                    {
                        recycleCooldowns.Remove(playerID);
                    }
                }
            }

            if(!recycleCooldowns.ContainsKey(player.userID.ToString())) {
                recycleCooldowns.Add(player.userID.ToString(), DateTime.Now);
            }
            var ply = onlinePlayers[player];
            if (ply.View == null)
            {
                OpenBoxView(player, target);
                return;
            }

            CloseBoxView(player, ply.View);
            timer.In(1f, () => OpenBoxView(player, target));
        }

        void HideBox(BasePlayer player)
        {
            player.EndLooting();
            var ply = onlinePlayers[player];
            if (ply.View == null)
            {
                return;
            }

            CloseBoxView(player, ply.View);
        }

        void OpenBoxView(BasePlayer player, BaseEntity targArg)
        {
            Subscribe(nameof(CanNetworkTo));

            var pos = new Vector3(player.transform.position.x, player.transform.position.y-0.6f, player.transform.position.z);
            int slots = 1;
            var view = GameManager.server.CreateEntity(box,pos) as StorageContainer;
            view.transform.position = pos;


            if (!view) return;

            player.EndLooting();
            if(targArg is BasePlayer) {
                BasePlayer target = targArg as BasePlayer;
                ItemContainer container = new ItemContainer();
                container.playerOwner = player;
                container.ServerInitialize((Item) null, slots);
                if ((int) container.uid == 0)
                    container.GiveUID();
                

                if(!this.containers.ContainsKey(container)) {
                    this.containers.Add(container, player.userID);
                }

                view.enableSaving = false;
                view.Spawn();
                view.inventory = container;
                view.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                onlinePlayers[player].View = view;
                onlinePlayers[player].Target = target;
                timer.Once(0.1f, delegate() {
                    view.PlayerOpenLoot(player);
                });
                
            }
        }

        void CloseBoxView(BasePlayer player, StorageContainer view)
        {
            OnlinePlayer onlinePlayer;
            if (!onlinePlayers.TryGetValue(player, out onlinePlayer)) return;
            if (onlinePlayer.View == null) return;

            if(containers.ContainsKey(view.inventory)) {
                containers.Remove(view.inventory);
            }

            player.inventory.loot.containers = new List<ItemContainer>();
            view.inventory = new ItemContainer();

            if (player.inventory.loot.IsLooting()) {
                player.SendConsoleCommand("inventory.endloot", null);
            }


            onlinePlayer.View = null;
            onlinePlayer.Target = null;

            view.KillMessage();

            if (onlinePlayers.Values.Count(p => p.View != null) <= 0)
            {
                Unsubscribe(nameof(CanNetworkTo));
            }
        }

        bool SalvageItem(BasePlayer player, Item item)
        {
            var sb = new StringBuilder();

            var ratio = item.hasCondition ? (item.condition / item.maxCondition) : 1;

            sb.Append(string.Format(GetMsg("Recycle: Complete", player), item.info.displayName.english, (refundRatio * 100)));

            if(item.info.Blueprint == null) {
                return false;
            }

            foreach (var ingredient in item.info.Blueprint.ingredients)
            {
                var refundAmount = (double)ingredient.amount / item.info.Blueprint.amountToCreate;
                refundAmount *= item.amount;
                refundAmount *= ratio;
                refundAmount *= refundRatio;
                refundAmount = System.Math.Ceiling(refundAmount);
                if (refundAmount < 1) refundAmount = 1;

                var newItem = ItemManager.Create(ingredient.itemDef, (int)refundAmount);

                ItemBlueprint ingredientBp = ingredient.itemDef.Blueprint;
                if (item.hasCondition) newItem.condition = (float)System.Math.Ceiling(newItem.maxCondition * ratio);

                player.GiveItem(newItem);
                sb.AppendLine();
                sb.Append(string.Format(GetMsg("Recycle: Item", player), newItem.info.displayName.english, newItem.amount));
            }

            ShowNotification(player, sb.ToString());

            return true;
        }

        bool CanPlayerRecycle(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, "recycle.use"))
            {
                SendReply(player, GetMsg("Denied: Permission", player));
                return false;
            }

            if (!player.CanBuild())
            {
                SendReply(player, GetMsg("Denied: Privilege", player));
                return false;
            }
            if (radiationMax > 0 && player.radiationLevel > radiationMax)
            {
                SendReply(player, GetMsg("Denied: Irradiated", player));
                return false;
            }
            if (player.IsSwimming())
            {
                SendReply(player, GetMsg("Denied: Swimming", player));
                return false;
            }
            if (!player.IsOnGround())
            {
                SendReply(player, GetMsg("Denied: Falling", player));
                return false;
            }
            if (player.IsFlying)
            {
                SendReply(player, GetMsg("Denied: Falling", player));
                return false;
            }
            if (player.IsWounded())
            {
                SendReply(player, GetMsg("Denied: Wounded", player));
                return false;
            }

            var canRecycle = Interface.Call("CanRecycleCommand", player);
            if (canRecycle != null)
            {
                if (canRecycle is string)
                {
                    SendReply(player, Convert.ToString(canRecycle));
                }
                else
                {
                    SendReply(player, GetMsg("Denied: Generic", player));
                }
                return false;
            }

            return true;
        }

        #endregion

        #region GUI

        public string jsonNotify = @"[{""name"":""NotifyMsg"",""parent"":""Overlay"",""components"":[{""type"":""UnityEngine.UI.Image"",""color"":""0 0 0 0.89""},{""type"":""RectTransform"",""anchormax"":""0.99 0.94"",""anchormin"":""0.69 0.77""}]},{""name"":""MassText"",""parent"":""NotifyMsg"",""components"":[{""type"":""UnityEngine.UI.Text"",""text"":""{msg}"",""fontSize"":16,""align"":""UpperLeft""},{""type"":""RectTransform"",""anchormax"":""0.98 0.99"",""anchormin"":""0.01 0.02""}]},{""name"":""CloseButton{1}"",""parent"":""NotifyMsg"",""components"":[{""type"":""UnityEngine.UI.Button"",""color"":""0.95 0 0 0.68"",""close"":""NotifyMsg"",""imagetype"":""Tiled""},{""type"":""RectTransform"",""anchormax"":""0.99 1"",""anchormin"":""0.91 0.86""}]},{""name"":""CloseButtonLabel"",""parent"":""CloseButton{1}"",""components"":[{""type"":""UnityEngine.UI.Text"",""text"":""X"",""fontSize"":5,""align"":""MiddleCenter""},{""type"":""RectTransform"",""anchormax"":""1 1"",""anchormin"":""0 0""}]}]";

        public void ShowNotification(BasePlayer player, string msg)
        {
            this.HideNotification(player);
            string send = jsonNotify.Replace("{msg}", msg);

            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", send);
            timer.Once(3f, delegate()
            {
                this.HideNotification(player);
            });
        }

        public void HideNotification(BasePlayer player)
        {
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "NotifyMsg");
        }

        #endregion

        #region HelpText
        private void SendHelpText(BasePlayer player)
        {
            var sb = new StringBuilder()
               .Append("Recycle by <color=#ce422b>http://rustservers.io</color>\n")
               .Append("  ").Append("<color=\"#ffd479\">/rec</color> - Open recycle box").Append("\n");
            player.ChatMessage(sb.ToString());
        }
        #endregion

        #region Helper methods

        string GetMsg(string key, BasePlayer player = null)
        {
            return lang.GetMessage(key, this, player == null ? null : player.UserIDString);
        }

        private T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null)
            {
                return defaultValue;
            }

            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

        private T GetConfig<T>(string name, string name2, T defaultValue)
        {
            if (Config[name, name2] == null)
            {
                return defaultValue;
            }

            return (T)Convert.ChangeType(Config[name, name2], typeof(T));
        }

        #endregion
    }
}

// --- End of file: Recycle.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/InstantSmelt.cs ---
// --- Original Local Path: InstantSmelt.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Instant Smelt", "Orange", "2.0.5")]
    [Description("Smelt resources as soon as they are mined")]
    public class InstantSmelt : RustPlugin
    {
        #region Vars

        private const string permUse = "instantsmelt.use";
        private const string charcoalItemName = "charcoal";
        private const string woodItemName = "wood";

        #endregion
        
        #region Oxide Hooks

        private void Init()
        {
            permission.RegisterPermission(permUse, this);
            cmd.AddChatCommand(config.command, this, nameof(cmdToggleChat));
            LoadData();
        }

        private void Unload()
        {
            SaveData();
        }

        private object OnCollectiblePickup(Item item, BasePlayer player)
        {
            return OnGather(player, item, false, true);
        }
        
        private object OnDispenserGather(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            return OnGather(player, item);
        }
        
        private object OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            return OnGather(player, item, true);
        }

        #endregion

        #region Commands

        private void cmdToggleChat(BasePlayer player)
        {
            if (HasPermission(player) == false)
            {
                Message(player, "Permission");
                return;
            }

            var key = string.Empty;
            
            if (data.Contains(player.userID))
            {
                key = "Enabled";
                data.Remove(player.userID);
            }
            else
            {
                key = "Disabled";
                data.Add(player.userID);
            }
            
            Message(player, key);
        }

        #endregion

        #region Core

        private object OnGather(BasePlayer player, Item item, bool bonus = false, bool pickup = false)
        {
            var perm = HasPermission(player);
            if (perm == false)
            {
                return null;
            }

            if (data.Contains(player.userID))
            {
                return null;
            }

            var shortname = item.info.shortname;
            if (config.blackList.Contains(shortname))
            {
                return null;
            }

            var newItem = (Item) null;
            
            if (shortname == woodItemName)
            {
                newItem = ItemManager.CreateByName(charcoalItemName, item.amount);
            }
            else
            {
                var cookable = item.info.GetComponent<ItemModCookable>();
                if (cookable == null) {return null;}
                newItem = ItemManager.Create(cookable.becomeOnCooked, item.amount);
            }
            
            NextTick(() =>
            {
                newItem.amount = item.amount;
                item.GetHeldEntity()?.Kill();
                item.DoRemove();

                if (bonus == false)
                {
                    player.GiveItem(newItem, BaseEntity.GiveItemReason.ResourceHarvested);
                }
            });
                
            return pickup ? null : newItem;
        }

        private bool HasPermission(BasePlayer player)
        {
            return permission.UserHasPermission(player.UserIDString, permUse);
        }

        #endregion
        
        #region Configuration 1.1.0

        private static ConfigData config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Command")]
            public string command;

            [JsonProperty(PropertyName = "A. Blacklist")]
            public List<string> blackList;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                command = "ismelt",
                blackList = new List<string>
                {
                    "shortname here",
                    "another shortname"
                }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintError("Configuration file is corrupt! Unloading plugin...");
                Interface.Oxide.RootPluginManager.RemovePlugin(this);
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
        
        #region Data 1.0.0

        private const string filename = "Temp/InstantSmelt/Playes";
        private List<ulong> data = new List<ulong>();

        private void LoadData()
        {
            try
            {
                data = Interface.Oxide.DataFileSystem.ReadObject<List<ulong>>(filename);
            }
            catch (Exception e)
            {
                PrintWarning(e.Message);
            }

            SaveData();
            timer.Every(Core.Random.Range(500, 700f), SaveData);
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(filename, data);
        }

        #endregion
        
        #region Localization 1.1.1
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Permission", "You don't have permission to use that!"},
                {"Enabled", "You enabled instant smelt!"},
                {"Disabled", "You disabled instant smelt!"},
            }, this);
        }

        private void Message(BasePlayer player, string messageKey, params object[] args)
        {
            if (player == null)
            {
                return;
            }

            var message = GetMessage(messageKey, player.UserIDString, args);
            player.ChatMessage(message);
        }

        private string GetMessage(string messageKey, string playerID, params object[] args)
        {
            return string.Format(lang.GetMessage(messageKey, this, playerID), args);
        }

        #endregion
    }
}

// --- End of file: InstantSmelt.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/EvoCop.cs ---
// --- Original Local Path: EvoCop.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Rust;
using System.Linq;
using System.Globalization;
namespace Oxide.Plugins
{
    [Info("EvoCop", "Urust", "0.0.01", ResourceId = 0)]
    class EvoCop : RustPlugin
    {
        #region Fields
        [PluginReference]
        Plugin Spawns, Craft;

        private static EvoCop ins;
        const string copPrefab = "assets/content/vehicles/minicopter/minicopter.entity.prefab";

        private bool initialized;

        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            permission.RegisterPermission("evocop.craft", this);
            lang.RegisterMessages(Messages, this);
        }

        private void OnServerInitialized()
        {
            ins = this;
            initialized = true;
        }

        private void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (!initialized || player == null) return;

        }

        #endregion

        

        #region API
        private BaseEntity SpawnAtLocation(Vector3 position, Quaternion rotation = default(Quaternion), bool enableSaving = false, bool isExternallyManaged = false, bool repairEnabled = true, bool disableFuel = false, bool disableSecurity = false, bool disableCollision = false)
        {
            BaseEntity entity = GameManager.server.CreateEntity(copPrefab, position + Vector3.up, rotation);

            entity.Spawn();

            return entity;
        }

        #endregion

        

        #region Commands
        [ChatCommand("cop")]
        void CmdSpawnCarUser(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "evocop.craft"))
            {
                SendReply(player, "У тебя нету прав использовать эту команду!");
                return;
            }

            if (configData.options.copCraft)
            {
                foreach (var ingredient in bp.ingredients)
                {
                    var playeram = player.inventory.GetAmount(ingredient.itemDef.itemid);
                    if (playeram >= ingredient.amount) continue;
                    var replyPlayer = bp.ingredients.Select(x =>
                        string.Format(msg(player.inventory.GetAmount(x.itemDef.itemid) >= x.amount
                                ? "EnoughtIngridient"
                                : "NotEnoughtIngridient"
                            , player.UserIDString), x.itemDef.displayName.translated, player.inventory.GetAmount(x.itemDef.itemid),
                            x.amount)).ToArray();
                    SendReply(player, Messages["Noingridient"], string.Join("\n", replyPlayer));
                    return;
                }
                List<Item> items = new List<Item>();
                ItemCrafter itemCrafter = player.inventory.crafting;

                foreach (var ingridient in bp.ingredients)
                {
                    var amount = (int)ingridient.amount;
                    foreach (var container in itemCrafter.containers)
                    {
                        amount -= container.Take(items, ingridient.itemid, amount);
                        if (amount > 0)
                            continue;
                        break;
                    }
                }
            }

            Vector3 position = player.transform.position + (player.transform.forward * 3);
            RaycastHit hit;
            if (Physics.SphereCast(player.eyes.position, 0.1f, Quaternion.Euler(player.serverInput.current.aimAngles) * Vector3.forward, out hit, 20f))
                position = hit.point;
                        SpawnAtLocation(position, new Quaternion());
        }

        #endregion


        #region Config
        private ConfigData configData;
        private ItemBlueprint bp;
        private ItemDefinition def;
        class ConfigData
        {
            [JsonProperty(PropertyName = "Options")]
            public Options options { get; set; }
            public class Options
            {
                [JsonProperty(PropertyName = "Включить крафт minicopter за ресурсы?")]
                public bool copCraft { get; set; }
                [JsonProperty(PropertyName = "Ресурсы для крафта minicopter (ShortName - Amount)")]
                public Dictionary<string, int> CraftItems = new Dictionary<string, int>();
            }
            public Oxide.Core.VersionNumber Version { get; set; }
        }
            public int Amount = 1;
            protected override void LoadConfig()
            {
                base.LoadConfig();
                configData = Config.ReadObject<ConfigData>();

                if (configData.Version < Version)
                    UpdateConfigValues();

                Config.WriteObject(configData, true);

                var ingridients = new List<ItemAmount>();
                var defs = ItemManager.GetItemDefinitions();

                foreach (var item in configData.options.CraftItems)
                {
                    def = defs.FirstOrDefault(x =>
                        x.displayName.english == item.Key || x.shortname == item.Key || x.itemid.ToString() == item.Key);
                    if (!def)
                    {
                        PrintWarning(Messages["Nodef"], item.Key);
                        continue;
                    }
                    ingridients.Add(new ItemAmount(def, item.Value));
                }

                def = ItemManager.FindItemDefinition("workbench3");
                if (!def)
                {
                    PrintError("Unable to find the quarry defenition! The plugin can't work at all.\nPlease contact the developer");
                    Interface.Oxide.UnloadPlugin(Title);
                }
                bp = def.Blueprint;
                if (bp != null)
                {
                    var reply = 70;
                    if (reply == 0) { }
                    bp = def.gameObject.AddComponent<ItemBlueprint>();
                    bp.ingredients = ingridients;
                    bp.defaultBlueprint = false;
                    bp.userCraftable = true;
                    bp.isResearchable = false;
                    bp.amountToCreate = Amount;
                    bp.scrapRequired = 750;
                    bp.blueprintStackSize = 1;
                }
            }
        protected override void LoadDefaultConfig() => configData = GetBaseConfig();
        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                options = new ConfigData.Options
                {
                    copCraft = true,
                    CraftItems = new Dictionary<string, int>()
                    {
                        ["scrap"] = 1000,
                        ["metal.refined"] = 100,
                        ["gears"] = 25,
                        ["sheetmetal"] = 25,
                        ["metalspring"] = 15
                    }

                },

                Version = Version
            };
        }
        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion

        #region Localization
        string msg(string key, string playerId = null) => lang.GetMessage(key, this, playerId);

        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["Nodef"] = "Не найдено определение предмета {0}. Он не будет добавлен к цене крафта.",
            ["nopermission"] = "<color=#D3D3D3>У вас нет разрешения на управление MiniCopter</color>",
            ["EnoughtIngridient"] = "{0} - <color=#53f442>{1}</color>/{2}",
            ["NotEnoughtIngridient"] = "{0} - <color=#f44141>{1}</color>/{2}",
            ["Noingridient"] = "Не хватает ресурсов для крафта:\n{0}"

        };
        #endregion
    }
}



// --- End of file: EvoCop.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ChatPlus.cs ---
// --- Original Local Path: ChatPlus.cs ---

﻿//#define RUST
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using System.Text.RegularExpressions;
using ConVar;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("ChatPlus", "RustPlugin.ru - Developed by Vlad-00003", "1.4.0", ResourceId = 82)]
    public class ChatPlus : CovalencePlugin
    {
        /*  covalence.FormatText(msg);
         *  Formatter.ToPlaintext(msg);
         *  Original autor: Unknown
         *  Editor: Vlad-00003
         *  Editor info:
         *    E-mail: Vlad-00003@mail.ru
         *    Vk: vk.com/vlad_00003
         * v1.1.0
         *   Добавлены команды:
         *     chatplus.message {steamid/ник} привилегия
         *     chatplus.name {steamid/ник} привилегия
         *     chatplus.prefix {steamid/ник} привилегия
         *       Данные команды лишь УСТАНАВЛИВАЮТ префикс\цвета игроку. Для использования необходимо выдать игроку 
         *       привилегии. Без привилегий команды работать НЕ будут.
         *       Для использования из консоли игрока требуется привилегия на присваивание префикса и цветов (chatplus.assign)
         *   Добавлена возможноть выдавать мут\использовать команды присваивания цветов\префика игрокам, не находящимся на сервере.
         *   Добавлена комманда mutelist - выводит список текущик игроков, у которых заблокирован чат.
         *   При отключении чата игроку сохраняется не только время, а так же то, кто заблокировал игроку чат и причина,
         *   что полностью отражается как в чате и заблокированного, так и при команде mutelist
         *   Отныне при использовании команды mute причина и время опциональны - можно заблокировать человека навсегда, но с причиной.
         *   Примеры:
         *     "mute vlad" - блокировать игроку чат на всегда. Причина - Not specified
         *     "mute vlad 1d" - блокировать чат игроку на 1 день. Причина - Not specified
         *     "mute vlad Просто потому что я так решил." - блокировать чат игроку навсегда. Причина - "Просто потому что я так решил."
         *     "mute vlad 1d Это весомоя причина" - блокировать чат игроку на 1 день. Причина - "Это весомоя причина"
         *   Разделены привилегии на использование команд mute/unmute на две разные привилегии - chatplus.mute и chatplus.unmute соответственно.
         *   Небольшая чистка и оптимизация кода.
         * V1.1.1
         *   Стандартная причина мута (если не указана) выведена в файл конфигурации
         * v1.1.2
         *   Добавлен API - private void API_RegisterThirdPartyTitle(Plugin plugin, Func<IPlayer, string> titleGetter)
         * V1.1.3
         *   Удалена ненужная проверка
         * V1.2.0
         *   Плагин переведён на тип Covalence - Теперь он может работать не только в Rust-е. Требуется проверка на других играх.
         *     Так же теперь плагин поддерживает стандартизированное форматирование ([#HEXCOLOR][/#] [+SIZE][/+])
         *   Исправлена ошибка при удалении игрока из чёрного списка - теперь сообщение о том, что игрока удалили появляется в нужное время.
         *   Если игрок указал неверный параметр в команде /chat, то ему будет выведена справка. Раньше не выводилось ничего.
         *   Если у вас возникнут ошибки при обновлении до данной версии вы можете сделать следующие - очистить BlackList у каждого игрока 
         *     в файле данных. Или просто удалите ChatPlus_Players.json из папки oxide/data.
         *   Для полной совместимости с Clans Reborn вам нужно поправить функцию OnPluginLoaded в плагине Clans:
         *   void OnPluginLoaded(Plugin plugin)
         *   {
         *       if (plugin.Title != "Better Chat" || plugin.Title != "ChatPlus") return;
         *       if (enableClanTagging) Interface.CallHook("API_RegisterThirdPartyTitle", this, new Func<IPlayer, string>(getFormattedClanTag));
         *   }
         * V1.2.1
         *   Добавлено лоигрование режимов администратора и модератора чата.
         * V1.2.2
         *   Исправлена ошибка во флаге, Rust заменено на RUST. Из-за этого даже в игре Rust использовались мультиобразные вызовы,
         *   что приводило к отсутствию звуков личных сообщений и отсутствию иконок игроков в чате
         *   Так же исправлена возможность отправлять ЛС самому себе если отображаемое имя на сервере игры RUST отличается от 
         *   фактического имени в базе
         *   Добавлен ResourceId
         * V1.3.0
         *   Добавлена возможность использовать PM через консоль и отвечать через r. 
         *     Теперь вы можете отправлять личные сообщения игрокам из консоли, а они могут вам отвечать!
         *   Исправлена ошибка в языковых файлах. Команд присваивания префикса\цветов имён\сообщений в чате
         *   Полностью переписаны языковые файл (Изменён принцип форматирования на стандартизированное представление):
         *     <color=#HEX></color> заменено на [#HEX][/#] и <size=N></size> заменено на [+N][/+]
         *   Удалите ваши старые языковые файлы и перезапустите плагин. 
         *   Данное действие ОБЯЗАТЕЛЬНО!
         *   Добавлены новые строки файла конфигурации(пересоздавать ничего не нужно - 
         *     они автоматически будут добавлены в конфиг при первом запуске обновлённой версии):
         *      M. Имя консоли при отправке личных сообщений и отключении чата из консоли
         *      N. Формат отправки сообщений из консоли командой say
         *  Имя консоли это то имя, которые будет выводиться при блокировке чата из консоли сервера.
         *  Так же теперь изменению подверглась команда global.say, которую, помимо консоли, могут вызывать администраторы из консоли игры:
         *    Теперь вы можете настроить формат вывода сообщений в чат при использовании данной команды!
         *    {0} - Это имя консоли, из пераметра выше. {1} - само сообщение.
         * V1.3.1
         *   Добавлена возможность отображение аватарок игрока при отправке личного сообщения(ТОЛЬКО Rust!)
         * V1.3.2
         *   Переделана система логгирования, теперь так же ведётся лог личных сообщений(что крайне мешает когда ты переписываешься через консоль
         *     я подумаю как это сделать красивее).
         *   Оптимизация функций, отвечающих за отображение иконок в личных переписках.
         *   Проверка на консоль сервера вынесена отдельно
         * V1.3.3
         *   Теперь в списках имён\префиксов\цветов сообщений отображается default, дабы игрок мог вернуть цвет к стандарту без команды /chat reset
         * v1.3.4
         *   Исправление v1.3.3 - теперь default видят только те, у кого на данный момент выбран не стандартный цвет\префикс
         * v1.3.5
         *   Добавлено верное форматирование в функцию BroadcastChat - вывод сообщений в чат о мутах. Теперь она так же поддерживает стандартизированное форматирование.
         * v1.3.6
         *   Теперь верно получается языковой файл справки о команде /chat
		 * v1.3.7
		 *   Попытка исправить NRE в SendChat при вызове SendConsoleCommand
         * v1.3.71
         *   Убрана устаревшая функция Reply, принимающая как аргумент BasePlayer, упрощён доступ к данным пользователя в команде /chat
         * v1.3.8
         *   Добавлена возможность скрывать имя администратора, который заблокировал доступ к чату.
         * v1.3.9
         *   Добавлен API IsPlayerMuted(object ID) - вернёт true если игроку недоступен чат
         *   Добавлен хук OnChatPlusMessage(Dictionary<string,object> dict), доступные параметры:
         *     ["Player"] - Iplayer - игрок, написавший в чат
         *     ["Message"] - string - его сообщение в чат
         *     ["CensoredMessage"] - string - версия его сообщения с цензурой
         *     ["Prefixes"] - string - все префиксы игрока, разделённые одним пробелом.
         * v1.3.10
         *   Исправил ошибку в хуке
         * v1.3.11
         *   Добавлена новая строка в языковой файл - сообщение о том, что игрока нет в чёрном списке при использовании /chat ignore remove <name>
         *   Исправлена ошибка, по которой сообщение в чат могло отправляться игроку, которого нет на сервере, что приводило к сбоям в работе плагина.
         *   Проверка IsServerConsole по ID игрока заменена на поле IsServer класса IPlayer.
         * v1.4.0
         *   Убрана возможность форматирования текста игроками(перед форматированием сообщение очищается от тэегов)
         *   Поправлена цензура чата. Теперь если исключение находиться на нулевой позиции оно так же будет учтено.
         *   Исправлена ошибка из-за которой время блокировки чата не сохранялось при перезагрузках.
         *      Всем администраторам - пересмотрите список тех, кому блокировали чат. Возможно часть из этих блокировок уже давно должна была закончится =)
         */

        #region Global vars
        private ChatConfig config;
        private static ChatPlus m_Instance;
        private static Dictionary<string, MuteData> mutes = new Dictionary<string, MuteData>();
        private Dictionary<string, PlayerData> PlayersData = new Dictionary<string, PlayerData>();
        private PlayerData defaultData = new PlayerData();
        private bool GlobalMute = false;
        private bool HasExpired;
        private IPlayer ConsoleIPly;

        DynamicConfigFile mutes_File = Interface.Oxide.DataFileSystem.GetFile("ChatPlus_Mutes");
        DynamicConfigFile players_File = Interface.Oxide.DataFileSystem.GetFile("ChatPlus_Players");

        public static Dictionary<Plugin, Func<IPlayer, string>> ThirdPartyTitles = new Dictionary<Plugin, Func<IPlayer, string>>();
        #endregion

        #region Initialization and quiting
        void OnServerInitialized()
        {
            m_Instance = this;
            LoadMessages();
            LoadConfig();
            LoadData();
            config.RegisterPerms();
            timer.Repeat(10, 0, () =>
            {
                List<string> expired = mutes.Where(m => m.Value.Expired).Select(m => m.Key).ToList();
                foreach (string userID in expired)
                {
                    IPlayer player = players.FindPlayerById(userID.ToString());
                    if (player == null) continue;
                    mutes.Remove(userID);
                    BroadcastChat("MUTE.EXPIRED", player.Name);
                    Log(LogType.Mute, string.Format(GetMsg("MUTE.EXPIRED"), player.Name));
                    if (!HasExpired)
                        HasExpired = true;
                }
                if (HasExpired)
                {
                    SaveMutes();
                    HasExpired = false;
                }
            });
        }

        void Unload()
        {
            OnServerSave();
        }
        void OnServerSave()
        {
            SaveMutes();
            players_File.WriteObject(PlayersData.Where(p => !p.Value.Equals(defaultData)).ToDictionary(p => p.Key, p => p.Value));
        }
        private void SaveMutes()
        {
            mutes_File.WriteObject(mutes);
        }
        void LoadData()
        {
            mutes = mutes_File.ReadObject<Dictionary<string, MuteData>>();
            PlayersData = players_File.ReadObject<Dictionary<string, PlayerData>>();
        }
        #endregion

        #region Chat handling
        object OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
        {
            IPlayer sender = player.IPlayer;
            if (GlobalMute)
            {
                if (!CanMuteAll(sender))
                {
                    Reply(sender, "MUTE.ALL.DISABLED");
                    return false;
                }
            }
            
            Puts($"[{channel}] {player.displayName}[{player.userID}]: {message}");
            var pData = GetPlayerData(sender);
            if (pData.IsAdmin == true)
            {
                Log(LogType.Chat, $"[ADMIN MODE] {sender.Name}({sender.Id}): {message}");
                bool outer;
                var cens = CensorBadWords(message, out outer);
                cens = string.Format(config.adminPrivilages.AdminFormat, cens);
                message = string.Format(config.adminPrivilages.AdminFormat, message);
                SendChat(player, "", channel, message, cens);
                return false;
            }
            if (pData.IsModer == true)
            {
                Log(LogType.Chat, $"[MODERATOR MODE] {sender.Name}({sender.Id}): {message}");
                bool outer;
                var cens = CensorBadWords(message, out outer);
                cens = string.Format(config.adminPrivilages.ModerFormat, cens);
                message = string.Format(config.adminPrivilages.ModerFormat, message);
                SendChat(player, "", channel, message, cens);
                return false;
            }
            if (SpamCheck(sender, message) != null) return true;
            if (MuteCheck(sender) != null) return true;

            if (config.CapsBlock)
            {
                message = RemoveCaps(message);
            }
            message = RemoveTags(message);
            bool mute;
            var censorMessage = CensorBadWords(message, out mute);
            if (config.BadWordsBlock & mute)
            {
                Mute(sender.Id, sender.Name, new TimeSpan(0, 0, config.MuteBadWordsDefault), config.MuteReasonAutoMute, "ChatPlus");
            }
            var prefix = config.Get(config.prefixes, pData.Prefix).Format;
            var nameColor = config.Get(config.names, pData.NameColor).Format;
            var messageColor = config.Get(config.messages, pData.MessageColor).Format;

            var name = string.Format(nameColor, sender.Name);
            message = string.Format(messageColor, message);
            censorMessage = string.Format(messageColor, censorMessage);
            foreach (var thirdPartyTitle in ThirdPartyTitles)
            {
                try
                {
                    string title = thirdPartyTitle.Value(sender);

                    if (!string.IsNullOrEmpty(title))
                    {
                        prefix = title + " " + prefix;
                    }
                }
                catch (Exception ex)
                {
                    PrintError($"Error when trying to get third-party title from plugin '{thirdPartyTitle.Key.Title}'{Environment.NewLine}{ex}");
                }
            }
            Dictionary<string,object> hookDictionary = new Dictionary<string, object>()
            {
                ["Player"] = sender,
                ["Message"] = message,
                ["CensoredMessage"] = censorMessage,
                ["Prefixes"] = prefix
            };
            foreach (var plugin in plugins.GetAll())
            {
                object result = plugin.CallHook("OnChatPlusMessage", hookDictionary);
                if (result is Dictionary<string, object>)
                {
                    try
                    {
                        var dict = (Dictionary<string, object>)result;
                        sender = dict["Player"] as IPlayer;
                        message = dict["Message"] as string;
                        censorMessage = dict["CensoredMessage"] as string;
                        prefix = dict["Prefixes"] as string;
                    }
                    catch (Exception ex)
                    {
                        PrintWarning($"Plugin '{plugin.Title}({plugin.Version})' failed to modify the ChatPlus message data. Error:\n{ex.Message}");
                    }
                }
                else if(result != null)
                    return null;
            }
            if (prefix.Length > 0)
                name = $"{prefix} {name}";
            SendChat(player, name, channel, message, censorMessage, sender.Id);
            Log(LogType.Chat, $"{name}[{sender.Id}]: {message}");
            return false;
        }
        private string RemoveTags(string message)
        {
            List<string> forbiddenTags = new List<string>{
                "</color>",
                "</size>",
                "<b>",
                "</b>",
                "<i>",
                "</i>"
            };
            message = Regex.Replace(message, "(<color=.+?>)", string.Empty, RegexOptions.IgnoreCase);
            message = Regex.Replace(message, "(<size=.+?>)", string.Empty, RegexOptions.IgnoreCase);
            foreach (string tag in forbiddenTags)
                message = Regex.Replace(message, tag, string.Empty, RegexOptions.IgnoreCase);
            return Formatter.ToPlaintext(message);
        }
        string RemoveCaps(string message)
        {
            var ss = message.Split(' ');
            for (int j = 0; j < ss.Length; j++)
                for (int i = 1; i < ss[j].Length; i++)
                {
                    var sym = ss[j][i];
                    if (char.IsLower(sym)) continue;
                    ss[j] = ss[j].Remove(i, 1);
                    ss[j] = ss[j].Insert(i, char.ToLower(sym).ToString());
                }
            return string.Join(" ", ss);
        }

        bool? MuteCheck(IPlayer sender)
        {
            if (MuteData.IsMuted(sender.Id))
            {
                MuteData md = mutes[sender.Id];
                Reply(sender, "YOU.MUTED", md.Initiator, md.Reason, md.Remain);
                return true;
            }
            return null;
        }
        
        bool? SpamCheck(IPlayer sender, string message)
        {
            if (message.Length > 500)
            {
                sender.Kick(GetMsg("CHAT.TOOMUCH", sender));
                return false;
            }
            if (message.Length > 100)
            {
                Reply(sender, "CHAT.SPAM");
                return false;
            }
            return null;
        }
        public string CensorBadWords(string input, out bool found)
        {
            found = false;
            string temp = input.ToLower();
            foreach (var swear in config.badWords)
            {
                var firstIndex = temp.IndexOf(swear.Key);
                if (firstIndex >= 0 && swear.Value.All(exception => temp.IndexOf(exception) <= 0))
                    while (firstIndex < input.Length && input[firstIndex] != ' ')
                    {
                        input = input.Remove(firstIndex, 1);
                        input = input.Insert(firstIndex, "*");
                        firstIndex++;
                        found = true;
                    }
            }
            return input;
        }
        #endregion

        #region Logging
        enum LogType
        {
            Chat,
            Mute,
            PM,
            ServerConsole
        }
        private void Log(LogType type, string msg)
        {
            switch (type)
            {
                case LogType.Chat:
                    Interface.Oxide.RootLogger.Write(Oxide.Core.Logging.LogType.Info, $"[CHAT] {Formatter.ToPlaintext(msg)}");
                    return;
                case LogType.Mute:
                    Interface.Oxide.RootLogger.Write(Oxide.Core.Logging.LogType.Info, $"[MUTE] {Formatter.ToPlaintext(msg)}");
                    return;
                case LogType.PM:
                    Interface.Oxide.RootLogger.Write(Oxide.Core.Logging.LogType.Info, $"[PM] {Formatter.ToPlaintext(msg)}");
                    return;
                case LogType.ServerConsole:
                    Interface.Oxide.RootLogger.Write(Oxide.Core.Logging.LogType.Info, $"[ServerConsole] {Formatter.ToPlaintext(msg)}");
                    return;
            }
        }
        #endregion

        #region Broadcasting
        void SendChat(BasePlayer players, string name, Chat.ChatChannel channel, string message, string censorMessage = "", string userId = "0")
        {
            name = covalence.FormatText(name);
            message = covalence.FormatText(message);
            censorMessage = covalence.FormatText(censorMessage);
            if (string.IsNullOrEmpty(censorMessage)) censorMessage = message;
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (channel == Chat.ChatChannel.Global)
                {
                    string msg = GetPlayerData(player).Censor ? censorMessage : message;
                    player?.SendConsoleCommand("chat.add", channel, userId,
                        string.IsNullOrEmpty(name) ? $"{msg}" : $"{name}: {msg}");
                }
            }

            if (channel == Chat.ChatChannel.Team)
            {
                RelationshipManager.PlayerTeam team = BasePlayer.Find(userId).Team;
                if (team == null || team.members.Count == 0)
                {
                    return;
                }

                foreach (ulong userId2 in team.members)
                {
                    string msg = GetPlayerData(players).Censor ? censorMessage : message;
                    BasePlayer basePlayer = RelationshipManager.FindByID(userId2);
                    basePlayer.SendConsoleCommand("chat.add", (int) channel, players.userID,
                        string.IsNullOrEmpty(name) ? $"{msg}" : $"{name}: {msg}");
                }
            }
        }
        void BroadcastChat(string langKey, params object[] args)
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                player.ChatMessage(covalence.FormatText(string.Format(GetMsg(langKey, player), args)));
            }
        }
        private void Reply(IPlayer player, string langkey, params object[] args)
        {
            string message = string.Format(GetMsg(langkey, player.Id), args);
            message = player.IsServer ? Formatter.ToPlaintext(message) : covalence.FormatText(message);
            if(player.IsServer | player.IsConnected)
                player.Reply(message);
        }
        #endregion

        #region Sub functions
        void Mute(string userID, string name, TimeSpan? time = null, string reason = null, string sender = null)
        {
            if (string.IsNullOrEmpty(sender)) sender = "Not specified";
            if (string.IsNullOrEmpty(reason)) reason = config.MuteReason;
            string log;
            if (!time.HasValue)
            {
                mutes[userID] = new MuteData(sender, reason);
                BroadcastChat("USER.MUTED.REASON", sender, name, reason, "Unlimited");
                log = string.Format(GetMsg("USER.MUTED.LOG"), sender, name, "Unlimited", reason);
            }
            else
            {
                mutes[userID] = new MuteData(sender, reason, time.Value);
                BroadcastChat("USER.MUTED.REASON", sender, name, reason, MuteData.TimeToString(time.Value));
                log = string.Format(GetMsg("USER.MUTED.LOG"), sender, name, MuteData.TimeToString(time.Value), reason);
            }
            Log(LogType.Mute, log);
            SaveMutes();
        }
        private Dictionary<string, string> GetPlayers(string NameOrID)
        {
            var pl = players.FindPlayers(NameOrID).ToList();
            return pl.Select(p => new KeyValuePair<string, string>(p.Id, p.Name)).ToDictionary(x => x.Key, x => x.Value);
        }
        private void SendChatHelp(IPlayer player)
        {
            string msg = GetMsg("CMD.CHAT.HELP", player.Id);
            if (CanMuteAll(player)) msg += GetMsg("CMD.MUTE.ALL.HELP", player.Id);
            if (IsAdmin(player)) msg += GetMsg("CMD.CHAT.HELP.PERMISSION.ADMIN", player.Id);
            if (IsModerator(player)) msg += GetMsg("CMD.CHAT.HELP.PERMISSION.MODERATOR", player.Id);
            msg = player.IsServer ? Formatter.ToPlaintext(msg) : covalence.FormatText(msg);
            player.Message(msg);
        }
        #endregion

        #region Flags
        bool IsModerator(IPlayer player) => PermissionService.HasPermission(player.Id, config.adminPrivilages.ModerPermiss) || player.IsAdmin;//player.net.connection.authLevel >= 1;
        bool IsAdmin(IPlayer player) => PermissionService.HasPermission(player.Id, config.adminPrivilages.AdminPermiss) || player.IsAdmin;//player.net.connection.authLevel >= 2;
        bool CanMute(IPlayer player) => PermissionService.HasPermission(player.Id, config.adminPrivilages.MutePermiss) || player.IsAdmin;//player.net.connection.authLevel >= 1;
        bool CanMuteAll(IPlayer player) => PermissionService.HasPermission(player.Id, config.adminPrivilages.MuteAllPermiss) || player.IsAdmin;//player.net.connection.authLevel >= 2;
        bool CanAssign(IPlayer player) => PermissionService.HasPermission(player.Id, config.adminPrivilages.AssignPermiss) || player.IsAdmin;//player.net.connection.authLevel >= 2;
        bool CanUnMute(IPlayer player) => PermissionService.HasPermission(player.Id, config.adminPrivilages.UnMutePermiss) || player.IsAdmin;//player.net.connection.authLevel >= 1;
        #endregion

        #region Commands
#if RUST
        object OnServerCommand(ConsoleSystem.Arg arg, Chat.ChatChannel channel)
        {
            if (arg?.cmd?.FullName != null && arg?.cmd?.FullName == "global.say")
            {
                if (!arg.HasArgs())
                    return false;
                string message = string.Join(" ", arg.Args);

                bool outer;
                var cens = CensorBadWords(message, out outer);
                cens = string.Format(config.ConsoleFormat, config.ConsoleName, cens);
                message = string.Format(config.ConsoleFormat, config.ConsoleName, message);
                Log(LogType.ServerConsole, message);
                SendChat(arg.Player(), "", channel, message, cens);
                return true;
            }
            else return null;
        }
#endif

        [Command("chatplus.prefix")]
        private void cmdConsolePrefix(IPlayer player, string cmd, string[] Args)
        {
            if (!CanAssign(player))
            {
                Reply(player, "NO.ACCESS");
                return;
            }
            if (Args == null || Args.Length < 2)
            {
                Reply(player, "CMD.HELP.PREFIX");
                return;
            }
            var recivers = GetPlayers(Args[0]);
            if (recivers == null || recivers.Count == 0)
            {
                Reply(player, "PLAYER.NOT.FOUND", Args[0]);
                return;
            }
            if (recivers.Count > 1)
            {
                Reply(player, "MULTIPLE.PLAYERS.FOUND", string.Join("\n", recivers.Select(p => $"{p.Value} ({p.Key})").ToArray()));
                return;
            }
            var target = recivers.First();
            var pdata = GetPlayerData(target.Key);
            if (!PermissionService.HasPermission(target.Key, Args[1]))
            {
                Reply(player, "NO.PERMISSION.PLAYER");
                return;
            }
            pdata.Prefix = Args[1];
            Reply(player, "PREFIX.CHANGED", Args[1]);
        }
        [Command("chatplus.name")]
        private void cmdConsoleName(IPlayer player, string cmd, string[] Args)
        {
            if (!CanAssign(player))
            {
                Reply(player, "NO.ACCESS");
                return;
            }
            if (Args == null || Args.Length < 2)
            {
                Reply(player, "CMD.HELP.NAME");
                return;
            }
            var recivers = GetPlayers(Args[0]);
            if (recivers == null || recivers.Count == 0)
            {
                Reply(player, "PLAYER.NOT.FOUND", Args[0]);
                return;
            }
            if (recivers.Count > 1)
            {
                Reply(player, "MULTIPLE.PLAYERS.FOUND", string.Join("\n", recivers.Select(p => $"{p.Value} ({p.Key})").ToArray()));
                return;
            }
            var target = recivers.First();
            var pdata = GetPlayerData(target.Key);
            if (!PermissionService.HasPermission(target.Key, Args[1]))
            {
                Reply(player, "NO.PERMISSION.PLAYER");
                return;
            }
            pdata.NameColor = Args[1];
            Reply(player, "NAME.COLOR.CHANGED", Args[1]);
        }
        [Command("chatplus.message")]
        private void cmdConsoleMessage(IPlayer player, string cmd, string[] Args)
        {
            if (!CanAssign(player))
            {
                Reply(player, "NO.ACCESS");
                return;
            }
            if (Args == null || Args.Length < 2)
            {
                Reply(player, "CMD.HELP.MESSAGE");
                return;
            }
            var recivers = GetPlayers(Args[0]);
            if (recivers == null || recivers.Count == 0)
            {
                Reply(player, "PLAYER.NOT.FOUND", Args[0]);
                return;
            }
            if (recivers.Count > 1)
            {
                Reply(player, "MULTIPLE.PLAYERS.FOUND", string.Join("\n", recivers.Select(p => $"{p.Value} ({p.Key})").ToArray()));
                return;
            }
            var target = recivers.First();
            var pdata = GetPlayerData(target.Key);
            if (!PermissionService.HasPermission(target.Key, Args[1]))
            {
                Reply(player, "NO.PERMISSIO.PLAYERN");
                return;
            }
            pdata.MessageColor = Args[1];
            Reply(player, "MESSAGE.COLOR.CHANGED", Args[1]);
        }
        [Command("muteall")]
        private void cmdChatMuteAll(IPlayer player, string cmd, string[] Args)
        {
            if (!CanMuteAll(player))
            {
                Reply(player, "NO.ACCESS");
                return;
            }
            if (GlobalMute)
            {
                BroadcastChat("MUTE.ALL.ENABLED");
                GlobalMute = false;
                return;
            }
            BroadcastChat("MUTE.ALL.DISABLED");
            GlobalMute = true;
            return;
        }
        [Command("mutelist")]
        void cmdChatMuteList(IPlayer player, string cmd, string[] Args)
        {
            if (!CanMute(player) || !CanUnMute(player))
            {
                Reply(player, "NO.ACCESS");
                return;
            }
            string msg;
            if (mutes.Count == 0)
                msg = GetMsg("MUTE.LIST.NOONE");
            else
            {
                msg = GetMsg("MUTE.LIST.HEAD");
                foreach (var mute in mutes)
                {
                    msg += "\n" + string.Format(GetMsg("MUTE.LIST.BODY", player.Id), mute.Value.Initiator, $"{players.FindPlayerById(mute.Key.ToString()).Name} ({mute.Key})", mute.Value.Reason, mute.Value.Remain);
                }
            }
            player.Reply(msg);
        }
        [Command("mute")]
        void cmdChatMute(IPlayer player, string cmd, string[] args)
        {
            if (!CanMute(player))
            {
                Reply(player, "NO.ACCESS");
                return;
            }
            if (args.Length < 1)
            {
                Reply(player, "CMD.MUTE.HELP");
                return;
            }
            var recivers = GetPlayers(args[0]);
            if (recivers == null || recivers.Count == 0)
            {
                Reply(player, "PLAYER.NOT.FOUND", args[0]);
                return;
            }
            if (recivers.Count > 1)
            {
                Reply(player, "MULTIPLE.PLAYERS.FOUND", string.Join("\n", recivers.Select(p => $"{p.Value} ({p.Key})").ToArray()));
                return;
            }
            var mutePlayer = recivers.First();
            if (MuteData.IsMuted(mutePlayer.Key))
            {
                Reply(player, "USER.ALREADY.MUTED", mutePlayer.Value, mutes[mutePlayer.Key].Reason, mutes[mutePlayer.Key].Remain);
                return;
            }
            TimeSpan time;
            string sender = player.IsServer ? config.ConsoleName : player.Name;
            if (config.adminPrivilages.HideAdmins.HasValue && config.adminPrivilages.HideAdmins.Value && !player.IsServer)
                sender = config.adminPrivilages.AdminReplace;
            if (args.Length == 1)
            {
                Mute(mutePlayer.Key, mutePlayer.Value, null, null, sender);
                return;
            }
            if (MuteData.StringToTime(args[1], out time))
            {
                Mute(mutePlayer.Key, mutePlayer.Value, time, string.Join(" ", args.Skip(2).ToArray()), sender);
                return;
            }
            Mute(mutePlayer.Key, mutePlayer.Value, null, string.Join(" ", args.Skip(1).ToArray()), sender);
        }
        [Command("unmute")]
        void cmdChatUnMute(IPlayer player, string cmd, string[] args)
        {
            if (!CanUnMute(player))
            {
                Reply(player, "NO.ACCESS");
                return;
            }
            if (args.Length == 0)
            {
                Reply(player, "CMD.UNMUTE.HELP");
                return;
            }
            var recivers = GetPlayers(args[0]);
            if (recivers == null || recivers.Count == 0)
            {
                Reply(player, "PLAYER.NOT.FOUND", args[0]);
                return;
            }
            recivers = recivers.Where(p => mutes.ContainsKey(p.Key)).ToDictionary(x => x.Key, x => x.Value);
            if (recivers == null || recivers.Count == 0)
            {
                Reply(player, "PLAYER.NOT.MUTED");
                return;
            }
            if (recivers.Count > 1)
            {
                Reply(player, "MULTIPLE.PLAYERS.FOUND", string.Join("\n", recivers.Select(p => $"{p.Value} ({p.Key})").ToArray()));
                return;
            }
            var mutePlayer = recivers.First();
            mutes.Remove(mutePlayer.Key);
            BroadcastChat("USER.UNMUTED", player.Name, mutePlayer.Value);
            string log = GetMsg("USER.UNMUTED.LOG");
            log = string.Format(log, player.Name, mutePlayer.Value);
            Log(LogType.Mute, log);
            SaveMutes();
        }
        [Command("chat")]
        void cmdChat(IPlayer player, string cmd, string[] args)
        {
            if (args.Length == 0)
            {
                SendChatHelp(player);
                return;
            }
            var playerData = GetPlayerData(player);
            switch (args[0])
            {
                case "reset":
                    PlayersData[player.Id] = new PlayerData();
                    Reply(player, "RESET.SUCCESSFULL");
                    return;
                case "admin":
                    if (!IsAdmin(player))
                    {
                        Reply(player, "NO.ACCESS");
                        return;
                    }
                    if (playerData.IsAdmin)
                    {
                        playerData.IsAdmin = false;
                        Reply(player, "ADMIN.DISABLE");
                        return;
                    }
                    playerData.IsAdmin = true;
                    Reply(player, "ADMIN.ENABLE");
                    return;
                case "moder":
                    if (!IsModerator(player))
                    {
                        Reply(player, "NO.ACCESS");
                        return;
                    }
                    if (playerData.IsModer)
                    {
                        playerData.IsModer = false;
                        Reply(player, "MODERATOR.DISABLE");
                        return;
                    }
                    playerData.IsModer = true;
                    Reply(player, "MODERATOR.ENABLE");
                    return;
                case "censor":
                    if (playerData.Censor)
                    {
                        playerData.Censor = false;
                        Reply(player, "CENSOR.DISABLED");
                        return;
                    }
                    playerData.Censor = true;
                    Reply(player, "CENSOR.ENABLED");
                    return;
                case "ignore":
                    if (args.Length == 2 && args[1] == "list")
                    {
                        if (playerData.BlackList.Count == 0)
                        {
                            Reply(player, "IGNORE.LIST.IS.EMPTY");
                            return;
                        }
                        Reply(player, "IGNORE.LIST", string.Join(", ", playerData.BlackList.Select(p => GetPlayerData(p).Name).ToArray()));
                        return;
                    }
                    if (args.Length < 3 || (args[1] != "add" && args[1] != "remove"))
                    {
                        Reply(player, "CMD.CHAT.IGNORE.HELP");
                        return;
                    }
                    bool mode = args[1] == "add" ? true : false;
                    var reply = 777;
                    var recivers = players.FindPlayers(args[2]);
                    if (recivers == null || !recivers.Any())
                    {
                        Reply(player, "PLAYER.NOT.FOUND", args[2]);
                        return;
                    }
                    if (recivers.Count() > 1)
                    {
                        Reply(player, "MULTIPLE.PLAYERS.FOUND", string.Join("\n", recivers.Select(p => $"{p.Name} ({p.Id})").ToArray()));
                        return;
                    }
                    var ignorePlayer = recivers.First();
                    if (mode)
                    {
                        if (!playerData.BlackList.Contains(ignorePlayer.Id))
                        {
                            playerData.BlackList.Add(ignorePlayer.Id);
                            Reply(player, "USER.ADD.IGNORE.LIST", ignorePlayer.Name);
                            if (ignorePlayer.IsConnected)
                                Reply(ignorePlayer, "YOU.ADD.IGNORE.LIST", player.Name);
                            return;
                        }
                        Reply(player, "USER.IS.IGNORE.LIST", ignorePlayer.Name);
                        return;
                    }
                    else
                    {
                        if (playerData.BlackList.Contains(ignorePlayer.Id))
                        {
                            playerData.BlackList.Remove(ignorePlayer.Id);
                            Reply(player, "USER.REMOVE.IGNORE.LIST", ignorePlayer.Name);
                            Reply(ignorePlayer, "YOU.REMOVE.IGNORE.LIST", player.Name);
                            return;
                        }
                        Reply(player, "NOT.ON.IGNORE.LIST",ignorePlayer.Name);
                        return;
                    }
                case "sound":
                    if (args.Length == 1 || (args[1] != "on" && args[1] != "off"))
                    {
                        Reply(player, "CMD.CHAT.SOUND.HELP");
                        return;
                    }
                    bool pmSound = args[1] == "on";
                    playerData.PMSound = pmSound;
                    if (pmSound)
                    {
                        Reply(player, "SOUND.ENABLED");
                        return;
                    }
                    else
                    {
                        Reply(player, "SOUND.DISABLED");
                        return;
                    }
                case "prefix":
                    var aviablePrefixes = config.prefixes
                        .Where(p => PermissionService.HasPermission(player.Id, p.Perm) && playerData.Prefix != p.Perm
                        || p.Perm == "chatplus.default" && playerData.Prefix != p.Perm).ToList();
                    if (aviablePrefixes.Count == 0)
                    {
                        Reply(player, "NO.AVAILABLE.PREFIXS");
                        return;
                    }
                    if (args.Length == 1)
                    {
                        Reply(player, "AVAILABLE.COLORS.PREFIX",
                            string.Join(", ", aviablePrefixes.Select(p => $"{p.Arg}({covalence.FormatText(p.Format)})").ToArray()));
                        return;
                    }
                    var selectedPrefix = aviablePrefixes.FirstOrDefault(p => p.Arg == args[1]);
                    if (selectedPrefix == null)
                    {
                        Reply(player, "PREFIX.NOT.FOUND", args[1]);
                        return;
                    }
                    playerData.Prefix = selectedPrefix.Perm;
                    Reply(player, "PREFIX.CHANGED", selectedPrefix.Arg);
                    return;
                case "name":
                    var aviableNameColors = config.names
                        .Where(p => PermissionService.HasPermission(player.Id, p.Perm) && playerData.NameColor != p.Perm
                        || p.Perm == "chatplus.default" && playerData.NameColor != p.Perm).ToList();
                    if (aviableNameColors.Count == 0)
                    {
                        Reply(player, "NO.AVAILABLE.COLORS");
                        return;
                    }
                    if (args.Length == 1)
                    {
                        Reply(player, "AVAILABLE.COLORS.NAME",
                            string.Join(", ", aviableNameColors.Select(p => covalence.FormatText(string.Format(p.Format, p.Arg))).ToArray()));
                        return;
                    }
                    var selectedNameColor = aviableNameColors.FirstOrDefault(p => p.Arg == args[1]);
                    if (selectedNameColor == null)
                    {
                        Reply(player, "COLOR.NOT.FOUND", args[1]);
                        return;
                    }
                    playerData.NameColor = selectedNameColor.Perm;
                    Reply(player, "NAME.COLOR.CHANGED", selectedNameColor.Arg);
                    return;
                case "message":
                    var aviableMessageColors = config.messages
                        .Where(p => PermissionService.HasPermission(player.Id, p.Perm) && playerData.MessageColor != p.Perm
                        || p.Perm == "chatplus.default" && playerData.MessageColor != p.Perm).ToList();
                    if (aviableMessageColors.Count == 0)
                    {
                        Reply(player, "NO.AVAILABLE.COLORS");
                        return;
                    }
                    if (args.Length == 1)
                    {
                        Reply(player, "AVAILABLE.COLORS.MESSAGE",
                            string.Join(", ", aviableMessageColors.Select(p => covalence.FormatText(string.Format(p.Format, p.Arg))).ToArray()));
                        return;
                    }
                    var selectedMessageColor = aviableMessageColors.FirstOrDefault(p => p.Arg == args[1]);
                    if (selectedMessageColor == null)
                    {
                        Reply(player, "COLOR.NOT.FOUND", args[1]);
                        return;
                    }
                    playerData.MessageColor = selectedMessageColor.Perm;
                    Reply(player, "MESSAGE.COLOR.CHANGED", selectedMessageColor.Arg);
                    return;
                default:
                    SendChatHelp(player);
                    return;
            }
        }
        #endregion

        #region Private messaging
#if RUST
        private bool PmAvatar() => config.PMAva.HasValue && config.PMAva.Value;
        private void RustChat(IPlayer player, string langkey, string avatar, params object[] args)
        {
            var msg = string.Format(GetMsg(langkey, player.Id), args);
            player.Command("chat.add 0", PmAvatar() ? avatar : "0", covalence.FormatText(msg));
        }
#endif
        Dictionary<string, string> pmHistory = new Dictionary<string, string>();
        [Command("pm")]
        void cmdChatPM(IPlayer player, string cmd, string[] args)
        {
            if (args.Length < 2)
            {
                Reply(player, "CMD.PM.HELP");
                return;
            }
            var argList = args.ToList();
            argList.RemoveAt(0);
            string message = string.Join(" ", argList.ToArray());
            var receivers = players.Connected.Where(p => p.Name.ToLower()
            .Contains(args[0].ToLower()) || p.Id == args[0]).ToList();
            if (receivers == null || receivers.Count == 0)
            {
                Reply(player, "PLAYER.NOT.FOUND", args[0]);
                return;
            }
            if (receivers.Count > 1)
            {
                Reply(player, "MULTIPLE.PLAYERS.FOUND", string.Join("\n", receivers.Select(p => $"{p.Name} ({p.Id})").ToArray()));
                return;
            }
            IPlayer receiver = receivers[0];
            if (receiver.Id == player.Id)
            {
                Reply(player, "PM.SELF");
                return;
            }
            if (GetPlayerData(receiver).BlackList.Contains(player.Id))
            {
                Reply(player, "PM.YOU.ARE.BLACK.LIST", receiver.Name);
                return;
            }
            pmHistory[player.Id] = receiver.Id;
            pmHistory[receiver.Id] = player.Id;
#if RUST
            string msg;

            if (player.IsServer)
            {
                ConsoleIPly = player;
                Reply(player, "PM.SENDER.FORMAT", receiver.Name, message);
                RustChat(receiver, "PM.RECEIVER.FORMAT", "0", config.ConsoleName, message);
            }
            else
            {
                RustChat(player, "PM.SENDER.FORMAT", player.Id, receiver.Name, message);
                RustChat(receiver, "PM.RECEIVER.FORMAT", player.Id, player.Name, message);
            }

            var bply = receiver.Object as BasePlayer;
            if (GetPlayerData(receiver).PMSound)
            {
                Effect.server.Run(strName: config.PrivateSoundMessagePath, ent: bply, boneID: 0, posLocal: Vector3.zero, normLocal: Vector3.zero);
            }
#else
            Reply(player, "PM.SENDER.FORMAT", receiver.Name, message);
            if (player.IsServer)
            {
                ConsoleIPly = player;
                Reply(receiver, "PM.RECEIVER.FORMAT", config.ConsoleName, message);
            }
            else
                Reply(receiver, "PM.RECEIVER.FORMAT", player.Name, message);
#endif
            Log(LogType.PM, string.Format(GetMsg("PM.LOG"), $"{player.Name}({player.Id})", $"{receiver.Name}({receiver.Id})", message));
        }
        [Command("r")]
        void cmdChatR(IPlayer player, string cmd, string[] args)
        {
            if (args.Length == 0)
            {
                Reply(player, "CMD.R.HELP");
                return;
            }
            string message = string.Join(" ", args);

            string recieverUserId;
            if (!pmHistory.TryGetValue(player.Id, out recieverUserId))
            {
                Reply(player, "PM.NO.MESSAGES");
                return;
            }
            if (recieverUserId== "server_console")
            {
#if RUST
                RustChat(player, "PM.SENDER.FORMAT", player.Id, config.ConsoleName, message);
#else
                Reply(player, "PM.SENDER.FORMAT", config.ConsoleName, message);
#endif
                Reply(ConsoleIPly, "PM.RECEIVER.FORMAT", player.Name, message);
                Log(LogType.PM, string.Format(GetMsg("PM.LOG"), $"{player.Name}({player.Id})", $"Server console", message));
                return;
            }

            var receiver = players.Connected.FirstOrDefault(p => p.Id == recieverUserId);
            if (receiver == null)
            {
                Reply(player, "PM.PLAYER.LEAVE");
                return;
            }
            if (GetPlayerData(receiver).BlackList.Contains(player.Id))
            {
                Reply(player, "PM.YOU.ARE.BLACK.LIST", receiver.Name);
                return;
            }
#if RUST
            if (player.IsServer)
            {
                Reply(player, "PM.SENDER.FORMAT", receiver.Name, message);
                RustChat(receiver, "PM.RECEIVER.FORMAT", "0", config.ConsoleName, message);
            }
            else
            {
                RustChat(player, "PM.SENDER.FORMAT", player.Id, receiver.Name, message);
                RustChat(receiver, "PM.RECEIVER.FORMAT", player.Id, player.Name, message);
            }
            var bply = receiver.Object as BasePlayer;
            if (GetPlayerData(receiver).PMSound)
            {
                Effect.server.Run(strName: config.PrivateSoundMessagePath, ent: bply, boneID: 0, posLocal: Vector3.zero, normLocal: Vector3.zero);
            }
#else
            Reply(player, "PM.SENDER.FORMAT", receiver.Name, message);
            Reply(receiver, "PM.RECEIVER.FORMAT", player.IsServer ? config.ConsoleName : player.Name, message);
#endif
            Log(LogType.PM, string.Format(GetMsg("PM.LOG"), $"{player.Name}({player.Id})", $"{receiver.Name}({receiver.Id})", message));
        }
        #endregion

        #region Data
        private class MuteData
        {
            public readonly string Initiator;
            public readonly string Reason;
            public readonly DateTime ExpireDate;
            [JsonIgnore]
            private bool Timed => ExpireDate != DateTime.MinValue;
            [JsonIgnore]
            public bool Expired => Timed && ExpireDate < DateTime.UtcNow;
            [JsonIgnore]
            public string Remain => Timed ? TimeToString(ExpireDate - DateTime.UtcNow) : "Unlimited";
            public static bool IsMuted(string userID) => mutes.ContainsKey(userID);
            public MuteData(string Initiator, string Reason, TimeSpan? Until = null)
            {
                this.ExpireDate = Until.HasValue ? DateTime.UtcNow + Until.Value : DateTime.MinValue;
                this.Reason = Reason;
                this.Initiator = Initiator;
            }
            [JsonConstructor]
            public MuteData(string Initiator, string Reason, DateTime ExpireDate)
            {
                Interface.Oxide.RootLogger.Write(Core.Logging.LogType.Chat,$"Mutedata initilizere called with: {Initiator} | {Reason} | {ExpireDate}");
                this.ExpireDate = ExpireDate;
                this.Reason = Reason;
                this.Initiator = Initiator;
            }

            public static string TimeToString(TimeSpan elapsedTime)
            {
                int hours = elapsedTime.Hours;
                int minutes = elapsedTime.Minutes;
                int seconds = elapsedTime.Seconds;
                int days = elapsedTime.Days;
                string s = "";
                if (days > 0) s += $"{days} дн. ";
                if (hours > 0) s += $"{hours} ч. ";
                if (minutes > 0) s += $"{minutes} мин. ";
                if (seconds > 0) s += $"{seconds} сек.";
                else s = s.TrimEnd(' ');
                return s;
            }
            public static bool StringToTime(string source, out TimeSpan time)
            {
                int seconds = 0, minutes = 0, hours = 0, days = 0;
                Match s = new Regex(@"(\d+?)s", RegexOptions.IgnoreCase).Match(source);
                Match m = new Regex(@"(\d+?)m", RegexOptions.IgnoreCase).Match(source);
                Match h = new Regex(@"(\d+?)h", RegexOptions.IgnoreCase).Match(source);
                Match d = new Regex(@"(\d+?)d", RegexOptions.IgnoreCase).Match(source);
                if (s.Success)
                    seconds = Convert.ToInt32(s.Groups[1].ToString());
                if (m.Success)
                    minutes = Convert.ToInt32(m.Groups[1].ToString());
                if (h.Success)
                    hours = Convert.ToInt32(h.Groups[1].ToString());
                if (d.Success)
                    days = Convert.ToInt32(d.Groups[1].ToString());
                source = source.Replace(seconds + "s", string.Empty);
                source = source.Replace(minutes + "m", string.Empty);
                source = source.Replace(hours + "h", string.Empty);
                source = source.Replace(days + "d", string.Empty);
                if (!string.IsNullOrEmpty(source) || (!s.Success && !m.Success && !h.Success && !d.Success))
                {
                    time = TimeSpan.Zero;
                    return false;
                }
                time = new TimeSpan(days, hours, minutes, seconds);
                return true;
            }
        }
        public class PlayerData
        {
            public string Prefix = "chatplus.default";
            public string NameColor = "chatplus.default";
            public string MessageColor = "chatplus.default";
            public bool Censor = true;
            public bool PMSound = true;
            public string Name = "";
            public bool IsAdmin = false;
            public bool IsModer = false;
            public List<string> BlackList = new List<string>();
        }

        PlayerData GetPlayerData(IPlayer player)
        {
            var data = GetPlayerData(player.Id);
            data.Name = player.Name;
            return data;
        }
        PlayerData GetPlayerData(BasePlayer player)
        {
            var data = GetPlayerData(player.UserIDString);
            data.Name = player.displayName;
            return data;
        }
        PlayerData GetPlayerData(string userId)
        {
            PlayerData config;
            if (PlayersData.TryGetValue(userId, out config))
            {
                if (config.Prefix != "chatplus.default" && !PermissionService.HasPermission(userId, config.Prefix)) config.Prefix = "chatplus.default";
                if (config.NameColor != "chatplus.default" && !PermissionService.HasPermission(userId, config.NameColor)) config.NameColor = "chatplus.default";
                if (config.MessageColor != "chatplus.default" && !PermissionService.HasPermission(userId, config.MessageColor)) config.MessageColor = "chatplus.default";
                return config;
            }
            config = new PlayerData();
            PlayersData[userId] = config;
            return config;
        }
        #endregion

        #region Localization
        string GetMsg(string key, object ID = null, params object[] args) => lang.GetMessage(key, this, ID == null ? null : ID.ToString());
        private void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                ["CMD.CHAT.HELP"] = "Available commands:\n[#00FF00]/chat censor[/#] - switching chat censor\n[#00FF00]/chat prefix[/#] - switching your chat prefix\n[#00FF00]/chat name[/#] - switching your chat name color\n[#00FF00]/chat message[/#] - switching your chat message color\n[#00FF00]/chat ignore[/#] [#42f4ee]add/remove/list[/#] - managing black list\n[#00FF00]/chat sound[/#] [#42f4ee]on/off[/#] - switching private messages sounds\n[#00FF00]/chat reset[/#] - set your chat/message color and prefix to default",
                ["CMD.CHAT.HELP.PERMISSION.ADMIN"] = "\n[#00FF00]/chat admin[/#] - administrator mode",
                ["CMD.CHAT.HELP.PERMISSION.MODERATOR"] = "\n[#00FF00]/chat moder[/#] - moderator mode",
                ["CMD.MUTE.ALL.HELP"] = "\n[#00FF00]/muteall[/#] - Toggle global chat mute",
                ["NO.AVAILABLE.PREFIXS"] = "You have no prefixes available",
                ["PREFIX.NOT.FOUND"] = "Prefix \"{0}\" not found",
                ["PREFIX.CHANGED"] = "Prefix changed to {0}",
                ["AVAILABLE.COLORS.NAME"] = "Available name colors:\n{0}",
                ["AVAILABLE.COLORS.PREFIX"] = "Available prefixes:\n{0}",
                ["AVAILABLE.COLORS.MESSAGE"] = "Available chat colors:\n{0}",
                ["NO.AVAILABLE.COLORS"] = "You have no colors available",
                ["COLOR.NOT.FOUND"] = "Color \"{0}\" not found",
                ["NAME.COLOR.CHANGED"] = "Name color changed to {0}",
                ["MESSAGE.COLOR.CHANGED"] = "Message color changed to {0}",
                ["CMD.CHAT.SOUND.HELP"] = "Use [#00FF00]/chat sound[/#] [#008000]on[/#] or [#00FF00]/chat sound[/#] [#FF4500]off[/#] to toggle sound of income PM",
                ["SOUND.ENABLED"] = "You have turn income PM sounds [#008000]ON[/#]",
                ["SOUND.DISABLED"] = "You have turn income PM sounds [#FF4500]OFF[/#]",
                ["CMD.MUTE.HELP"] = "Use [#00FF00]/mute[/#] <\"player name\"> [time] [reason] to mute player",
                ["USER.ALREADY.MUTED"] = "Player \"{0}\" Already muted.\nReason: {1}\nTimeleft: {2}",
                ["USER.MUTED.REASON"] = "{0} has mute player \"{1}\"\nReason: {2}\nTimeleft: {3}",
                ["USER.MUTED.LOG"] = "\"{0}\" muted player \"{1}\" for {2}\nReason: \"{3}\"",
                ["CMD.UNMUTE.HELP"] = "Use [#00FF00]/unmute[/#] \"player name\" to unmute player",
                ["USER.UNMUTED"] = "{0} remove mute from player \"{1}\"",
                ["USER.UNMUTED.LOG"] = "\"{0}\" unmuted player \"{1}\"",
                ["YOU.MUTED"] = "You are muted, and may not chat!\nInitiator: {0}\nReason: {1}\nTimeleft: {2}",
                ["MUTE.ALL.ENABLED"] = "Global chat [#62ff29]ENABLED[/#]",
                ["MUTE.ALL.DISABLED"] = "Global chat [#ff552a]DISABLED[/#]",
                ["CMD.CHAT.IGNORE.HELP"] = "Commands list:\n[#00FF00]/chat ignore add[/#] \"player name\" - add player to your blacklist\n[#00FF00]/chat ignore remove[/#] \"player name\" - remove player from your blacklist\n[#00FF00]/chat ignore list[/#] - show your blacklist",
                ["USER.IS.IGNORE.LIST"] = "Player \"{0}\" already blacklisted",
                ["NOT.ON.IGNORE.LIST"] = "Player \"{0}\" isn't blacklisted",
                ["USER.ADD.IGNORE.LIST"] = "You successfully add player \"{0}\" to your blacklist",
                ["YOU.ADD.IGNORE.LIST"] = "Player \"{0}\" added you to his/her blacklist",
                ["IGNORE.LIST.IS.EMPTY"] = "Blacklist is empty",
                ["USER.REMOVE.IGNORE.LIST"] = "You have removed player \"{0}\" from your blacklist",
                ["YOU.REMOVE.IGNORE.LIST"] = "Player \"{0}\" removed you from his/her blacklist",
                ["IGNORE.LIST"] = "BLACKLIST:\n",
                ["CMD.PM.HELP"] = "Use [#00FF00]/pm[/#] \"player name\" \"message\" to send PM to another player",
                ["PM.SENDER.FORMAT"] = "[#e664a5]PM for {0}[/#]: {1}",
                ["PM.RECEIVER.FORMAT"] = "[#e664a5]PM from {0}[/#]: {1}",
                ["PM.NO.MESSAGES"] = "You havn't recive PM yet.",
                ["PM.PLAYER.LEAVE"] = "Player with who you were chating has left the server.",
                ["PM.YOU.ARE.BLACK.LIST"] = "You can't send PM to the player \"{0}\", you are in his/her blacklist",
                ["CMD.R.HELP"] = "Use [#00FF00]/r[/#] \"message\" to reply to the lates PM",
                ["CENSOR.ENABLED"] = "You have [#62ff29]ENABLE[/#] chat censority",
                ["CENSOR.DISABLED"] = "You have [#ff552a]DISABLE[/#] chat censority",
                ["NO.ACCESS"] = "You have no access to this command",
                ["PLAYER.NOT.FOUND"] = "PLayer \"{0}\" not found",
                ["MULTIPLE.PLAYERS.FOUND"] = "Multiply players found:\n{0}",
                ["PM.SELF"] = "You can't send messages to self",
                ["MODERATOR.ENABLE"] = "Moderator mode has been [#62ff29]ENABLED[/#]",
                ["MODERATOR.DISABLE"] = "Moderator mode has been [#ff552a]DISABLED[/#]",
                ["ADMIN.ENABLE"] = "Administrator mode has been [#62ff29]ENABLED[/#]",
                ["ADMIN.DISABLE"] = "Administrator mode has been [#ff552a]DISABLED[/#]",
                ["PLAYER.NOT.MUTED"] = "Player is not muted",
                ["RESET.SUCCESSFULL"] = "Your chat setting was resetted to default",
                ["CHAT.SPAM"] = "Your message is to loong!",
                ["CHAT.TOOMUCH"] = "Too long message. > 500",
                ["CMD.HELP.PREFIX"] = "Incorrect syntax! chatplus.prefix steamid/nick privilege",
                ["CMD.HELP.NAME"] = "Incorrect syntax! chatplus.name steamid/nick privilege",
                ["CMD.HELP.MESSAGE"] = "Incorrect syntax! chatplus.message steamid/nick privilege",
                ["NO.PERMISSION.PLAYER"] = "Player doesn't have requiered permission!",
                ["NO.PERMISSION.YOU"] = "You don't have requiered permission!",
                ["MUTE.EXPIRED"] = "Player {0} is no longer muted.",
                ["MUTE.LIST.HEAD"] = "Mutelist:",
                ["MUTE.LIST.BODY"] = "--------------------\nInitiator: {0}\nPlayer: {1}\nReason: {2}\nTimeleft: {3}\n--------------------",
                ["MUTE.LIST.NOONE"] = "No one is currently muted",
                ["PM.LOG"] = "PM from \"{0}\" to \"{1}\": {2}"
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>()
            {
                ["CMD.CHAT.HELP"] = "Доступные команды:\n[#00FF00]/chat censor[/#] - цензура в чате\n[#00FF00]/chat prefix[/#] - доступные префиксы\n[#00FF00]/chat name[/#] - доступные цвета имени\n[#00FF00]/chat message[/#] - доступные цвета сообщений\n[#00FF00]/chat ignore[/#] [#42f4ee]add/remove/list[/#] - управление чёрным списком\n[#00FF00]/chat sound[/#] [#42f4ee]on/off[/#] - звук при получении ЛС\n[#00FF00]/chat reset[/#] - Сбрасывает ваши настройки чата на стандартные.",
                ["CMD.CHAT.HELP.PERMISSION.ADMIN"] = "\n[#00FF00]/chat admin[/#] - режим администратора",
                ["CMD.CHAT.HELP.PERMISSION.MODERATOR"] = "\n[#00FF00]/chat moder[/#] - режим модератора",
                ["CMD.MUTE.ALL.HELP"] = "\n[#00FF00]/muteall[/#] - Блокировка/разблокировка общего чата",
                ["NO.AVAILABLE.PREFIXS"] = "У вас нет доступных префиксов",
                ["PREFIX.NOT.FOUND"] = "Префикс с названием \"{0}\" не найден",
                ["PREFIX.CHANGED"] = "Префикс изменен на {0}",
                ["AVAILABLE.COLORS.NAME"] = "Доступные цвета имени:\n{0}",
                ["AVAILABLE.COLORS.PREFIX"] = "Доступные префиксы:\n{0}",
                ["AVAILABLE.COLORS.MESSAGE"] = "Доступные цвета сообщений:\n{0}",
                ["NO.AVAILABLE.COLORS"] = "У вас нет доступных цветов",
                ["COLOR.NOT.FOUND"] = "Цвет с названием \"{0}\" не найден",
                ["NAME.COLOR.CHANGED"] = "Цвет имени успешно изменен на {0}",
                ["MESSAGE.COLOR.CHANGED"] = "Цвет сообщений успешно изменен на {0}",
                ["CMD.CHAT.SOUND.HELP"] = "Используйте [#00FF00]/chat sound[/#] [#008000]on[/#] или [#FF4500]off[/#] чтобы включить или выключить звуковое оповещение при получении ЛС",
                ["SOUND.ENABLED"] = "Вы включили звуковое оповещение при получении ЛС",
                ["SOUND.DISABLED"] = "Вы выключили звуковое оповещение при получении ЛС",
                ["CMD.MUTE.HELP"] = "Используйте [#00FF00]/mute[/#] <\"имя игрока\"> [длительность] [причина] чтобы заблокировать чат игроку",
                ["USER.ALREADY.MUTED"] = "У игрока \"{0}\" уже отключён чат.\nПричина: {1}\nОсталось времени: {2}",
                ["USER.MUTED.REASON"] = "{0} заблокировал чат игроку \"{1}\"\nПричина: {2}\nВремя блокировки: {3}",
                ["USER.MUTED.LOG"] = "\"{0}\" заблокировал чат игроку \"{1}\" на {2}\nПричина: \"{3}\"",
                ["CMD.UNMUTE.HELP"] = "Используйте [#00FF00]/unmute[/#] \"имя игрока\" чтобы разблокировать чат игроку",
                ["USER.UNMUTED"] = "{0} снял мут с игрока \"{1}\"",
                ["USER.UNMUTED.LOG"] = "\"{0}\" разблокировал чат \"{1}\"",
                ["YOU.MUTED"] = "Ваш чат заблокирован!\nЗаблокировавший: {0}\nПричина: {1}\nОсталось времени: {2}",
                ["MUTE.ALL.ENABLED"] = "Общий чат [#62ff29]РАЗБЛОКИРОВАН[/#]",
                ["MUTE.ALL.DISABLED"] = "Общий чат [#ff552a]ЗАБЛОКИРОВАН[/#]",
                ["CMD.CHAT.IGNORE.HELP"] = "Список команд:\n[#00FF00]/chat ignore add[/#] \"имя игрока\" - добавить в черный список\n[#00FF00]/chat ignore remove[/#] \"имя игрока\" - удалить из черного списка\n[#00FF00]/chat ignore list[/#] - показать черный список",
                ["USER.IS.IGNORE.LIST"] = "Игрок \"{0}\" уже находится в черном списке",
                ["USER.ADD.IGNORE.LIST"] = "Вы добавили игрока \"{0}\" в черный список",
                ["YOU.ADD.IGNORE.LIST"] = "Игрок \"{0}\" добавил вас в черный список",
                ["NOT.ON.IGNORE.LIST"] = "Игрок \"{0}\" не находится в чёрном списке",
                ["IGNORE.LIST.IS.EMPTY"] = "Черный список пуст",
                ["USER.REMOVE.IGNORE.LIST"] = "Вы удалили игрока \"{0}\" из черного списка",
                ["YOU.REMOVE.IGNORE.LIST"] = "Игрок \"{0}\" удалил вас из черного списка",
                ["IGNORE.LIST"] = "Чёрный список:\n",
                ["CMD.PM.HELP"] = "Используйте [#00FF00]/pm[/#] \"имя игрока\" \"сообщение\" чтобы отправить ЛС игроку",
                ["PM.SENDER.FORMAT"] = "[#e664a5]ЛС для {0}[/#]: {1}",
                ["PM.RECEIVER.FORMAT"] = "[#e664a5]ЛС от {0}[/#]: {1}",
                ["PM.NO.MESSAGES"] = "Вы не получали личных сообщений",
                ["PM.PLAYER.LEAVE"] = "Игрок с которым вы переписывались вышел с сервера",
                ["PM.YOU.ARE.BLACK.LIST"] = "Вы не можете отправить ЛС игроку \"{0}\", он добавил вас в черный список",
                ["CMD.R.HELP"] = "Используйте [#00FF00]/r[/#] \"сообщение\" чтобы ответить но последнее ЛС",
                ["CENSOR.ENABLED"] = "Вы [#62ff29]ВКЛЮЧИЛИ[/#] цензуру в чате",
                ["CENSOR.DISABLED"] = "Вы [#ff552a]ВЫКЛЮЧИЛИ[/#] цензуру в чате",
                ["NO.ACCESS"] = "У вас нет доступа к этой команде",
                ["PLAYER.NOT.FOUND"] = "Игрок \"{0}\" не найден",
                ["MULTIPLE.PLAYERS.FOUND"] = "Найдено несколько игроков с похожим именем:\n{0}",
                ["PM.SELF"] = "Вы не можете отправлять сообщения самому себе",
                ["MODERATOR.ENABLE"] = "Режим модератора [#62ff29]ВКЛЮЧЕН[/#]",
                ["MODERATOR.DISABLE"] = "Режим модератора [#ff552a]ВЫКЛЮЧЕН[/#]",
                ["ADMIN.ENABLE"] = "Режим администратора [#62ff29]ВКЛЮЧЕН[/#]",
                ["ADMIN.DISABLE"] = "Режим администратора [#ff552a]ВЫКЛЮЧЕН[/#]",
                ["PLAYER.NOT.MUTED"] = "У игрока не отключен чат",
                ["RESET.SUCCESSFULL"] = "Вы сбросили свои настройки чата на стандартные",
                ["CHAT.SPAM"] = "Ваше сообщение слишком длинное!",
                ["CHAT.TOOMUCH"] = "Слишком длинное сообщение. Больше 500 символов.",
                ["CMD.HELP.PREFIX"] = "Неверный синтаксис! chatplus.prefix steamid/ник привилегия",
                ["CMD.HELP.NAME"] = "Неверный синтаксис! chatplus.name steamid/ник привилегия",
                ["CMD.HELP.MESSAGE"] = "Неверный синтаксис! chatplus.message steamid/ник привилегия",
                ["NO.PERMISSION.PLAYER"] = "У игрока нет необходимой привилегии!",
                ["NO.PERMISSION.YOU"] = "У вас нет необходимой привилегии!",
                ["MUTE.EXPIRED"] = "Игроку \"{0}\" вновь доступен чат.",
                ["MUTE.LIST.HEAD"] = "Список игроков с отключённым чатом:",
                ["MUTE.LIST.BODY"] = "--------------------\nИнициатор: {0}\nИгрок: {1}\nПричина: {2}\nСрок: {3}\n--------------------",
                ["MUTE.LIST.NOONE"] = "Чат на данный момент доступен всем игрокам.",
                ["PM.LOG"] = "ЛС от \"{0}\" для \"{1}\": {2}"
            }, this, "ru");
        }
        #endregion

        #region Config Initialization
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Благодарим за приобритение плагина на сайте RustPlugin.ru. Если вы приобрели этот плагин на другом ресурсе знайте - это лишает вас гарантированных обновлений!");
            config = new ChatConfig()
            {
                CapsBlock = true,
                BadWordsBlock = false,
                MuteReasonAutoMute = "Нецензурная лексика",
                MuteReason = "Не указана",
                MuteBadWordsDefault = 300,
                PrivateSoundMessage = true,
                PrivateSoundMessagePath = "assets/bundled/prefabs/fx/notice/stack.world.fx.prefab",
                adminPrivilages = new AdminPrivilages
                {
                    AdminPermiss = "chatplus.adminmode",
                    ModerPermiss = "chatplus.moderatormode",
                    MutePermiss = "chatplus.mute",
                    UnMutePermiss = "chatplus.unmute",
                    MuteAllPermiss = "chatplus.muteall",
                    AssignPermiss = "chatplus.assign",
                    AdminFormat = "[#a5e664]Администратор[/#]: {0}",
                    ModerFormat = "[#a5e664]Модератор[/#]: {0}",
                    HideAdmins = false,
                    AdminReplace = "Модератор чата"
                },
                prefixes = new List<ChatPrivilege>()
                    {
                        new ChatPrivilege()
                        {
                            Perm = "chatplus.default",
                            Arg = "default",
                            Format = "",
                        },
                        new ChatPrivilege()
                        {
                            Perm = "chatplus.vip",
                            Arg = "vip",
                            Format = "[#9370DB][VIP][/#]",
                        },
                        new ChatPrivilege()
                        {
                            Perm = "chatplus.premium",
                            Arg = "premium",
                            Format = "[#00FF7F][Премиум][/#]",
                        }
                    },
                names = new List<ChatPrivilege>()
                    {
                        new ChatPrivilege()
                        {
                            Perm = "chatplus.default",
                            Arg = "default",
                            Format = "[#ffffff]{0}[/#]",
                        },
                        new ChatPrivilege()
                        {
                            Perm = "chatplus.hotpink",
                            Arg = "hotpink",
                            Format = "[#FF69B4]{0}[/#]",
                        },
                        new ChatPrivilege()
                        {
                            Perm = "chatplus.tomato",
                            Arg = "tomato",
                            Format = "[#FF6347]{0}[/#]",
                        }
                    },
                messages = new List<ChatPrivilege>()
                    {
                        new ChatPrivilege()
                        {
                            Perm = "chatplus.default",
                            Arg = "default",
                            Format = "[#ffffff]{0}[/#]",
                        },
                        new ChatPrivilege()
                        {
                            Perm = "chatplus.blue",
                            Arg = "blue",
                            Format = "[#64a5e6]{0}[/#]",
                        },
                        new ChatPrivilege()
                        {
                            Perm = "chatplus.gold",
                            Arg = "gold",
                            Format = "[#DAA520]{0}[/#]",
                        }
                    },
                badWords = new Dictionary<string, List<string>>()
                    {
                        { "ебля", new List<string>() },
                        { "сука", new List<string>() },
                        { "пидор", new List<string>() },
                    },
                ConsoleName = "Server Console",
                ConsoleFormat = "[+16][#00ff00]{0}[/#]: {1}[/+]",
                PMAva = true
            };
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            {
                config = Config.ReadObject<ChatConfig>();
                if (!config.names.Any(c => c.Perm == "chatplus.default"))
                {
                    PrintWarning("Не удаляйте привилегию chatplus.default! Стандартное имя восстановлено. Без него плагин работать не будет.");
                    config.names.Add(new ChatPrivilege()
                    {
                        Arg = "default",
                        Perm = "chatplus.default",
                        Format = "<color=#ffffff>{0}</color>"
                    });
                    Config.WriteObject(config);
                }
                if (!config.messages.Any(c => c.Perm == "chatplus.default"))
                {
                    PrintWarning("Не удаляйте привилегию chatplus.default! Стандартный вид сообщений восстановлен. Без него плагин работать не будет.");
                    config.messages.Add(new ChatPrivilege()
                    {
                        Arg = "default",
                        Perm = "chatplus.default",
                        Format = "<color=#ffffff>{0}</color>"
                    });
                    Config.WriteObject(config);
                }
                if (!config.prefixes.Any(c => c.Perm == "chatplus.default"))
                {
                    PrintWarning("Не удаляйте привилегию chatplus.default! Стандартный перфикс восстановлен. Без него плагин работать не будет.");
                    config.prefixes.Add(new ChatPrivilege()
                    {
                        Arg = "default",
                        Perm = "chatplus.default",
                        Format = ""
                    });
                    Config.WriteObject(config);
                }
                //Для совместимости с прошлыми версиями
                bool changed = false;
                if (config.ConsoleName == null)
                {
                    PrintWarning("В файл конфигурации добавлен новый параметр - \"M. Имя консоли при отправке личных сообщений и отключении чата из консоли\"");
                    config.ConsoleName = "Server Console";
                    changed = true;
                }
                if (config.ConsoleFormat == null)
                {
                    PrintWarning("В файл конфигурации добавлен новый параметр - \"N. Формат отправки сообщений из консоли командой say\"");
                    config.ConsoleFormat = "[+16][#00ff00]{0}[/#]: {1}[/+]";
                    changed = true;
                }
                if (!config.PMAva.HasValue)
                {
                    PrintWarning("В файл конфигурации добавлен новый параметр - \"O. Отображать ли аватарки игроков при получении ЛС(только RUST)\"");
                    config.PMAva = true;
                    changed = true;
                }
                if (!config.adminPrivilages.HideAdmins.HasValue)
                {
                    PrintWarning("В файл конфигурации добавлен новый параметр - \"H - Скрывать имена администраторов при блокировке чата\"");
                    config.adminPrivilages.HideAdmins = false;
                    changed = true;
                }
                if(config.adminPrivilages.AdminReplace == null)
                {
                    PrintWarning("В файл конфигурации добавлен новый параметр - \"H - Замена имени администратора при блокировке чата(если включено)\"");
                    config.adminPrivilages.AdminReplace = "Модератор чата";
                    changed = true;
                }
                if (changed)
                    SaveConfig();
            }
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
        #endregion

        #region Configuration
        public class ChatPrivilege
        {
            [JsonProperty("Привилегия")]
            public string Perm;
            [JsonProperty("Аргумент")]
            public string Arg;
            [JsonProperty("Формат")]
            public string Format;
        }
        public class AdminPrivilages
        {
            [JsonProperty("Привилегия для включения режима администратора")]
            public string AdminPermiss;
            [JsonProperty("Привилегия для включения режима модератора")]
            public string ModerPermiss;
            [JsonProperty("Привилегия для использования команды /mute")]
            public string MutePermiss;
            [JsonProperty("Привилегия для использования команды /unmute")]
            public string UnMutePermiss;
            [JsonProperty("Формат чата режима администратор")]
            public string AdminFormat;
            [JsonProperty("Формат чата режима модератор")]
            public string ModerFormat;
            [JsonProperty("Привилегия для полного отключения чата")]
            public string MuteAllPermiss;
            [JsonProperty("Привилегия для использования консольных команд на присваивание префикса и цветов")]
            public string AssignPermiss;
            [JsonProperty("Скрывать имена администраторов при блокировке чата")]
            public bool? HideAdmins;
            [JsonProperty("Замена имени администратора при блокировке чата(если включено)")]
            public string AdminReplace;
        }
        public class ChatConfig
        {
            [JsonProperty("A. Автоматически блокировать чат за нецензурную лексику")]
            public bool BadWordsBlock;
            [JsonProperty("B. Длительность блокировки чата за нецензурную лексику(в секундах)")]
            public int MuteBadWordsDefault;
            [JsonProperty("C. Причина мута при автоматической блокировке чата за нецензурную лексику")]
            public string MuteReasonAutoMute;
            [JsonProperty("D. Стандартная причина мута")]
            public string MuteReason;
            [JsonProperty("E. Воспроизводить звук при получении личного сообщения")]
            public bool PrivateSoundMessage;
            [JsonProperty("F. Полный путь к звуковому файлу")]
            public string PrivateSoundMessagePath;
            [JsonProperty("G. Выключить заглавные буквы в чате")]
            public bool CapsBlock;
            [JsonProperty("H. Настройки привелегий администраторов")]
            public AdminPrivilages adminPrivilages;
            [JsonProperty("I. Цвет имен")]
            public List<ChatPrivilege> names;
            [JsonProperty("J. Префиксы")]
            public List<ChatPrivilege> prefixes;
            [JsonProperty("K. Цвет сообщений")]
            public List<ChatPrivilege> messages;
            [JsonProperty("L. Список начальных букв нецензурных слов или слова целиком | список исключений")]
            public Dictionary<string, List<string>> badWords;
            [JsonProperty("M. Имя консоли при отправке личных сообщений и отключении чата из консоли")]
            public string ConsoleName;
            [JsonProperty("N. Формат отправки сообщений из консоли командой say")]
            public string ConsoleFormat;
            [JsonProperty("O. Отображать ли аватарки игроков при получении ЛС(только RUST)")]
            public bool? PMAva;
            public void RegisterPerms()
            {
                PermissionService.RegisterPermissions(prefixes.Select(p => p.Perm).ToList());
                PermissionService.RegisterPermissions(names.Select(p => p.Perm).ToList());
                PermissionService.RegisterPermissions(messages.Select(p => p.Perm).ToList());
                PermissionService.RegisterPermissions(new List<string>()
                {
                    adminPrivilages.AdminPermiss,
                    adminPrivilages.ModerPermiss,
                    adminPrivilages.MutePermiss,
                    adminPrivilages.MuteAllPermiss,
                    adminPrivilages.AssignPermiss,
                    adminPrivilages.UnMutePermiss
                });
            }

            public ChatPrivilege Get(List<ChatPrivilege> list, string perm)
            {
                return list.FirstOrDefault(p => p.Perm == perm);
            }
        }
        #endregion

        #region API
        bool IsPlayerMuted(object id) => MuteData.IsMuted(id.ToString());
        void OnPluginUnloaded(Plugin plugin)
        {
            if (ThirdPartyTitles.ContainsKey(plugin))
                ThirdPartyTitles.Remove(plugin);
        }
        private void API_RegisterThirdPartyTitle(Plugin plugin, Func<IPlayer, string> titleGetter) => ThirdPartyTitles[plugin] = titleGetter;
        #endregion

        #region PermissionService

        public static class PermissionService
        {
            public static Permission permission = Interface.GetMod().GetLibrary<Permission>();

            public static bool HasPermission(string uid, string permissionName)
            {
                return !string.IsNullOrEmpty(permissionName) && permission.UserHasPermission(uid, permissionName);
            }

            public static void RegisterPermissions(List<string> permissions)
            {
                if (permissions == null) throw new ArgumentNullException("commands");

                foreach (var permissionName in permissions.Where(permissionName => !permission.PermissionExists(permissionName)))
                {
                    permission.RegisterPermission(permissionName, m_Instance);
                }
            }
            public static bool UserIDVaild(string userID)
            {
                return permission.UserIdValid(userID);
            }
        }

        #endregion
    }
}
///////////////////////////////////////////////


// --- End of file: ChatPlus.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AAlertRaidEN-2.0.1.cs ---
// --- Original Local Path: AAlertRaidEN-2.0.1.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;
using CompanionServer;
using Oxide.Ext.Discord.Entities;
using System.Text.RegularExpressions;
using Oxide.Core.Libraries.Covalence;
using ru = Oxide.Game.Rust;
using ConVar;
using Oxide.Ext.Discord.Builders;
using Oxide.Ext.Discord.Clients;
using Oxide.Ext.Discord.Connections;
using Oxide.Ext.Discord.Constants;
using Oxide.Ext.Discord.Extensions;
using Oxide.Ext.Discord.Interfaces;
using Oxide.Ext.Discord.Libraries;
using Oxide.Ext.Discord.Logging;

namespace Oxide.Plugins
{
    [Info("AAlertRaidEN", "fermens", "2.0.1")]
    public class AAlertRaidEN : RustPlugin, IDiscordPlugin
    {
        #region CONFIG
        const bool fermensEN = true;

        private static PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }


        class VK
        {
            [JsonProperty(fermensEN ? "Enable?" : "Включить?")]
            public bool enable;

            [JsonProperty(fermensEN ? "API" : "API от группы")]
            public string api;

            [JsonProperty(fermensEN ? "Link to the group" : "Ссылка на группу")]
            public string link;

            [JsonProperty(fermensEN ? "Cooldown for sending" : "Кд на отправку")]
            public float cooldown;
        }
        class RUSTPLUS
        {
            [JsonProperty(fermensEN ? "Enable?" : "Включить?")]
            public bool enable;

            [JsonProperty(fermensEN ? "Cooldown for sending" : "Кд на отправку")]
            public float cooldown;
        }
        class INGAME
        {
            [JsonProperty(fermensEN ? "Enable?" : "Включить?")]
            public bool enable;

            [JsonProperty(fermensEN ? "Cooldown for sending" : "Кд на отправку")]
            public float cooldown;

            [JsonProperty(fermensEN ? "Send game effect when notification are received" : "Эффект при получении уведомления")]
            public string effect;

            [JsonProperty(fermensEN ? "Time after the UI is destroyed" : "Время, через которое пропадает UI [секунды]")]
            public float destroy;

            [JsonProperty("UI")]
            public string UI;
        }

        class DISCORD
        {
            [JsonProperty(fermensEN ? "Enable?" : "Включить?")]
            public bool enable;

            [JsonProperty(fermensEN ? "Cooldown for sending" : "Кд на отправку")]
            public float cooldown;

            [JsonProperty(fermensEN ? "Invitation link" : "Приглашение в группу")]
            public string link;

            [JsonProperty(fermensEN ? "Token (https://discordapp.com/developers/applications)" : "Токен бота (https://discordapp.com/developers/applications)")]
            public string token;

            [JsonProperty(fermensEN ? "Channel ID, where the player will take the code to confirm the profile" : "ID канала, гле игрок будет брать код, для подтверджения профиля")]
            public string channel;

            [JsonProperty(fermensEN ? "Server ID" : "ID Сервера")]
            public ulong server;

            [JsonProperty(fermensEN ? "Info text" : "Дискорд канал с получением кода - текст")]
            public string channeltext;

            [JsonProperty(fermensEN ? "Info text - line color on the left" : "Дискорд канал с получением кода - цвет линии слева (https://gist.github.com/thomasbnt/b6f455e2c7d743b796917fa3c205f812#file-code_colors_discordjs-md)")]
            public uint channelcolor;

            [JsonProperty(fermensEN ? "Text on button" : "Дискорд канал с получением кода - кнопка")]
            public string channelbutton;

            [JsonProperty(fermensEN ? "Reply after button click" : "Дискорд канал с получением кода - ответ")]
            public string channelex;

            [JsonProperty(fermensEN ? "Don't touch this field" : "Дискорд канал с получением кода - ID сообщения (не трогаем! сам заполнится!)")]
            public string channelmessageid;
        }

        class TELEGRAM
        {
            [JsonProperty(fermensEN ? "Enable?" : "Включить?")]
            public bool enable;

            [JsonProperty(fermensEN ? "Cooldown for sending" : "Кд на отправку")]
            public float cooldown;

            [JsonProperty(fermensEN ? "Bot tag" : "Тэг бота")]
            public string bottag;

            [JsonProperty(fermensEN ? "Token" : "Токен")]
            public string token;
        }

        class UIMenu
        {
            [JsonProperty(fermensEN ? "Background color" : "Цвет фона")]
            public string background;

            [JsonProperty(fermensEN ? "Strip color" : "Цвет полоски")]
            public string stripcolor;

            [JsonProperty(fermensEN ? "Rectangular container background color" : "Цвет фона прямоугольного контейнера")]
            public string rectangularcolor;

            [JsonProperty(fermensEN ? "Button text color" : "Цвет текста в кнопке")]
            public string buttoncolortext;

            [JsonProperty(fermensEN ? "Text color" : "Цвет текста")]
            public string textcolor;

            [JsonProperty(fermensEN ? "Green button color" : "Цвет зелёной кнопки")]
            public string greenbuttoncolor;

            [JsonProperty(fermensEN ? "Red button color" : "Цвет красной кнопки")]
            public string redbuttoncolor;

            [JsonProperty(fermensEN ? "Gray button color" : "Цвет серой кнопки")]
            public string graybuttoncolor;

            [JsonProperty(fermensEN ? "Header text color" : "Цвет текста заголовка")]
            public string headertextcolor;

            [JsonProperty(fermensEN ? "Error text color" : "Цвет текста ошибки")]
            public string errortextcolor;

            [JsonProperty(fermensEN ? "Text color of <exit> and <back> buttons" : "Цвет текста кнопок <выход> и <назад>")]
            public string colortextexit;

            [JsonProperty(fermensEN ? "Rectangular container text color" : "Цвет текст прямоугольного контейнера")]
            public string rectangulartextcolor;

            [JsonProperty(fermensEN ? "The color of the text with hints at the bottom of the screen" : "Цвет текста с подсказками внизу экрана")]
            public string hintstextcolor;

            [JsonProperty(fermensEN ? "Abbreviations and their colors" : "Аббревиатуры и их цвета")]
            public UIMainMenu uIMainMenu;
        }

        class UIMainMenu
        {
            [JsonProperty(fermensEN ? "Abbreviation for telegram" : "Аббревиатура для телеграма")]
            public string abr_telegram;

            [JsonProperty(fermensEN ? "Telegram icon color" : "Цвет иконки телеграма")]
            public string color_telegram;

            [JsonProperty(fermensEN ? "Abbreviation for vk.com" : "Аббревиатура для вконтакте")]
            public string abr_vk;

            [JsonProperty(fermensEN ? "Vk.com icon color" : "Цвет иконки вконтакте")]
            public string color_vk;

            [JsonProperty(fermensEN ? "Abbreviation for rust+" : "Аббревиатура для rust+")]
            public string abr_rustplus;

            [JsonProperty(fermensEN ? "Rust+ icon color" : "Цвет иконки rust+")]
            public string color_rustplus;

            [JsonProperty(fermensEN ? "Abbreviation for discord" : "Аббревиатура для дискорда")]
            public string abr_discord;

            [JsonProperty(fermensEN ? "Discord icon color" : "Цвет иконки дискорда")]
            public string color_discord;

            [JsonProperty(fermensEN ? "Abbreviation for in game" : "Аббревиатура для графическое отображение в игре")]
            public string abr_ui;

            [JsonProperty(fermensEN ? "In game icon color" : "Цвет иконки графическое отображение в игре")]
            public string color_ui;
        }

        private class PluginConfig
        {
            [JsonProperty(fermensEN ? "Server name, will using for alerts" : "Название сервера - для оповещений")]
            public string servername;

            [JsonProperty(fermensEN ? "Raid alert works only for those who have permission" : "Оповещение о рейде работает только для тех, у кого есть разрешение")]
            public bool needpermission;

            [JsonProperty(fermensEN ? "VK.com" : "Оповещание о рейде в ВК")]
            public VK vk;

            [JsonProperty(fermensEN ? "Rust+" : "Оповещание о рейде в Rust+")]
            public RUSTPLUS rustplus;

            [JsonProperty(fermensEN ? "In game" : "Оповещание о рейде в игре")]
            public INGAME ingame;

            [JsonProperty(fermensEN ? "Discord" : "Оповещание о рейде в дискорд")]
            public DISCORD discord;

            [JsonProperty(fermensEN ? "Telegram" : "Оповещание о рейде в телеграм")]
            public TELEGRAM telegram { get; set; } = new TELEGRAM
            {
                token = "",
                cooldown = 1200f,
                enable = true,
                bottag = "@haxlite_bot"
            };

            [JsonProperty(fermensEN ? "Menu UI" : "Настройка UI")]
            public UIMenu ui { get; set; } = new UIMenu
            {
                background = "0.07843138 0.06666667 0.1098039 0.9490196",
                stripcolor = "0.8784314 0.9843137 1 0.5686275",
                rectangularcolor = "0.8901961 0.8901961 0.8901961 0.4156863",
                graybuttoncolor = "0.8901961 0.8901961 0.8901961 0.4156863",
                buttoncolortext = "1 1 1 0.9056942",
                rectangulartextcolor = "1 1 1 0.7843137",
                textcolor = "1 1 1 1",
                headertextcolor = "1 1 1 1",
                hintstextcolor = "1 1 1 0.6699298",
                greenbuttoncolor = "0.5450981 1 0.6941177 0.509804",
                errortextcolor = "1 0.5429931 0.5429931 0.787812",
                colortextexit = "0.5938045 0.5789595 0.5789595 1",
                redbuttoncolor = "1 0.5450981 0.5450981 0.509804",
                uIMainMenu = new UIMainMenu
                {
                    abr_discord = "DS",
                    abr_rustplus = "R+",
                    abr_telegram = "TG",
                    abr_ui = "UI",
                    abr_vk = "VK",
                    color_discord = "0.6313726 0.5764706 1 0.4156863",
                    color_rustplus = "1 0.5803921 0.6013725 0.4156863",
                    color_vk = "0.5803922 0.6627451 1 0.4156863",
                    color_ui = "1 0.7843137 0.5764706 0.4156863",
                    color_telegram = "0.5479987 0.9459876 1 0.4156863"
                }
            };


            [JsonProperty(fermensEN ? "Additional list" : "Дополнительный список предметов, которые учитывать")]
            public string[] spisok;

            [JsonProperty(fermensEN ? "Notification when usual items are destroyed" : "Оповещение при уничтожении обычных предметов")]
            public bool extralist;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    servername = "HaxLite X10",
                    vk = new VK
                    {
                        api = "",
                        cooldown = 1200f,
                        enable = true,
                    },
                    rustplus = new RUSTPLUS
                    {
                        cooldown = 600f,
                        enable = true
                    },
                    ingame = new INGAME
                    {
                        cooldown = 60f,
                        enable = true,
                        effect = "assets/prefabs/weapons/toolgun/effects/repairerror.prefab",
                        destroy = 4f,
                        UI = "[{\"name\":\"UIA\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"material\":\"assets/content/ui/uibackgroundblur.mat\", \"sprite\":\"assets/content/ui/ui.background.transparent.linearltr.tga\",\"color\":\"0 0 0 0.6279221\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 0.5\",\"anchormax\":\"1 0.5\",\"offsetmin\":\"-250 -30\",\"offsetmax\":\"0 30\"}]},{\"name\":\"D\",\"parent\":\"UIA\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"1 0 0 0.392904\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 0\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 5\"}]},{\"name\":\"T\",\"parent\":\"UIA\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{text}\",\"fontSize\":12,\"align\":\"MiddleLeft\",\"color\":\"1 1 1 0.8644356\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"5 0\",\"offsetmax\":\"-5 0\"}]},{\"name\":\"U\",\"parent\":\"UIA\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"1 0 0 0.3921569\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 1\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 -5\",\"offsetmax\":\"0 0\"}]}]"
                    },
                    discord = new DISCORD
                    {
                        cooldown = 600f,
                        enable = true,
                        token = "",
                        channel = "",
                        channelbutton = fermensEN ? "Get code" : "Получить код",
                        channelex = fermensEN ? "Your code: {code}" : "Ваш код: {code}",
                        channelmessageid = "",
                        channeltext = fermensEN ? "Enter the received code in the integration menu for raid alerts.\nChat command /raid\nEnter it in the game itself, not in the discord!" : "Введите полученый код в меню интеграции дискорда с игровым профилем.\nЧат команда /raid\nВводить в самой игре, а не в дискорде!",
                        channelcolor = 14177041
                    },
                    spisok = _spisok
                };
            }
        }
        private static string[] _spisok = new string[] { "wall.external.high", "wall.external.high.stone", "gates.external.high.wood", "gates.external.high.stone", "wall.window.bars.metal", "wall.window.bars.toptier", "wall.window.glass.reinforced", "wall.window.bars.wood" };

        #endregion

        #region DISCORD
        private readonly BotConnection _discordSettings = new BotConnection
        {
            Intents = GatewayIntents.GuildMessages | GatewayIntents.DirectMessages | GatewayIntents.Guilds | GatewayIntents.GuildMembers
        };
        private DiscordGuild _guild;
        public DiscordClient Client { get; set; }

        private void CreateClient()
        {
            _discordSettings.ApiToken = config.discord.token;
            _discordSettings.LogLevel = Ext.Discord.Logging.DiscordLogLevel.Error;
            Client.Connect(_discordSettings);
            
            timer.Once(5f, () =>
            {
                try
                {
                    if (Client == null)
                    {
                        CreateClient();
                        Debug.Log("Discord reconnecting in 5 sec...");
                    }
                    else
                    {
                        _guild = Client.Bot.GetGuild(new Snowflake(config.discord.server));
                        Debug.Log(fermensEN ? $"DISCORD BOT CONNECTED TO {_guild.Name}." : $"DISCORD БОТ АВТОРИЗОВАН НА СЕРВЕРЕ {_guild.Name}.");

                        DiscordChannel channel;
                        if (!_guild.Channels.TryGetValue(new Snowflake(config.discord.channel), out channel))
                        {
                            Debug.Log(fermensEN ? $"CHANNEL NOT FOUND! ({_guild.Channels.Count})" : $"КАНАЛ НЕ СУЩЕСТВУЕТ! ({_guild.Channels.Count})");
                            return;
                        }

                        var embeds = new List<DiscordEmbed> { new DiscordEmbed { Color = new DiscordColor(config.discord.channelcolor), Description = config.discord.channeltext } };
                        var components = CreateComponents(config.discord.channelbutton);
                        if (!string.IsNullOrEmpty(config.discord.channelmessageid) && ulong.TryParse(config.discord.channelmessageid, out ulong num) && num < 9223372036854775807)
                        {
                            channel.GetMessage(Client, new Snowflake(config.discord.channelmessageid)).Then(message =>
                            {
                                message.Edit(Client, new MessageUpdate { Embeds = embeds, Components = components });

                            }).Catch(error =>
                            {
                                DiscordCreateMessage(channel, embeds, components);
                            });
                        }
                        else
                        {
                            DiscordCreateMessage(channel, embeds, components);
                        }
                    }
                }
                catch { }
            });
        }

        private void DiscordCreateMessage(DiscordChannel channel, List<DiscordEmbed> embeds, List<ActionRowComponent> components)
        {
            var promise = channel?.CreateMessage(Client, new MessageCreate { Embeds = embeds, Components = components }).Then(message =>
            {
                config.discord.channelmessageid = message.Id;
                SaveConfig();
            });
        }

        [HookMethod(DiscordExtHooks.OnDiscordInteractionCreated)]
        private void OnDiscordInteractionCreated(DiscordInteraction interaction)
        {
            if (interaction.Type != InteractionType.MessageComponent)
            {
                return;
            }

            if (!interaction.Data.ComponentType.HasValue || interaction.Data.ComponentType.Value != MessageComponentType.Button || interaction.Data.CustomId != $"{Name}_{ConVar.Server.ip}_{ConVar.Server.port}")
            {
                return;
            }

            DiscordUser user = interaction.User ?? interaction.Member?.User;
            HandleAcceptLinkButton(interaction, user);

        }
        private void HandleAcceptLinkButton(DiscordInteraction interaction, DiscordUser user)
        {
            string num;
            if (!DISCORDCODES.TryGetValue(user.Id.Id, out num))
            {
                num = DISCORDCODES[user.Id.Id] = RANDOMNUM();
            }
            string linkMessage = Formatter.ToPlaintext(config.discord.channelex.Replace("{code}", num));
            interaction.CreateResponse(Client, new InteractionResponse
            {
                Type = InteractionResponseType.ChannelMessageWithSource,
                Data = new InteractionCallbackData
                {
                    Content = linkMessage,
                    Flags = MessageFlags.Ephemeral
                }
            });
        }

        private void CloseClient()
        {
            if (Client != null) Client.Disconnect();
        }

        private void CREATECHANNEL(string dsid, string text)
        {
            Snowflake ss = new Snowflake(dsid);
            if (!_guild.Members.Any(x => x.Value.User.Id == ss)) return;
            _guild.Members.First(x => x.Value.User.Id == ss).Value.User.SendDirectMessage(Client, new MessageCreate { Content = text });
        }

        private void SENDMESSAGE(string dsid, string text)
        {
            DiscordChannel channel = _guild.GetChannel(dsid);

            if (channel != null)
            {
                channel?.CreateMessage(Client, text);
            }
            else
            {
                CREATECHANNEL(dsid, text);
            }
        }

        public List<ActionRowComponent> CreateComponents(string button)
        {
            MessageComponentBuilder builder = new MessageComponentBuilder();
            builder.AddActionButton(ButtonStyle.Success, button, $"{Name}_{ConVar.Server.ip}_{ConVar.Server.port}", false);

            return builder.Build();
        }

        private readonly List<Regex> _regexTags = new List<Regex>
        {
            new Regex("<color=.+?>", RegexOptions.Compiled),
            new Regex("<size=.+?>", RegexOptions.Compiled)
        };

        private readonly List<string> _tags = new List<string>
        {
            "</color>",
            "`",
            "</size>",
            "<i>",
            "</i>",
            "<b>",
            "</b>"
        };

        private string STRIP(string original)
        {
            if (string.IsNullOrEmpty(original))
            {
                return string.Empty;
            }

            foreach (string tag in _tags)
            {
                original = original.Replace(tag, "");
            }

            foreach (Regex regexTag in _regexTags)
            {
                original = regexTag.Replace(original, "");
            }

            return original;
        }

        private DiscordChannel GetChannel(string id)
        {
            return _guild.Channels.FirstOrDefault(x => x.Key.ToString() == id).Value;
        }
        #endregion

        #region STORAGE
        string connect = "14.02.22:1406";

        //{fon}

        string FON = "";
        string MAIN = "";
        string UI = "";
        string IF2 = "";
        string IF2A = "";
        string BTN = "";
        string ER = "";
        string IBLOCK = "";
        string MAINH = "";
        string AG = "";
        string EXIT = "";
        string BACK = "";

        #region Data
        class Storage
        {
            public string vk;
            public string telegram;
            public ulong discord;
            public bool rustplus;
            public bool ingamerust { get; set; } = true;
        }

        #region fermens#8767
        #endregion

        private Storage GetStorage(ulong userid)
        {
            Storage storage;
            if (datas.TryGetValue(userid, out storage)) return storage;

            string useridstring = userid.ToString();
            if (!Interface.Oxide.DataFileSystem.ExistsDatafile($"AAlertRaid/{useridstring}"))
            {
                storage = new Storage();
                datas.Add(userid, storage);
                return storage;
            }

            storage = Interface.Oxide.DataFileSystem.ReadObject<Storage>($"AAlertRaid/{useridstring}");
            datas.Add(userid, storage);
            return storage;
        }

        private void SaveStorage(BasePlayer player)
        {
            Storage storage;
            if (datas.TryGetValue(player.userID, out storage))
            {
                ServerMgr.Instance.StartCoroutine(Saving(player.UserIDString, storage));
            }
        }

        private IEnumerator Saving(string userid, Storage storage)
        {
            yield return new WaitForSeconds(1f);
            Interface.Oxide.DataFileSystem.WriteObject($"AAlertRaid/{userid}", storage);
        }

        Dictionary<ulong, Storage> datas = new Dictionary<ulong, Storage>();
        #endregion
        #endregion

        #region API TELEGRAM 
        private void GetRequestTelegram(string reciverID, string msg, BasePlayer player = null, bool accept = false) => webrequest.Enqueue($"https://api.telegram.org/bot" + config.telegram.token + "/sendMessage?chat_id=" + reciverID + "&text=" + Uri.EscapeDataString(msg), null, (code2, response2) => ServerMgr.Instance.StartCoroutine(GetCallbackTelegram(code2, response2, reciverID, player, accept)), this);

        private IEnumerator GetCallbackTelegram(int code, string response, string id, BasePlayer player = null, bool accept = false)
        {
            if (player == null || response == null) yield break;

            if (code == 401)
            {
                Debug.LogError("[AlertRaid] Telegram token not valid!");
            }
            else if (code == 200)
            {
                if (!response.Contains("error_code"))
                {
                    ALERT aLERT;
                    if (alerts.TryGetValue(player.userID, out aLERT))
                    {
                        aLERT.vkcodecooldown = DateTime.Now.AddMinutes(1);
                    }
                    else
                    {
                        alerts.Add(player.userID, new ALERT { telegramcodecooldown = DateTime.Now.AddMinutes(1) });
                    }

                    Storage storage = GetStorage(player.userID);
                    storage.telegram = id;
                    SaveStorage(player);

                    write[player.userID] = "";
                    OpenMenu(player, false);
                }
            }
            else
            {
                SendError(player, "telegramuseridnotfound");
            }
            yield break;
        }
        #endregion

        #region API VK
        const string connects = "001.002.2022:1508";
        class ALERT
        {
            public DateTime gamecooldown;
            public DateTime rustpluscooldown;
            public DateTime vkcooldown;
            public DateTime discordcooldown;
            public DateTime vkcodecooldown;

            public DateTime telegramcooldown;
            public DateTime telegramcodecooldown;
        }

        private static Dictionary<ulong, ALERT> alerts = new Dictionary<ulong, ALERT>();
        class CODE
        {
            public string id;
            public ulong gameid;
        }

        private Dictionary<string, CODE> VKCODES = new Dictionary<string, CODE>();
        private Dictionary<ulong, string> DISCORDCODES = new Dictionary<ulong, string>();

        private void GetRequest(string reciverID, string msg, BasePlayer player = null, string num = null) => webrequest.Enqueue("https://api.vk.com/method/messages.send?domain=" + reciverID + "&message=" + Uri.EscapeDataString(msg) + "&v=5.81&access_token=" + config.vk.api, null, (code2, response2) => ServerMgr.Instance.StartCoroutine(GetCallbackVK(code2, response2, reciverID, player, num)), this);

        private void SendError(BasePlayer player, string key)
        {
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "ER");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", ER.Replace("{e0}", GetMessage(key, player.UserIDString)));
        }
        private IEnumerator GetCallbackVK(int code, string response, string id, BasePlayer player = null, string num = null)
        {
            if (player == null) yield break;
            if (response == null || code != 200)
            {
                ALERT alert;
                if (alerts.TryGetValue(player.userID, out alert)) alert.vkcooldown = DateTime.Now;
                Debug.Log("НЕ ПОЛУЧИЛОСЬ ОТПРАВИТЬ СООБЩЕНИЕ В ВК! => обнулили кд на отправку");
                yield break;
            }
            yield return new WaitForEndOfFrame();
            if (!response.Contains("error"))
            {
                ALERT aLERT;
                if (alerts.TryGetValue(player.userID, out aLERT))
                {
                    aLERT.vkcodecooldown = DateTime.Now.AddMinutes(1);
                }
                else
                {
                    alerts.Add(player.userID, new ALERT { vkcodecooldown = DateTime.Now.AddMinutes(1) });
                }
                if (VKCODES.ContainsKey(num)) VKCODES.Remove(num);
                VKCODES.Add(num, new CODE { gameid = player.userID, id = id });
                write[player.userID] = "";
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "ER");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "BTN");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", IBLOCK);
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", BTN.Replace("{text1}", GetMessage("{text1}", player.UserIDString)).Replace("{color}", "1 1 1 0.509804"));
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", IF2.Replace("{t3}", GetMessage("{t4}", player.UserIDString)).Replace("{coma}", "").Replace("{text2}", GetMessage("{text2}", player.UserIDString)));
            }
            else if (response.Contains("PrivateMessage"))
            {
                SendError(player, "rnprivate");
            }
            else if (response.Contains("ErrorSend"))
            {
                SendError(player, "rnerror");
            }
            else if (response.Contains("BlackList"))
            {
                SendError(player, "rnblack");
            }
            else
            {
                SendError(player, "rnerror2");
            }
            yield break;
        }
        #endregion

        #region COMMANDS
        private string perm = "discord fermens#8767";
        [PluginReference] Plugin BMenu;

        private void callcommandrn(BasePlayer player, string command, string[] arg)
        {
            OpenMenu(player);
        }

        private bool HasAcces(string id)
        {
            if (!config.needpermission) return true;
            return permission.UserHasPermission(id, perm);
        }

        private void OpenMenu(BasePlayer player, bool first = true)
        {
            if (!HasAcces(player.UserIDString))
            {
                player.ChatMessage(GetMessage("permission", player.UserIDString));
                return;
            }

            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "SubContent_UI");
            if (first)
            {
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "Main_UI");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", FON);
                if (BMenu != null)
                {
                    BMenu.Call("DestroyProfileLayers", player);
                    BMenu.Call("SetPage", (ulong)player.userID, "raid");
                    BMenu.Call("SetActivePButton", player, "raid");
                }
            }
            //0.5450981 1 0.6941177 0.509804
            //{\"name\":\"Main_UI\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.07843138 0.06666667 0.1098039 0.9490196\",\"material\":\"assets/content/ui/uibackgroundblur.mat\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", MAIN);
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "E");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", EXIT.Replace("{t7}", GetMessage("{t7}", player.UserIDString)));
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", MAINH.Replace("{a0}", GetMessage("{amain}", player.UserIDString)));
            int num = 0;
            Storage storage = GetStorage(player.userID);
            #region VK
            if (config.vk.enable && !string.IsNullOrEmpty(config.vk.api))
            {
                if (!string.IsNullOrEmpty(storage.vk)) AddElementUI(player, GetMessage("{element_vk}", player.UserIDString), config.ui.graybuttoncolor, GetMessage("{element_disable}", player.UserIDString), "raid.vkdelete", config.ui.uIMainMenu.abr_vk, config.ui.uIMainMenu.color_vk, num);
                else AddElementUI(player, GetMessage("{element_vk}", player.UserIDString), config.ui.greenbuttoncolor, GetMessage("{element_setup}", player.UserIDString), "raid.vkadd", config.ui.uIMainMenu.abr_vk, config.ui.uIMainMenu.color_vk, num);
                num++;
            }
            #endregion

            #region Telegram
            if (config.telegram.enable && !string.IsNullOrEmpty(config.telegram.token))
            {
                if (!string.IsNullOrEmpty(storage.telegram)) AddElementUI(player, GetMessage("{element_telegram}", player.UserIDString), config.ui.graybuttoncolor, GetMessage("{element_disable}", player.UserIDString), "raid.tgdelete", config.ui.uIMainMenu.abr_telegram, config.ui.uIMainMenu.color_telegram, num);
                else AddElementUI(player, GetMessage("{element_telegram}", player.UserIDString), config.ui.greenbuttoncolor, GetMessage("{element_setup}", player.UserIDString), "raid.tgadd", config.ui.uIMainMenu.abr_telegram, config.ui.uIMainMenu.color_telegram, num);
                num++;
            }
            #endregion

            #region Rust+
            if (config.rustplus.enable && !string.IsNullOrEmpty(App.serverid) && App.port > 0 && App.notifications)
            {
                if (!storage.rustplus) AddElementUI(player, GetMessage("{element_rustplus}", player.UserIDString), config.ui.greenbuttoncolor, GetMessage("{element_enable}", player.UserIDString), "raid.rustplus", config.ui.uIMainMenu.abr_rustplus, config.ui.uIMainMenu.color_rustplus, num);
                else AddElementUI(player, GetMessage("{element_rustplus}", player.UserIDString), config.ui.graybuttoncolor, GetMessage("{element_disable}", player.UserIDString), "raid.rustplus", config.ui.uIMainMenu.abr_rustplus, config.ui.uIMainMenu.color_rustplus, num);
                num++;
            }
            #endregion

            #region InGame
            if (config.ingame.enable)
            {
                if (!storage.ingamerust) AddElementUI(player, GetMessage("{element_ingame}", player.UserIDString), config.ui.greenbuttoncolor, GetMessage("{element_enable}", player.UserIDString), "raid.ingame", config.ui.uIMainMenu.abr_ui, config.ui.uIMainMenu.color_ui, num);
                else AddElementUI(player, GetMessage("{element_ingame}", player.UserIDString), config.ui.graybuttoncolor, GetMessage("{element_disable}", player.UserIDString), "raid.ingame", config.ui.uIMainMenu.abr_ui, config.ui.uIMainMenu.color_ui, num);
                num++;
            }
            #endregion

            #region Discord
            if (config.discord.enable && !string.IsNullOrEmpty(config.discord.token))
            {
                if (storage.discord == 0UL) AddElementUI(player, GetMessage("{element_discord}", player.UserIDString), config.ui.greenbuttoncolor, GetMessage("{element_setup}", player.UserIDString), "raid.discordadd", config.ui.uIMainMenu.abr_discord, config.ui.uIMainMenu.color_discord, num);
                else
                {
                    AddElementUI(player, GetMessage("{element_discord}", player.UserIDString), config.ui.graybuttoncolor, GetMessage("{element_disable}", player.UserIDString), "raid.discorddelete", config.ui.uIMainMenu.abr_discord, config.ui.uIMainMenu.color_discord, num);
                }
                num++;
            }
            #endregion
        }

        class C
        {
            public string min;
            public string max;
        }

        Dictionary<int, C> _caddele = new Dictionary<int, C>();

        private void AddElementUI(BasePlayer player, string name, string color, string button, string command, string ico, string icocolor, int num)
        {
            C ce;
            if (!_caddele.TryGetValue(num, out ce))
            {
                ce = new C();
                float start = 60f;
                float e = 30f;
                float p = 35f;
                float max = start - (num * p);
                ce.min = (max - e).ToString();
                ce.max = max.ToString();
                _caddele.Add(num, ce);
            }

            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", AG.Replace("{num}", num.ToString()).Replace("{id}", name).Replace("{coma}", command).Replace("{ico}", ico).Replace("{icocolor}", icocolor).Replace("{color}", color).Replace("{text1}", button).Replace("{min}", ce.min).Replace("{max}", ce.max));
        }

        Dictionary<ulong, string> write = new Dictionary<ulong, string>();

        [ConsoleCommand("raid.input")]
        void ccmdopeinput(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            string text = arg.HasArgs() ? string.Join(" ", arg.Args) : null;
            write[player.userID] = text;
        }

        private void SendError2(BasePlayer player, string key)
        {
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "BTN2");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", IF2A.Replace("{text2}", GetMessage(key, player.UserIDString)).Replace("{coma}", "").Replace("{color}", config.ui.redbuttoncolor));
            timer.Once(1f, () =>
            {
                if (!player.IsConnected) return;
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "BTN2");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", IF2A.Replace("{text2}", GetMessage("{text2}", player.UserIDString)).Replace("{coma}", "raid.accept").Replace("{color}", config.ui.greenbuttoncolor));
            });
        }

        #region InGame Comand
        [ConsoleCommand("raid.ingame")]
        void raplsgame(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            Storage storage = GetStorage(player.userID);
            storage.ingamerust = !storage.ingamerust;
            SaveStorage(player);
            OpenMenu(player, false);
        }
        #endregion


        #region Rust+ Comand
        [ConsoleCommand("raid.rustplus")]
        void rapls(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            Storage storage = GetStorage(player.userID);
            storage.rustplus = !storage.rustplus;
            SaveStorage(player);
            OpenMenu(player, false);
        }
        #endregion

        #region Discord command
        [ConsoleCommand("raid.discordadd")]
        void ccmdadiscoradd(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "SubContent_UI");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "E");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", MAIN);
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", BACK.Replace("{t7}", GetMessage("{back}", player.UserIDString)));
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", UI.Replace("{t7}", GetMessage("{d7}", player.UserIDString)).Replace("{t6}", GetMessage("{d6}", player.UserIDString)).Replace("{t5}", GetMessage("{d5}", player.UserIDString)).Replace("{t4}", GetMessage("{d3}", player.UserIDString)).Replace("{t2}", config.discord.link).Replace("{t1}", GetMessage("{d1}", player.UserIDString)).Replace("{t0}", GetMessage("{d0}", player.UserIDString))); ;
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", BTN.Replace("{text1}", GetMessage("{text2}", player.UserIDString)).Replace("{coma}", "raid.acceptds").Replace("{color}", config.ui.greenbuttoncolor));
        }

        [ConsoleCommand("raid.acceptds")]
        void raidacceptds(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            //0.8901961 0.8901961 0.8901961 0.4156863
            //1 0.5450981 0.5450981 0.509804
            // raid.accept
            string text;
            if (!write.TryGetValue(player.userID, out text) || string.IsNullOrEmpty(text))
            {
                SendError(player, "rnnocode");
                return;
            }


            ulong user = DISCORDCODES.FirstOrDefault(x => x.Value == text).Key;
            if (user != 0UL)
            {
                Storage storage = GetStorage(player.userID);
                storage.discord = user;
                SaveStorage(player);
                DISCORDCODES.Remove(user);
                OpenMenu(player, false);
            }
            else
            {
                SendError(player, "rncancel");
            }
        }

        [ConsoleCommand("raid.discorddelete")]
        void vdiscorddelete(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            Storage storage = GetStorage(player.userID);
            storage.discord = 0;
            SaveStorage(player);
            OpenMenu(player, false);
        }
        #endregion

        #region Telegram COmand
        [ConsoleCommand("raid.tgdelete")]
        void rgdelete(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            Storage storage = GetStorage(player.userID);
            storage.telegram = null;
            SaveStorage(player);
            OpenMenu(player, false);
        }

        [ConsoleCommand("raid.tgadd")]
        void ccmdtgadd(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "SubContent_UI");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "E");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", MAIN);
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", BACK.Replace("{t7}", GetMessage("{back}", player.UserIDString)));
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", UI.Replace("{t7}", GetMessage("{teleg7}", player.UserIDString)).Replace("{t6}", GetMessage("{teleg6}", player.UserIDString)).Replace("{t5}", GetMessage("{teleg5}", player.UserIDString)).Replace("{t4}", GetMessage("{teleg3}", player.UserIDString)).Replace("{t2}", GetMessage("{teleg2}", player.UserIDString).Replace("{tag}", config.telegram.bottag)).Replace("{t1}", GetMessage("{teleg1}", player.UserIDString).Replace("{tag}", config.telegram.bottag)).Replace("{t0}", GetMessage("{teleg0}", player.UserIDString)));
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", BTN.Replace("{text1}", GetMessage("{text2}", player.UserIDString)).Replace("{coma}", "raid.accepttg").Replace("{color}", config.ui.greenbuttoncolor));
        }

        [ConsoleCommand("raid.accepttg")]
        void ccmdaccepttg(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;

            ALERT aLERT;
            if (alerts.TryGetValue(player.userID, out aLERT) && aLERT.telegramcodecooldown > DateTime.Now)
            {
                SendError(player, "rnaddcooldown");
                return;
            }

            string text;
            if (!write.TryGetValue(player.userID, out text) || string.IsNullOrEmpty(text))
            {
                SendError(player, "telegid");
                return;
            }

            GetRequestTelegram(text, GetMessage("telegramadd", player.UserIDString), player, true);
        }
        #endregion

        #region Vk COmand
        [ConsoleCommand("raid.vkdelete")]
        void vkdelete(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            Storage storage = GetStorage(player.userID);
            storage.vk = null;
            SaveStorage(player);
            OpenMenu(player, false);
        }

        [ConsoleCommand("raid.vkadd")]
        void ccmdavkadd(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "SubContent_UI");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "E");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", MAIN);
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", BACK.Replace("{t7}", GetMessage("{back}", player.UserIDString)));
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", UI.Replace("{t7}", GetMessage("{t7}", player.UserIDString)).Replace("{t6}", GetMessage("{t6}", player.UserIDString)).Replace("{t5}", GetMessage("{t5}", player.UserIDString)).Replace("{t4}", GetMessage("{t3}", player.UserIDString)).Replace("{t2}", config.vk.link).Replace("{t1}", GetMessage("{t1}", player.UserIDString)).Replace("{t0}", GetMessage("{t0}", player.UserIDString)));
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", BTN.Replace("{text1}", GetMessage("{text1}", player.UserIDString)).Replace("{coma}", "raid.send").Replace("{color}", config.ui.greenbuttoncolor));
        }

        [ConsoleCommand("raid.accept")]
        void ccmdaccept(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            //0.8901961 0.8901961 0.8901961 0.4156863
            //1 0.5450981 0.5450981 0.509804
            // raid.accept
            string text;
            if (!write.TryGetValue(player.userID, out text) || string.IsNullOrEmpty(text))
            {
                SendError2(player, "rnnocode");
                return;
            }

            CODE cODE;
            if (VKCODES.TryGetValue(text, out cODE) && cODE.gameid == player.userID)
            {
                Storage storage = GetStorage(player.userID);
                storage.vk = cODE.id;
                SaveStorage(player);
                VKCODES.Remove(text);
                OpenMenu(player, false);
            }
            else
            {
                SendError2(player, "rncancel");
            }
        }

        [ConsoleCommand("raid.send")]
        void ccmdopesendt(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            ALERT aLERT;
            if (alerts.TryGetValue(player.userID, out aLERT) && aLERT.vkcodecooldown > DateTime.Now)
            {
                SendError(player, "rnaddcooldown");
                return;
            }

            string text;
            if (!write.TryGetValue(player.userID, out text) || string.IsNullOrEmpty(text))
            {
                SendError(player, "null");
                return;
            }

            string vkid = text.ToLower().Replace("vk.com/", "").Replace("https://", "").Replace("http://", "");
            string num = RANDOMNUM();
            GetRequest(vkid, GetMessage("code", player.UserIDString).Replace("{code}", num), player, num);
        }
        #endregion

        private string RANDOMNUM() => UnityEngine.Random.Range(1000, 99999).ToString();
        #endregion

        #region OXIDE HOOKS
        private void Unload()
        {
            CloseClient();
            //CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", "Main_UI");
        }

        private void OnServerInitialized()
        {
            ServerMgr.Instance.StartCoroutine(GetCallback());
        }

        #region WEBCONFIG

        public Dictionary<string, string> messagesEN = new Dictionary<string, string>
        {
            { "{t0}", "Join a group" },
            { "{element_vk}", "Vkontakte" },
            { "{element_telegram}", "Telegram" },
            { "{element_discord}", "Discord" },
            { "{element_rustplus}", "Rust+ app" },
            { "{element_ingame}", "Show in game" },
            { "{element_setup}", "Set up" },
            { "{element_disable}", "Disable" },
            { "{element_enable}", "Enable" },
            { "permission", "You do not have permission to use this command!" },
            { "{t1}", "Write any message to the group" },
            { "{t2}", "VK.COM/HAXLITE" },
            { "{t3}", "Link to your profile" },
            { "{t4}", "Check your mail in vk.com and enter the received code" },
            { "{t5}", "Enter text via Ctrl + V, so that commands binded on the keys that you press are not executed during input" },
            { "{t6}", "Set up alert" },
            { "{d0}", "Join the discord server" },
            { "{d1}", "Get the code in the 'Game Profile Integration' channel" },
            { "{d2}", "DISCORD.GG/CyFmAqGBED" },
            { "{d3}", "Enter the received code" },
            { "{d5}", "Enter text via Ctrl + V, so that commands binded on the keys that you press are not executed during input" },
            { "{d6}", "Set up alert" },
            { "{t7}", "EXIT" },
            { "{teleg0}", "Add the @userinfobot bot, press /start and copy the resulting Id" },
            { "{teleg1}", "Add bot {tag} and press /start" },
            { "{teleg2}", "{tag}" },
            { "{teleg3}", "Enter the copied Id" },
            { "{teleg5}", "Enter text via Ctrl + V, so that commands binded on the keys that you press are not executed during input" },
            { "{teleg6}", "Set up alert" },
            { "{back}", "BACK" },
            { "telegramuseridnotfound", "User id not found!" },
            { "telegramadd", "Now you will receive alert raid here" },
            { "telegid", "Enter the copied Id!" },
            { "{amain}", "Raid Alerts Control Panel" },
            { "{text1}", "Get code" },
            { "code", "Account verification code: {code}." },
            { "{text2}", "Confirm" },
            { "notallow", "Buy privilige to enable raid alerts in the store!" },
            { "rncancel", "Incorrect code!" },
            { "alertvk", "Attention! Player {name} destroyed {destroy} in square {quad}\nconnect {ip}" },
            { "alerttelegram", "Attention! Player {name} destroyed {destroy} in square {quad}\nconnect {ip}" },
            { "alertdiscord", "Attention! Player {name} destroyed {destroy} in square {quad}\nconnect {ip}" },
            { "alertrustplus", "Attention! Player {name} destroyed {destroy} in {quad}" },
            { "alertingame", "Player {name} destroyed {destroy} in {quad}" },
            { "null", "Enter the link to your profile!" },
            { "rnnocode", "No code provided!" },
            { "rnprivate", "Your privacy settings do not allow you to send a message." },
            { "rnerror", "The message could not be sent.\nPlease check the link is correct or try again later." },
            { "rnblack", "Unable to send message.\nYou have added a group to the black list or are not subscribed to it, if this is not the case, then simply write any message to the server group and try again." },
            { "rnerror2", "You have specified an incorrect link to your VK, if this is not the case, then simply write any message to the server group and try again." },
            { "rnaddcooldown", "You recently generated a verification code, please try again in a minute." },
            { "+wall Stone", "your stone wall" },
            { "+wall.low Stone", "your low stone wall" },
            { "+wall.frame Stone", "your stone wall frame" },
            { "+foundation Stone", "your stone foundation" },
            { "+roof Stone", "your stone roof" },
            { "+wall.doorway Stone", "your stone doorway" },
            { "+foundation.steps Stone", "your stone steps" },
            { "+block.stair.lshape Stone", "your stone L-stairs" },
            { "+block.stair.ushape Stone", "your stone U-ladder" },
            { "+foundation.triangle Stone", "your stone triangular foundation" },
            { "+wall.window Stone", "your stone window" },
            { "+wall.half Stone", "your stone half-wall" },
            { "+wall Metal", "your metal wall" },
            { "+wall.low Metal", "your metal low wall" },
            { "+wall.frame Metal", "your metal wall frame" },
            { "+foundation Metal", "your metal foundation" },
            { "+roof Metal", "your metal roof" },
            { "+wall.doorway Metal", "your metal doorway" },
            { "+foundation.steps Metal", "your metal stairs" },
            { "+block.stair.lshape Metal", "your metal L-ladder" },
            { "+block.stair.ushape Metal", "your metal U-ladder" },
            { "+foundation.triangle Metal", "your metal triangular foundation" },
            { "+wall.window Metal", "your metal window" },
            { "+wall.half Metal", "your metal half wall" },
            { "+wall TopTier", "your armored wall" },
            { "+wall.low TopTier", "your armored low wall" },
            { "+wall.frame TopTier", "your armored wall frame" },
            { "+foundation TopTier", "your armored foundation" },
            { "+roof TopTier", "your armored roof" },
            { "+wall.doorway TopTier", "your armored doorway" },
            { "+foundation.steps TopTier", "your armored steps" },
            { "+block.stair.lshape TopTier", "your armored L-ladder" },
            { "+block.stair.ushape TopTier", "your armored U-ladder" },
            { "+foundation.triangle TopTier", "your armored triangular foundation" },
            { "+wall.window TopTier", "your armored window" },
            { "+wall.half TopTier", "your armored half-wall" },
            { "+wall Wood", "your wooden wall" },
            { "+wall.low Wood", "your wooden low wall" },
            { "+wall.frame Wood", "your wooden wall frame" },
            { "+foundation Wood", "your wooden foundation" },
            { "+roof Wood", "your wooden roof" },
            { "+wall.doorway Wood", "your wooden doorway" },
            { "+foundation.steps Wood", "your wooden steps" },
            { "+block.stair.lshape Wood", "your wooden L-ladder" },
            { "+block.stair.ushape Wood", "your wooden U-ladder" },
            { "+foundation.triangle Wood", "your wooden triangular foundation" },
            { "+wall.window Wood", "your wooden window" },
            { "+door.hinged.metal", "" },
            { "+floor Wood", "your metal door" },
            { "+floor Metal", "your metal floor" },
            { "+door.hinged.wood", "your wooden door" },
            { "+floor Stone", "your stone floor" },
            { "+door.double.hinged.wood", "your double wooden door" },
            { "+door.double.hinged.metal", "your double metal door" },
            { "+shutter.wood.a", "your wooden shutters" },
            { "+wall.frame.garagedoor", "your garage door" },
            { "+wall.window.bars.wood", "your wood grate" },
            { "+floor.triangle Stone", "your stone triangular ceiling" },
            { "+wall.external.high.wood", "your high wooden gate" },
            { "+door.double.hinged.toptier", "your double armored door" },
            { "+floor.triangle Metal", "your metal triangular ceiling" },
            { "+wall.frame.netting", "your frame netting wall" },
            { "+door.hinged.toptier", "your armored door" },
            { "+shutter.metal.embrasure.a", "your metal shutters" },
            { "+wall.external.high.stone", "your external high stone wall" },
            { "+gates.external.high.stone", "your external high stone gates" },
            { "+floor.ladder.hatch", "your hatch with a ladder" },
            { "+floor.grill", "your floor grill" },
            { "+floor.triangle Wood", "your wooden triangular ceiling" },
            { "+floor.triangle TopTier", "your armored triangular ceiling" },
            { "+gates.external.high.wood", "your high wooden gate" },
            { "+wall.half Wood", "your wooden half wall" },
            { "+floor TopTier", "your triangular armored ceiling" },
            { "+wall.frame.cell", "your frame wall" },
            { "+wall.window.bars.metal", "your metal grill" },
            { "+wall.frame.fence", "your frame fence" },
            { "+shutter.metal.embrasure.b", "your metal shutter embrasure" },
            { "+wall.window.glass.reinforced", "your reinforced glass window" },
            { "+wall.frame.fence.gate", "your frame fence gate" },
            { "+floor.frame Stone", "your stone floor frame" },
            { "+wall.frame.cell.gate", "your wall frame cell gate" },
            { "+floor.frame Metal", "your metal floor frame" },
            { "+floor.frame Wood", "your wooden floor frame" },
            { "+wall.frame.shopfront", "your shopfront" },
            { "+wall.window.bars.toptier", "your window bars" },
            { "+autoturret_deployed", "your autoturret" },
            { "+sam_site_turret_deployed", "your sam site turret" },
            { "+ramp TopTier", "your armored ramp" },
            { "+floor.triangle.ladder.hatch", "your triangular hatch with stairs" },
            { "+block.stair.spiral Wood", "your wooden spiral staircase" },
            { "+ramp Metal", "your metal ramp" },
            { "+block.stair.spiral.triangle Wood", "your wooden triangular spiral staircase" },
            { "+block.stair.spiral.triangle Metal", "your metal triangular spiral staircase" },
            { "+block.stair.spiral Stone", "your stone spiral staircase" },
            { "+block.stair.spiral Metal", "your metal spiral staircase" },
            { "+floor.triangle.frame Stone", "your stone triangular ceiling frame" },
            { "+roof.triangle Metal", "your metal roof" },
            { "+floor.triangle.frame Metal", "your metal triangular ceiling frame" },
            { "+block.stair.spiral.triangle Stone", "your stone triangular spiral staircase" },
            { "+block.stair.spiral.triangle TopTier", "your armored triangular spiral staircase" },
            { "+ramp Wood", "your wooden ramp" },
            { "+roof.triangle Stone", "your stone roof" },
            { "+floor.triangle.frame TopTier", "your armored triangular ceiling frame" },
            { "+door.hinged.industrial.a", "your industrial door" },
            { "+roof.triangle TopTier", "your armored roof" },
            { "+ramp Stone", "your stone ramp" },
            { "+block.stair.spiral TopTier", "your armored spiral staircase" },
            { "+roof.triangle Wood", "your wooden roof" },
            { "+floor.frame TopTier", "your armored ceiling frame" }
        };

        public Dictionary<string, string> messagesRU = new Dictionary<string, string>
        {
            { "{t0}", "Вступить в группу" },
            { "{element_vk}", "Вконтакте" },
            { "{element_telegram}", "Телеграм" },
            { "{element_discord}", "Discord" },
            { "{element_rustplus}", "Приложение Rust+" },
            { "{element_ingame}", "Графическое отображение в игре" },
            { "{element_setup}", "Подключить" },
            { "{element_disable}", "Отключить" },
            { "{element_enable}", "Включить" },
            { "permission", "У вас нет разрешения для использования этой команды!" },
            { "{t1}", "Написать любое сообщение в группу" },
            { "{t2}", "VK.COM/HAXLITE" },
            { "{t3}", "Ссылка на ваш профиль" },
            { "{t4}", "Проверьте вашу почту в vk.com и введите полученый код" },
            { "{t5}", "Вводите текст через Ctrl+V, что бы во время ввода не выполнялись команды забинженые на клавиши, которые вы нажимаете" },
            { "{t6}", "Подключение оповещения о рейдах" },
            { "{d0}", "Присоединитесь к дискорд серверу" },
            { "{d1}", "Получить код в канале 'Интеграция с игровым профилем'" },
            { "{d2}", "DISCORD.GG/CyFmAqGBED" },
            { "{d3}", "Введите полученный код" },
            { "{d5}", "Вводите текст через Ctrl+V, что бы во время ввода не выполнялись команды забинженые на клавиши, которые вы нажимаете" },
            { "{d6}", "Подключение оповещения о рейдах" },
            { "{t7}", "ВЫХОД" },
            { "{teleg0}", "Добавьте бота @userinfobot, нажмите /start и скопируйте полученный Id" },
            { "{teleg1}", "Добавьте бота {tag} и нажать /start" },
            { "{teleg2}", "{tag}" },
            { "{teleg3}", "Введите скопированный Id" },
            { "{teleg5}", "Вводите текст через Ctrl+V, что бы во время ввода не выполнялись команды забинженые на клавиши, которые вы нажимаете" },
            { "{teleg6}", "Подключение оповещения о рейдах" },
            { "{back}", "НАЗАД" },
            { "telegramuseridnotfound", "User id не найден" },
            { "telegramadd", "Теперь вы будете получать рейд-оповещение здесь" },
            { "telegid", "Введите скопированный Id!" },
            { "{amain}", "Панель управления оповещений о рейде" },
            { "{text1}", "Получить код" },
            { "code", "Код для подтверджения аккаунта: {code}." },
            { "{text2}", "Подтвердить" },
            { "notallow", "Купите возможность подключить оповещения о рейде в магазине!" },
            { "rncancel", "Неверный код!" },
            { "alertvk", "Внимание! Игрок {name} разрушил {destroy} в квадрате {quad}\nconnect {ip}" },
            { "alerttelegram", "Внимание! Игрок {name} разрушил {destroy} в квадрате {quad}\nconnect {ip}" },
            { "alertdiscord", "Внимание! Игрок {name} разрушил {destroy} в квадрате {quad}\nconnect {ip}" },
            { "alertrustplus", "Внимание! Игрок {name} разрушил {destroy} в квадрате {quad}" },
            { "alertingame", "Игрок {name} разрушил {destroy} в квадрате {quad}" },
            { "null", "Введите ссылку на ваш профиль!" },
            { "rnnocode", "Не указали код!" },
            { "rnprivate", "Ваши настройки приватности не позволяют отправить вам сообщение." },
            { "rnerror", "Невозможно отправить сообщение.\nПроверьте правильность ссылки или повторите попытку позже." },
            { "rnblack", "Невозможно отправить сообщение.\nВы добавили группу в черный список или не подписаны на нее, если это не так, то просто напишите в группу сервера любое сообщение и попробуйте еще раз." },
            { "rnerror2", "Вы указали неверную ссылку на ваш Вк, если это не так, то просто напишите в группу сервера любое сообщение и попробуйте еще раз." },
            { "rnaddcooldown", "Вы недавно создавали код для подтверждения, попробуйте еще раз через минуту." },
            { "+wall Stone", "вашу каменную стену" },
            { "+wall.low Stone", "вашу каменную низкую стену" },
            { "+wall.frame Stone", "ваш каменный настенный каркас" },
            { "+foundation Stone", "ваш каменный фундамент" },
            { "+roof Stone", "вашу каменную крышу" },
            { "+wall.doorway Stone", "ваш каменный дверной проём" },
            { "+foundation.steps Stone", "ваши каменные ступеньки" },
            { "+block.stair.lshape Stone", "вашу каменную L-лестницу" },
            { "+block.stair.ushape Stone", "вашу каменную U-лестницу" },
            { "+foundation.triangle Stone", "ваш каменный треугольный фундамент" },
            { "+wall.window Stone", "ваше каменное окно" },
            { "+wall.half Stone", "вашу каменную полустену" },
            { "+wall Metal", "вашу металлическую стену" },
            { "+wall.low Metal", "вашу металлическую низкую стену" },
            { "+wall.frame Metal", "ваш металлический настенный каркас" },
            { "+foundation Metal", "ваш металлический фундамент" },
            { "+roof Metal", "вашу металлическую крышу" },
            { "+wall.doorway Metal", "ваш металлический дверной проём" },
            { "+foundation.steps Metal", "ваши металлические ступеньки" },
            { "+block.stair.lshape Metal", "вашу металлическую L-лестницу" },
            { "+block.stair.ushape Metal", "вашу металлическую U-лестницу" },
            { "+foundation.triangle Metal", "ваш металлический треугольный фундамент" },
            { "+wall.window Metal", "ваше металлическое окно" },
            { "+wall.half Metal", "вашу металлическую полустену" },
            { "+wall TopTier", "вашу бронированную стену" },
            { "+wall.low TopTier", "вашу бронированную низкую стену" },
            { "+wall.frame TopTier", "ваш бронированный настенный каркас" },
            { "+foundation TopTier", "ваш бронированный фундамент" },
            { "+roof TopTier", "вашу бронированную крышу" },
            { "+wall.doorway TopTier", "ваш бронированный дверной проём" },
            { "+foundation.steps TopTier", "ваши бронированные ступеньки" },
            { "+block.stair.lshape TopTier", "вашу бронированную L-лестницу" },
            { "+block.stair.ushape TopTier", "вашу бронированную U-лестницу" },
            { "+foundation.triangle TopTier", "ваш бронированный треугольный фундамент" },
            { "+wall.window TopTier", "ваше бронированное окно" },
            { "+wall.half TopTier", "вашу бронированную полустену" },
            { "+wall Wood", "вашу деревянную стену" },
            { "+wall.low Wood", "вашу деревянную низкую стену" },
            { "+wall.frame Wood", "ваш деревянный настенный каркас" },
            { "+foundation Wood", "ваш деревянный фундамент" },
            { "+roof Wood", "вашу деревянную крышу" },
            { "+wall.doorway Wood", "ваш деревянный дверной проём" },
            { "+foundation.steps Wood", "ваши деревянные ступеньки" },
            { "+block.stair.lshape Wood", "вашу деревянную L-лестницу" },
            { "+block.stair.ushape Wood", "вашу деревянную U-лестницу" },
            { "+foundation.triangle Wood", "ваш деревянный треугольный фундамент" },
            { "+wall.window Wood", "ваше деревянное окно" },
            { "+door.hinged.metal", "вашу металлическую дверь" },
            { "+floor Wood", "ваш деревянный пол" },
            { "+floor Metal", "ваш металлический пол" },
            { "+door.hinged.wood", "вашу деревянную дверь" },
            { "+floor Stone", "ваш каменный пол" },
            { "+door.double.hinged.wood", "вашу двойную деревянную дверь" },
            { "+door.double.hinged.metal", "вашу двойную металлическую дверь" },
            { "+shutter.wood.a", "ваши деревянные ставни" },
            { "+wall.frame.garagedoor", "вашу гаражную дверь" },
            { "+wall.window.bars.wood", "вашу деревянную решетку" },
            { "+floor.triangle Stone", "ваш каменный треугольный потолок" },
            { "+wall.external.high.wood", "ваши высокие деревянные ворота" },
            { "+door.double.hinged.toptier", "вашу двойную бронированную дверь" },
            { "+floor.triangle Metal", "ваш металлический треугольный потолок" },
            { "+wall.frame.netting", "вашу сетчатую стену" },
            { "+door.hinged.toptier", "вашу бронированную дверь" },
            { "+shutter.metal.embrasure.a", "ваши металлические ставни" },
            { "+wall.external.high.stone", "вашу высокую каменную стену" },
            { "+gates.external.high.stone", "ваши высокие каменные ворота" },
            { "+floor.ladder.hatch", "ваш люк с лестницей" },
            { "+floor.grill", "ваш решетчатый настил" },
            { "+floor.triangle Wood", "ваш деревянный треугольный потолок" },
            { "+floor.triangle TopTier", "ваш бронированный треугольный потолок" },
            { "+gates.external.high.wood", "ваши высокие деревянные ворота" },
            { "+wall.half Wood", "вашу деревянную полустену" },
            { "+floor TopTier", "ваш треугольный бронированный потолок" },
            { "+wall.frame.cell", "вашу тюремную стену" },
            { "+wall.window.bars.metal", "вашу металлическую решетку" },
            { "+wall.frame.fence", "ваш сетчатый забор" },
            { "+shutter.metal.embrasure.b", "вашу металлическую бойницу" },
            { "+wall.window.glass.reinforced", "ваше окно из укрепленного стекла" },
            { "+wall.frame.fence.gate", "вашу сетчатую дверь" },
            { "+floor.frame Stone", "ваш каменный потолочный каркас" },
            { "+wall.frame.cell.gate", "вашу тюремную решетку" },
            { "+floor.frame Metal", "ваш металический потолочный каркас" },
            { "+floor.frame Wood", "ваш деревянный потолочный каркас" },
            { "+wall.frame.shopfront", "вашу витрину" },
            { "+wall.window.bars.toptier", "ваши оконные решетки" },
            { "+autoturret_deployed", "вашу турель" },
            { "+sam_site_turret_deployed", "вашу зенитную турель" },
            { "+ramp TopTier", "вашу бронированную рампу" },
            { "+floor.triangle.ladder.hatch", "ваш треугольный люк с лестницей" },
            { "+block.stair.spiral Wood", "вашу деревянную спиральную лестницу" },
            { "+ramp Metal", "вашу металлическую рампу" },
            { "+block.stair.spiral.triangle Wood", "вашу деревянную треугольную спиральную лестницу" },
            { "+block.stair.spiral.triangle Metal", "вашу металлическую треугольную спиральную лестницу" },
            { "+block.stair.spiral Stone", "вашу каменную спиральную лестницу" },
            { "+block.stair.spiral Metal", "вашу металлическую спиральную лестницу" },
            { "+floor.triangle.frame Stone", "ваш каменный треугольный потолочный каркас" },
            { "+roof.triangle Metal", "вашу металлическую крышу" },
            { "+floor.triangle.frame Metal", "ваш металлический треугольный потолочный каркас" },
            { "+block.stair.spiral.triangle Stone", "вашу каменную треугольную спиральную лестницу" },
            { "+block.stair.spiral.triangle TopTier", "вашу бронированную треугольную спиральную лестницу" },
            { "+ramp Wood", "вашу деревянную рампу" },
            { "+roof.triangle Stone", "вашу каменную крышу" },
            { "+floor.triangle.frame TopTier", "ваш бронированный треугольный потолочный каркас" },
            { "+door.hinged.industrial.a", "вашу промышленную дверь" },
            { "+roof.triangle TopTier", "вашу бронированную крышу" },
            { "+ramp Stone", "вашу каменную  рампу" },
            { "+block.stair.spiral TopTier", "вашу бронированную спиральную лестницу" },
            { "+roof.triangle Wood", "вашу деревянную крышу" },
            { "+floor.frame TopTier", "ваш бронированный потолочный каркас" }
        };

        IEnumerator GetCallback()
        {
            if (config.discord.link == null)
            {
                config.discord.link = GetMessage("{t2}", "0");
                if (config.vk.link == "{t2}") config.vk.link = "VK.COM/YOURLINK";
            }

            if (config.vk.link == null)
            {
                config.vk.link = GetMessage("{d2}", "0");
                if (config.vk.link == "{d2}") config.vk.link = "DISCORD.GG/YOURLINK";
            }
            SaveConfig();

            lang.RegisterMessages(messagesEN, this, "en");
            lang.RegisterMessages(messagesRU, this, "ru");
            perm = Name + ".use";
            permission.RegisterPermission(perm, this);

            FON = "[{\"name\":\"Main_UI\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"NeedsCursor\"},{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{color}\",\"material\":\"assets/content/ui/uibackgroundblur.mat\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]}]".Replace("{color}", config.ui.background);
            MAIN = "[{\"name\":\"SubContent_UI\",\"parent\":\"Main_UI\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"color\":\"0 0 0 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0.6\",\"anchormax\":\"0.5 0.6\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]}]";
            UI = "[{\"name\":\"IF\",\"parent\":\"SubContent_UI\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{rectangularcolor}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0.5\",\"anchormax\":\"0.5 0.5\",\"offsetmin\":\"-120 -100\",\"offsetmax\":\"120 -70\"}]},{\"name\":\"D\",\"parent\":\"IF\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 0\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 1\"}]},{\"name\":\"U\",\"parent\":\"IF\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 1\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 -1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"L\",\"parent\":\"IF\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 0\"}]},{\"name\":\"R\",\"parent\":\"IF\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"-1 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"I\",\"parent\":\"IF\",\"components\":[{\"type\":\"UnityEngine.UI.InputField\",\"align\":\"MiddleLeft\",\"color\":\"{colorcontainertext}\",\"command\":\"raid.input\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"5 0\",\"offsetmax\":\"-5 0\"}]},{\"name\":\"L1\",\"parent\":\"IF\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0 0\",\"offsetmin\":\"-40 17\",\"offsetmax\":\"-5 18\"}]},{\"name\":\"L4\",\"parent\":\"IF\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0 0\",\"offsetmin\":\"-40 84\",\"offsetmax\":\"-5 85\"}]},{\"name\":\"P1\",\"parent\":\"L4\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{rectangularcolor}\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 0\",\"anchormax\":\"1 0\",\"offsetmin\":\"5 -15\",\"offsetmax\":\"245 15\"}]},{\"name\":\"D\",\"parent\":\"P1\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 0\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 1\"}]},{\"name\":\"U\",\"parent\":\"P1\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 1\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 -1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"L\",\"parent\":\"P1\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 0\"}]},{\"name\":\"R\",\"parent\":\"P1\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"-1 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"T\",\"parent\":\"P1\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{t2}\",\"align\":\"MiddleCenter\",\"color\":\"{colorcontainertext}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"5 0\",\"offsetmax\":\"-5 0\"}]},{\"name\":\"L5\",\"parent\":\"L4\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 1\",\"anchormax\":\"0 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 35\"}]},{\"name\":\"L6\",\"parent\":\"L5\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 1\",\"anchormax\":\"0 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"35 1\"}]},{\"name\":\"T\",\"parent\":\"L6\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{t1}\", \"color\":\"{colortext}\",\"font\":\"RobotoCondensed-Regular.ttf\",\"align\":\"MiddleLeft\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 0\",\"anchormax\":\"1 0\",\"offsetmin\":\"5 -10\",\"offsetmax\":\"720 10\"}]},{\"name\":\"L7\",\"parent\":\"L5\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 1\",\"anchormax\":\"0 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 35\"}]},{\"name\":\"L8\",\"parent\":\"L7\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 1\",\"anchormax\":\"0 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"35 1\"}]},{\"name\":\"T\",\"parent\":\"L8\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{t0}\", \"color\":\"{colortext}\",\"font\":\"RobotoCondensed-Regular.ttf\",\"align\":\"MiddleLeft\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 0\",\"anchormax\":\"1 0\",\"offsetmin\":\"5 -10\",\"offsetmax\":\"720 10\"}]},{\"name\":\"H\",\"parent\":\"L7\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{t6}\", \"color\":\"{colorheader}\",\"fontSize\":24},{\"type\":\"RectTransform\",\"anchormin\":\"40 1\",\"anchormax\":\"720 1\",\"offsetmin\":\"0 20\",\"offsetmax\":\"0 60\"}]},{\"name\":\"L2\",\"parent\":\"L1\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0 0\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 35\"}]},{\"name\":\"L3\",\"parent\":\"L2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 1\",\"anchormax\":\"0 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"35 1\"}]},{\"name\":\"T1\",\"parent\":\"L3\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{t4}\",\"font\":\"RobotoCondensed-Regular.ttf\",\"align\":\"MiddleLeft\",\"color\":\"{colortext}\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 0\",\"anchormax\":\"1 0\",\"offsetmin\":\"5 -10\",\"offsetmax\":\"720 10\"}]},{\"name\":\"DESC\",\"parent\":\"IF\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{t5}\",\"font\":\"RobotoCondensed-Regular.ttf\",\"color\":\"{colordesctext}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0\",\"anchormax\":\"0.5 0\",\"offsetmin\":\"-160 -200\",\"offsetmax\":\"250 -100\"}]}]".Replace("{colorline}", config.ui.stripcolor).Replace("{rectangularcolor}", config.ui.rectangularcolor).Replace("{colordesctext}", config.ui.hintstextcolor).Replace("{colortext}", config.ui.textcolor).Replace("{colorcontainertext}", config.ui.rectangulartextcolor).Replace("{colorheader}", config.ui.headertextcolor).Replace("{colordesctext}", config.ui.hintstextcolor);
            IF2 = "[{\"name\":\"IF2\",\"parent\":\"IF\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{rectangularcolor}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0\",\"anchormax\":\"0.5 0\",\"offsetmin\":\"-120 -70\",\"offsetmax\":\"120 -40\"}]},{\"name\":\"D\",\"parent\":\"IF2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 0\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 1\"}]},{\"name\":\"U\",\"parent\":\"IF2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 1\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 -1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"L\",\"parent\":\"IF2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 0\"}]},{\"name\":\"R\",\"parent\":\"IF2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"-1 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"I\",\"parent\":\"IF2\",\"components\":[{\"type\":\"UnityEngine.UI.InputField\",\"command\":\"raid.input\",\"align\":\"MiddleLeft\",\"color\":\"{colorcontainertext}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"5 0\",\"offsetmax\":\"-5 0\"}]},{\"name\":\"BTN2\",\"parent\":\"IF2\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"raid.accept\",\"color\":\"{greenbuttoncolor}\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 1\",\"anchormax\":\"1 1\",\"offsetmin\":\"5 -30\",\"offsetmax\":\"125 0\"}]},{\"name\":\"T\",\"parent\":\"BTN2\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{text2}\",\"align\":\"MiddleCenter\",\"color\":\"{buttoncolortext}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"L1\",\"parent\":\"IF2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0 0\",\"offsetmin\":\"-40 17\",\"offsetmax\":\"-5 18\"}]},{\"name\":\"L2\",\"parent\":\"L1\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0 0\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 35\"}]},{\"name\":\"L3\",\"parent\":\"L2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 1\",\"anchormax\":\"0 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"35 1\"}]},{\"name\":\"T1\",\"parent\":\"L3\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{t3}\",\"font\":\"RobotoCondensed-Regular.ttf\",\"align\":\"MiddleLeft\",\"color\":\"{colortext}\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 0\",\"anchormax\":\"1 0\",\"offsetmin\":\"5 -10\",\"offsetmax\":\"500 10\"}]}]".Replace("{rectangularcolor}", config.ui.rectangularcolor).Replace("{colorline}", config.ui.stripcolor).Replace("{colorcontainertext}", config.ui.rectangulartextcolor).Replace("{colortext}", config.ui.textcolor).Replace("{greenbuttoncolor}", config.ui.greenbuttoncolor).Replace("{buttoncolortext}", config.ui.buttoncolortext);
            IF2A = "[{\"name\":\"BTN2\",\"parent\":\"IF2\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"{coma}\",\"color\":\"{color}\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 1\",\"anchormax\":\"1 1\",\"offsetmin\":\"5 -30\",\"offsetmax\":\"125 0\"}]},{\"name\":\"T\",\"parent\":\"BTN2\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{text2}\",\"align\":\"MiddleCenter\",\"color\":\"{buttoncolortext}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]}]".Replace("{buttoncolortext}", config.ui.buttoncolortext);
            BTN = "[{\"name\":\"BTN\",\"parent\":\"IF\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"{coma}\",\"color\":\"{color}\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 1\",\"anchormax\":\"1 1\",\"offsetmin\":\"5 -30\",\"offsetmax\":\"125 0\"}]},{\"name\":\"T\",\"parent\":\"BTN\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{text1}\",\"align\":\"MiddleCenter\",\"color\":\"{buttoncolortext}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]}]".Replace("{buttoncolortext}", config.ui.buttoncolortext);
            ER = "[{\"name\":\"ER\",\"parent\":\"IF\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{e0}\",\"fontSize\":16,\"font\":\"RobotoCondensed-Regular.ttf\",\"color\":\"{errortextcolor}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0.5\",\"anchormax\":\"0.5 0.5\",\"offsetmin\":\"-160 -95\",\"offsetmax\":\"245 -35\"}]}]".Replace("{errortextcolor}", config.ui.errortextcolor);
            MAINH = "[{\"name\":\"AG\",\"parent\":\"SubContent_UI\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{a0}\",\"fontSize\":24},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0 0\",\"offsetmin\":\"-155 60\",\"offsetmax\":\"500 115\"}]}]";
            IBLOCK = "[{\"name\":\"E\",\"parent\":\"Main_UI\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"close\":\"Main_UI\",\"color\":\"1 1 1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 1\",\"anchormax\":\"1 1\",\"offsetmin\":\"-300 -100\",\"offsetmax\":\"-150 -50\"}]},{\"name\":\"ET\",\"parent\":\"E\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{t7}\",\"fontSize\":30,\"align\":\"MiddleCenter\",\"color\":\"{colortextexit}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"10 0\",\"offsetmax\":\"0 0\"}]}]";
            BACK = "[{\"name\":\"E\",\"parent\":\"Main_UI\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"chat.say /raid\",\"color\":\"1 1 1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 1\",\"anchormax\":\"1 1\",\"offsetmin\":\"-300 -100\",\"offsetmax\":\"-150 -50\"}]},{\"name\":\"ET\",\"parent\":\"E\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{t7}\",\"fontSize\":30,\"align\":\"MiddleCenter\",\"color\":\"{colortextexit}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"10 0\",\"offsetmax\":\"0 0\"}]}]".Replace("{colortextexit}", config.ui.colortextexit);
            EXIT = "[{\"name\":\"E\",\"parent\":\"Main_UI\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"close\":\"Main_UI\",\"color\":\"1 1 1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 1\",\"anchormax\":\"1 1\",\"offsetmin\":\"-300 -100\",\"offsetmax\":\"-150 -50\"}]},{\"name\":\"ET\",\"parent\":\"E\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{t7}\",\"fontSize\":30,\"align\":\"MiddleCenter\",\"color\":\"{colortextexit}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"10 0\",\"offsetmax\":\"0 0\"}]}]".Replace("{colortextexit}", config.ui.colortextexit);
            AG = "[{\"name\":\"AGG{num}\",\"parent\":\"SubContent_UI\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{rectangularcolor}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0 0\",\"offsetmin\":\"-120 {min}\",\"offsetmax\":\"120 {max}\"}]},{\"name\":\"D\",\"parent\":\"AGG{num}\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 0\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 1\"}]},{\"name\":\"R\",\"parent\":\"AGG{num}\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"-1 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"U\",\"parent\":\"AGG{num}\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 1\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 -1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"L\",\"parent\":\"AGG{num}\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 0\"}]},{\"name\":\"AT\",\"parent\":\"AGG{num}\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{id}\",\"align\":\"MiddleLeft\",\"color\":\"{colorcontainertext}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"5 0\",\"offsetmax\":\"-5 0\"}]},{\"name\":\"BTN{num}\",\"parent\":\"AGG{num}\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"{coma}\",\"color\":\"{color}\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 0\",\"anchormax\":\"1 0\",\"offsetmin\":\"5 0\",\"offsetmax\":\"125 30\"}]},{\"name\":\"T\",\"parent\":\"BTN{num}\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{text1}\",\"align\":\"MiddleCenter\",\"color\":\"{buttoncolortext}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"AL\",\"parent\":\"AGG{num}\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{icocolor}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 1\",\"anchormax\":\"0 1\",\"offsetmin\":\"-35 -30\",\"offsetmax\":\"-5 0\"}]},{\"name\":\"ALT\",\"parent\":\"AL\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{ico}\",\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]}]".Replace("{colorline}", config.ui.stripcolor).Replace("{rectangularcolor}", config.ui.rectangularcolor).Replace("{colorcontainertext}", config.ui.rectangulartextcolor).Replace("{buttoncolortext}", config.ui.buttoncolortext);

            if (!string.IsNullOrEmpty(config.discord.token))
            {
                if (config.discord.server > 0) CreateClient();
                else Debug.LogError("Set up Server ID in config");
            }
            else Debug.LogError(fermensEN ? "AALERTRAID - TOKEN FOR DISCORD BOT IS NULL!" : "AALERTRAID - Не указан токен для Discord бота!");

            connect = ConVar.Server.ip + ":" + ConVar.Server.port;
            CreateSpawnGrid();

            Interface.Oxide.GetLibrary<ru.Libraries.Command>(null).AddChatCommand("raid", this, "callcommandrn");

            Debug.Log(">>AlertRaid<< OK!");

            yield break;
        }
        #endregion

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (info == null || entity == null) return;
            BasePlayer player = info.InitiatorPlayer;
            if (player == null) return;
            if (entity is BuildingBlock)
            {
                int tt = (int)(entity as BuildingBlock).grade;
                if (tt <= 0) return;
                ServerMgr.Instance.StartCoroutine(Alerting(entity, player, tt));
            }
            else if (config.extralist && (entity is DecayEntity || entity is IOEntity) || entity is AnimatedBuildingBlock || entity is SamSite || entity is AutoTurret || config.spisok.Contains(entity.ShortPrefabName))
            {
                ServerMgr.Instance.StartCoroutine(Alerting(entity, player));
            }
        }
        #endregion

        #region FUNCTIONS

        private IEnumerator Alerting(BaseCombatEntity entity, BasePlayer player, int tt = 0)
        {
            Vector3 position = entity.transform.position;
            string dname = entity.ShortPrefabName;

            if (tt == 1) dname += " Wood";
            else if (tt == 2) dname += " Stone";
            else if (tt == 3) dname += " Metal";
            else if (tt == 4) dname += " TopTier";

            BuildingPrivlidge buildingPrivlidge = entity is BuildingPrivlidge ? entity as BuildingPrivlidge : entity.GetBuildingPrivilege(entity.WorldSpaceBounds());
            if (buildingPrivlidge == null) yield break;
            if (!buildingPrivlidge.AnyAuthed()) yield break;

            var list = buildingPrivlidge.authorizedPlayers.ToList();

            yield return CoroutineEx.waitForSeconds(0.5f);

            string name = player.displayName;
            string attackerid = player.UserIDString;
            string quad = GetNameGrid(position);
            string connect = ConVar.Server.ip + ":" + ConVar.Server.port;

            string key = "+" + dname;

            foreach (var z in list)
            {
                string destroy = GetMessage(key, z.userid.ToString());
                if (destroy == key) destroy = entity.ShortPrefabName.Replace(".deployed", "");

                ALERTPLAYER(z.userid, name, quad, connect, destroy, attackerid);

                yield return CoroutineEx.waitForEndOfFrame;
            }
        }

        List<ulong> block = new List<ulong>();
        private void ALERTPLAYER(ulong ID, string name, string quad, string connect, string destroy, string attackerid)
        {
            string IDstring = ID.ToString();

            if (!HasAcces(IDstring)) return;

            ALERT alert;
            if (!alerts.TryGetValue(ID, out alert))
            {
                alerts.Add(ID, new ALERT());
                alert = alerts[ID];
            }
            Storage storage = GetStorage(ID);

            #region ОПОВЕЩЕНИЕ В ВК
            if (config.vk.enable && !string.IsNullOrEmpty(config.vk.api) && alert.vkcooldown < DateTime.Now)
            {
                if (!string.IsNullOrEmpty(storage.vk))
                {
                    GetRequest(storage.vk, GetMessage("alertvk", IDstring).Replace("{ip}", connect).Replace("{steamid}", attackerid).Replace("{name}", name).Replace("{destroy}", destroy).Replace("{quad}", quad).Replace("{servername}", config.servername));
                    alert.vkcooldown = DateTime.Now.AddSeconds(config.vk.cooldown);
                }
            }
            #endregion

            #region ОПОВЕЩЕНИЕ В ТЕЛЕГРАМ
            if (config.telegram.enable && !string.IsNullOrEmpty(config.telegram.token) && alert.telegramcooldown < DateTime.Now)
            {
                if (!string.IsNullOrEmpty(storage.telegram))
                {
                    GetRequestTelegram(storage.telegram, GetMessage("alerttelegram", IDstring).Replace("{ip}", connect).Replace("{steamid}", attackerid).Replace("{name}", name).Replace("{destroy}", destroy).Replace("{quad}", quad).Replace("{servername}", config.servername));
                    alert.telegramcooldown = DateTime.Now.AddSeconds(config.telegram.cooldown);
                }
            }
            #endregion

            #region ОПОВЕЩЕНИЕ В RUST+
            if (!string.IsNullOrEmpty(App.serverid) && App.port > 0 && App.notifications && storage.rustplus && config.rustplus.enable && alert.rustpluscooldown < DateTime.Now)
            {
                NotificationList.SendNotificationTo(ID, NotificationChannel.SmartAlarm, GetMessage("alertrustplus", IDstring).Replace("{steamid}", attackerid).Replace("{ip}", connect).Replace("{name}", name).Replace("{destroy}", destroy).Replace("{quad}", quad).Replace("{servername}", config.servername), config.servername, Util.GetServerPairingData());
                alert.rustpluscooldown = DateTime.Now.AddSeconds(config.rustplus.cooldown);
            }
            #endregion

            #region ОПОВЕЩЕНИЕ В DISCORD
            if (config.discord.enable && !block.Contains(ID) && !string.IsNullOrEmpty(config.discord.token) && alert.discordcooldown < DateTime.Now)
            {
                if (storage.discord != 0UL)
                {
                    Snowflake ss = new Snowflake(storage.discord);
                    if (!_guild.Members.Any(x => x.Value.User.Id == ss))
                    {
                        return;
                    }
                    _guild.Members.First(x => x.Value.User.Id == ss).Value.User.SendDirectMessage(Client, new MessageCreate { Content = GetMessage("alertdiscord", IDstring).Replace("{steamid}", attackerid).Replace("{ip}", connect).Replace("{name}", name).Replace("{destroy}", destroy).Replace("{quad}", quad).Replace("{servername}", config.servername) }).Catch(err =>
                    {
                       // Debug.Log(err.Message);
                        //block.Add(ID);
                    });
                    alert.discordcooldown = DateTime.Now.AddSeconds(config.discord.cooldown);
                }
            }
            #endregion

            #region ОПОВЕЩЕНИЕ В ИГРЕ
            if (storage.ingamerust && config.ingame.enable && alert.gamecooldown < DateTime.Now)
            {
                BasePlayer player = BasePlayer.FindByID(ID);
                if (player != null && player.IsConnected)
                { 
                    Timer ss;
                    if (timal.TryGetValue(player.userID, out ss))
                    {
                        if (!ss.Destroyed) ss.Destroy();
                    }
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "UIA");
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", config.ingame.UI.Replace("{text}", GetMessage("alertingame", IDstring).Replace("{steamid}", attackerid).Replace("{ip}", connect).Replace("{name}", name).Replace("{destroy}", destroy).Replace("{quad}", quad).Replace("{servername}", config.servername)));
                    if (!string.IsNullOrEmpty(config.ingame.effect)) EffectNetwork.Send(new Effect(config.ingame.effect, player, 0, Vector3.up, Vector3.zero) { scale = 1f }, player.net.connection);
                    timal[player.userID] = timer.Once(config.ingame.destroy, () => CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "UIA"));
                    alert.gamecooldown = DateTime.Now.AddSeconds(config.ingame.cooldown);
                }
            }
            #endregion
        }

        private Dictionary<ulong, Timer> timal = new Dictionary<ulong, Timer>();
        #endregion

        #region Lang
        private string GetMessage(string key, string userId) => lang.GetMessage(key, this, userId);
        #endregion

        #region GRID
        private static Dictionary<string, Vector3> Grids = new Dictionary<string, Vector3>();
        private void CreateSpawnGrid()
        {
            Grids.Clear();
            var worldSize = (ConVar.Server.worldsize);
            float offset = worldSize / 2;
            var gridWidth = (0.0066666666666667f * worldSize);
            float step = worldSize / gridWidth;

            string start = "";

            char letter = 'A';
            int number = 0;

            for (float zz = offset; zz > -offset; zz -= step)
            {
                for (float xx = -offset; xx < offset; xx += step)
                {
                    Grids.Add($"{start}{letter}{number}", new Vector3(xx - 55f, 0, zz + 20f));
                    if (letter.ToString().ToUpper() == "Z")
                    {
                        start = "A";
                        letter = 'A';
                    }
                    else
                    {
                        letter = (char)(((int)letter) + 1);
                    }


                }
                number++;
                start = "";
                letter = 'A';
            }
        }

        private string GetNameGrid(Vector3 pos) => Grids.Where(x => x.Value.x < pos.x && x.Value.x + 150f > pos.x && x.Value.z > pos.z && x.Value.z - 150f < pos.z).FirstOrDefault().Key;
        #endregion
    }
}

// --- End of file: AAlertRaidEN-2.0.1.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BuildingGrades.cs ---
// --- Original Local Path: BuildingGrades.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

using Facepunch;

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Building Grades", "bawNg / Nogrod", "0.3.6", ResourceId = 865)]
    class BuildingGrades : RustPlugin
    {
        private readonly FieldInfo serverInputField = typeof(BasePlayer).GetField("serverInput", BindingFlags.Instance | BindingFlags.NonPublic);
        private readonly FieldInfo instancesField = typeof(MeshColliderBatch).GetField("instances", BindingFlags.Instance | BindingFlags.NonPublic);
        private const string Perm = "buildinggrades.cangrade";
        private const string PermNoCost = "buildinggrades.nocost";
        private const string PermOwner = "buildinggrades.owner";
        private const float Distance = 3f;
        private readonly HashSet<ulong> runningPlayers = new HashSet<ulong>();
        private ConfigData configData;
        private readonly Dictionary<string, HashSet<uint>> categories = new Dictionary<string, HashSet<uint>>();

        class ConfigData
        {
            public int BatchSize { get; set; }
            public Dictionary<string, HashSet<string>> Categories { get; set; }
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                BatchSize = 500,
                Categories = new Dictionary<string, HashSet<string>>
                {
                    {
                        "foundation", new HashSet<string>
                        {
                            "assets/prefabs/building core/foundation.triangle/foundation.triangle.prefab",
                            "assets/prefabs/building core/foundation.steps/foundation.steps.prefab",
                            "assets/prefabs/building core/foundation/foundation.prefab"
                        }
                    },
                    {
                        "wall", new HashSet<string>
                        {
                            "assets/prefabs/building core/wall.frame/wall.frame.prefab",
                            "assets/prefabs/building core/wall.window/wall.window.prefab",
                            "assets/prefabs/building core/wall.doorway/wall.doorway.prefab",
                            "assets/prefabs/building core/wall/wall.prefab"
                        }
                    },
                    {
                        "floor", new HashSet<string>
                        {
                            "assets/prefabs/building core/floor.frame/floor.frame.prefab",
                            "assets/prefabs/building core/floor.triangle/floor.triangle.prefab",
                            "assets/prefabs/building core/floor/floor.prefab"
                        }
                    },
                    {
                        "other", new HashSet<string>
                        {
                            "assets/prefabs/building core/roof/roof.prefab",
                            "assets/prefabs/building core/stairs.l/block.stair.lshape.prefab",
                            "assets/prefabs/building core/pillar/pillar.prefab",
                            "assets/prefabs/building core/stairs.u/block.stair.ushape.prefab"
                        }
                    }
                }
            };
            Config.WriteObject(config, true);
        }

        private void Init()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"NotEnoughItems", "Not enough {0}! You need {1} but you only have {2}"},
                {"NotAllowed", "<color=red>You are not allowed to use that command!</color>"},
                {"UnknownGrade", "<color=red>Unknown grade!</color>"},
                {"UnknownCategory", "<color=red>Unknown category!</color>"},
                {"NotLookingAt", "<color=red>You are not looking at a building block!</color>"},
                {"FinishedUp", "Finished upgrading!"},
                {"FinishedDown", "Finished downgrading!"},
                {"AlreadyRunning", "Already running, please wait!"},
                {"AnotherProcess", "Another process already running, please try again in a few seconds!"}
            }, this);
            configData = Config.ReadObject<ConfigData>();
            foreach (var category in configData.Categories)
            {
                var data = new HashSet<uint>();
                foreach (var prefab in category.Value)
                {
                    var prefabId = StringPool.Get(prefab);
                    if (prefabId <= 0) continue;
                    data.Add(prefabId);
                }
                categories.Add(category.Key, data);
            }
        }

        void OnServerInitialized()
        {
            permission.RegisterPermission(Perm, this);
            permission.RegisterPermission(PermNoCost, this);
            permission.RegisterPermission(PermOwner, this);
        }

        [ChatCommand("up4")]
        void UpCommand4(BasePlayer player, string command, string[] args)
        {
            ChangeBuildingGrade(player, args.Length > 0 ? new[] { "4", args[0] } : new[] { "4" }, true);
        }

        [ChatCommand("up3")]
        void UpCommand3(BasePlayer player, string command, string[] args)
        {
            ChangeBuildingGrade(player, args.Length > 0 ? new[] { "3", args[0] } : new[] { "3" }, true);
        }

        [ChatCommand("up2")]
        void UpCommand2(BasePlayer player, string command, string[] args)
        {
            ChangeBuildingGrade(player, args.Length > 0 ? new[] { "2", args[0] } : new[] { "2" }, true);
        }

        [ChatCommand("up1")]
        void UpCommand1(BasePlayer player, string command, string[] args)
        {
            ChangeBuildingGrade(player, args.Length > 0 ? new[] { "1", args[0] } : new[] { "1" }, true);
        }

        [ChatCommand("up")]
        void UpCommand(BasePlayer player, string command, string[] args)
        {
            ChangeBuildingGrade(player, args, true);
        }

        [ChatCommand("down3")]
        void DownCommand3(BasePlayer player, string command, string[] args)
        {
            ChangeBuildingGrade(player, args.Length > 0 ? new[] { "3", args[0] } : new[] { "3" }, false);
        }

        [ChatCommand("down2")]
        void DownCommand2(BasePlayer player, string command, string[] args)
        {
            ChangeBuildingGrade(player, args.Length > 0 ? new[] { "2", args[0] } : new[] { "2" }, false);
        }

        [ChatCommand("down1")]
        void DownCommand1(BasePlayer player, string command, string[] args)
        {
            ChangeBuildingGrade(player, args.Length > 0 ? new[] { "1", args[0] } : new[] { "1" }, false);
        }

        [ChatCommand("down0")]
        void DownCommand0(BasePlayer player, string command, string[] args)
        {
            ChangeBuildingGrade(player, args.Length > 0 ? new[] { "0", args[0] } : new []{"0"}, false);
        }

        [ChatCommand("down")]
        void DownCommand(BasePlayer player, string command, string[] args)
        {
            ChangeBuildingGrade(player, args, false);
        }

        void ChangeBuildingGrade(BasePlayer player, string[] args, bool increment)
        {
            if (!IsAllowed(player))
            {
                PrintMessage(player, "NotAllowed");
                return;
            }

            if (runningPlayers.Contains(player.userID))
            {
                PrintMessage(player, "AlreadyRunning");
                return;
            }

            if (!player.IsAdmin() && runningPlayers.Count > 0)
            {
                PrintMessage(player, "AnotherProcess");
                return;
            }

            var targetGrade = -1;
            var filter = false;
            HashSet<uint> prefabs = null;
            if (args.Length > 0)
            {
                try
                {
                    targetGrade = (int)(BuildingGrade.Enum)Enum.Parse(typeof(BuildingGrade.Enum), args[0], true);
                }
                catch (Exception)
                {
                    PrintMessage(player, "UnknownGrade");
                    return;
                }
                if (args.Length > 1)
                {
                    if (!categories.TryGetValue(args[1], out prefabs))
                    {
                        PrintMessage(player, "UnknownCategory");
                        return;
                    }
                    filter = prefabs.Count > 0;
                }
            }

            var stack = GetTargetBuildingBlock(player);
            if (stack == null || stack.Count == 0)
            {
                PrintMessage(player, "NotLookingAt");
                return;
            }

            var all_blocks = new HashSet<BuildingBlock>();

            //var started = Interface.Oxide.Now;
            //var done = 0;
            while (stack.Count > 0)
            {
                var building_block = stack.Pop();
                var position = new OBB(building_block.transform, building_block.bounds).ToBounds().center;
                var blocks = Pool.GetList<BuildingBlock>();
                Vis.Entities(position, Distance, blocks, 270532864);
                foreach (var block in blocks)
                {
                    if (!all_blocks.Add(block)) continue;
                    stack.Push(block);
                }
                Pool.FreeList(ref blocks);
                //done++;
            }
            var allowed = player.IsAdmin() || permission.UserHasPermission(player.UserIDString, PermOwner);
            all_blocks.RemoveWhere(b => !allowed && b.OwnerID != player.userID || filter && !prefabs.Contains(b.prefabID));
            //Puts("Time: {0} Size: {1} Done: {2}", Interface.Oxide.Now - started, all_blocks.Count, done);

            if (increment && !player.IsAdmin() && !permission.UserHasPermission(player.UserIDString, PermNoCost))
            {
                var costs = GetCosts(all_blocks, targetGrade);
                if (!CanAffordUpgrade(costs, player)) return;
                PayForUpgrade(costs, player);
            }

            runningPlayers.Add(player.userID);

            NextTick(() => DoUpgrade(all_blocks, targetGrade, increment, player));

            /*foreach (var building_block in all_blocks)
            {
                var target_grade = NextBlockGrade(building_block, grade, increment ? 1 : -1);
                if (!CanUpgrade(building_block, (BuildingGrade.Enum) target_grade)) continue;

                building_block.SetGrade((BuildingGrade.Enum)target_grade);
                building_block.SetHealthToMax();
                building_block.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                building_block.UpdateSkin();
            }
            PrintMessage(player, increment ? "FinishedUp" : "FinishedDown");
            runningPlayers.Remove(player.userID);
            */
        }

        private void DoUpgrade(HashSet<BuildingBlock> all_blocks, int targetGrade, bool increment, BasePlayer player)
        {
            var todo = all_blocks.Take(configData.BatchSize).ToArray();
            foreach (var building_block in todo)
            {
                all_blocks.Remove(building_block);
                var target_grade = NextBlockGrade(building_block, targetGrade, increment ? 1 : -1);
                if (!CanUpgrade(building_block, (BuildingGrade.Enum)target_grade)) continue;

                building_block.SetGrade((BuildingGrade.Enum)target_grade);
                building_block.SetHealthToMax();
                building_block.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                building_block.UpdateSkin();
            }
            if (all_blocks.Count > 0)
                NextTick(() => DoUpgrade(all_blocks, targetGrade, increment, player));
            else
            {
                PrintMessage(player, increment ? "FinishedUp" : "FinishedDown");
                runningPlayers.Remove(player.userID);
            }
        }

        private Dictionary<int, float> GetCosts(HashSet<BuildingBlock> blocks, int targetGrade)
        {
            Dictionary<int, float> costs = new Dictionary<int, float>();
            var toRemove = new HashSet<BuildingBlock>();
            foreach (var block in blocks)
            {
                var grade = NextBlockGrade(block, targetGrade, 1);
                if (!CanUpgrade(block, (BuildingGrade.Enum) grade))
                {
                    toRemove.Add(block);
                    continue;
                }
                var costToBuild = block.blockDefinition.grades[grade].costToBuild;
                foreach (var itemAmount in costToBuild)
                {
                    if (!costs.ContainsKey(itemAmount.itemid))
                        costs[itemAmount.itemid] = itemAmount.amount;
                    else
                        costs[itemAmount.itemid] += itemAmount.amount;
                }
            }
            foreach (var block in toRemove)
                blocks.Remove(block);
            return costs;
        }

        private bool CanAffordUpgrade(Dictionary<int, float> costs, BasePlayer player)
        {
            foreach (var current in costs)
            {
                var amount = player.inventory.GetAmount(current.Key);
                if (amount >= current.Value)
                    continue;
                PrintMessage(player, "NotEnoughItems", ItemManager.FindItemDefinition(current.Key).displayName.english, (int)current.Value, amount);
                return false;
            }
            return true;
        }

        private void PayForUpgrade(Dictionary<int, float> costs, BasePlayer player)
        {
            var items = new List<Item>();
            foreach (var current in costs)
            {
                player.inventory.Take(items, current.Key, (int)current.Value);
                player.Command(string.Concat("note.inv ", current.Key, " ", current.Value * -1f));
            }
            foreach (var item in items)
                item.Remove(0f);
        }

        static bool CanUpgrade(BuildingBlock block, BuildingGrade.Enum grade)
        {
            if (block.isDestroyed || grade == block.grade)
                return false;
            if ((int) grade > block.blockDefinition.grades.Length)
                return false;
            if (grade < BuildingGrade.Enum.Twigs)
                return false;
            return true;
        }

        static int NextBlockGrade(BuildingBlock building_block, int targetGrade, int offset)
        {
            var grade = (int)building_block.grade;

            var grades = building_block.blockDefinition.grades;
            if (grades == null) return grade;

            if (offset > 0 && targetGrade >= 0 && targetGrade < grades.Length && grades[targetGrade] != null)
                return grade >= targetGrade ? grade : targetGrade;
            if (offset < 0 && targetGrade >= 0 && targetGrade < grades.Length && grades[targetGrade] != null)
                return grade <= targetGrade ? grade : targetGrade;

            targetGrade = grade + offset;
            while (targetGrade >= 0 && targetGrade < grades.Length)
            {
                if (grades[targetGrade] != null) return targetGrade;
                targetGrade += offset;
            }

            return grade;
        }

        Stack<BuildingBlock> GetTargetBuildingBlock(BasePlayer player)
        {
            var input = serverInputField?.GetValue(player) as InputState;
            if (input == null) return null;
            var direction = Quaternion.Euler(input.current.aimAngles);
            var stack = new Stack<BuildingBlock>();
            RaycastHit initial_hit;
            if (!Physics.Raycast(new Ray(player.transform.position + new Vector3(0f, 1.5f, 0f), direction * Vector3.forward), out initial_hit, 150f) || initial_hit.collider is TerrainCollider)
                return stack;
            var entity = initial_hit.collider.GetComponentInParent<BuildingBlock>();
            if (entity != null) stack.Push(entity);
            else
            {
                var batch = initial_hit.collider?.GetComponent<MeshColliderBatch>();
                if (batch == null) return stack;
                var colliders = (ListDictionary<Component, ColliderCombineInstance>)instancesField.GetValue(batch);
                if (colliders == null) return stack;
                foreach (var instance in colliders.Values)
                {
                    entity = instance.collider?.GetComponentInParent<BuildingBlock>();
                    if (entity == null) continue;
                    stack.Push(entity);
                }
            }
            return stack;
        }

        bool IsAllowed(BasePlayer player)
        {
            return player != null && (player.IsAdmin() || permission.UserHasPermission(player.UserIDString, Perm));
        }

        private void PrintMessage(BasePlayer player, string msgId, params object[] args)
        {
            PrintToChat(player, lang.GetMessage(msgId, this, player.UserIDString), args);
        }
    }
}


// --- End of file: BuildingGrades.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SchedShutdown.cs ---
// --- Original Local Path: SchedShutdown.cs ---

// Reference: Oxide.Ext.Unity

/* 
 * Many thanks to feramor@computer.org for his HappyHour.cs plugin, which 
 * gave me examples of how to work with dates and timers in a plugin.
 */

/*
 * The MIT License (MIT)
 * Copyright (c) 2015 #db_arcane
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries;

namespace Oxide.Plugins
{
    [Info("SchedShutdown", "db_arcane", "1.1.2")]
    public class SchedShutdown : RustPlugin
    {   
        static List<Oxide.Core.Libraries.Timer.TimerInstance> Timers = new List<Oxide.Core.Libraries.Timer.TimerInstance>();
        Oxide.Core.Libraries.Timer MainTimer;
        string TimeFormat = "HH:mm:ss";
        string EnabledStr = "enabled";
        string DisabledStr = "disabled";

        void Init()
        {
            LoadConfig();
            CleanupConfig();
            MainTimer = Interface.GetMod().GetLibrary<Oxide.Core.Libraries.Timer>("Timer");
        }

        [ConsoleCommand("schedule.shutdown")]
        private void ScheduleShutdown(ConsoleSystem.Arg arg)
        {
            string param = arg.ArgsStr.ToString();
            
            if (param == "")
            {
                 PrintShutdownStatus();
                 return;
            }    
            
            if (param == "enable")
            {
                if (Config["UTC_Time"].ToString() == "") {
                    this.Puts("The shutdown time has not been configured yet. The shutdown timer remains disabled.");
                    return;
                }
                
                Config["Status"] = EnabledStr;
                SaveConfig();
                ResetShutdownTimer();
                return;
            }
            
            if (param == DisabledStr)
            {
                Config["Status"] = DisabledStr;
                SaveConfig();
                ResetShutdownTimer();
                return;
            }
            
            if (!IsTimeValid(param))
            {
				this.Puts("The time entered was unreadable, must be in format like '01:30:00'. No changes have been made. ");
                PrintShutdownStatus();
                return;
            }
            Config["Status"] = EnabledStr;
            Config["UTC_Time"] = param;
            SaveConfig();
            ResetShutdownTimer();
        }
        
        [HookMethod("OnServerInitialized")]
        void myOnServerInitialized()
        {
            DateTime configTime; 
            DateTime mainTime = DateTime.UtcNow;
            
            if (Config["Status"].ToString() == DisabledStr) {
                PrintShutdownStatus();
				return;
			}
                
            // Set up timer for server save and shutdown
            try
            {
                configTime = DateTime.ParseExact(Config["UTC_Time"].ToString(), TimeFormat, null);                 
            }
            catch (Exception e)
            {
                PrintShutdownStatus();
                return;
            }
            
            DateTime shutdownTime = new DateTime(mainTime.Year, mainTime.Month, mainTime.Day, configTime.Hour, configTime.Minute, configTime.Second, DateTimeKind.Utc);
            if (mainTime > shutdownTime) 
            {
                shutdownTime = shutdownTime.AddDays(1);
            }
            long shutdownInterval = Convert.ToInt64((shutdownTime - mainTime).TotalSeconds);

            // schedule the server save command.
            Oxide.Core.Libraries.Timer.TimerInstance newTimer = MainTimer.Once(shutdownInterval, () => ConsoleSystem.Run.Server.Normal("server.save"));
            Timers.Add(newTimer);

            // schedule the restart command.  Restart simply shuts down the server after a 60-second countdown
            newTimer = MainTimer.Once(shutdownInterval, () => ConsoleSystem.Run.Server.Normal("restart"));
            Timers.Add(newTimer);
            
            PrintShutdownStatus();
        }
        
        [HookMethod("Unload")]
        void myUnload()
        {
            foreach (Oxide.Core.Libraries.Timer.TimerInstance CurrentTimer in Timers)
            {
                if (CurrentTimer != null)
                    if (CurrentTimer.Destroyed == false)
                        CurrentTimer.Destroy();
            }
            Timers.Clear();
        }

        [HookMethod("LoadDefaultConfig")]
        void myLoadDefaultConfig()
        {
            Config["Status"] = DisabledStr;
            Config["UTC_Time"] = "";
            SaveConfig();
        }

        private void ResetShutdownTimer()
        {
            myUnload();
            myOnServerInitialized();
        }
        
        private void PrintShutdownStatus()
        {
            string status = (Config["Status"].ToString() == DisabledStr) ? "DISABLED" : "ENABLED";
            string schedTime = Config["UTC_Time"].ToString();
            schedTime = (schedTime == "") ? "blank" : schedTime + " UTC" ;

            this.Puts("Shutdown timer is " + status + ", configured shutdown time is " + schedTime);
        }
        
        private void CleanupConfig()
        {
            string status = Config["Status"].ToString().ToLower();
            Config["Status"] = ((status != EnabledStr) && (status != DisabledStr)) ? DisabledStr : status;
            
            if (!IsTimeValid(Config["UTC_Time"].ToString())) 
            {
               Config["UTC_Time"] = "";
               Config["Status"] = DisabledStr;
            }
            SaveConfig();
        }
        
        private bool IsTimeValid(string timeString)
        {
            DateTime temp;

            try
            {
                temp = DateTime.ParseExact(timeString, TimeFormat, null);
            }
            catch (Exception e)
            {
                return false;
            }
            return true;
        }
        
    }
}


// --- End of file: SchedShutdown.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/MoegicBox.cs ---
// --- Original Local Path: MoegicBox.cs ---

using System.Collections.Generic;
using System.Linq;
using System.Text;
using Oxide.Core;
using System;
using Oxide.Core.Plugins;
using MoegicBoxExtensions;

/*
    FUTURE EXPANSION:
        - Admin pays nothing for recycling box
        - Ownership tracking of boxes to protect from unwarranted unlinks
        - Have some kind of access list to tradeboxes so an NPC can manage quest-user associations (API?)
        - Support Hunt XP rewards or other types of rewards
        - Put items in crate and have them offered for sale..drag in your invent and pay up?
        - Support NPC association?
        - Have some basic logging or saved contents of the trade?
        - Let users create their own trade chests

    KNOWN ISSUES:
        - Rounding with a 100% refund on recycle can create situations where you get a tiny bit more than you should
          There is no way around this other than rounding down instead of up which creates bigger issues.
          Solution: Don't use 100% refund
          Example of this issue: Recycling a timed explosive charge down to base mats yields 75 low grade fuel
          Each craft of low grade yields 7 LGF and 75 cannot be divided by 7.
          When the player recycles the 75 low grade, the "round up" causes him to be able to craft 77 with the returned mats
          We could lower it to give only stuff for 70, but then users would complain the refund is not 100%
          We could force recycling on stacks to use the output amount and just return whatever didn't form a whole craft
          (in this case stuff for 70 LFG and return the 5 as is)
        - Cannot have price over 1 stack (very limiting!)
*/

namespace MoegicBoxExtensions
{
    static class MoegicExtensions
    {
        public static string MoegicId(this BaseEntity entity)
        {
            return $"({entity.transform.localPosition.x};{entity.transform.localPosition.y};{entity.transform.localPosition.z})";
        }
    }
}

namespace Oxide.Plugins
{
    [Info("MoegicBox", "Deicide666ra", "1.0.3")]
    class MoegicBox : RustPlugin
    {
        // config
        public class MoegicConfig
        {
            // general
            public Dictionary<string, TradeList> TradeLists = new Dictionary<string, TradeList>(); // listname, TradeList
            public Dictionary<string, string> BoxLinks = new Dictionary<string, string>(); // entityid, listname

            // recycler
            public float RefundRatio= 0.5f; // default ratio
            public Dictionary<string, int> RecyclerPrice = new Dictionary<string, int>() {  };

            public void Save()
            {
                Interface.GetMod().DataFileSystem.WriteObject("MoegicBox", this);
            }
        }
        MoegicConfig g_config= null;

        // global variables
        private Dictionary<ulong, string> g_playerCommands = new Dictionary<ulong, string>(); // steamid, activeCommand
        Dictionary<string, ItemDefinition> g_itemDefinitions = new Dictionary<string, ItemDefinition>();
        Dictionary<string, ItemBlueprint> g_blueprintDefinitions = new Dictionary<string, ItemBlueprint>();

        void CreateExampleSalesLists()
        {
            var exampleList = new TradeList("list1");
            exampleList.Offers.Add(new TradeOffer(new Product("Wood", 1000), new[] { new Product("Salvaged Axe", 1) }));
            exampleList.Offers.Add(new TradeOffer(new Product("Metal Ore", 1000), new[] { new Product("Pick Axe", 1) }));
            g_config.TradeLists.Add(exampleList.Listname, exampleList);

            exampleList = new TradeList("list2");
            exampleList.Offers.Add(new TradeOffer(new Product("Cloth", 500), new[] { new Product("Animal Fat", 250) }));
            exampleList.Offers.Add(new TradeOffer(new Product("Animal Fat", 250), new[] { new Product("Cloth", 500) }));
            g_config.TradeLists.Add(exampleList.Listname, exampleList);

            exampleList = new TradeList("list3");
            exampleList.Offers.Add(new TradeOffer(new Product("Metal Fragments", 2500), new[] { new Product("Assault Rifle", 1), new Product("5.56 Rifle Ammo", 100) }));
            g_config.TradeLists.Add(exampleList.Listname, exampleList);

        }

        void Loaded()
        {
            g_config = Interface.GetMod().DataFileSystem.ReadObject<MoegicConfig>("MoegicBox");
            if (g_config.TradeLists.Count == 0)
            {
                Puts("New configuration file created.");
                CreateExampleSalesLists();
                g_config.Save();
            }
        }

        public class TradeOffer
        {
            public TradeOffer() { } // for serialization purposes

            public TradeOffer(Product price, Product [] reward)
            {
                Price = price;
                Reward = reward;
            }

            public Product Price { get; set; }
            public Product [] Reward { get; set; }

            public override string ToString()
            {
                var sb = new StringBuilder();
                sb.Append($"Selling {Reward[0]}");

                foreach (var reward in Reward.Except(new[] { Reward[0] }))
                {
                    sb.Append(" + ");
                    sb.Append(reward);
                }

                sb.Append($" (cost: {Price})");
                return sb.ToString();
            }
        }

        public class Product
        {
            public Product() { } // for serialization purposes

            public Product(string displayName, int amount)
            {
                DisplayName = displayName;
                Amount = amount;
            }

            public string DisplayName { get; set; }
            public int Amount { get; set; }

            public override string ToString()
            {
                return $"<color=yellow>{DisplayName}</color>x<color=yellow>{Amount}</color>";
            }
        }

        public class TradeList
        {
            public TradeList() { } // for serialization purposes

            public TradeList(string name)
            {
                Listname = name;
                Offers = new List<TradeOffer>();
            }

            public List<TradeOffer> Offers { get; set; }

            public string Listname { get; set; }

            public override string ToString()
            {
                var sb = new StringBuilder();
                foreach (var offer in Offers)
                    sb.Append($"\n\t{offer.ToString()}");
                return sb.ToString();
            }
        }

        public class TradeBox
        {
            public TradeBox() { } // for serialization purposes

            int BoxEntityId { get; set; }
            ulong OwnerId { get; set; }
            string TradeListName { get; set; }
        }
        
        bool IsMoethorized(BasePlayer player)
        {
            return player.IsAdmin();
        }

        void OnServerInitialized()
        {
            g_itemDefinitions = ItemManager.itemList.ToDictionary(c => c.displayName.english.Trim(new[] { ' ', '\n', '\r' }), c => c);
            g_blueprintDefinitions = ItemManager.bpList.ToDictionary(c => c.targetItem.shortname, c => c);
        }

        [HookMethod("SendHelpText")]
        private void SendHelpText(BasePlayer player)
        {
            cmdMoe(player, "help", null);
        }

        [ChatCommand("moe")]
        void cmdMoe(BasePlayer player, string cmd, string[] args)
        {
            var sb = new StringBuilder();
            sb.Append("<color=lime>MoegixBox</color> version <color=yellow>1.0.3</color> by <color=red>Deicide666ra & [HBros]Moe</color>\n");
            sb.Append("=======================================\n");
            sb.Append("\tAvailable commands:\n");
            sb.Append("<color=yellow>\t\t/mrec</color>\t\t\t\t\tstarts recycle box mode\n");
            if (IsMoethorized(player))
            {
                sb.Append("<color=yellow>\t\t/mlists</color>\t\t\t\tshows available tradelists\n");
                sb.Append("<color=yellow>\t\t/mshow xxxx</color>\tshows the contents of list named xxxx\n");
                sb.Append("<color=yellow>\t\t/mlink xxxx</color>\t\tstarts link mode for list named xxxx\n");
            }
            sb.Append("<color=yellow>\t\t/mulink</color>\t\t\t\tstarts unlink mode");

            if (cmd != "help")
            {
                sb.AppendLine();
                sb.Append(GetPriceString());
            }

            player.ChatMessage(sb.ToString());
        }

        [ChatCommand("mlists")]
        void cmdTradelists(BasePlayer player, string cmd, string[] args)
        {
            if (!IsMoethorized(player))
            {
                player.ChatMessage("Unknown command 'tradelists'!");
                return;
            }

            var msg = "<color=lime>Available trade lists:</color> <color=yellow>";
            foreach (var list in g_config.TradeLists)
                msg+= $"\n\t{list.Value.Listname}";
            msg += "</color>";
            player.ChatMessage(msg);
        }

        string FormatError(string message)
        {
            return $"<color=red>ERROR</color>: {message} - <color=orange>aborting</color>.";
        }

        [ChatCommand("mshow")]
        void cmdShowlist(BasePlayer player, string cmd, string[] args)
        {
            if (!IsMoethorized(player))
            {
                player.ChatMessage("Unknown command 'showlist'!");
                return;
            }

            // Make sure we have a listname as param otherwise show usage
            if (args.Length != 1)
            {
                player.ChatMessage(FormatError("Usage: <color=yellow>/mlist</color> <color=lime>listname</color>"));
                return;
            }

            // Get the list and show msg if it does not exist
            TradeList list= GetList(args[0]);
            if (list == null)
            {
                player.ChatMessage(FormatError($"Trade list <color=yellow>" + args[0] + "</color> not found (it's case sensitive!)"));
                return;
            }

            // Generate and show the list contents

            var sb = new StringBuilder();
            sb.Append($"Displaying trade list <color=lime>\"{list.Listname}\"</color>:");
            sb.Append(list);
            player.ChatMessage(sb.ToString());
        }
                
        [ChatCommand("mrec")]
        void cmdRecycleBox(BasePlayer player, string cmd, string[] args)
        {
            var sb = new StringBuilder();

            var currentCommand = GetActiveCommand(player);
            if (currentCommand != null)
            {
                ClearActiveCommand(player);
                sb.Append($"<color=yellow>{currentCommand}</color> mode is now <color=red>OFF</color>\n");
            }

            if (!HasPrice(player))
            {
                player.ChatMessage(FormatError(GetPriceString()));
                return;
            }

            SetActiveCommand(player, $"recyclebox");

            sb.Append($"<color=yellow>recyclebox</color> mode is now <color=lime>ON</color>\nOpen the container you wish to toggle recycling box mode for");
            player.ChatMessage(sb.ToString());
        }


        [ChatCommand("mlink")]
        void cmdLinkBox(BasePlayer player, string cmd, string[] args)
        {
            if (!IsMoethorized(player))
            {
                player.ChatMessage("Unknown command 'linkbox'!");
                return;
            }

            var sb = new StringBuilder();

            var currentCommand = GetActiveCommand(player);
            if (currentCommand != null)
            {
                ClearActiveCommand(player);
                sb.Append($"<color=yellow>{currentCommand}</color> mode is now <color=red>OFF</color>\n");
            }

            if (args.Length != 1)
            {
                sb.Append(FormatError("Usage: <color=yellow>/mlink</color> <color=lime>listname</color>"));
                player.ChatMessage(sb.ToString());
                return;
            }

            TradeList list= GetList(args[0]);
            if (list == null)
            {
                sb.Append(FormatError("Trade list <color=yellow>" + args[0] + "</color> not found (check case)"));
                player.ChatMessage(sb.ToString());
                return;
            }

            SetActiveCommand(player, $"linkbox {args[0]}");

            sb.Append($"<color=yellow>linkbox</color> mode is now <color=lime>ON</color>\nOpen the container you wish to associate with <color=yellow>{args[0]}</color>");
            player.ChatMessage(sb.ToString());
        }

        [ChatCommand("mulink")]
        void cmdUnlinkBox(BasePlayer player, string cmd, string[] args)
        {
            var sb = new StringBuilder();

            var currentCommand = GetActiveCommand(player);
            if (currentCommand != null)
            {
                ClearActiveCommand(player);
                sb.Append($"<color=yellow>{currentCommand}</color> mode is now <color=red>OFF</color>\n");
            }

            SetActiveCommand(player, $"unlinkbox");

            sb.Append($"<color=yellow>unlinkbox</color> mode is now <color=lime>ON</color>\nOpen the container you wish to unlink");
            player.ChatMessage(sb.ToString());
        }

        void OnPlayerLoot(PlayerLoot lootInventory, object lootable)
        {
            var looter = lootInventory.GetComponent<BasePlayer>();
            if (looter == null) return;

            BaseEntity container = lootable as BaseEntity;
            if (container == null) return;
            if (container.LookupShortPrefabName() != "box.wooden.large.prefab")
                return;

            string command = GetActiveCommand(looter);
            if (command == null)
            {
                var currentTradeList = GetActiveList(container);

                if (currentTradeList == "recycling")
                {
                    looter.ChatMessage("You found a <color=yellow>Moegic Recycling Box!</color>!");
                }
                else if (currentTradeList != null)
                {
                    var list = GetList(currentTradeList);
                    looter.ChatMessage("You found a <color=yellow>Moegic Tradebox</color>!" + list.ToString());

                }
                return;
            }
            
            var sb = new StringBuilder();
            ClearActiveCommand(looter);
            sb.Append($"<color=yellow>{command}</color> mode is now <color=red>OFF</color>");
            looter.ChatMessage(sb.ToString());

            RunCommand(looter, command, container);
        }

        void RunCommand(BasePlayer player, string command, BaseEntity box)
        {
            var currentTradeList = GetActiveList(box);

            //*********************************************
            // RECYCLEBOX
            //*********************************************
            if (command.StartsWith("recyclebox"))
            {
                // Make sure the box is not already associated with a list
                if (currentTradeList != null)
                {
                    player.ChatMessage($"This box is already associated with <color=yellow>{currentTradeList}</color>!");
                    return;
                }
                else
                {
                    // Check if we have the price and if so, remove
                    if (!HasPrice(player))
                    {
                        player.ChatMessage(FormatError(GetPriceString()));
                        return;
                    }
                    foreach (var price in g_config.RecyclerPrice)
                    {
                        var removed = RemoveItemsFromInventory(player, price.Key, price.Value);
                        if (removed != price.Value)
                        {
                            Puts($"Oh snap! Tried to remove {price.Value} X {price.Key} but only {removed} were found --- this should not happen, contact the author");
                        }
                    }

                    // Link the box
                    g_config.BoxLinks.Add(box.MoegicId(), "recycling");
                    g_config.Save();

                    // Report success
                    player.ChatMessage($"Box is now a <color=yellow>Moegic Recycling Box</color>!");
                    return;
                }
            }


            //*********************************************
            // LINKBOX
            //*********************************************
            if (command.StartsWith("linkbox"))
            {
                // Make sure the box is not already associated with a list
                if (currentTradeList != null)
                {
                    player.ChatMessage(FormatError("This box is already associated with <color=lime>" + currentTradeList + "</color>, use <color=yellow>/unlinkbox</color> first"));
                    return;
                }

                // Make sure the new list we're trying to assign actually exists
                var listName = command.Split(new[] { ' ' }).Last();
                TradeList list = GetList(listName);
                if (list == null)
                {
                    player.ChatMessage(FormatError("Trade list <color=yellow>" + listName + "</color> not found (check case)"));
                    return;
                }

                // Link the box
                g_config.BoxLinks.Add(box.MoegicId(), listName);
                g_config.Save();

                // Report success
                player.ChatMessage($"Box associated with <color=yellow>{listName}</color> successfully!");
                return;
            }

            //*********************************************
            // UNLINKBOX
            //*********************************************
            if (command.StartsWith("unlinkbox"))
            {
                // Abort if no list is currently associated with the box
                if (currentTradeList == null)
                {
                    player.ChatMessage(FormatError("This box is not linked with any list!"));
                    return;
                }

                if (currentTradeList != "recycling" && !IsMoethorized(player))
                {
                    player.ChatMessage(FormatError("You do not have the required access to unlink this box"));
                    return;
                }

                // Unlink the box
                g_config.BoxLinks.Remove(box.MoegicId());
                g_config.Save();

                // Report success
                player.ChatMessage($"Box successfully unlinked from <color=yellow>{currentTradeList}</color>");
                return;                
            }
        }


        private string GetActiveCommand(BasePlayer player)
        {
            string command = null;
            g_playerCommands.TryGetValue(player.userID, out command);
            return command;
        }

        private void SetActiveCommand(BasePlayer player, string command)
        {
            string oldCommand = GetActiveCommand(player);
            if (oldCommand != null) ClearActiveCommand(player);
            g_playerCommands.Add(player.userID, command);
        }

        private void ClearActiveCommand(BasePlayer player)
        {
            if (GetActiveCommand(player) != null)
                g_playerCommands.Remove(player.userID);
        }

        private TradeList GetList(string listName)
        {
            TradeList list;
            if (!g_config.TradeLists.TryGetValue(listName, out list)) return null;
            return list;
        }

        private string GetActiveList(BaseEntity box)
        {
            string listName = null;
            g_config.BoxLinks.TryGetValue(box.MoegicId(), out listName);
            return listName;
        }

        private bool SetActiveList(BaseEntity box, string list)
        {
            string existingList = GetActiveList(box);
            if (existingList != null) return false;
            g_config.BoxLinks.Add(box.MoegicId(), list);
            return true;
        }

        private static BasePlayer GetPlayerFromContainer(ItemContainer container, Item item) => item.GetOwnerPlayer() ?? 
                            BasePlayer.activePlayerList.FirstOrDefault(p => p.inventory.loot.IsLooting() && p.inventory.loot.entitySource == container.entityOwner);


        void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            BaseEntity box = container.entityOwner;
            if (box == null) return;

            if (box.LookupShortPrefabName() != "box.wooden.large.prefab") return;

            string listname = GetActiveList(box);
            if (listname == null) return;
            
            // Try to identify the looter based on stored info (ugly hack)
            BasePlayer player= GetPlayerFromContainer(container, item);
            if (player == null)
            {
                Puts($"Looter cannot be identified");
                return;
            }

            if (listname == "recycling")
            {
                if (item.hasCondition && item.condition == 0)
                {
                    player.ChatMessage(FormatError("This item is totally broken, nothing would be recycled out of it, try repairing it first!"));
                    return;
                }

                ItemBlueprint bp = null;
                if (g_blueprintDefinitions.TryGetValue(item.info.shortname, out bp) == false)
                {
                    player.ChatMessage(FormatError($"This item is not recyclable: {item.info.displayName.english}"));
                    player.GiveItem(item);
                    return;
                }

                item.RemoveFromContainer();
                SalvageItem(player, item);

                player.ChatMessage($"Successfully recycled <color=yellow>{item.info.displayName.english}</color> to base materials!");
            }
            else // normal tradelist
            {
                var list = GetList(listname);
                var matchingOffers = list.Offers.Where(o => o.Price.DisplayName == item.info.displayName.english && o.Price.Amount <= item.amount).OrderBy(o => o.Price.Amount);
                if (!matchingOffers.Any())
                {
                    player.ChatMessage($"This Moegic Tradebox does not have anything for sale that is worth {item.amount}X {item.info.displayName.translated}");
                    player.GiveItem(item);
                    return;
                }

                var pricePaid = item.amount;
                var price = matchingOffers.First().Price.Amount;

                // give player his reward(s)
                while (pricePaid >= price)
                {
                    pricePaid -= price;
                    foreach (var r in matchingOffers.First().Reward)
                    {
                        var reward = ItemManager.Create(g_itemDefinitions[r.DisplayName], r.Amount);
                        player.GiveItem(reward);
                    }
                }

                if (pricePaid > 0)
                {
                    var refund = ItemManager.Create(g_itemDefinitions[item.info.displayName.english], pricePaid);
                    player.GiveItem(refund);
                }

                item.RemoveFromContainer();
            }
        }

        //void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        //{
        //    if (g_config.BoxLinks.Any(bl => bl.Key == entity.MoegicId() && bl.Value != "recycling"))
        //    {
        //        hitInfo.damageTypes.ScaleAll(0);

        //        var player = hitInfo?.Initiator?.ToPlayer();
        //        if (player != null)
        //        {
        //            player.ChatMessage(FormatError("This is a <color=yellow>Moegic Tradebox</color> and it is immune to all forms of damage."));
        //        }
        //    }
        //}

        bool CheckPlayerInventoryForItems(BasePlayer player, string displayName, int amount)
        {
            ItemDefinition itemToCheck = null;
            var ret = g_itemDefinitions.TryGetValue(displayName, out itemToCheck);
            if (ret == false) return false;
            var foundItems = player.inventory.FindItemIDs(itemToCheck.itemid);
            if (foundItems == null || !foundItems.Any()) return false;
            var nbFound = foundItems == null ? 0 : foundItems.Sum(item => item.amount);
            if (nbFound < amount) return false;
            return true;
        }

        int RemoveItemsFromInventory(BasePlayer player, string displayName, int amount)
        {
            ItemDefinition itemToRemove = null;
            var ret = g_itemDefinitions.TryGetValue(displayName, out itemToRemove);
            var foundItems = player.inventory.FindItemIDs(itemToRemove.itemid);
            var nbFound = foundItems == null ? 0 : foundItems.Sum(item => item.amount);
            if (nbFound < amount) amount = nbFound;
            var nbRemoved = player.inventory.Take(foundItems, itemToRemove.itemid, amount);
            return nbRemoved;
        }

        void SalvageItem(BasePlayer player, Item item)
        {
            var sb = new StringBuilder();

            ItemBlueprint bp = null;
            if (g_blueprintDefinitions.TryGetValue(item.info.shortname, out bp) == false)
                return;

            var ratio = item.hasCondition ? (item.condition / item.maxCondition) : 1;

            sb.Append($"Recycling <color=lime>{item.info.displayName.english}</color> to {(int)(g_config.RefundRatio * 100.0)}% base materials:");

            // WARNING: This opens up a LOT of exploiting, use with caution
            // Example: Players using guitars or bullets to get quasi-unlimited bp frags
            //if (item.IsBlueprint())
            //{
            //    var framents = 100;
            //    switch (item.info.rarity)
            //    {
            //        case Rust.Rarity.Common:
            //            framents = (int)Math.Floor(100.0 * g_config.RefundRatio);
            //            break;
            //        case Rust.Rarity.Uncommon:
            //            framents = (int)Math.Floor(250.0 * g_config.RefundRatio);
            //            break;
            //        case Rust.Rarity.Rare:
            //            framents = (int)Math.Floor(500.0 * g_config.RefundRatio);
            //            break;
            //        case Rust.Rarity.VeryRare:
            //            framents = (int)Math.Floor(1000.0 * g_config.RefundRatio);
            //            break;
            //        default:
            //            return;
            //    }

            //    var newItem = ItemManager.Create(g_itemDefinitions["Blueprint Fragment"], framents);
            //    player.GiveItem(newItem);
            //    sb.AppendLine();
            //    sb.Append($"    <color=lime>{newItem.info.displayName.english}</color> X<color=yellow>{framents}</color>");
            //}
            //else
            {
                foreach (var ingredient in bp.ingredients)
                {
                    var refundAmount = (double)ingredient.amount / bp.amountToCreate;
                    refundAmount *= item.amount;
                    refundAmount *= ratio;
                    refundAmount *= g_config.RefundRatio;
                    refundAmount = Math.Ceiling(refundAmount);
                    if (refundAmount < 1) refundAmount = 1;

                    var newItem = ItemManager.Create(g_itemDefinitions[ingredient.itemDef.displayName.english], (int)refundAmount);

                    ItemBlueprint ingredientBp = null;
                    if (g_blueprintDefinitions.TryGetValue(ingredient.itemDef.shortname, out ingredientBp) == true)
                        if (item.hasCondition) newItem.condition = (float)Math.Ceiling(newItem.maxCondition * ratio);

                    player.GiveItem(newItem);
                    sb.AppendLine();
                    sb.Append($"    <color=lime>{newItem.info.displayName.english}</color> X<color=yellow>{newItem.amount}</color>");
                }
            }

            player.ChatMessage(sb.ToString());
        }

        string GetPriceString()
        {
            var sb = new StringBuilder();
            sb.Append("\tThe price to setup a <color=yellow>Recycling Moegic Box</color> is:");
            foreach (var price in g_config.RecyclerPrice)
            {
                sb.Append($"\n\t\t{price.Value} {price.Key}");
            }

            return sb.ToString();
        }

        bool HasPrice(BasePlayer player)
        {
            foreach (var price in g_config.RecyclerPrice)
            {
                if (!CheckPlayerInventoryForItems(player, price.Key, price.Value))
                    return false;
            }
            return true;
        }
    }
}

// --- End of file: MoegicBox.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Rewards.cs ---
// --- Original Local Path: Rewards.cs ---

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using Oxide.Core.Plugins;
using Oxide.Core;
using UnityEngine;
namespace Oxide.Plugins
{
    [Info("Rewards", "Tarek", "1.3.5", ResourceId = 1961)]
    [Description("Reward players for killing animals, players, other entities, and activity using Economic and/or ServerRewards")]

    class Rewards : RustPlugin
    {
        [PluginReference]
        Plugin Economics;
        [PluginReference]
        Plugin ServerRewards;
        [PluginReference]
        Plugin Friends;
        [PluginReference]
        Plugin Clans;
        [PluginReference]
        Plugin HumanNPC;

        private bool IsFriendsLoaded = false;
        private bool IsEconomicsLoaded = false;
        private bool IsServerRewardsLoaded = false;
        private bool IsClansLoaded = false;
        private bool IsNPCLoaded = false;

        private bool HappyHourActive = false;
        TimeSpan hhstart; TimeSpan hhend; TimeSpan hhnow;

        StoredData storedData;

        RewardRates rr; Multipliers m; Options o; Rewards_Version rv;//Strings str;
        public List<string> Options_itemList = new List<string> { "NPCReward_Enabled", "VIPMultiplier_Enabled", "ActivityReward_Enabled", "WelcomeMoney_Enabled", "WeaponMultiplier_Enabled", "DistanceMultiplier_Enabled", "UseEconomicsPlugin", "UseServerRewardsPlugin", "UseFriendsPlugin", "UseClansPlugin", "Economincs_TakeMoneyFromVictim", "ServerRewards_TakeMoneyFromVictim", "PrintToConsole", "HappyHour_Enabled" };
        public List<string> Multipliers_itemList = new List<string> { "LR300","VIPMultiplier","HuntingBow", "Crossbow", "AssaultRifle", "PumpShotgun", "SemiAutomaticRifle", "Thompson", "CustomSMG", "BoltActionRifle", "TimedExplosiveCharge", "M249", "EokaPistol", "Revolver", "WaterpipeShotgun", "SemiAutomaticPistol", "DoubleBarrelShotgun", "SatchelCharge", "distance_50", "distance_100", "distance_200", "distance_300", "distance_400", "HappyHourMultiplier" };
        public List<string> Rewards_itemList = new List<string> { "human", "bear", "wolf", "chicken", "horse", "boar", "stag", "helicopter", "autoturret", "ActivityRewardRate_minutes", "ActivityReward", "WelcomeMoney", "HappyHour_BeginHour", "HappyHour_DurationInHours", "HappyHour_EndHour", "NPCKill_Reward" };
        //public List<string> Strings_itemList = new List<string> { "CustomPermissionName" };
        //private Strings strings = new Strings();
        private Rewards_Version rewardsversion = new Rewards_Version();
        private RewardRates rewardrates = new RewardRates();
        private Options options = new Options();
        private Multipliers multipliers = new Multipliers();

        private Dictionary<BasePlayer, int> LastReward = new Dictionary<BasePlayer, int>();

        private void OnServerInitialized()
        {            
            if (options.UseEconomicsPlugin && Economics != null)
                IsEconomicsLoaded = true;
            else if (options.UseEconomicsPlugin && Economics == null)
                PrintWarning("Plugin Economics was not found! Can't reward players using Economics.");
            if (options.UseServerRewardsPlugin && ServerRewards != null)
                IsServerRewardsLoaded = true;
            else if (options.UseServerRewardsPlugin && ServerRewards == null)
                PrintWarning("Plugin ServerRewards was not found! Can't reward players using ServerRewards.");
            if (options.UseFriendsPlugin && Friends != null)
                IsFriendsLoaded = true;
            else if (options.UseFriendsPlugin && Friends == null)
                PrintWarning("Plugin Friends was not found! Can't check if victim is friend to killer.");
            if (options.UseClansPlugin && Clans != null)
                IsClansLoaded = true;
            else if (options.UseClansPlugin && Clans == null)
                PrintWarning("Plugin Clans was not found! Can't check if victim is in the same clan of killer.");
            if (options.NPCReward_Enabled && HumanNPC != null)
                IsNPCLoaded = true;
            else if (options.NPCReward_Enabled && HumanNPC == null)
                PrintWarning("Plugin HumanNPC was not found! Can't reward players on NPC kill.");
        }
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            //Config["Strings"] = str;
            Config["Rewards_Version"] = rv;
            Config["Rewards"] = rr;
            Config["Multipliers"] = m;
            Config["Options"] = o;
            SaveConfig();
            LoadConfig();
        }
        void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["KillReward"] = "You received {0}. Reward for killing {1}",
                ["ActivityReward"] = "You received {0}. Reward for activity",
                ["WelcomeReward"] = "Welcome to server! You received {0} as a welcome reward",
                ["VictimNoMoney"] = "{0} doesn't have enough money.",
                ["SetRewards"] = "Varaibles you can set:",
                ["RewardSet"] = "Reward was set",
                ["stag"] = "a stag",
                ["boar"] = "a boar",
                ["horse"] = "a horse",
                ["bear"] = "a bear",
                ["wolf"] = "a wolf",
                ["chicken"] = "a chicken",
                ["autoturret"] = "an autoturret",
                ["helicopter"] = "a helicopter",
                ["Prefix"] = "Rewards",
                ["HappyHourStart"] = "Happy hour started",
                ["HappyHourEnd"] = "Happy hour ended"
            }, this);
        }
        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject<StoredData>("Rewards", storedData);
            Puts("Data saved");
        }
        void Loaded()
        {
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>("Rewards");
        }
        private void SetDefaultConfigValues()
        {
            //str = new Strings
            //{
            //    CustomPermissionName = "null"
            //};
            rv = new Rewards_Version
            {
                Version = this.Version.ToString()
            };
            rr = new RewardRates
            {
                human = 50,
                bear = 35,
                wolf = 30,
                chicken = 15,
                horse = 15,
                boar = 15,
                stag = 10,
                helicopter = 250,
                autoturret = 150,
                ActivityRewardRate_minutes = 30,
                ActivityReward = 25,
                WelcomeMoney = 250,
                HappyHour_BeginHour = 20,
                HappyHour_DurationInHours = 2,
                HappyHour_EndHour = 23,
                NPCKill_Reward = 50
            };
            m = new Multipliers
            {
                AssaultRifle = 1.5,
                BoltActionRifle = 1.5,
                HuntingBow = 1,
                PumpShotgun = 1,
                Thompson = 1.3,
                SemiAutomaticRifle = 1.3,
                Crossbow = 1.3,
                CustomSMG = 1.5,
                M249 = 1.5,
                SemiAutomaticPistol = 1,
                WaterpipeShotgun = 1.4,
                EokaPistol = 1.1,
                Revolver = 1.2,
                TimedExplosiveCharge = 2,
                SatchelCharge = 2,
                DoubleBarrelShotgun = 1.5,
                distance_50 = 1,
                distance_100 = 1.3,
                distance_200 = 1.5,
                distance_300 = 2,
                distance_400 = 3,
                HappyHourMultiplier = 2,
                VIPMultiplier = 2,
                LR300 = 1.5
            };

            o = new Options
            {
                ActivityReward_Enabled = true,
                WelcomeMoney_Enabled = true,
                UseEconomicsPlugin = true,
                UseServerRewardsPlugin = false,
                UseFriendsPlugin = true,
                UseClansPlugin = true,
                Economincs_TakeMoneyFromVictim = true,
                ServerRewards_TakeMoneyFromVictim = false,
                WeaponMultiplier_Enabled = true,
                DistanceMultiplier_Enabled = true,
                PrintToConsole = true,
                HappyHour_Enabled = true,
                VIPMultiplier_Enabled = false,
                NPCReward_Enabled = false
            };
        }
        private void FixConfig()
        {
            try
            {
                
                Dictionary<string, object> temp;
                Dictionary<string, object> temp2;
                Dictionary<string, object> temp3;
                Dictionary<string, object> temp4;
                try { temp = (Dictionary<string, object>)Config["Rewards"]; } catch { Config["Rewards"] = rr; SaveConfig(); temp = (Dictionary<string, object>)Config["Rewards"]; }
                try { temp2 = (Dictionary<string, object>)Config["Options"]; } catch { Config["Options"] = o; SaveConfig(); temp2 = (Dictionary<string, object>)Config["Options"]; }
                try { temp3 = (Dictionary<string, object>)Config["Multipliers"]; } catch { Config["Multipliers"] = m; SaveConfig(); temp3 = (Dictionary<string, object>)Config["Multipliers"]; }
                //try { temp4 = (Dictionary<string, object>)Config["Strings"]; } catch { Config["Strings"] = str; SaveConfig(); temp4 = (Dictionary<string, object>)Config["Strings"]; Puts(temp4["CustomPermissionName"].ToString()); }
                foreach (var s in Rewards_itemList)
                {
                    if (!temp.ContainsKey(s))
                    {
                        Config["Rewards", s] = rr.GetItemByString(s);
                        SaveConfig();
                    }
                }
                foreach (var s in Options_itemList)
                {
                    if (!temp2.ContainsKey(s))
                    {
                        Config["Options", s] = o.GetItemByString(s);
                        SaveConfig();
                    }
                }
                foreach (var s in Multipliers_itemList)
                {
                    if (!temp3.ContainsKey(s))
                    {
                        Config["Multipliers", s] = m.GetItemByString(s);
                        SaveConfig();
                    }
                }                
                Config["Rewards_Version", "Version"] = this.Version.ToString();
                SaveConfig();
            }
            catch (Exception ex)
            { Puts(ex.Message); Puts("Couldn't fix. Creating new config file"); Config.Clear(); LoadDefaultConfig(); Loadcfg(); }
        }
        void Loadcfg()
        {
            SetDefaultConfigValues();
            try
            {
                Dictionary<string, object> temp = (Dictionary<string, object>)Config["Rewards_Version"];
                if (this.Version.ToString() != temp["Version"].ToString())
                {
                    Puts("Outdated config file. Fixing");
                    FixConfig();
                }              
            }
            catch (Exception e)
            {
                Puts("Outdated config file. Fixing");
                FixConfig();                            
            }
            try
            {
                Dictionary<string, object> temp = (Dictionary<string, object>)Config["Rewards"];
                rewardrates.ActivityReward = Convert.ToDouble(temp["ActivityReward"]);
                rewardrates.ActivityRewardRate_minutes = Convert.ToDouble(temp["ActivityRewardRate_minutes"]);
                rewardrates.autoturret = Convert.ToDouble(temp["autoturret"]);
                rewardrates.bear = Convert.ToDouble(temp["bear"]);
                rewardrates.boar = Convert.ToDouble(temp["boar"]);
                rewardrates.chicken = Convert.ToDouble(temp["chicken"]);
                rewardrates.helicopter = Convert.ToDouble(temp["helicopter"]);
                rewardrates.horse = Convert.ToDouble(temp["horse"]);
                rewardrates.human = Convert.ToDouble(temp["human"]);
                rewardrates.stag = Convert.ToDouble(temp["stag"]);
                rewardrates.WelcomeMoney = Convert.ToDouble(temp["WelcomeMoney"]);
                rewardrates.wolf = Convert.ToDouble(temp["wolf"]);
                rewardrates.HappyHour_BeginHour = Convert.ToDouble(temp["HappyHour_BeginHour"]);
                rewardrates.HappyHour_DurationInHours = Convert.ToDouble(temp["HappyHour_DurationInHours"]);
                rewardrates.HappyHour_EndHour = Convert.ToDouble(temp["HappyHour_EndHour"]);
                rewardrates.NPCKill_Reward = Convert.ToDouble(temp["NPCKill_Reward"]);

                Dictionary<string, object> temp2 = (Dictionary<string, object>)Config["Options"];
                options.ActivityReward_Enabled = (bool)temp2["ActivityReward_Enabled"];
                options.DistanceMultiplier_Enabled = (bool)temp2["DistanceMultiplier_Enabled"];
                options.Economincs_TakeMoneyFromVictim = (bool)temp2["Economincs_TakeMoneyFromVictim"];
                options.ServerRewards_TakeMoneyFromVictim = (bool)temp2["ServerRewards_TakeMoneyFromVictim"];
                options.UseClansPlugin = (bool)temp2["UseClansPlugin"];
                options.UseEconomicsPlugin = (bool)temp2["UseEconomicsPlugin"];
                options.UseFriendsPlugin = (bool)temp2["UseFriendsPlugin"];
                options.UseServerRewardsPlugin = (bool)temp2["UseServerRewardsPlugin"];
                options.WeaponMultiplier_Enabled = (bool)temp2["WeaponMultiplier_Enabled"];
                options.WelcomeMoney_Enabled = (bool)temp2["WelcomeMoney_Enabled"];
                options.PrintToConsole = (bool)temp2["PrintToConsole"];
                options.VIPMultiplier_Enabled = (bool)temp2["VIPMultiplier_Enabled"];
                options.NPCReward_Enabled = (bool)temp2["NPCReward_Enabled"];
                options.HappyHour_Enabled = (bool)temp2["HappyHour_Enabled"];

                Dictionary<string, object> temp3 = (Dictionary<string, object>)Config["Multipliers"];
                multipliers.AssaultRifle = Convert.ToDouble(temp3["AssaultRifle"]);
                multipliers.BoltActionRifle = Convert.ToDouble(temp3["BoltActionRifle"]);
                multipliers.HuntingBow = Convert.ToDouble(temp3["HuntingBow"]);
                multipliers.PumpShotgun = Convert.ToDouble(temp3["PumpShotgun"]);
                multipliers.Thompson = Convert.ToDouble(temp3["Thompson"]);
                multipliers.SemiAutomaticRifle = Convert.ToDouble(temp3["SemiAutomaticRifle"]);
                multipliers.Crossbow = Convert.ToDouble(temp3["Crossbow"]);
                multipliers.CustomSMG = Convert.ToDouble(temp3["CustomSMG"]);
                multipliers.M249 = Convert.ToDouble(temp3["M249"]);
                multipliers.TimedExplosiveCharge = Convert.ToDouble(temp3["TimedExplosiveCharge"]);
                multipliers.EokaPistol = Convert.ToDouble(temp3["EokaPistol"]);
                multipliers.Revolver = Convert.ToDouble(temp3["Revolver"]);
                multipliers.SemiAutomaticPistol = Convert.ToDouble(temp3["SemiAutomaticPistol"]);
                multipliers.WaterpipeShotgun = Convert.ToDouble(temp3["WaterpipeShotgun"]);
                multipliers.DoubleBarrelShotgun = Convert.ToDouble(temp3["DoubleBarrelShotgun"]);
                multipliers.SatchelCharge = Convert.ToDouble(temp3["SatchelCharge"]);
                multipliers.distance_50 = Convert.ToDouble(temp3["distance_50"]);
                multipliers.distance_100 = Convert.ToDouble(temp3["distance_100"]);
                multipliers.distance_200 = Convert.ToDouble(temp3["distance_200"]);
                multipliers.distance_300 = Convert.ToDouble(temp3["distance_300"]);
                multipliers.distance_400 = Convert.ToDouble(temp3["distance_400"]);
                multipliers.VIPMultiplier = Convert.ToDouble(temp3["VIPMultiplier"]);
                multipliers.HappyHourMultiplier = Convert.ToDouble(temp3["HappyHourMultiplier"]);
                multipliers.LR300 = Convert.ToDouble(temp3["LR300"]);

                //Dictionary<string, object> temp4 = (Dictionary<string, object>)Config["Strings"];
                //str.CustomPermissionName = temp4["CustomPermissionName"].ToString();
            }
            catch
            {
                FixConfig(); Loadcfg();
            }
        }
        void Init()
        {
            permission.RegisterPermission("rewards.admin", this);
            permission.RegisterPermission("rewards.vip", this);
            LoadDefaultMessages();
            Loadcfg();
            if (options.HappyHour_Enabled)
            {
                hhstart = new TimeSpan(Convert.ToInt32(rewardrates.HappyHour_BeginHour), 0, 0);
                hhend = new TimeSpan(Convert.ToInt32(rewardrates.HappyHour_EndHour), 0, 0);
                
            }
            #region Activity Check
            if (options.ActivityReward_Enabled || options.HappyHour_Enabled)
            {
                timer.Repeat(60, 0, () =>
                {
                    if (options.ActivityReward_Enabled)
                    {
                        foreach (var p in BasePlayer.activePlayerList)
                        {
                            if (Convert.ToDouble(p.secondsConnected) / 60 > rewardrates.ActivityRewardRate_minutes)
                            {
                                if (LastReward.ContainsKey(p))
                                {
                                    if (Convert.ToDouble(p.secondsConnected - LastReward[p]) / 60 > rewardrates.ActivityRewardRate_minutes)
                                    {
                                        RewardPlayer(p, rewardrates.ActivityReward);
                                        LastReward[p] = p.secondsConnected;
                                    }
                                }
                                else
                                {
                                    RewardPlayer(p, rewardrates.ActivityReward);
                                    LastReward.Add(p, p.secondsConnected);
                                }
                            }
                        }
                    }
                    if (options.HappyHour_Enabled)
                    {
                        if (!HappyHourActive)
                        {
                            if (GameTime() >= rewardrates.HappyHour_BeginHour)
                            {
                                HappyHourActive = true;
                                Puts("Happy hour started. Ending at " + rewardrates.HappyHour_EndHour);
                                BroadcastMessage(Lang("Prefix"), Lang("HappyHourStart"));
                            }
                        }
                        else
                        {
                            if (GameTime() > rewardrates.HappyHour_EndHour)
                            {
                                HappyHourActive = false;
                                Puts("Happy hour ended");
                                BroadcastMessage(Lang("Prefix"), Lang("HappyHourEnd"));
                            }
                        }
                    }

                });
            }
            #endregion
        }
        bool checktime(float gtime, double cfgtime)
        {

            return false;
        }
        void OnPlayerInit(BasePlayer player)
        {
            if (options.WelcomeMoney_Enabled)
            {
                if (!storedData.Players.Contains(player.UserIDString))
                {
                    RewardPlayer(player, rewardrates.WelcomeMoney, 1, null, true);
                    storedData.Players.Add(player.UserIDString);
                    SaveData();
                }
            }
        }
        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        bool HasPerm(BasePlayer p, string pe) => permission.UserHasPermission(p.userID.ToString(), pe);
        void SendChatMessage(BasePlayer player, string prefix, string msg = null, object uid = null) => rust.SendChatMessage(player, msg == null ? prefix : "<color=#C4FF00>" + prefix + "</color>: " + msg, null, uid?.ToString() ?? "0");
        void BroadcastMessage(string prefix, string msg = null, object uid = null) => rust.BroadcastChat(msg == null ? prefix : "<color=#C4FF00>" + prefix + "</color>: " + msg, null);
        void OnKillNPC(BasePlayer victim, HitInfo info)
        {
            
            if (options.NPCReward_Enabled)
            {
                if (info?.Initiator?.ToPlayer() == null)
                    return;
                double totalmultiplier = 1;

                if (options.DistanceMultiplier_Enabled || options.WeaponMultiplier_Enabled)
                    totalmultiplier = (options.DistanceMultiplier_Enabled ? multipliers.GetDistanceM(victim.Distance2D(info?.Initiator?.ToPlayer())) : 1) * (options.WeaponMultiplier_Enabled ? multipliers.GetWeaponM(info?.Weapon?.GetItem()?.info?.displayName?.english) : 1) * (HappyHourActive ? multipliers.HappyHourMultiplier : 1) * ((options.VIPMultiplier_Enabled && HasPerm(info?.Initiator?.ToPlayer(), "rewards.vip")) ? multipliers.VIPMultiplier : 1) * ((HasPerm(info?.Initiator?.ToPlayer(), "rewards.vip")) ? multipliers.VIPMultiplier : 1);

                RewardPlayer(info?.Initiator?.ToPlayer(), rewardrates.NPCKill_Reward, totalmultiplier, victim.displayName);
            }
        }
        void OnEntityDeath(BaseCombatEntity victim, HitInfo info)
        {          
            if (victim == null)
                return;
            if (info?.Initiator?.ToPlayer() == null)
                return;
            double totalmultiplier = 1;
            
            if (options.DistanceMultiplier_Enabled || options.WeaponMultiplier_Enabled)
                totalmultiplier = (options.DistanceMultiplier_Enabled ? multipliers.GetDistanceM(victim.Distance2D(info?.Initiator?.ToPlayer())) : 1) * (options.WeaponMultiplier_Enabled ? multipliers.GetWeaponM(info?.Weapon?.GetItem()?.info?.displayName?.english) : 1) * (HappyHourActive ? multipliers.HappyHourMultiplier : 1) * ((options.VIPMultiplier_Enabled && HasPerm(info?.Initiator?.ToPlayer(), "rewards.vip")) ? multipliers.VIPMultiplier : 1) * ((HasPerm(info?.Initiator?.ToPlayer(), "rewards.vip")) ? multipliers.VIPMultiplier : 1);
            
            if (victim.ToPlayer() != null)
            {
                if (victim.ToPlayer().userID <= 2147483647)
                    return;
                else if (info?.Initiator?.ToPlayer().userID == victim.ToPlayer().userID)
                    return;
                else { RewardForPlayerKill(info?.Initiator?.ToPlayer(), victim.ToPlayer(), totalmultiplier); return; }
            }
            else if (victim.name.Contains("autospawn/animals"))
            {
                try
                {
                    var AnimalName = victim.name.Split(new[] { "autospawn/animals/" }, StringSplitOptions.None)[1].Split('.')[0];
                    double rewardmoney = 0;
                    if (AnimalName == "stag")
                        rewardmoney = rewardrates.stag;
                    else if (AnimalName == "boar")
                        rewardmoney = rewardrates.boar;
                    else if (AnimalName == "horse")
                        rewardmoney = rewardrates.horse;
                    else if (AnimalName == "bear")
                        rewardmoney = rewardrates.bear;
                    else if (AnimalName == "wolf")
                        rewardmoney = rewardrates.wolf;
                    else if (AnimalName == "chicken")
                        rewardmoney = rewardrates.chicken;
                    else
                        return;
                    RewardPlayer(info?.Initiator?.ToPlayer(), rewardmoney, totalmultiplier, Lang(AnimalName, info?.Initiator?.ToPlayer().UserIDString));
                }
                catch { }
            }
            else if (victim.name.Contains("helicopter/patrolhelicopter.prefab"))
            {
                RewardPlayer(info?.Initiator?.ToPlayer(), rewardrates.helicopter, totalmultiplier, Lang("helicopter", info?.Initiator?.ToPlayer().UserIDString));
            }
            else if (victim.name == "assets/prefabs/npc/autoturret/autoturret_deployed.prefab")
            {
                RewardPlayer(info?.Initiator?.ToPlayer(), rewardrates.autoturret, totalmultiplier, Lang("autoturret", info?.Initiator?.ToPlayer().UserIDString));
            }
        }
        private void RewardPlayer(BasePlayer player, double amount, double multiplier = 1, string reason = null, bool isWelcomeReward = false)
        {
            
            if (amount > 0)
            {
                amount = amount * multiplier;
                if (options.UseEconomicsPlugin)
                    Economics?.Call("Deposit", player.userID, amount);
                if (options.UseServerRewardsPlugin)
                    ServerRewards?.Call("AddPoints", new object[] { player.userID, amount });
                if (!isWelcomeReward)
                {
                    SendChatMessage(player, Lang("Prefix"), reason == null ? Lang("ActivityReward", player.UserIDString, amount) : Lang("KillReward", player.UserIDString, amount, reason));
                    ConVar.Server.Log("/oxide/logs/RewardsLog.txt", player.displayName + " got " + amount + " for " + (reason == null ? "activity" : "killing " + reason));
                    if (options.PrintToConsole)
                        Puts(player.displayName + " got " + amount + " for " + (reason == null ? "activity" : "killing " + reason));
                }
                else
                {
                    SendChatMessage(player, Lang("Prefix"), Lang("WelcomeReward", player.UserIDString, amount));
                    ConVar.Server.Log("/oxide/logs/RewardsLog.txt", player.displayName + " got " + amount + " as a welcome reward");
                    if (options.PrintToConsole)
                        Puts(player.displayName + " got " + amount + " as a welcome reward");
                }
            }
        }
        private static float GameTime()
        {           
            return TOD_Sky.Instance.Cycle.Hour;
        }
        private void RewardForPlayerKill(BasePlayer player, BasePlayer victim, double multiplier = 1)
        {
            if (rewardrates.human > 0)
            {
                bool success = true;
                bool isFriend = false;
                if (IsFriendsLoaded)
                    isFriend = (bool)Friends?.CallHook("HasFriend", player.userID, victim.userID);               
                if (!isFriend && IsClansLoaded)
                {
                    string pclan = (string)Clans?.CallHook("GetClanOf", player); string vclan = (string)Clans?.CallHook("GetClanOf", victim);
                    if (pclan == vclan)
                        isFriend = true;
                }
                if (!isFriend)
                {
                    if (IsEconomicsLoaded) //Eco
                    {
                        if (options.Economincs_TakeMoneyFromVictim)
                        {
                            if (!(bool)Economics?.Call("Transfer", victim.userID, player.userID, rewardrates.human * multiplier))
                            {
                                SendChatMessage(player, Lang("Prefix"), Lang("VictimNoMoney", player.UserIDString, victim.displayName));
                                success = false;
                            }
                        }
                        else
                            Economics?.Call("Deposit", player.userID, rewardrates.human * multiplier);
                    }
                    if (IsServerRewardsLoaded) //ServerRewards
                    {
                        if (options.ServerRewards_TakeMoneyFromVictim)
                            ServerRewards?.Call("TakePoints", new object[] { victim.userID, rewardrates.human * multiplier });
                        ServerRewards?.Call("AddPoints", new object[] { player.userID, rewardrates.human * multiplier });
                        success = true;
                    }
                    if (success) //Send message if transaction was successful
                    {
                        SendChatMessage(player, Lang("Prefix"), Lang("KillReward", player.UserIDString, rewardrates.human * multiplier, victim.displayName));
                        ConVar.Server.Log("/oxide/logs/RewardsLog.txt", player.displayName + " got " + rewardrates.human * multiplier + " for killing " + victim.displayName);
                        if (options.PrintToConsole)
                            Puts(player.displayName + " got " + rewardrates.human * multiplier + " for killing " + victim.displayName);
                    }
                }
            }
        }
        [ConsoleCommand("setreward")]
        private void setreward(ConsoleSystem.Arg arg)
        {
            if (arg.isAdmin)
            {
                try
                {
                    var args = arg.Args;
                    Config["Rewards", args[0]] = Convert.ToDouble(args[1]);
                    SaveConfig();
                    try
                    {
                        Loadcfg();
                    }
                    catch
                    {
                        FixConfig();
                    }
                    arg.ReplyWith("Reward set");
                }
                catch { arg.ReplyWith("Varaibles you can set: 'human', 'horse', 'wolf', 'chicken', 'bear', 'boar', 'stag', 'helicopter', 'autoturret', 'ActivityReward' 'ActivityRewardRate_minutes', 'WelcomeMoney'"); }
            }
        }
        [ConsoleCommand("showrewards")]
        private void showrewards(ConsoleSystem.Arg arg)
        {
            if (arg.isAdmin)
                arg.ReplyWith(String.Format("human = {0}, horse = {1}, wolf = {2}, chicken = {3}, bear = {4}, boar = {5}, stag = {6}, helicopter = {7}, autoturret = {8} Activity Reward Rate (minutes) = {9}, Activity Reward = {10}, WelcomeMoney = {11}", rewardrates.human, rewardrates.horse, rewardrates.wolf, rewardrates.chicken, rewardrates.bear, rewardrates.boar, rewardrates.stag, rewardrates.helicopter, rewardrates.autoturret, rewardrates.ActivityRewardRate_minutes, rewardrates.ActivityReward, rewardrates.WelcomeMoney));
        }
        [ChatCommand("setreward")]
        private void setrewardCommand(BasePlayer player, string command, string[] args)
        {
            if (HasPerm(player, "rewards.admin"))
            {
                try
                {
                    Config["Rewards", args[0]] = Convert.ToDouble(args[1]);
                    SaveConfig();
                    try
                    {
                        Loadcfg();
                    }
                    catch
                    {
                        FixConfig();
                    }
                    SendChatMessage(player, Lang("Prefix"), Lang("RewardSet", player.UserIDString));
                }
                catch { SendChatMessage(player, Lang("Prefix"), Lang("SetRewards", player.UserIDString) + " 'human', 'horse', 'wolf', 'chicken', 'bear', 'boar', 'stag', 'helicopter', 'autoturret', 'ActivityReward', 'ActivityRewardRate_minutes', 'WelcomeMoney'"); }
            }
        }
        [ChatCommand("showrewards")]
        private void showrewardsCommand(BasePlayer player, string command, string[] args)
        {
            if (HasPerm(player, "rewards.admin"))
                SendChatMessage(player, Lang("Prefix"), String.Format("human = {0}, horse = {1}, wolf = {2}, chicken = {3}, bear = {4}, boar = {5}, stag = {6}, helicopter = {7}, autoturret = {8} Activity Reward Rate (minutes) = {9}, Activity Reward = {10}, WelcomeMoney = {11}", rewardrates.human, rewardrates.horse, rewardrates.wolf, rewardrates.chicken, rewardrates.bear, rewardrates.boar, rewardrates.stag, rewardrates.helicopter, rewardrates.autoturret, rewardrates.ActivityRewardRate_minutes, rewardrates.ActivityReward, rewardrates.WelcomeMoney));
        }
        class StoredData
        {
            public HashSet<string> Players = new HashSet<string>();
            public StoredData()
            {
            }
        }
        class RewardRates
        {
            public double human { get; set; }
            public double bear { get; set; }
            public double wolf { get; set; }
            public double chicken { get; set; }
            public double horse { get; set; }
            public double boar { get; set; }
            public double stag { get; set; }
            public double helicopter { get; set; }
            public double autoturret { get; set; }
            public double ActivityRewardRate_minutes { get; set; }
            public double ActivityReward { get; set; }
            public double WelcomeMoney { get; set; }
            public double HappyHour_BeginHour { get; set; }
            public double HappyHour_DurationInHours { get; set; }
            public double HappyHour_EndHour { get; set; }
            public double NPCKill_Reward { get; set; }
            public double GetItemByString(string itemName)
            {
                if (itemName == "human")
                    return this.human;
                else if (itemName == "bear")
                    return this.bear;
                else if (itemName == "wolf")
                    return this.wolf;
                else if (itemName == "chicken")
                    return this.chicken;
                else if (itemName == "horse")
                    return this.horse;
                else if (itemName == "boar")
                    return this.boar;
                else if (itemName == "stag")
                    return this.stag;
                else if (itemName == "helicopter")
                    return this.helicopter;
                else if (itemName == "autoturret")
                    return this.autoturret;
                else if (itemName == "ActivityRewardRate_minutes")
                    return this.ActivityRewardRate_minutes;
                else if (itemName == "ActivityReward")
                    return this.ActivityReward;
                else if (itemName == "WelcomeMoney")
                    return this.WelcomeMoney;
                else if (itemName == "HappyHour_BeginHour")
                    return this.HappyHour_BeginHour;
                else if (itemName == "HappyHour_DurationInHours")
                    return this.HappyHour_DurationInHours;
                else if (itemName == "HappyHour_EndHour")
                    return this.HappyHour_EndHour;
                else if (itemName == "NPCKill_Reward")
                    return this.NPCKill_Reward;
                else
                    return 0;
            }
        }
        class Multipliers
        {
            public double HuntingBow { get; set; }
            public double Crossbow { get; set; }
            public double AssaultRifle { get; set; }
            public double PumpShotgun { get; set; }
            public double SemiAutomaticRifle { get; set; }
            public double Thompson { get; set; }
            public double CustomSMG { get; set; }
            public double BoltActionRifle { get; set; }
            public double TimedExplosiveCharge { get; set; }
            public double M249 { get; set; }
            public double EokaPistol { get; set; }
            public double Revolver { get; set; }
            public double WaterpipeShotgun { get; set; }
            public double SemiAutomaticPistol { get; set; }
            public double DoubleBarrelShotgun { get; set; }
            public double SatchelCharge { get; set; }
            public double distance_50 { get; set; }
            public double distance_100 { get; set; }
            public double distance_200 { get; set; }
            public double distance_300 { get; set; }
            public double distance_400 { get; set; }
            public double HappyHourMultiplier { get; set; }
            public double VIPMultiplier { get; set; }
            public double CustomPermissionMultiplier { get; set; }
            public double LR300 { get; set; }
            public double GetWeaponM(string wn)
            {
                if (wn == "Assault Rifle")
                    return this.AssaultRifle;
                else if (wn == "Hunting Bow")
                    return this.HuntingBow;
                else if (wn == "Bolt Action Rifle")
                    return this.BoltActionRifle;
                else if (wn == "Crossbow")
                    return this.Crossbow;
                else if (wn == "Thompson")
                    return this.Thompson;
                else if (wn == "Eoka Pistol")
                    return this.EokaPistol;
                else if (wn == "Revolver")
                    return this.Revolver;
                else if (wn == "Custom SMG")
                    return this.CustomSMG;
                else if (wn == "Semi-Automatic Rifle")
                    return this.SemiAutomaticRifle;
                else if (wn == "Semi-Automatic Pistol")
                    return this.SemiAutomaticPistol;
                else if (wn == "Pump Shotgun")
                    return this.PumpShotgun;
                else if (wn == "Waterpipe Shotgun")
                    return this.WaterpipeShotgun;
                else if (wn == "M249")
                    return this.M249;
                else if (wn == "Explosivetimed")
                    return this.TimedExplosiveCharge;
                else if (wn == "Explosivesatchel")
                    return this.SatchelCharge;
                else if (wn == "Double Barrel Shotgun")
                    return this.DoubleBarrelShotgun;
                else if (wn == "LR-300 Assault Rifle")
                    return this.LR300;
                else
                    return 1;
            }
            public double GetDistanceM(float distance)
            {
               
                if (distance >= 400)
                    return this.distance_400;
                else if (distance >= 300)
                    return this.distance_300;
                else if (distance >= 200)
                    return this.distance_200;
                else if (distance >= 100)
                    return this.distance_100;
                else if (distance >= 50)
                    return this.distance_50;
                else
                    return 1;
            }

            public double GetItemByString(string itemName)
            {
                if (itemName == "HuntingBow")
                    return this.HuntingBow;
                else if (itemName == "Crossbow")
                    return this.Crossbow;
                else if (itemName == "AssaultRifle")
                    return this.AssaultRifle;
                else if (itemName == "PumpShotgun")
                    return this.PumpShotgun;
                else if (itemName == "SemiAutomaticRifle")
                    return this.SemiAutomaticRifle;
                else if (itemName == "Thompson")
                    return this.Thompson;
                else if (itemName == "CustomSMG")
                    return this.CustomSMG;
                else if (itemName == "BoltActionRifle")
                    return this.BoltActionRifle;
                else if (itemName == "TimedExplosiveCharge")
                    return this.TimedExplosiveCharge;
                else if (itemName == "M249")
                    return this.M249;
                else if (itemName == "EokaPistol")
                    return this.EokaPistol;
                else if (itemName == "Revolver")
                    return this.Revolver;
                else if (itemName == "WaterpipeShotgun")
                    return this.WaterpipeShotgun;
                else if (itemName == "SemiAutomaticPistol")
                    return this.SemiAutomaticPistol;
                else if (itemName == "DoubleBarrelShotgun")
                    return this.DoubleBarrelShotgun;
                else if (itemName == "SatchelCharge")
                    return this.SatchelCharge;
                else if (itemName == "distance_50")
                    return this.distance_50;
                else if (itemName == "distance_100")
                    return this.distance_100;
                else if (itemName == "distance_200")
                    return this.distance_200;
                else if (itemName == "distance_300")
                    return this.distance_300;
                else if (itemName == "distance_400")
                    return this.distance_400;
                else if (itemName == "HappyHourMultiplier")
                    return this.HappyHourMultiplier;
                else if (itemName == "VIPMultiplier")
                    return this.VIPMultiplier;
                else if (itemName == "CustomPermissionMultiplier")
                    return this.CustomPermissionMultiplier;
                else if (itemName == "LR300")
                    return this.LR300;
                else
                    return 0;
            }
            
        }
        class Options
        {
            public bool ActivityReward_Enabled { get; set; }
            public bool WelcomeMoney_Enabled { get; set; }
            public bool WeaponMultiplier_Enabled { get; set; }
            public bool DistanceMultiplier_Enabled { get; set; }
            public bool HappyHour_Enabled { get; set; }
            public bool VIPMultiplier_Enabled { get; set; }
            public bool UseEconomicsPlugin { get; set; }
            public bool UseServerRewardsPlugin { get; set; }
            public bool UseFriendsPlugin { get; set; }
            public bool UseClansPlugin { get; set; }
            public bool Economincs_TakeMoneyFromVictim { get; set; }
            public bool ServerRewards_TakeMoneyFromVictim { get; set; }
            public bool PrintToConsole { get; set; }           
            public bool CustomPermissionMultiplier_Enabled { get; set; }  
            public bool NPCReward_Enabled { get; set; }         
            public bool GetItemByString(string itemName)
            {
                if (itemName == "ActivityReward_Enabled")
                    return this.ActivityReward_Enabled;
                else if (itemName == "WelcomeMoney_Enabled")
                    return this.WelcomeMoney_Enabled;
                else if (itemName == "WeaponMultiplier_Enabled")
                    return this.WeaponMultiplier_Enabled;
                else if (itemName == "DistanceMultiplier_Enabled")
                    return this.DistanceMultiplier_Enabled;
                else if (itemName == "UseEconomicsPlugin")
                    return this.UseEconomicsPlugin;
                else if (itemName == "UseServerRewardsPlugin")
                    return this.UseServerRewardsPlugin;
                else if (itemName == "UseFriendsPlugin")
                    return this.UseFriendsPlugin;
                else if (itemName == "UseClansPlugin")
                    return this.UseClansPlugin;
                else if (itemName == "Economincs_TakeMoneyFromVictim")
                    return this.Economincs_TakeMoneyFromVictim;
                else if (itemName == "ServerRewards_TakeMoneyFromVictim")
                    return this.ServerRewards_TakeMoneyFromVictim;
                else if (itemName == "PrintToConsole")
                    return this.PrintToConsole;
                else if (itemName == "HappyHour_Enabled")
                    return this.HappyHour_Enabled;
                else if (itemName == "VIPMultiplier_Enabled")
                    return this.VIPMultiplier_Enabled;
                else if (itemName == "NPCReward_Enabled")
                    return this.NPCReward_Enabled;
                else
                    return false;
            }          
        }
        class Rewards_Version
        {
            public string Version { get; set; }
        }
        //class Strings
        //{
        //    public string CustomPermissionName { get; set; }
        //    public string GetItemByString(string itemName)
        //    {
        //        if (itemName == "CustomPermissionName")
        //            return this.CustomPermissionName;
        //        else
        //            return null;
        //    }
        //}
    }
}

// --- End of file: Rewards.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AC.cs ---
// --- Original Local Path: AC.cs ---

using UnityEngine;
using Newtonsoft.Json;
using Oxide.Core.Libraries;
using System.Collections.Generic;
using Time = UnityEngine.Time;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("AntiCheat", "playermodel", "1.0.0")]
    class AC : RustPlugin
    {

        #region Helpers
        
        public class PlayerDetect
        {
            public string SteamId { get; set; }
            public int Detects { get; set; }
            
            public string DetectType { get; set; }
        }
        
        class DetectSystem {
            static List<PlayerDetect> repository = new List<PlayerDetect>();

            public static int Count(string SteamId, string DetectType)
            {
                IEnumerable<PlayerDetect> detects = repository.Where(item => item.SteamId == SteamId && item.DetectType == DetectType);

                if(detects.Count() < 1) {
                    return 0;
                }

                PlayerDetect detect = detects.First();

                if(detect != null)
                    return detect.Detects;
                
                return 0;
            }

            public static bool Increase(string SteamId, string DetectType)
            {
                IEnumerable<PlayerDetect> detects = repository.Where(item => item.SteamId == SteamId && item.DetectType == DetectType);

                if(detects.Count() < 1) {
                    repository.Add(new PlayerDetect() {
                        SteamId = SteamId,
                        DetectType = DetectType,
                        Detects = 1
                    });

                    return true;
                }

                PlayerDetect detect = detects.First();

                if(detect == null) return false;

                if(!repository.Contains(detect)) return false;

                repository[repository.IndexOf(detect)].Detects++;

                return true;
            }

            public static void Drop(string SteamId, string DetectType)
            {
                repository.RemoveAll(item => item.SteamId == SteamId && item.DetectType == DetectType);
            }
        }

        class AcConfig
        {
            public string DiscordWebHook;
            public string BanReason;
            public int AntiFakeAdminInterval;
            public bool BanForBulletTeleport;
            public bool BanForInvalidDistance;
            public bool BanForFastKill;
            public bool BanForAntiAimDetectType1;
            public bool BanForWalkOnWater;
            public bool BanForIvalidHitMaterial;
            public bool BanForAutoFarm;
            public bool ShootWhileMounted;
        }
        AcConfig config;
        
        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(new AcConfig() {
                DiscordWebHook = "https://discord.com/api/webhooks/",
                BanReason = "Использование читов",
                AntiFakeAdminInterval = 30,
                BanForBulletTeleport = true,
                BanForInvalidDistance = true,
                BanForFastKill = true,
                BanForAntiAimDetectType1 = false,
                BanForWalkOnWater = false,
                BanForIvalidHitMaterial = true,
                BanForAutoFarm = true,
                ShootWhileMounted = true,
            }, true);
        }
        void SendDetectDiscord(string content, string detectType)
        {
            Dictionary<string, object> embed = new Dictionary<string, object>
            {
                ["embeds"] = new List<object>
                {
                    new Dictionary<string, object>
                    {
                        ["title"] = $"Игрок - {content}",
                        ["description"] = $"Возможное использование {detectType}, проследите за игроком!",
                        ["color"] = 16711680
                    }
                }
            };
            
            string json = JsonConvert.SerializeObject(embed);
            
            webrequest.Enqueue(config.DiscordWebHook, json, (code, response) =>
            {
                if (code != 204)
                {
                    Puts($"Failed to send Discord webhook. Code: {code}, Response: {response}");
                }
                else
                {
                    Puts("Discord webhook sent successfully!");
                }
            }, this, RequestMethod.POST, new Dictionary<string, string> { ["Content-Type"] = "application/json" });
        }
        
        void SendProjectileLog(string content, string detectType, HitInfo info, BasePlayer attacker)
        {
            Dictionary<string, object> embed = new Dictionary<string, object>
            {
                ["embeds"] = new List<object>
                {
                    new Dictionary<string, object>
                    {
                        ["title"] = $"Игрок - {content}",
                        ["description"] = $"Возможное использование {detectType}, проследите за игроком!",
                        ["color"] = 16711680,
                        ["fields"] = new List<object>
                        {
                            new Dictionary<string, object>
                            {
                                ["name"] = "Shoot information:",
                                ["value"] = $"\n\n" +
                                            $"Hit position world: {info.HitPositionWorld}\n" +
                                            $"Hit position local: {info.HitPositionLocal}\n" +
                                            $"Hit normal world: {info.HitNormalWorld}\n" +
                                            $"Hit normal local: {info.HitNormalLocal}\n" +
                                            $"Attacker see point end? {attacker.IsVisible(info.HitPositionOnRay())}\n" +
                                            $"\nDebug info:\n" +
                                            $"Projectile distance: {info.ProjectileDistance}\n" +
                                            $"Distance to target: {Vector3.Distance(attacker.transform.position, info.HitPositionWorld)}\n" +
                                            $"Point start: {info.PointStart}\n" +
                                            $"Point end: {info.PointEnd}\n" +
                                            $"Weapon used: {info.WeaponPrefab.name}"
                            }
                        }
                    }
                }
            };
            
            string json = JsonConvert.SerializeObject(embed);
            
            webrequest.Enqueue(config.DiscordWebHook, json, (code, response) =>
            {
                if (code != 204)
                {
                    Puts($"Failed to send Discord webhook. Code: {code}, Response: {response}");
                }
                else
                {
                    Puts("Discord webhook sent successfully!");
                }
            }, this, RequestMethod.POST, new Dictionary<string, string> { ["Content-Type"] = "application/json" });
        }
        bool IsInteger(double number)
        {
            return number == (int)number;
        }
        
        #endregion

        void Init()
        {
            config = Config.ReadObject<AcConfig>();
        }

        void OnServerInitialized()
        {
            timer.Every(config.AntiFakeAdminInterval, () => {
                foreach(BasePlayer player in BasePlayer.activePlayerList) {
                    if(player != null && !player.IsAdmin) {
                        player.SendConsoleCommand("noclip");
                        player.SendConsoleCommand("debugcamera");
                        player.SendConsoleCommand("drawcolliders true");
                    }
                }
            });
        }
        
        void OnWeaponFired(BaseProjectile projectile, BasePlayer player, ItemModProjectile mod, ProtoBuf.ProjectileShoot projectiles)
        {
            if(player == null || player.IsAdmin) return;
            
            if (player.timeSinceLastTick > 0.3f && Performance.report.frameRate > 60)
            {

                if(!DetectSystem.Increase(player.UserIDString, "manipulator"))
                    return;
                
                if (DetectSystem.Count(player.UserIDString, "manipulator") > 6)
                {
                    SendDetectDiscord($"{player.UserIDString} | {player.displayName} | {player.net.connection.ipaddress.Split(':')[0]}", "manipulator");

                    DetectSystem.Drop(player.UserIDString, "manipulator");

                    return;
                }
            }
            
            var veh = player.GetMountedVehicle();
            if(veh != null) {
                if((veh.PrefabName.Contains("minicopter") || veh.PrefabName.Contains("scraptransporthelicopter")) && veh.GetPlayerSeat(player) == 0) {
                    SendDetectDiscord($"{player.UserIDString} | {player.displayName} | {player.net.connection.ipaddress.Split(':')[0]}", "ShootWhileMounted");
                    veh.Hurt(float.MaxValue);
                    
                    if (config.ShootWhileMounted)
                    {
                        ConsoleSystem.Run(ConsoleSystem.Option.Server, "ban", player.UserIDString, config.BanReason);
                    }
                }
            }
        }
        
        object OnPlayerLand(BasePlayer player, float num)
        {
            if (player == null || player.IsAdmin) return null;
            if (num == 1)
            {
                if(!DetectSystem.Increase(player.UserIDString, "fastkill"))
                    return null;

                if (DetectSystem.Count(player.UserIDString, "fastkill") > 3)
                {
                    SendDetectDiscord($"{player.UserIDString} | {player.displayName} | {player.net.connection.ipaddress.Split(':')[0]}", "fastkill");

                    DetectSystem.Drop(player.UserIDString, "fastkill");

                    if (config.BanForFastKill)
                    {
                        ConsoleSystem.Run(ConsoleSystem.Option.Server, "ban", player.UserIDString, config.BanReason);
                    }
                    return null;
                }
            }
            return null;
        }
        
        // object OnPlayerViolation(BasePlayer player, AntiHackType type, float amount)
        // {
        //     if (player != null && type == AntiHackType.FlyHack)
        //     {
        //         
        //         // if (!player.IsAdmin)
        //         // {
        //         //     if (player.Connection != null && !player.Connection.IsRecording)
        //         //     {
        //         //         player.StartDemoRecording();
        //         //     }
        //         //     
        //         //     SendDetectDiscord($"{player.UserIDString} | {player.displayName} | {player.net.connection.ipaddress.Split(':')[0]}", "flyhack_violation");
        //         //     
        //         //     timer.Once(5f, () =>
        //         //     {
        //         //         if (player.Connection != null && player.Connection.IsRecording)
        //         //         {
        //         //             player.StopDemoRecording();
        //         //         }
        //         //     });                    
        //         // }
        //         
        //     }
        //     return null;
        // }
        
        object OnPlayerTick(BasePlayer player, PlayerTick msg, bool wasPlayerStalled)
        {
            if(player == null || player.IsAdmin || !player.IsConnected || player.IsWounded() || player.IsSleeping() || player.IsDead() || Performance.report.frameRate < 60) return null;
            
            if (msg.inputState.aimAngles.x > 360 ||
                msg.inputState.aimAngles.x < -360 ||
                msg.inputState.aimAngles.y > 360 ||
                msg.inputState.aimAngles.y < -360)
            {
                if(!DetectSystem.Increase(player.UserIDString, "antiaim_type1"))
                    return null;

                if (DetectSystem.Count(player.UserIDString, "antiaim_type1") > 128)
                {
                    SendDetectDiscord($"{player.UserIDString} | {player.displayName} | {player.net.connection.ipaddress.Split(':')[0]}", "antiaim_type1");

                    DetectSystem.Drop(player.UserIDString, "antiaim_type1");
                    
                    if (config.BanForAntiAimDetectType1)
                    {
                        ConsoleSystem.Run(ConsoleSystem.Option.Server, "ban", player.UserIDString, config.BanReason);
                    }
                    return null;
                }
            }

            return null;
        }
        
        /*void OnPlayerInput(BasePlayer player, InputState input)
        {
        	if(player == null || player.IsAdmin) return;
            
            float radius = player.GetRadius();
            float height = player.GetHeight(false);
            Vector3 currentPosition = player.transform.position;
            Vector3 lastPosition = player.lastReceivedTick.position;
            Vector3 vector = (lastPosition + currentPosition) * 0.5f;
            Vector3 vector2 = vector + new Vector3(0.0f, radius - 2.0f, 0.0f);
            Vector3 vector3 = vector + new Vector3(0.0f, height - radius, 0.0f);
            bool isBuildingNear = GamePhysics.CheckCapsule(vector2, vector3, 0.5f, 2097152, QueryTriggerInteraction.Ignore);
            if (isBuildingNear)
            {
                if (input.IsDown(BUTTON.JUMP) && !player.modelState.onLadder)
                {
                    RaycastHit hit;
                    if (Physics.Raycast(player.transform.position, Vector3.down, out hit, Mathf.Infinity, LayerMask.GetMask("Terrain", "World", "Construction")))
                    {
                        if (hit.distance > 0.1f)
                        {
                            var ray = player.eyes.HeadRay();
                            RaycastHit lookray;

                            if (Physics.Raycast(ray, out lookray, 1f))
                            {
                                BaseEntity entity = lookray.GetEntity();
                                if (entity.ShortPrefabName == "wall" || entity.ShortPrefabName == "wall.half")
                                {
                                    if (hit.distance > 1.7)
                                    {
                                        if(!DetectSystem.Increase(player.UserIDString, "spider"))
                                            return;
                                        
                                        if (DetectSystem.Count(player.UserIDString, "spider") > 20)
                                        {
                                            SendDetectDiscord($"{player.UserIDString}\n" +
                                                              $"IP:{player.net.connection.ipaddress.Split(':')[0]}", "spider");
                        
                                            DetectSystem.Drop(player.UserIDString, "spider");
                                            
                                            return;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            bool isOverWater = WaterLevel.Test(player.transform.position, 0.01f, player);
            float waterDepth = WaterLevel.GetOverallWaterDepth(player.transform.position, false, player);
            
            if (waterDepth > 1.2f && !player.isMounted)
            {
                if (isOverWater)
                {
                    if(!DetectSystem.Increase(player.UserIDString, "walk_on_water"))
                        return;
                
                    if (DetectSystem.Count(player.UserIDString, "walk_on_water") > 20)
                    {
                        SendDetectDiscord($"{player.UserIDString}\n" + 
                                          $"IP:{player.net.connection.ipaddress.Split(':')[0]}", "walk_water");
                        
                        DetectSystem.Drop(player.UserIDString, "walk_on_water");
                        
                        if (config.BanForWalkOnWater)
                        {
                            ConsoleSystem.Run(ConsoleSystem.Option.Server, "ban", player.UserIDString, config.BanReason);
                        }
                        return;
                    }
                }
            }
        }*/
        
        object OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            if(info.HitEntity == null || attacker.IsAdmin) return null;
            
            if (info.HitEntity is BasePlayer)
            {
                if(Vector3.Distance(attacker.transform.position, info.HitPositionWorld) < info.ProjectileDistance 
                   && Mathf.Abs(Vector3.Distance(attacker.transform.position, info.HitPositionWorld) - info.ProjectileDistance) >= 50)
                {
                    SendProjectileLog($"{attacker.UserIDString} | {attacker.displayName} | {attacker.net.connection.ipaddress.Split(':')[0]}", "invalid_hit_distance", info, attacker);
                    
                    if (config.BanForInvalidDistance)
                    {
                        ConsoleSystem.Run(ConsoleSystem.Option.Server, "ban", attacker.UserIDString, config.BanReason);
                    }
                    return false;
                }
                
                // if(IsInteger(info.ProjectileDistance))
                // {
                //     SendProjectileLog($"{attacker.UserIDString} | {attacker.displayName} | {attacker.net.connection.ipaddress.Split(':')[0]}", "invalid_hit_distance", info, attacker);
                //     
                //     if (config.BanForInvalidDistance)
                //     {
                //         ConsoleSystem.Run(ConsoleSystem.Option.Server, "ban", attacker.UserIDString, config.BanReason);
                //     }
                //     return false;
                // }
                
                if (info.HitNormalLocal == Vector3.zero && info.HitNormalWorld == Vector3.zero) {
                    SendProjectileLog($"{attacker.UserIDString} | {attacker.displayName} | {attacker.net.connection.ipaddress.Split(':')[0]}", "bullet_teleport", info, attacker);
                    
                    if (config.BanForBulletTeleport)
                    {
                        ConsoleSystem.Run(ConsoleSystem.Option.Server, "ban", attacker.UserIDString, config.BanReason);
                    }
                    return false;
                }
            
                if (info.HitMaterial != 1395914656) {
                    if(!DetectSystem.Increase(attacker.UserIDString, "invalid_hitmaterial")) return false;
                
                    if (DetectSystem.Count(attacker.UserIDString, "invalid_hitmaterial") > 3)
                    {
                        SendProjectileLog($"{attacker.UserIDString} | {attacker.displayName} | {attacker.net.connection.ipaddress.Split(':')[0]}", "invalid_hitmaterial", info, attacker);

                        DetectSystem.Drop(attacker.UserIDString, "invalid_hitmaterial");
                        
                        if (config.BanForIvalidHitMaterial)
                        {
                            ConsoleSystem.Run(ConsoleSystem.Option.Server, "ban", attacker.UserIDString, config.BanReason);
                        }
                        return false;
                    }
                }
                
            } else {
                if(info.HitEntity.name == "assets/prefabs/misc/orebonus/orebonus_generic.prefab") {
                    SendDetectDiscord($"{attacker.UserIDString} | {attacker.displayName} | {attacker.net.connection.ipaddress.Split(':')[0]})", "autofarm");

                    ConsoleSystem.Run(ConsoleSystem.Option.Server, "ban", attacker.UserIDString, config.BanReason);

                    return false;
                }
            }

            return null;
        }
    }
}

// --- End of file: AC.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/WellFed.cs ---
// --- Original Local Path: WellFed.cs ---

using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("WellFed", "ColonBlow", "1.1.5", ResourceId = 1233)]
    class WellFed : RustPlugin
    {

	public float LoginWellFedHealth => Config.Get<float>("Login Health");
	public float SpawnWellFedHealth => Config.Get<float>("Spawn Health");
	public float LoginWellFedHunger => Config.Get<float>("Login Hunger");
	public float SpawnWellFedHunger => Config.Get<float>("Spawn Hunger");
	public float LoginWellFedThirst => Config.Get<float>("Login Thirst");
	public float SpawnWellFedThirst => Config.Get<float>("Spawn Thirst");
	
        protected override void LoadDefaultConfig()
        {

            Config["Login Health"] = 100f;
            Config["Spawn Health"] = 100f;
	    Config["Login Hunger"] = 500f;
	    Config["Spawn Hunger"] = 500f;
	    Config["Login Thirst"] = 500f;
	    Config["Spawn Thirst"] = 500f;

            SaveConfig();
        }

        void OnServerInitialized()
        {
           	permission.RegisterPermission("wellfed.onlogin", this);
		permission.RegisterPermission("wellfed.onspawn", this);
    	}

	void OnPlayerInit(BasePlayer player)

        {
		if (CanBeFed(player, "wellfed.onlogin"))
			{
                	player.metabolism.hydration.value = LoginWellFedThirst;
                	player.metabolism.calories.value = LoginWellFedHunger;
                	player.health = LoginWellFedHealth;
			}
	return;
	}

	void OnPlayerRespawned(BasePlayer player)

        {
		if (CanBeFed(player, "wellfed.onspawn"))
			{
                	player.metabolism.hydration.value = SpawnWellFedThirst;
                	player.metabolism.calories.value = SpawnWellFedHunger;
                	player.health = SpawnWellFedHealth;
			}
	return;
	}

        bool CanBeFed(BasePlayer player, string perm)
        {
            if (permission.UserHasPermission(player.userID.ToString(), perm)) return true;
            return false;
        }

    }
}


// --- End of file: WellFed.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SimpleScan-1.0.0.cs ---
// --- Original Local Path: SimpleScan-1.0.0.cs ---

using UnityEngine;
using System.Collections.Generic;

namespace Oxide.Plugins 
{
    [Info("Simple Scan", "walkinrey", "1.0.0")]
    class SimpleScan : RustPlugin 
    {
        [ChatCommand("simplescan")] 
        void ScanCommand(BasePlayer player) 
        {
            if(player.IsAdmin || player.IPlayer.HasPermission("simplescan.use")) 
            {
                RaycastHit hitInfo;
                if (!Physics.Raycast(player.eyes.position, player.eyes.HeadForward(), out hitInfo, 5f)) return;
                var ent = hitInfo.GetEntity();
                if (ent == null) return;
                if(ent is Door) {
                    Door door = (Door)ent;
                    SendReply(player, $"<size=18><color=yellow>Объект: дверь ({ent._name})</color></size>\nВладелец: {GetOwner(ent)}\nВладелец онлайн: {isOnline(GetOwner(ent))}");
                    var slot = ((Door) ent).GetSlot(BaseEntity.Slot.Lock);
                    if(slot == null) return;
                    SendReply(player, $"<size=18><color=yellow>Слот: кодовый замок</color></size>\nВладелец: {GetOwner(ent)}\nВладелец онлайн: {isOnline(GetOwner(ent))}\nЗамок: {IsCodeLockLocked(((CodeLock)slot))}\nКод: {((CodeLock)slot).code}\nГостевой код: {((CodeLock)slot).guestCode}");
                    return;
                }
                if(ent is KeyLock) {
                    KeyLock keyLock = (KeyLock)ent;
                    SendReply(player, $"<size=18><color=yellow>Объект: кодовый замок</color></size>\nВладелец: {GetOwner(ent)}\nВладелец онлайн: {isOnline(GetOwner(ent))}\nЗамок: {IsKeyLockLocked(keyLock)}\nКод: {keyLock.keyCode}");
                    return;
                }
                if(ent is BuildingPrivlidge) {
                    SendReply(player, $"<size=18><color=yellow>Объект: шкаф</color></size>\nВладелец: {GetOwner(ent)}\nВладелец онлайн: {isOnline(GetOwner(ent))}\nЗащищен на: {((BuildingPrivlidge)ent).GetProtectedMinutes()} минут\n");
                    string message = "<size=18><color=yellow>Авторизованные игроки:</color></size>";
                    foreach(var playerClass in ((BuildingPrivlidge)ent).authorizedPlayers) 
                    {
                        message = message + $"\nИмя: {playerClass.username}\nSteam ID: {playerClass.userid}\nОнлайн: {isOnline(playerClass.userid)}";
                    }
                    SendReply(player, message);
                    return;
                }
                SendReply(player, $"<size=18><color=yellow>Объект: {ent._name}</color></size>\nВладелец: {GetOwner(ent)}\nВладелец онлайн: {isOnline(GetOwner(ent))}");
            }
        }
        void Init() => permission.RegisterPermission("simplescan.use", this);
        string IsKeyLockLocked(KeyLock locker) 
        {
            if(locker.HasFlag(BaseEntity.Flags.Locked)) return "закрыт";
            else return "открыт";
        }
        string IsCodeLockLocked(CodeLock codeLock) 
        {
            if(codeLock.IsLocked()) return "закрыт";
            else return "открыт";
        }
        string isOnline(ulong id) 
        {
            BasePlayer playerOnline = null;
            foreach(var playerFind in BasePlayer.activePlayerList) 
            {
                if(playerFind.userID == id) 
                {
                    playerOnline = playerFind;
                    break;
                }
            }
            if(playerOnline == null) return "нет";
            else return $"да\nИмя владельца: {playerOnline.displayName}";
        }
        ulong GetOwner(BaseEntity entity) 
        {
            if(entity.OwnerID == 0) return 0;
            else return entity.OwnerID;
        }
    }
}

// --- End of file: SimpleScan-1.0.0.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ZombieHorde.cs ---
// --- Original Local Path: ZombieHorde.cs ---

﻿using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core.Plugins;
using Rust.Ai.HTN;
using Rust.Ai.HTN.Sensors;
using Rust.Ai.HTN.Reasoning;
using Rust.Ai.HTN.Murderer;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.AI;

namespace Oxide.Plugins
{
    [Info("ZombieHorde", "k1lly0u", "0.3.4")]
    class ZombieHorde : RustPlugin
    {
        [PluginReference] 
        private Plugin Kits, Spawns;

        private static ZombieHorde Instance { get; set; }   

        private const string SCARECROW_PREFAB = "assets/prefabs/npc/scarecrow/scarecrow.prefab";

        private const int WORLD_LAYER = 65536;
       

        #region Oxide Hooks       
        private void OnServerInitialized()
        {
            Instance = this;

            HordeThinkManager.Create();

            permission.RegisterPermission("zombiehorde.admin", this);
            permission.RegisterPermission("zombiehorde.ignore", this);

            _blueprintBase = ItemManager.FindItemDefinition("blueprintbase");
            _glowEyes = ItemManager.FindItemDefinition("gloweyes");

            if (!configData.Member.TargetedByPeaceKeeperTurrets)
                Unsubscribe(nameof(CanEntityBeHostile));

            ValidateLoadoutProfiles();
            ValidateSpawnSystem();
            CreateMonumentHordeOrders();
            NextTick(() => CreateRandomHordes());
        }
                
        private void OnEntityTakeDamage(BaseCombatEntity baseCombatEntity, HitInfo hitInfo)
        {
            if (hitInfo != null)
            {
                HordeMember hordeMember;

                if (hitInfo.InitiatorPlayer != null)
                {
                    hordeMember = hitInfo.InitiatorPlayer.GetComponent<HordeMember>();
                    if (hordeMember != null)
                    {
                        if (hordeMember.damageMultiplier != 1f)
                            hitInfo.damageTypes.ScaleAll(hordeMember.damageMultiplier);
                        return;
                    }
                }

                hordeMember = baseCombatEntity.GetComponent<HordeMember>();
                if (hordeMember != null)
                {
                    if (configData.Member.HeadshotKills && hitInfo.isHeadshot)
                        hitInfo.damageTypes.ScaleAll(1000);
                }
            }
        }

        private void OnPlayerDeath(BasePlayer player, HitInfo hitInfo)
        {
            if (player == null || hitInfo == null)
                return;

            HordeMember hordeMember = player.GetComponent<HordeMember>();
            if (hordeMember != null)
            {
                if (configData.Loot.DropInventory)
                    hordeMember.PrepareInventory();

                hordeMember.Manager.OnMemberDeath(hordeMember, hitInfo.Initiator as BaseCombatEntity);
                return;
            }

            if (configData.Horde.CreateOnDeath && hitInfo.InitiatorPlayer != null)
            {
                HordeMember attacker = hitInfo.InitiatorPlayer.GetComponent<HordeMember>();

                if (attacker != null && attacker.Manager != null)                
                    attacker.Manager.OnPlayerDeath(player, attacker);
            }
        }

        private void OnEntityKill(HTNPlayer htnPlayer)
        {
            HordeMember hordeMember = htnPlayer.GetComponent<HordeMember>();
            if (hordeMember != null && hordeMember.Manager != null)            
                hordeMember.Manager.OnMemberDeath(hordeMember, null);            
        }

        private object CanBeTargeted(BasePlayer player, MonoBehaviour behaviour)
        {
            HordeMember hordeMember = player.GetComponent<HordeMember>();
            if (hordeMember != null)
            {
                if (((behaviour is AutoTurret) || (behaviour is GunTrap) || (behaviour is FlameTurret)) && configData.Member.TargetedByTurrets)
                    return null;
                return false;
            }

            return null;
        }

        private object CanEntityBeHostile(HTNPlayer htnPlayer) => htnPlayer != null && htnPlayer.GetComponent<HordeMember>() != null ? (object)true : null;
        
        private object CanBradleyApcTarget(BradleyAPC bradleyAPC, HTNPlayer htnPlayer)
        {
            if (htnPlayer != null)
            {
                HordeMember hordeMember = htnPlayer.GetComponent<HordeMember>();
                if (hordeMember != null && !configData.Member.TargetedByAPC)
                    return false;
            }
            return null;
        }

        private object OnCorpsePopulate(HTNPlayer htnPlayer, NPCPlayerCorpse npcPlayerCorpse)
        {
            if (htnPlayer != null && npcPlayerCorpse != null)
            {
                HordeMember hordeMember = htnPlayer.GetComponent<HordeMember>();
                if (hordeMember == null)
                    return null;

                if (configData.Loot.DropInventory)
                {
                    hordeMember.MoveInventoryTo(npcPlayerCorpse);
                    return npcPlayerCorpse;
                }

                SpawnIntoContainer(npcPlayerCorpse);
                return npcPlayerCorpse;
            }
            return null;
        }

        private object CanPopulateLoot(HTNPlayer htnPlayer, NPCPlayerCorpse corpse) => htnPlayer != null && htnPlayer.GetComponent<HordeMember>() != null ? (object)false : null;

        private void Unload()
        {
            HordeManager.Order.OnUnload();

            _hordeThinkManager.Destroy();

            for (int i = HordeManager._allHordes.Count - 1; i >= 0; i--)
                HordeManager._allHordes[i].Destroy(true, true);

            HordeManager._allHordes.Clear();

            _spawnState = SpawnState.Spawn;

            configData = null;
            Instance = null;
        }
        #endregion

        #region Functions
        #region Horde Spawning
        private List<Vector3> _spawnPoints;

        private SpawnSystem _spawnSystem = SpawnSystem.None; 

        private bool ValidateSpawnSystem()
        {
            _spawnSystem = ParseType<SpawnSystem>(configData.Horde.SpawnType);

            if (_spawnSystem == SpawnSystem.None)
            {
                PrintError("You have set an invalid value in the config entry \"Spawn Type\". Unable to spawn hordes!");
                return false;
            }
            else if (_spawnSystem == SpawnSystem.SpawnsDatabase)
            {
                if (Spawns != null)
                {
                    if (string.IsNullOrEmpty(configData.Horde.SpawnFile))
                    {
                        PrintError("You have selected SpawnsDatabase as your method of spawning hordes, however you have not specified a spawn file. Unable to spawn hordes!");
                        return false;
                    }

                    object success = Spawns?.Call("LoadSpawnFile", configData.Horde.SpawnFile);
                    if (success is List<Vector3>)
                    {
                        _spawnPoints = success as List<Vector3>;
                        if (_spawnPoints.Count > 0)
                            return true;
                    }
                    PrintError("You have selected SpawnsDatabase as your method of spawning hordes, however the spawn file you have chosen is either invalid, or has no spawn points. Unable to spawn hordes!");
                    return false;
                }
                else PrintError("You have selected SpawnsDatabase as your method of spawning hordes, however SpawnsDatabase is not loaded on your server. Unable to spawn hordes!");
                return false;
            }
            
            return true;
        }

        private const int SPAWN_RAYCAST_MASK = 1 << 0 | 1 << 8 | 1 << 15 | 1 << 17 | 1 << 21 | 1 << 29;

        private const TerrainTopology.Enum SPAWN_TOPOLOGY_MASK = (TerrainTopology.Enum.Ocean | TerrainTopology.Enum.River | TerrainTopology.Enum.Lake | TerrainTopology.Enum.Cliff | TerrainTopology.Enum.Offshore | TerrainTopology.Enum.Summit);

        private Vector3 GetSpawnPoint()
        {
            switch (_spawnSystem)
            {
                case SpawnSystem.None:
                    break;

                case SpawnSystem.SpawnsDatabase:
                {
                    if (Spawns == null)
                    {
                        PrintError("Tried getting a spawn point but SpawnsDatabase is null. Make sure SpawnsDatabase is still loaded to continue using custom spawn points");
                        break;
                    }

                    if (_spawnPoints == null || _spawnPoints.Count == 0)
                    {
                        PrintError("No spawnpoints have been loaded from the designated spawnfile. Defaulting to Rust spawns");
                        break;
                    }

                    Vector3 spawnPoint = _spawnPoints.GetRandom();
                    _spawnPoints.Remove(spawnPoint);
                    if (_spawnPoints.Count == 0)
                        _spawnPoints = (List<Vector3>)Spawns.Call("LoadSpawnFile", configData.Horde.SpawnFile);

                    return spawnPoint;
                }
            }
            
            float size = (World.Size / 2f) * 0.75f;
            NavMeshHit navMeshHit;

            for (int i = 0; i < 10; i++)
            {
                Vector2 randomInCircle = UnityEngine.Random.insideUnitCircle * size;

                Vector3 position = new Vector3(randomInCircle.x, 0, randomInCircle.y);
                position.y = TerrainMeta.HeightMap.GetHeight(position);

                if (NavMesh.SamplePosition(position, out navMeshHit, 25f, 1))
                {                    
                    position = navMeshHit.position;

                    if (Physics.SphereCast(new Ray(position + (Vector3.up * 5f), Vector3.down), 10f, 10f, SPAWN_RAYCAST_MASK))
                        continue;

                    if (ContainsTopologyAtPoint(SPAWN_TOPOLOGY_MASK, position))
                        continue;

                    if (WaterLevel.GetWaterDepth(position, true, null) <= 0.01f)                    
                        return position;
                }
            }

            return ServerMgr.FindSpawnPoint().pos;
        }
        
        private void CreateMonumentHordeOrders()
        {
            int count = 0;
            GameObject[] allobjects = UnityEngine.Object.FindObjectsOfType<GameObject>();
            foreach (GameObject gobject in allobjects)
            {
                if (count >= configData.Horde.MaximumHordes)
                    break;

                if (gobject.name.Contains("autospawn/monument"))
                {
                    Transform tr = gobject.transform;
                    Vector3 position = tr.position;

                    if (position == Vector3.zero)
                        continue;

                    if (gobject.name.Contains("powerplant_1") && configData.Monument.Powerplant.Enabled)
                    {
                        HordeManager.Order.CreateOrder(tr.TransformPoint(new Vector3(-30.8f, 0.2f, -15.8f)), configData.Monument.Powerplant);
                        count++;
                        continue;
                    }

                    if (gobject.name.Contains("military_tunnel_1") && configData.Monument.Tunnels.Enabled)
                    {
                        HordeManager.Order.CreateOrder(tr.TransformPoint(new Vector3(-7.4f, 13.4f, 53.8f)), configData.Monument.Tunnels);
                        count++;
                        continue;
                    }

                    if (gobject.name.Contains("harbor_1") && configData.Monument.LargeHarbor.Enabled)
                    {
                        HordeManager.Order.CreateOrder(tr.TransformPoint(new Vector3(54.7f, 5.1f, -39.6f)), configData.Monument.LargeHarbor);
                        count++;
                        continue;
                    }

                    if (gobject.name.Contains("harbor_2") && configData.Monument.SmallHarbor.Enabled)
                    {
                        HordeManager.Order.CreateOrder(tr.TransformPoint(new Vector3(-66.6f, 4.9f, 16.2f)), configData.Monument.SmallHarbor);
                        count++;
                        continue;
                    }

                    if (gobject.name.Contains("airfield_1") && configData.Monument.Airfield.Enabled)
                    {
                        HordeManager.Order.CreateOrder(tr.TransformPoint(new Vector3(-12.4f, 0.2f, -28.9f)), configData.Monument.Airfield);
                        count++;
                        continue;
                    }

                    if (gobject.name.Contains("trainyard_1") && configData.Monument.Trainyard.Enabled)
                    {
                        HordeManager.Order.CreateOrder(tr.TransformPoint(new Vector3(35.8f, 0.2f, -0.8f)), configData.Monument.Trainyard);
                        count++;
                        continue;
                    }

                    if (gobject.name.Contains("water_treatment_plant_1") && configData.Monument.WaterTreatment.Enabled)
                    {
                        HordeManager.Order.CreateOrder(tr.TransformPoint(new Vector3(11.1f, 0.3f, -80.2f)), configData.Monument.WaterTreatment);
                        count++;
                        continue;
                    }

                    if (gobject.name.Contains("warehouse") && configData.Monument.Warehouse.Enabled)
                    {
                        HordeManager.Order.CreateOrder(tr.TransformPoint(new Vector3(16.6f, 0.1f, -7.5f)), configData.Monument.Warehouse);
                        count++;
                        continue;
                    }

                    if (gobject.name.Contains("satellite_dish") && configData.Monument.Satellite.Enabled)
                    {
                        HordeManager.Order.CreateOrder(tr.TransformPoint(new Vector3(18.6f, 6.0f, -7.5f)), configData.Monument.Satellite);
                        count++;
                        continue;
                    }

                    if (gobject.name.Contains("sphere_tank") && configData.Monument.Dome.Enabled)
                    {
                        HordeManager.Order.CreateOrder(tr.TransformPoint(new Vector3(1518.7f, -11.4f, 175.4f)), configData.Monument.Dome);
                        count++;
                        continue;
                    }

                    if (gobject.name.Contains("radtown_small_3") && configData.Monument.Radtown.Enabled)
                    {
                        HordeManager.Order.CreateOrder(tr.TransformPoint(new Vector3(-16.3f, -2.1f, -3.3f)), configData.Monument.Radtown);
                        count++;
                        continue;
                    }

                    if (gobject.name.Contains("launch_site_1") && configData.Monument.LaunchSite.Enabled)
                    {
                        HordeManager.Order.CreateOrder(tr.TransformPoint(new Vector3(222.1f, 3.3f, 0.0f)), configData.Monument.LaunchSite);
                        count++;
                        continue;
                    }

                    if (gobject.name.Contains("gas_station_1") && configData.Monument.GasStation.Enabled)
                    {
                        HordeManager.Order.CreateOrder(tr.TransformPoint(new Vector3(-9.8f, 3.0f, 7.2f)), configData.Monument.GasStation);
                        count++;
                        continue;
                    }

                    if (gobject.name.Contains("supermarket_1") && configData.Monument.Supermarket.Enabled)
                    {
                        HordeManager.Order.CreateOrder(tr.TransformPoint(new Vector3(5.5f, 0.0f, -20.5f)), configData.Monument.Supermarket);
                        count++;
                        continue;
                    }

                    if (gobject.name.Contains("mining_quarry_c") && configData.Monument.HQMQuarry.Enabled)
                    {
                        HordeManager.Order.CreateOrder(tr.TransformPoint(new Vector3(15.8f, 4.5f, -1.5f)), configData.Monument.HQMQuarry);
                        count++;
                        continue;
                    }

                    if (gobject.name.Contains("mining_quarry_a") && configData.Monument.SulfurQuarry.Enabled)
                    {
                        HordeManager.Order.CreateOrder(tr.TransformPoint(new Vector3(-0.8f, 0.6f, 11.4f)), configData.Monument.SulfurQuarry);
                        count++;
                        continue;
                    }

                    if (gobject.name.Contains("mining_quarry_b") && configData.Monument.StoneQuarry.Enabled)
                    {
                        HordeManager.Order.CreateOrder(tr.TransformPoint(new Vector3(-7.6f, 0.2f, 12.3f)), configData.Monument.StoneQuarry);
                        count++;
                        continue;
                    }

                    if (gobject.name.Contains("junkyard_1") && configData.Monument.Junkyard.Enabled)
                    {
                        HordeManager.Order.CreateOrder(tr.TransformPoint(new Vector3(12.8f, 10.8f, -58.4f)), configData.Monument.Junkyard);
                        count++;
                        continue;
                    }
                }
            }
        }

        private void CreateRandomHordes()
        {
            int amountToCreate = configData.Horde.MaximumHordes - HordeManager._allHordes.Count;
            for (int i = 0; i < amountToCreate; i++)
            {
                float roamDistance = configData.Horde.LocalRoam ? configData.Horde.RoamDistance : -1;
                string profile = configData.Horde.UseProfiles ? configData.HordeProfiles.Keys.ToArray().GetRandom() : string.Empty;

                HordeManager.Order.CreateOrder(GetSpawnPoint(), configData.Horde.InitialMemberCount, configData.Horde.MaximumMemberCount, roamDistance, profile);
            }
        }
        #endregion

        #region Inventory and Loot
        private ItemDefinition _blueprintBase;

        private ItemDefinition _glowEyes;

        private static MurdererDefinition _defaultDefinition;
        private static MurdererDefinition DefaultDefinition
        {
            get
            {
                if (_defaultDefinition == null)
                    _defaultDefinition = GameManager.server.FindPrefab(SCARECROW_PREFAB).GetComponent<HTNPlayer>().AiDefinition as MurdererDefinition;
                return _defaultDefinition;
            }
        }

        private void ValidateLoadoutProfiles()
        {
            Puts("Validating horde profiles...");

            bool hasChanged = false;

            for (int i = configData.HordeProfiles.Count - 1; i >= 0; i--)
            {
                string key = configData.HordeProfiles.ElementAt(i).Key;

                for (int y = configData.HordeProfiles[key].Count - 1; y >= 0; y--)
                {
                    string loadoutId = configData.HordeProfiles[key][y];

                    if (!configData.Member.Loadouts.Any(x => x.LoadoutID == loadoutId))
                    {
                        Puts($"Loadout profile {loadoutId} does not exist. Removing from config");
                        configData.HordeProfiles[key].Remove(loadoutId);
                        hasChanged = true;
                    }
                }

                if (configData.HordeProfiles[key].Count <= 0)
                {
                    Puts($"Horde profile {key} does not have any valid loadouts. Removing from config");
                    configData.HordeProfiles.Remove(key);
                    hasChanged = true;
                }
            }

            foreach (ConfigData.MemberOptions.Loadout loadout in configData.Member.Loadouts)
            {
                if (loadout.Vitals == null)
                {
                    loadout.Vitals = new ConfigData.MemberOptions.Loadout.VitalStats() { Health = DefaultDefinition.Vitals.HP };
                    hasChanged = true;
                }

                if (loadout.Movement == null)
                {
                    loadout.Movement = new ConfigData.MemberOptions.Loadout.MovementStats()
                    {
                        Acceleration = DefaultDefinition.Movement.Acceleration,
                        DuckSpeed = DefaultDefinition.Movement.DuckSpeed,
                        RunSpeed = DefaultDefinition.Movement.RunSpeed,
                        TurnSpeed = DefaultDefinition.Movement.TurnSpeed,
                        WalkSpeed = DefaultDefinition.Movement.WalkSpeed
                    };
                    hasChanged = true;
                }

                if (loadout.Sensory == null)
                {
                    loadout.Sensory = new ConfigData.MemberOptions.Loadout.SensoryStats()
                    {
                        FOV = DefaultDefinition.Sensory.FieldOfView,
                        HearingRange = DefaultDefinition.Sensory.HearingRange,
                        VisionRange = DefaultDefinition.Sensory.VisionRange
                    };
                    hasChanged = true;
                }
            }

            if (hasChanged)
                SaveConfig();
        }

        private void SpawnIntoContainer(LootableCorpse lootableCorpse)
        {
            int count = UnityEngine.Random.Range(configData.Loot.Random.Minimum, configData.Loot.Random.Maximum);

            int spawnedCount = 0;
            int loopCount = 0;

            while (true)
            {
                loopCount++;

                if (loopCount > 3)
                    return;

                float probability = UnityEngine.Random.Range(0f, 1f);

                List<ConfigData.LootTable.RandomLoot.LootDefinition> definitions = new List<ConfigData.LootTable.RandomLoot.LootDefinition>(configData.Loot.Random.List);

                for (int i = 0; i < configData.Loot.Random.List.Count; i++)
                {
                    ConfigData.LootTable.RandomLoot.LootDefinition lootDefinition = definitions.GetRandom();

                    definitions.Remove(lootDefinition);

                    if (lootDefinition.Probability >= probability)
                    {
                        CreateItem(lootDefinition, lootableCorpse.containers[0]);

                        spawnedCount++;

                        if (spawnedCount >= count)
                            return;
                    }
                }
            }
        }

        private void CreateItem(ConfigData.LootTable.RandomLoot.LootDefinition lootDefinition, ItemContainer container)
        {
            Item item;

            if (!lootDefinition.IsBlueprint)
                item = ItemManager.CreateByName(lootDefinition.Shortname, lootDefinition.GetAmount(), lootDefinition.SkinID);
            else
            {
                item = ItemManager.Create(_blueprintBase);
                item.blueprintTarget = ItemManager.FindItemDefinition(lootDefinition.Shortname).itemid;
            }

            if (item != null)
            {
                item.OnVirginSpawn();
                if (!item.MoveToContainer(container, -1, true))
                    item.Remove(0f);
            }

            if (lootDefinition.Required != null)
                CreateItem(lootDefinition.Required, container);
        }

        private static void StripInventory(BasePlayer player, bool skipWear = false)
        {
            List<Item> list = Pool.GetList<Item>();

            player.inventory.AllItemsNoAlloc(ref list);

            for (int i = list.Count - 1; i >= 0; i--)
            {
                Item item = list[i];

                if (skipWear && item?.parent == player.inventory.containerWear)
                    continue;

                item.RemoveFromContainer();
                item.Remove();
            }

            Pool.FreeList(ref list);
        }

        private static void ClearContainer(ItemContainer container, bool skipWear = false)
        {
            if (container == null || container.itemList == null)
                return;

            while (container.itemList.Count > 0)
            {
                Item item = container.itemList[0];
                item.RemoveFromContainer();
                item.Remove(0f);
            }
        }        
        #endregion

        #region Spawning
        private static HTNPlayer InstantiateEntity(Vector3 position)
        {
            GameObject gameObject = Instantiate.GameObject(GameManager.server.FindPrefab(SCARECROW_PREFAB), position, Quaternion.identity);
            gameObject.name = SCARECROW_PREFAB;

            UnityEngine.SceneManagement.SceneManager.MoveGameObjectToScene(gameObject, Rust.Server.EntityScene);

            UnityEngine.Object.Destroy(gameObject.GetComponent<Spawnable>());

            if (!gameObject.activeSelf)
                gameObject.SetActive(true);

            HTNPlayer component = gameObject.GetComponent<HTNPlayer>();
            return component;
        }

        private static NavMeshHit navHit;
        private static RaycastHit raycastHit;
        private static Collider[] _buffer = new Collider[256];

        private static object FindPointOnNavmesh(Vector3 targetPosition, float maxDistance = 4f)
        {
            for (int i = 0; i < 10; i++)
            {
                Vector3 position = i == 0 ? targetPosition : targetPosition + (UnityEngine.Random.onUnitSphere * maxDistance);
                if (NavMesh.SamplePosition(position, out navHit, maxDistance, 1))
                {
                    if (IsInRockPrefab(navHit.position))                    
                        continue;                    

                    if (IsNearWorldCollider(navHit.position))                    
                        continue;  

                    return navHit.position;
                }
            }
            return null;
        } 

        private static bool IsInRockPrefab(Vector3 position)
        {
            Physics.queriesHitBackfaces = true;

            bool isInRock = Physics.Raycast(position, Vector3.up, out raycastHit, 20f, WORLD_LAYER, QueryTriggerInteraction.Ignore) && 
                            blockedColliders.Any(s => raycastHit.collider?.gameObject?.name.Contains(s) ?? false);

            Physics.queriesHitBackfaces = false;

            return isInRock;
        }

        private static bool IsNearWorldCollider(Vector3 position)
        {
            Physics.queriesHitBackfaces = true;

            int count = Physics.OverlapSphereNonAlloc(position, 2f, _buffer, WORLD_LAYER, QueryTriggerInteraction.Ignore);
            Physics.queriesHitBackfaces = false;

            int removed = 0;
            for (int i = 0; i < count; i++)
            {                
                if (acceptedColliders.Any(s => _buffer[i].gameObject.name.Contains(s)))
                  removed++;
            }


            return count - removed > 0;
        }

        private static readonly string[] acceptedColliders = new string[] { "road", "rocket_factory", "range", "train_track", "runway", "_grounds", "concrete_slabs", "lighthouse", "cave", "office", "walkways", "sphere", "tunnel", "industrial", "junkyard" };

        private static readonly string[] blockedColliders = new string[] { "rock", "junk", "range", "invisible" };
        #endregion

        private T ParseType<T>(string type)
        {
            try
            {
                return (T)Enum.Parse(typeof(T), type, true);
            }
            catch
            {
                return default(T);
            }
        }

        private static bool ContainsTopologyAtPoint(TerrainTopology.Enum mask, Vector3 position) => (TerrainMeta.TopologyMap.GetTopology(position) & (int)mask) != 0;
        #endregion

        #region Think Manager
        private HordeThinkManager _hordeThinkManager;

        private static SpawnState _spawnState = SpawnState.Spawn;


        private class HordeThinkManager : MonoBehaviour
        {
            internal static void Create() => Instance._hordeThinkManager = new GameObject("ZombieHorde-ThinkManager").AddComponent<HordeThinkManager>();

            private void Awake()
            {
                _spawnState = configData.TimedSpawns.Enabled ? (ShouldSpawn() ? SpawnState.Spawn : SpawnState.Despawn) : SpawnState.Spawn;

                if (configData.TimedSpawns.Enabled)
                    InvokeHandler.InvokeRepeating(this, CheckTimeTick, 0f, 1f);
            }

            internal void Update()
            {
                HordeManager._hordeTickQueue.RunQueue(0.5);
                HordeMember._memberTickQueue.RunQueue(0.5);
            }

            internal void Destroy()
            {
                if (configData.TimedSpawns.Enabled)
                    InvokeHandler.CancelInvoke(this, CheckTimeTick);

                Destroy(gameObject);
            }

            private bool ShouldSpawn()
            {
                float currentTime = TOD_Sky.Instance.Cycle.Hour;

                if (configData.TimedSpawns.Start > configData.TimedSpawns.End)
                    return currentTime > configData.TimedSpawns.Start || currentTime < configData.TimedSpawns.End;
                else return currentTime > configData.TimedSpawns.Start && currentTime < configData.TimedSpawns.End;
            }
                         
            private void CheckTimeTick()
            {
                if (ShouldSpawn())
                {
                    if (_spawnState == SpawnState.Despawn)
                    {
                        _spawnState = SpawnState.Spawn;
                        HordeManager.Order.StopDespawning();
                        HordeManager.Order.BeginSpawning();
                    }
                }
                else
                {
                    if (_spawnState == SpawnState.Spawn)
                    {
                        _spawnState = SpawnState.Despawn;

                        if (configData.TimedSpawns.Despawn)
                        {
                            HordeManager.Order.StopSpawning();
                            HordeManager.Order.BeginDespawning();
                        }
                    }
                }
            }
        }

        internal class HordeMemberTickQueue : ObjectWorkQueue<HordeMember>
        {
            protected override void RunJob(HordeMember hordeMember)
            {
                if (!ShouldAdd(hordeMember))
                    return;

                hordeMember.OnTick();
            }

            protected override bool ShouldAdd(HordeMember hordeMember)
            {
                if (!base.ShouldAdd(hordeMember))
                    return false;

                return hordeMember != null && hordeMember.Entity != null && hordeMember.Entity.IsValid();
            }
        }

        internal class HordeTickQueue : ObjectWorkQueue<HordeManager>
        {
            protected override void RunJob(HordeManager hordeManager)
            {
                if (!ShouldAdd(hordeManager))
                    return;

                hordeManager.HordeTick();
                
                Instance.timer.In(3f, ()=> HordeManager._hordeTickQueue.Add(hordeManager));
            }

            protected override bool ShouldAdd(HordeManager hordeManager)
            {
                if (!base.ShouldAdd(hordeManager))
                    return false;

                return hordeManager != null && !hordeManager.isDestroyed && hordeManager.members?.Count > 0;
            }
        }
        #endregion

        #region Horde Manager
        internal class HordeManager
        {
            internal static List<HordeManager> _allHordes = new List<HordeManager>();

            internal static HordeTickQueue _hordeTickQueue = new HordeTickQueue();

            internal List<HordeMember> members;

            internal Vector3 Destination;

            internal Vector3 AverageLocation;


            internal BaseCombatEntity PrimaryTarget;

            internal NpcPlayerInfo NpcPlayerInfo;

            internal AnimalInfo AnimalInfo;


            internal bool DebugMode { get; set; } = false;


            private bool isRoaming = true;

            private bool isRegrouping = false;

            internal bool isDestroyed = false;


            private Vector3 initialSpawnPosition;

            private int initialMemberCount;

            private bool isLocalHorde = false;

            private float maximumRoamDistance;

            internal string hordeProfile;


            private float nextGrowthTime = Time.time + configData.Horde.GrowthRate;

            private int maximumMemberCount;

            private float nextMergeTime = Time.time + MERGE_COOLDOWN;

            private float refreshRoamTime;

            private float verifyTargetTime;

            internal bool PathStateFailed { get; set; }


            private const float MERGE_COOLDOWN = 180f;

            private const float ROAM_REFRESH_RATE = 1f;

            private const float TARGET_VERIFY_RATE = 3f;


            internal static bool Create(Order order)
            {
                HordeManager manager = new HordeManager
                {
                    members = Pool.GetList<HordeMember>(),
                    initialSpawnPosition = order.position,
                    isLocalHorde = order.maximumRoamDistance > 0,
                    maximumRoamDistance = order.maximumRoamDistance,
                    initialMemberCount = order.initialMemberCount,
                    maximumMemberCount = order.maximumMemberCount,
                    hordeProfile = order.hordeProfile
                };                  

                for (int i = 0; i < order.initialMemberCount; i++)                
                    manager.SpawnMember(order.position, false);

                if (manager.members.Count == 0)
                {
                    manager.Destroy();
                    return false;
                }

                _allHordes.Add(manager);

                _hordeTickQueue.Add(manager);

                return true;
            }

            internal void Destroy(bool permanent = false, bool killNpcs = false)
            {
                isDestroyed = true;

                if (killNpcs)
                {
                    for (int i = members.Count - 1; i >= 0; i--)
                    {
                        HordeMember hordeMember = members[i];
                        if (hordeMember != null && hordeMember.Entity != null && !hordeMember.Entity.IsDestroyed)
                        {
                            StripInventory(hordeMember.Entity);
                            hordeMember.Entity.Kill();
                        }
                    }
                }

                members.Clear();
                Pool.FreeList(ref members);

                _allHordes.Remove(this);

                if (!permanent && _allHordes.Count <= configData.Horde.MaximumHordes)                
                    InvokeHandler.Invoke(Instance._hordeThinkManager, () => 
                    Order.CreateOrder(isLocalHorde ? initialSpawnPosition : Instance.GetSpawnPoint(), initialMemberCount, maximumMemberCount, isLocalHorde ? maximumRoamDistance : -1f, hordeProfile), configData.Horde.RespawnTime);                
            }

            internal void HordeTick()
            {
                if (members.Count == 0 || isDestroyed)                
                    return;

                if (DebugMode)
                {
                    foreach(BasePlayer player in BasePlayer.activePlayerList)
                    {
                        if (player.IsAdmin)
                            player.SendConsoleCommand("ddraw.text", 10f, Color.green, AverageLocation + new Vector3(0, 1.5f, 0), $"<size=20>Horde {_allHordes.IndexOf(this)}</size>");
                    }
                }
                
                bool hasSeentargetRecently = false;
                bool isDormant = true;

                for (int i = members.Count - 1; i >= 0; i--)
                {
                    HordeMember member = members[i];

                    if (!member.Entity.IsDormant)
                        isDormant = false;

                    if (!isRoaming && !hasSeentargetRecently)
                    {
                        if (Time.time - member.lastSeenTargetTime < configData.Horde.ForgetTime)
                        {
                            hasSeentargetRecently = true;

                            if (PrimaryTarget != null)                            
                                Destination = PrimaryTarget.ServerPosition;                            
                        }
                    }
                }

                if (isDormant)
                    return;

                AverageLocation = GetAverageVector();

                TryMergeHordes();

                TryGrowHorde();

                bool hasValidTarget = PrimaryTarget != null && IsValidTarget(PrimaryTarget);

                if (hasSeentargetRecently && Time.time > verifyTargetTime)
                {
                    verifyTargetTime = Time.time + TARGET_VERIFY_RATE;
                    if (!hasValidTarget)
                    {
                        if (DebugMode)
                            Debug.Log($"Target is invalid, set roaming");
                        hasSeentargetRecently = false;
                        SetPrimaryTarget(null);
                    }
                }

                if (!isRoaming && !hasSeentargetRecently)
                {
                    if (DebugMode)
                        Debug.Log($"No targets, set roaming");

                    isRoaming = true;
                }

                if (isRoaming)
                {
                    if (Time.time > refreshRoamTime)
                    {
                        refreshRoamTime = Time.time + ROAM_REFRESH_RATE;

                        if ((!isRegrouping && GetMaximumSeperation() > 15f) || (isRegrouping && GetMaximumSeperation() > 5))
                        {                            
                            isRegrouping = true;

                            Destination = members.GetRandom().Transform.position;

                            if (DebugMode)
                                Debug.Log($"Regroup at {Destination}");

                            goto UPDATE_ROAM;
                        }

                        if (Destination == Vector3.zero || Vector3.Distance(Destination, AverageLocation) < 10f || members.All(x => x.Domain.NavAgent.isPathStale))
                        {                            
                            isRegrouping = false;

                            Destination = GetRandomLocation(isLocalHorde ? initialSpawnPosition : AverageLocation);
                           
                            if (DebugMode)
                                Debug.Log($"Set new destination at {Destination}");

                            goto UPDATE_ROAM;
                        }

                        if (PathStateFailed)
                        {
                            Destination = GetRandomLocation(isLocalHorde ? initialSpawnPosition : AverageLocation);
                            PathStateFailed = false;

                            if (DebugMode)
                                Debug.Log($"Path has failed. New destination {Destination}");
                        }

                        UPDATE_ROAM:
                        if (DebugMode)
                            Debug.Log($"Update roam target | Current {AverageLocation} | Destination {Destination} | Distance {Vector3.Distance(AverageLocation, Destination)}");
                        UpdateRoamTarget();
                    }
                }
            }

            internal void EvaluateTarget(NpcPlayerInfo target)
            {
                if (target.Player == null || target.Player.IsDead() || target.Player.transform == null || PrimaryTarget == target.Player)
                    return;

                if (PrimaryTarget == null || PrimaryTarget.IsDead())
                {
                    SetPrimaryTarget(target.Player, target);
                    return;
                }

                if (PrimaryTarget.transform == null)
                    return;

                if (Vector3.Distance(AverageLocation, target.Player.transform.position) < Vector3.Distance(AverageLocation, PrimaryTarget.transform.position) || PrimaryTarget is BaseNpc)
                {
                    SetPrimaryTarget(target.Player, target);
                    return;
                }
            }

            internal void EvaluateTarget(AnimalInfo target)
            {
                if (target.Animal == null || target.Animal.IsDead() || target.Animal.transform == null || PrimaryTarget == target.Animal)
                    return;

                if (PrimaryTarget == null || PrimaryTarget.IsDead())
                {
                    SetPrimaryTarget(target.Animal, target);
                    return;
                }

                if (PrimaryTarget.transform == null || PrimaryTarget is BasePlayer)
                    return;

                if (Vector3.Distance(AverageLocation, target.Animal.transform.position) < Vector3.Distance(AverageLocation, PrimaryTarget.transform.position))
                {
                    SetPrimaryTarget(target.Animal, target);
                    return;
                }
            }

            internal void SetPrimaryTarget(BaseCombatEntity baseCombatEntity, NpcPlayerInfo info)
            {
                if (baseCombatEntity == null || baseCombatEntity.transform == null)
                    return;

                SetPrimaryTarget(baseCombatEntity);

                PrimaryTarget = baseCombatEntity;

                NpcPlayerInfo = info;

                AnimalInfo = default(AnimalInfo);

                for (int i = 0; i < members.Count; i++)
                {
                    members[i].OnTargetUpdated(info);
                }
            }

            internal void SetPrimaryTarget(BaseCombatEntity baseCombatEntity, AnimalInfo info)
            {
                if (baseCombatEntity == null || baseCombatEntity.transform == null)
                    return;

                SetPrimaryTarget(baseCombatEntity);

                PrimaryTarget = baseCombatEntity;

                NpcPlayerInfo = default(NpcPlayerInfo);

                AnimalInfo = info;

                for (int i = 0; i < members.Count; i++)
                {
                    members[i].OnTargetUpdated(info);
                }
            }

            internal void SetPrimaryTarget(BaseCombatEntity baseCombatEntity)
            {
                if (baseCombatEntity == null || baseCombatEntity.transform == null)
                {
                    NpcPlayerInfo = default(NpcPlayerInfo);
                    AnimalInfo = default(AnimalInfo);
                    isRoaming = true;
                    Destination = AverageLocation;
                }
                else
                {
                    isRoaming = false;
                    isRegrouping = false;
                    Destination = baseCombatEntity.transform.position;
                }
            }

            private void UpdateRoamTarget()
            {
                for (int i = 0; i < members.Count; i++)
                {
                    HordeMember hordeMember = members[i];
                    if (hordeMember != null)
                        hordeMember.SetRoamToDestination();
                }
            }

            internal Vector3 GetAverageVector()
            {
                Vector3 location = Vector3.zero;

                if (members.Count == 0)
                    return location;

                int count = 0;
                for (int i = 0; i < members.Count; i++)
                {
                    HordeMember hordeMember = members[i];

                    if (hordeMember == null || hordeMember.Entity == null)
                        continue;

                    location += hordeMember.Transform.position;
                    count++;
                }

                return location /= count;
            }

            
            private const TerrainTopology.Enum DESTINATION_TOPOLOGY_MASK = (TerrainTopology.Enum.Ocean | TerrainTopology.Enum.River | TerrainTopology.Enum.Lake | TerrainTopology.Enum.Offshore | TerrainTopology.Enum.Cliff);

            private Vector3 GetRandomLocation(Vector3 from)
            {
                for (int i = 0; i < 10; i++)
                {
                    Vector2 vector2 = UnityEngine.Random.insideUnitCircle * (isLocalHorde ? maximumRoamDistance : 100f);
                    
                    Vector3 destination = from + new Vector3(vector2.x, 0f, vector2.y);
                    if (TerrainMeta.HeightMap != null)                    
                        destination.y = TerrainMeta.HeightMap.GetHeight(destination);

                    NavMeshHit navMeshHit;
                    if (NavMesh.FindClosestEdge(destination, out navMeshHit, 1))
                    {
                        destination = navMeshHit.position;
                        if (WaterLevel.GetWaterDepth(destination, true, null) <= 0.01f && !ContainsTopologyAtPoint(DESTINATION_TOPOLOGY_MASK, destination))                                                    
                            return destination;                        
                    }
                    else if (NavMesh.SamplePosition(destination, out navMeshHit, 5f, 1) && !ContainsTopologyAtPoint(DESTINATION_TOPOLOGY_MASK, destination))
                    {                        
                        destination = navMeshHit.position;
                        if (WaterLevel.GetWaterDepth(destination, true, null) <= 0.01f)
                            return destination;                        
                    }
                }
                return AverageLocation;
            }

            private float GetMaximumSeperation()
            {
                float distance = 0;

                for (int i = 0; i < members.Count; i++)
                {
                    HordeMember hordeMember = members[i];
                    if (hordeMember != null && hordeMember.Entity != null)
                    {
                        float d = Vector3.Distance(hordeMember.Transform.position, AverageLocation);
                        if (d > distance)
                            distance = d;
                    }
                }

                return distance;
            }

            internal bool IsValidTarget(BaseCombatEntity baseCombatEntity)
            {
                if (baseCombatEntity == null || baseCombatEntity.IsDestroyed || baseCombatEntity.transform == null)
                    return false;

                if (baseCombatEntity.Health() <= 0f)
                    return false;

                if (baseCombatEntity is BasePlayer)
                {
                    BasePlayer player = baseCombatEntity as BasePlayer;

                    if (player.IsDead())
                        return false;

                    if (player._limitedNetworking)
                        return false;

                    if (player.IsFlying)
                        return false;

                    if (player is HTNPlayer && (player as HTNPlayer).AiDefinition?.Info?.Family == BaseNpcDefinition.Family.Murderer)
                        return false;

                    if (!configData.Member.TargetNPCs)
                    {
                        if (player.IsNpc)
                            return false;

                        if (player is NPCPlayer || player is HTNPlayer)
                            return false;
                    }

                    if (!configData.Member.TargetHumanNPCs && !player.userID.IsSteamId() && !player.IsNpc)
                        return false;

                    if (player.HasPlayerFlag(BasePlayer.PlayerFlags.SafeZone))
                        return false;

                    if (configData.Member.IgnoreSleepers && player.IsSleeping())
                        return false;

                    if (player.userID.IsSteamId() && Instance.permission.UserHasPermission(player.UserIDString, "zombiehorde.ignore"))
                        return false;
                }

                return true;
            }

            internal bool SpawnMember(Vector3 position, bool alreadyInitialized = true)
            {                
                HTNPlayer htnPlayer = InstantiateEntity(position);                
                htnPlayer.enableSaving = false;
                htnPlayer.Spawn();

                HordeMember member = htnPlayer.gameObject.AddComponent<HordeMember>();
                member.Manager = this;
                members.Add(member);

                if (alreadyInitialized)
                {
                    if (PrimaryTarget == null || PrimaryTarget is BasePlayer)
                        member.OnTargetUpdated(NpcPlayerInfo);
                    else if (PrimaryTarget is BaseNpc)
                        member.OnTargetUpdated(AnimalInfo);
                }

                return true;
            }

            internal void OnPlayerDeath(BasePlayer player, HordeMember hordeMember)
            {
                if (hordeMember == null || !members.Contains(hordeMember))
                    return;

                if (members.Count < maximumMemberCount)
                    SpawnMember(hordeMember.Transform.position);
            }

            internal void OnMemberDeath(HordeMember hordeMember, BaseCombatEntity initiator)
            {
                if (isDestroyed || members == null)
                    return;

                members.Remove(hordeMember);

                if (members.Count == 0)
                    Destroy();
                else
                {
                    if (PrimaryTarget == null && initiator is BasePlayer)
                    {
                        SetPrimaryTarget(initiator, new NpcPlayerInfo()
                        {
                            Player = initiator as BasePlayer,
                            Time = Time.time,
                            SqrDistance = (initiator.transform.position - AverageLocation).sqrMagnitude,
                            BodyVisible = true,
                            HeadVisible = true,
                        });
                    }
                }
            }

            private void TryGrowHorde()
            {
                if (nextGrowthTime < Time.time)
                {
                    if (members.Count < maximumMemberCount)
                    {
                        for (int i = 0; i < 5; i++)
                        {
                            if (SpawnMember(members.GetRandom().Transform.position))
                                break;
                        }
                    }

                    nextGrowthTime = Time.time + configData.Horde.GrowthRate;
                }
            }

            private void TryMergeHordes()
            {
                if (!configData.Horde.MergeHordes || nextMergeTime > Time.time)
                    return;

                for (int y = _allHordes.Count - 1; y >= 0; y--)
                {
                    HordeManager manager = _allHordes[y];

                    if (manager == this)
                        continue;

                    if (members.Count >= maximumMemberCount)
                        return;

                    if (Vector3.Distance(AverageLocation, manager.AverageLocation) < 20)
                    {
                        int amountToMerge = maximumMemberCount - members.Count;
                        if (amountToMerge >= manager.members.Count)
                        {
                            for (int i = 0; i < manager.members.Count; i++)
                            {
                                HordeMember member = manager.members[i];
                                members.Add(member);
                                member.Manager = this;
                            }

                            manager.members.Clear();
                            manager.Destroy();

                            nextMergeTime = Time.time + MERGE_COOLDOWN;
                        }
                        else
                        {
                            bool hasMerged = false;
                            for (int i = 0; i < amountToMerge; i++)
                            {
                                if (manager.members.Count > 0)
                                {
                                    HordeMember member = manager.members[0];

                                    members.Add(member);

                                    member.Manager = this;

                                    manager.members.Remove(member);

                                    hasMerged = true;
                                }
                            }

                            if (hasMerged)                            
                                nextMergeTime = Time.time + MERGE_COOLDOWN;                            
                        }
                    }
                }
            }

            public class Order
            {
                public Vector3 position;
                public int initialMemberCount;
                public int maximumMemberCount;
                public float maximumRoamDistance;
                public string hordeProfile;

                public Order(Vector3 position, int initialMemberCount, string hordeProfile)
                {
                    this.position = position;
                    this.initialMemberCount = initialMemberCount;
                    maximumMemberCount = configData.Horde.MaximumMemberCount;
                    maximumRoamDistance = -1f;
                    this.hordeProfile = hordeProfile;
                }

                public Order(Vector3 position, int initialMemberCount, int maximumMemberCount, float maximumRoamDistance, string hordeProfile)
                {
                    this.position = position;
                    this.initialMemberCount = initialMemberCount;
                    this.maximumMemberCount = maximumMemberCount;
                    this.maximumRoamDistance = maximumRoamDistance;
                    this.hordeProfile = hordeProfile;
                }

                //private static WaitUntil waitUntilFinishedSpawning = new WaitUntil(() => IsSpawning == false);

                //private static WaitUntil waitUntilFinishedDespawning = new WaitUntil(() => IsDespawning == false);


                private static Queue<Order> _queue = new Queue<Order>();

                private static bool IsSpawning { get; set; }

                private static bool IsDespawning { get; set; }

                private static Coroutine SpawnRoutine { get; set; }

                private static Coroutine DespawnRoutine { get; set; }

                internal static void CreateOrder(Vector3 position, int initialMemberCount, int maximumMemberCount, float maximumRoamDistance, string hordeProfile)
                {
                    object success = FindPointOnNavmesh(position, 10f);
                    if (success == null)
                        return;

                    _queue.Enqueue(new Order((Vector3)success, initialMemberCount, maximumMemberCount, maximumRoamDistance, hordeProfile));

                    if (!IsSpawning && _spawnState == SpawnState.Spawn)                    
                        BeginSpawning();                    
                }

                internal static void CreateOrder(Vector3 position, ConfigData.MonumentSpawn.MonumentSettings settings)
                {
                    object success = FindPointOnNavmesh(position, 10f);
                    if (success == null)                    
                        return;
                    
                    _queue.Enqueue(new Order((Vector3)success, configData.Horde.InitialMemberCount, settings.HordeSize, settings.RoamDistance, settings.Profile));

                    if (!IsSpawning && _spawnState == SpawnState.Spawn)
                        BeginSpawning();
                }

                internal static Coroutine BeginSpawning() => SpawnRoutine = ServerMgr.Instance.StartCoroutine(ProcessSpawnOrders());

                internal static Coroutine BeginDespawning() => DespawnRoutine = ServerMgr.Instance.StartCoroutine(ProcessDespawn());   
                
                internal static void StopSpawning()
                {
                    if (SpawnRoutine != null)
                        ServerMgr.Instance.StopCoroutine(SpawnRoutine);

                    IsSpawning = false;
                }

                internal static void StopDespawning()
                {
                    if (DespawnRoutine != null)
                        ServerMgr.Instance.StopCoroutine(DespawnRoutine);

                    IsDespawning = false;
                }

                private static IEnumerator ProcessSpawnOrders()
                {
                    if (_queue.Count == 0)
                        yield break;

                    IsSpawning = true;

                    RESTART:
                    if (IsDespawning)
                        StopDespawning();

                    while (_allHordes?.Count > configData.Horde.MaximumHordes)                    
                        yield return CoroutineEx.waitForSeconds(10f);
                    
                    Order order = _queue.Dequeue();

                    if (order != null)
                        Create(order);

                    if (_queue.Count > 0)
                    {
                        yield return CoroutineEx.waitForSeconds(3f);
                        goto RESTART;
                    }

                    IsSpawning = false;
                }

                private static IEnumerator ProcessDespawn()
                {
                    IsDespawning = true;

                    if (IsSpawning)
                        StopSpawning();

                    while (_allHordes?.Count > 0)
                    {
                        HordeManager manager = HordeManager._allHordes.GetRandom();
                        if (manager.PrimaryTarget == null)
                        {
                            Order.CreateOrder(manager.isLocalHorde ? manager.initialSpawnPosition : Instance.GetSpawnPoint(), manager.initialMemberCount,
                                              manager.maximumMemberCount, manager.isLocalHorde ? manager.maximumRoamDistance : -1f, manager.hordeProfile);

                            manager.Destroy(true, true);
                        }

                        yield return CoroutineEx.waitForSeconds(3f);
                    }

                    IsDespawning = false;
                }

                internal static void OnUnload()
                {
                    if (SpawnRoutine != null)
                        ServerMgr.Instance.StopCoroutine(SpawnRoutine);

                    if (DespawnRoutine != null)
                        ServerMgr.Instance.StopCoroutine(DespawnRoutine);

                    IsDespawning = false;
                    IsSpawning = false;

                   _queue.Clear();
                }
            }
        }
        #endregion

        #region Horde Member
        internal class HordeMember : MonoBehaviour
        {
            internal static HordeMemberTickQueue _memberTickQueue = new HordeMemberTickQueue();

            internal HTNPlayer Entity { get; private set; }

            internal MurdererDomain Domain { get; private set; }

            internal MurdererContext Context { get; private set; }

            internal MurdererMemory Memory { get; private set; }

            internal HordeManager Manager { get; set; }

            internal Transform Transform { get; set; }


            internal List<AnimalInfo> animalsLineOfSight = Pool.GetList<AnimalInfo>();

            internal float damageMultiplier;

            internal float lastSeenTargetTime;

            private bool lightsOn;

            private ItemContainer[] containers;

            private void Awake()
            {
                Entity = GetComponent<HTNPlayer>();

                Transform = Entity.transform;

                Domain = Entity.AiDomain as MurdererDomain;
                Context = Domain.MurdererContext;
                Memory = Context.Memory;

                InitializeSensorsAndReasoners();

                InitializeNpc();
            }

            private void OnDestroy()
            {
                Pool.Free(ref animalsLineOfSight);
            }

            private void InitializeSensorsAndReasoners()
            {
                int index = Domain.Reasoners.FindIndex(x => x is Rust.Ai.HTN.Murderer.Reasoners.ReturnHomeReasoner);
                Domain.Reasoners.RemoveAt(index);

                index = Domain.Sensors.FindIndex(x => x is Rust.Ai.HTN.Sensors.PlayersInRangeSensor);
                Domain.Sensors.RemoveAt(index);
                Domain.Sensors.Insert(index, new PlayersInRangeSensor(this));

                index = Domain.Sensors.FindIndex(x => x is Rust.Ai.HTN.Murderer.Sensors.AnimalsInRangeSensor);
                Domain.Sensors.RemoveAt(index);

                if (configData.Member.TargetAnimals)
                {
                    Domain.Sensors.Insert(index, new AnimalsInRangeSensor(this));

                    index = Domain.Reasoners.FindIndex(x => x is Rust.Ai.HTN.Murderer.Reasoners.EnemyRangeReasoner);
                    Domain.Reasoners.RemoveAt(index);
                    Domain.Reasoners.Add(new EnemyRangeReasoner(this));

                    index = Domain.Reasoners.FindIndex(x => x is Rust.Ai.HTN.Murderer.Reasoners.EnemyTargetReasoner);
                    Domain.Reasoners.RemoveAt(index);
                    Domain.Reasoners.Add(new EnemyTargetReasoner(this));

                    index = Domain.Reasoners.FindIndex(x => x is Rust.Ai.HTN.Murderer.Reasoners.EnemyPlayerLineOfSightReasoner);
                    Domain.Reasoners.RemoveAt(index);
                    Domain.Reasoners.Add(new EnemyPlayerLineOfSightReasoner(this));

                    index = Domain.Reasoners.FindIndex(x => x is Rust.Ai.HTN.Murderer.Reasoners.FireTacticReasoner);
                    Domain.Reasoners.RemoveAt(index);
                    Domain.Reasoners.Add(new FireTacticReasoner(this));

                    index = Domain.Reasoners.FindIndex(x => x is Rust.Ai.HTN.Murderer.Reasoners.PreferredFightingRangeReasoner);
                    Domain.Reasoners.RemoveAt(index);
                    Domain.Reasoners.Add(new PreferredFightingRangeReasoner(this));

                    index = Domain.Reasoners.FindIndex(x => x is Rust.Ai.HTN.Murderer.Reasoners.AtLastKnownEnemyPlayerLocationReasoner);
                    Domain.Reasoners.RemoveAt(index);
                    Domain.Reasoners.Add(new AtLastKnownEnemyPlayerLocationReasoner(this));
                }
            }

            private void InitializeNpc()
            {
                if (configData.Member.DisableDormantSystem)                
                    Rust.Ai.AiManager.Instance.HTNAgency.Remove(Entity);
                
                StripInventory(Entity); 
                Entity.Invoke(GiveLoadout, 0.1f);

                InvokeHandler.InvokeRepeating(this, ScheduleMemberUpdate, 1f, UnityEngine.Random.Range(0.1f, 0.15f));
            }

            private void GiveLoadout()
            {
                ConfigData.MemberOptions.Loadout loadout;
                if (!string.IsNullOrEmpty(Manager.hordeProfile) && configData.HordeProfiles.ContainsKey(Manager.hordeProfile))
                {
                    string loadoutId = configData.HordeProfiles[Manager.hordeProfile].GetRandom();
                    loadout = configData.Member.Loadouts.Find(x => x.LoadoutID == loadoutId);
                }
                else loadout = configData.Member.Loadouts.GetRandom();

                Entity.displayName = loadout.Names.Length > 0 ? loadout.Names.GetRandom() : "Zombie";

                Entity._aiDefinition = loadout.LoadoutDefintion;

                Entity.InitializeHealth(loadout.Vitals.Health, loadout.Vitals.Health);               

                damageMultiplier = loadout.DamageMultiplier;

                for (int i = 0; i < loadout.BeltItems.Count; i++)
                {
                    ConfigData.LootTable.InventoryItem loadoutItem = loadout.BeltItems[i];

                    Item item = ItemManager.CreateByName(loadoutItem.Shortname, loadoutItem.Amount, loadoutItem.SkinID);
                    item.MoveToContainer(Entity.inventory.containerBelt);

                    if (loadoutItem.SubSpawn != null && item.contents != null)
                    {
                        for (int y = 0; y < loadoutItem.SubSpawn.Length; y++)
                        {
                            ConfigData.LootTable.InventoryItem subspawnItem = loadoutItem.SubSpawn[y];

                            Item subItem = ItemManager.CreateByName(subspawnItem.Shortname, subspawnItem.Amount, subspawnItem.SkinID);
                            subItem.MoveToContainer(item.contents);
                        }                        
                    }
                }

                for (int i = 0; i < loadout.MainItems.Count; i++)
                {
                    ConfigData.LootTable.InventoryItem loadoutItem = loadout.MainItems[i];

                    Item item = ItemManager.CreateByName(loadoutItem.Shortname, loadoutItem.Amount, loadoutItem.SkinID);
                    item.MoveToContainer(Entity.inventory.containerMain);

                    if (loadoutItem.SubSpawn != null && item.contents != null)
                    {
                        for (int y = 0; y < loadoutItem.SubSpawn.Length; y++)
                        {
                            ConfigData.LootTable.InventoryItem subspawnItem = loadoutItem.SubSpawn[y];

                            Item subItem = ItemManager.CreateByName(subspawnItem.Shortname, subspawnItem.Amount, subspawnItem.SkinID);
                            subItem.MoveToContainer(item.contents);
                        }
                    }
                }

                for (int i = 0; i < loadout.WearItems.Count; i++)
                {
                    ConfigData.LootTable.InventoryItem loadoutItem = loadout.WearItems[i];

                    Item item = ItemManager.CreateByName(loadoutItem.Shortname, loadoutItem.Amount, loadoutItem.SkinID);
                    item.MoveToContainer(Entity.inventory.containerWear);

                    if (loadoutItem.SubSpawn != null && item.contents != null)
                    {
                        for (int y = 0; y < loadoutItem.SubSpawn.Length; y++)
                        {
                            ConfigData.LootTable.InventoryItem subspawnItem = loadoutItem.SubSpawn[y];

                            Item subItem = ItemManager.CreateByName(subspawnItem.Shortname, subspawnItem.Amount, subspawnItem.SkinID);
                            subItem.MoveToContainer(item.contents);
                        }
                    }
                }

                Entity.InvokeRandomized(LightCheck, 5f, 30f, 5f);

                if (configData.Member.GiveGlowEyes)
                    ItemManager.Create(Instance._glowEyes).MoveToContainer(Entity.inventory.containerWear);

                if (configData.Member.AimconeOverride != 0f)
                    InvokeHandler.Invoke(this, UpdateProjectileAccuracy, 3f);
            }

            private void LightCheck()
            {
                if ((TOD_Sky.Instance.Cycle.Hour > 18 || TOD_Sky.Instance.Cycle.Hour < 6) && !lightsOn)
                    LightToggle(true);
                else if ((TOD_Sky.Instance.Cycle.Hour < 18 && TOD_Sky.Instance.Cycle.Hour > 6) && lightsOn)
                    LightToggle(false);                
            }

            private void LightToggle(bool on)
            {
                Item activeItem = Entity.GetActiveItem();
                if (activeItem != null)
                {
                    BaseEntity heldEntity = activeItem.GetHeldEntity();
                    if (heldEntity != null)
                    {
                        HeldEntity component = heldEntity.GetComponent<HeldEntity>();
                        if (component)
                        {
                            component.SendMessage("SetLightsOn", on, SendMessageOptions.DontRequireReceiver);
                        }
                    }
                }
                foreach (Item item in Entity.inventory.containerWear.itemList)
                {
                    ItemModWearable itemModWearable = item.info.GetComponent<ItemModWearable>();
                    if (!itemModWearable || !itemModWearable.emissive)                    
                        continue;
                    
                    item.SetFlag(global::Item.Flag.IsOn, on);
                    item.MarkDirty();
                }

                lightsOn = on;
            }

            private static Hash<string, float> _aimConeDefaults = new Hash<string, float>();

            private void UpdateProjectileAccuracy()
            {
                for (int i = 0; i < Entity.inventory.containerBelt.itemList.Count; i++)
                {
                    Item item = Entity.inventory.containerBelt.itemList[i];

                    BaseProjectile baseProjectile = item.GetHeldEntity() as BaseProjectile;
                    if (baseProjectile != null)
                    {
                        if (_aimConeDefaults.ContainsKey(item.info.shortname))
                            _aimConeDefaults[item.info.shortname] = baseProjectile.aimCone;

                        baseProjectile.aimCone = configData.Member.AimconeOverride;
                    }
                }
            }

            private void ScheduleMemberUpdate() => _memberTickQueue.Add(this);

            internal void OnTick()
            {          
                if (Entity.InSafeZone())
                {
                    KillInSafeZone();
                    return;
                }

                if (configData.Member.KillUnderWater && IsUnderWater())
                {
                    Manager.OnMemberDeath(this, null);
                    Entity.Kill();                    
                    return;
                }

                if (configData.Member.DisableDormantSystem)
                {
                    Entity.IsDormant = false;
                    Entity.Tick();
                }

                if (Entity.IsDormant)
                    return;

                if (Manager.PrimaryTarget == null)
                {
                    if (Memory.TargetDestination != Manager.Destination || Domain.NavAgent.isPathStale)
                    {
                        if (Manager.DebugMode)
                        {
                            if (Domain.NavAgent.isPathStale)
                                Debug.Log($"Member {Manager.members.IndexOf(this)} has stale path");
                            else Debug.Log($"Member {Manager.members.IndexOf(this)} has mismatched destination. Manager: {Manager.Destination} - Memory {Memory.TargetDestination}");
                        }

                        SetRoamToDestination();
                    }
                }

                if (Memory.PrimaryKnownEnemyPlayer.PlayerInfo.VisibilityScore > 0.5f)
                    lastSeenTargetTime = Time.time;

                BaseNpcTargetTick();
            }

            private void KillInSafeZone()
            {
                Manager.OnMemberDeath(this, null);

                NPCPlayerCorpse npcPlayerCorpse = Entity.DropCorpse("assets/prefabs/npc/murderer/murderer_corpse.prefab") as NPCPlayerCorpse;

                if (Entity.AiDomain != null && Entity.AiDomain.NavAgent != null && Entity.AiDomain.NavAgent.isOnNavMesh)                
                    npcPlayerCorpse.transform.position = npcPlayerCorpse.transform.position + (Vector3.down * Entity.AiDomain.NavAgent.baseOffset);
                
                npcPlayerCorpse.SetLootableIn(2f);
                npcPlayerCorpse.SetFlag(BaseEntity.Flags.Reserved2, true, false, true);

                int number = 0;
                while (number < Entity.inventory.containerWear.itemList.Count)
                {
                    Item item = Entity.inventory.containerWear.itemList[number];
                    if (item == null || !(item.info.shortname == "gloweyes"))                    
                        number++;                    
                    else
                    {
                        Entity.inventory.containerWear.Remove(item);
                        break;
                    }
                }

                npcPlayerCorpse.containers = new ItemContainer[3];

                for (int i = 0; i < npcPlayerCorpse.containers.Length; i++)
                {
                    npcPlayerCorpse.containers[i] = new ItemContainer();
                    npcPlayerCorpse.containers[i].ServerInitialize(null, i == 1 ? Entity.inventory.containerWear.capacity : 0);
                    npcPlayerCorpse.containers[i].GiveUID();
                    npcPlayerCorpse.containers[i].entityOwner = npcPlayerCorpse;

                    if (i == 1)
                    {
                        List<Item> list = Entity.inventory.containerWear.itemList;
                        for (int j = 0; j < list.Count; j++)
                        {
                            Item item = list[j];
                            if (!item.MoveToContainer(npcPlayerCorpse.containers[i], -1, true))
                            {
                                item.DropAndTossUpwards(Transform.position, 2f);
                            }
                        }
                    }
                }

                npcPlayerCorpse.Spawn();
                Entity.Kill();
            }

            private bool IsUnderWater()
            {
                return TerrainMeta.WaterMap.GetDepth(Transform.position) > 1.5f;
            }

            #region Attack behaviour for BaseNpc targets
            private float _lastAttackTime;
            private bool _isAttacking;

            private void BaseNpcTargetTick()
            {
                if (configData.Member.TargetAnimals && Manager.PrimaryTarget is BaseNpc)
                {
                    Domain.SetDestination(GetPreferredFightingPosition(Context));
                    TickWeapons();
                }
            }

            private void TickWeapons()
            {
                if (Context.GetFact(Facts.HasEnemyTarget) == 0 || _isAttacking || !Context.IsBodyAlive())
                {
                    Context.Body.modelState.aiming = _isAttacking;
                    return;
                }
                switch (Context.GetFact(Facts.FirearmOrder))
                {
                    case 1:
                        {
                            TickFirearm(0f);
                            return;
                        }
                    case 2:
                        {
                            TickFirearm(0.2f);
                            return;
                        }
                    case 3:
                        {
                            TickFirearm(0.5f);
                            return;
                        }
                    default:
                        {
                            if (Context.GetFact(Facts.HeldItemType) != 2)
                            {
                                return;
                            }
                            else
                            {
                                break;
                            }
                        }
                }
                Context.Body.modelState.aiming = true;
            }

            private void TickFirearm(float interval)
            {
                AttackEntity firearm = Domain.ReloadFirearmIfEmpty();
                if (firearm == null || !(firearm is BaseMelee) || Context.GetFact(Facts.HeldItemType) == 2)
                {
                    MurdererDomain.MurdererHoldItemOfType.SwitchToItem(Context, ItemType.MeleeWeapon);
                    firearm = Domain.GetFirearm();
                }
                if (firearm == null)                
                    return;
                
                BaseMelee baseMelee = firearm as BaseMelee;

                if (baseMelee == null || baseMelee.effectiveRange > 2f)                
                    Context.Body.modelState.aiming = false;                
                else Context.Body.modelState.aiming = true;
                
                float time = Time.time;

                if (time - _lastAttackTime < interval)                
                    return;
                
                if (Manager.PrimaryTarget == null)                
                    return;
                
                if (!CanUseFirearmAtRange((Manager.PrimaryTarget.transform.position - Context.BodyPosition).sqrMagnitude))                
                    return;
                
                BaseProjectile baseProjectile = firearm as BaseProjectile;
                if (baseProjectile && baseProjectile.NextAttackTime > time)                
                    return;
                
                switch (Context.GetFact(Facts.FireTactic))
                {
                    case 0:
                        {
                            FireBurst(baseProjectile, time);
                            return;
                        }
                    case 2:
                        {
                            FireFullAuto(baseProjectile, time);
                            return;
                        }
                    default:
                        {
                            FireSingle(firearm, time);
                            return;
                        }
                }
            }

            private bool CanUseFirearmAtRange(float sqrRange)
            {
                AttackEntity firearm = Domain.GetFirearm();
                if (firearm == null)                
                    return false;
                
                if (sqrRange <= Context.Body.AiDefinition.Engagement.SqrCloseRangeFirearm(firearm))               
                    return true;
                
                if (sqrRange <= Context.Body.AiDefinition.Engagement.SqrMediumRangeFirearm(firearm))                
                    return firearm.CanUseAtMediumRange;
               
                return firearm.CanUseAtLongRange;
            }

            private void FireBurst(BaseProjectile proj, float time)
            {
                if (proj == null)                
                    return;
                
                Entity.StartCoroutine(HoldTriggerLogic(proj, time, UnityEngine.Random.Range(proj.attackLengthMin, proj.attackLengthMax)));
            }

            private void FireFullAuto(BaseProjectile proj, float time)
            {
                if (proj == null)
                {
                    return;
                }
                Entity.StartCoroutine(HoldTriggerLogic(proj, time, 4f));
            }

            private void FireSingle(AttackEntity attackEnt, float time)
            {
                if (Context.EnemyPlayersInLineOfSight.Count > 3)
                {
                    attackEnt.ServerUse((1f + UnityEngine.Random.@value * 0.5f) * ConVar.AI.npc_htn_player_base_damage_modifier, null);
                }
                else if (!(Context.PrimaryEnemyPlayerInLineOfSight.Player != null) || Context.PrimaryEnemyPlayerInLineOfSight.Player.healthFraction >= 0.2f)
                {
                    attackEnt.ServerUse(ConVar.AI.npc_htn_player_base_damage_modifier, null);
                }
                else
                {
                    attackEnt.ServerUse((0.1f + UnityEngine.Random.@value * 0.5f) * ConVar.AI.npc_htn_player_base_damage_modifier, null);
                }
                _lastAttackTime = time + attackEnt.attackSpacing * (0.5f + UnityEngine.Random.@value * 0.5f);
                Context.IncrementFact(Facts.Vulnerability, 1, true, true, true);
            }

            private IEnumerator HoldTriggerLogic(BaseProjectile proj, float startTime, float triggerDownInterval)
            {
                _isAttacking = true;
                _lastAttackTime = startTime + triggerDownInterval + proj.attackSpacing;
                Context.IncrementFact(Facts.Vulnerability, 1, true, true, true);
                do
                {
                    if (Time.time - startTime >= triggerDownInterval || !Context.IsBodyAlive() || !Context.IsFact(Facts.CanSeeEnemy))
                    {
                        break;
                    }
                    if (Context.EnemyPlayersInLineOfSight.Count > 3)
                    {
                        proj.ServerUse((1f + UnityEngine.Random.@value * 0.5f) * ConVar.AI.npc_htn_player_base_damage_modifier, null);
                    }
                    else if (!(Context.PrimaryEnemyPlayerInLineOfSight.Player != null) || Context.PrimaryEnemyPlayerInLineOfSight.Player.healthFraction >= 0.2f)
                    {
                        proj.ServerUse(ConVar.AI.npc_htn_player_base_damage_modifier, null);
                    }
                    else
                    {
                        proj.ServerUse((0.1f + UnityEngine.Random.@value * 0.5f) * ConVar.AI.npc_htn_player_base_damage_modifier, null);
                    }
                    yield return CoroutineEx.waitForSeconds(proj.repeatDelay);
                }
                while (proj.primaryMagazine.contents > 0);
                _isAttacking = false;
            }

            #endregion

            internal void OnTargetUpdated(NpcPlayerInfo playerInfo)
            {
                Context.ResetState();

                if (WantsToRoam())
                    return;

                if (playerInfo.Player == null)
                {
                    Memory.ForgetPrimiaryEnemyPlayer();                    
                    return;
                }

                if (Manager.PrimaryTarget is BasePlayer)
                {
                    BasePlayer targetPlayer = Manager.PrimaryTarget as BasePlayer;
                    if (targetPlayer == null || targetPlayer.transform == null)
                    {
                        Manager.PrimaryTarget = null;
                        return;
                    }

                    Context.EnemyPlayersAudible.Add(playerInfo);
                    Context.EnemyPlayersInLineOfSight.Add(playerInfo);
                    Context.PlayersInRange.Add(playerInfo);

                    Context.PrimaryEnemyPlayerAudible = Context.PrimaryEnemyPlayerInLineOfSight = playerInfo;

                    BaseNpcMemory.EnemyPlayerInfo info = new BaseNpcMemory.EnemyPlayerInfo()
                    {
                        BodyVisibleWhenLastNoticed = true,
                        HeadVisibleWhenLastNoticed = true,
                        LastKnownLocalPosition = targetPlayer.transform.localPosition,
                        LastKnownLocalHeading = targetPlayer.transform.localPosition - Context.BodyPosition,
                        OurLastLocalPositionWhenLastSeen = Entity.transform.localPosition,
                        PlayerInfo = playerInfo,
                        Time = Time.time
                    };

                    Memory.KnownEnemyPlayers.Add(info);
                    Memory.PrimaryKnownEnemyPlayer = info;

                    if ((info.LastKnownPosition - Context.BodyPosition).sqrMagnitude > 1f)
                        Context.HasVisitedLastKnownEnemyPlayerLocation = false;
                }
                else if (Manager.PrimaryTarget is BaseNpc)
                {
                    Memory.RememberPrimaryAnimal(Manager.PrimaryTarget as BaseNpc);
                }
            }

            internal void OnTargetUpdated(AnimalInfo animalInfo)
            {
                Context.ResetState();

                if (WantsToRoam())
                    return;

                if (Manager.PrimaryTarget is BaseNpc)
                {                    
                    BaseNpc targetAnimal = Manager.PrimaryTarget as BaseNpc;
                    if (targetAnimal == null || targetAnimal.transform == null)
                    {
                        Manager.PrimaryTarget = null;
                        return;
                    }

                    Context.AnimalsInRange.Add(animalInfo);

                    Memory.PrimaryKnownAnimal = animalInfo;

                    Context.SetFact(Facts.HasEnemyTarget, true);
                }
                else if (Manager.PrimaryTarget is BasePlayer)
                {
                    Context.Memory.RememberPrimaryAnimal(Manager.PrimaryTarget as BaseNpc);
                }
            }

            private bool WantsToRoam()
            {
                if (Manager.PrimaryTarget == null)
                {
                    SetRoamToDestination();
                    return true;
                }

                return false;
            }

            internal void SetRoamToDestination()
            {                
                Memory.ForgetPrimiaryEnemyPlayer();
                
                if (Memory.TargetDestination != Manager.Destination || Memory.CachedRoamDestination != Manager.Destination || Domain.NavAgent.isPathStale || (Domain.NavAgent.isOnNavMesh && Domain.NavAgent.isStopped))
                {
                    if (Manager.DebugMode)
                    {
                        foreach (Vector3 v in Domain.NavAgent.path.corners)
                        {
                            foreach (BasePlayer player in BasePlayer.activePlayerList)
                            {
                                if (player.IsAdmin)
                                    player.SendConsoleCommand("ddraw.sphere", 10f, Color.blue, v, 0.5f);
                            }
                        }
                    }

                    if (!Domain.SetDestination(Manager.Destination, false))
                    {
                        if (Manager.DebugMode)
                            Debug.Log($"Member {Manager.members.IndexOf(this)} failed SetDestination. PathState failed");

                        Manager.PathStateFailed = true;
                        return;
                    }
                }
                
                Memory.CachedRoamDestination = Manager.Destination;
                Memory.CachedRoamDestinationTime = Time.time;
                Memory.HasTargetDestination = true;

                Context.PushFactChangeDuringPlanning(Facts.FirearmOrder, FirearmOrders.HoldYourFire, false);
                Context.SetFact(Facts.FireTactic, (byte)0, true, true, true);

                Context.SetFact(Facts.PathStatus, (byte)1, true, false, true);

                Context.SetFact(Facts.IsIdle, false, true, true, true);
                Context.SetFact(Facts.IsWaiting, false, true, true, true);

                Context.SetFact(Facts.IsNavigating, true, true, true, true);
                Context.SetFact(Facts.IsRoaming, (byte)1, true, true, true);
            }

            #region Loot
            internal void PrepareInventory()
            {
                ItemContainer[] source = new ItemContainer[] { Entity.inventory.containerMain, Entity.inventory.containerWear, Entity.inventory.containerBelt };

                containers = new ItemContainer[3];

                for (int i = 0; i < containers.Length; i++)
                {
                    containers[i] = new ItemContainer();
                    containers[i].ServerInitialize(null, source[i].capacity);
                    containers[i].GiveUID();
                    Item[] array = source[i].itemList.ToArray();
                    for (int j = 0; j < array.Length; j++)
                    {
                        Item item = array[j];
                        if (i == 1)
                        {
                            Item newItem = ItemManager.CreateByItemID(item.info.itemid, item.amount, item.skin);
                            if (!newItem.MoveToContainer(containers[i], -1, true))
                                newItem.Remove(0f);
                        }
                        else
                        {
                            if (i == 2 && configData.Member.AimconeOverride != 0f)
                            {
                                float aimCone;
                                if (_aimConeDefaults.TryGetValue(item.info.shortname, out aimCone))
                                {
                                    BaseProjectile baseProjectile = item.GetHeldEntity() as BaseProjectile;
                                    if (baseProjectile != null)
                                        baseProjectile.aimCone = aimCone;
                                }
                            }

                            if (!item.MoveToContainer(containers[i], -1, true))
                                item.Remove(0f);
                        }
                    }
                }
            }

            internal void MoveInventoryTo(LootableCorpse corpse)
            {
                for (int i = 0; i < containers.Length; i++)
                {
                    Item[] array = containers[i].itemList.ToArray();
                    corpse.containers[i].capacity = array.Length;

                    for (int j = 0; j < array.Length; j++)
                    {
                        Item item = array[j];

                        if (item == null)
                            continue;

                        if (item.info.shortname == Instance._glowEyes.shortname)
                        {
                            item.RemoveFromContainer();
                            item.Remove(0f);
                            continue;
                        }

                        if (!item.MoveToContainer(corpse.containers[i], -1, true))
                        {
                            item.Remove(0f);
                        }
                    }
                }

                corpse.ResetRemovalTime();
            }
            #endregion
        }
        #endregion

        #region Sensors and Reasoners
        public class PlayersInRangeSensor : INpcSensor
        {
            internal HordeMember HordeMember { get; private set; }

            public float TickFrequency { get; set; }

            public float LastTickTime { get; set; }


            public const int MaxPlayers = 128;

            public static BasePlayer[] PlayerQueryResults = new BasePlayer[128];

            public static int PlayerQueryResultCount = 0;


            public PlayersInRangeSensor(HordeMember hordeMember)
            {
                HordeMember = hordeMember;
                TickFrequency = 0.5f;
            }

            private Func<BasePlayer, bool> Query = (BasePlayer player) => player != null && player.isServer && !player.IsDestroyed && player.transform != null && !player.IsDead() && !player.IsWounded() && (!player.IsSleeping() || player.secondsSleeping >= NPCAutoTurret.sleeperhostiledelay);

            public void Tick(IHTNAgent htnAgent, float deltaTime, float time)
            {
                if (HordeMember == null || htnAgent == null || htnAgent.transform == null || htnAgent.IsDestroyed || htnAgent.AiDefinition == null)
                    return;

                PlayerQueryResultCount = BaseEntity.Query.Server.GetPlayersInSphere(htnAgent.transform.position, htnAgent.AiDefinition.Sensory.VisionRange, PlayerQueryResults, Query);

                List<NpcPlayerInfo> playersInRange = htnAgent.AiDomain.NpcContext.PlayersInRange;

                if (PlayerQueryResultCount > 0)
                {
                    for (int i = 0; i < PlayerQueryResultCount; i++)
                    {
                        BasePlayer potentialTarget = PlayerQueryResults[i];

                        if (potentialTarget != null && !potentialTarget.IsDead() && potentialTarget.transform != null && potentialTarget != HordeMember.Entity && (potentialTarget.transform.position - htnAgent.transform.position).sqrMagnitude <= htnAgent.AiDefinition.Sensory.SqrVisionRange)
                        {
                            bool flag = false;
                            for (int j = 0; j < playersInRange.Count; j++)
                            {
                                NpcPlayerInfo npcPlayerInfo = playersInRange[j];
                                if (npcPlayerInfo.Player == potentialTarget)
                                {
                                    npcPlayerInfo.Time = time;
                                    playersInRange[j] = npcPlayerInfo;
                                    flag = true;
                                    break;
                                }
                            }
                            if (!flag)
                            {
                                if (HordeMember.Manager.IsValidTarget(potentialTarget))
                                {
                                    playersInRange.Add(new NpcPlayerInfo
                                    {
                                        Player = potentialTarget,
                                        Time = time
                                    });
                                }
                            }
                        }
                    }
                }
                for (int k = 0; k < playersInRange.Count; k++)
                {
                    NpcPlayerInfo npcPlayerInfo = playersInRange[k];

                    if ((time - npcPlayerInfo.Time > htnAgent.AiDefinition.Memory.ForgetInRangeTime && htnAgent.AiDomain.NpcContext.BaseMemory.ShouldRemoveOnPlayerForgetTimeout(time, npcPlayerInfo)) || (npcPlayerInfo.Player?.IsDead() ?? false))
                    {
                        playersInRange.RemoveAt(k);
                        k--;
                    }
                    else HordeMember.Manager.EvaluateTarget(npcPlayerInfo);
                }
            }
        }

        public class AnimalsInRangeSensor : INpcSensor
        {
            internal HordeMember HordeMember { get; private set; }
            
            public float LastTickTime { get; set; }

            public float TickFrequency { get; set; }


            public const int MaxAnimals = 128;

            public static BaseNpc[] QueryResults = new BaseNpc[128];

            public static int QueryResultCount = 0;

            public AnimalsInRangeSensor(HordeMember hordeMember)
            {
                HordeMember = hordeMember;
                TickFrequency = 1f;
            }

            public void Tick(IHTNAgent htnAgent, float deltaTime, float time)
            {
                if (HordeMember == null || htnAgent == null || htnAgent.transform == null || htnAgent.IsDestroyed || htnAgent.AiDefinition == null)
                    return;

                MurdererDomain aiDomain = HordeMember.Domain;
                if (aiDomain == null || HordeMember.Context == null)                
                    return;
                
                QueryResultCount = BaseEntity.Query.Server.GetInSphere(htnAgent.transform.position, htnAgent.AiDefinition.Sensory.VisionRange / 2f, QueryResults, (BaseEntity entity) => 
                {
                    BaseNpc baseNpc = entity as BaseNpc;
                    if (baseNpc != null && !baseNpc.IsDestroyed && !baseNpc.IsDead())                    
                        return true;                    
                    return false;
                });

                List<AnimalInfo> animalsInRange = htnAgent.AiDomain.NpcContext.AnimalsInRange;
                if (QueryResultCount > 0)
                {
                    for (int i = 0; i < QueryResultCount; i++)
                    {
                        BaseNpc potentialTarget = QueryResults[i];
                        if (potentialTarget != null && !potentialTarget.IsDead() && potentialTarget.transform != null && potentialTarget != HordeMember.Entity)
                        {
                            float sqrDistance = (potentialTarget.transform.position - htnAgent.transform.position).sqrMagnitude;
                            if (sqrDistance <= htnAgent.AiDefinition.Sensory.SqrVisionRange)
                            {
                                bool flag = false;
                                int num = 0;
                                while (num < animalsInRange.Count)
                                {
                                    AnimalInfo info = animalsInRange[num];
                                    if (info.Animal != potentialTarget)
                                    {
                                        num++;
                                    }
                                    else
                                    {
                                        info.Time = time;
                                        info.SqrDistance = sqrDistance;
                                        animalsInRange[num] = info;
                                        flag = true;
                                        break;
                                    }
                                }
                                if (!flag)
                                {
                                    AnimalInfo animalInfo = new AnimalInfo()
                                    {
                                        Animal = potentialTarget,
                                        Time = time,
                                        SqrDistance = sqrDistance
                                    };
                                    animalsInRange.Add(animalInfo);
                                }
                            }
                        }
                    }
                }
                for (int j = 0; j < animalsInRange.Count; j++)
                {
                    AnimalInfo animalInfo = animalsInRange[j];

                    if ((time - animalInfo.Time > htnAgent.AiDefinition.Memory.ForgetAnimalInRangeTime) || (animalInfo.Animal?.IsDead() ?? false))
                    {
                        animalsInRange.RemoveAt(j);
                        j--;
                    }
                    else HordeMember.Manager.EvaluateTarget(animalInfo);
                }
            }
        }

        public class EnemyRangeReasoner : INpcReasoner
        {
            internal HordeMember HordeMember { get; private set; }

            public float LastTickTime { get; set; }

            public float TickFrequency { get; set; }

            public EnemyRangeReasoner(HordeMember hordeMember)
            {
                HordeMember = hordeMember;
                TickFrequency = 0.2f;
            }

            public void Tick(IHTNAgent htnAgent, float deltaTime, float time)
            {
                if (HordeMember == null || htnAgent == null || htnAgent.transform == null || htnAgent.IsDestroyed || htnAgent.AiDefinition == null)
                    return;

                MurdererContext npcContext = HordeMember.Context;
                if (npcContext == null)                
                    return;

                if (HordeMember.Manager.PrimaryTarget == null)
                {
                    npcContext.SetFact(Facts.EnemyRange, EnemyRange.OutOfRange, true, true, true);
                    return;
                }
               
                float sqrDistance = (HordeMember.Manager.Destination - npcContext.BodyPosition).sqrMagnitude;

                AttackEntity firearm = npcContext.Domain.GetFirearm();

                if (sqrDistance <= npcContext.Body.AiDefinition.Engagement.SqrCloseRangeFirearm(firearm))
                {
                    npcContext.SetFact(Facts.EnemyRange, EnemyRange.CloseRange, true, true, true);
                    return;
                }

                if (sqrDistance <= npcContext.Body.AiDefinition.Engagement.SqrMediumRangeFirearm(firearm))
                {
                    npcContext.SetFact(Facts.EnemyRange, EnemyRange.MediumRange, true, true, true);
                    return;
                }

                if (sqrDistance <= npcContext.Body.AiDefinition.Engagement.SqrLongRangeFirearm(firearm))
                {
                    npcContext.SetFact(Facts.EnemyRange, EnemyRange.LongRange, true, true, true);
                    return;
                }

                npcContext.SetFact(Facts.EnemyRange, EnemyRange.OutOfRange, true, true, true);
            }
        }

        public class EnemyTargetReasoner : INpcReasoner
        {
            internal HordeMember HordeMember { get; private set; }

            public float LastTickTime { get; set; }

            public float TickFrequency { get; set; }

            public EnemyTargetReasoner(HordeMember hordeMember)
            {
                HordeMember = hordeMember;
                TickFrequency = 0.2f;
            }

            public void Tick(IHTNAgent htnAgent, float deltaTime, float time)
            {
                if (HordeMember == null || htnAgent == null || htnAgent.transform == null || htnAgent.IsDestroyed)
                    return;

                MurdererContext npcContext = HordeMember.Context;
                if (npcContext == null)                
                    return;
                
                npcContext.SetFact(Facts.HasEnemyTarget, HordeMember.Manager.PrimaryTarget != null, true, true, true);
            }
        }

        public class FireTacticReasoner : INpcReasoner
        {
            internal HordeMember HordeMember { get; private set; }

            public float LastTickTime { get; set; }

            public float TickFrequency { get; set; }

            public FireTacticReasoner(HordeMember hordeMember)
            {
                HordeMember = hordeMember;
                TickFrequency = 0.2f;
            }

            public void Tick(IHTNAgent htnAgent, float deltaTime, float time)
            {
                if (HordeMember == null || htnAgent == null || htnAgent.transform == null || htnAgent.IsDestroyed)
                    return;

                MurdererContext npcContext = HordeMember.Context;
                if (npcContext == null)                
                    return;
                
                FireTactic fireTactic = FireTactic.Single;
                AttackEntity heldEntity = HordeMember.Entity.GetHeldEntity() as AttackEntity;
                if (heldEntity)
                {
                    BaseProjectile baseProjectile = heldEntity as BaseProjectile;
                    float sqrDistance = float.MaxValue;

                    if (HordeMember.Manager.PrimaryTarget != null)                    
                        sqrDistance = (HordeMember.Manager.Destination - npcContext.BodyPosition).sqrMagnitude;
                    
                    if (heldEntity.attackLengthMin < 0f || sqrDistance > npcContext.Body.AiDefinition.Engagement.SqrCloseRangeFirearm(baseProjectile))                    
                        fireTactic = (heldEntity.attackLengthMin < 0f || sqrDistance > npcContext.Body.AiDefinition.Engagement.SqrMediumRangeFirearm(baseProjectile) ? FireTactic.Single : FireTactic.Burst);
                    
                    else fireTactic = FireTactic.FullAuto;
                    
                }
                npcContext.SetFact(Facts.FireTactic, fireTactic, true, true, true);
            }
        }

        public class PreferredFightingRangeReasoner : INpcReasoner
        {
            internal HordeMember HordeMember { get; private set; }

            public float LastTickTime { get; set; }

            public float TickFrequency { get; set; }

            public PreferredFightingRangeReasoner(HordeMember hordeMember)
            {
                HordeMember = hordeMember;
                TickFrequency = 0.2f;
            }

            public static bool IsAtPreferredRange(MurdererContext context, float sqrDistance, AttackEntity firearm)
            {
                if (firearm == null)                
                    return false;
                
                switch (firearm.effectiveRangeType)
                {
                    case NPCPlayerApex.WeaponTypeEnum.CloseRange:
                        {
                            return sqrDistance <= context.Body.AiDefinition.Engagement.SqrCloseRangeFirearm(firearm);
                        }
                    case NPCPlayerApex.WeaponTypeEnum.MediumRange:
                        {
                            if (sqrDistance > context.Body.AiDefinition.Engagement.SqrMediumRangeFirearm(firearm))
                            {
                                return false;
                            }
                            return sqrDistance > context.Body.AiDefinition.Engagement.SqrCloseRangeFirearm(firearm);
                        }
                    case NPCPlayerApex.WeaponTypeEnum.LongRange:
                        {
                            if (sqrDistance >= context.Body.AiDefinition.Engagement.SqrLongRangeFirearm(firearm))
                            {
                                return false;
                            }
                            return sqrDistance > context.Body.AiDefinition.Engagement.SqrMediumRangeFirearm(firearm);
                        }
                }
                return false;
            }

            public void Tick(IHTNAgent htnAgent, float deltaTime, float time)
            {
                if (HordeMember == null || htnAgent == null || htnAgent.transform == null || htnAgent.IsDestroyed)
                    return;

                MurdererContext npcContext = HordeMember.Context;
                if (npcContext == null)                
                    return;
                
                if (HordeMember.Manager.PrimaryTarget != null)
                {
                    float sqrDistance = (HordeMember.Manager.Destination - npcContext.BodyPosition).sqrMagnitude;

                    if (IsAtPreferredRange(npcContext, sqrDistance, npcContext.Domain.GetFirearm()))
                    {
                        npcContext.SetFact(Facts.AtLocationPreferredFightingRange, 1, true, true, true);
                        return;
                    }
                    npcContext.SetFact(Facts.AtLocationPreferredFightingRange, 0, true, true, true);
                }
            }
        }

        public class AtLastKnownEnemyPlayerLocationReasoner : INpcReasoner
        {
            internal HordeMember HordeMember { get; private set; }

            public float LastTickTime { get; set; }

            public float TickFrequency { get; set; }


            private NavMeshHit navMeshHit;

            public AtLastKnownEnemyPlayerLocationReasoner(HordeMember hordeMember)
            {
                HordeMember = hordeMember;
                TickFrequency = 0.2f;
            }

            public void Tick(IHTNAgent htnAgent, float deltaTime, float time)
            {
                if (HordeMember == null || htnAgent == null || htnAgent.transform == null || htnAgent.IsDestroyed)
                    return;

                MurdererContext npcContext = HordeMember.Context;
                if (npcContext == null)                
                    return;
                
                if (HordeMember.Manager.PrimaryTarget != null && (GetDestination() - HordeMember.Context.BodyPosition).sqrMagnitude < 1f)                
                    npcContext.SetFact(Facts.AtLocationLastKnownLocationOfPrimaryEnemyPlayer, 1, true, true, true);
                else npcContext.SetFact(Facts.AtLocationLastKnownLocationOfPrimaryEnemyPlayer, 0, true, true, true);
            }

            private Vector3 GetDestination()
            {
                if (HordeMember.Manager.PrimaryTarget != null && !HordeMember.Context.HasVisitedLastKnownEnemyPlayerLocation && NavMesh.FindClosestEdge(HordeMember.Manager.Destination, out navMeshHit, HordeMember.Domain.NavAgent.areaMask))
                    return navMeshHit.position;
                
                return HordeMember.Context.Body.transform.position;
            }
        }

        public class EnemyPlayerLineOfSightReasoner : INpcReasoner
        {
            internal HordeMember HordeMember { get; private set; }

            public float LastTickTime { get; set; }

            public float TickFrequency { get; set; }

            public EnemyPlayerLineOfSightReasoner(HordeMember hordeMember)
            {
                HordeMember = hordeMember;
                TickFrequency = 0.2f;
            }

            public void Tick(IHTNAgent htnAgent, float deltaTime, float time)
            {
                if (HordeMember == null || htnAgent == null || htnAgent.transform == null || htnAgent.IsDestroyed)
                    return;

                MurdererContext npcContext = HordeMember.Context;
                if (npcContext == null)                
                    return;
                
                npcContext.SetFact(Facts.CanSeeEnemy, npcContext.EnemyPlayersInLineOfSight.Count > 0 || HordeMember.Manager.PrimaryTarget is BaseNpc, true, true, true);
                
                float distance = 0f;
                NpcPlayerInfo npcPlayerInfo = default(NpcPlayerInfo);

                foreach (NpcPlayerInfo enemyPlayersInLineOfSight in htnAgent.AiDomain.NpcContext.EnemyPlayersInLineOfSight)
                {
                    float forwardDotDir = (enemyPlayersInLineOfSight.ForwardDotDir + 1f) * 0.5f;
                    float sqrDistance = (1f - enemyPlayersInLineOfSight.SqrDistance / htnAgent.AiDefinition.Engagement.SqrAggroRange) * 2f + forwardDotDir;
                    if (sqrDistance > distance)
                    {
                        distance = sqrDistance;
                        npcPlayerInfo = enemyPlayersInLineOfSight;
                    }

                    NpcPlayerInfo npcPlayerInfo1 = enemyPlayersInLineOfSight;
                    npcPlayerInfo1.VisibilityScore = sqrDistance;
                    npcContext.Memory.RememberEnemyPlayer(htnAgent, ref npcPlayerInfo1, time, 0f, "SEE!");
                }
                npcContext.PrimaryEnemyPlayerInLineOfSight = npcPlayerInfo;
                if (npcPlayerInfo.Player != null && (npcContext.Memory.PrimaryKnownEnemyPlayer.PlayerInfo.Player == null || npcContext.Memory.PrimaryKnownEnemyPlayer.PlayerInfo.AudibleScore < distance))
                {
                    npcContext.Memory.RememberPrimaryEnemyPlayer(npcPlayerInfo.Player);
                    npcContext.IncrementFact(Facts.Alertness, 2, true, true, true);
                }
            }
        }

        public static Vector3 GetPreferredFightingPosition(MurdererContext context)
        {            
            if (Time.time - context.Memory.CachedPreferredDistanceDestinationTime < 0.01f)            
                return context.Memory.CachedPreferredDistanceDestination;

            Vector3 vector3;
            Vector3 body;
            NavMeshHit navMeshHit;

            AnimalInfo primaryAnimalTarget = context.Memory.PrimaryKnownAnimal;
            if (primaryAnimalTarget.Animal != null)
            {
                float single = 1.5f;
                AttackEntity firearm = context.Domain.GetFirearm();
                if (firearm != null)
                {
                    single = (firearm.effectiveRangeType != NPCPlayerApex.WeaponTypeEnum.CloseRange ? context.Body.AiDefinition.Engagement.CenterOfMediumRangeFirearm(firearm) : context.Body.AiDefinition.Engagement.CenterOfCloseRangeFirearm(firearm));
                }
                float single1 = single * single;
                if (primaryAnimalTarget.Animal.NavAgent.velocity.Magnitude2D() <= 5f)
                {
                    single -= 0.1f;
                    if (primaryAnimalTarget.SqrDistance > single1)
                    {
                        body = context.Body.transform.position - primaryAnimalTarget.Animal.transform.position;
                        vector3 = body.normalized;
                    }
                    else
                    {
                        body = primaryAnimalTarget.Animal.transform.position - context.Body.transform.position;
                        vector3 = body.normalized;
                    }
                }
                else
                {
                    single += 1.5f;
                    if (primaryAnimalTarget.SqrDistance > single1)
                    {
                        body = primaryAnimalTarget.Animal.transform.position - context.Body.transform.position;
                        vector3 = body.normalized;
                    }
                    else
                    {
                        body = context.Body.transform.position - primaryAnimalTarget.Animal.transform.position;
                        vector3 = body.normalized;
                    }
                    if (Vector3.Dot(primaryAnimalTarget.Animal.NavAgent.velocity, vector3) < 0f)
                    {
                        if (primaryAnimalTarget.SqrDistance > single1)
                        {
                            body = context.Body.transform.position - primaryAnimalTarget.Animal.transform.position;
                            vector3 = body.normalized;
                        }
                        else
                        {
                            body = primaryAnimalTarget.Animal.transform.position - context.Body.transform.position;
                            vector3 = body.normalized;
                        }
                    }
                }
                Vector3 player = primaryAnimalTarget.Animal.transform.position + (vector3 * single);
                if (!NavMesh.SamplePosition(player + (Vector3.up * 0.1f), out navMeshHit, 2f * context.Domain.NavAgent.height, -1))
                {
                    context.Memory.AddFailedDestination(player);
                }
                else
                {
                    Vector3 allowedMovementDestination = context.Domain.ToAllowedMovementDestination(navMeshHit.position);
                    if (context.Memory.IsValid(allowedMovementDestination))
                    {
                        context.Memory.CachedPreferredDistanceDestination = allowedMovementDestination;
                        context.Memory.CachedPreferredDistanceDestinationTime = Time.time;
                        return allowedMovementDestination;
                    }
                }
            }
            return context.Body.transform.position;
        }
        #endregion

        #region Commands        
        [ChatCommand("horde")]
        private void cmdHorde(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "zombiehorde.admin"))
            {
                SendReply(player, "You do not have permission to use this command");
                return;
            }

            if (args.Length == 0)
            {
                SendReply(player, "/horde info - Show position and information about active zombie hordes");
                SendReply(player, "/horde tpto <number> - Teleport to the specified zombie horde");
                SendReply(player, "/horde destroy <number> - Destroy the specified zombie horde");
                SendReply(player, "/horde create <opt:distance> <opt:profile> - Create a new zombie horde on your position, optionally specifying distance they can roam and the horde profile you want to use");
                SendReply(player, "/horde createloadout - Copy your current inventory to a new zombie loadout");
                SendReply(player, "/horde hordecount <number> - Set the maximum number of hordes allowed");
                SendReply(player, "/horde membercount <number> - Set the maximum number of members allowed per horde");
                return;
            }

            switch (args[0].ToLower())
            {                
                case "info":
                    int memberCount = 0;
                    int hordeNumber = 0;
                    foreach (HordeManager hordeManager in HordeManager._allHordes)
                    {
                        player.SendConsoleCommand("ddraw.text", 30, Color.green, hordeManager.AverageLocation + new Vector3(0, 1.5f, 0), $"<size=20>Zombie Horde {hordeNumber}</size>");
                        memberCount += hordeManager.members.Count;
                        hordeNumber++;
                    }

                    SendReply(player, $"There are {HordeManager._allHordes.Count} active zombie hordes with a total of {memberCount} zombies");
                    return;
                case "destroy":
                    {
                        int number;
                        if (args.Length != 2 || !int.TryParse(args[1], out number))
                        {
                            SendReply(player, "You must specify a horde number");
                            return;
                        }

                        if (number < 0 || number >= HordeManager._allHordes.Count)
                        {
                            SendReply(player, "An invalid horde number has been specified");
                            return;
                        }

                        HordeManager._allHordes[number].Destroy(true, true);
                        SendReply(player, $"You have destroyed zombie horde {number}");
                        return;
                    }
                case "tpto":
                    {
                        int number;
                        if (args.Length != 2 || !int.TryParse(args[1], out number))
                        {
                            SendReply(player, "You must specify a horde number");
                            return;
                        }

                        if (number < 0 || number >= HordeManager._allHordes.Count)
                        {
                            SendReply(player, "An invalid horde number has been specified");
                            return;
                        }

                        player.Teleport(HordeManager._allHordes[number].AverageLocation);
                        SendReply(player, $"You have teleported to zombie horde {number}");
                        return;
                    }
                case "debug":
                    {
                        int number;
                        if (args.Length != 2 || !int.TryParse(args[1], out number))
                        {
                            SendReply(player, "You must specify a horde number");
                            return;
                        }

                        if (number < 0 || number >= HordeManager._allHordes.Count)
                        {
                            SendReply(player, "An invalid horde number has been specified");
                            return;
                        }


                        HordeManager._allHordes[number].DebugMode = !HordeManager._allHordes[number].DebugMode;
                        SendReply(player, $"Debug mode horde {number} : {HordeManager._allHordes[number].DebugMode}");
                        return;
                    }
                case "create":
                    float distance = -1;
                    if (args.Length >= 2)
                    {
                        if (!float.TryParse(args[1], out distance))
                        {
                            SendReply(player, "Invalid Syntax!");
                            return;
                        }
                    }

                    string profile = string.Empty;
                    if (args.Length >= 3 && configData.HordeProfiles.ContainsKey(args[2]))
                        profile = args[2];

                    object success = FindPointOnNavmesh(player.transform.position, 5f);
                    if (success != null)
                    {
                        if (HordeManager.Create(new HordeManager.Order((Vector3)success, configData.Horde.InitialMemberCount, configData.Horde.MaximumMemberCount, distance, profile)))
                        {
                            if (distance > 0)
                                SendReply(player, $"You have created a zombie horde with a roam distance of {distance}");
                            else SendReply(player, "You have created a zombie horde");

                            return;
                        }
                    }

                    SendReply(player, "Invalid spawn position, move to another more open position. Unable to spawn horde");
                    return;

                case "createloadout":
                    ConfigData.MemberOptions.Loadout loadout = new ConfigData.MemberOptions.Loadout($"loadout-{configData.Member.Loadouts.Count}", DefaultDefinition);
                    
                    for (int i = 0; i < player.inventory.containerBelt.itemList.Count; i++)
                    {
                        Item item = player.inventory.containerBelt.itemList[i];
                        if (item == null || item.amount == 0)
                            continue;

                        loadout.BeltItems.Add(new ConfigData.LootTable.InventoryItem()
                        {
                            Amount = item.amount,
                            Shortname = item.info.shortname,
                            SkinID = item.skin
                        });
                    }

                    for (int i = 0; i < player.inventory.containerMain.itemList.Count; i++)
                    {
                        Item item = player.inventory.containerMain.itemList[i];
                        if (item == null || item.amount == 0)
                            continue;

                        loadout.MainItems.Add(new ConfigData.LootTable.InventoryItem()
                        {
                            Amount = item.amount,
                            Shortname = item.info.shortname,
                            SkinID = item.skin
                        });
                    }

                    for (int i = 0; i < player.inventory.containerWear.itemList.Count; i++)
                    {
                        Item item = player.inventory.containerWear.itemList[i];
                        if (item == null || item.amount == 0)
                            continue;

                        loadout.WearItems.Add(new ConfigData.LootTable.InventoryItem()
                        {
                            Amount = item.amount,
                            Shortname = item.info.shortname,
                            SkinID = item.skin
                        });
                    }

                    configData.Member.Loadouts.Add(loadout);
                    SaveConfig();

                    SendReply(player, "Saved your current inventory as a zombie loadout");
                    return;

                case "hordecount":
                    int hordes;
                    if (args.Length < 2 || !int.TryParse(args[1], out hordes))
                    {
                        SendReply(player, "You must enter a number");
                        return;
                    }

                    configData.Horde.MaximumHordes = hordes;

                    if (HordeManager._allHordes.Count < hordes)
                        CreateRandomHordes();
                    SaveConfig();
                    SendReply(player, $"Set maximum hordes to {hordes}");
                    return;

                case "membercount":
                    int members;
                    if (args.Length < 2 || !int.TryParse(args[1], out members))
                    {
                        SendReply(player, "You must enter a number");
                        return;
                    }

                    configData.Horde.MaximumMemberCount = members;
                    SaveConfig();
                    SendReply(player, $"Set maximum horde members to {members}");
                    return;
                default:
                    SendReply(player, "Invalid Syntax!");
                    break;
            }
        }

        [ConsoleCommand("horde")]
        private void ccmdHorde(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
            {
                if (!permission.UserHasPermission(arg.Connection.userid.ToString(), "zombiehorde.admin"))
                {
                    SendReply(arg, "You do not have permission to use this command");
                    return;
                }
            }

            if (arg.Args == null || arg.Args.Length == 0)
            {
                SendReply(arg, "horde info - Show position and information about active zombie hordes");
                SendReply(arg, "horde destroy <number> - Destroy the specified zombie horde");
                SendReply(arg, "horde create <opt:distance> - Create a new zombie horde at a random position, optionally specifying distance they can roam from the initial spawn point");
                SendReply(arg, "horde addloadout <kitname> <opt:otherkitname> <opt:otherkitname> - Convert the specified kit(s) into loadout(s) (add as many as you want)");
                SendReply(arg, "horde hordecount <number> - Set the maximum number of hordes allowed");
                SendReply(arg, "horde membercount <number> - Set the maximum number of members allowed per horde");
                return;
            }

            switch (arg.Args[0].ToLower())
            {
                case "info":
                    int memberCount = 0;
                    int hordeNumber = 0;
                    foreach (HordeManager hordeManager in HordeManager._allHordes)
                    {
                        memberCount += hordeManager.members.Count;
                        hordeNumber++;
                    }

                    SendReply(arg, $"There are {HordeManager._allHordes.Count} active zombie hordes with a total of {memberCount} zombies");
                    return;
                case "destroy":
                    int number;
                    if (arg.Args.Length != 2 || !int.TryParse(arg.Args[1], out number))
                    {
                        SendReply(arg, "You must specify a horde number");
                        return;
                    }

                    if (number < 1 || number > HordeManager._allHordes.Count)
                    {
                        SendReply(arg, "An invalid horde number has been specified");
                        return;
                    }

                    HordeManager._allHordes[number - 1].Destroy(true, true);
                    SendReply(arg, $"You have destroyed zombie horde {number}");
                    return;                
                case "create":
                    float distance = -1;
                    if (arg.Args.Length >= 2)
                    {
                        if (!float.TryParse(arg.Args[1], out distance))
                        {
                            SendReply(arg, "Invalid Syntax!");
                            return;
                        }
                    }

                    string profile = string.Empty;
                    if (arg.Args.Length >= 3 && configData.HordeProfiles.ContainsKey(arg.Args[2]))
                        profile = arg.Args[2];

                    if (HordeManager.Create(new HordeManager.Order(GetSpawnPoint(), configData.Horde.InitialMemberCount, configData.Horde.MaximumMemberCount, distance, profile)))
                    {
                        if (distance > 0)
                            SendReply(arg, $"You have created a zombie horde with a roam distance of {distance}");
                        else SendReply(arg, "You have created a zombie horde");
                    }
                    else SendReply(arg, "Invalid spawn position. Unable to spawn horde. Try again for a new random position");

                    return;
                case "addloadout":
                    if (!Kits)
                    {
                        SendReply(arg, "Unable to find the kits plugin");
                        return;
                    }

                    if (arg.Args.Length < 2)
                    {
                        SendReply(arg, "horde addloadout <kitname> <opt:otherkitname> <opt:otherkitname> - Convert the specified kit(s) into loadout(s) (add as many as you want)");
                        return;
                    }

                    for (int i = 1; i < arg.Args.Length; i++)
                    {
                        string kitname = arg.Args[i];
                        object success = Kits.Call("GetKitInfo", kitname);
                        if (success == null)
                        {
                            SendReply(arg, $"Unable to find a kit with the name {kitname}");
                            continue;
                        }

                        JObject obj = success as JObject;
                        JArray items = obj["items"] as JArray;

                        ConfigData.MemberOptions.Loadout loadout = new ConfigData.MemberOptions.Loadout(kitname, DefaultDefinition);

                        for (int y = 0; y < items.Count; y++)
                        {
                            JObject item = items[y] as JObject;
                            string container = (string)item["container"];

                            List<ConfigData.LootTable.InventoryItem> list = container == "belt" ? loadout.BeltItems : container == "main" ? loadout.MainItems : loadout.WearItems;
                            list.Add(new ConfigData.LootTable.InventoryItem
                            {
                                Amount = (int)item["amount"],
                                Shortname = ItemManager.FindItemDefinition((int)item["itemid"])?.shortname,
                                SkinID = (ulong)item["skinid"]
                            });
                        }

                        configData.Member.Loadouts.Add(loadout);

                        SendReply(arg, $"Successfully converted the kit {kitname} to a zombie loadout");
                    }
                    
                    SaveConfig();                    
                    return;

                case "hordecount":
                    int hordes;
                    if (arg.Args.Length < 2 || !int.TryParse(arg.Args[1], out hordes))
                    {
                        SendReply(arg, "You must enter a number");
                        return;
                    }

                    configData.Horde.MaximumHordes = hordes;

                    if (HordeManager._allHordes.Count < hordes)
                        CreateRandomHordes();
                    SaveConfig();
                    SendReply(arg, $"Set maximum hordes to {hordes}");
                    return;

                case "membercount":
                    int members;
                    if (arg.Args.Length < 2 || !int.TryParse(arg.Args[1], out members))
                    {
                        SendReply(arg, "You must enter a number");
                        return;
                    }

                    configData.Horde.MaximumMemberCount = members;
                    SaveConfig();
                    SendReply(arg, $"Set maximum horde members to {members}");
                    return;
                default:
                    SendReply(arg, "Invalid Syntax!");
                    break;
            }
        }

        private float nextCountTime;
        private string cachedString = string.Empty;

        private string GetInfoString()
        {
            if (nextCountTime < Time.time || string.IsNullOrEmpty(cachedString))
            {
                int memberCount = 0;
                HordeManager._allHordes.ForEach(x => memberCount += x.members.Count);
                cachedString = $"There are currently <color=#ce422b>{HordeManager._allHordes.Count}</color> hordes with a total of <color=#ce422b>{memberCount}</color> zombies";
                nextCountTime = Time.time + 30f;
            }

            return cachedString;
        }

        [ChatCommand("hordeinfo")]
        private void cmdHordeInfo(BasePlayer player, string command, string[] args) => player.ChatMessage(GetInfoString());
        
        [ConsoleCommand("hordeinfo")]
        private void ccmdHordeInfo(ConsoleSystem.Arg arg)
        {            
            if (arg.Connection == null)
                PrintToChat(GetInfoString());
        }

        #endregion

        #region Config       
        public enum SpawnSystem { None, Random, SpawnsDatabase }

        public enum SpawnState { Spawn, Despawn }

        internal static ConfigData configData;

        internal class ConfigData
        {
            [JsonProperty(PropertyName = "Horde Options")]
            public HordeOptions Horde { get; set; }

            [JsonProperty(PropertyName = "Horde Member Options")]
            public MemberOptions Member { get; set; }

            [JsonProperty(PropertyName = "Loot Table")]
            public LootTable Loot { get; set; }

            [JsonProperty(PropertyName = "Monument Spawn Options")]
            public MonumentSpawn Monument { get; set; }

            [JsonProperty(PropertyName = "Timed Spawn Options")]
            public TimedSpawnOptions TimedSpawns { get; set; }

            [JsonProperty(PropertyName = "Horde Profiles (profile name, list of applicable loadouts)")]
            public Dictionary<string, List<string>> HordeProfiles { get; set; }

            public class TimedSpawnOptions
            {
                [JsonProperty(PropertyName = "Only allows spawns during the set time period")]
                public bool Enabled { get; set; }

                [JsonProperty(PropertyName = "Despawn hordes outside of the set time period")]
                public bool Despawn { get; set; }

                [JsonProperty(PropertyName = "Start time (0.0 - 24.0)")]
                public float Start { get; set; }

                [JsonProperty(PropertyName = "End time (0.0 - 24.0)")]
                public float End { get; set; }
            }

            public class HordeOptions
            {
                [JsonProperty(PropertyName = "Amount of zombies to spawn when a new horde is created")]
                public int InitialMemberCount { get; set; }

                [JsonProperty(PropertyName = "Maximum amount of spawned zombies per horde")]
                public int MaximumMemberCount { get; set; }

                [JsonProperty(PropertyName = "Maximum amount of hordes at any given time")]
                public int MaximumHordes { get; set; }

                [JsonProperty(PropertyName = "Amount of time from when a horde is destroyed until a new horde is created (seconds)")]
                public int RespawnTime { get; set; }

                [JsonProperty(PropertyName = "Amount of time before a horde grows in size")]
                public int GrowthRate { get; set; }

                [JsonProperty(PropertyName = "Add a zombie to the horde when a horde member kills a player")]
                public bool CreateOnDeath { get; set; }

                [JsonProperty(PropertyName = "Merge hordes together if they collide")]
                public bool MergeHordes { get; set; }

                [JsonProperty(PropertyName = "Spawn system (SpawnsDatabase, Random)")]
                public string SpawnType { get; set; }

                [JsonProperty(PropertyName = "Spawn file (only required when using SpawnsDatabase)")]
                public string SpawnFile { get; set; }

                [JsonProperty(PropertyName = "Amount of time a player needs to be outside of a zombies vision before it forgets about them")]
                public float ForgetTime { get; set; }

                [JsonProperty(PropertyName = "Force all hordes to roam locally")]
                public bool LocalRoam { get; set; }

                [JsonProperty(PropertyName = "Local roam distance")]
                public float RoamDistance { get; set; }

                [JsonProperty(PropertyName = "Use horde profiles for randomly spawned hordes")]
                public bool UseProfiles { get; set; }
            }

            public class MemberOptions
            {
                [JsonProperty(PropertyName = "Can target animals")]
                public bool TargetAnimals { get; set; }

                [JsonProperty(PropertyName = "Can be targeted by turrets")]
                public bool TargetedByTurrets { get; set; }

                [JsonProperty(PropertyName = "Can be targeted by turrets set to peacekeeper mode")]
                public bool TargetedByPeaceKeeperTurrets { get; set; }

                [JsonProperty(PropertyName = "Can be targeted by Bradley APC")]
                public bool TargetedByAPC { get; set; }

                [JsonProperty(PropertyName = "Can target other NPCs")]
                public bool TargetNPCs { get; set; }

                [JsonProperty(PropertyName = "Can target NPCs from HumanNPC")]
                public bool TargetHumanNPCs { get; set; }

                [JsonProperty(PropertyName = "Ignore sleeping players")]
                public bool IgnoreSleepers { get; set; }

                [JsonProperty(PropertyName = "Give all zombies glowing eyes")]
                public bool GiveGlowEyes { get; set; }

                [JsonProperty(PropertyName = "Headshots instantly kill zombie")]
                public bool HeadshotKills { get; set; }

                [JsonProperty(PropertyName = "Projectile weapon aimcone override (0 = disabled)")]
                public float AimconeOverride { get; set; }

                [JsonProperty(PropertyName = "Kill NPCs that are under water")]
                public bool KillUnderWater { get; set; }

                [JsonProperty(PropertyName = "Disable NPC dormant system. This will allow NPCs to move all the time, but at a cost to performance")]
                public bool DisableDormantSystem { get; set; }

                public List<Loadout> Loadouts { get; set; }

                public class Loadout
                {
                    public string LoadoutID { get; set; }

                    [JsonProperty(PropertyName = "Potential names for zombies using this loadout (chosen at random)")]
                    public string[] Names { get; set; }

                    [JsonProperty(PropertyName = "Damage multiplier")]
                    public float DamageMultiplier { get; set; }

                    public VitalStats Vitals { get; set; }

                    public MovementStats Movement { get; set; }

                    public SensoryStats Sensory { get; set; }

                    public List<LootTable.InventoryItem> BeltItems { get; set; }

                    public List<LootTable.InventoryItem> MainItems { get; set; }

                    public List<LootTable.InventoryItem> WearItems { get; set; }
                   
                    public class VitalStats
                    {
                        public float Health { get; set; }
                    }

                    public class MovementStats
                    {
                        [JsonProperty(PropertyName = "Movement speed (running)")]
                        public float RunSpeed { get; set; }

                        [JsonProperty(PropertyName = "Movement speed (walking)")]
                        public float WalkSpeed { get; set; }

                        [JsonProperty(PropertyName = "Turn speed")]
                        public float TurnSpeed { get; set; }

                        [JsonProperty(PropertyName = "Duck speed")]
                        public float DuckSpeed { get; set; }

                        public float Acceleration { get; set; }
                    }

                    public class SensoryStats
                    {
                        [JsonProperty(PropertyName = "Vision range")]
                        public float VisionRange { get; set; }

                        [JsonProperty(PropertyName = "Hearing range")]
                        public float HearingRange { get; set; }

                        [JsonProperty(PropertyName = "Field of view")]
                        public float FOV { get; set; }
                    }

                    [JsonIgnore]
                    private MurdererDefinition _loadoutDefinition;

                    [JsonIgnore]
                    public MurdererDefinition LoadoutDefintion
                    {
                        get
                        {
                            if (_loadoutDefinition == null)
                            {
                                _loadoutDefinition = UnityEngine.Object.Instantiate(DefaultDefinition);

                                _loadoutDefinition.Vitals.HP = Vitals.Health;

                                _loadoutDefinition.Sensory.VisionRange = Sensory.VisionRange;
                                _loadoutDefinition.Sensory.HearingRange = Sensory.HearingRange;
                                _loadoutDefinition.Sensory.FieldOfView = Sensory.FOV;

                                _loadoutDefinition.Movement.RunSpeed = Movement.RunSpeed;
                                _loadoutDefinition.Movement.WalkSpeed = Movement.WalkSpeed;
                                _loadoutDefinition.Movement.Acceleration = Movement.Acceleration;
                                _loadoutDefinition.Movement.DuckSpeed = Movement.DuckSpeed;
                                _loadoutDefinition.Movement.TurnSpeed = Movement.TurnSpeed;
                            }

                            return _loadoutDefinition;
                        }
                    }

                    public Loadout() { }

                    public Loadout(string loadoutID, MurdererDefinition definition)
                    {
                        LoadoutID = loadoutID;

                        Names = new string[] { "Zombie" };

                        DamageMultiplier = 1f;

                        Vitals = new VitalStats() { Health = definition.Vitals.HP };

                        Movement = new MovementStats()
                        {
                            Acceleration = definition.Movement.Acceleration,
                            DuckSpeed = definition.Movement.DuckSpeed,
                            RunSpeed = definition.Movement.RunSpeed,
                            TurnSpeed = definition.Movement.TurnSpeed,
                            WalkSpeed = definition.Movement.WalkSpeed
                        };

                        Sensory = new SensoryStats()
                        {
                            FOV = definition.Sensory.FieldOfView,
                            HearingRange = definition.Sensory.HearingRange,
                            VisionRange = definition.Sensory.VisionRange
                        };

                        BeltItems = new List<LootTable.InventoryItem>();
                        MainItems = new List<LootTable.InventoryItem>();
                        WearItems = new List<LootTable.InventoryItem>();
                    }
                }
            }

            public class LootTable
            {
                [JsonProperty(PropertyName = "Drop inventory on death instead of random loot")]
                public bool DropInventory { get; set; }

                [JsonProperty(PropertyName = "Random loot table")]
                public RandomLoot Random { get; set; }

                public class InventoryItem
                {
                    public string Shortname { get; set; }
                    public ulong SkinID { get; set; }
                    public int Amount { get; set; }

                    [JsonProperty(PropertyName = "Attachments", NullValueHandling = NullValueHandling.Ignore)]
                    public InventoryItem[] SubSpawn { get; set; }
                }

                public class RandomLoot
                {
                    [JsonProperty(PropertyName = "Minimum amount of items to spawn")]
                    public int Minimum { get; set; }

                    [JsonProperty(PropertyName = "Maximum amount of items to spawn")]
                    public int Maximum { get; set; }

                    public List<LootDefinition> List { get; set; }

                    public class LootDefinition
                    {
                        public string Shortname { get; set; }

                        public int Minimum { get; set; }

                        public int Maximum { get; set; }

                        public ulong SkinID { get; set; }

                        [JsonProperty(PropertyName = "Spawn as blueprint")]
                        public bool IsBlueprint { get; set; }

                        [JsonProperty(PropertyName = "Probability (0.0 - 1.0)")]
                        public float Probability { get; set; }

                        [JsonProperty(PropertyName = "Spawn with")]
                        public LootDefinition Required { get; set; }

                        public int GetAmount()
                        {
                            if (Maximum <= 0f || Maximum <= Minimum)
                                return Minimum;

                            return UnityEngine.Random.Range(Minimum, Maximum);
                        }
                    }
                }
            }

            public class MonumentSpawn
            {
                public MonumentSettings Airfield { get; set; }
                public MonumentSettings Dome { get; set; }
                public MonumentSettings Junkyard { get; set; }
                public MonumentSettings LargeHarbor { get; set; }
                public MonumentSettings GasStation { get; set; }
                public MonumentSettings Powerplant { get; set; }
                public MonumentSettings StoneQuarry { get; set; }
                public MonumentSettings SulfurQuarry { get; set; }
                public MonumentSettings HQMQuarry { get; set; }
                public MonumentSettings Radtown { get; set; }
                public MonumentSettings LaunchSite { get; set; }
                public MonumentSettings Satellite { get; set; }
                public MonumentSettings SmallHarbor { get; set; }
                public MonumentSettings Supermarket { get; set; }
                public MonumentSettings Trainyard { get; set; }
                public MonumentSettings Tunnels { get; set; }
                public MonumentSettings Warehouse { get; set; }
                public MonumentSettings WaterTreatment { get; set; }

                public class MonumentSettings : SpawnSettings
                {
                    [JsonProperty(PropertyName = "Enable spawns at this monument")]
                    public bool Enabled { get; set; }
                }
            }

            public class CustomSpawnPoints : SpawnSettings
            {
                public SerializedVector Location { get; set; }

                public class SerializedVector
                {
                    public float X { get; set; }
                    public float Y { get; set; }
                    public float Z { get; set; }

                    public SerializedVector() { }

                    public SerializedVector(float x, float y, float z)
                    {
                        this.X = x;
                        this.Y = y;
                        this.Z = z;
                    }

                    public static implicit operator Vector3(SerializedVector v)
                    {
                        return new Vector3(v.X, v.Y, v.Z);
                    }

                    public static implicit operator SerializedVector(Vector3 v)
                    {
                        return new SerializedVector(v.x, v.y, v.z);
                    }
                }
            }

            public class SpawnSettings
            {
                [JsonProperty(PropertyName = "Distance that this horde can roam from their initial spawn point")]
                public float RoamDistance { get; set; }

                [JsonProperty(PropertyName = "Maximum amount of members in this horde")]
                public int HordeSize { get; set; }

                [JsonProperty(PropertyName = "Horde profile")]
                public string Profile { get; set; }
            }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Horde = new ConfigData.HordeOptions
                {
                    InitialMemberCount = 3,
                    MaximumHordes = 5,
                    MaximumMemberCount = 10,
                    GrowthRate = 300,
                    CreateOnDeath = true,
                    ForgetTime = 10f,
                    MergeHordes = true,
                    RespawnTime = 900,                   
                    SpawnType = "Random",
                    SpawnFile = "",
                    LocalRoam = false,
                    RoamDistance = 150,
                    UseProfiles = false
                },
                Member = new ConfigData.MemberOptions
                {
                    IgnoreSleepers = false,
                    TargetAnimals = false,
                    TargetedByTurrets = false,
                    TargetedByAPC = false,                    
                    TargetNPCs = true,
                    TargetHumanNPCs = false,
                    GiveGlowEyes = true,
                    HeadshotKills = true,
                    Loadouts = BuildDefaultLoadouts(),
                    AimconeOverride = 0,
                    KillUnderWater = true,
                    TargetedByPeaceKeeperTurrets = true,
                    DisableDormantSystem = true
                },
                Loot = new ConfigData.LootTable
                {
                    DropInventory = false,
                    Random = BuildDefaultLootTable(),
                },
                TimedSpawns = new ConfigData.TimedSpawnOptions
                {
                    Enabled = false,
                    Despawn = true,
                    Start = 18f,
                    End = 6f
                },
                HordeProfiles = new Dictionary<string, List<string>>
                {
                    ["Profile1"] = new List<string> { "loadout-1", "loadout-2", "loadout-3" },
                    ["Profile2"] = new List<string> { "loadout-2", "loadout-3", "loadout-4" },
                },
                Monument = new ConfigData.MonumentSpawn
                {
                    Airfield = new ConfigData.MonumentSpawn.MonumentSettings
                    {
                        Enabled = false,
                        RoamDistance = 85,
                        HordeSize = 10,
                        Profile = "",
                    },
                    Dome = new ConfigData.MonumentSpawn.MonumentSettings
                    {
                        Enabled = false,
                        RoamDistance = 50,
                        HordeSize = 10,
                    },
                    Junkyard = new ConfigData.MonumentSpawn.MonumentSettings
                    {
                        Enabled = false,
                        RoamDistance = 100,
                        HordeSize = 10,
                        Profile = ""
                    },
                    GasStation = new ConfigData.MonumentSpawn.MonumentSettings
                    {
                        Enabled = false,
                        RoamDistance = 40,
                        HordeSize = 10,
                        Profile = ""
                    },
                    LargeHarbor = new ConfigData.MonumentSpawn.MonumentSettings
                    {
                        Enabled = false,
                        RoamDistance = 120,
                        HordeSize = 10,
                        Profile = ""
                    },
                    Powerplant = new ConfigData.MonumentSpawn.MonumentSettings
                    {
                        Enabled = false,
                        RoamDistance = 120,
                        HordeSize = 10,
                        Profile = ""
                    },
                    HQMQuarry = new ConfigData.MonumentSpawn.MonumentSettings
                    {
                        Enabled = false,
                        RoamDistance = 40,
                        HordeSize = 10,
                        Profile = ""
                    },
                    StoneQuarry = new ConfigData.MonumentSpawn.MonumentSettings
                    {
                        Enabled = false,
                        RoamDistance = 40,
                        HordeSize = 10,
                        Profile = ""
                    },
                    SulfurQuarry = new ConfigData.MonumentSpawn.MonumentSettings
                    {
                        Enabled = false,
                        RoamDistance = 40,
                        HordeSize = 10,
                        Profile = ""
                    },
                    Radtown = new ConfigData.MonumentSpawn.MonumentSettings
                    {
                        Enabled = false,
                        RoamDistance = 85,
                        HordeSize = 10,
                        Profile = ""
                    },
                    LaunchSite = new ConfigData.MonumentSpawn.MonumentSettings
                    {
                        Enabled = false,
                        RoamDistance = 140,
                        HordeSize = 10,
                        Profile = ""
                    },
                    Satellite = new ConfigData.MonumentSpawn.MonumentSettings
                    {
                        Enabled = false,
                        RoamDistance = 60,
                        HordeSize = 10,
                        Profile = ""
                    },
                    SmallHarbor = new ConfigData.MonumentSpawn.MonumentSettings
                    {
                        Enabled = false,
                        RoamDistance = 85,
                        HordeSize = 10,
                        Profile = ""
                    },
                    Supermarket = new ConfigData.MonumentSpawn.MonumentSettings
                    {
                        Enabled = false,
                        RoamDistance = 20,
                        HordeSize = 10,
                        Profile = ""
                    },
                    Trainyard = new ConfigData.MonumentSpawn.MonumentSettings
                    {
                        Enabled = false,
                        RoamDistance = 100,
                        HordeSize = 10,
                        Profile = ""
                    },
                    Tunnels = new ConfigData.MonumentSpawn.MonumentSettings
                    {
                        Enabled = false,
                        RoamDistance = 90,
                        HordeSize = 10,
                        Profile = ""
                    },
                    Warehouse = new ConfigData.MonumentSpawn.MonumentSettings
                    {
                        Enabled = false,
                        RoamDistance = 40,
                        HordeSize = 10,
                        Profile = ""
                    },
                    WaterTreatment = new ConfigData.MonumentSpawn.MonumentSettings
                    {
                        Enabled = false,
                        RoamDistance = 120,
                        HordeSize = 10,
                        Profile = ""
                    },
                },
                Version = Version
            };
        }

        private List<ConfigData.MemberOptions.Loadout> BuildDefaultLoadouts()
        {
            List<ConfigData.MemberOptions.Loadout> list = new List<ConfigData.MemberOptions.Loadout>();

            MurdererDefinition definition = DefaultDefinition;
            if (definition != null)
            {
                for (int i = 0; i < definition.loadouts.Length; i++)
                {
                    PlayerInventoryProperties inventoryProperties = definition.loadouts[i];

                    ConfigData.MemberOptions.Loadout loadout = new ConfigData.MemberOptions.Loadout($"loadout-{list.Count}", definition);

                    for (int belt = 0; belt < inventoryProperties.belt.Count; belt++)
                    {
                        PlayerInventoryProperties.ItemAmountSkinned item = inventoryProperties.belt[belt];

                        loadout.BeltItems.Add(new ConfigData.LootTable.InventoryItem() { Shortname = item.itemDef.shortname, SkinID = item.skinOverride, Amount = (int)item.amount });
                    }

                    for (int main = 0; main < inventoryProperties.main.Count; main++)
                    {
                        PlayerInventoryProperties.ItemAmountSkinned item = inventoryProperties.main[main];

                        loadout.MainItems.Add(new ConfigData.LootTable.InventoryItem() { Shortname = item.itemDef.shortname, SkinID = item.skinOverride, Amount = (int)item.amount });
                    }

                    for (int wear = 0; wear < inventoryProperties.wear.Count; wear++)
                    {
                        PlayerInventoryProperties.ItemAmountSkinned item = inventoryProperties.wear[wear];

                        loadout.WearItems.Add(new ConfigData.LootTable.InventoryItem() { Shortname = item.itemDef.shortname, SkinID = item.skinOverride, Amount = (int)item.amount });
                    }

                    list.Add(loadout);
                }
            }
            return list;
        }

        private ConfigData.LootTable.RandomLoot BuildDefaultLootTable()
        {
            ConfigData.LootTable.RandomLoot randomLoot = new ConfigData.LootTable.RandomLoot();

            randomLoot.Minimum = 3;
            randomLoot.Maximum = 9;
            randomLoot.List = new List<ConfigData.LootTable.RandomLoot.LootDefinition>();

            MurdererDefinition definition = DefaultDefinition;
            if (definition != null)
            {
                for (int i = 0; i < definition.Loot.Length; i++)
                {
                    LootContainer.LootSpawnSlot lootSpawn = definition.Loot[i];

                    for (int y = 0; y < lootSpawn.definition.subSpawn.Length; y++)
                    {
                        LootSpawn.Entry entry = lootSpawn.definition.subSpawn[y];                                               

                        for (int c = 0; c < entry.category.items.Length; c++)
                        {
                            ItemAmountRanged itemAmountRanged = entry.category.items[c];

                            ConfigData.LootTable.RandomLoot.LootDefinition lootDefinition = new ConfigData.LootTable.RandomLoot.LootDefinition();
                            lootDefinition.Probability = lootSpawn.probability;
                            lootDefinition.Shortname = itemAmountRanged.itemDef.shortname;
                            lootDefinition.Minimum = (int)itemAmountRanged.amount;
                            lootDefinition.Maximum = (int)itemAmountRanged.maxAmount;
                            lootDefinition.SkinID = 0;
                            lootDefinition.IsBlueprint = itemAmountRanged.itemDef.spawnAsBlueprint;
                            lootDefinition.Required = null;

                            randomLoot.List.Add(lootDefinition);
                        }
                    }
                }
            }
            return randomLoot;
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new Core.VersionNumber(0, 2, 0))
                configData = baseConfig;

            if (configData.Version < new Core.VersionNumber(0, 2, 1))
                configData.Loot.Random = baseConfig.Loot.Random;

            if (configData.Version < new Core.VersionNumber(0, 2, 2))
            {
                for (int i = 0; i < configData.Member.Loadouts.Count; i++)                
                    configData.Member.Loadouts[i].LoadoutID = $"loadout-{i}";

                configData.Horde.LocalRoam = false;
                configData.Horde.RoamDistance = 150;
                configData.Horde.UseProfiles = false;

                configData.HordeProfiles = baseConfig.HordeProfiles;

                configData.Monument.Airfield.Profile = string.Empty;
                configData.Monument.Dome.Profile = string.Empty;
                configData.Monument.GasStation.Profile = string.Empty;
                configData.Monument.HQMQuarry.Profile = string.Empty;
                configData.Monument.Junkyard.Profile = string.Empty;
                configData.Monument.LargeHarbor.Profile = string.Empty;
                configData.Monument.LaunchSite.Profile = string.Empty;
                configData.Monument.Powerplant.Profile = string.Empty;
                configData.Monument.Radtown.Profile = string.Empty;
                configData.Monument.Satellite.Profile = string.Empty;
                configData.Monument.SmallHarbor.Profile = string.Empty;
                configData.Monument.StoneQuarry.Profile = string.Empty;
                configData.Monument.SulfurQuarry.Profile = string.Empty;
                configData.Monument.Supermarket.Profile = string.Empty;
                configData.Monument.Trainyard.Profile = string.Empty;
                configData.Monument.Tunnels.Profile = string.Empty;
                configData.Monument.Warehouse.Profile = string.Empty;
                configData.Monument.WaterTreatment.Profile = string.Empty;
            }

            if (configData.Version < new Core.VersionNumber(0, 2, 5))
                configData.Member.AimconeOverride = 0f;

            if (configData.Version < new Core.VersionNumber(0, 2, 13))
                configData.TimedSpawns = baseConfig.TimedSpawns;

            if (configData.Version < new Core.VersionNumber(0, 2, 18))            
                configData.Member.TargetedByPeaceKeeperTurrets = configData.Member.TargetedByTurrets; 

            if (configData.Version < new Core.VersionNumber(0, 2, 30))
            {
                if (configData.Horde.SpawnType == "RandomSpawns" || configData.Horde.SpawnType == "Default")
                    configData.Horde.SpawnType = "Random";
            }

            if (configData.Version < new Core.VersionNumber(0, 2, 31))
            {
                if (string.IsNullOrEmpty(configData.Horde.SpawnType))
                    configData.Horde.SpawnType = "Random";

                configData.Member.DisableDormantSystem = true;
            }
            
            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion
    }
}


// --- End of file: ZombieHorde.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/IQEventSystem.cs ---
// --- Original Local Path: IQEventSystem.cs ---

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using ConVar;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("IQEventSystem", "Mercury", "0.0.2")]
    [Description("Не услышанный пионер Mercury")]
    class IQEventSystem : RustPlugin
    {
        #region Reference
        [PluginReference] Plugin IQChat;
        #endregion

        #region Vars
        public bool EventStatus = false;
        public EventType EventLocal;
        public int LocalIndexEvent = 0;
        public enum EventType
        {
            Gather,
            PickUp,
            Search,
            Kills
        }
        public Dictionary<BasePlayer, int> EventPlayerList = new Dictionary<BasePlayer, int>();
        #endregion

        #region Configuration
        private static Configuration config = new Configuration();
        private class Configuration
        {
            [JsonProperty("Настройка ивентов")]
            public List<Events> EventList = new List<Events>();
            [JsonProperty("Настройка интерфейса")]
            public InterfaceSetting InterfaceSettings = new InterfaceSetting();
            [JsonProperty("Через сколько запуск случайный ивент(в секундах)")]
            public float TimeToStartEvent;
            [JsonProperty("Время ожидания регистрации игроков на ивент")]
            public float TimerVotesWait;
            [JsonProperty("Префикс в чате(IQChat)")]
            public string PrefixForChat;
            [JsonProperty("Минимум игроков для запуска ивента")]
            public int MinimumOnline;

            internal class Events
            {
                [JsonProperty("Тип ивента : 0 - Добыча, 1 - Поднять с пола, 2 - Найти в ящике, 3 - Убийство")]
                public EventType EventTypes;
                [JsonProperty("Время ивента ( в секундах )")]
                public float TimerEvent;
                [JsonProperty("Отображаемое имя")]
                public string DisplayName;
                [JsonProperty("Описание ивента")]
                public string Description;
                [JsonProperty("Цель ивента : Shortname")]
                public string Shortname;
                [JsonProperty("Цель ивента : SkinID (если не требуется,оставляйте 0)")]
                public ulong SkinID;
                [JsonProperty("Награда за победу в ивенте")]
                public List<Reward> Rewards = new List<Reward>();

                internal class Reward
                {
                    [JsonProperty("Shortname")]
                    public string Shortname;
                    [JsonProperty("Команда")]
                    public string Command;
                    [JsonProperty("SkinID")]
                    public ulong SkinID;
                    [JsonProperty("Минимальное количество")]
                    public int MinAmount;
                    [JsonProperty("Максимальное количество")]
                    public int MaxAmount;
                }
            }

            internal class InterfaceSetting
            {
                [JsonProperty("AnchorMin всей панели")]
                public string AnchorMin;
                [JsonProperty("AnchorMax всей панели")]
                public string AnchorMax;
                [JsonProperty("AnchorMin кнопки для участия")]
                public string AnchorMinVote;
                [JsonProperty("AnchorMax кнопки для участия")]
                public string AnchorMaxVote;
                [JsonProperty("Основной цвет")]
                public string MainColor;
                [JsonProperty("Дополнительный цвет")]
                public string TwoMainColor;
            }

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    TimeToStartEvent = 1600,
                    TimerVotesWait = 20,
                    MinimumOnline = 5,
                    PrefixForChat = "<color=#007FFF><b>[МЕРОПРИЯТИЕ]</b></color>",
                    InterfaceSettings = new InterfaceSetting
                    {
                        AnchorMin = "0.003645837 0.6509259",
                        AnchorMax = "0.1661458 0.9916667",
                        AnchorMinVote = "0.3078125 0.112963",
                        AnchorMaxVote = "0.6765625 0.162963",
                        MainColor = "#6B803EFF",
                        TwoMainColor = "#566B2BFF",
                    },
                    EventList = new List<Events>
                    {
                       new Events
                       {
                           EventTypes = EventType.Gather,
                           DisplayName = "<b>Каменьщик</b>",
                           Description = "<b><size=12>Добудьте КАМНЯ больше всех и получите приз</size></b>",
                           TimerEvent = 600,
                           Shortname = "stones",
                           SkinID = 0,
                           Rewards = new List<Events.Reward>
                           {
                               new Events.Reward
                               {
                                   Shortname = "wrappingpaper",
                                   Command = "",
                                   SkinID = 0,
                                   MinAmount = 1,
                                   MaxAmount = 5
                               }
                           }
                       },
                       new Events
                       {
                           EventTypes = EventType.Kills,
                           DisplayName = "<b>Убийца животных</b>",
                           Description = "<b><size=12>Убейте КАБАНОВ больше всех и получите приз</size></b>",
                           TimerEvent = 600,
                           Shortname = "boar",
                           SkinID = 0,
                           Rewards = new List<Events.Reward>
                           {
                               new Events.Reward
                               {
                                   Shortname = "wrappingpaper",
                                   Command = "",
                                   SkinID = 0,
                                   MinAmount = 1,
                                   MaxAmount = 5
                               },
                               new Events.Reward
                               {
                                   Shortname = "piano",
                                   Command = "say %STEAMID%",
                                   SkinID = 0,
                                   MinAmount = 1,
                                   MaxAmount = 5
                               },
                           }
                       },
                       new Events
                       {
                           EventTypes = EventType.PickUp,
                           DisplayName = "<b>Грибник</b>",
                           Description = "<b><size=12>Найдите грибов больше всех и получите приз</size></b>",
                           TimerEvent = 600,
                           Shortname = "mushroom",
                           SkinID = 0,
                           Rewards = new List<Events.Reward>
                           {
                               new Events.Reward
                               {
                                   Shortname = "wrappingpaper",
                                   Command = "",
                                   SkinID = 0,
                                   MinAmount = 1,
                                   MaxAmount = 5
                               },
                               new Events.Reward
                               {
                                   Shortname = "piano",
                                   Command = "say %STEAMID%",
                                   SkinID = 0,
                                   MinAmount = 1,
                                   MaxAmount = 5
                               },
                           }
                       },
                       new Events
                       {
                           EventTypes = EventType.Search,
                           DisplayName = "<b>Искатель</b>",
                           Description = "<b><size=12>Найдите скрапа больше всех и получите приз</size></b>",
                           TimerEvent = 100,
                           Shortname = "scrap",
                           SkinID = 0,
                           Rewards = new List<Events.Reward>
                           {
                               new Events.Reward
                               {
                                   Shortname = "wrappingpaper",
                                   Command = "",
                                   SkinID = 0,
                                   MinAmount = 1,
                                   MaxAmount = 5
                               },
                               new Events.Reward
                               {
                                   Shortname = "piano",
                                   Command = "say %STEAMID%",
                                   SkinID = 0,
                                   MinAmount = 1,
                                   MaxAmount = 5
                               },
                           }
                       },
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning("Ошибка #132167" + $"чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region UI

        public static string QIEVENT_PARENT = "IQEVENT_PARENTS";
        public static string QIEVENT_VOTE_PARENT = "IQEVENTVOTE_PARENTS";

        public void UIEventVotes(int IndexEvent)
        {
            if (EventStatus) return;
            EventPlayerList.Clear();

            for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                var player = BasePlayer.activePlayerList[i];

                CuiElementContainer container = new CuiElementContainer();
                CuiHelper.DestroyUi(player, QIEVENT_VOTE_PARENT);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = config.InterfaceSettings.AnchorMinVote, AnchorMax = config.InterfaceSettings.AnchorMaxVote },
                    Button = { Close = QIEVENT_VOTE_PARENT, Command = "iqe vote", Color = HexToRustFormat(config.InterfaceSettings.MainColor), Material = "assets/content/ui/uibackgroundblur.mat" },
                    Text = { FadeIn = 0.8f, Text = lang.GetMessage("EVENT_VOTES_BTN", this, player.UserIDString), Align = TextAnchor.MiddleCenter }
                }, "Overlay", QIEVENT_VOTE_PARENT);

                CuiHelper.AddUi(player, container);
            };

            timer.Once(config.TimerVotesWait, () =>
            {
                foreach (var MembersEvent in EventPlayerList)
                    UIEvent(MembersEvent.Key, IndexEvent);

                for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
                {
                    var player = BasePlayer.activePlayerList[i];
                    CuiHelper.DestroyUi(player, QIEVENT_VOTE_PARENT);
                }
            });
        }

        public void UIEvent(BasePlayer player, int IndexEvent)
        {
            var Event = config.EventList[IndexEvent];
            var Interface = config.InterfaceSettings;
            EventLocal = Event.EventTypes; 
            EventStatus = true;

            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, QIEVENT_PARENT);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = Interface.AnchorMin, AnchorMax = Interface.AnchorMax },
                Image = { FadeIn = 0.15f, Color = "0 0 0 0" }
            }, "Overlay", QIEVENT_PARENT);

            #region TitlePanel

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.8940217", AnchorMax = "1 1" },
                Image = { FadeIn = 0.15f, Color = HexToRustFormat(Interface.MainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            },  QIEVENT_PARENT, "TITLE_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.03205127 0", AnchorMax = "0.7211539 1" },
                Text = { Text = Event.DisplayName, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft, FadeIn = 0.3f }
            }, "TITLE_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.775641 0", AnchorMax = "1 0.9074167" },
                Text = { Text = $"<b>{FormatTime(TimeSpan.FromSeconds(Event.TimerEvent))}</b>", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, "TITLE_PANEL", "TIMER");

            #endregion

            #region MainPanel

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.8858696" },
                Image = { FadeIn = 0.15f, Color = HexToRustFormat(Interface.MainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, QIEVENT_PARENT, "MAIN_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.9049079", AnchorMax = "1 1" },
                Text = { Text = lang.GetMessage("LIST_MEMBERS",this,player.UserIDString), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, "MAIN_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.8527607", AnchorMax = "1 0.9233128" },
                Text = { Text = lang.GetMessage("ONE_DESCTIPTION", this,player.UserIDString), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, "MAIN_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.1441717" },
                Text = { Text = Event.Description, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, "MAIN_PANEL");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.02 0.1503068", AnchorMax = "0.98 0.8036808" },
                Image = { FadeIn = 0.15f, Color = HexToRustFormat(config.InterfaceSettings.TwoMainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, "MAIN_PANEL", "PLAYERS_PANEL");

            #endregion

            CuiHelper.AddUi(player, container);

            timer.Once(1, () => { RefreshTimer(player, (float)Event.TimerEvent, IndexEvent); });
        }

        public void RefreshTimer(BasePlayer player, float Timer,int IndexEvent)
        {
            CuiHelper.DestroyUi(player, "TIMER");
            if (!EventStatus) return;
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.775641 0", AnchorMax = "1 0.9074075" },
                Text = { Text = $"<b>{FormatTime(TimeSpan.FromSeconds(Timer))}</b>", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, "TITLE_PANEL", "TIMER");

            var TopEvent = EventPlayerList.OrderByDescending(x => x.Value).Take(8).ToDictionary(x => x.Key, x => x.Value);

            for(int i = 0; i < TopEvent.Count; i++)
            {
                CuiHelper.DestroyUi(player, $"PLAYER_COUNT_{i}");
                var ElementTop = TopEvent.ElementAt(i);

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0 {0.8779345 - (i * 0.13)}", AnchorMax = $"1 {1 - (i * 0.13)}" },
                    Text = { Text = $"{ElementTop.Key.displayName} : {ElementTop.Value}шт", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
                }, "PLAYERS_PANEL", $"PLAYER_COUNT_{i}");
            }

            CuiHelper.AddUi(player, container);

            if(Timer <= 0)
            {
                EventStatus = false;
                GiveReward(IndexEvent);
                foreach (var Eventers in EventPlayerList)
                    CuiHelper.DestroyUi(Eventers.Key, QIEVENT_PARENT);
                return;
            }
            Timer--;
            timer.Once(1, () => { RefreshTimer(player, (float)Timer, IndexEvent); });
        }

        #endregion

        #region Lang
        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["LIST_MEMBERS"] = "<size=14><b>Entry</b></size>",
                ["ONE_DESCTIPTION"] = "<size=10><b>Outrun everyone and hold first place</b></size>",
                ["NON_ADMIN_CHAT_COMMAND"] = "You are not an Administrator",
                ["NON_CORRECT_CHAT_COMMAND"] = "You are using the command incorrectly",
                ["EVENT_VOTES_BTN"] = "<size=14><b>The event is about to begin!\n To take part, click on this button</b></size>",
                ["EVENT_VOTES_BTN_ACCESS"] = "You have successfully registered for participation",
                ["EVENT_WINNER_ALERT"] = "You received a reward for winning the event, congratulations!",

            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["LIST_MEMBERS"] = "<size=14><b>Список участников</b></size>",
                ["ONE_DESCTIPTION"] = "<size=10><b>Обгони всех и удержи первое место</b></size>",
                ["NON_ADMIN_CHAT_COMMAND"] = "Вы не являетесь Администратором",
                ["NON_CORRECT_CHAT_COMMAND"] = "Вы некорректно используете команду",
                ["EVENT_VOTES_BTN"] = "<size=14><b>Achtung!!! Сейчас начнется Ивент!\nЧтобы принять участие,нажмите на эту кнопку</b></size>",
                ["EVENT_VOTES_BTN_ACCESS"] = "Вы успешно зарегистрировались на участие",
                ["EVENT_WINNER_ALERT"] = "Вы получили награду за победу в ивенте,поздравляем!",

            }, this, "ru");
            PrintWarning("Языковой файл загружен успешно");
        }
        #endregion

        #region Hooks
        private void OnServerInitialized()
        {
            EventAutoStart();
        }

        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            if (!EventStatus) return;
            if (dispenser == null || entity == null || item == null) return;
            if (EventLocal != EventType.Gather) return;
            if (item.info.shortname != config.EventList[LocalIndexEvent].Shortname) return;
            BasePlayer player = (BasePlayer)entity;
            WriteResult(player, item.amount);
        }

        void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (!EventStatus) return;
            if (dispenser == null || player == null || item == null) return;
            if (EventLocal != EventType.Gather) return;
            if (item.info.shortname != config.EventList[LocalIndexEvent].Shortname) return;
            WriteResult(player, item.amount);
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (!EventStatus) return;
            if (info?.InitiatorPlayer == null || info == null || entity == null) return;
            if (EventLocal != EventType.Kills) return;
            if (entity.ShortPrefabName != config.EventList[LocalIndexEvent].Shortname) return;
            var player = info?.InitiatorPlayer;
            WriteResult(player, 1);
        }

        void OnCollectiblePickup(Item item, BasePlayer player)
        {
            if (!EventStatus) return;
            if (item == null || player == null) return;
            if (EventLocal != EventType.PickUp) return;
            if (item.info.shortname != config.EventList[LocalIndexEvent].Shortname) return;
            WriteResult(player, item.amount);
        }
        void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            if (!EventStatus) return;
            if (entity == null || player == null) return;
            if (entity.GetComponent<StorageContainer>() == null) return;
            if (entity.OwnerID >= 7656000000) return;
            if (EventLocal != EventType.Search) return;

            foreach (var content in entity.GetComponent<StorageContainer>().inventory.itemList)
            {
                if (content.info.shortname == config.EventList[LocalIndexEvent].Shortname)
                    WriteResult(player, content.amount);
            }
        }
        #endregion

        #region Metods

        void EventAutoStart()
        {
            timer.Every(config.TimeToStartEvent, () =>
             {
                 if (EventStatus)
                 {
                     PrintError("Слишком маленькое время для автоматического старта! Прошлый ивент не успел закончится!\nНовый ивент перенесен!");
                     return;
                 }
                 if(BasePlayer.activePlayerList.Count < config.MinimumOnline)
                 {
                     PrintWarning("Автоматический запуск ивента отменен! Недостаточно игроков на сервере!\nНовый ивент перенесен!");
                     return;
                 }
                 LocalIndexEvent = GetRandomEvent();
                 UIEventVotes(LocalIndexEvent);
             });
        }

        public int GetRandomEvent()
        {
            int IndexEvent = UnityEngine.Random.Range(0, config.EventList.Count());
            return IndexEvent;
        }

        public void WriteResult(BasePlayer player,int Amount)
        {
            if (!EventPlayerList.ContainsKey(player)) return;
            EventPlayerList[player] += Amount;
        }

        public void GiveReward(int IndexEvent)
        {
            var Winner = EventPlayerList.OrderByDescending(x => x.Value).Take(1).ToDictionary(x => x.Key, x => x.Value);
            var Rewards = config.EventList[IndexEvent].Rewards;
            foreach (var player in Winner)
            {
                for (int i = 0; i < Rewards.Count; i++)
                {
                    if (String.IsNullOrEmpty(Rewards[i].Command))
                    {
                        var RandomAmount = UnityEngine.Random.Range(Rewards[i].MinAmount, Rewards[i].MaxAmount);
                        Item item = ItemManager.CreateByName(Rewards[i].Shortname, RandomAmount, Rewards[i].SkinID);
                        player.Key.GiveItem(item);
                    }
                    else Server.Command(Rewards[i].Command.Replace("%STEAMID%", player.Key.UserIDString));
                }
                SendChat(lang.GetMessage("EVENT_WINNER_ALERT", this, player.Key.UserIDString), player.Key);
            }
        }
        #endregion

        #region Command

        [ChatCommand("iqe")]
        void IQEventCommand(BasePlayer player, string cmd, string[] arg)
        {
            if (!player.IsAdmin)
            {
                SendChat(lang.GetMessage("NON_ADMIN_CHAT_COMMAND", this, player.UserIDString), player);
                return;
            }
            if (arg == null || arg.Length < 1 || arg[0].Length < 0)
            {
                SendChat(lang.GetMessage("NON_CORRECT_CHAT_COMMAND", this, player.UserIDString), player);
                return;
            }
            switch(arg[0].ToLower())
            {
                case "start":
                    {
                        LocalIndexEvent = GetRandomEvent();
                        UIEventVotes(LocalIndexEvent);
                        SendChat("Вы успешно запустили ивент вручную", player);
                        break;
                    }
                case "stop":
                    {
                        for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
                        {
                            var p = BasePlayer.activePlayerList[i];
                            CuiHelper.DestroyUi(p, QIEVENT_PARENT);
                            CuiHelper.DestroyUi(p, QIEVENT_VOTE_PARENT);
                        }

                        EventStatus = false;
                        SendChat("Вы успешно остановили ивент вручную", player);
                        break;
                    }
            }
        }

        [ConsoleCommand("iqe")]
        void IQECommandConsole(ConsoleSystem.Arg arg)
        {
            switch(arg.Args[0])
            {
                case "vote":
                    {
                        BasePlayer player = arg.Player();
                        EventPlayerList.Add(player, 0);
                        SendChat(lang.GetMessage("EVENT_VOTES_BTN_ACCESS", this, player.UserIDString), player);
                        break;
                    }
            }
        }

        #endregion

        #region Helps
        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        static double CurrentTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;

        public static string FormatTime(TimeSpan time)
        {
            string result = string.Empty;
            if (time.Days != 0)
                result += $"{Format(time.Days, "д", "д", "д")} ";

            if (time.Hours != 0)
                result += $"{Format(time.Hours, "ч", "ч", "ч")} ";

            if (time.Minutes != 0)
                result += $"{Format(time.Minutes, "м", "м", "м")} ";

            if (time.Seconds != 0)
                result += $"{Format(time.Seconds, "с", "с", "с")} ";

            return result;
        }

        private static string Format(int units, string form1, string form2, string form3)
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                return $"{units} {form1}";

            if (tmp >= 2 && tmp <= 4)
                return $"{units} {form2}";

            return $"{units} {form3}";
        }

        public void SendChat(string Message, BasePlayer player, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            if (IQChat)
                IQChat?.Call("API_ALERT_PLAYER", player, Message, config.PrefixForChat);
            else player.SendConsoleCommand("chat.add", channel, 0, Message);
        }
        #endregion
    }
}


// --- End of file: IQEventSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Promo-1.0.1.cs ---
// --- Original Local Path: Promo-1.0.1.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
	[Info("Promo", "xkrystalll", "1.0.1")]
	class Promo : RustPlugin
	{
		#region Classes

		internal class ItemData
		{
			[JsonProperty(Order = 0)] public string Shortname;
			[JsonProperty("Skin", Order = 1)] public ulong SkinID;
			[JsonProperty(Order = 2)] public int Amount;

			[JsonProperty("Display name (still empty if not need to change)", Order = 4)]
			public string DisplayName;

			public Item ToItem()
			{
				Item item = ItemManager.CreateByName(Shortname, Amount, SkinID);
				if (!string.IsNullOrEmpty(DisplayName))
					item.name = DisplayName;

				var heldEntity = item.GetHeldEntity();
				if (heldEntity != null)
					heldEntity.SendNetworkUpdate();
				return item;
			}
		}

		internal class Reward
		{
			[JsonProperty("Команды (%STEAMID% - id игрока) | Оставить пустым если нужно выдавать предметы ниже", Order = 0)]
			public List<string> Commands;
			[JsonProperty("Предметы", Order = 1)]
			public List<ItemData> Items;

			public new RewardType GetType() => Commands.IsNullOrEmpty() ? RewardType.Items : RewardType.Command;
		}
		
		internal class Promocode
		{
			public string Code;
			public int Usages;
			public bool Enabled;
			public Reward Reward;
		}
		#endregion

		#region Fields

		private Dictionary<string, int> EnteredPromocodesAmount = new();
		private Dictionary<ulong, List<string>> EnteredPromocodesPlayers = new();

		internal enum RewardType : byte
		{
			Items = 0,
			Command = 1
		}
		
		#endregion

		#region Hooks
		private void OnServerInitialized()
		{
			LoadData();
			foreach (var x in cfg.Promocodes)
			{
				if (!x.Value.Enabled)
					continue;
				cmd.AddChatCommand(x.Value.Code, this, nameof(cmdTakePromocode));
			}
		}

		private void Unload() => SaveData();

		private void OnServerSave() => SaveData();

		#endregion

		#region Methods

		private bool CanTakePromocode(BasePlayer target, string code)
		{
			var promocode = cfg.Promocodes.FirstOrDefault(x => x.Value.Code == code);

			if (promocode.Value == null)
				return false;
			
			if (EnteredPromocodesAmount.TryGetValue(promocode.Key, out var usagesAmount))
				if (usagesAmount > promocode.Value.Usages)
					return false;
			
			if (EnteredPromocodesPlayers.TryGetValue(target.userID, out var usedByPlayer))
				if (usedByPlayer.Contains(promocode.Key))
				{
					SendMessage(target, GetMsg("entered.alreadyentered", target.userID));
					return false;
				}

			return true;
		}

		private void TakeCode(BasePlayer player, KeyValuePair<string, Promocode> promocodeInfo)
		{
			if (promocodeInfo.Value == null)
				return;
			
			if (!EnteredPromocodesPlayers.ContainsKey(player.userID))
				EnteredPromocodesPlayers.Add(player.userID, new());

			if (!CanTakePromocode(player, promocodeInfo.Value.Code))
				return;


			switch (promocodeInfo.Value.Reward.GetType())
			{
				case RewardType.Command:
					foreach (var x in promocodeInfo.Value.Reward.Commands)
						Server.Command(x.Replace("%STEAMID%", player.UserIDString));
					break;
				case RewardType.Items:
					foreach (var x in promocodeInfo.Value.Reward.Items)
						player.GiveItem(x.ToItem());
					break;
				
				default:
					throw new ArgumentException("Promocode::Reward");
			}
			
			if (!EnteredPromocodesAmount.ContainsKey(promocodeInfo.Key))
				EnteredPromocodesAmount.Add(promocodeInfo.Key, 0);

			EnteredPromocodesPlayers[player.userID].Add(promocodeInfo.Key);
			EnteredPromocodesAmount[promocodeInfo.Key]++;

			SendMessage(player, GetMsg("entered.success", player.userID));
		}

		private void SendMessage(BasePlayer player, string message)
		{
			player.SendConsoleCommand("chat.add", new object[]
			{
				2,
				cfg.AvatarID,
				message
			});
		}
		#endregion

		#region Commands
		private void cmdTakePromocode(BasePlayer player, string command)
		{
			if (player == null || string.IsNullOrEmpty(command))
				return;

			var code = cfg.Promocodes.FirstOrDefault(x => x.Value.Code == command);

			if (code.Value == null)
				return;
			
			if (CanTakePromocode(player, command))
				TakeCode(player, new(code.Key, code.Value));
		}

		#endregion
		
		#region Config

		private ConfigData cfg;

		public class ConfigData
		{
			[JsonProperty("Аватарка")] public ulong AvatarID;
			[JsonProperty("Промокоды")] public Dictionary<string, Promocode> Promocodes;
		}

		protected override void LoadDefaultConfig()
		{
			var config = new ConfigData
			{
				AvatarID = 76561198802642520,
				Promocodes = new()
				{
					["test1"] = new()
					{
						Code = "promocode",
						Usages = 10,
						Enabled = true,
						Reward = new()
						{
							Commands = null,
							Items = new()
							{
								new()
								{
									Shortname = "rifle.ak",
									SkinID = 123,
									Amount = 1,
									DisplayName = "TEST AK"
								},
								new()
								{
									Shortname = "rifle.lr300",
									SkinID = 0,
									Amount = 1,
									DisplayName = null
								}
							}
						},
						
					},
					["test2"] = new()
					{
						Code = "promocode2",
						Usages = 10,
						Enabled = true,
						Reward = new()
						{
							Commands = new()
							{
								"test 1 %STEAMID%",
								"testtest %STEAMID%"
							}
						}
					}
				}
			};
			SaveConfig(config);
		}

		protected override void LoadConfig()
		{
			base.LoadConfig();
			cfg = Config.ReadObject<ConfigData>();
			SaveConfig(cfg);
		}

		private void SaveConfig(object config)
		{
			Config.WriteObject(config, true);
		}
		#endregion

		#region Data

		private void SaveData()
		{
			Interface.Oxide.DataFileSystem.WriteObject($"{Title}/playersEnteredCodes", EnteredPromocodesPlayers);
			Interface.Oxide.DataFileSystem.WriteObject($"{Title}/promoUsages", EnteredPromocodesAmount);
		}

		private void LoadData()
		{
			EnteredPromocodesPlayers = Interface.Oxide?.DataFileSystem?.ReadObject<Dictionary<ulong, List<string>>>($"{Title}/playersEnteredCodes")
			    ?? new();
			EnteredPromocodesAmount = Interface.Oxide?.DataFileSystem?.ReadObject<Dictionary<string, int>>($"{Title}/promoUsages")
			    ?? new();
		}
		#endregion
		
		#region Langs

		private void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["entered.success"] = "Promocode successfully used",
				["entered.alreadyentered"] = "You already used this promocode"
			}, this);

			lang.RegisterMessages(new Dictionary<string, string>
			{
				["entered.success"] = "Промокод успешно активирован",
				["entered.alreadyentered"] = "Вы уже вводили этот промокод"
			}, this, "ru");
		}
		private string GetMsg(string key, ulong id, params object[] args) =>
			string.Format(lang.GetMessage(key, this, id.ToString()), args);
		#endregion
	}
}

// --- End of file: Promo-1.0.1.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Kits1.cs ---
// --- Original Local Path: Kits1.cs ---

// Name: Kits
// Documentation: https://gist.github.com/JVCVkrSzVqsfEcwJqk7N/cec76ff33a5653acd3f13418b065190e
// Changelog:
// * [1.0.0] Release
// 
// End
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Kits", "Orange", "1.0.1")]
    [Description("Kits with features for your server! Made by Orange#0900")]
    public class Kits1 : RustPlugin
    {
        #region Vars

        [PluginReference] private Plugin ImageLibrary;

        private void AddImage(string name, string url)
        {
            if (ImageLibrary == null)
            {
                return;
            }
            
            if (!ImageLibrary.IsLoaded)
            {
                timer.Once(1f, () =>
                {
                    AddImage(name, url);
                });
            }
            
            ImageLibrary.CallHook("AddImage", url, name, 0UL);
        }
        
        private string GetImage(string name)
        {
            return ImageLibrary?.Call<string>("GetImage", name);
        }

        private class Kit
        {
            [JsonProperty(PropertyName = "1. Name")]
            public string name;

            [JsonProperty(PropertyName = "2. Display name")]
            public string displayName;

            [JsonProperty(PropertyName = "3. Permission")]
            public string permission;

            [JsonProperty(PropertyName = "4. Cooldown")]
            public int cooldown;

            [JsonProperty(PropertyName = "5. Wipe-block time")]
            public int block;

            [JsonProperty(PropertyName = "6. Icon")]
            public string url;

            [JsonProperty(PropertyName = "7. Description")]
            public string description;

            [JsonProperty(PropertyName = "8. Max uses")]
            public int uses;

            [JsonProperty(PropertyName = "9. Give on respawn")]
            public bool auto;

            [JsonProperty(PropertyName = "Items:")]
            public List<BaseItem> items;
        }

        private class BaseItem
        {
            public string shortname;
            public int amount;
            public ulong skin;
            public string container;
            public int position;
        }

        #endregion

        #region Oxide Hooks

        private void Init()
        {
            LoadData();
            lang.RegisterMessages(EN, this);
            permission.RegisterPermission("Kits.Unknown", this);
            cmd.AddChatCommand(config.command, this, "Command");
            cmd.AddConsoleCommand(config.command, this, "Command");
        }

        private void Loaded()
        {
            var mask = lang.GetMessage("Kit", this);
            
            foreach (var kit in config.kits)
            {
                permission.RegisterPermission(kit.permission, this);
                AddImage(kit.name, kit.url);
            }

            foreach (var item in config.kits.SelectMany(x => x.items).Distinct())
            {
                var name = item.shortname;
                AddImage(name, $"https://rustlabs.com/img/items180/{name}.png");
            }
        }

        private void Unload()
        {
            SaveData();
        }

        private void OnNewSave()
        {
            SaveData();
        }
        
        private void OnPlayerRespawned(BasePlayer player) // TODO: Change
        {
            player.inventory.Strip();
            GiveKit(player, config.kits.FirstOrDefault(x => x.auto == true));
        }

        #endregion

        #region Config

        private static ConfigData config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "1. Command")]
            public string command;

            [JsonProperty(PropertyName = "Kit list:")]
            public List<Kit> kits;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                command = "kit",
                kits = new List<Kit>
                {
                    new Kit
                    {
                        name = "starter",
                        displayName = "Starter",
                        permission = "",
                        cooldown = 600,
                        block = 0,
                        description = "Start items",
                        url = "https://i.imgur.com/IIP8QMF.png",
                        uses = 0,
                        auto = false,
                        items = new List<BaseItem>
                        {
                            new BaseItem
                            {
                                shortname = "stonehatchet",
                                amount = 1
                            },
                            new BaseItem
                            {
                                shortname = "stone.pickaxe",
                                amount = 1
                            }
                        }
                    }
                }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region Data

        private const string filename = "Temp/Kits/players_data";
        private PlayerData data = new PlayerData();

        private class PlayerData
        {
            public Dictionary<ulong, Dictionary<string, double>> cooldowns =
                new Dictionary<ulong, Dictionary<string, double>>();

            public Dictionary<ulong, Dictionary<string, int>> uses = new Dictionary<ulong, Dictionary<string, int>>();
        }

        private void LoadData()
        {
            try
            {
                data = Interface.Oxide.DataFileSystem.ReadObject<PlayerData>(filename);
            }
            catch (Exception e)
            {
                PrintWarning(e.Message);
            }

            SaveData();
            timer.Every(150f, SaveData);
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(filename, data);
        }

        #endregion

        #region Localization

        private Dictionary<string, string> EN = new Dictionary<string, string>
        {
            {
                "Usage", "Usage:\n" +
                         " * /kit list - Get list of all kits\n" +
                         " * /kit NAME - Get kit with name\n" +
                         " * /kit add NAME - Add new kit with name (copy your items on creation)\n" +
                         " * /kit remove NAME - Remove kit with name"
            },
            {"Permission", "You don't have permission to use that!"},
            {"Cooldown", "Cooldown for {0} seconds!"},
            {"Blocked", "Kit is blocked for {0} since wipe"},
            {"Added", "You successfully added kit '{0}' with '{1}' items"},
            {"Removed", "You successfully removed kit '{0}'"},
            {"Can't find", "Can't find kit with name '{0}'"},
            {"Kits", "Available kits:\n{0}"},
            {"Kit", " * {0}, {1}, Cooldown {2}\n"},
            {"Uses", "You already used maximal amount [{0}] of that kit!"},
            {"Available", "You can get following kits:"},
            {"GUI ON", "Available"},
            {"GUI OFF", "{0}"},
            {"Day", "d"},
            {"Hour", "h"},
            {"Minute", "m"},
            {"Second", "s"},
            {"ImageLibrary", "Image library not installed!"}
        };

        private void message(BasePlayer player, string key, params object[] args)
        {
            var message = string.Format(lang.GetMessage(key, this, player.UserIDString), args);
            player.ChatMessage(message);
        }

        #endregion

        #region Commands

        private void Command(BasePlayer player, string command, string[] args)
        {
            Command(player, args);
        }

        private void Command(ConsoleSystem.Arg arg)
        {
            Command(arg.Player(), arg.Args);
        }

        private void Command(BasePlayer player, string[] args)
        {
            if (player == null)
            {
                return;
            }

            if (args == null || args.Length == 0)
            {
                CreatePanel(player);
                return;
            }

            var action = args[0].ToLower();
            var name = args.Length > 1 ? args[1] : "null";
            
            switch (action)
            {
                case "add":
                    AddKit(player, name);
                    break;

                case "remove":
                    RemoveKit(player, name);
                    break;
                
                case "info":
                    ShowInfo(player, name);
                    break;

                default:
                    TryGiveKit(player, action);
                    break;
            }
        }

        #endregion

        #region Core

        private List<BaseItem> GetItems(BasePlayer player)
        {
            var container = player.inventory;
            var items = new List<BaseItem>();

            foreach (var item in container.containerMain.itemList)
            {
                if (item.position < 24)
                {
                    items.Add(new BaseItem
                    {
                        shortname = item.info.shortname,
                        amount = item.amount,
                        skin = item.skin,
                        container = "Main",
                        position = item.position
                    });
                }
            }

            foreach (var item in container.containerWear.itemList)
            {
                items.Add(new BaseItem
                {
                    shortname = item.info.shortname,
                    amount = item.amount,
                    skin = item.skin,
                    container = "Wear",
                    position = item.position
                });
            }

            foreach (var item in container.containerBelt.itemList)
            {
                items.Add(new BaseItem
                {
                    shortname = item.info.shortname,
                    amount = item.amount,
                    skin = item.skin,
                    container = "Belt",
                    position = item.position
                });
            }

            return items;
        }

        private void AddKit(BasePlayer player, string name)
        {
            if (!player.IsAdmin)
            {
                message(player, "Permission");
                return;
            }

            var items = GetItems(player);

            config.kits.Add(new Kit
            {
                name = name,
                items = items,
                cooldown = 3600,
                permission = "Kits.Unknown",
                description = "Kit description",
                url = "",
                displayName = "",
                auto = false,
                block = 0,
                uses = 0
            });

            SaveConfig();
            message(player, "Added", name, items.Count);
        }

        private void RemoveKit(BasePlayer player, string name)
        {
            if (!player.IsAdmin)
            {
                message(player, "Permission");
                return;
            }

            var kit = GetKit(name);
            
            if (kit != null)
            {
                config.kits.Remove(kit);
                SaveConfig();
                message(player, "Removed", name);
            }
            else
            {
                message(player, "Can't find", name);
            }
        }

        private void TryGiveKit(BasePlayer player, string name)
        {
            timer.Once(0.2f, () => { CreateKits(player); });
            
            if (!CanUse(player))
            {
                return;
            }
            
            var kit = GetKit(name);
            if (kit == null)
            {
                message(player, "Can't find", name);
                return;
            }

            var id = player.userID;

            if (!HasPermission(id.ToString(), kit.permission))
            {
                message(player, "Permission");
                return;
            }

            var block = GetBlockTime(kit.block);
            if (block > 0)
            {
                message(player, "Block", block);
                return;
            }

            var uses = GetUses(id, kit.name);
            if (kit.uses != 0 && uses >= kit.uses)
            {
                message(player, "Uses", kit.uses);
                return;
            }

            var cooldown = GetCooldown(id, kit.name, kit.cooldown);
            if (cooldown > 0)
            {
                message(player, "Cooldown", cooldown);
                return;
            }

            data.cooldowns[id][kit.name] = Now();
            data.uses[id][kit.name]++;
            GiveKit(player, kit);
        }

        private void GiveKit(BasePlayer player, Kit kit)
        {
            foreach (var value in kit.items)
            {
                var item = ItemManager.CreateByName(value.shortname, value.amount, value.skin);
                if (item == null)
                {
                    continue;
                }

                var position = value.position;

                switch (value.container)
                {
                    case "Main":
                        item.MoveToContainer(player.inventory.containerMain, position);
                        break;
                    case "Wear":
                        item.MoveToContainer(player.inventory.containerWear, position);
                        break;
                    case "Belt":
                        item.MoveToContainer(player.inventory.containerBelt, position);
                        break;
                }

                if (item.GetRootContainer() == null)
                {
                    player.GiveItem(item);
                }
            }
        }

        private void GiveKit(BasePlayer player, string name)
        {
            var kit = GetKit(name);
            if (kit == null)
            {
                PrintError($"Can't find kit with name '{name}'!!!");
                return;
            }

            GiveKit(player, kit);
        }

        private Kit GetKit(string name)
        {
            try
            {
                return config.kits.First(x => string.Equals(x.name, name, StringComparison.CurrentCultureIgnoreCase));
            }
            catch
            {
                return null;
            }
        }

        private bool CanUse(BasePlayer player)
        {
            return Interface.Oxide.CallHook("canRedeemKit", player) == null;
        }

        #endregion

        #region Helpers

        private double Now()
        {
            return DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;
        }

        private int Passed(double a)
        {
            return Convert.ToInt32(Now() - a);
        }

        private double SaveTime()
        {
            return SaveRestore.SaveCreatedTime.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;
        }

        private int GetBlockTime(int time)
        {
            return time - Passed(SaveTime());
        }

        private int GetCooldown(ulong id, string name, int cooldown)
        {
            data.cooldowns.TryAdd(id, new Dictionary<string, double>());
            data.cooldowns[id].TryAdd(name, 0);
            return cooldown - Passed(data.cooldowns[id][name]);
        }

        private int GetUses(ulong id, string name)
        {
            data.uses.TryAdd(id, new Dictionary<string, int>());
            data.uses[id].TryAdd(name, 0);
            return data.uses[id][name];
        }

        private bool HasPermission(string id, string name)
        {
            return string.IsNullOrEmpty(name) || permission.UserHasPermission(id, name);
        }
        
        private string GetTimeString(int time)
        {
            var timeString = string.Empty;
            var days = Convert.ToInt32(time / 86400);
            var temp = 0;
            time = time % 86400;
            if (days > 0)
            {
                timeString += days + $" {lang.GetMessage("Day", this)}";
                temp = days;
            }
            
            var hours = Convert.ToInt32(time / 3600);
            time = time % 3600;
            if (hours > 0)
            {
                if (temp> 0)
                {
                    timeString += ", ";
                }
                
                timeString += hours + $" {lang.GetMessage("Hour", this)}";
                temp = hours;
            }
            
            var minutes = Convert.ToInt32(time / 60);
            time = time % 60;
            if (minutes > 0)
            {
                if (temp> 0)
                {
                    timeString += ", ";
                }
                
                timeString += minutes + $" {lang.GetMessage("Minute", this)}";
                temp = minutes;
            }
            
            var seconds = Convert.ToInt32(time);
            if (seconds > 0)
            {
                if (temp> 0)
                {
                    timeString += ", ";
                }
                
                timeString += seconds + $" {lang.GetMessage("Second", this)}";
            }

            return timeString;
        }

        #endregion

        #region GUI
               
        private const string elemHud = "kits.hud";
        private const string elemMain = "kits.main";
        private const string elemInfo = "kits.info";
        private const string outlineColor =  "0 0 0 1";
        private const string outlineDistance = "1.0 -0.5";

        private void CreatePanel(BasePlayer player)
        {
            if (ImageLibrary == null)
            {
                message(player, "ImageLibrary");
                return;
            }
            
            if (!CanUse(player))
            {
                return;
            }
            
            var container = new CuiElementContainer
            {
                new CuiElement // Hud
                {
                    Name = elemHud,
                    Parent = "Hud.Menu",
                    Components =
                    {
                        new CuiButtonComponent
                        {
                            Color = "0.25 0.25 0.25 0.75",
                            Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat",
                            Close = elemHud
                        },
                        new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"},
                        new CuiNeedsCursorComponent()
                    }
                },
                new CuiElement // Text
                {
                    Parent = elemHud,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = lang.GetMessage("Available", this, player.UserIDString),
                            Color = "1 0.71 0.51 1",
                            FontSize = 25,
                            Align = TextAnchor.MiddleCenter
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.0 0.7", 
                            AnchorMax = "1.0 0.8"
                        }
                    }
                }
            };

            CuiHelper.DestroyUi(player, elemHud);
            CuiHelper.AddUi(player, container);
            CreateKits(player);
        }

        private void CreateKits(BasePlayer player)
        {
            var x = -0.1;
            var y = 0.8;
            var sizeX = 0.22;
            var sizeY = 0.2;
            var kits = config.kits.Where(kit => HasPermission(player.UserIDString, kit.permission)).ToList();
            
            var container = new CuiElementContainer
            {
                new CuiElement // Main Panel
                {
                    Name = elemMain,
                    Parent = elemHud,
                    Components =
                    {
                        new CuiButtonComponent {Color = "1 1 1 0"},
                        new CuiRectTransformComponent {AnchorMin = "0.2 0.2", AnchorMax = "0.8 0.7"}
                    }
                }
            };
            
            for (var i = 0; i < kits.Count; i++)
            {
                if (i != 0 && i % 5 == 0)
                {
                    x = -0.1;
                    y -= sizeY + 0.05;
                }

                var kit = kits[i];
                var id = kit.name;
                var cooldown = GetCooldown(player.userID, kit.name, kit.cooldown);
                var mask = lang.GetMessage(cooldown > 0 ? "GUI OFF" : "GUI ON", this, player.UserIDString);
                var cooldownText = string.Format(mask, GetTimeString(cooldown));

                if (string.IsNullOrEmpty(kit.url))
                {
                    container.Add(new CuiElement
                    {
                        Name = id,
                        Parent = elemMain,
                        Components =
                        {
                            new CuiImageComponent
                            {
                                Color = "0.25 0.25 0.25 0.5"
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = $"{x} {y}",
                                AnchorMax = $"{x + sizeX} {y + sizeY}"
                            }
                        }
                    });
                }
                else
                {
                    container.Add(new CuiElement
                    {
                        Name = id,
                        Parent = elemMain,
                        Components =
                        {
                            new CuiRawImageComponent
                            {
                                Png =  GetImage(id),
                                Color = "1 1 1 1"
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = $"{x} {y}",
                                AnchorMax = $"{x + sizeX} {y + sizeY}"
                            }
                        }
                    });
                }

                container.Add(new CuiElement // Kit name
                {
                    Parent = id,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = kit.displayName,
                            Align = TextAnchor.MiddleCenter,
                            Color = "1 1 1 1",
                            FontSize = 15
                        },
                        new CuiOutlineComponent
                        {
                            Color = outlineColor,
                            Distance = outlineDistance
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0.7",
                            AnchorMax = "1 0.95"
                        }
                    }
                });
                
                container.Add(new CuiElement // Info text
                {
                    Parent = id,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = "????",
                            Align = TextAnchor.UpperRight,
                            Color = "1 1 1 1",
                            FontSize = 15
                        },
                        new CuiOutlineComponent
                        {
                            Color = outlineColor,
                            Distance = outlineDistance
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0.5",
                            AnchorMax = "0.95 0.95"
                        }
                    }
                });

                container.Add(new CuiElement // Cooldown
                {
                    Parent = id,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text  = cooldownText,
                            Align = TextAnchor.LowerCenter  
                        },
                        new CuiOutlineComponent
                        {
                            Color = outlineColor,
                            Distance = outlineDistance
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0.03",
                            AnchorMax = "1 0.5"
                        }
                    }
                });
                
                container.Add(new CuiElement // Info button
                {
                    Parent = id,
                    Components =
                    {
                        new CuiButtonComponent
                        {
                            Command = $"{config.command} info {kit.name}",
                            Color = "1 1 1 0"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0.77",
                            AnchorMax = "1 1"
                        }
                    }
                });
                
                container.Add(new CuiElement // Get button
                {
                    Parent = id,
                    Components =
                    {
                        new CuiButtonComponent
                        {
                            Command = $"{config.command} {kit.name}",
                            Color = "1 1 1 0"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 0.77"
                        }
                    }
                });

                x += sizeX + 0.02;
            }
            
            CuiHelper.DestroyUi(player, elemMain);
            CuiHelper.AddUi(player, container);
        }

        private void ShowInfo(BasePlayer player, string name)
        {
            if (ImageLibrary == null)
            {
                message(player, "ImageLibrary");
                return;
            }
            
            var kit = GetKit(name);
            if (kit == null) {return;}
            
            var container = new CuiElementContainer
            {
                new CuiElement // Hud
                {
                    Name = elemInfo,
                    Parent = "Hud.Menu",
                    Components =
                    {
                        new CuiButtonComponent
                        {
                            Color = "0.25 0.25 0.25 0.75",
                            Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat",
                            Close = elemInfo
                        },
                        new CuiRectTransformComponent 
                        {
                            AnchorMin = "0 0", 
                            AnchorMax = "1 1"
                        }
                    }
                },
                new CuiElement // Name
                {
                    Parent = elemInfo,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = kit.displayName.ToUpper(),
                            Color = "1 1 1 1",
                            FontSize = 30,
                            Align = TextAnchor.MiddleCenter
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.0 0.7", 
                            AnchorMax = "1 1"
                        }
                    }
                },
                new CuiElement // Info
                {
                    Parent = elemInfo,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = $"{kit.description}\n" +
                                   $"Перезарядка {GetTimeString(kit.cooldown)}\n" +
                                   (kit.uses == 0 ? "" : $"Uses {kit.uses}"),
                            Color = "1 1 1 1",
                            FontSize = 15,
                            Align = TextAnchor.MiddleCenter
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.0 0.7", 
                            AnchorMax = "1 0.8"
                        }
                    }
                }
            };

            var x = 0.3;
            var y = 0.6;
            var sizeX = 0.05;
            var sizeY = 0.08;
            var items = kit.items; 

            for (var i = 0; i < items.Count; i++)
            {
                if (i != 0 && i % 8 == 0)
                {
                    x = 0.3;
                    y -= sizeY + 0.01;
                }

                var item = items[i];

                container.Add(new CuiElement
                {
                    Parent = elemInfo,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0.5 0.5 0.5 0.75"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = $"{x} {y}",
                            AnchorMax = $"{x + sizeX} {y + sizeY}"
                        }
                    }
                });
                
                container.Add(new CuiElement
                {
                    Parent = elemInfo,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Png = GetImage(item.shortname)
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = $"{x} {y}",
                            AnchorMax = $"{x + sizeX} {y + sizeY}"
                        }
                    }
                });
                
                container.Add(new CuiElement
                {
                    Parent = elemInfo,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = $"x {item.amount}",
                            Align = TextAnchor.LowerRight
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = $"{x} {y}",
                            AnchorMax = $"{x + sizeX} {y + sizeY}"
                        }
                    }
                });

                x += sizeX + 0.005;
            }

            CuiHelper.DestroyUi(player, elemInfo);
            CuiHelper.AddUi(player, container);
        }

        #endregion
    }
}

// --- End of file: Kits1.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/EnhancedBanSystem.cs ---
// --- Original Local Path: EnhancedBanSystem.cs ---

using System.Collections.Generic;
using System;
using System.Reflection;
using System.Data;
using System.Linq;
using UnityEngine;
using Facepunch;
using Oxide.Core;
using Oxide.Core.Plugins;
using Rust;

namespace Oxide.Plugins
{
    [Info("Enhanced Ban System", "Domestos & Reneb", "3.0.8", ResourceId = 693)]
    class EnhancedBanSystem : RustPlugin
    {
        [PluginReference]
        Plugin PlayerDatabase;

        static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        static double LogTime() { return DateTime.UtcNow.Subtract(epoch).TotalSeconds; }

        ////////////////////////////////////////////////////////////
        // Oxide Hooks
        ////////////////////////////////////////////////////////////

        void Loaded()
        {
            LoadData();
            UpdateBannedIPs();
            if (!permission.PermissionExists(PermissionBan)) permission.RegisterPermission(PermissionBan, this);
            if (!permission.PermissionExists(PermissionBanCheck)) permission.RegisterPermission(PermissionBanCheck, this);
            if (!permission.PermissionExists(PermissionKick)) permission.RegisterPermission(PermissionKick, this);
        }
        void Unload()
        {
            SaveData();
        }
        object CanClientLogin(Network.Connection connection)
        {
            string ipaddress = connection.ipaddress.Substring(0, connection.ipaddress.IndexOf(":"));
            string userid = connection.userid.ToString();
            string reason = string.Empty;
            if (banLogs[userid] != null)
                if(!CanConnect(banLogs[userid], connection, out reason))
                {
                    return reason;
                }
            if(bannedIPs[ipaddress] != null)
                if(!CanConnect(bannedIPs[ipaddress], connection, out reason))
                {
                    return reason;
                }
            return null;
        }

        bool CanConnect(BanData bandata, Network.Connection connection, out string reason)
        {
            reason = string.Empty;
            string ipaddress = connection.ipaddress.Substring(0, connection.ipaddress.IndexOf(":"));
            string userid = connection.userid.ToString();

            if (bandata.steamID == ipaddress)
            {
                string reason2 = bandata.reason;
                int duration = bandata.expiration == 0 ? 0 : Convert.ToInt32(Time.time) - bandata.expiration;
                UnbanIP(null, ipaddress);
                BanID(null, connection.userid, reason2, duration);
                bandata = banLogs[userid];
            }
            if (bandata.expiration != 0 && Convert.ToInt32(LogTime()) >= bandata.expiration)
            {
                Unban(null, userid);
            }
            else
            {
                if (!bandata.IPs.Contains(ipaddress)) { AddIPToUserBan(userid, ipaddress); }
                if (banLogs[userid] == null) { BanID(null, connection.userid, bandata.reason, bandata.expiration == 0 ? 0 : Convert.ToInt32(Time.time) - bandata.expiration); }
                reason = bandata.expiration == 0 ? MessageDenyConnection : MessageDenyConnectionTemp;
                return false;
            }
            return true;
        }

        ////////////////////////////////////////////////////////////
        // Log Management
        ////////////////////////////////////////////////////////////

        static StoredData storedData;
        static Hash<string, BanData> banLogs = new Hash<string, BanData>();
        static Hash<string, BanData> bannedIPs = new Hash<string, BanData>();

        void UpdateBannedIPs()
        {
            bannedIPs.Clear();
            foreach(KeyValuePair<string, BanData> pair in banLogs)
            {
                foreach(string ip in pair.Value.IPs)
                {
                    if (bannedIPs[ip] == null)
                        bannedIPs.Add(ip, pair.Value);
                }
            }
        }

        class StoredData
        {
            public HashSet<BanData> BanLogs = new HashSet<BanData>();
            public StoredData()
            {
            }
        }

        void OnServerSave()
        {
            SaveData();
        }

        void SaveData()
        {
            Interface.GetMod().DataFileSystem.WriteObject("EnhancedBanSystem", storedData);
        }

        void LoadData()
        {
            banLogs.Clear();
            try
            {
                storedData = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("EnhancedBanSystem");
            }
            catch
            {
                storedData = new StoredData();
            }
            foreach (var thelog in storedData.BanLogs)
            {
                banLogs[thelog.steamID] = thelog;
            }
        }

        public class BanData
        {
            public string steamID;
            public string reason;
            public string name;
            public List<string> IPs;
            public int expiration;

            public BanData() { }

            public BanData(string steamID, string reason, string name, string IP, int duration)
            {
                this.steamID = steamID;
                this.reason = reason;
                this.name = name;
                this.IPs = new List<string> { IP };
                if (duration < 1) this.expiration = 0;
                else
                {
                    this.expiration = Convert.ToInt32(LogTime()) + duration;
                }
            }
        }

        ////////////////////////////////////////////////////////////
        // Config Fields
        ////////////////////////////////////////////////////////////

        static bool BroadcastBans = true;
        static bool BroadcastUnbans = true;
        static bool BroadcastKicks = true;
        static bool LogToConsole = true;
        static string ChatName = "<color=orange>SERVER</color>";
        static string PermissionBan = "enhancedbansystem.ban";
        static string PermissionKick = "enhancedbansystem.kick";
        static string PermissionBanCheck = "enhancedbansystem.bancheck";
        static string MessageKick = "An admin kicked you for {0}";
        static string MessageKickBroadcast = "{0} was kicked from the server for {1}";
        static string MessageBan = "An admin banned you for {0}";
        static string MessageBanBroadcast = "An admin banned {0} from the server for {1}";
        static string MessageDenyConnection = "You are banned on this server";
        static string MessageDenyConnectionTemp = "You are temp-banned on this server";
        static string MessageBanCheck = "Use /bancheck to check if and for how long someone is banned";
        static string DefaultBanReason = "Hacking";
        static string MessageNoPlayerFound = "No player found";
        ////////////////////////////////////////////////////////////
        // Config Management
        ////////////////////////////////////////////////////////////

        protected override void LoadDefaultConfig() { }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }
        private void CheckCfgFloat(string Key, ref float var)
        {

            if (Config[Key] != null)
                var = Convert.ToSingle(Config[Key]);
            else
                Config[Key] = var;
        }

        void Init()
        {
            CheckCfg<bool>("Ban - Broadcast Chat", ref BroadcastBans);
            CheckCfg<string>("Ban - permission", ref PermissionBan);
            CheckCfg<string>("Ban - Message - Player", ref MessageBan);
            CheckCfg<string>("Ban - Message - Broadcast", ref MessageBanBroadcast);
            CheckCfg<string>("Ban - Message - Deny Connection - Permanent", ref MessageDenyConnection);
            CheckCfg<string>("Ban - Message - Deny Connection - Temp", ref MessageDenyConnectionTemp);
            CheckCfg<string>("Ban - Default Ban Reason", ref DefaultBanReason);

            CheckCfg<bool>("Kick - Broadcast Chat", ref BroadcastKicks);
            CheckCfg<string>("Kick - permission", ref PermissionKick);
            CheckCfg<string>("Kick - Message - Player", ref MessageKick);
            CheckCfg<string>("Kick - Message - Broadcast", ref MessageKickBroadcast);

            CheckCfg<bool>("Unban - Broadcast Chat", ref BroadcastUnbans);
            CheckCfg<string>("Setting - Chat Name", ref ChatName);
            CheckCfg<string>("Setting - Message - No Player Found", ref MessageNoPlayerFound);
            SaveConfig();
        }

        ////////////////////////////////////////////////////////////
        // External Hooks Functions
        ////////////////////////////////////////////////////////////
        List<string> BannedPlayers()
        {
            var banlist = new List<string>();
            foreach (KeyValuePair<string, BanData> pair in banLogs) { banlist.Add(pair.Key); }
            return banlist;
        }
        Dictionary<string, object> GetBanData(ulong userid)
        {
            return GetBanData(userid.ToString());
        }
        Dictionary<string, object> GetBanData(string target)
        {
            var bandataa = new Dictionary<string, object>();
            if (banLogs[target] != null)
            {
                bandataa.Add("name", banLogs[target].name);
                bandataa.Add("steamID", banLogs[target].steamID);
                bandataa.Add("reason", banLogs[target].reason);
                bandataa.Add("IPs", banLogs[target].IPs);
                bandataa.Add("expiration", banLogs[target].expiration);
            }
            else
            {
                if(bannedIPs[target] != null)
                {
                    BanData bdata = bannedIPs[target];
                    bandataa.Add("name", bdata.name);
                    bandataa.Add("steamID", bdata.steamID);
                    bandataa.Add("reason", bdata.reason);
                    bandataa.Add("IPs", bdata.IPs);
                    bandataa.Add("expiration", bdata.expiration);
                }
            }
            return bandataa;
        }

        ////////////////////////////////////////////////////////////
        // Random Functions
        ////////////////////////////////////////////////////////////
        bool hasPermission(BasePlayer player, string permissionName)
        {
            if (player.net.connection.authLevel > 1) return true;
            return permission.UserHasPermission(player.userID.ToString(), permissionName);
        }

        private object FindPlayer(string arg)
        {
            ulong steamidParsed;
            if (arg.Length == 17 && ulong.TryParse(arg, out steamidParsed))
                return steamidParsed;

            if (PlayerDatabase != null)
            {
                string success = PlayerDatabase.Call("FindPlayer", arg) as string;
                if (success.Length == 17)
                    return ulong.Parse(success);
                else
                    return success;
            }
            else
            {
                List<BasePlayer> foundPlayers = new List<BasePlayer>();
                string argLower = arg.ToLower();
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    if (player.displayName.ToLower().Contains(argLower))
                        foundPlayers.Add(player);
                }
                foreach (BasePlayer player in BasePlayer.sleepingPlayerList)
                {
                    if (player.displayName.ToLower().Contains(argLower))
                        foundPlayers.Add(player);
                }
                if (foundPlayers.Count == 1)
                    return foundPlayers[0].userID;
                else if (foundPlayers.Count == 0)
                    return "Couldn't find a player that matches";
                else
                {
                    string msg = "Multiple players found:\n";
                    foreach(BasePlayer player in foundPlayers) { msg += string.Format("{0} {1}\n", player.userID.ToString(), player.displayName); }
                    return msg;
                }
            }
        }
        private object FindOnlinePlayer(string arg)
        {
            ulong steamidParsed = 0L;
            if (arg.Length == 17 && ulong.TryParse(arg, out steamidParsed)) {
                BasePlayer foundplayer = (BasePlayer)BasePlayer.Find(arg);
                if (foundplayer == null) return MessageNoPlayerFound;
                return foundplayer;
            }

            string argLower = arg.ToLower();
            List<BasePlayer> foundPlayers = new List<BasePlayer>();
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (player.displayName.ToLower().Contains(argLower))
                    foundPlayers.Add(player);
            }
            if (foundPlayers.Count == 1)
                return foundPlayers[0];
            else if (foundPlayers.Count == 0)
                return MessageNoPlayerFound;
            else
            {
                string msg = "Multiple players found:\n";
                foreach (BasePlayer player in foundPlayers) { msg += string.Format("{0} {1}\n", player.userID.ToString(), player.displayName); }
                return msg;
            }
        }
        
        void SendMessage(object source, string msg)
        {
            if (source is BasePlayer)
                SendReply((BasePlayer)source, msg);
            else if (source is ConsoleSystem.Arg)
                SendReply((ConsoleSystem.Arg)source, msg);
            else
                Debug.LogWarning(msg);
        }

        
        ////////////////////////////////////////////////////////////
        // show bans functions
        ////////////////////////////////////////////////////////////
        void ShowBans(object source, string[] args)
        {
            int startNum = 0;
            if (args != null && args.Length > 0)
                int.TryParse(args[0], out startNum);

            int current = 0;
            foreach(KeyValuePair<string, BanData> pair in banLogs)
            {
                if (current >= startNum)
                    SendMessage(source, string.Format("{0} - {1} - {2} - {3} {4}", current.ToString(), pair.Key, pair.Value.name, pair.Value.reason, pair.Value.expiration == 0 ? string.Empty : Convert.ToInt32(LogTime()) - pair.Value.expiration > 0 ? "- Expired" : "- "+ (pair.Value.expiration - Convert.ToInt32(LogTime())).ToString() + "s left"));
                current++;
            }
        }

        ////////////////////////////////////////////////////////////
        // Kick functions
        ////////////////////////////////////////////////////////////
        void TryKick(object source, string[] args)
        {
            if (args == null || args.Length < 1) { SendMessage(source, "Syntax: player.kick <name|steamID> <reason (optional)>"); return; }
            Kick(source, args[0], args.Length > 1 ? args[1] : DefaultBanReason);
        }
        void Kick(object source, string target, string reason)
        {
            var findplayer = FindOnlinePlayer(target);
            if (!(findplayer is BasePlayer)) { SendMessage(source, findplayer is string ? (string)findplayer : MessageNoPlayerFound); return; }
            ExecuteKick(source, (BasePlayer)findplayer, reason);
        }
        void ExecuteKick(object source, BasePlayer target, string reason)
        {
            SendMessage(source, string.Format("You've kicked {0}", target.displayName));
            if(BroadcastKicks)
                ConsoleSystem.Broadcast("chat.add", new object[] { 0, ChatName + " " + string.Format(MessageKickBroadcast, target.displayName, reason) });
            Network.Net.sv.Kick(target.net.connection, string.Format(MessageKick, reason));
        }
        ////////////////////////////////////////////////////////////
        // Ban IP functions
        ////////////////////////////////////////////////////////////

        static string ipPattern = @"\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b";
        static System.Text.RegularExpressions.Regex regex = new System.Text.RegularExpressions.Regex(ipPattern);
        void TryBanIP(object source, string[] args)
        {
            string target = args[0];
            string reason = args.Length > 1 ? args[1] : DefaultBanReason;
            int duration = 0;
            if (args.Length > 2)
                int.TryParse(args[2], out duration);
            BanIP(source, target, reason, duration);
        }
        Dictionary<string, string> FindPlayersByIP(string ipaddress)
        {
            var listplayers = new Dictionary<string, string>();
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (player.net.connection.ipaddress.Substring(0, player.net.connection.ipaddress.IndexOf(":")) == ipaddress)
                {
                    string steamid = player.userID.ToString();
                    string name = player.displayName;
                    if(!listplayers.ContainsKey(steamid))
                        listplayers.Add(steamid, name);
                }
            }
            if (PlayerDatabase != null)
            {
                var playerLists = (PlayerDatabase.Call("GetAllKnownPlayers") as HashSet<string>).ToList();
                foreach (string playerid in playerLists)
                {
                    var lips = PlayerDatabase.Call("GetPlayerData", playerid, "IPs") as Dictionary<string, object>;
                    if (lips != null)
                    {
                        foreach (KeyValuePair<string, object> pair in lips)
                        {
                            if (pair.Value.ToString() == ipaddress)
                            {
                                string steamid = playerid;
                                string name = "Unknown";
                                var playerdata = (PlayerDatabase.Call("GetPlayerData", playerid, "default") as Dictionary<string, object>);
                                if (playerdata != null)
                                    if (playerdata["name"] != null)
                                        name = playerdata["name"] as string;
                                if (!listplayers.ContainsKey(steamid))
                                    listplayers.Add(steamid, name);
                            }
                        }
                    }
                }
            }
            return listplayers;
        }
        void RawBanIP(object source, string ipaddress, string reason, int duration)
        {

            BanData bandata = new BanData(ipaddress, reason, "Unknown", ipaddress, duration);
            if (banLogs[ipaddress] != null)
                storedData.BanLogs.Remove(banLogs[ipaddress]);
            banLogs[ipaddress] = bandata;
            storedData.BanLogs.Add(banLogs[ipaddress]);
            SendMessage(source, string.Format("{0} was banned from the server for {1}", ipaddress.ToString(), reason));
            UpdateBannedIPs();
            SaveData();
        }
        void AddIpToBan(object source, string targetID, string ipaddress)
        {
            if (banLogs[targetID] == null) return;

            foreach (string ip in banLogs[targetID].IPs)
            {
                if (ip == ipaddress)
                {
                    SendMessage(source, string.Format("This ip adress is already banned in {0} - {1} for {2}", targetID, banLogs[targetID].name, banLogs[targetID].reason));
                    return;
                }
            }
            storedData.BanLogs.Remove(banLogs[targetID]);
            banLogs[targetID].IPs.Add(ipaddress);
            SendMessage(source, string.Format("This ip adress was added to the ban of {0} - {1} for {2}", targetID, banLogs[targetID].name, banLogs[targetID].reason));
            storedData.BanLogs.Add(banLogs[targetID]);
            SaveData();
        }
        void BanIP(object source, string ipaddress, string reason, int duration)
        {
            string targetName = string.Empty;
            string targetID = string.Empty;
            var players = FindPlayersByIP(ipaddress);
            if(players.Count == 0)
            {
                RawBanIP(source, ipaddress, reason, duration);
                return;
            }
            foreach(KeyValuePair<string,string> pair in players)
            {
                targetID = pair.Key;
                targetName = pair.Value;
                if (banLogs[targetID] == null)
                    ExecuteBan(source, targetID, targetName, ipaddress, reason, duration);
                else
                    AddIpToBan(source, targetID, ipaddress);
            }
            List<BasePlayer> targetkick = new List<BasePlayer>();
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (ipaddress == player.net.connection.ipaddress.Substring(0, player.net.connection.ipaddress.IndexOf(":")))
                    targetkick.Add(player);
            }
            for (int i = 0; i < targetkick.Count; i++)
            {
                Network.Net.sv.Kick(targetkick[i].net.connection, string.Format(MessageBan, reason));
            }
            SaveData();
        }

        bool IsBannedIP(string arg)
        {
            if (bannedIPs[arg] != null) return true;
            return false;
        }
        bool IsBannedUser(ulong userid)
        {
            if (banLogs[userid.ToString()] != null)
                return true;
            return false;
        }
        void AddIPToUserBan(string userid, string ipaddress)
        {
            storedData.BanLogs.Remove(banLogs[userid]);
            banLogs[userid].IPs.Add(ipaddress);
            storedData.BanLogs.Add(banLogs[userid]);
            SaveData();
            UpdateBannedIPs();
        }
        ////////////////////////////////////////////////////////////
        // Unban IP functions
        ////////////////////////////////////////////////////////////

        void UnbanIP(object source, string ipaddress)
        {
            List<string> targetNames = new List<string>();
            List<string> targetIDs = new List<string>();
            bool unbanned = false;

            List<string> unbanip = new List<string>();
            foreach(BanData bdata in banLogs.Values)
            {
                if (bdata.IPs.Contains(ipaddress))
                    unbanip.Add(bdata.steamID);
            }
            foreach(string steamid in unbanip)
            {
                unbanned = true;
                Unban(source, steamid);
            }
            if (banLogs[ipaddress] != null)
            {
                unbanned = true;
                Unban(source, ipaddress);
            }
            if(!unbanned)
                SendMessage(source, "No matchs were found");
        }
        ////////////////////////////////////////////////////////////
        // Ban functions
        ////////////////////////////////////////////////////////////
        void TryBan(object source, string[] args)
        {
            if (args == null || args.Length < 1) { SendMessage(source, "Syntax: player.ban <name|steamID|IP> <reason (optional)> <time in seconds (optional)>"); return; }

            string target = args[0];
            if (regex.IsMatch(target)) { TryBanIP(source, args); return; }

            string reason = args.Length > 1 ? args[1] : DefaultBanReason;

            int duration = 0;
            if (args.Length > 2) int.TryParse(args[2], out duration);

            var findplayer = FindPlayer(args[0]);
            if (!(findplayer is ulong))
            {
                SendMessage(source, findplayer is string ? (string)findplayer : "Couldn't find a player that matches.");
                return;
            }
            if (banLogs[findplayer.ToString()] != null)
            {
                SendMessage(source, "This player is already banned");
                return;
            }
            BanID(source, (ulong)findplayer, reason, duration);
        }

        void BanID(object sourcePlayer, ulong targetID, string reason, int duration)
        {
            string targetName = string.Empty;
            string targetIP = string.Empty;
            string ipaddress = string.Empty;
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (player.userID == targetID)
                {
                    targetName = player.displayName;
                    targetIP = player.net.connection.ipaddress.Substring(0, player.net.connection.ipaddress.IndexOf(":"));
                    break;
                }
            }

            if (targetName == string.Empty || targetIP == string.Empty)
            {
                if (PlayerDatabase != null)
                {
                    var playerdata = (PlayerDatabase.Call("GetPlayerData", targetID.ToString(), "default") as Dictionary<string, object>);
                    if (playerdata != null)
                    {
                        if (playerdata.ContainsKey("name"))
                        {
                            targetName = playerdata["name"] as string;
                        }
                    }
                    var lips = PlayerDatabase.Call("GetPlayerData", targetID.ToString(), "IPs") as Dictionary<string, object>;
                    if (lips != null)
                    {
                        if (lips.ContainsKey("0"))
                        {
                            targetIP = lips["0"] as string;
                        }
                    }
                }
                else
                {
                    foreach (BasePlayer player in BasePlayer.sleepingPlayerList)
                    {
                        if (player.userID == targetID)
                        {
                            targetName = player.displayName;
                            targetIP = "0";
                            break;
                        }
                    }
                }
            }
            if (targetName == string.Empty)
            {
                targetName = "Unknown";
                targetIP = "0";
            }
            if(banLogs[targetIP] != null)
                UnbanIP(sourcePlayer, targetIP);
            ExecuteBan(sourcePlayer, targetID.ToString(), targetName, targetIP, reason, duration);
        }
        void Ban(object sourcePlayer, BasePlayer player, string reason, object duration)
        {
            BanID(sourcePlayer, player.userID, reason, duration is int ? (int)duration : 0);
        }
        void ExecuteBan(object sourcePlayer, string targetID, string targetName, string targetIP, string reason, int duration)
        {
            BanData bandata = new BanData(targetID, reason, targetName, targetIP, duration);
            if (banLogs[targetID] != null)
                storedData.BanLogs.Remove(banLogs[targetID]);
            banLogs[targetID] = bandata;
            storedData.BanLogs.Add(banLogs[targetID]);
            SendMessage(sourcePlayer, string.Format("{0} - {1} was banned from the server for {2}", targetID, targetName, reason));
            if(BroadcastBans)
            {
                ConsoleSystem.Broadcast("chat.add", new object[] { 0, ChatName + " " + string.Format(MessageBanBroadcast, targetName, reason) });
            }
            List<BasePlayer> targetkick = new List<BasePlayer>();
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (player.userID.ToString() == targetID)
                    targetkick.Add(player);
            }
            for (int i = 0; i < targetkick.Count; i++)
            {
                Network.Net.sv.Kick(targetkick[i].net.connection, string.Format(MessageBan, reason));
            }
            UpdateBannedIPs();
            SaveData();
        }
        void CheckBan(object sourcePlayer, string[] args)
        {
            if (args == null || args.Length < 1)
            {
                SendMessage(sourcePlayer, "Syntax: player.checkban <name|steamID|ip>");
                return;
            }
            string target = args[0].ToLower();
            Dictionary<string, object> bdata = new Dictionary<string, object>();

            var tempdata = GetBanData(target);
            if(tempdata.Count != 0)
                bdata = tempdata;

            if(bdata.Count == 0)
            {
                object findplayer = FindPlayer(target);
                if (findplayer is ulong)
                {
                    var tdata = GetBanData((ulong)findplayer);
                    if (tdata.Count != 0)
                        bdata = tempdata;
                }
            }

            if(bdata.Count == 0)
            {
                List<BanData> foundBanData = new List<BanData>();
                foreach (KeyValuePair<string, BanData> pair in banLogs)
                {
                    if (pair.Value.name.ToLower().Contains(target) || pair.Value.IPs.Contains(target))
                        foundBanData.Add(pair.Value);
                }
                if(foundBanData.Count > 1)
                {
                    string msg = "Multiple bans found:\n";
                    foreach (BanData bbdata in foundBanData) { msg += string.Format("{0} {1}\n", bbdata.steamID, bbdata.name); }
                    SendMessage(sourcePlayer, msg);
                    return;
                }
                if(foundBanData.Count == 1)
                {
                    bdata.Add("name", foundBanData[0].name);
                    bdata.Add("steamID", foundBanData[0].steamID);
                    bdata.Add("reason", foundBanData[0].reason);
                    bdata.Add("IPs", foundBanData[0].IPs);
                    bdata.Add("expiration", foundBanData[0].expiration);
                }
            }

            if(bdata.Count == 0)
            {
                SendMessage(sourcePlayer, string.Format("No players found matching {0}", args[0]));
                return;
            }

            if ((int)bdata["expiration"] == 0)
            {
                SendMessage(sourcePlayer, string.Format("{1} {0} is permanently banned for {2}", (string)bdata["name"], (string)bdata["steamID"], (string)bdata["reason"]));
            }
            else if (Convert.ToInt32(LogTime()) >= (int)bdata["expiration"])
            {
                SendMessage(sourcePlayer, string.Format("{1} {0} ban expired ({2})", (string)bdata["name"], (string)bdata["steamID"], (string)bdata["reason"]));
            }
            else
            {
                SendMessage(sourcePlayer, string.Format("{1} {0} is temporarly banned for {2}", (string)bdata["name"], (string)bdata["steamID"], (string)bdata["reason"]));
            }
        }

        ////////////////////////////////////////////////////////////
        // Unban functions
        ////////////////////////////////////////////////////////////
        void TryUnban(object source, string[] args)
        {
            if (args == null || args.Length < 1)
            { 
                return;
            }
            string target = args[0];
            if (regex.IsMatch(target))
            {
                UnbanIP(source, target);
                return;
            }
            object findban = FindBanLog(target);
            if (!(findban is ulong))
            {
                SendMessage(source, findban is string ? (string)findban : "Couldn't find a ban that matches.");
                return;
            }
            Unban(source, (ulong)findban);
        }
        object FindBanLog(string arg)
        {
            string argLower = arg.ToLower();
            if (banLogs[arg] != null)
                return ulong.Parse(arg);

            string foundNames = string.Empty;
            ulong foundBandata = 0L;
            bool multipleBans = false;
            foreach (KeyValuePair<string, BanData> pair in banLogs)
            {
                if (pair.Value.name.ToLower().Contains(argLower))
                {
                    if (foundBandata == 0L)
                    {
                        foundBandata = ulong.Parse(pair.Key);
                        foundNames += string.Format("{0} {1}\n", pair.Key, pair.Value.name);
                    }
                    else
                    {
                        multipleBans = true;
                        foundNames += string.Format("- {0} {1}\n", pair.Key, pair.Value.name);
                    }
                }
            }
            if (multipleBans)
                return foundNames;
            if (foundBandata == 0L)
                return "No ban found";
            return foundBandata;
        }
        void Unban(object source, string targetID)
        {
            if (banLogs[targetID] == null)
                SendMessage(source, string.Format("{0} isn't banned", targetID));
            else
            {
                string name = banLogs[targetID].name;
                DeleteBan(targetID);
                SendMessage(source, string.Format("{0} - {1} was unbanned from the server.", targetID, name));

                if(BroadcastUnbans)
                    ConsoleSystem.Broadcast("chat.add", new object[] { 0, ChatName + " " + string.Format("{0} - {1} was unbanned from the server.", targetID, name) });
            }
        }
        void DeleteBan(string targetID)
        {
            storedData.BanLogs.Remove(banLogs[targetID]);
            banLogs[targetID] = null;
            banLogs.Remove(targetID);
            SaveData();
            UpdateBannedIPs();
        }
        void Unban(object source, ulong targetID)
        {
            Unban(source, targetID.ToString());
        }
        ////////////////////////////////////////////////////////////
        // Chat commands
        ////////////////////////////////////////////////////////////
        [ChatCommand("ban")]
        void cmdChatBan(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player, PermissionBan))
            {
                SendReply(player, "You dont have access to this command");
                return;
            }
            TryBan(player, args);
        }
        [ChatCommand("kick")]
        void cmdChatKick(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player, PermissionKick))
            {
                SendReply(player, "You dont have access to this command");
                return;
            }
            TryKick(player, args);
        }
        [ChatCommand("unban")]
        void cmdChatUnban(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player, PermissionBan))
            {
                SendReply(player, "You dont have access to this command");
                return;
            }
            TryUnban(player, args);
        }
        
        [ChatCommand("checkban")]
        void cmdChatCheckBan(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player, PermissionBanCheck))
            {
                SendReply(player, "You dont have access to this command");
                return;
            }
            CheckBan(player, args);
        }
        ////////////////////////////////////////////////////////////
        // Console Commands
        ////////////////////////////////////////////////////////////
        [ConsoleCommand("player.ban")]
        void cmdConsolePlayerBan(ConsoleSystem.Arg arg)
        {
            if (arg.connection != null)
            {
                if (!hasPermission(arg.Player(), PermissionBan))
                {
                    SendReply(arg, "You dont have access to this command");
                    return;
                }
            }
            TryBan(arg, arg.Args);
        }
        
        [ConsoleCommand("player.checkban")]
        void cmdConsolePlayerCheckBan(ConsoleSystem.Arg arg)
        {
            if (arg.connection != null)
            {
                if (!hasPermission(arg.Player(), PermissionBanCheck))
                {
                    SendReply(arg, "You dont have access to this command");
                    return;
                }
            }
            CheckBan(arg, arg.Args);
        }
        [ConsoleCommand("player.kick")]
        void cmdConsolePlayerKick(ConsoleSystem.Arg arg)
        {
            if (arg.connection != null)
            {
                if (!hasPermission(arg.Player(), PermissionKick))
                {
                    SendReply(arg, "You dont have access to this command");
                    return;
                }
            }
            TryKick(arg, arg.Args);
        }
        [ConsoleCommand("player.unban")]
        void cmdConsolePlayerUnban(ConsoleSystem.Arg arg)
        {
            if (arg.connection != null)
            {
                if (!hasPermission(arg.Player(), PermissionBan))
                {
                    SendReply(arg, "You dont have access to this command");
                    return;
                }
            }
            TryUnban(arg, arg.Args);
        }
        [ConsoleCommand("player.banlist")]
        void ccmdPlayerBanlist(ConsoleSystem.Arg arg)
        {
            if (arg.connection != null)
            {
                if (!hasPermission(arg.Player(), PermissionBanCheck))
                {
                    SendReply(arg, "You dont have access to this command");
                    return;
                }
            }
            ShowBans(arg, arg.Args);
        }
        [ConsoleCommand("ebs.import")]
        void ccmdEBSImport(ConsoleSystem.Arg arg)
        {
            if (arg.connection != null)
            {
                SendReply(arg, "You can only use this command from the server console");
                return;
            }
            var ebslist = Interface.Oxide.DataFileSystem.GetFile("ebsbanlist") as Oxide.Core.Configuration.DynamicConfigFile;
            foreach (KeyValuePair<string, object> pair in ebslist)
            {
                if (pair.Key == null) continue;
                if (pair.Value == null) continue;
                if (banLogs[pair.Key] != null) continue;
                var playerbanlistdata = pair.Value as Dictionary<string, object>;
                if (playerbanlistdata == null) continue;
                ExecuteBan(null, playerbanlistdata["steamID"].ToString(), playerbanlistdata["name"].ToString(), playerbanlistdata["IP"].ToString(), playerbanlistdata["reason"].ToString(), 0);
            }
            SaveData();
        }
    }
}


// --- End of file: EnhancedBanSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ComponentBox.cs ---
// --- Original Local Path: ComponentBox.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("ComponentBox", "TopPlugin.ru", "2.0.2"), Description("Allows players to store components in a secondary container carried in their inventory")]
    class ComponentBox : RustPlugin
    {
        #region Fields
        private const int PRESENT_ITEM_ID = -1622660759;
        private const ulong PRESENT_SKIN_ID = 1526403462;

        private const string PERMISSION_USE = "componentbox.use";
        #endregion

        #region Oxide Hooks     
        protected override void LoadDefaultMessages() => lang.RegisterMessages(Messages, this);

        private void OnServerInitialized()
        {
            permission.RegisterPermission(PERMISSION_USE, this);

            foreach (ConfigData.CraftingSettings.CraftItem craftItem in Configuration.Crafting.Cost)
                craftItem.Validate();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
                return;

            if (!Configuration.Crafting.RequiresCrafting)
            {
                IEnumerable<Item> items = FindComponentBoxes(player);
                if (items.Count() > 0)
                {
                    SetupComponentBoxes(items);
                    return;
                }

                GiveComponentBox(player);
            }
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            timer.In(1f, () =>
            {
                if (player == null)
                    return;

                if (!permission.UserHasPermission(player.UserIDString, PERMISSION_USE) || Configuration.Crafting.RequiresCrafting)
                    return;

                IEnumerable<Item> items = FindComponentBoxes(player);
                if (items.Count() > 0)
                {
                    SetupComponentBoxes(items);
                    return;
                }

                if (!Configuration.Crafting.RequiresCrafting)
                    timer.In(1f, () => GiveComponentBox(player));
            });            
        }

        private void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if (player == null)            
                return;

            if (!Configuration.LeaveOnCorpse)
                DropComponentBoxItems(player);
        }
        #endregion

        #region Item Management
        private object OnItemAction(Item item, string action, BasePlayer player)
        {
            if (item == null || player == null)      
                return null;

            if (item.skin == PRESENT_SKIN_ID)
            {
                const string UNWRAP = "unwrap";
                const string DROP = "drop";

                if (action.Equals(UNWRAP, StringComparison.OrdinalIgnoreCase))
                {
                    if (player.inventory.loot.itemSource == item)
                        return false;

                    BeginLootingComponentBox(player, item, true);

                    Interface.CallHook("OnLootItem", player, item);
                    player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", "generic");
                    return false;
                }
                else if (action.Equals(DROP, StringComparison.OrdinalIgnoreCase))
                {
                    if (!Configuration.IsDroppable)
                    {
                        Message(player, "Error.CantDrop");
                        return false;
                    }
                }
            }

            return null;
        }
       
        private object OnItemPickup(Item item, BasePlayer player)
        {
            if (item == null || player == null)
                return null;

            if (item.skin == PRESENT_SKIN_ID)
            {
                if (!permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
                {
                    Message(player, "Error.NoCarryPermission");
                    BeginLootingComponentBox(player, item, false);
                    return false;
                }

                if (Configuration.LimitCarryAmount)
                {
                    if (FindComponentBoxes(player).Count() > 0)
                    {
                        Message(player, "Error.HaveToolbox");
                        BeginLootingComponentBox(player, item, false);
                        return false;
                    }
                }
            }

            if (Configuration.DepositAutomatically && Configuration.Items.CanAcceptItem(item))
            {
                foreach (Item componentBox in FindComponentBoxes(player))
                {
                    int amountMoved = item.amount;

                    if (!item.CanMoveTo(componentBox.contents))
                        continue;

                    if (!componentBox.contents.CanAccept(item))
                        continue;

                    WorldItem worldItem = item.GetWorldEntity() as WorldItem;
                    worldItem.RemoveItem();
                    worldItem.ClientRPC(null, "PickupSound");

                    if (!item.MoveToContainer(componentBox.contents))
                    {
                        item.Drop(componentBox.contents.dropPosition, componentBox.contents.dropVelocity, default(Quaternion));
                        continue;
                    }
                    
                    player.Command("note.inv", item.info.itemid, amountMoved, string.IsNullOrEmpty(item.name) ? null : item.name, BasePlayer.GiveItemReason.PickedUp);
                    player.SignalBroadcast(BaseEntity.Signal.Gesture, "pickup_item");
                    return false;
                }
            }
            return null;
        }       

        private object CanAcceptItem(ItemContainer container, Item componentBox, int target)
        {
            if (container == null || componentBox == null)           
                return null;
            
            if (componentBox != null && componentBox.skin == PRESENT_SKIN_ID)
            {
                if (componentBox.contents != null && componentBox.contents == container)
                    return ItemContainer.CanAcceptResult.CannotAccept;

                if (componentBox.parent != null)
                {
                    if (componentBox.parent.playerOwner == container.playerOwner)
                        return null;

                    if (componentBox.parent.playerOwner != null && componentBox.parent.playerOwner.IsDead() && container.entityOwner is BaseCorpse)
                        return null;
                }

                if (Configuration.LimitCarryAmount && container.playerOwner != null)
                {
                    BasePlayer player = container.playerOwner;
                    IEnumerable<Item> componentBoxes = FindComponentBoxes(player);

                    if (componentBoxes.Count() > 0)
                    {
                        MoveContentsToPlayer(componentBox, container.playerOwner, componentBoxes);
                        Message(container.playerOwner, "Notification.ContentsTaken");
                        return ItemContainer.CanAcceptResult.CannotAccept;
                    }
                }

                if (container.entityOwner != null)
                {
                    if (!Configuration.IsStorable || (componentBox.contents != null && componentBox.contents.itemList.Count > 0))
                    {
                        if (componentBox.parent != null && componentBox.parent.playerOwner != null)
                        {
                            Message(componentBox.parent.playerOwner, !Configuration.IsStorable ? "Error.CantStore" : "Error.ToolboxContents");
                            return ItemContainer.CanAcceptResult.CannotAccept;
                        }
                    }
                }

                if (container.playerOwner != null && !permission.UserHasPermission(container.playerOwner.UserIDString, PERMISSION_USE))
                {
                    Message(container.playerOwner, "Error.NoCarryPermission");
                    return ItemContainer.CanAcceptResult.CannotAccept;
                }
            }

            if (container != null && container.parent != null && container.parent.skin == PRESENT_SKIN_ID && container.parent.parent?.playerOwner == null)            
                return ItemContainer.CanAcceptResult.CannotAccept;
            
            return null;
        }

        private object CanMoveItem(Item movedItem, PlayerInventory inventory, uint targetContainerID, int targetSlot, int amount)
        {
            if (movedItem == null || inventory == null)
                return null;

            if (movedItem.skin == PRESENT_SKIN_ID)
            {
                if (targetSlot == -1)
                {
                    if (targetContainerID != 0)
                    {
                        ItemContainer targetContainer = inventory.FindContainer(targetContainerID);
                        if (targetContainer == movedItem.contents)
                            return false;

                        MoveContentsToPlayer(movedItem, inventory.baseEntity);
                        return false;
                    }
                    else
                    {
                        if (Configuration.LimitCarryAmount)
                        {
                            MoveContentsToPlayer(movedItem, inventory.baseEntity);
                            Message(inventory.baseEntity, "Notification.ContentsTaken");
                            return false;
                        }

                        return null;
                    }
                }
            }

            if (Configuration.DepositAutomatically)
            {
                if (Configuration.Items.CanAcceptItem(movedItem))
                {
                    if ((inventory.loot.entitySource is LootContainer || inventory.loot.entitySource is LootableCorpse || (inventory.loot.itemSource?.GetOwnerPlayer() != inventory.baseEntity && inventory.loot.itemSource?.skin == PRESENT_SKIN_ID)))
                    {
                        if (targetContainerID == 0 && targetSlot == -1)
                        {
                            foreach (Item box in FindComponentBoxes(inventory.baseEntity))
                            {
                                if (box != null && box.contents != null)
                                {
                                    if (movedItem.MoveToContainer(box.contents))
                                        return false;
                                }
                            }
                        }
                    }
                }
            }

            return null;
        } 
        #endregion

        #region Functions
        private void GiveComponentBox(BasePlayer player)
        {
            Item componentBox = ItemManager.CreateByItemID(PRESENT_ITEM_ID, 1, PRESENT_SKIN_ID);

            SetupComponentBox(componentBox);

            if (!componentBox.MoveToContainer(player.inventory.containerMain, player.inventory.containerMain.capacity - 1, false))
                player.GiveItem(componentBox);
        }

        private void SetupComponentBoxes(IEnumerable<Item> items)
        {
            foreach (Item componentBox in items)
                SetupComponentBox(componentBox);
        }

        private void SetupComponentBox(Item componentBox)
        {
            componentBox.name = "Component Box";

            if (componentBox.contents == null)
            {
                componentBox.contents = new ItemContainer();
                componentBox.contents.ServerInitialize(componentBox, Mathf.Clamp(Configuration.Slots, 1, 36));
                componentBox.contents.GiveUID();
            }
            else
            {
                if (componentBox.contents.capacity != Configuration.Slots)
                {
                    componentBox.contents.capacity = Mathf.Clamp(Configuration.Slots, 1, 36);
                    componentBox.contents.MarkDirty();
                }
            }

            componentBox.contents.allowedContents = ItemContainer.ContentsType.Generic;
            componentBox.contents.canAcceptItem = (Item item, int amount) => Configuration.Items.CanAcceptItem(item);
        }

        private IEnumerable<Item> FindComponentBoxes(BasePlayer player)
        {
            foreach (Item item in player.inventory.AllItems())
            {
                if (item.skin == PRESENT_SKIN_ID)                
                    yield return item;                
            }
        }

        private void BeginLootingComponentBox(BasePlayer player, Item item, bool isInInventory)
        {
            player.inventory.loot.Clear();
            player.inventory.loot.entitySource = RelationshipManager.ServerInstance;
            player.inventory.loot.PositionChecks = false;

            item.contents.onDirty += player.inventory.loot.MarkDirty;
            player.inventory.loot.itemSource = item;

            player.inventory.loot.AddContainer(item.contents);
            player.inventory.loot.SendImmediate();

            if (!isInInventory)
            {
                player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", "generic_resizable");
                player.SendNetworkUpdate();
            }
        }

        private void DropComponentBoxItems(BasePlayer player)
        {
            foreach (Item componentBox in FindComponentBoxes(player))
            {
                if (componentBox.contents == null)
                    continue;

                for (int i = componentBox.contents.itemList.Count - 1; i >= 0; i--)
                {
                    Item item = componentBox.contents.itemList[i];
                    if (item != null && !player.inventory.GiveItem(item))
                        break;
                }

                if (componentBox.contents.itemList.Count > 0)
                {
                    const string BACKPACK_PREFAB = "assets/prefabs/misc/item drop/item_drop_backpack.prefab";

                    DroppedItemContainer droppedItemContainer = ItemContainer.Drop(BACKPACK_PREFAB, player.transform.position, Quaternion.identity, componentBox.contents);
                    if (droppedItemContainer != null)
                    {
                        droppedItemContainer.playerName = player.displayName;
                        droppedItemContainer.playerSteamID = player.userID;
                    }
                }

                componentBox.RemoveFromContainer();
                componentBox.Remove();
            }
        }

        private void MoveContentsToPlayer(Item componentBox, BasePlayer player, IEnumerable<Item> componentBoxes = null)
        {
            if (componentBoxes == null)
                componentBoxes = FindComponentBoxes(player);

            if (componentBoxes.Count() > 0)
            {
                for (int i = componentBox.contents.itemList.Count - 1; i >= 0; i--)
                {
                    Item item = componentBox.contents.itemList[i];
                    if (item != null)
                    {
                        bool hasMoved = false;
                        foreach (Item box in componentBoxes)
                        {
                            if (box.contents != null && item.MoveToContainer(box.contents))
                            {
                                hasMoved = true;
                                break;
                            }
                        }

                        if (!hasMoved && !item.MoveToContainer(player.inventory.containerMain))
                            item.Drop(player.transform.position, player.eyes.BodyForward() * 1.5f, Quaternion.identity);
                    }
                }
            }
        }
        #endregion

        #region Commands
        [ConsoleCommand("toolbox")]
        private void CraftToolboxConsoleCommand(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player != null)            
                CraftToolboxCommand(player, arg.cmd.Name, arg.Args ?? Array.Empty<string>());            
        }

        [ChatCommand("toolbox")]
        private void CraftToolboxCommand(BasePlayer player, string command, string[] args)
        {
            switch (args.Length > 0 ? args[0] : "")
            {
                default:
                    {
                        Message(player, "Cmd.Format");
                        break;
                    }
                case "cost":
                    {
                        Message(player, "Craft.Cost", string.Join("\n", Configuration.Crafting.Requirements));
                        break;
                    }
                case "craft":
                    {                        
                        if (!permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
                        {
                            Message(player, "Cmd.Permission");
                            return;
                        }

                        if (!Configuration.Crafting.RequiresCrafting)
                        {
                            Message(player, "Craft.NotEnabled");
                            return;
                        }

                        if (FindComponentBoxes(player).Count() > 0)
                        {
                            Message(player, "Error.HaveToolbox");
                            return;
                        }

                        if (!Configuration.Crafting.CanAffordToCraft(player))
                            return;

                        Configuration.Crafting.PayCraftCost(player);

                        GiveComponentBox(player);

                        Message(player, "Craft.Crafted");
                        break;
                    }
                case "remove":
                    {
                        if (!Configuration.Crafting.RequiresCrafting)
                        {
                            Message(player, "Craft.NotEnabled");
                            return;
                        }

                        if (!permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
                        {
                            Message(player, "Cmd.Permission");
                            return;
                        }

                        int boxCount = FindComponentBoxes(player).Count();
                        if (boxCount == 0)
                        {
                            Message(player, "Destroy.NoToolbox");
                            return;
                        }

                        if (Configuration.Crafting.RefundOnDestroy)
                        {
                            for (int i = 0; i < boxCount; i++)
                                Configuration.Crafting.RefundCraftCost(player);
                        }

                        DropComponentBoxItems(player);

                        Message(player, "Destroy.Destroyed");
                        break;
                    }
            }
        }
        #endregion

        #region Config        
        private ConfigData Configuration;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Leave component box on corpse when player is killed")]
            public bool LeaveOnCorpse { get; set; }            

            [JsonProperty(PropertyName = "Automatically place allowed items in the component box when picked up")]
            public bool DepositAutomatically { get; set; }

            [JsonProperty(PropertyName = "Number of slots in the component box (1 - 36)")]
            public int Slots { get; set; }

            [JsonProperty(PropertyName = "Allow players to drop the component box")]
            public bool IsDroppable { get; set; }

            [JsonProperty(PropertyName = "Allow players to store the component box in other containers")]
            public bool IsStorable { get; set; }

            [JsonProperty(PropertyName = "Only allow players to carry 1 component box at a time")]
            public bool LimitCarryAmount { get; set; }


            [JsonProperty(PropertyName = "Crafting Settings")]
            public CraftingSettings Crafting { get; set; }

            [JsonProperty(PropertyName = "Item Settings")]
            public ItemSettings Items { get; set; }


            public class ItemSettings
            {
                [JsonProperty(PropertyName = "Allowed item categories")]
                public Hash<ItemCategory, bool> Categories { get; set; }

                [JsonProperty(PropertyName = "Blocked item shortnames")]
                public string[] BlockedItems { get; set; }

                [JsonProperty(PropertyName = "Allowed item shortnames")]
                public string[] AllowedItems { get; set; }

                public bool CanAcceptItem(Item item)
                {
                    if (AllowedItems.Contains(item.info.shortname))
                        return true;

                    return Categories[item.info.category] && !BlockedItems.Contains(item.info.shortname);
                }
            }


            public class CraftingSettings
            {
                [JsonProperty(PropertyName = "Require component box to be crafted")]
                public bool RequiresCrafting { get; set; }

                [JsonProperty(PropertyName = "Refund crafting cost when destroying the component box")]
                public bool RefundOnDestroy { get; set; }

                [JsonProperty(PropertyName = "Refund cost fraction (0.0 - 1.0)")]
                public float RefundPercentage { get; set; }

                [JsonProperty(PropertyName = "Cost to craft a component box")]
                public List<CraftItem> Cost { get; set; }


                [JsonIgnore]
                private IEnumerable<string> craftingRequirements;

                [JsonIgnore]
                public IEnumerable<string> Requirements
                {
                    get
                    {
                        if (craftingRequirements == null)
                            craftingRequirements = Cost.Where(x => x.IsValid).Select(x => x.CostString);
                        return craftingRequirements;
                    }
                }


                public bool CanAffordToCraft(BasePlayer player)
                {
                    foreach (CraftItem craftItem in Cost)
                    {
                        if (!craftItem.IsValid)
                            continue;

                        if (player.inventory.GetAmount(craftItem.ItemID) < craftItem.Amount)
                        {
                            player.ChatMessage($"You require {craftItem.CostString} to craft!");
                            return false;
                        }                                              
                    }

                    return true;
                }

                public void PayCraftCost(BasePlayer player)
                {
                    foreach (CraftItem craftItem in Cost)
                    {
                        if (!craftItem.IsValid)
                            continue;

                        player.inventory.Take(null, craftItem.ItemID, craftItem.Amount);
                    }
                }

                public void RefundCraftCost(BasePlayer player)
                {
                    foreach (CraftItem craftItem in Cost)
                    {
                        if (!craftItem.IsValid)
                            continue;

                        int amount = Mathf.RoundToInt((float)craftItem.Amount * Mathf.Clamp01(RefundPercentage));
                        if (amount > 0)
                            player.GiveItem(ItemManager.CreateByItemID(craftItem.ItemID, amount));
                    }
                }

                public class CraftItem
                {
                    public string Shortname { get; set; }

                    public int Amount { get; set; }

                    [JsonIgnore]
                    public int ItemID { get; set; }

                    [JsonIgnore]
                    public string CostString { get; private set; }

                    [JsonIgnore]
                    public bool IsValid { get; private set; }

                    public void Validate()
                    {
                        ItemDefinition itemDefinition = ItemManager.FindItemDefinition(Shortname);
                        if (itemDefinition == null)
                        {
                            Debug.LogError($"ComponentBox has a invalid item shortname as a crafting cost : {Shortname}");
                            return;
                        }

                        ItemID = itemDefinition.itemid;
                        CostString = $"{Amount} x {itemDefinition.displayName.english}";
                        IsValid = true;
                    }
                }
            }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Configuration = Config.ReadObject<ConfigData>();

            if (Configuration.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(Configuration, true);
        }

        protected override void LoadDefaultConfig() => Configuration = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Items = new ConfigData.ItemSettings
                {
                    Categories = new Hash<ItemCategory, bool>
                    {
                        [ItemCategory.All] = false,
                        [ItemCategory.Weapon] = false,
                        [ItemCategory.Construction] = false,
                        [ItemCategory.Items] = false,
                        [ItemCategory.Resources] = false,
                        [ItemCategory.Attire] = false,
                        [ItemCategory.Tool] = false,
                        [ItemCategory.Medical] = false,
                        [ItemCategory.Food] = false,
                        [ItemCategory.Ammunition] = false,
                        [ItemCategory.Traps] = false,
                        [ItemCategory.Misc] = false,
                        [ItemCategory.Component] = true,
                        [ItemCategory.Electrical] = false,
                        [ItemCategory.Fun] = false,
                    },
                    BlockedItems = new string[]
                    {
                        "explosive.timed",
                        "ammo.rocket.basic",
                        "ammo.rocket.smoke",
                        "ammo.rocket.hv",
                        "ammo.rocket.fire",
                        "explosives",
                        "gunpowder",
                        "grenade.f1",
                        "grenade.beancan",
                        "explosive.satchel",
                        "ammo.grenadelauncher.he",
                        "ammo.grenadelauncher.smoke",
                        "xmas.present.large"
                    },
                    AllowedItems = new string[]
                    {
                        "scrap",
                        "keycard_green",
                        "keycard_blue",
                        "keycard_red",
                        "cctv.camera",
                        "targeting.computer"
                    }
                },
                Crafting = new ConfigData.CraftingSettings
                {
                    RequiresCrafting = false,
                    RefundOnDestroy = false,
                    RefundPercentage = 1f,
                    Cost = new List<ConfigData.CraftingSettings.CraftItem>
                    {
                        new ConfigData.CraftingSettings.CraftItem
                        {
                            Shortname = "metal.refined",
                            Amount = 10
                        },
                        new ConfigData.CraftingSettings.CraftItem
                        {
                            Shortname = "metal.fragments",
                            Amount = 400
                        }
                    }
                },
                DepositAutomatically = true,
                LeaveOnCorpse = false,
                Slots = 12,
                LimitCarryAmount = true,
                IsDroppable = true,
                IsStorable = true,
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(Configuration, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (Configuration.Version < new VersionNumber(2, 0, 0))
                Configuration = baseConfig;

            Configuration.Version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion

        #region Localization
        private void Message(BasePlayer player, string key, params string[] args)
        {
            string msg = lang.GetMessage(key, this, player.UserIDString);
            if (args != null && args.Length > 0)
                player.ChatMessage(string.Format(msg, args));
            else player.ChatMessage(msg);
        }

        private readonly Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["Error.CantDrop"] = "You are not allowed to drop the component box!",
            ["Error.NoCarryPermission"] = "You do not have permission to carry a toolbox",
            ["Error.HaveToolbox"] = "You can only have one toolbox at a time",
            ["Error.CantStore"] = "You are not allowed to store the component box!",
            ["Error.ToolboxContents"] = "You can only store a component box in a container when it's empty",
            ["Notification.ContentsTaken"] = "You can only have one toolbox at a time. The contents of this toolbox have been moved to your inventory",
            ["Cmd.Format"] = "Incorrect format! Use /toolbox (craft, cost, remove)",
            ["Cmd.Permission"] = "You do not have the permission to use this command!",
            ["Craft.Cost"] = "Cost:\n{0}",
            ["Craft.NotEnabled"] = "The toolbox is not craftable!",
            ["Craft.Crafted"] = "You have crafted a toolbox!",
            ["Destroy.NoToolbox"] = "You don't have a toolbox!",
            ["Destroy.Destroyed"] = "Removed your toolbox!",
        };
        #endregion
    }
}


// --- End of file: ComponentBox.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/DMDeployables.cs ---
// --- Original Local Path: DMDeployables.cs ---

namespace Oxide.Plugins
{
    [Info("DMDeployables", "ColonBlow", "1.1.5", ResourceId = 1240)]
    class DMDeployables : RustPlugin
    {


	public bool ProtectToolCupboard => Config.Get<bool>("ProtectToolCupboard");
	public bool ProtectSignage => Config.Get<bool>("ProtectSignage");
	public bool ProtectBaseOven => Config.Get<bool>("ProtectBaseOven");
        public bool ProtectMiningQuarry => Config.Get<bool>("ProtectMiningQuarry");
	public bool ProtectWaterCatcher => Config.Get<bool>("ProtectWaterCatcher");
	public bool ProtectResearchTable => Config.Get<bool>("ProtectResearchTable");
	public bool ProtectSleepingBag => Config.Get<bool>("ProtectSleepingBag");
        public bool ProtectRepairBench => Config.Get<bool>("ProtectRepairBench");
        public bool ProtectAutoTurret => Config.Get<bool>("ProtectAutoTurret");
	public bool ProtectBoxes => Config.Get<bool>("ProtectBoxes");
	public bool ProtectBarricade => Config.Get<bool>("ProtectBarricade");
	public bool ProtectSingleDoors => Config.Get<bool>("ProtectSingleDoors");
	public bool ProtectDoubleDoors => Config.Get<bool>("ProtectDoubleDoors");
	public bool ProtectWindows => Config.Get<bool>("ProtectWindows");
	public bool ProtectShutters => Config.Get<bool>("ProtectShutters");
	public bool ProtectShelves => Config.Get<bool>("ProtectShelves");
	public bool ProtectChainLink => Config.Get<bool>("ProtectChainLink");
	public bool ProtectPrisonCell => Config.Get<bool>("ProtectPrisonCell");
	public bool ProtectShopFront => Config.Get<bool>("ProtectShopFront");
	public bool ProtectExternalWalls => Config.Get<bool>("ProtectExternalWalls");
	public bool ProtectExternalGates => Config.Get<bool>("ProtectExternalGates");
	public bool ProtectFloorGrill => Config.Get<bool>("ProtectFloorGrill");
	public bool ProtectFloorLadder => Config.Get<bool>("ProtectFloorLadder");

        protected override void LoadDefaultConfig()
        	{
            	Config["ProtectToolCupboard"] = true;
	    	Config["ProtectSignage"] = true;
	    	Config["ProtectBaseOven"] = true;
	   	Config["ProtectMiningQuarry"] = true;
           	Config["ProtectWaterCatcher"] = true;
	   	Config["ProtectResearchTable"] = true;
	    	Config["ProtectSleepingBag"] = true;
	    	Config["ProtectRepairBench"] = true;
	    	Config["ProtectAutoTurret"] = true;
	    	Config["ProtectBoxes"] = true;
		Config["ProtectBarricade"] = true;
		Config["ProtectSingleDoors"] = true;
		Config["ProtectDoubleDoors"] = true;
		Config["ProtectWindows"] = true;
		Config["ProtectShutters"] = true;
		Config["ProtectShelves"] = true;
		Config["ProtectChainLink"] = true;
		Config["ProtectPrisonCell"] = true;
		Config["ProtectShopFront"] = true;
		Config["ProtectExternalGates"] = true;
		Config["ProtectExternalWalls"] = true;
		Config["ProtectFloorGrill"] = true;
		Config["ProtectFloorLadder"] = true;

            	SaveConfig();
        	}

        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {

		if ((entity.name.Contains("cupboard.tool")) & (ProtectToolCupboard == true)) return false;
				
            	if (entity as Signage != null && hitInfo.damageTypes.GetMajorityDamageType().ToString().Contains(""))
				{
				if (ProtectSignage == true)
					{
                   			hitInfo.damageTypes = new Rust.DamageTypeList();
					}
				}

		// Lanterns, Furnaces, Campfires Protection
           	   if (entity as BaseOven != null && hitInfo.damageTypes.GetMajorityDamageType().ToString().Contains(""))
				{
				if (ProtectBaseOven == true)
					{
                   			hitInfo.damageTypes = new Rust.DamageTypeList();
					}
				}

           	   if (entity as SleepingBag != null && hitInfo.damageTypes.GetMajorityDamageType().ToString().Contains(""))
				{
				if (ProtectSleepingBag == true)
					{
                   			hitInfo.damageTypes = new Rust.DamageTypeList();
					}
				}

           	   if (entity as AutoTurret != null && hitInfo.damageTypes.GetMajorityDamageType().ToString().Contains(""))
				{
				if (ProtectAutoTurret == true)
					{
                   			hitInfo.damageTypes = new Rust.DamageTypeList();
					}
				}

		   if ((entity.name.Contains("repair.bench")) & (ProtectRepairBench == true)) return false;

		   if ((entity.name.Contains("mining.quarry")) & (ProtectMiningQuarry == true)) return false;

		   if ((entity.name.Contains("research.table")) & (ProtectResearchTable == true)) return false;

		   if ((entity.name.Contains("barricade")) & (ProtectBarricade == true)) return false;

                   if ((entity.name.Contains("water.catcher")) & (ProtectWaterCatcher == true)) return false;

		   if ((entity.name.Contains("gates.external")) & (ProtectExternalGates == true)) return false;

		   if ((entity.name.Contains("wall.external")) & (ProtectExternalWalls == true)) return false;

           	   if ((entity.name.Contains("door.hinged")) & (ProtectSingleDoors == true)) return false;

           	   if ((entity.name.Contains("door.double")) & (ProtectDoubleDoors == true)) return false;
	
		   if ((entity.name.Contains("box.wooden")) & (ProtectBoxes == true)) return false;
		   if ((entity.name.Contains("stash.small")) & (ProtectBoxes == true)) return false;
		
		   if ((entity.name.Contains("embrasure")) & (ProtectShutters == true)) return false;

		   if ((entity.name.Contains("window.bars")) & (ProtectWindows == true)) return false;

		   if ((entity.name.Contains("shelves")) & (ProtectWindows == true)) return false;

		   if ((entity.name.Contains("frame.fence")) & (ProtectChainLink == true)) return false;

		   if ((entity.name.Contains("frame.cell")) & (ProtectPrisonCell == true)) return false;

		   if ((entity.name.Contains("shopfront")) & (ProtectShopFront == true)) return false;

		   if ((entity.name.Contains("floor.grill")) & (ProtectFloorGrill == true)) return false;

		   if ((entity.name.Contains("floor.ladder")) & (ProtectFloorLadder == true)) return false;		

		return null;
        }
    }
}


// --- End of file: DMDeployables.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XFarmRoom.cs ---
// --- Original Local Path: XFarmRoom.cs ---

using System.Collections;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;
using System;
using Oxide.Game.Rust.Cui;
using System.Linq;
using System.Collections.Generic;
		   		 		  						  	   		  	  			  		  		  	 	 		  			 
namespace Oxide.Plugins 
{
    [Info("XFarmRoom", "Monster", "1.0.1")]
    class XFarmRoom : RustPlugin
    {
		
		private bool CanPickupEntity(BasePlayer player, BaseEntity entity)
		{
			if(entity.OwnerID == 100002)
				return false;
			
			return true;
		}
		
		private void ChatMessage(BasePlayer player, string message) => Player.Reply(player, config.Setting.PrefixChat + message, config.Setting.SteamID);
		 
		protected override void LoadConfig()
        {
            base.LoadConfig(); 
			 
			try
			{
				config = Config.ReadObject<FarmRoomConfig>();
			}
			catch
			{
				PrintWarning("Ошибка чтения конфигурации! Создание дефолтной конфигурации!");
				LoadDefaultConfig();
			}
			
			SaveConfig();
        }
		
		private void OnPlayerDeath(BasePlayer player, HitInfo info)
		{
			if(player != null && _players_in_room.ContainsKey(player.userID))
				LeaveFarmRoom(player);
		}
		
		private void Unload()
		{
			if(_coroutine != null)
				ServerMgr.Instance.StopCoroutine(_coroutine);
			
			foreach(var player_in_room in _players_in_room)
			{
				BasePlayer player = BasePlayer.FindByID(player_in_room.Key) ?? BasePlayer.FindSleeping(player_in_room.Key);
				
				if(player != null)
				{
					LeaveFarmRoom(player, true);
					CuiHelper.DestroyUi(player, ".GUI_FARMROOM");
				}
			}
				
			SaveData();
		}
		internal class PrefabsRoom
		{
			
			public PrefabsRoom(string shortname, Vector3 pos, Vector3 rot)
			{
				ShortPrefabName = shortname; Position = pos; Rotation = rot;
			}
			public string ShortPrefabName;
			public Vector3 Rotation;
			public Vector3 Position;
		}
		
		[ConsoleCommand("xfarmroom_give_ore")]
		void ccmdGiveOre(ConsoleSystem.Arg args)
		{
			BasePlayer player = args.Player();
			
			if(player == null || player.IsAdmin)
				if(args.Args != null && args.Args.Length >= 3)
				{
					ulong steamID;
					ulong.TryParse(args.Args[0], out steamID);
					
					string ore_shortname = args.Args[1];
					
					int amount;
					int.TryParse(args.Args[2], out amount);
					
					if(!_ores_shortname.Contains(ore_shortname)) return;
					
					if(StoredData.ContainsKey(steamID))
						StoredData[steamID].Ore[ore_shortname] += amount;
					else
						if(steamID.IsSteamId())
						{
							StoredData.Add(steamID, new Data(0, new Dictionary<string, int>{ ["sulfur-ore"] = 0, ["metal-ore"] = 0, ["stone-ore"] = 0 }));
							StoredData[steamID].Ore[ore_shortname] += amount;
						}
				}
		}
		
		[ConsoleCommand("xfarmroom_clear_ore")]
		void ccmdClearOre(ConsoleSystem.Arg args)
		{
			BasePlayer player = args.Player();
			
			if(player == null || player.IsAdmin)
				if(args.Args != null && args.Args.Length >= 1)
				{
					ulong steamID;
					ulong.TryParse(args.Args[0], out steamID);
					
					if(StoredData.ContainsKey(steamID))
						StoredData[steamID].Ore = new Dictionary<string, int>{ ["sulfur-ore"] = 0, ["metal-ore"] = 0, ["stone-ore"] = 0 };
				}
		}
		
		private object CanBuild(Planner planner)
		{
			BasePlayer player = planner.GetOwnerPlayer();
			
			if(player != null && _players_in_room.ContainsKey(player.userID))
				return true;
			
			return null;
		}
		
		private void RemoveRoomOrEntity(Vector3 position)
		{
			List<BaseEntity> list_entity = new List<BaseEntity>();
			Vis.Entities(position, 10, list_entity);
			
			list_entity = list_entity.Distinct().ToList();
			list_entity = list_entity.Where(x => !(x is BasePlayer) && !(x is PlayerCorpse) && !(x is DroppedItemContainer) && !(x is DroppedItem)).ToList();
			
			foreach(BaseEntity entity in list_entity)
				if(entity != null && !entity.IsDestroyed)
					entity.Kill();
		}
		
				
				
		[ChatCommand("roomtp")]
		void cmdTPFarmRoom(BasePlayer player)
		{
			if(player.IsDead()) return;
			
			if(!permission.UserHasPermission(player.UserIDString, "xfarmroom.use"))
			{
				ChatMessage(player, lang.GetMessage("CHAT_NO_PERM", this, player.UserIDString));
				return;
			}
			
			if(!_players_in_room.ContainsKey(player.userID))
			{
				if(Cooldowns.ContainsKey(player.userID))
				{
					int cd = permission.UserHasPermission(player.UserIDString, "xfarmroom.nocdtp") ? 5 : config.Setting.CDTPRoom;
					
					if(DateTimeOffset.Now.ToUnixTimeSeconds() - Cooldowns[player.userID] <= cd)
					{
						ChatMessage(player, string.Format(lang.GetMessage("CHAT_CD_TP", this, player.UserIDString), Cooldowns[player.userID] + cd - DateTimeOffset.Now.ToUnixTimeSeconds()));
						
						return;
					}
				}
				
				if(config.Setting.UseMaxCountItem && player.inventory.AllItems().Count() > config.Setting.MaxCountItem)
				{
					ChatMessage(player, string.Format(lang.GetMessage("CHAT_LIMIT_ITEMS", this, player.UserIDString), config.Setting.MaxCountItem));
					
					return;
				}
				
				bool no_permission = GetOresPermission(player);
				
				if(!StoredData.ContainsKey(player.userID))
				{
					ChatMessage(player, lang.GetMessage("CHAT_NO_ALL_PERM", this, player.UserIDString));
					
					return;
				}
				
				if(StoredData[player.userID].Ore.Values.Sum() <= 0)
				{
					if(no_permission)
						ChatMessage(player, lang.GetMessage("CHAT_NOT_ORES_NOT_PERM", 