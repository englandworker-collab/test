
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel);
            }
            static public void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter, float fadein = 1.0f)
            {
                if (DisableUI_FadeIn)
                    fadein = 0;
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = fadein, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);

            }
            static public void CreateButton(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter, float fadein = 1.0f)
            {
                if (DisableUI_FadeIn)
                    fadein = 0;
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = fadein },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel);
            }
            static public void LoadImage(ref CuiElementContainer container, string panel, string png, string aMin, string aMax)
            {
                container.Add(new CuiElement
                {
                    Parent = panel,
                    Components =
                    {
                        new CuiRawImageComponent {Png = png },
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax }
                    }
                });
            }
            static public void CreateTextOverlay(ref CuiElementContainer container, string panel, string text, string color, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter, float fadein = 1.0f)
            {
                if (DisableUI_FadeIn)
                    fadein = 0;
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = fadein, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);

            }
        }

        private void DestroyAllPvXUI(BasePlayer player)
        {
            foreach(string _v in GuiList)
            {
                CuiHelper.DestroyUi(player, _v);
            }
            //DestroyEntries(player);
        }
        private void DestroyPvXUI(BasePlayer player, string _ui)
        {
            CuiHelper.DestroyUi(player, _ui);
        }
        //private void DestroyEntries(BasePlayer player)
        //{
        //    CuiHelper.DestroyUi(player, UIPanel);
        //    if (OpenUI.ContainsKey(player.userID))
        //    {
        //        foreach (var entry in OpenUI[player.userID])
        //            CuiHelper.DestroyUi(player, entry);
        //        OpenUI.Remove(player.userID);
        //    }
        //}
        private void AddUIString(BasePlayer player, string name)
        {
            if (!OpenUI.ContainsKey(player.userID))
                OpenUI.Add(player.userID, new List<string>());
            OpenUI[player.userID].Add(name);
        }

        private Dictionary<string, string> UIColors = new Dictionary<string, string>
        {
            {"Black-100", "0.0 0.0 0.0 1.0" },  //Black
            {"Black-50", "0.0 0.0 0.0 0.50" },
            {"Black-15", "0.0 0.0 0.0 0.15" },
            {"Grey2-100", "0.2 0.2 0.2 1.0" },  //Grey 2
            {"Grey2-50", "0.2 0.2 0.2 0.50" },
            {"Grey2-15", "0.2 0.2 0.2 0.15" },
            {"Grey5-100", "0.5 0.5 0.5 1.0" },  //Grey 5
            {"Grey5-50", "0.5 0.5 0.5 0.50" },
            {"Grey5-15", "0.5 0.5 0.5 0.15" },
            {"Grey8-100", "0.8 0.8 0.8 1.0" },  //Grey 8
            {"Grey8-50", "0.8 0.8 0.8 0.50" },
            {"Grey8-15", "0.8 0.8 0.8 0.15" },
            {"White-100", "1.0 1.0 1.0 1.0" },  //White
            {"White-50", "1.0 1.0 1.0 0.50" },
            {"White-15", "1.0 1.0 1.0 0.15" },
            {"Red-100", "0.7 0.2 0.2 1.0" },    //Red
            {"Red-50", "0.7 0.2 0.2 0.50" },
            {"Red-15", "0.7 0.2 0.2 0.15" },
            {"Green-100", "0.2 0.7 0.2 1.0" },  //Green
            {"Green-50", "0.2 0.7 0.2 0.50" },
            {"Green-15", "0.2 0.7 0.2 0.15" },
            {"Blue-100", "0.2 0.2 0.7 1.0" },  //Blue
            {"Blue-50", "0.2 0.2 0.7 0.50" },
            {"Blue-15", "0.2 0.2 0.7 0.15" },
            {"Yellow-100", "0.9 0.9 0.2 1.0" },  //Yellow
            {"Yellow-50", "0.9 0.9 0.2 0.50" },
            {"Yellow-15", "0.9 0.9 0.2 0.15" },
            {"buttonbg", "0.2 0.2 0.2 0.7" },
            {"buttonopen", "0.2 0.8 0.2 0.9" },
            {"buttoncompleted", "0 0.5 0.1 0.9" },
            {"buttonred", "0.85 0 0.35 0.9" },
            {"buttongrey", "0.8 0.8 0.8 0.9" },
        };
        #endregion

        #region GUIs

        private void createPvXSelector(BasePlayer _player)
        {
            selectGuiOpen.Add(_player.userID);
            timer.Once(5, () => updatePvXSelector(_player));
            var PvXselectorContainer = QUI.CreateElementContainer(
                pvxPlayerSelectorUI,
                UIColors["Black-50"],
                "0.17 0.15",
                "0.33 0.25",
                true
                );
            QUI.CreateButton(
                ref PvXselectorContainer,
                pvxPlayerSelectorUI,
                UIColors["Red-100"],
                "PvP",
                22,
                "0.1 0.2",
                "0.45 0.8",
                "PvXGuiCMD pvp"
                );
            QUI.CreateButton(
                ref PvXselectorContainer,
                pvxPlayerSelectorUI,
                UIColors["Green-100"],
                "PvE",
                22,
                "0.55 0.2",
                "0.9 0.8",
                "PvXGuiCMD pve"
                );
            CuiHelper.AddUi(_player, PvXselectorContainer);
        }
        private void updatePvXSelector(BasePlayer _player)
        {
            CuiHelper.DestroyUi(_player, pvxPlayerSelectorUI);
            if (isplayerNA(_player))createPvXSelector(_player);
        }

        private void createPvXIndicator(BasePlayer _player)
        {
            var indicatorContainer = QUI.CreateElementContainer(
                pvxPlayerUI,
                UIColors["Black-15"],
                "0.48 0.11",
                "0.52 0.14");
            if (InfoCache[_player.userID].mode == "NA")
                indicatorContainer = QUI.CreateElementContainer(
                    pvxPlayerUI,
                    UIColors["Red-100"],
                    "0.48 0.11",
                    "0.52 0.14");
            else if (ticketData.Info.ContainsKey(_player.userID))
                indicatorContainer = QUI.CreateElementContainer(
                    pvxPlayerUI,
                    UIColors["Yellow-15"],
                    "0.48 0.11",
                    "0.52 0.14");
            if (AdminPlayerMode.Contains(_player))
            {
                QUI.CreateLabel(
                    ref indicatorContainer,
                    pvxPlayerUI,
                    UIColors["Green-100"],
                    InfoCache[_player.userID].mode,
                    15,
                    "0.1 0.1",
                    "0.90 0.99");
            }
            else
            {
                QUI.CreateLabel(ref indicatorContainer,
                    pvxPlayerUI,
                    UIColors["White-100"],
                    InfoCache[_player.userID].mode,
                    15,
                    "0.1 0.1",
                    "0.90 0.99");
            }
            CuiHelper.AddUi(_player, indicatorContainer);
        }
        private void updatePvXIndicator(BasePlayer _player)
        {
            CuiHelper.DestroyUi(_player, pvxPlayerUI);
            createPvXIndicator(_player);
        }

        private void createAdminIndicator(BasePlayer _player)
        {
            if (!hasPerm(_player, "admin")) return;
            var adminCountContainer = QUI.CreateElementContainer(
                pvxAdminUI,
                UIColors["Black-100"],
                "0.166 0.055",
                "0.34 0.0955");
            QUI.CreateLabel(ref adminCountContainer,
                pvxAdminUI,
                UIColors["White-100"],
                "PvX Tickets",
                10,
                "0.0 0.1",
                "0.3 0.90");
            QUI.CreateLabel(ref adminCountContainer,
                pvxAdminUI,
                UIColors["White-100"],
                string.Format("Open: {0}", ticketData.Info.Count.ToString()),
                10,
                "0.301 0.1",
                "0.65 0.90");
            QUI.CreateLabel(ref adminCountContainer,
                pvxAdminUI,
                UIColors["White-100"],
                string.Format("Closed: {0}", ticketLog.Log.Count.ToString()),
                10,
                "0.651 0.1",
                "1 0.90");
            CuiHelper.AddUi(_player, adminCountContainer);
        }
        private void UpdateAdminIndicator()
        {
            if (activeAdmins == null) return;
            else if (activeAdmins.Count < 1) return;
            foreach (BasePlayer _player in activeAdmins)
            {
                CuiHelper.DestroyUi(_player, pvxAdminUI);
                createAdminIndicator(_player);
            }
        }

        private void createButton(BasePlayer _player)
        { }
        #endregion

        #region Lang/Chat
        void LangMSG(BasePlayer _player, string langMsg, params object[] args)
        {
            string message = lang.GetMessage(langMsg, this, _player.UserIDString);
            PrintToChat(_player, $"<color={ChatPrefixColor}>{ChatPrefix}</color>: <color={ChatMessageColor}>{message}</color>", args);
        }
        void LangMSGBroadcast(string langMsg, params object[] args)
        {
            string message = lang.GetMessage(langMsg, this);
            PrintToChat($"<color={ChatPrefixColor}>{ChatPrefix}</color>: <color={ChatMessageColor}>{message}</color>", args);
        }
        void BroadcastMessageHandle(string message, params object[] args)
        {
            PrintToChat($"<color={ChatPrefixColor}>{ChatPrefix}</color>: <color={ChatMessageColor}>{message}</color>", args);
        }
        void ChatMessageHandle(BasePlayer _player, string message, params object[] args)
        {
            PrintToChat(_player, $"<color={ChatPrefixColor}>{ChatPrefix}</color>: <color={ChatMessageColor}>{message}</color>", args);
        }
        void PutsLang(string langMsg, params object[] args)
        {
            string message = lang.GetMessage(langMsg, this);
            Puts(string.Format(message, args));
        }
        void PutsPlayerHandle(BasePlayer _player, string msg, params object[] args)
        {
            Puts(msg, args);
            PrintToChat(_player, $"<color={ChatPrefixColor}>{ChatPrefix}</color>: <color={ChatMessageColor}>{msg}</color>", args);
        }
        void PutsPlayerHandleLang(BasePlayer _player, string langMsg, params object[] args)
        {
            string msg = lang.GetMessage(langMsg, this, _player.UserIDString);
            Puts(msg, args);
            SendReply(_player, msg, args);
        }

        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"xx", "xxx" },
            {"notAllwPickup", "You can't pick this item as owner is: {0}" },
            {"AdmModeRem", "You have deactivated Admin Mode" },
            {"AdmModeAdd", "You are now in Admin mode" },
            {"lvlRedxpSav", "Your Level was reduced, Lost xp has been saved." },
            {"lvlIncrxpRes", "Your Level has been increased, Lost xp Restored." },
            {"numbonly", "Incorrect format: Included letter in ticketID" },
            {"TickCrea", "You have created a ticket" },
            {"TickCanc", "You have Canceled your ticket" },
            {"TickAcep", "Your Ticket has been accepted" },
            {"TickDecl", "Your Ticket has been declined" },
            {"TickAcepAdm", "Your Ticket accepted the ticket" },
            {"TickDeclAdm", "Your Ticket decline the ticket" },
            {"TickClosLogin", "Welcome back, Your ticket was {0}" },
            {"TickList", "Ticket#: {0}, User: {1}" },
            {"TickDet", "Ticket Details:" },
            {"TickID", "Ticket ID: {0}" },
            {"TickName", "Username: {0}" },
            {"TickStmID", "SteamID: {0}" },
            {"TickSelc", "Selected: {0}" },
            {"TickRsn", "Reason: {0}" },
            {"TickDate", "Ticket Created: {0}" },
            {"TickCnt", "Open Tickets: {0}" },
            {"TickNotAvail", "Ticket#:{0} Does not exist" },
            {"ComndList", "PvX Command List:" },
            {"CompTickCnt", "Closed Tickets: {0}" },
            {"IncoForm", "Incorrect format" },
            {"IncoFormPleaUse", "Incorrect format Please Use:" },
            {"TicketDefaultReason", "Change Requested Via Chat" },
            {"NoTicket", "There are no tickets to display" },
            {"AlreadySubmitted", "You have already requested to change, Please conctact your admin" },
            {"PvETarget", "You are attacking a PvE player" },
            {"NoActTick", "You do not have an active ticket" },
            {"RSNChan", "You have changed your tickets reason." },
            {"PvEStructure", "That structure belongs to a PvE player" },
            {"NoXPModeNA", "You will not earn XP until you have selected PvE/PvP" },
            {"NoSaveLvLNA", "Your levl is not saved unless you select PvE or PvP" },
            {"TargisGod", "You are attacking a god" },
            {"YouisGod", "You are attacking a god" },
            {"MissPerm", "You do not have the required permision" }
        };
        #endregion

        #region Ticket Functions
        void createTicket(BasePlayer _player, string selection)
        {
            int _TicketNumber = GetNewID();
            string _username = _player.displayName;
            string _requested = selection;
            string _reason = lang.GetMessage("TicketDefaultReason", this, _player.UserIDString);
            ticketData.Link.Add(_TicketNumber, _player.userID);
            ticketData.Info.Add(_player.userID, new Ticket
            {
                CreatedTimeStamp = DateTimeStamp(),
                reason = lang.GetMessage("TicketDefaultReason", this, _player.UserIDString),
                requested = selection,
                TicketNumber = _TicketNumber,
                UserId = _player.UserIDString,
                Username = _player.displayName
            });
            LangMSG(_player, "TickCrea");
            InfoCache[_player.userID].ticket = true;
            SaveAll();
            UpdateAdminIndicator();
            updatePvXIndicator(_player);
        }
        void cancelTicket(BasePlayer _player)
        {
            if (playerData.Info[_player.userID].ticket == false) return;
            int _ticketNumber = ticketData.Info[_player.userID].TicketNumber;
            ticketData.Link.Remove(_ticketNumber);
            ticketData.Info.Remove(_player.userID);
            InfoCache[_player.userID].ticket = false;
            SaveAll();
            LangMSG(_player, "TickCanc");
            updatePvXIndicator(_player);
            UpdateAdminIndicator();
            return;
        }
        void ticketAccept(BasePlayer _admin, int _ticketID)//Update required to fix Baseplayer NRE
        {
            ulong _UserID = ticketData.Link[_ticketID];
            addTicketLog(_admin, _ticketID, true);
            LangMSG(_admin, "TickAcepAdm");
            playerData.Info[_UserID].ticket = false;
            InfoCache[_UserID].mode = ticketData.Info[_UserID].requested;
            SaveAll();
            BasePlayer _player = basePlayerByID(_UserID);
            if (_player != null && _player.isConnected)
            {
                LangMSG(_player, "TickAcep");
                updatePvXIndicator(_player);
                updatePlayerChatTag(_player);
            }
            else if (_player != null && !_player.isConnected)
            {
                ticketData.Notification.Add(_player.userID, "Accepted");
            }
            else
            {
                ticketData.Notification.Add(_player.userID, "Accepted");
            }
            ticketData.Info.Remove(_UserID);
            ticketData.Link.Remove(_ticketID);
            SaveAll();
            UpdateAdminIndicator();
            if (_player != null && _player.isConnected) updatePvXIndicator(_player);
        }
        void ticketDecline(BasePlayer _admin, int _ticketID)//updated: Fixed Baseplayer NRE
        {
            ulong _UserID = ticketData.Link[_ticketID];
            addTicketLog(_admin, _ticketID, false);
            LangMSG(_admin, "TickAcepAdm");
            playerData.Info[_UserID].ticket = false;
            ticketData.Info.Remove(_UserID);
            ticketData.Link.Remove(_ticketID);
            SaveAll();
            UpdateAdminIndicator();
            BasePlayer _player = basePlayerByID(_UserID);
            if (_player != null && _player.isConnected)
            {
                LangMSG(_player, "TickDecl");
                updatePvXIndicator(_player);
            }
            else ticketData.Notification.Add(_player.userID, "Declined");
        }
        void ticketCount(BasePlayer _player)
        {
            LangMSG(_player, "TickCnt", ticketData.Link.Count);
            LangMSG(_player, "CompTickCnt", ticketLog.Log.Count);
        }
        void listTickets(BasePlayer _player)
        {
            if (ticketData.Link.Count > 0)
            {
                foreach (var ticket in ticketData.Info)
                {
                    ulong _key = ticket.Key;
                    PutsPlayerHandleLang(_player, "TickList", ticketData.Info[_key].TicketNumber, ticketData.Info[_key].Username);
                }
            }
        }
        void displayTicket(BasePlayer _player, int _ticketID)
        {
            if (ticketData.Link.ContainsKey(_ticketID))
            {
                ulong _key = ticketData.Link[_ticketID];
                //DateTime _date = DateTime.FromOADate(ticketData.Info[_key].timeStamp);
                LangMSG(_player, "TickDet");
                LangMSG(_player, "TickID", _ticketID);
                LangMSG(_player, "TickName", ticketData.Info[_key].Username);
                LangMSG(_player, "TickStmID", _key);
                LangMSG(_player, "TickSelc", ticketData.Info[_key].requested);
                LangMSG(_player, "TickRsn", ticketData.Info[_key].reason);
                LangMSG(_player, "TickDate", ticketData.Info[_key].CreatedTimeStamp);
            }
            else LangMSG(_player, "TickNotAvail", _ticketID);
        }
        bool playerHasTicket(BasePlayer _player)
        {
            if (InfoCache[_player.userID].ticket == true) return true;
            else return false;
        }
        bool playerHasTicket(ulong _userID)
        {
            if (InfoCache[_userID].ticket == true) return true;
            else return false;
        }

        int GetNewID()
        {
            for (int _i = 1; _i <= 500; _i++)
            {
                if (ticketData.Link.ContainsKey(_i)) { }//Place Debug code in future
                else
                {
                    //Puts("Key {0} doesnt exist, Returning ticket number", _i); //debug
                    return _i;
                }
            }
            return 0;
        }
        int NewLogID()
        {
            for (int _i = 1; _i <= 500; _i++)
            {
                if (ticketLog.Log.ContainsKey(_i)) { }
                else
                {
                    //Puts("Key {0} doesnt exist, Returning ticket number", _i); //debug
                    return _i;
                }
            }
            return 0;
        }

        void consolListTickets()
        {
            foreach (ulong _ticket in ticketData.Info.Keys)
            {
                Puts("    ");
                Puts("    ");
                PutsLang("TickDet");
                PutsLang("TickID", ticketData.Info[_ticket].TicketNumber);
                PutsLang("TickName", ticketData.Info[_ticket].Username);
                PutsLang("TickStmID", _ticket);
                PutsLang("TickSelc", ticketData.Info[_ticket].requested);
                PutsLang("TickRsn", ticketData.Info[_ticket].reason);
                PutsLang("TickDate", ticketData.Info[_ticket].CreatedTimeStamp);
            }
        }
        void consolListLog()
        {
            foreach (int _ticket in ticketLog.Log.Keys)
            {
                Puts("    ");
                Puts("    ");
                Puts("Log Ticket");
                Puts("Accepted: {0}", ticketLog.Log[_ticket].Accepted);
                Puts("CreatedTimeStamp: {0}", ticketLog.Log[_ticket].CreatedTimeStamp);
                Puts("ClosedTimeStamp: {0}", ticketLog.Log[_ticket].ClosedTimeStamp);
                Puts("Username: {0}", ticketLog.Log[_ticket].Username);
                Puts("UserId: {0}", ticketLog.Log[_ticket].UserId);
                Puts("AdminName: {0}", ticketLog.Log[_ticket].AdminName);
                Puts("AdminId: {0}", ticketLog.Log[_ticket].AdminId);
                Puts("Requested: {0}", ticketLog.Log[_ticket].requested);
                Puts("Reason: {0}", ticketLog.Log[_ticket].reason);
            }
        }

        #endregion

        #region Looting Functions
        ItemContainer.CanAcceptResult CanAcceptItem(ItemContainer container, Item item)
        {
            if (container.playerOwner != null)
            {
                BasePlayer _player = container.playerOwner;
                List<Item.OwnerFraction> _itemOwners = item.owners;
                if (_itemOwners == null) return ItemContainer.CanAcceptResult.CanAccept;
                if (_itemOwners.Count < 1) return ItemContainer.CanAcceptResult.CanAccept;
                ulong _ownerID = _itemOwners[0].userid;
                if (_ownerID == 0) return ItemContainer.CanAcceptResult.CanAccept;
                if (isNPC(_ownerID)) return ItemContainer.CanAcceptResult.CanAccept;
                if (SameOnlyCheck(container.playerOwner.userID, _ownerID)) return ItemContainer.CanAcceptResult.CanAccept;
                else
                {
                    LangMSG(container.playerOwner, "notAllwPickup", InfoCache[_ownerID].mode);
                    return ItemContainer.CanAcceptResult.CannotAccept;
                }
            }
            else return ItemContainer.CanAcceptResult.CanAccept;
        }
        private object CanLootPlayer(BasePlayer _target, BasePlayer _looter)
        {
            if (isNPC(_target)) return canLootNPC(_looter);
            if (isGod(_target)) return null;
            if (areInEvent(_looter, _target)) return null;
            return PvPOnlyCheck(_looter, _target) ? null : (object)false;
        }
        private void OnLootPlayer(BasePlayer _looter, BasePlayer _target)
        {
            if (isNPC(_target)) { npcLootHandle(_looter); return; };
            if (areInEvent(_looter, _target)) return;
            if (PvPOnlyCheck(_looter, _target)) return;
            else NextTick(_looter.EndLooting);
        }
        private void OnLootEntity(BasePlayer _looter, BaseEntity _target)
        {
            if (_target is BaseCorpse)
            {
                var corpse = _target?.GetComponent<PlayerCorpse>() ?? null;
                if (corpse != null)
                {
                    if (isNPC(corpse)) { npcLootHandle(_looter); return; }
                    ulong _corpseID = corpse.playerSteamID;
                    if (_corpseID == _looter.userID) return;
                    BasePlayer _corpseBP = basePlayerByID(_corpseID);
                    if (_corpseBP != null)
                        if (areInEvent(_looter, _corpseBP)) return;
                        else if (PvPOnlyCheck(_looter.userID, _corpseID)) return;
                        else NextTick(_looter.EndLooting);
                }
            }
            else if (_target is StorageContainer)
            {
                StorageContainer _container = (StorageContainer)_target;
                if (_container.OwnerID == 0) return;
                BasePlayer _containerBP = basePlayerByID(_container.OwnerID);
                if (_container.OwnerID == _looter.userID) return;
                if (_containerBP != null)
                    if (areInEvent(_looter, _containerBP)) return;
                if (SameOnlyCheck(_looter.userID, _container.OwnerID)) return;
                else NextTick(_looter.EndLooting);
            }
            else return;
        }
        #endregion

        #region Building Functions
        private List<object> BuildEntityList = new List<object>() {
            typeof(AutoTurret),typeof(Barricade),typeof(BaseCombatEntity),
            typeof(BaseOven),typeof(BearTrap),typeof(BuildingBlock),
            typeof(BuildingPrivlidge),typeof(CeilingLight),typeof(Door),
            typeof(Landmine),typeof(LiquidContainer),typeof(ReactiveTarget),
            typeof(RepairBench),typeof(ResearchTable),typeof(Signage),
            typeof(SimpleBuildingBlock),typeof(SleepingBag),typeof(StabilityEntity),
            typeof(StorageContainer),typeof(SurvivalFishTrap),typeof(WaterCatcher),
            typeof(WaterPurifier)};
        private List<object> BasePartEntityList = new List<object>() {
            typeof(BaseOven),typeof(BuildingBlock),typeof(BuildingPrivlidge),
            typeof(CeilingLight),typeof(Door),typeof(LiquidContainer),
            typeof(RepairBench),typeof(ResearchTable),typeof(Signage),
            typeof(SimpleBuildingBlock),typeof(SleepingBag),typeof(StabilityEntity),
            typeof(StorageContainer),typeof(SurvivalFishTrap),typeof(WaterCatcher),
            typeof(WaterPurifier)};
        private List<object> CombatPartEntityList = new List<object>() {
            typeof(AutoTurret),typeof(Barricade),typeof(BearTrap),typeof(Landmine),
            typeof(ReactiveTarget),typeof(BaseCombatEntity)};



        void OnEntitySpawned(BaseNetworkable _entity)
        {
            if (_entity is BaseEntity)
            {
                BaseEntity _base = (BaseEntity)_entity;
                if (_base.OwnerID == 0) return;
                else if (AdminPlayerMode.Contains(basePlayerByID(_base.OwnerID)))
                    _base.OwnerID = 0;
            }
        }

        #endregion

        #region Compatibility Functions

        [PluginReference]
        Plugin Vanish;
        [PluginReference]
        Plugin Skills;

        bool checkInvis(BasePlayer _player)
        {
            var isInvisible = Vanish?.Call("IsInvisible", _player);
            var isStealthed = Skills?.Call("isStealthed", _player);
            if (isInvisible != null && (bool)isInvisible)
            {
                return true;
            }
            else if (isStealthed != null && (bool)isStealthed)
            {
                return true;
            }
            else return false;
        }

        [PluginReference]
        private Plugin BetterChat;
        void RegisterGroups()
        {
            if (!BetterChat) return;
            if (!GroupExists("PvP"))
            {
                NewGroup("PvP");
                SetGroupTitle("PvP");
                SetGroupColor("PvP");
            }
            if (!GroupExists("PvE"))
            {
                NewGroup("PvE");
                SetGroupTitle("PvE");
                SetGroupColor("PvE");
            }
        }

        void updatePlayerChatTag(BasePlayer _player)
        {
            if (!BetterChat) return;
            ulong _userID = _player.userID;
            string _userIDs = _player.UserIDString;
            string _mode = InfoCache[_userID].mode;
            if (_mode == "pvp")
            {
                if (!(UserInGroup(_userIDs, "PvP"))) AddToGroup(_userIDs, "PvP");
                if (UserInGroup(_userIDs, "PvE")) RemoveFromGroup(_userIDs, "PvE");
            }
            else if (_mode == "pve")
            {
                if (!(UserInGroup(_userIDs, "PvE"))) AddToGroup(_userIDs, "PvE");
                if (UserInGroup(_userIDs, "PvP")) RemoveFromGroup(_userIDs, "PvP");
            }
            else if (_mode == "NA")
            {
                if (UserInGroup(_userIDs, "PvE")) RemoveFromGroup(_userIDs, "PvE");
                if (UserInGroup(_userIDs, "PvP")) RemoveFromGroup(_userIDs, "PvP");
            }
        }

        private bool GroupExists(string name) => (bool)BetterChat?.Call("API_GroupExists", (name.ToLower()));
        private bool NewGroup(string name) => (bool)BetterChat?.Call("API_AddGroup", (name.ToLower()));
        private bool UserInGroup(string ID, string name) => (bool)BetterChat?.Call("API_IsUserInGroup", ID, (name.ToLower()));
        private bool AddToGroup(string ID, string name) => (bool)BetterChat?.Call("API_AddUserToGroup", ID, (name.ToLower()));
        private bool RemoveFromGroup(string ID, string name) => (bool)BetterChat?.Call("API_RemoveUserFromGroup", ID, (name.ToLower()));
        private object SetGroupTitle(string name) => BetterChat?.Call("API_SetGroupSetting", (name.ToLower()), "title", $"[{name}]");
        private object SetGroupColor(string name) => BetterChat?.Call("API_SetGroupSetting", (name.ToLower()), "titlecolor", "orange");

        [PluginReference]
        private Plugin HumanNPC;
        bool isNPC(ulong _test)
        {
            if (HumanNPC == null) return false;
            else if (_test < 76560000000000000L) return true;
            else return false;
        }
        bool isNPC(BasePlayer _test)
        {
            if (HumanNPC == null) return false;
            else if (_test.userID < 76560000000000000L) return true;
            else return false;
        }
        bool isNPC(BaseCombatEntity _player)
        {
            BasePlayer _test = (BasePlayer)_player;
            if (HumanNPC == null) return false;
            else if (_test.userID < 76560000000000000L) return true;
            else return false;
        }
        bool isNPC(PlayerCorpse _test)
        {
            if (HumanNPC == null) return false;
            else if (_test.playerSteamID < 76560000000000000L) return true;
            else return false;
        }

        void npcDamageHandle(BasePlayer _NPC, HitInfo _hitInfo)
        {
            BasePlayer _attacker = (BasePlayer)_hitInfo.Initiator;
            if (isNPC(_attacker)) return;
            if ((InfoCache[_attacker.userID].mode == "pvp") && (PvPAttackNPC == true)) return;
            if ((InfoCache[_attacker.userID].mode == "pve") && (PvEAttackNPC == true)) return;
            else ModifyDamage(_hitInfo, 0);
        }
        void npcAttackHandle(BasePlayer _target, HitInfo _hitInfo)
        {
            if (isNPC(_target)) return;
            if ((InfoCache[_target.userID].mode == "pvp") && (NPCAttackPvP == true)) return;
            if ((InfoCache[_target.userID].mode == "pve") && (NPCAttackPvE == true)) return;
            else ModifyDamage(_hitInfo, 0);
        }

        bool canLootNPC(BasePlayer _player)
        {
            if ((PvELootNPC == true) && (PvPLootNPC == true)) return true;
            else if ((InfoCache[_player.userID].mode == "pvp") && (PvPLootNPC == true)) return true;
            else if ((InfoCache[_player.userID].mode == "pve") && (PvELootNPC == true)) return true;
            else return false;
        }
        void npcLootHandle(BasePlayer _player)
        {
            if ((PvELootNPC == true) && (PvPLootNPC == true)) return;
            if ((InfoCache[_player.userID].mode == "pvp") && (PvPLootNPC == true)) return;
            if ((InfoCache[_player.userID].mode == "pve") && (PvELootNPC == true)) return;
            BroadcastMessageHandle("Not allowed to loot");
            NextTick(_player.EndLooting);
        }

        [PluginReference]
        private Plugin EventManager;
        bool isInEvent(BasePlayer _player1)
        {
            if (EventManager == null) return false;
            bool _var = (bool)EventManager?.Call("isPlaying", _player1);
            if (_var == true) return true;
            return false;
        }

        bool areInEvent(BasePlayer _player1, BasePlayer _player2)
        {
            if (EventManager == null) return false;
            bool _var1 = (bool)EventManager?.Call("isPlaying", _player1);
            bool _var2 = (bool)EventManager?.Call("isPlaying", _player2);
            if (_var1 == true && _var1 == _var2) return true;
            return false;
        }


        [PluginReference]
        private Plugin Godmode;
        private bool checkIsGod(string _player) => (bool)Godmode?.Call("IsGod", _player);

        private bool isGod(ulong _player)
        {
            if (Godmode == null) return false;
            return checkIsGod(_player.ToString());
        }
        private bool isGod(BasePlayer _player)
        {
            if (Godmode == null) return false;
            if (_player == null) return false;
            return checkIsGod(_player.UserIDString);
        }


        #endregion

        #region Door Functions
        void OnDoorOpened(Door _door, BasePlayer _player)
        {
            if (_door == null) return;
            if (_door.OwnerID == 0) return;
            if (!(SameOnlyCheck(_player.userID, _door.OwnerID)))
            {
                _door.SetFlag(BaseEntity.Flags.Open, false);
                _door.SendNetworkUpdateImmediate();
            }
        }
        #endregion

        #region PvX Check/Find Functions
        private bool PvPOnlyCheck(BasePlayer _player1, BasePlayer _player2)
        {
            if (isplayerNA(_player1)) return false;
            if (isplayerNA(_player2)) return false;
            if ((InfoCache[_player1.userID].mode == "pvp") && (InfoCache[_player2.userID].mode == "pvp"))
                return true;
            return false;
        }
        private bool PvPOnlyCheck(ulong _player1, ulong _player2)
        {
            if (isplayerNA(_player1)) return false;
            if (isplayerNA(_player2)) return false;
            if ((InfoCache[_player1].mode == "pvp") && (InfoCache[_player2].mode == "pvp")) return true;
            return false;
        }
        private bool PvEOnlyCheck(BasePlayer _player1, BasePlayer _player2)
        {
            if (isplayerNA(_player1)) return false;
            if (isplayerNA(_player2)) return false;
            if ((InfoCache[_player1.userID].mode == "pve") && (InfoCache[_player2.userID].mode == "pve"))
                return true;
            return false;
        }
        private bool PvEOnlyCheck(ulong _player1, ulong _player2)
        {
            if (isplayerNA(_player1)) return false;
            if (isplayerNA(_player2)) return false;
            if ((InfoCache[_player1].mode == "pve") && (InfoCache[_player2].mode == "pve")) return true;
            return false;
        }
        private bool SameOnlyCheck(BasePlayer _player1, BasePlayer _player2)
        {
            if (isplayerNA(_player1)) return false;
            if (isplayerNA(_player2)) return false;
            if (InfoCache[_player1.userID].mode == InfoCache[_player2.userID].mode) return true;
            return false;
        }
        private bool SameOnlyCheck(ulong _player1, ulong _player2)
        {
            if (isplayerNA(_player1)) return false;
            if (isplayerNA(_player2)) return false;
            if (InfoCache[_player1].mode == InfoCache[_player2].mode) return true;
            return false;
        }

        bool isplayerNA(BasePlayer _player)
        {
            ulong _playerID = _player.userID;
            if (!InfoCache.ContainsKey(_playerID))
            {
                if (_player == null)
                {
                    addOffline(_playerID);
                    BroadcastMessageHandle("Adding offline");
                    SaveAll();
                    return true;
                }
                addPlayer(_player);
                return true;
            }
            if (InfoCache[_playerID].mode == "NA") return true;
            else return false;
        }
        bool isplayerNA(ulong _playerID)
        {
            if (!InfoCache.ContainsKey(_playerID))
            {
                BasePlayer _player = basePlayerByID(_playerID);
                if (_player == null)
                {
                    addOffline(_playerID);
                    BroadcastMessageHandle("Adding offline");
                    SaveAll();
                    return true;
                }
                addPlayer(_player);
                return true;
            }
            if (InfoCache[_playerID].mode == "NA") return true;
            else return false;
        }
        bool isPvP(ulong _playerID)
        {
            if (_playerID == 0 || isNPC(_playerID)) return false;
            BasePlayer _player = basePlayerByID(_playerID);
            if (_player == null) return false;
            if (!InfoCache.ContainsKey(_playerID))
            {
                addPlayer(_player);
                return false;
            }
            if (InfoCache[_playerID].mode == "pvp") return true;
            else return false;
        }
        bool isPvP(BasePlayer _player)
        {
            ulong _playerID = _player.userID;
            if (_playerID == 0 || isNPC(_playerID)) return false;
            if (_player == null) return false;
            if (!InfoCache.ContainsKey(_playerID))
            {
                addPlayer(_player);
                return false;
            }
            if (InfoCache[_playerID].mode == "pvp") return true;
            else return false;
        }
        bool isPvP(BaseCombatEntity _BaseCombat)
        {
            BasePlayer _player = (BasePlayer)_BaseCombat;
            ulong _playerID = _player.userID;
            if (_playerID == 0 || isNPC(_playerID)) return false;
            if (_player == null) return false;
            if (!InfoCache.ContainsKey(_playerID))
            {
                addPlayer(_player);
                return false;
            }
            if (InfoCache[_playerID].mode == "pvp") return true;
            else return false;
        }
        bool isPvE(ulong _playerID)
        {
            if (_playerID == 0 || isNPC(_playerID)) return false;
            BasePlayer _player = basePlayerByID(_playerID);
            if (_player == null) return false;
            if (!InfoCache.ContainsKey(_playerID))
            {
                addPlayer(_player);
                return false;
            }
            if (InfoCache[_playerID].mode == "pve") return true;
            else return false;
        }
        bool isPvE(BasePlayer _player)
        {
            ulong _playerID = _player.userID;
            if (_playerID == 0 || isNPC(_playerID)) return false;
            if (_player == null) return false;
            if (!InfoCache.ContainsKey(_playerID))
            {
                addPlayer(_player);
                return false;
            }
            if (InfoCache[_playerID].mode == "pve") return true;
            else return false;
        }
        bool isPvE(BaseCombatEntity _BaseCombat)
        {
            BasePlayer _player = (BasePlayer)_BaseCombat;
            ulong _playerID = _player.userID;
            if (_playerID == 0 || isNPC(_playerID)) return false;
            if (_player == null) return false;
            if (!InfoCache.ContainsKey(_playerID))
            {
                addPlayer(_player);
                return false;
            }
            if (InfoCache[_playerID].mode == "pve") return true;
            else return false;
        }

        bool BaseplayerCheck(BasePlayer _attacker, BasePlayer _victim)
        {
            if (_attacker == _victim) return true;
            if (isGod(_victim)) return true;
            if (isGod(_attacker)) return true;
            if (areInEvent(_attacker, _victim)) return true;
            return false;
        }

        bool IsDigitsOnly(string str)
        {
            foreach (char c in str)
            {
                if (!char.IsDigit(c))
                {
                    //Puts("Character Detected Returning false");
                    return false;
                }
            }
            //Puts("Detected no Characters Returning true");
            return true;
        }
        BasePlayer basePlayerByID(ulong _ID)
        {
            BasePlayer _player = BasePlayer.FindByID(_ID);
            if (_player == null) _player = BasePlayer.FindSleeping(_ID);
            return _player;
        }
        #endregion

        #region Hooks
        public void updatePvXPlayerData(BasePlayer _player)
        {
            playerData.Info[_player.userID].username = _player.displayName;
            playerData.Info[_player.userID].LatestConnection = DateTimeStamp();
        }
        bool isPvEUlong(ulong _playerID)
        {
            if (_playerID == 0 || isNPC(_playerID)) return false;
            BasePlayer _player = basePlayerByID(_playerID);
            if (_player == null) return false;
            if (!InfoCache.ContainsKey(_playerID))
            {
                addPlayer(_player);
                return false;
            }
            if (InfoCache[_playerID].mode == "pve") return true;
            else return false;
        }
        bool isPvEBaseplayer(BasePlayer _player)
        {
            ulong _playerID = _player.userID;
            if (_playerID == 0 || isNPC(_playerID)) return false;
            if (_player == null) return false;
            if (!InfoCache.ContainsKey(_playerID))
            {
                addPlayer(_player);
                return false;
            }
            if (InfoCache[_playerID].mode == "pve") return true;
            else return false;
        }
        #endregion

        #region Chat/Console Handles
        [ChatCommand("pvx")]
        void PvXChatCmd(BasePlayer _player, string cmd, string[] args)
        {
            if ((args == null) || (args.Length == 0))
            {
                LangMSG(_player, "ComndList");
                ChatMessageHandle(_player, "/pvx select, /pvx change, /pvx ticket /pvx gui");
                if (hasPerm(_player, "admin")) ChatMessageHandle(_player, "/pvx select, /pvx admin");
                return;
            }
            switch (args[0].ToLower())
            {
                case "admin": //meed to transfer accept/dec;ome/list function
                    adminFunction(_player, args);
                    return;
                case "change": //Completed
                    changeFunction(_player);
                    return;
                case "debug":
                    debugFunction();
                    return;
                case "developer":
                    developerFunction();
                    return;
                case "help":
                    helpFunction(_player);
                    return;
                case "select":
                    selectFunction(_player, args);
                    return;
                case "ticket":
                    ticketFunction(_player, args);
                    return;
                case "gui":
                    guiFunction(_player, args);
                    return;
                default:
                    LangMSG(_player, "ComndList");
                    ChatMessageHandle(_player, "/pvx select, /pvx change, /pvx ticket /pvx gui");
                    if (hasPerm(_player, "admin")) ChatMessageHandle(_player, "/pvx select, /pvx admin");
                    return;
            }
        }

        [ConsoleCommand("pvx.cmd")]
        void PvXConsoleCmd(ConsoleSystem.Arg arg)
        {
            if (arg.connection != null) return;
            if (arg.Args == null || arg.Args.Length == 0) Puts("Hello");
            consolListTickets();
            consolListLog();
        }

        [ConsoleCommand("PvXGuiCMD")]
        void PvXGuiCMD(ConsoleSystem.Arg arg)
        {
            if (arg.Args.Length != 1)return;
            if (arg.Args[0] != "pvp" && arg.Args[0] != "pve")return;
            BasePlayer _player = (BasePlayer)arg.connection.player;
            if (_player == null) return;
            string cmdValue = arg.Args[0];
            if (isplayerNA(_player))
            {
                InfoCache[_player.userID].mode = cmdValue;
                saveCacheData();
                updatePvXIndicator(_player);
                updatePlayerChatTag(_player);
                ChatMessageHandle(_player, "Selected: {0}", cmdValue);
            }
            DestroyPvXUI(_player, pvxPlayerSelectorUI);
        }

        [ChatCommand("pvxhide")]
        void test1(BasePlayer _player, string cmd, string[] args)
        {
            DestroyAllPvXUI(_player);
        }
        [ChatCommand("pvxshow")]
        void test(BasePlayer _player, string cmd, string[] args)
        {
            createPvXIndicator(_player);
            createAdminIndicator(_player);
        }
        #endregion

        #region Chat Functions
        //chat
        void adminFunction(BasePlayer _player, string[] args)
        {
            if (args.Length < 2 || args.Length > 3)
            {
                LangMSG(_player, "IncoFormPleaUse");
                ChatMessageHandle(_player, "/pvx admin [list/accept/decline/display]");
                return;
            }
            string _cmd = args[1].ToLower(); // admin, accept, 1
            if (!(hasPerm(_player, "admin", "MissPerm"))) return;
            if (_cmd == "count") ticketCount(_player);
            if (_cmd == "list") listTickets(_player);
            if (_cmd == "mode") adminMode(_player);
            if ((_cmd == "display") && (args.Length == 3))
            {
                if (IsDigitsOnly(args[2]))
                    displayTicket(_player, Convert.ToInt32(args[2]));
            }
            if ((_cmd == "accept") && (args.Length == 3))
            {
                if ((IsDigitsOnly(args[2])) && (ticketData.Link.ContainsKey(Convert.ToInt32(args[2]))))
                    ticketAccept(_player, Convert.ToInt32(args[2]));
                else if (!(ticketData.Link.ContainsKey(Convert.ToInt32(args[2]))))
                    LangMSG(_player, "TickNotAvail", args[2]);
                else
                {
                    LangMSG(_player, "IncoFormPleaUse");
                    ChatMessageHandle(_player, "/pvx admin accept #");
                }
            }
            if ((_cmd == "decline") && (args.Length == 3))
            {
                if ((IsDigitsOnly(args[2])) && (ticketData.Link.ContainsKey(Convert.ToInt32(args[2]))))
                    ticketDecline(_player, Convert.ToInt32(args[2]));
                else if (!(ticketData.Link.ContainsKey(Convert.ToInt32(args[2]))))
                    LangMSG(_player, "TickNotAvail", args[2]);
                else
                {
                    LangMSG(_player, "IncoFormPleaUse");
                    ChatMessageHandle(_player, "/pvx admin decline #");
                }
            }
        }
        void changeFunction(BasePlayer _player)
        {
            if (playerHasTicket(_player) == true)
            {
                ChatMessageHandle(_player, "AlreadySubmitted"); return;
            }
            else if (isplayerNA(_player))
            {
                LangMSG(_player, "IncoFormPleaUse");
                ChatMessageHandle(_player, "/pvx select [pvp/pve]");
                return;
            }
            else if (isPvP(_player)) createTicket(_player, "pve");
            else if (isPvE(_player)) createTicket(_player, "pvp");
            else PutsPlayerHandle(_player, "Error: 27Q1 - Please inform Dev");
            return;
        }
        void selectFunction(BasePlayer _player, string[] args)
        {
            if ((args.Length != 2) && (args[1] != "pve") && (args[1] != "pvp"))
            {
                LangMSG(_player, "IncoFormPleaUse");
                ChatMessageHandle(_player, "/pvx select [pvp/pve]");
            }
            else if (InfoCache[_player.userID].mode == "NA")
            {
                InfoCache[_player.userID].mode = args[1].ToLower();
                saveCacheData();
                updatePvXIndicator(_player);
            }
        }
        void ticketFunction(BasePlayer _player, string[] args)
        {
            if (args.Length < 2 || args.Length > 3)
            {
                LangMSG(_player, "IncoFormPleaUse");
                ChatMessageHandle(_player, "/pvx ticket cancel");
                ChatMessageHandle(_player, "/pvx ticket reason ''reason on ticket''");
                return;
            }
            string _cmd = args[1].ToLower();
            if (InfoCache[_player.userID].ticket == false)
            {
                LangMSG(_player, "NoActTick");
                return;
            }
            if (_cmd == "cancel")
            {
                cancelTicket(_player);
            }
            if ((_cmd == "reason") && (args.Length == 3))
            {
                ticketData.Info[_player.userID].reason = args[2];
                LangMSG(_player, "RSNChan");
                ChatMessageHandle(_player, args[2]);
                SaveAll();
                return;
            }
        }
        void guiFunction(BasePlayer _player, string[] args)
        {
            if (args.Length == 1)
            {
                LangMSG(_player, "ComndList");
                ChatMessageHandle(_player, "/pvx gui pvx on/off");
                if (hasPerm(_player, "admin")) ChatMessageHandle(_player, "/pvx gui admin on/off");
                return;
            }
            if (!(args.Length == 3)) return;
            if ((args[1].ToLower() == "admin") && (hasPerm(_player, "admin")))
            {
                if (args[2].ToLower() == "on") createAdminIndicator(_player);
                else if (args[2].ToLower() == "off") DestroyPvXUI(_player, pvxAdminUI);
                return;
            }
            else if (args[1].ToLower() == "pvx")
            {
                if (args[2].ToLower() == "on") createPvXIndicator(_player);
                else if (args[2].ToLower() == "off") DestroyPvXUI(_player, pvxPlayerUI);
                return;
            }
            return;
        }
        void debugFunction()
        { }
        void developerFunction()
        { }
        void helpFunction(BasePlayer _player)
        {
            ChatMessageHandle(_player, "Plugin: PvX");
            ChatMessageHandle(_player, "Description: {0}", Description); 
            ChatMessageHandle(_player, "Version {0}", Version);
            ChatMessageHandle(_player, "Mod Developer: Alphawar");
        }

        //console

        #endregion


        #region OnEntityTakeDamage
        void OnEntityTakeDamage(BaseCombatEntity _target, HitInfo hitinfo)
        {
            BaseEntity _attacker = hitinfo.Initiator;
            object _n = _target.GetType();

            /*
            if (_target is BasePlayer && 1 == 1){
                BasePlayer _test = (BasePlayer)_target;
                if (_test.userID == 76561198006265515) testvar(_target, hitinfo);}
            else if (BuildEntityList.Contains(_n) && 1 == 1){
                if (_target.OwnerID == 76561198006265515) testvar(_target, hitinfo);}
            */

            if (_attacker is BasePlayer && _target is BasePlayer) PlayerVPlayer((BasePlayer)_target, (BasePlayer)_attacker, hitinfo);                               //Player V Player
            else if (_attacker is BasePlayer && BuildEntityList.Contains(_n) && !(_n is AutoTurret)) PlayerVBuilding(_target, (BasePlayer)_attacker, hitinfo);      //Player V Building

            else if (_attacker is BasePlayer && _target is BaseHelicopter) PlayerVHeli((BasePlayer)_attacker, hitinfo);                                             //Player V Heli
            else if ((_attacker is BaseHelicopter||(_attacker is FireBall && _attacker.ShortPrefabName == "napalm")) && _target is BasePlayer) HeliVPlayer((BasePlayer)_target, hitinfo);
            else if ((_attacker is BaseHelicopter || (_attacker is FireBall && _attacker.ShortPrefabName == "napalm")) && BuildEntityList.Contains(_n)) HeliVBuilding(_target, hitinfo);
            else if ((_attacker is BaseHelicopter || (_attacker is FireBall && _attacker.ShortPrefabName == "napalm")) && _target is BaseNPC) HeliVAnimal((BaseNPC)_target, hitinfo);
            

            else if (_attacker is BasePlayer && _target is AutoTurret) PlayerVTurret((AutoTurret)_target, (BasePlayer)_attacker, hitinfo);                          //Player V Turret
            else if (_attacker is AutoTurret && _target is BasePlayer) TurretVPlayer((BasePlayer)_target, (AutoTurret)_attacker, hitinfo);                          //Turret V Player
            else if (_attacker is AutoTurret && _target is AutoTurret) TurretVTurret((AutoTurret)_target, (AutoTurret)_attacker, hitinfo);                          //Turret V Turret
            else if (_attacker is AutoTurret && _target is BaseNPC) TurretVAnimal((BaseNPC)_target, (AutoTurret)_attacker, hitinfo);                                //Turret V Animal

            else if (_attacker is BasePlayer && _target is BaseNPC) PlayerVAnimal((BasePlayer)_attacker, hitinfo);                                                  //Player V Animal
            else if (_attacker is BaseNPC && _target is BasePlayer) AnimalVPlayer((BasePlayer)_target, hitinfo);
            else if (_attacker is FireBall)
            {
                FireBall _fire = (FireBall)_attacker;
                if (_target is BasePlayer) FireVPlayer((BasePlayer)_target, hitinfo);
                else if (BuildEntityList.Contains(_n)) FireVBuilding(_target, hitinfo);
            }

            
            //if (hitinfo.Initiator is BaseTrap)
            //if (hitinfo.Initiator is Barricade)
            //if (hitinfo.WeaponPrefab.ShortPrefabName == "rocket_heli" ||
            //hitinfo.WeaponPrefab.ShortPrefabName == "rocket_heli_napalm")
            //if (hitinfo.Initiator != null && hitinfo.Initiator.ShortPrefabName == "napalm")
        }

        void testvar(BaseCombatEntity _target, HitInfo hitinfo)
        {
            //Type typeInformation = hitinfo.Initiator.GetType();
            //BaseHelicopter
            //_attacker is FireBall && _attacker.ShortPrefabName = fireball_small
        }
        void PlayerVPlayer(BasePlayer _victim, BasePlayer _attacker, HitInfo _hitinfo)
        {
            //Puts("Calling PvP");
            if (BaseplayerCheck(_attacker, _victim)) return;
            if (isNPC(_attacker))
            {
                if (isNPC(_victim)) return;
                else if (isPvE(_victim) && NPCAttackPvE) ModifyDamage(_hitinfo, NPCDamagePvE);
                else if (isPvP(_victim) && NPCAttackPvP) ModifyDamage(_hitinfo, NPCDamagePvP);
                else ModifyDamage(_hitinfo, 0);
            }
            else if (isPvE(_attacker))
            {
                if (isNPC(_victim)) if (PvEAttackNPC) ModifyDamage(_hitinfo, PvEDamageNPC); else ModifyDamage(_hitinfo, 0);
                else if (isPvE(_victim) && PvEAttackPvE) ModifyDamage(_hitinfo, PvEDamagePvE);
                else if (isPvP(_victim) && PvEAttackPvP) ModifyDamage(_hitinfo, PvEDamagePvP);
                else ModifyDamage(_hitinfo, 0);
            }
            else if (isPvP(_attacker))
            {
                if (isNPC(_victim)) if (PvPAttackNPC) ModifyDamage(_hitinfo, PvPDamageNPC); else ModifyDamage(_hitinfo, 0);
                else if (isPvE(_victim) && PvPAttackPvE) ModifyDamage(_hitinfo, PvPDamagePvE);
                else if (isPvP(_victim) && PvPAttackPvP) ModifyDamage(_hitinfo, PvPDamagePvP);
                else ModifyDamage(_hitinfo, 0);
            }
            if (InfoCache[_victim.userID].mode == "pve")
            {
                if (!antiChatSpam.Contains(_attacker.userID))
                {
                    antiChatSpam.Add(_attacker.userID);
                    timer.Once(2f, () => antiChatSpam.Remove(_attacker.userID));
                    LangMSG(_attacker, lang.GetMessage("PvETarget", this, _attacker.UserIDString));
                }
                _victim.EndLooting();
            }
            //if (_victim.userID == 76561198006265515)
            //{
            //    Puts("AttackerBP: {0}", _attacker);
            //    Puts("VARE: {0}", hitinfo.Initiator);
            //    Puts("VARE: {0}", hitinfo.InitiatorPlayer);
            //}
            return;
        }
        void PlayerVBuilding(BaseEntity _target, BasePlayer _attacker, HitInfo _hitinfo)
        {
            //Puts("Calling PvB");
            ulong _victim = _target.OwnerID;
            if (_target.OwnerID == 0) return;
            if (isInEvent(_attacker)) return;
            if (_target.OwnerID == _attacker.userID) return;
            if (isGod(_target.OwnerID)) return;
            if (isGod(_attacker)) return;
            if (isNPC(_attacker))
            {
                if (isNPC(_victim)) return;
                else if (isPvE(_victim) && NPCAttackPvE) ModifyDamage(_hitinfo, NPCDamagePvE);
                else if (isPvP(_victim) && NPCAttackPvP) ModifyDamage(_hitinfo, NPCDamagePvP);
                else ModifyDamage(_hitinfo, 0);
            }
            else if (isPvE(_attacker))
            {
                if (isNPC(_victim)) if (PvEAttackNPC) ModifyDamage(_hitinfo, PvEDamageNPC); else ModifyDamage(_hitinfo, 0);
                else if (areInEvent(_attacker, _attacker)) return;
                else if (isPvE(_victim) && PvEAttackPvE) ModifyDamage(_hitinfo, PvEDamagePvE);
                else if (isPvP(_victim) && PvEAttackPvP) ModifyDamage(_hitinfo, PvEDamagePvP);
                else ModifyDamage(_hitinfo, 0);
            }
            else if (isPvP(_attacker))
            {
                if (isNPC(_victim)) if (PvPAttackNPC) ModifyDamage(_hitinfo, PvPDamageNPC); else ModifyDamage(_hitinfo, 0);
                else if (areInEvent(_attacker, _attacker)) return;
                else if (isPvE(_victim) && PvPAttackPvE) ModifyDamage(_hitinfo, PvPDamagePvE);
                else if (isPvP(_victim) && PvPAttackPvP) ModifyDamage(_hitinfo, PvPDamagePvP);
                else ModifyDamage(_hitinfo, 0);
            }
            if (InfoCache[_victim].mode == "pve")
            {
                if (!antiChatSpam.Contains(_attacker.userID))
                {
                    antiChatSpam.Add(_attacker.userID);
                    timer.Once(2f, () => antiChatSpam.Remove(_attacker.userID));
                    LangMSG(_attacker, lang.GetMessage("PvETarget", this, _attacker.UserIDString));
                }
            }
        }

        void PlayerVHeli(BasePlayer _attacker, HitInfo _hitinfo)
        {
            //Puts("Calling PvH");
            if (isNPC(_attacker)) return;
            else if (isGod(_attacker)) return;
            else if (isInEvent(_attacker)) return;
            else if (isPvE(_attacker) && HeliTargetPvE) ModifyDamage(_hitinfo, HeliDamageByPvE);
            else if (isPvP(_attacker) && HeliTargetPvP) ModifyDamage(_hitinfo, HeliDamageByPvP);
            else ModifyDamage(_hitinfo, 0);
        }
        void HeliVPlayer(BasePlayer _victim, HitInfo _hitinfo)
        {
            Puts("Calling HvP");
            if (isNPC(_victim)) return;
            else if (isGod(_victim)) return;
            else if (isInEvent(_victim)) return;
            else if (isPvE(_victim) && HeliTargetPvE) ModifyDamage(_hitinfo, HeliDamagePvE);
            else if (isPvP(_victim) && HeliTargetPvP) ModifyDamage(_hitinfo, HeliDamagePvP);
            else ModifyDamage(_hitinfo, 0);
        }
        void HeliVBuilding(BaseEntity _target, HitInfo _hitinfo)
        {
            //Puts("Calling HvB");
            ulong _ownerID = _target.OwnerID;
            if (isNPC(_ownerID)) return;
            else if (isGod(_ownerID)) return;
            else if (isPvE(_ownerID) && HeliTargetPvE) ModifyDamage(_hitinfo, HeliDamagePvEStruct);
            else if (isPvP(_ownerID) && HeliTargetPvP) ModifyDamage(_hitinfo, HeliDamagePvPStruct);
            else ModifyDamage(_hitinfo, 0);
        }
        void HeliVAnimal(BaseNPC _target, HitInfo _hitinfo)
        {
            //Puts("Calling HvA");
            ModifyDamage(_hitinfo, HeliDamageAnimal);
        }

        void PlayerVTurret(AutoTurret _target, BasePlayer _attacker, HitInfo _hitinfo)
        {
            //Puts("Calling PvT");
            ulong _ownerID = _target.OwnerID;
            if (isGod(_attacker)) return;
            else if (isInEvent(_attacker)) return;
            else if (isNPC(_attacker) && isPvE(_ownerID)) ModifyDamage(_hitinfo, TurretPvEDamageNPCAmnt);
            else if (isNPC(_attacker) && isPvP(_ownerID)) ModifyDamage(_hitinfo, TurretPvPDamageNPCAmnt);
            else if (isPvE(_attacker) && isPvE(_ownerID)) ModifyDamage(_hitinfo, TurretPvEDamagePvEAmnt);
            else if (isPvE(_attacker) && isPvP(_ownerID)) ModifyDamage(_hitinfo, TurretPvEDamagePvPAmnt);
            else if (isPvP(_attacker) && isPvE(_ownerID)) ModifyDamage(_hitinfo, TurretPvPDamagePvEAmnt);
            else if (isPvP(_attacker) && isPvP(_ownerID)) ModifyDamage(_hitinfo, TurretPvPDamagePvPAmnt);
            else ModifyDamage(_hitinfo, 0);
        }
        void TurretVPlayer(BasePlayer _target, AutoTurret _attacker, HitInfo _hitinfo)
        {
            //Puts("Calling TvP");
            ulong _attackerID = _attacker.OwnerID;
            if (isGod(_target)) return;
            else if (isInEvent(_target)) return;
            else if (isPvE(_attackerID) && isNPC(_target)) ModifyDamage(_hitinfo, TurretPvEDamageNPCAmnt);
            else if (isPvP(_attackerID) && isNPC(_target)) ModifyDamage(_hitinfo, TurretPvPDamageNPCAmnt);
            else if (isPvE(_attackerID) && isPvE(_target)) ModifyDamage(_hitinfo, TurretPvEDamagePvEAmnt);
            else if (isPvE(_attackerID) && isPvP(_target)) ModifyDamage(_hitinfo, TurretPvEDamagePvPAmnt);
            else if (isPvP(_attackerID) && isPvE(_target)) ModifyDamage(_hitinfo, TurretPvPDamagePvEAmnt);
            else if (isPvP(_attackerID) && isPvP(_target)) ModifyDamage(_hitinfo, TurretPvPDamagePvPAmnt);
            else ModifyDamage(_hitinfo, 0);
        }
        void TurretVTurret(AutoTurret _target, AutoTurret _attacker, HitInfo _hitinfo)
        {
            //Puts("Calling TvT");
            ulong _targetID = _target.OwnerID;
            ulong _attackerID = _target.OwnerID;
            if (isPvE(_attackerID) && isPvE(_targetID)) ModifyDamage(_hitinfo, TurretPvEDamagePvEAmnt);
            else if (isPvE(_attackerID) && isPvP(_targetID)) ModifyDamage(_hitinfo, TurretPvEDamagePvPAmnt);
            else if (isPvP(_attackerID) && isPvE(_targetID)) ModifyDamage(_hitinfo, TurretPvPDamagePvEAmnt);
            else if (isPvP(_attackerID) && isPvP(_targetID)) ModifyDamage(_hitinfo, TurretPvPDamagePvPAmnt);
            else ModifyDamage(_hitinfo, 0);
        }
        void TurretVAnimal(BaseNPC _target, AutoTurret _attacker, HitInfo _hitinfo)
        {
            //Puts("Calling TvA");
            ulong _turretOwner = _attacker.OwnerID;
            if (isPvE(_turretOwner) && TurretPvETargetAnimal) ModifyDamage(_hitinfo, TurretPvEDamageAnimalAmnt);
            else if (isPvP(_turretOwner) && TurretPvPTargetAnimal) ModifyDamage(_hitinfo, TurretPvPDamageAnimalAmnt);
            else ModifyDamage(_hitinfo, 0);
        }

        void PlayerVAnimal(BasePlayer _attacker, HitInfo _hitinfo)
        {
            //Puts("Calling PvA");
            if (isGod(_attacker)) return;
            else if (isInEvent(_attacker)) return;
            else if (isNPC(_attacker)) ModifyDamage(_hitinfo, NPCDamageAnimals);
            else if (isPvE(_attacker)) ModifyDamage(_hitinfo, PvEDamageAnimals);
            else if (isPvP(_attacker)) ModifyDamage(_hitinfo, PvPDamageAnimals);
            else ModifyDamage(_hitinfo, 0);
        }
        void AnimalVPlayer(BasePlayer _target, HitInfo _hitinfo)
        {
            //Puts("Calling AvP");
            if (isGod(_target)) return;
            else if (isInEvent(_target)) return;
            else if (isNPC(_target)) ModifyDamage(_hitinfo, AnimalsDamageNPC);
            else if (isPvE(_target)) ModifyDamage(_hitinfo, AnimalsDamagePvE);
            else if (isPvP(_target)) ModifyDamage(_hitinfo, AnimalsDamagePvP);
            else if (isplayerNA(_target)) ModifyDamage(_hitinfo, 1);
            else ModifyDamage(_hitinfo, 0);
        }

        void FireVPlayer(BasePlayer _target, HitInfo _hitinfo)
        {
            if (isNPC(_target)) return;
            else if (isGod(_target)) return;
            else if (isInEvent(_target)) return;
            else if (isPvE(_target)) ModifyDamage(_hitinfo, FireDamagePvE);
            else if (isPvP(_target)) ModifyDamage(_hitinfo, FireDamagePvP);
            else ModifyDamage(_hitinfo, 0);
        }
        void FireVBuilding(BaseEntity _target, HitInfo _hitinfo)
        {
            Puts("Calling FvB");
            if (isPvE(_target.OwnerID)) ModifyDamage(_hitinfo, FireDamagePvEStruc);
            else if (isPvP(_target.OwnerID)) ModifyDamage(_hitinfo, FireDamagePvPStruc);
            else ModifyDamage(_hitinfo, 0);
        }
        #endregion

        #region CanBeTargeted
        private object CanBeTargeted(BaseCombatEntity _target, MonoBehaviour turret)
        {
            if (turret is HelicopterTurret && _target is BasePlayer && HeliTargetPlayer((BasePlayer)_target)) return null;
            else if (turret is AutoTurret && _target is BasePlayer && TurretTargetPlayer((BasePlayer)_target, (AutoTurret)turret)) return null;
            else if (turret is AutoTurret && _target is BaseNPC && TurretTargetAnimals((BaseNPC)_target, (AutoTurret)turret)) return null;
            else return false;
        }

        bool HeliTargetPlayer(BasePlayer _target)
        {
            if (isNPC(_target) && HeliTargetNPC) return true;
            else if (checkInvis(_target)) return true;
            else if (isPvE(_target) && HeliTargetPvE) return true;
            else if (isPvP(_target) && HeliTargetPvP) return true;
            return false;
        }
        bool TurretTargetPlayer(BasePlayer _target, AutoTurret _attacker)
        {
            ulong _OwnerID = _attacker.OwnerID;
            if (!isNPC(_target) && checkInvis(_target)) return true;
            else if (isPvE(_OwnerID) && isNPC(_target) && TurretPvETargetNPC) return true;
            else if (isPvE(_OwnerID) && isPvE(_target) && TurretPvETargetPvE) return true;
            else if (isPvE(_OwnerID) && isPvP(_target) && TurretPvETargetPvP) return true;
            else if (isPvP(_OwnerID) && isNPC(_target) && TurretPvPTargetNPC) return true;
            else if (isPvP(_OwnerID) && isPvE(_target) && TurretPvPTargetPvE) return true;
            else if (isPvP(_OwnerID) && isPvP(_target) && TurretPvPTargetPvP) return true;
            return false;
        }
        bool TurretTargetAnimals(BaseNPC _target, AutoTurret _attacker)
        {
            ulong _OwnerID = _attacker.OwnerID;
            if (isPvE(_OwnerID) && TurretPvETargetAnimal) return true;
            if (isPvP(_OwnerID) && TurretPvPTargetAnimal) return true;
            return false;
        }
        #endregion

        //void OnEntityEnter(TriggerBase trigger, BaseEntity entity)
        //{
        //    if(trigger is BuildPrivilegeTrigger)
        //        trigger.
        //    Puts("OnEntityEnter works!");
        //}
        //void OnEntityLeave(TriggerBase trigger, BaseEntity entity)
        //{
        //    Puts("OnEntityLeave works!");
        //}

        void adminMode(BasePlayer _player)
        {
            if (AdminPlayerMode.Contains(_player))
            {
                LangMSG(_player, "AdmModeRem");
                AdminPlayerMode.Remove(_player);
                updatePvXIndicator(_player);
                return;
            }
            else AdminPlayerMode.Add(_player);
            LangMSG(_player, "AdmModeAdd");
            updatePvXIndicator(_player);
        }
        bool isInAdminMode(BasePlayer _player)
        {
            if (AdminPlayerMode.Contains(_player)) return true;
            return false;
        }
        void OnItemRemovedFromContainer(ItemContainer container, Item item)
        {
            //Puts("Container is type {0}", container.GetType());
            //Puts("Container is type {0}", container.entityOwner);
            //Puts("Container is type {0}", container.playerOwner);
            if (container.entityOwner != null) return;
            if (container.playerOwner != null)
            {
                BasePlayer _player = container.playerOwner;
                if (isInAdminMode(_player)) item.ClearOwners();
            }
        }


        



        void ModifyDamage(HitInfo hitinfo, float scale)
        {
            if (scale == 0f)
            {
                hitinfo.damageTypes = new DamageTypeList();
                hitinfo.DoHitEffects = false;
                hitinfo.HitMaterial = 0;
                hitinfo.PointStart = Vector3.zero;
                hitinfo.PointEnd = Vector3.zero;
            }
            else if (scale == 1) return;
            else
            {
                //Puts("Modify Damabe by: {0}", scale);
                hitinfo.damageTypes.ScaleAll(scale);
            }
        }

        string DateTimeStamp()
        {
            return DateTime.Now.ToString("HH:mm dd-MM-yyyy");
        }
        double GetTimeStamp()
        {
            return (DateTime.Now.Subtract(new DateTime(1970, 1, 1))).TotalSeconds;
        }



        //////////////////////////////////////////////////////////////////////////////////////
        // Debug /////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////

        int DebugLevel = 0;
        void DebugMessage(int _minDebuglvl, string _msg)
        {
            if (DebugLevel >= _minDebuglvl)
            {
                Puts(_msg);
                if (DebugLevel == 3 && _minDebuglvl == 1)
                {
                    PrintToChat(_msg);
                }
            }
        }
        void OnRunPlayerMetabolism(PlayerMetabolism metabolism)
        {
            //if (metabolism.bleeding.GetType)
            //if (metabolism.heartrate) return;
            //if (metabolism.hydration) return;
            //if (metabolism.calories) return;
        }
    }
}

//Ticket accepted should be fixed for offline/dead players, now add update mechanism on playerinit
// config color + opacity
// Fix up/Shorten hooks eg: 



// --- End of file: PvXselector.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Friends (2).cs ---
// --- Original Local Path: Friends (2).cs ---

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text.RegularExpressions;
using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using ProtoBuf;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("Friends", "Sempai#3239", "1.21.1")]
    [Description("Adds a friends system with a visual interface for quick interaction")]
    public class Friends : RustPlugin
    {
        #region Fields

        [PluginReference] private Plugin ImageLibrary, Notifications, PlayerList, PlayerDatabase;

        private const string Layer = "Com.Mevent.Main";

        private static Friends _instance;

        private readonly Dictionary<ulong, EntityEntry> _playerEntities = new Dictionary<ulong, EntityEntry>();

        private class EntityEntry
        {
            public HashSet<AutoTurret> AutoTurrets = new HashSet<AutoTurret>();
            public HashSet<BuildingPrivlidge> BuildingPrivileges = new HashSet<BuildingPrivlidge>();
        }

        private enum AutoAuthType
        {
            All,
            Turret,
            Cupboard
        }

        private enum BtnType
        {
            None,
            Doors,
            Cupboard,
            Turrets,
            Containers,
            FriendlyFire,
            Sams
        }

        #endregion

        #region Config

        private static Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Добавлять в команду | Add to team")]
            public readonly bool AddTeam = true;

            [JsonProperty(PropertyName = "Максимальное кол-во друзей | Max Friends")]
            public readonly int MaxFriendsAmount = 3;

            [JsonProperty(PropertyName = "Задержка между сообщениями FF | Delay between FF messages")]
            public readonly float FFDelay = 1;

            [JsonProperty(PropertyName =
                "Закрывать интерфейс после нажатия на кнопку | Close the interface after clicking on the button")]
            public bool AutoClose = true;

            [JsonProperty(PropertyName = "Огонь по друзьям | Friendly Fire")]
            public bool FriendlyFire;

            [JsonProperty(PropertyName = "Двери | Doors")]
            public readonly bool Doors = true;

            [JsonProperty(PropertyName = "Турели | Turrets")]
            public readonly bool Turrets = true;

            [JsonProperty(PropertyName = "Шкаф | Cupboard")]
            public readonly bool Cupboard = true;

            [JsonProperty(PropertyName = "Ящики | Containers")]
            public readonly bool Containers = true;

            [JsonProperty(PropertyName = "ПВО | SAMs")]
            public bool SAMs = true;

            [JsonProperty(PropertyName = "Добавлять друга к остальным друзьям? | Add a friend to other friends?")]
            public bool UseTeams = true;

            [JsonProperty(PropertyName = "Включить логирование в консоль? | Enable logging to the console?")]
            public readonly bool LogToConsole = true;

            [JsonProperty(PropertyName = "Включить логирование в файл? | Enable logging to the file?")]
            public readonly bool LogToFile = true;

            [JsonProperty(PropertyName = "Фон | Background")]
            public readonly IPanel Background = new IPanel
            {
                AnchorMin = "0 0", AnchorMax = "1 1",
                OffsetMin = "0 0", OffsetMax = "0 0",
                Image = string.Empty,
                Color = new IColor("#0D1F4E", 95),
                isRaw = false,
                Sprite = "Assets/Content/UI/UI.Background.Tile.psd",
                Material = "Assets/Icons/IconMaterial.mat"
            };

            [JsonProperty(PropertyName = "Заглавие | Title")]
            public readonly IText Title = new IText
            {
                AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5",
                OffsetMin = "-150 300", OffsetMax = "150 360",
                Font = "robotocondensed-bold.ttf",
                Align = TextAnchor.MiddleCenter,
                FontSize = 38,
                Color = new IColor("#FFFFFF", 100)
            };

            [JsonProperty(PropertyName = "Закрыть | Close")]
            public readonly IText Close = new IText
            {
                AnchorMin = "1 1", AnchorMax = "1 1",
                OffsetMin = "-35 -35", OffsetMax = "-5 -5",
                Font = "robotocondensed-bold.ttf",
                Align = TextAnchor.MiddleCenter,
                FontSize = 24,
                Color = new IColor("#FFFFFF", 100)
            };

            [JsonProperty(PropertyName = "Ошибка | Error")]
            public readonly IText Error = new IText
            {
                AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5",
                OffsetMin = "-300 -150", OffsetMax = "300 150",
                Font = "robotocondensed-bold.ttf",
                Align = TextAnchor.MiddleCenter,
                FontSize = 38,
                Color = new IColor("#FFFFFF", 100)
            };

            [JsonProperty(PropertyName = "Назад | Back")]
            public readonly IText Back = new IText
            {
                AnchorMin = "0 0.5", AnchorMax = "0 0.5",
                OffsetMin = "0 -40", OffsetMax = "65 40",
                Font = "robotocondensed-bold.ttf",
                Align = TextAnchor.MiddleCenter,
                FontSize = 60,
                Color = new IColor("#FFFFFF", 100)
            };

            [JsonProperty(PropertyName = "Вперёд | Next")]
            public readonly IText Next = new IText
            {
                AnchorMin = "1 0.5", AnchorMax = "1 0.5",
                OffsetMin = "-65 -40", OffsetMax = "0 40",
                Font = "robotocondensed-bold.ttf",
                Align = TextAnchor.MiddleCenter,
                FontSize = 60,
                Color = new IColor("#FFFFFF", 100)
            };

            [JsonProperty(PropertyName = "Настройка интерфейса | Interface Settings")]
            public readonly IFriendPanel Panel = new IFriendPanel
            {
                AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5",
                Height = 100,
                Width = 820,
                Margin = 20,
                Count = 4,
                Color = new IColor("#1D3676", 100),
                Avatar = new InterfacePosition
                {
                    AnchorMin = "0 0", AnchorMax = "0 0",
                    OffsetMin = "5 5", OffsetMax = "95 95"
                },
                Nickname = new NickName
                {
                    AnchorMin = "0 0", AnchorMax = "0 0",
                    OffsetMin = "100 40", OffsetMax = "500 100",
                    Align = TextAnchor.LowerLeft,
                    Font = "robotocondensed-regular.ttf",
                    Color = new IColor("#FFFFFF", 100),
                    FontSize = 38,
                    MaxLength = 30
                },
                Status = new SText
                {
                    AnchorMin = "0 0", AnchorMax = "0 0",
                    OffsetMin = "100 0", OffsetMax = "200 50",
                    Align = TextAnchor.UpperLeft,
                    Font = "robotocondensed-regular.ttf",
                    Color = new IColor("#B5FFC9", 100),
                    OfflineColor = new IColor("#B46292", 100),
                    FontSize = 16
                },
                Button = new IButton
                {
                    AnchorMin = "1 0.5", AnchorMax = "1 0.5",
                    Height = 35,
                    Width = 120,
                    Margin = 5
                },
                Buttons = new List<FButton>
                {
                    new FButton
                    {
                        Type = BtnType.Doors,
                        Text = "Двери",
                        Command = "friend doors {user}",
                        ActiveColor = new IColor("#5D8FDF", 95),
                        DisactiveColor = new IColor("#5D8FDF", 35),
                        FontSize = 20,
                        Font = "robotocondensed-regular.ttf",
                        Align = TextAnchor.MiddleCenter,
                        TColor = new IColor("#1D3676", 100)
                    },
                    new FButton
                    {
                        Type = BtnType.Cupboard,
                        Text = "Шкаф",
                        Command = "friend cupboard {user}",
                        ActiveColor = new IColor("#5D8FDF", 95),
                        DisactiveColor = new IColor("#5D8FDF", 35),
                        FontSize = 20,
                        Font = "robotocondensed-regular.ttf",
                        Align = TextAnchor.MiddleCenter,
                        TColor = new IColor("#1D3676", 100)
                    },
                    new FButton
                    {
                        Type = BtnType.Containers,
                        Text = "Ящики",
                        Command = "friend containers {user}",
                        ActiveColor = new IColor("#5D8FDF", 95),
                        DisactiveColor = new IColor("#5D8FDF", 35),
                        FontSize = 20,
                        Font = "robotocondensed-regular.ttf",
                        Align = TextAnchor.MiddleCenter,
                        TColor = new IColor("#1D3676", 100)
                    },
                    new FButton
                    {
                        Type = BtnType.Turrets,
                        Text = "Турели",
                        Command = "friend turrets {user}",
                        ActiveColor = new IColor("#5D8FDF", 95),
                        DisactiveColor = new IColor("#5D8FDF", 35),
                        FontSize = 20,
                        Font = "robotocondensed-regular.ttf",
                        Align = TextAnchor.MiddleCenter,
                        TColor = new IColor("#1D3676", 100)
                    },
                    new FButton
                    {
                        Type = BtnType.None,
                        Text = "Исключить",
                        Command = "friend remove {user}",
                        ActiveColor = new IColor("#5D8FDF", 95),
                        DisactiveColor = new IColor("#5D8FDF", 35),
                        FontSize = 20,
                        Font = "robotocondensed-regular.ttf",
                        Align = TextAnchor.MiddleCenter,
                        TColor = new IColor("#1D3676", 100)
                    },
                    new FButton
                    {
                        Type = BtnType.FriendlyFire,
                        Text = "Урон",
                        Command = "ff {user}",
                        ActiveColor = new IColor("#5D8FDF", 95),
                        DisactiveColor = new IColor("#5D8FDF", 35),
                        FontSize = 20,
                        Font = "robotocondensed-regular.ttf",
                        Align = TextAnchor.MiddleCenter,
                        TColor = new IColor("#1D3676", 100)
                    },
                    new FButton
                    {
                        Type = BtnType.None,
                        Text = "ТП",
                        Command = "tpr {user}",
                        ActiveColor = new IColor("#5D8FDF", 95),
                        DisactiveColor = new IColor("#5D8FDF", 35),
                        FontSize = 20,
                        Font = "robotocondensed-regular.ttf",
                        Align = TextAnchor.MiddleCenter,
                        TColor = new IColor("#1D3676", 100)
                    },
                    new FButton
                    {
                        Type = BtnType.Sams,
                        Text = "ПВО",
                        Command = "friend sams {user}",
                        ActiveColor = new IColor("#5D8FDF", 95),
                        DisactiveColor = new IColor("#5D8FDF", 35),
                        FontSize = 20,
                        Font = "robotocondensed-regular.ttf",
                        Align = TextAnchor.MiddleCenter,
                        TColor = new IColor("#1D3676", 100)
                    }
                }
            };

            [JsonProperty(PropertyName = "Приглашение в друзья | Friend Invite")]
            public readonly INotify FriendInvite = new INotify
            {
                Image = "friend",
                Url = "https://i.imgur.com/qAxHQIn.png",
                Delay = 30,
                Buttons = new List<INotifyButton>
                {
                    new INotifyButton
                    {
                        AnchorMin = "0.5 0", AnchorMax = "0.5 0",
                        OffsetMin = "-137.5 5", OffsetMax = "-2.5 25",
                        Align = TextAnchor.MiddleCenter,
                        Font = "robotocondensed-regular.ttf",
                        FontSize = 14,
                        Color = new IColor("#FFFFFF", 95),
                        BColor = new IColor("#528A4E", 95),
                        Command = "friend accept",
                        Msg = "Accept"
                    },
                    new INotifyButton
                    {
                        AnchorMin = "0.5 0", AnchorMax = "0.5 0",
                        OffsetMin = "2.5 5", OffsetMax = "137.5 25",
                        Align = TextAnchor.MiddleCenter,
                        Font = "robotocondensed-regular.ttf",
                        FontSize = 14,
                        Color = new IColor("#FFFFFF", 95),
                        BColor = new IColor("#50488A", 95),
                        Command = "friend cancel",
                        Msg = "Cancel"
                    }
                }
            };

            [JsonProperty(PropertyName = "Оповещение | Notification")]
            public readonly INotify Notify = new INotify
            {
                Image = "friend",
                Url = "https://i.imgur.com/qAxHQIn.png",
                Delay = 5,
                Buttons = new List<INotifyButton>()
            };

            [JsonProperty(PropertyName = "Найти друга | Find a Friend")]
            public readonly INotifyButton FindFriendBtn = new INotifyButton
            {
                AnchorMin = "0.5 0", AnchorMax = "0.5 0",
                OffsetMin = "-150 25", OffsetMax = "150 60",
                Align = TextAnchor.MiddleCenter,
                FontSize = 14,
                Font = "robotocondensed-regular.ttf",
                Color = new IColor("#5D8FDF", 100),
                BColor = new IColor("#1D3676", 100),
                Command = "playerslist",
                Msg = "FindFriend"
            };

            [JsonProperty(PropertyName = "PlayerDatabase")]
            public readonly PlayerDatabaseConf PlayerDatabase =
                new PlayerDatabaseConf(false, "Friends");

            public VersionNumber Version;
        }

        private class PlayerDatabaseConf
        {
            [JsonProperty(PropertyName = "Включено")]
            public readonly bool Enabled;

            [JsonProperty(PropertyName = "Поле")] public readonly string Field;

            public PlayerDatabaseConf(bool enabled, string field)
            {
                Enabled = enabled;
                Field = field;
            }
        }

        private class NickName : IText
        {
            [JsonProperty(PropertyName = "Максимальная длина | Max Lenght")]
            public int MaxLength;

            public new void Get(ref CuiElementContainer container, string parent = "Hud", string name = null,
                string text = "")
            {
                if (string.IsNullOrEmpty(name))
                    name = CuiHelper.GetGuid();

                text = text.Substring(0, Mathf.Min(text.Length, MaxLength));

                container.Add(new CuiLabel
                {
                    RectTransform =
                        {AnchorMin = AnchorMin, AnchorMax = AnchorMax, OffsetMin = OffsetMin, OffsetMax = OffsetMax},
                    Text =
                    {
                        Text = $"{text}", Align = Align, FontSize = FontSize, Color = Color.Get(),
                        Font = Font
                    }
                }, parent, name);
            }
        }

        private class INotify
        {
            [JsonProperty(PropertyName = "Ключ изображения | Image Key")]
            public string Image;

            [JsonProperty(PropertyName = "Ссылка на изображение | Image Url")]
            public string Url;

            [JsonProperty(PropertyName = "Время показа | Show Time")]
            public float Delay;

            [JsonProperty(PropertyName = "Кнопки | Buttons", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<INotifyButton> Buttons;
        }

        private class INotifyButton : IText
        {
            [JsonProperty(PropertyName = "Цвет | Color")]
            public IColor BColor;

            [JsonProperty(PropertyName = "Ключ языкового файла | Lang Key")]
            public string Msg;

            [JsonProperty(PropertyName = "Команда | Command")]
            public string Command;

            public void Get(ref CuiElementContainer container, BasePlayer player, string name = null,
                string parent = "")
            {
                if (string.IsNullOrEmpty(name))
                    name = CuiHelper.GetGuid();

                container.Add(new CuiButton
                {
                    RectTransform =
                        {AnchorMin = AnchorMin, AnchorMax = AnchorMax, OffsetMin = OffsetMin, OffsetMax = OffsetMax},
                    Text =
                    {
                        Text = _instance.Msg(Msg, player.UserIDString), Align = Align, FontSize = FontSize,
                        Color = Color.Get(),
                        Font = Font
                    },
                    Button =
                    {
                        Color = BColor.Get(),
                        Command = Command
                    }
                }, parent, name);
            }
        }

        private abstract class IAnchors
        {
            public string AnchorMin;

            public string AnchorMax;
        }

        private class InterfacePosition : IAnchors
        {
            public string OffsetMin;

            public string OffsetMax;
        }

        private class IFriendPanel : IAnchors
        {
            [JsonProperty(PropertyName = "Высота | Height")]
            public float Height;

            [JsonProperty(PropertyName = "Ширина | Width")]
            public float Width;

            [JsonProperty(PropertyName = "Отступ | Margin")]
            public float Margin;

            [JsonProperty(PropertyName = "Количество на странице | Count On Page")]
            public int Count;

            [JsonProperty(PropertyName = "Цвет | Color")]
            public IColor Color;

            [JsonProperty(PropertyName = "Аватарка | Avatar")]
            public InterfacePosition Avatar;

            [JsonProperty(PropertyName = "Никнейм | Nickname")]
            public NickName Nickname;

            [JsonProperty(PropertyName = "Статус | Status")]
            public SText Status;

            [JsonProperty(PropertyName = "Кнопка | Button")]
            public IButton Button;

            [JsonProperty(PropertyName = "Кнопки | Buttons", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<FButton> Buttons;

            public void Get(ref CuiElementContainer container, BasePlayer player, FriendData data, string parent,
                string name,
                string oMin, string oMax,
                int page,
                string mainParent)
            {
                if (string.IsNullOrEmpty(name))
                    name = CuiHelper.GetGuid();

                container.Add(new CuiPanel
                {
                    RectTransform =
                    {
                        AnchorMin = AnchorMin, AnchorMax = AnchorMax,
                        OffsetMin = oMin, OffsetMax = oMax
                    },
                    Image = {Color = Color.Get()}
                }, parent, name);

                if (_instance.ImageLibrary && Avatar != null)
                    container.Add(new CuiElement
                    {
                        Parent = name,
                        Components =
                        {
                            new CuiRawImageComponent
                                {Png = _instance.ImageLibrary.Call<string>("GetImage", $"avatar_{data.UserId}")},
                            new CuiRectTransformComponent
                            {
                                AnchorMin = Avatar.AnchorMin, AnchorMax = Avatar.AnchorMax,
                                OffsetMin = Avatar.OffsetMin, OffsetMax = Avatar.OffsetMax
                            }
                        }
                    });

                #region Name

                var targetId = $"{data.UserId}";

                var target = _instance.covalence.Players.FindPlayer(targetId);
                var displayName = _instance.GetPlayerName(data.UserId);

                var status = target != null && target.IsConnected;

                Nickname?.Get(ref container, name, name + ".Nickname", displayName);

                Status?.Get(ref container, status, name, name + ".Status",
                    _instance.Msg(status ? Online : Offline, player.UserIDString));

                #endregion

                #region Buttons

                if (Buttons != null)
                {
                    var xSwitch = -Button.Margin;

                    for (var i = 0; i < Buttons.Count; i++)
                    {
                        var button = Buttons[i];

                        var up = i < Buttons.Count / 2;

                        var ySwitch = up ? Button.Height + Button.Margin / 2f : -(Button.Margin / 2f);

                        button.Get(ref container, data, name, name + $".Btn.{i}", Button.AnchorMin, Button.AnchorMax,
                            $"{xSwitch - Button.Width} {ySwitch - Button.Height}",
                            $"{xSwitch} {ySwitch}",
                            page,
                            mainParent);

                        if (i + 1 == Buttons.Count / 2)
                            xSwitch = -Button.Margin;
                        else
                            xSwitch = xSwitch - Button.Margin - Button.Width;
                    }
                }

                #endregion
            }
        }

        private class IPanel : InterfacePosition
        {
            [JsonProperty(PropertyName = "Изображение | Image")]
            public string Image;

            [JsonProperty(PropertyName = "Цвет | Color")]
            public IColor Color;

            [JsonProperty(PropertyName = "Сохранять цвет изображения? | Save Image Color")]
            public bool isRaw;

            [JsonProperty(PropertyName = "Sprite")]
            public string Sprite;

            [JsonProperty(PropertyName = "Material")]
            public string Material;

            public void Get(ref CuiElementContainer container, string parent = "Hud", string name = null,
                bool cursor = false)
            {
                if (string.IsNullOrEmpty(name))
                    name = CuiHelper.GetGuid();

                if (isRaw)
                {
                    var element = new CuiElement
                    {
                        Name = name,
                        Parent = parent,
                        Components =
                        {
                            new CuiRawImageComponent
                            {
                                Png = !string.IsNullOrEmpty(Image)
                                    ? _instance.ImageLibrary.Call<string>("GetImage", Image)
                                    : null,
                                Color = Color.Get(),
                                Material = Material,
                                Sprite = !string.IsNullOrEmpty(Sprite) ? Sprite : "Assets/Icons/rust.png"
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = AnchorMin, AnchorMax = AnchorMax, OffsetMin = OffsetMin,
                                OffsetMax = OffsetMax
                            }
                        }
                    };

                    if (cursor) element.Components.Add(new CuiNeedsCursorComponent());

                    container.Add(element);
                }
                else
                {
                    container.Add(new CuiPanel
                    {
                        RectTransform =
                        {
                            AnchorMin = AnchorMin, AnchorMax = AnchorMax, OffsetMin = OffsetMin, OffsetMax = OffsetMax
                        },
                        Image =
                        {
                            Png = !string.IsNullOrEmpty(Image)
                                ? _instance.ImageLibrary.Call<string>("GetImage", Image)
                                : null,
                            Color = Color.Get(),
                            Sprite =
                                !string.IsNullOrEmpty(Sprite) ? Sprite : "Assets/Content/UI/UI.Background.Tile.psd",
                            Material = !string.IsNullOrEmpty(Material) ? Material : "Assets/Icons/IconMaterial.mat"
                        },
                        CursorEnabled = cursor
                    }, parent, name);
                }
            }
        }

        private class FButton
        {
            [JsonProperty(PropertyName = "Тип | Type")] [JsonConverter(typeof(StringEnumConverter))]
            public BtnType Type;

            [JsonProperty(PropertyName = "Текст | Text")]
            public string Text;

            [JsonProperty(PropertyName = "Команда | Command")]
            public string Command;

            [JsonProperty(PropertyName = "Активный Цвет | Active Color")]
            public IColor ActiveColor;

            [JsonProperty(PropertyName = "Неактивный Цвет | Disactive Color")]
            public IColor DisactiveColor;

            [JsonProperty(PropertyName = "Font Size")]
            public int FontSize;

            [JsonProperty(PropertyName = "Font")] public string Font;

            [JsonProperty(PropertyName = "Align")] [JsonConverter(typeof(StringEnumConverter))]
            public TextAnchor Align;

            [JsonProperty(PropertyName = "Text Color")]
            public IColor TColor;

            public void Get(ref CuiElementContainer container, FriendData data, string parent, string name, string aMin,
                string aMax, string oMin, string oMax, int page,
                string mainParent)
            {
                if (string.IsNullOrEmpty(name))
                    name = CuiHelper.GetGuid();

                var color = ActiveColor;

                switch (Type)
                {
                    case BtnType.Doors:
                        color = data.Doors ? ActiveColor : DisactiveColor;
                        break;
                    case BtnType.Cupboard:
                        color = data.Cupboard ? ActiveColor : DisactiveColor;
                        break;
                    case BtnType.Turrets:
                        color = data.Turrets ? ActiveColor : DisactiveColor;
                        break;
                    case BtnType.FriendlyFire:
                        color = data.FriendlyFire ? ActiveColor : DisactiveColor;
                        break;
                    case BtnType.Containers:
                        color = data.Containers ? ActiveColor : DisactiveColor;
                        break;
                    case BtnType.Sams:
                        color = data.SAMs ? ActiveColor : DisactiveColor;
                        break;
                }

                var text = Text.Replace("{user}", data.UserId.ToString());
                var command = Command.Replace("{user}", data.UserId.ToString());

                container.Add(new CuiButton
                {
                    RectTransform =
                    {
                        AnchorMin = aMin, AnchorMax = aMax,
                        OffsetMin = oMin, OffsetMax = oMax
                    },
                    Text =
                    {
                        Text = $"{text}",
                        Align = Align,
                        Font = Font,
                        FontSize = FontSize,
                        Color = TColor.Get()
                    },
                    Button =
                    {
                        Command =
                            $"UI_Friends sendcmd {page} {mainParent} {command}", // command.Contains("chat.say") ? $"friendssendcmd {command}" : $"{command}",
                        Color = color.Get(),
                        Close = _config.AutoClose ? Layer : string.Empty
                    }
                }, parent, name);
            }
        }

        private class IButton : IAnchors
        {
            [JsonProperty(PropertyName = "Высота | Height")]
            public float Height;

            [JsonProperty(PropertyName = "Ширина | Width")]
            public float Width;

            [JsonProperty(PropertyName = "Отступ | Margin")]
            public float Margin;
        }

        private class SText : InterfacePosition
        {
            [JsonProperty(PropertyName = "Font Size")]
            public int FontSize;

            [JsonProperty(PropertyName = "Font")] public string Font;

            [JsonProperty(PropertyName = "Align")] [JsonConverter(typeof(StringEnumConverter))]
            public TextAnchor Align;

            [JsonProperty(PropertyName = "Цвет игрока онлайн | Online Color")]
            public IColor Color;

            [JsonProperty(PropertyName = "Цвет игрока оффлайн | Offline Color")]
            public IColor OfflineColor;

            public void Get(ref CuiElementContainer container, bool online, string parent = "Hud", string name = null,
                string text = "")
            {
                if (string.IsNullOrEmpty(name))
                    name = CuiHelper.GetGuid();

                container.Add(new CuiLabel
                {
                    RectTransform =
                        {AnchorMin = AnchorMin, AnchorMax = AnchorMax, OffsetMin = OffsetMin, OffsetMax = OffsetMax},
                    Text =
                    {
                        Text = $"{text}", Align = Align, FontSize = FontSize,
                        Color = online ? Color.Get() : OfflineColor.Get(),
                        Font = Font
                    }
                }, parent, name);
            }
        }

        private class IText : InterfacePosition
        {
            [JsonProperty(PropertyName = "Font Size")]
            public int FontSize;

            [JsonProperty(PropertyName = "Font")] public string Font;

            [JsonProperty(PropertyName = "Align")] [JsonConverter(typeof(StringEnumConverter))]
            public TextAnchor Align;

            [JsonProperty(PropertyName = "Text Color")]
            public IColor Color;

            public void Get(ref CuiElementContainer container, string parent = "Hud", string name = null,
                string text = "")
            {
                if (string.IsNullOrEmpty(name))
                    name = CuiHelper.GetGuid();

                container.Add(new CuiLabel
                {
                    RectTransform =
                        {AnchorMin = AnchorMin, AnchorMax = AnchorMax, OffsetMin = OffsetMin, OffsetMax = OffsetMax},
                    Text =
                    {
                        Text = $"{text}", Align = Align, FontSize = FontSize, Color = Color.Get(),
                        Font = Font
                    }
                }, parent, name);
            }
        }

        private class IColor
        {
            [JsonProperty(PropertyName = "HEX")] public string HEX;

            [JsonProperty(PropertyName = "Непрозрачность | Opacity (0 - 100)")]
            public readonly float Alpha;

            public string Get()
            {
                if (string.IsNullOrEmpty(HEX)) HEX = "#FFFFFF";

                var str = HEX.Trim('#');
                if (str.Length != 6) throw new Exception(HEX);
                var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
                var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
                var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);

                return $"{(double) r / 255} {(double) g / 255} {(double) b / 255} {Alpha / 100}";
            }

            public IColor(string hex, float alpha)
            {
                HEX = hex;
                Alpha = alpha;
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();

                if (_config.Version < Version)
                    UpdateConfigValues();

                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            var baseConfig = new Configuration();

            if (_config.Version < new VersionNumber(1, 14, 0))
                _config.AutoClose = baseConfig.AutoClose;

            if (_config.Version < new VersionNumber(1, 15, 0))
            {
                _config.UseTeams = baseConfig.UseTeams;
                _config.SAMs = baseConfig.SAMs;
            }

            _config.Version = Version;
            PrintWarning("Config update completed!");
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        protected override void LoadDefaultConfig()
        {
            _config = new Configuration();
        }

        #endregion

        #region Data

        #region Fields

        private static PluginData _data;

        private Dictionary<ulong, PlayerData> _playersData = new Dictionary<ulong, PlayerData>();

        #endregion

        #region Save

        private void SaveData()
        {
            if (_config.PlayerDatabase.Enabled && PlayerDatabase)
                SaveDatabaseData();
            else
                SaveFilesData();
        }

        private void SaveDatabaseData()
        {
            foreach (var check in _playersData)
                SaveData(check.Key, check.Value);
        }

        private void SaveFilesData()
        {
            _data.Players = _playersData;

            Interface.Oxide.DataFileSystem.WriteObject(Name, _data);
        }

        private void SaveData(ulong userId, PlayerData data)
        {
            if (data == null) return;

            var serializeObject = JsonConvert.SerializeObject(data);
            if (serializeObject == null) return;

            PlayerDatabase?.Call("SetPlayerData", userId.ToString(), _config.PlayerDatabase.Field, serializeObject);
        }

        #endregion

        #region Load

        private void LoadData()
        {
            if (!_config.PlayerDatabase.Enabled) LoadFilesData();
        }

        private void LoadFilesData()
        {
            try
            {
                _data = Interface.Oxide.DataFileSystem.ReadObject<PluginData>(Name);
            }
            catch (Exception e)
            {
                PrintError(e.ToString());
            }

            if (_data == null) _data = new PluginData();

            _playersData = _data.Players;
        }

        private void LoadPlayerData(ulong userId)
        {
            var success =
                PlayerDatabase?.Call<string>("GetPlayerDataRaw", userId.ToString(), _config.PlayerDatabase.Field);
            if (string.IsNullOrEmpty(success)) return;

            var data = JsonConvert.DeserializeObject<PlayerData>(success);
            if (data == null) return;

            _playersData[userId] = data;
        }

        #endregion

        #region Classes

        private class PluginData
        {
            [JsonProperty(PropertyName = "Players", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<ulong, PlayerData> Players = new Dictionary<ulong, PlayerData>();
        }

        private class PlayerData
        {
            [JsonProperty(PropertyName = "Display Name")]
            public string DisplayName;

            [JsonProperty(PropertyName = "UserId")]
            public ulong UserId;

            [JsonProperty(PropertyName = "Friends", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public readonly List<FriendData> Friends = new List<FriendData>();

            [JsonProperty(PropertyName = "Removed Friends", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public readonly List<ulong> RemovedFriends = new List<ulong>();

            public bool IsFriend(ulong friend)
            {
                return Friends.Exists(check => check.UserId == friend);
            }

            public FriendData GetFriend(ulong friend)
            {
                return Friends.Find(check => check.UserId == friend);
            }

            public void AddFriend(ulong friend)
            {
                if (!friend.IsSteamId() || IsFriend(friend)) return;

                Friends.Add(new FriendData
                {
                    UserId = friend,
                    FriendlyFire = _config.FriendlyFire,
                    Doors = _config.Doors,
                    Turrets = _config.Turrets,
                    Cupboard = _config.Cupboard,
                    Containers = _config.Containers,
                    SAMs = _config.SAMs
                });

                RemovedFriends.Remove(friend);
            }

            public void RemoveFriend(ulong friend)
            {
                Friends?.ToList().FindAll(f => f.UserId == friend).ForEach(f =>
                {
                    if (!RemovedFriends.Contains(friend))
                        RemovedFriends.Add(friend);

                    Friends.Remove(f);
                });
            }
        }

        private class FriendData
        {
            [JsonProperty(PropertyName = "UserId")]
            public ulong UserId;

            [JsonProperty(PropertyName = "FriendlyFire")]
            public bool FriendlyFire;

            [JsonProperty(PropertyName = "Doors")] public bool Doors;

            [JsonProperty(PropertyName = "Turrets")]
            public bool Turrets;

            [JsonProperty(PropertyName = "Cupboard")]
            public bool Cupboard;

            [JsonProperty(PropertyName = "Containers")]
            public bool Containers;

            [JsonProperty(PropertyName = "SAMs")] public bool SAMs;
        }

        #endregion

        #region Utils

        private static PlayerData GetPlayerData(BasePlayer player)
        {
            if (player == null || !player.userID.IsSteamId()) return null;

            if (!_instance._playersData.ContainsKey(player.userID))
                _instance._playersData.Add(player.userID, new PlayerData
                {
                    DisplayName = player.displayName,
                    UserId = player.userID
                });

            return _instance._playersData[player.userID];
        }

        private static PlayerData GetPlayerData(ulong userId)
        {
            if (!userId.IsSteamId()) return null;

            if (!_instance._playersData.ContainsKey(userId))
                _instance._playersData.Add(userId, new PlayerData
                {
                    UserId = userId
                });

            return _instance._playersData[userId];
        }

        private static PlayerData FindPlayerData(string user)
        {
            return _instance._playersData.FirstOrDefault(x =>
                x.Key.ToString() == user ||
                !string.IsNullOrEmpty(x.Value.DisplayName) &&
                x.Value.DisplayName.StartsWith(user, StringComparison.CurrentCultureIgnoreCase)).Value;
        }

        #endregion

        #endregion

        #region Hooks

        private void Init()
        {
            _instance = this;

            LoadData();

            AddCovalenceCommand(new[] {"ff", "friendlyfire", "friend", "friends", "f", "fmenu", "f.menu"},
                nameof(CmdFriends));

            if (!_config.AddTeam)
            {
                Unsubscribe(nameof(OnTeamLeave));
                Unsubscribe(nameof(OnTeamAcceptInvite));
                Unsubscribe(nameof(OnTeamKick));
                Unsubscribe(nameof(OnTeamInvite));
                Unsubscribe(nameof(OnTeamRejectInvite));
            }

            if (!_config.PlayerDatabase.Enabled)
                Unsubscribe(nameof(OnPlayerDisconnected));
        }

        private void OnServerInitialized()
        {
            if (!ImageLibrary) PrintWarning("IMAGE LIBRARY IS NOT INSTALLED.");

            #region Init

            foreach (var player in BasePlayer.activePlayerList) OnPlayerConnected(player);

            #endregion

            #region Notifications

            Notifications?.Call("AddImage", _config.FriendInvite.Image, _config.FriendInvite.Url);

            Notifications?.Call("AddImage", _config.Notify.Image, _config.Notify.Url);

            #endregion

            #region Team

            RelationshipManager.maxTeamSize = _config.MaxFriendsAmount + 1;

            #endregion

            #region Auth

            foreach (var entity in BaseNetworkable.serverEntities.OfType<BaseEntity>()) CheckEntity(entity);

            #endregion

            timer.Every(1, TimeHandle);
        }

        private void OnServerSave()
        {
            timer.In(Random.Range(2f, 7f), SaveData);
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList) CuiHelper.DestroyUi(player, Layer);

            SaveData();

            _instance = null;
            _config = null;
            _data = null;
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null || !player.userID.IsSteamId()) return;

            var data = GetPlayerData(player);
            if (data == null) return;

            data.DisplayName = player.displayName;

            GetAvatar(player.userID,
                avatar => ImageLibrary?.Call("AddImage", avatar, $"avatar_{player.UserIDString}"));

            if (_config.AddTeam && data.Friends.Count > 0)
            {
                RelationshipManager.PlayerTeam team;
                var friend =
                    data.Friends.Find(x => RelationshipManager.ServerInstance.playerToTeam.ContainsKey(x.UserId));
                if (friend == null)
                {
                    team = RelationshipManager.ServerInstance.CreateTeam();
                    team.AddPlayer(player);
                    team.SetTeamLeader(player.userID);

                    var friendPlayer = FindPlayer(data.Friends);
                    if (friendPlayer != null) team.AddPlayer(friendPlayer);
                }
                else
                {
                    team = RelationshipManager.ServerInstance.playerToTeam[friend.UserId];
                    if (team == null) return;
                    team.AddPlayer(player);
                }
            }

            if (_config.PlayerDatabase.Enabled) LoadPlayerData(player.userID);
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            if (player == null) return;

            SaveData(player.userID, GetPlayerData(player.userID));
        }

        private void OnEntityTakeDamage(BasePlayer player, HitInfo info)
        {
            if (player == null || info == null) return;

            var initiator = info.InitiatorPlayer;
            if (initiator == null) return;

            if (!IsFriend(player.userID, initiator.userID) || player.userID == initiator.userID)
                return;

            var data = GetPlayerData(initiator);

            var friend = data?.Friends.Find(x => x.UserId == player.userID);
            if (friend == null || friend.FriendlyFire) return;

            info.damageTypes.ScaleAll(0);

            if (IsCd(initiator.userID)) return;

            Notify(initiator, _config.Notify.Delay, Msg(NotifyTitle, initiator.UserIDString),
                Msg(FF, initiator.UserIDString, player.displayName), _config.Notify.Image);

            SetCd(initiator.userID);
        }

        #region Team

        private void OnTeamLeave(RelationshipManager.PlayerTeam playerTeam, BasePlayer player)
        {
            if (playerTeam == null || player == null) return;

            playerTeam.members.ToList().ForEach(user =>
            {
                GetPlayerData(player)?.RemoveFriend(user);
                GetPlayerData(user)?.RemoveFriend(player.userID);
            });

            UpdateAuthList(player.userID, AutoAuthType.All);
            UpdateTeamAuthList(playerTeam.members);
        }

        private void OnTeamAcceptInvite(RelationshipManager.PlayerTeam playerTeam, BasePlayer player)
        {
            NextTick(() =>
            {
                if (playerTeam == null || player == null || !player.userID.IsSteamId()) return;

                var invite = _invites.Find(x => x.Target == player);
                if (invite != null && playerTeam.members.Exists(x => invite.Inviter.userID == x))
                {
                    AcceptInvite(player);
                    return;
                }

                if (playerTeam.members.Contains(player.userID))
                    if (_config.UseTeams)
                    {
                        playerTeam.members.ToList().ForEach(user =>
                        {
                            if (user == player.userID) return;

                            GetPlayerData(player)?.AddFriend(user);
                            GetPlayerData(user)?.AddFriend(player.userID);

                            Log("friends", $"Player '{player}' added '{user}' as a friend");
                        });

                        UpdateTeamAuthList(playerTeam.members);
                    }
            });
        }

        private void OnTeamKick(RelationshipManager.PlayerTeam playerTeam, BasePlayer player, ulong target)
        {
            NextTick(() =>
            {
                if (playerTeam == null) return;

                if (!playerTeam.members.Contains(target))
                {
                    playerTeam.members.ToList().ForEach(user =>
                    {
                        GetPlayerData(user)?.RemoveFriend(target);
                        GetPlayerData(target)?.RemoveFriend(user);
                    });

                    UpdateAuthList(target, AutoAuthType.All);
                    UpdateTeamAuthList(playerTeam.members);
                }
            });
        }

        private void OnTeamInvite(BasePlayer inviter, BasePlayer target)
        {
            SendInvite(inviter, target);
        }

        private void OnTeamRejectInvite(BasePlayer rejector, RelationshipManager.PlayerTeam team)
        {
            CancelInvite(rejector);
        }

        private void UpdateTeamAuthList(List<ulong> teamMembers)
        {
            if (teamMembers.Count <= 0) return;
            teamMembers.ForEach(member => UpdateAuthList(member, AutoAuthType.All));
        }

        #endregion

        #region SAMs

        private object OnSamSiteTarget(SamSite samSite, BaseVehicle vehicle)
        {
            if (samSite == null || !samSite.OwnerID.IsSteamId() || vehicle == null)
                return null;

            var data = GetPlayerData(samSite.OwnerID);
            if (data == null)
                return null;

            if (vehicle.OwnerID == samSite.OwnerID ||
                data.Friends.Exists(friend => friend.UserId == vehicle.OwnerID && friend.SAMs))
                return true;

            foreach (var mounted in vehicle.allMountPoints
                         .Where(allMountPoint => allMountPoint != null && allMountPoint.mountable != null)
                         .Select(allMountPoint => allMountPoint.mountable.GetMounted())
                         .Where(mounted => mounted != null))
            {
                if (mounted.userID == samSite.OwnerID)
                    return true;

                var friendData = data.GetFriend(mounted.userID);
                if (friendData != null && friendData.SAMs)
                    return true;
            }

            return null;
        }

        #endregion

        #endregion

        #region Commands

        private void CmdFriends(IPlayer cov, string command, string[] args)
        {
            var player = cov?.Object as BasePlayer;
            if (player == null) return;

            switch (command)
            {
                case "friendlyfire":
                case "ff":
                {
                    var data = GetPlayerData(player);
                    if (data == null) return;

                    if (args.Length < 1)
                    {
                        Reply(player, FFErrorSyntax, command);
                        return;
                    }

                    var friends = FindRemoveFriend(player, args[0]);
                    if (friends == null || friends.Count == 0)
                    {
                        Notify(player, _config.Notify.Delay, Msg(NotifyTitle, player.UserIDString),
                            Msg(NotFound, player.UserIDString, args[0]), _config.Notify.Image);
                        return;
                    }

                    PlayerData friend;

                    if (friends.Count > 1)
                    {
                        int index;
                        if (args.Length >= 3 && int.TryParse(args[2], out index))
                        {
                            if (index - 1 < 0 || friends.Count <= index - 1)
                                return;

                            friend = friends[index - 1];
                        }
                        else
                        {
                            var f = 0;
                            var str = string.Join(", ", friends.Select(x =>
                            {
                                f++;
                                return $"{x.DisplayName} ({x.UserId}) [{f}]";
                            }));

                            Reply(player, MultipleFound, str, f, args[0], args[1]);
                            return;
                        }
                    }
                    else
                    {
                        friend = friends.FirstOrDefault();
                    }

                    if (friend == null)
                    {
                        Notify(player, _config.Notify.Delay, Msg(NotifyTitle, player.UserIDString),
                            Msg(NotFound, player.UserIDString, args[0]), _config.Notify.Image);
                        return;
                    }

                    var fData = data.GetFriend(friend.UserId);
                    if (fData == null)
                    {
                        Notify(player, _config.Notify.Delay, Msg(NotifyTitle, player.UserIDString),
                            Msg(IsNotFriend, player.UserIDString, friend.DisplayName), _config.Notify.Image);
                        return;
                    }


                    if (args.Length > 2)
                        switch (args[1].ToLower())
                        {
                            case "on":
                            {
                                fData.FriendlyFire = true;
                                break;
                            }
                            case "off":
                            {
                                fData.FriendlyFire = false;
                                break;
                            }
                        }
                    else
                        fData.FriendlyFire = !fData.FriendlyFire;

                    Notify(player, _config.Notify.Delay, Msg(NotifyTitle, player.UserIDString),
                        Msg(fData.FriendlyFire ? FFOn : FFOff, player.UserIDString), _config.Notify.Image);
                    break;
                }
                default:
                {
                    if (args.Length == 0)
                    {
                        MainUi(player);
                        return;
                    }

                    switch (args[0].ToLower())
                    {
                        case "+":
                        case "i":
                        case "inv":
                        case "invite":
                        case "add":
                        {
                            if (args.Length < 2)
                            {
                                Reply(player, ErrorSyntax, command, args[0]);
                                return;
                            }

                            var friends = FindPlayer(args[1]);
                            if (friends.Count == 0)
                            {
                                Notify(player, _config.Notify.Delay, Msg(NotifyTitle, player.UserIDString),
                                    Msg(NotFound, player.UserIDString, args[1]), _config.Notify.Image);
                                return;
                            }

                            BasePlayer friend;

                            if (friends.Count > 1)
                            {
                                int index;
                                if (args.Length >= 3 && int.TryParse(args[2], out index))
                                {
                                    if (index - 1 < 0 || friends.Count <= index - 1)
                                        return;

                                    friend = friends[index - 1];
                                }
                                else
                                {
                                    var f = 0;
                                    var str = string.Join(", ", friends.Select(x =>
                                    {
                                        f++;
                                        return $"{x.displayName} ({x.UserIDString}) [{f}]";
                                    }));

                                    Reply(player, MultipleFound, str, f, args[0], args[1]);
                                    return;
                                }
                            }
                            else
                            {
                                friend = friends.FirstOrDefault();
                            }

                            if (friend == null)
                            {
                                Notify(player, _config.Notify.Delay, Msg(NotifyTitle, player.UserIDString),
                                    Msg(NotFound, player.UserIDString, args[1]), _config.Notify.Image);
                                return;
                            }

                            if (player.userID == friend.userID)
                            {
                                Notify(player, _config.Notify.Delay, Msg(NotifyTitle, player.UserIDString),
                                    Msg(CantAddSelf, player.UserIDString), _config.Notify.Image);
                                return;
                            }

                            var pData = GetPlayerData(player);
                            if (pData == null) return;

                            if (pData.IsFriend(friend.userID))
                            {
                                Notify(player, _config.Notify.Delay, Msg(NotifyTitle, player.UserIDString),
                                    Msg(AlreadyFriends, player.UserIDString), _config.Notify.Image);
                                return;
                            }

                            if (pData.Friends.Count >= _config.MaxFriendsAmount)
                            {
                                Notify(player, _config.Notify.Delay, Msg(NotifyTitle, player.UserIDString),
                                    Msg(MaxFriends, player.UserIDString), _config.Notify.Image);
                                return;
                            }

                            var fData = GetPlayerData(friend);
                            if (fData == null) return;

                            if (fData.Friends.Count >= _config.MaxFriendsAmount)
                            {
                                Notify(player, _config.Notify.Delay, Msg(NotifyTitle, player.UserIDString),
                                    Msg(TargetMaxFriends, player.UserIDString), _config.Notify.Image);
                                return;
                            }

                            SendInvite(player, friend);
                            break;
                        }
                        case "-":
                        case "del":
                        case "delete":
                        case "rem":
                        case "remove":
                        {
                            if (args.Length < 2)
                            {
                                Reply(player, ErrorSyntax, command, args[0]);
                                return;
                            }

                            var friends = FindRemoveFriend(player, args[1]);
                            if (friends == null || friends.Count == 0)
                            {
                                Notify(player, _config.Notify.Delay, Msg(NotifyTitle, player.UserIDString),
                                    Msg(NotFound, player.UserIDString, args[1]), _config.Notify.Image);
                                return;
                            }

                            PlayerData friend;

                            if (friends.Count > 1)
                            {
                                int index;
                                if (args.Length >= 3 && int.TryParse(args[2], out index))
                                {
                                    if (index - 1 < 0 || friends.Count <= index - 1)
                                        return;

                                    friend = friends[index - 1];
                                }
                                else
                                {
                                    var f = 0;
                                    var str = string.Join(", ", friends.Select(x =>
                                    {
                                        f++;
                                        return $"{x.DisplayName} ({x.UserId}) [{f}]";
                                    }));

                                    Reply(player, MultipleFound, str, f, args[0], args[1]);
                                    return;
                                }
                            }
                            else
                            {
                                friend = friends.FirstOrDefault();
                            }

                            if (friend == null)
                            {
                                Notify(player, _config.Notify.Delay, Msg(NotifyTitle, player.UserIDString),
                                    Msg(NotFound, player.UserIDString, args[1]), _config.Notify.Image);
                                return;
                            }

                            CuiHelper.DestroyUi(player, Layer);

                            RemoveFriend(player, friend.UserId);
                            break;
                        }
                        case "a":
                        case "accept":
                        {
                            AcceptInvite(player);
                            break;
                        }
                        case "c":
                        case "cancel":
                        {
                            CancelInvite(player);
                            break;
                        }
                        case "list":
                        {
                            var data = GetPlayerData(player);
                            if (data == null) return;

                            if (data.Friends.Count == 0)
                            {
                                Notify(player, _config.Notify.Delay, Msg(NotifyTitle, player.UserIDString),
                                    Msg(NoFriends, player.UserIDString), _config.Notify.Image);
                            }
                            else
                            {
                                var friends = string.Join(", ",
                                    data.Friends.Select(x =>
                                        $"{GetPlayerData(x.UserId)?.DisplayName ?? "NONE"} ({x.UserId})"));

                                Reply(player, Msg(FriendList, player.UserIDString, friends));
                            }

                            break;
                        }
                        case "doors":
                        {
                            if (args.Length < 2)
                            {
                                Reply(player, ErrorSyntax, command, args[0]);
                                return;
                            }

                            var friend = FindPlayerData(args[1]);
                            if (friend == null)
                            {
                                Reply(player, NotFound, args[1]);
                                return;
                            }

                            var friendData = GetPlayerData(player)?.GetFriend(friend.UserId);
                            if (friendData == null)
                            {
                                Notify(player, _config.Notify.Delay, Msg(NotifyTitle, player.UserIDString),
                                    Msg(IsNotFriend, player.UserIDString, friend.DisplayName), _config.Notify.Image);
                                return;
                            }

                            friendData.Doors = !friendData.Doors;
                            Notify(player, _config.Notify.Delay, Msg(NotifyTitle, player.UserIDString),
                                Msg(friendData.Doors ? DoorsOn : DoorsOff, player.UserIDString), _config.Notify.Image);
                            break;
                        }
                        case "cupboard":
                        {
                            if (args.Length < 2)
                            {
                                Reply(player, ErrorSyntax, command, args[0]);
                                return;
                            }

                            var friend = FindPlayerData(args[1]);
                            if (friend == null)
                            {
                                Reply(player, NotFound, args[1]);
                                return;
                            }

                            var friendData = GetPlayerData(player)?.GetFriend(friend.UserId);
                            if (friendData == null)
                            {
                                Notify(player, _config.Notify.Delay, Msg(NotifyTitle, player.UserIDString),
                                    Msg(IsNotFriend, player.UserIDString, friend.DisplayName), _config.Notify.Image);
                                return;
                            }

                            friendData.Cupboard = !friendData.Cupboard;
                            Notify(player, _config.Notify.Delay, Msg(NotifyTitle, player.UserIDString),
                                Msg(friendData.Cupboard ? CupboardOn : CupboardOff, player.UserIDString),
                                _config.Notify.Image);

                            UpdateAuthList(player.userID, AutoAuthType.Cupboard);
                            break;
                        }
                        case "containers":
                        {
                            if (args.Length < 2)
                            {
                                Reply(player, ErrorSyntax, command, args[0]);
                                return;
                            }

                            var friend = FindPlayerData(args[1]);
                            if (friend == null)
                            {
                                Reply(player, NotFound, args[1]);
                                return;
                            }

                            var friendData = GetPlayerData(player)?.GetFriend(friend.UserId);
                            if (friendData == null)
                            {
                                Notify(player, _config.Notify.Delay, Msg(NotifyTitle, player.UserIDString),
                                    Msg(IsNotFriend, player.UserIDString, friend.DisplayName), _config.Notify.Image);
                                return;
                            }

                            friendData.Containers = !friendData.Containers;
                            Notify(player, _config.Notify.Delay, Msg(NotifyTitle, player.UserIDString),
                                Msg(friendData.Containers ? ContainersOn : ContainersOff, player.UserIDString),
                                _config.Notify.Image);
                            break;
                        }
                        case "turrets":
                        {
                            if (args.Length < 2)
                            {
                                Reply(player, ErrorSyntax, command, args[0]);
                                return;
                            }

                            var friend = FindPlayerData(args[1]);
                            if (friend == null)
                            {
                                Reply(player, NotFound, args[1]);
                                return;
                            }

                            var friendData = GetPlayerData(player)?.GetFriend(friend.UserId);
                            if (friendData == null)
                            {
                                Notify(player, _config.Notify.Delay, Msg(NotifyTitle, player.UserIDString),
                                    Msg(IsNotFriend, player.UserIDString, friend.DisplayName), _config.Notify.Image);
                                return;
                            }

                            friendData.Turrets = !friendData.Turrets;
                            Notify(player, _config.Notify.Delay, Msg(NotifyTitle, player.UserIDString),
                                Msg(friendData.Turrets ? TurretsOn : TurretsOff, player.UserIDString),
                                _config.Notify.Image);

                            UpdateAuthList(player.userID, AutoAuthType.Turret);
                            break;
                        }

                        case "sams":
                        {
                            if (args.Length < 2)
                            {
                                Reply(player, ErrorSyntax, command, args[0]);
                                return;
                            }

                            var friend = FindPlayerData(args[1]);
                            if (friend == null)
                            {
                                Reply(player, NotFound, args[1]);
                                return;
                            }

                            var friendData = GetPlayerData(player)?.GetFriend(friend.UserId);
                            if (friendData == null)
                            {
                                Notify(player, _config.Notify.Delay, Msg(NotifyTitle, player.UserIDString),
                                    Msg(IsNotFriend, player.UserIDString, friend.DisplayName), _config.Notify.Image);
                                return;
                            }

                            friendData.SAMs = !friendData.SAMs;
                            Notify(player, _config.Notify.Delay, Msg(NotifyTitle, player.UserIDString),
                                Msg(friendData.SAMs ? SamsOn : SamsOff, player.UserIDString),
                                _config.Notify.Image);
                            break;
                        }
                        case "help":
                        {
                            Reply(player, Help);
                            break;
                        }
                    }

                    break;
                }
            }
        }

        [ConsoleCommand("UI_Friends")]
        private void ConsoleCmdFriends(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player();
            if (player == null || !arg.HasArgs()) return;

            switch (arg.Args[0])
            {
                case "page":
                {
                    int page;
                    if (!arg.HasArgs(3) ||
                        !int.TryParse(arg.Args[1], out page)) return;

                    MainUi(player, arg.Args[2], page);
                    break;
                }

                case "sendcmd":
                {
                    int page;
                    if (!arg.HasArgs(4) || !int.TryParse(arg.Args[1], out page)) return;

                    var command = string.Join(" ", arg.Args.Skip(3));
                    if (string.IsNullOrEmpty(command)) return;

                    player.Command(command.Contains("chat.say") ? $"friendssendcmd {command}" : $"{command}");

                    if (!_config.AutoClose)
                        timer.In(0.2f, () => MainUi(player, arg.Args[2], page));
                    break;
                }

                case "close":
                {
                    CuiHelper.DestroyUi(player, Layer);
                    break;
                }
            }
        }

        [ConsoleCommand("friendssendcmd")]
        private void SendCommand(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null || !args.HasArgs()) return;

            var convertcmd = args.Args.Length == 1
                ? args.Args[0]
                : $"{args.Args[0]}  \" {string.Join(" ", args.Args.ToList().GetRange(1, args.Args.Length - 1))}\" 0";
            player.SendConsoleCommand(convertcmd);
        }

        [ConsoleCommand("friends.migrate")]
        private void CmdConsoleMigrate(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;

            PluginData data = null;
            try
            {
                data = Interface.Oxide.DataFileSystem.ReadObject<PluginData>(Name);
            }
            catch (Exception e)
            {
                PrintError(e.ToString());
            }

            if (data == null) return;

            foreach (var check in data.Players)
                SaveData(check.Key, check.Value);

            PrintWarning("The migration is complete!");
        }

        #endregion

        #region Interface

        private void MainUi(BasePlayer player, string parent = "Overlay", int page = 0)
        {
            var data = GetPlayerData(player);
            if (data == null) return;

            if (string.IsNullOrEmpty(parent))
                parent = "Overlay";

            var container = new CuiElementContainer();

            _config.Background.Get(ref container, parent, Layer, true);

            if (parent == "Overlay")
                _config.Title.Get(ref container, Layer, null, Msg(UITitle, player.UserIDString));

            #region Friends

            var friends = data.Friends?.Skip(_config.Panel.Count * page).Take(_config.Panel.Count).ToList();
            if (friends != null && friends.Count > 0)
            {
                var ySwitch = (friends.Count * _config.Panel.Height + (friends.Count - 1) * _config.Panel.Margin) /
                              2f;
                friends.ForEach(friend =>
                {
                    if (friend == null) return;

                    _config.Panel?.Get(ref container, player, friend, Layer, null,
                        $"-{_config.Panel.Width / 2f} {ySwitch - _config.Panel.Height}",
                        $"{_config.Panel.Width / 2f} {ySwitch}", page, parent);

                    ySwitch = ySwitch - _config.Panel.Margin - _config.Panel.Height;
                });
            }
            else
            {
                _config.Error.Get(ref container, Layer, null, Msg(NoFriends, player.UserIDString));
            }

            #endregion

            #region Pages

            if (data.Friends != null && data.Friends.Count > _config.Panel.Count)
            {
                container.Add(new CuiButton
                {
                    RectTransform =
                    {
                        AnchorMin =
                            _config.Back.AnchorMin,
                        AnchorMax =
                            _config.Back.AnchorMax,
                        OffsetMin =
                            _config.Back.OffsetMin,
                        OffsetMax =
                            _config.Back.OffsetMax
                    },
                    Text =
                    {
                        Text = "«",
                        Align =
                            _config.Back.Align,
                        FontSize =
                            _config.Back.FontSize,
                        Font =
                            _config.Back.Font,
                        Color =
                            _config.Back.Color.Get()
                    },
                    Button =
                    {
                        Color = "0 0 0 0",
                        Command = page != 0 ? $"UI_Friends page {page - 1} {parent}" : ""
                    }
                }, Layer);

                container.Add(new CuiButton
                {
                    RectTransform =
                    {
                        AnchorMin =
                            _config.Next.AnchorMin,
                        AnchorMax =
                            _config.Next.AnchorMax,
                        OffsetMin =
                            _config.Next.OffsetMin,
                        OffsetMax =
                            _config.Next.OffsetMax
                    },
                    Text =
                    {
                        Text = "»",
                        Align =
                            _config.Next.Align,
                        FontSize =
                            _config.Next.FontSize,
                        Font =
                            _config.Next.Font,
                        Color =
                            _config.Next.Color.Get()
                    },
                    Button =
                    {
                        Color = "0 0 0 0",
                        Command = data.Friends.Count > (page + 1) * _config.Panel.Count
                            ? $"UI_Friends page {page + 1} {parent}"
                            : ""
                    }
                }, Layer);
            }

            #endregion

            #region Find Friend

            if (data.Friends != null && PlayerList && GetMaxFriends() - data.Friends.Count > 0)
                _config.FindFriendBtn.Get(ref container, player, null, Layer);

            #endregion

            #region Close

            _config.Close?.Get(ref container, Layer, Layer + ".Close", "✕");

            container.Add(new CuiButton
            {
                RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
                Text = {Text = ""},
                Button = {Color = "0 0 0 0", Command = "UI_Friends close"}
            }, Layer + ".Close");

            #endregion

            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Auth

        #region Hooks

        private object OnCupboardAuthorize(BuildingPrivlidge privilege, BasePlayer player)
        {
            if (privilege == null || player == null) return null;

            var count = privilege.authorizedPlayers.Count;
            if (count == 0) return null;

            if (count > RelationshipManager.maxTeamSize) privilege.authorizedPlayers.RemoveRange(0, count - 1);

            return null;
        }

        private void OnEntitySpawned(BaseEntity entity)
        {
            CheckEntity(entity, true);
        }

        private void CheckEntity(BaseEntity entity, bool justCreated = false)
        {
            if (entity == null || !entity.OwnerID.IsSteamId()) return;

            var buildingPrivilege = entity as BuildingPrivlidge;
            if (buildingPrivilege != null)
            {
                if (_playerEntities.ContainsKey(entity.OwnerID))
                    _playerEntities[entity.OwnerID].BuildingPrivileges.Add(buildingPrivilege);
                else
                    _playerEntities.Add(entity.OwnerID,
                        new EntityEntry {BuildingPrivileges = new HashSet<BuildingPrivlidge> {buildingPrivilege}});

                if (justCreated)
                    AuthToCupboard(new HashSet<BuildingPrivlidge> {buildingPrivilege}, entity.OwnerID);
                return;
            }

            var autoTurret = entity as AutoTurret;
            if (autoTurret != null)
            {
                if (_playerEntities.ContainsKey(entity.OwnerID))
                    _playerEntities[entity.OwnerID].AutoTurrets.Add(autoTurret);
                else
                    _playerEntities.Add(entity.OwnerID,
                        new EntityEntry {AutoTurrets = new HashSet<AutoTurret> {autoTurret}});

                if (justCreated)
                    AuthToTurret(new HashSet<AutoTurret> {autoTurret}, entity.OwnerID);
            }
        }

        private void OnEntityKill(BaseEntity entity)
        {
            if (entity == null || entity.OwnerID == 0) return;

            var buildingPrivilege = entity as BuildingPrivlidge;
            if (buildingPrivilege != null)
            {
                foreach (var entry in _playerEntities.Where(entry =>
                             entry.Value.BuildingPrivileges.Contains(buildingPrivilege)))
                {
                    entry.Value.BuildingPrivileges.Remove(buildingPrivilege);
                    return;
                }

                return;
            }

            var autoTurret = entity as AutoTurret;
            if (autoTurret != null)
                foreach (var entry in _playerEntities.Where(entry => entry.Value.AutoTurrets.Contains(autoTurret)))
                {
                    entry.Value.AutoTurrets.Remove(autoTurret);
                    return;
                }
        }

        private object CanUseLockedEntity(BasePlayer player, BaseLock baseLock)
        {
            if (player == null || baseLock == null) return null;

            var parentEntity = baseLock.GetParentEntity();
            if (parentEntity == null || parentEntity.OwnerID == 0 || !baseLock.IsLocked()) return null;

            var friend = GetPlayerData(baseLock.OwnerID)?.GetFriend(player.userID);
            if (friend == null) return null;

            if (parentEntity is Door && friend.Doors ||
                parentEntity is BuildingPrivlidge && friend.Cupboard ||
                parentEntity is StorageContainer && friend.Containers)
            {
                var codeLock = baseLock as CodeLock;
                if (codeLock != null)
                    Effect.server.Run(codeLock.effectUnlocked.resourcePath, codeLock.transform.position);
                return true;
            }

            return null;
        }

        #endregion

        private void UpdateAuthList(ulong playerID, AutoAuthType autoAuthType)
        {
            EntityEntry entityEntry;
            if (!_playerEntities.TryGetValue(playerID, out entityEntry)) return;

            switch (autoAuthType)
            {
                case AutoAuthType.All:
                    AuthToCupboard(entityEntry.BuildingPrivileges, playerID);
                    AuthToTurret(entityEntry.AutoTurrets, playerID);
                    return;

                case AutoAuthType.Turret:
                    AuthToTurret(entityEntry.AutoTurrets, playerID);
                    return;

                case AutoAuthType.Cupboard:
                    AuthToCupboard(entityEntry.BuildingPrivileges, playerID);
                    return;
            }
        }

        private void AuthToCupboard(HashSet<BuildingPrivlidge> cupboards, ulong playerID)
        {
            if (cupboards.Count <= 0) return;
            var authList = GetPlayerNameIDs(playerID, AutoAuthType.Cupboard);

            foreach (var buildingPrivilege in cupboards.Where(buildingPrivilege =>
                         buildingPrivilege != null && !buildingPrivilege.IsDestroyed))
            {
                buildingPrivilege.authorizedPlayers.Clear();

                foreach (var friend in authList) buildingPrivilege.authorizedPlayers.Add(friend);

                buildingPrivilege.SendNetworkUpdateImmediate();
            }
        }

        private void AuthToTurret(HashSet<AutoTurret> autoTurrets, ulong playerID)
        {
            if (autoTurrets.Count <= 0) return;
            var authList = GetPlayerNameIDs(playerID, AutoAuthType.Turret);

            foreach (var autoTurret in autoTurrets)
            {
                if (autoTurret == null || autoTurret.IsDestroyed) continue;
                var isOnline = false;
                if (autoTurret.IsOnline())
                {
                    autoTurret.SetIsOnline(false);
                    isOnline = true;
                }

                autoTurret.authorizedPlayers.Clear();

                foreach (var friend in authList) autoTurret.authorizedPlayers.Add(friend);

                if (isOnline) autoTurret.SetIsOnline(true);
                autoTurret.SendNetworkUpdateImmediate();
            }
        }

        private List<PlayerNameID> GetPlayerNameIDs(ulong playerId, AutoAuthType autoAuthType)
        {
            var playerNameIDs = new List<PlayerNameID>();
            var authList = GetAuthList(playerId, autoAuthType);

            playerNameIDs.AddRange(authList.Select(auth => new PlayerNameID
            {
                userid = auth, username = covalence.Players.FindPlayer(auth.ToString())?.Name ?? string.Empty,
                ShouldPool = true
            }));

            return playerNameIDs;
        }

        private HashSet<ulong> GetAuthList(ulong playerID, AutoAuthType autoAuthType)
        {
            var data = GetPlayerData(playerID);
            var sharePlayers = new HashSet<ulong> {playerID};

            data.Friends?.ForEach(friend =>
            {
                if (autoAuthType == AutoAuthType.Turret ? friend.Turrets : friend.Cupboard)
                    sharePlayers.Add(friend.UserId);
            });

            return sharePlayers;
        }

        #endregion

        #region Utils

        #region Log

        private void Log(string filename, string text)
        {
            if (_config.LogToConsole) Puts(text);

            if (_config.LogToFile) LogToFile(filename, $"[{DateTime.Now}] {text}", this);
        }

        #endregion

        private readonly Regex _regex = new Regex(@"<avatarFull><!\[CDATA\[(.*)\]\]></avatarFull>");

        private void GetAvatar(ulong userId, Action<string> callback)
        {
            if (callback == null) return;

            webrequest.Enqueue($"http://steamcommunity.com/profiles/{userId}?xml=1", null, (code, response) =>
            {
                if (code != 200 || response == null)
                    return;

                var avatar = _regex.Match(response).Groups[1].ToString();
                if (string.IsNullOrEmpty(avatar))
                    return;

                callback.Invoke(avatar);
            }, this);
        }

        private string GetPlayerName(ulong target)
        {
            var data = GetPlayerData(target);
            var result = data == null
                ? covalence.Players.FindPlayerById(target.ToString())?.Name ?? "UNKNOWN"
                : data.DisplayName;

            return string.IsNullOrEmpty(result) ? "UNKNOWN" : result;
        }

        private void TimeHandle()
        {
            var toRemove = Pool.GetList<Invite>();

            _invites?.ForEach(invite =>
            {
                if (Time.time - invite.Cooldown >= 0)
                {
                    RemoveNotify(invite.Target, invite.Guid);

                    Notify(invite.Inviter, _config.Notify.Delay, Msg(NotifyTitle, invite.Inviter.UserIDString),
                        Msg(TimeLose, invite.Inviter.UserIDString), _config.Notify.Image);

                    Notify(invite.Target, _config.Notify.Delay, Msg(NotifyTitle, invite.Target.UserIDString),
                        Msg(TargetTimeLose, invite.Target.UserIDString, invite.Inviter.displayName),
                        _config.Notify.Image);

                    toRemove.Add(invite);
                }
            });

            toRemove.ForEach(invite =>
            {
                if (_config.AddTeam)
                    if (invite.Inviter != null && invite.Target != null)
                    {
                        var team = GetOrCreateTeam(invite.Inviter);
                        if (team != null)
                            if (!team.invites.Contains(invite.Target.userID))
                                team.RejectInvite(invite.Target);
                    }

                _invites.Remove(invite);
            });
            Pool.FreeList(ref toRemove);
        }

        private BasePlayer FindPlayer(List<FriendData> friendDatas)
        {
            return friendDatas.Select(friendData => FindPlayer(friendData.UserId))
                .FirstOrDefault(friend => friend != null);
        }

        private BasePlayer FindPlayer(ulong user)
        {
            foreach (var player in BasePlayer.activePlayerList)
                if (player.userID == user)
                    return player;

            foreach (var player in BasePlayer.sleepingPlayerList)
                if (player.userID == user)
                    return player;

            return null;
        }

        private List<BasePlayer> FindPlayer(string steamOrIdOrName)
        {
            var result = new List<BasePlayer>();

            foreach (var player in BasePlayer.activePlayerList)
                if (player.UserIDString == steamOrIdOrName ||
                    player.displayName.StartsWith(steamOrIdOrName, StringComparison.CurrentCultureIgnoreCase) ||
                    player.displayName.Contains(steamOrIdOrName))
                    result.Add(player);

            return result;
        }

        private List<PlayerData> FindRemoveFriend(BasePlayer player, string friend)
        {
            var result = new List<PlayerData>();

            GetPlayerData(player)?.Friends?.ForEach(f =>
            {
                var fData = GetPlayerData(f.UserId);
                if (fData == null) return;

                if (f.UserId.ToString() == friend ||
                    !string.IsNullOrEmpty(fData.DisplayName) &&
                    fData.DisplayName.StartsWith(friend, StringComparison.CurrentCultureIgnoreCase))
                    result.Add(fData);
            });

            return result;
        }

        private void RemoveFriend(BasePlayer player, ulong friend)
        {
            var data = GetPlayerData(player);
            if (data == null) return;

            var fData = GetPlayerData(friend);
            if (fData == null) return;

            var target = BasePlayer.FindByID(friend);

            var name = target != null ? target.displayName : $"{friend}";

            if (!data.Friends.Exists(x => x.UserId == friend))
            {
                Notify(player, _config.Notify.Delay, Msg(NotifyTitle, player.UserIDString),
                    Msg(IsNotFriend, player.UserIDString, name), _config.Notify.Image);
                return;
            }

            data.RemoveFriend(friend);
            fData.RemoveFriend(player.userID);

            if (_config.AddTeam) player.Team?.RemovePlayer(friend);

            if (_config.UseTeams)
                GetTeamList(player.userID)?.ForEach(member =>
                {
                    GetPlayerData(member)?.RemoveFriend(friend);
                    fData.RemoveFriend(member);
                });

            Notify(player, _config.Notify.Delay, Msg(NotifyTitle, player.UserIDString),
                Msg(FriendRemoved, player.UserIDString, name), _config.Notify.Image);

            if (target != null)
                Notify(target, _config.Notify.Delay, Msg(NotifyTitle, target.UserIDString),
                    Msg(FriendRemoved, target.UserIDString, player.displayName), _config.Notify.Image);

            NextTick(() =>
            {
                UpdateAuthList(player.userID, AutoAuthType.All);

                UpdateAuthList(friend, AutoAuthType.All);
            });
        }

        private RelationshipManager.PlayerTeam GetOrCreateTeam(BasePlayer player)
        {
            var team = RelationshipManager.ServerInstance.FindPlayersTeam(player.userID);
            if (team == null)
            {
                team = RelationshipManager.ServerInstance.CreateTeam();
                team.AddPlayer(player);
                team.SetTeamLeader(player.userID);
            }

            return team;
        }

        #region Invites

        private class Invite
        {
            public readonly BasePlayer Inviter;
            public readonly BasePlayer Target;
            public readonly string Guid;
            public readonly float Cooldown;

            public Invite(BasePlayer inviter, BasePlayer target, string guid)
            {
                Inviter = inviter;
                Target = target;
                Guid = guid;
                Cooldown = Time.time + _config.FriendInvite.Delay;
            }
        }

        private readonly List<Invite> _invites = new List<Invite>();

        private void SendInvite(BasePlayer inviter, BasePlayer target)
        {
            if (inviter == null || target == null || !inviter.userID.IsSteamId() || !target.userID.IsSteamId()) return;

            var data = GetPlayerData(inviter);
            if (data == null) return;

            if (data.Friends.Count >= _config.MaxFriendsAmount)
            {
                Notify(inviter, _config.Notify.Delay, Msg(NotifyTitle, inviter.UserIDString),
                    Msg(TargetMaxFriends, inviter.UserIDString), _config.Notify.Image);
                return;
            }

            if (_invites.Exists(x => x.Inviter == inviter && x.Target == target))
            {
                Notify(inviter, _config.Notify.Delay, Msg(NotifyTitle, inviter.UserIDString),
                    Msg(AlreadyPending, inviter.UserIDString), _config.Notify.Image);
                return;
            }

            if (_invites.Exists(x => x.Inviter == target || x.Target == target))
            {
                Notify(inviter, _config.Notify.Delay, Msg(NotifyTitle, inviter.UserIDString),
                    Msg(PendingBusy, inviter.UserIDString), _config.Notify.Image);
                return;
            }

            var guid = string.Empty;
            if (Notifications)
            {
                var container = new CuiElementContainer();
                _config.FriendInvite.Buttons.ForEach(btn => btn.Get(ref container, target));

                guid = (string) Notifications.Call("ShowNotify",
                    target,
                    _config.FriendInvite.Delay,
                    Msg(NotifyTitle, target.UserIDString),
                    Msg(Pending, target.UserIDString, inviter.displayName),
                    _config.FriendInvite.Image,
                    container);

                Notify(inviter, _config.Notify.Delay, Msg(NotifyTitle, inviter.UserIDString),
                    Msg(PendingSuccessSend, inviter.UserIDString), _config.Notify.Image);
            }
            else
            {
                Reply(target, Pending, inviter.displayName);
                Reply(inviter, PendingSuccessSend);
            }

            if (_config.AddTeam)
            {
                var team = GetOrCreateTeam(inviter);
                if (team != null)
                    if (!team.invites.Contains(target.userID))
                        team.SendInvite(target);
            }

            _invites.Add(new Invite(inviter, target, guid));
        }

        private void AcceptInvite(BasePlayer target)
        {
            var invite = _invites.Find(x => x.Target == target);
            if (invite == null)
            {
                Notify(target, _config.Notify.Delay, Msg(NotifyTitle, target.UserIDString),
                    Msg(PendingNotFound, target.UserIDString), _config.Notify.Image);
                return;
            }

            var inviter = invite.Inviter;
            if (inviter == null) return;

            var iData = GetPlayerData(inviter);
            if (iData == null) return;

            var tData = GetPlayerData(target);
            if (tData == null) return;

            if (target.userID == inviter.userID)
            {
                Notify(target, _config.Notify.Delay, Msg(NotifyTitle, target.UserIDString),
                    Msg(CantAddSelf, target.UserIDString), _config.Notify.Image);
                return;
            }

            if (_config.UseTeams)
            {
                GetTeamList(inviter.userID)?.ForEach(player =>
                {
                    GetPlayerData(player)?.AddFriend(target.userID);
                    tData.AddFriend(player);

                    Log("friends", $"Player '{player}' added '{target.userID}' as a friend");
                });
            }
            else
            {
                GetPlayerData(inviter)?.AddFriend(target.userID);
                tData.AddFriend(inviter.userID);

                Log("friends", $"Player '{inviter.userID}' added '{target.userID}' as a friend");
            }

            RemoveNotify(invite.Target, invite.Guid);

            Notify(target, _config.Notify.Delay, Msg(NotifyTitle, target.UserIDString),
                Msg(FriendAdded, target.UserIDString, inviter.displayName), _config.Notify.Image);

            Notify(inviter, _config.Notify.Delay, Msg(NotifyTitle, inviter.UserIDString),
                Msg(FriendAdded, inviter.UserIDString, target.displayName), _config.Notify.Image);

            _invites.Remove(invite);

            if (_config.AddTeam)
            {
                target.Team?.RemovePlayer(target.userID);

                if (inviter.Team == null || inviter.Team.teamID == 0)
                {
                    var team = RelationshipManager.ServerInstance.CreateTeam();
                    team.AddPlayer(inviter);
                    team.SetTeamLeader(inviter.userID);
                    team.AddPlayer(target);
                }
                else
                {
                    inviter.Team.AddPlayer(target);
                }
            }

            NextTick(() =>
            {
                if (_config.AddTeam && inviter.Team != null) UpdateTeamAuthList(GetTeamList(inviter.userID));
            });
        }

        private List<ulong> GetTeamList(ulong user)
        {
            var result = new List<ulong> {user};

            GetPlayerData(user)?.Friends.ForEach(friend =>
            {
                if (!result.Contains(friend.UserId))
                    result.Add(friend.UserId);
            });

            return result;
        }

        private void CancelInvite(BasePlayer player)
        {
            var invite = _invites.Find(x => x.Target == player);
            if (invite == null)
            {
                Notify(player, _config.Notify.Delay, Msg(NotifyTitle, player.UserIDString),
                    Msg(PendingNotFound, player.UserIDString), _config.Notify.Image);
                return;
            }

            Notify(invite.Inviter, _config.Notify.Delay, Msg(NotifyTitle, invite.Inviter.UserIDString),
                Msg(InviterFriendCancel, invite.Inviter.UserIDString, player.displayName), _config.Notify.Image);

            Notify(player, _config.Notify.Delay, Msg(NotifyTitle, player.UserIDString),
                Msg(FriendCancel, player.UserIDString, invite.Inviter.displayName), _config.Notify.Image);

            RemoveNotify(invite.Target, invite.Guid);

            _invites.Remove(invite);
        }

        #endregion

        #endregion

        #region Lang

        private const string
            UITitle = "UITitle",
            Online = "Online",
            Offline = "Offline",
            NotifyTitle = "InviteTitle",
            Pending = "Pending",
            AlreadyPending = "AlreadyPending",
            PendingBusy = "PendingBusy",
            PendingSuccessSend = "PendingSuccessSend",
            PendingNotFound = "PendingNotFound",
            AlreadyFriends = "AlreadyFriends",
            CantAddSelf = "CantAddSelf",
            MaxFriends = "MaxFriends",
            TargetMaxFriends = "TargetMaxFriends",
            TimeLose = "TimeLose",
            TargetTimeLose = "TargetTimeLose",
            FriendAdded = "FriendAdded",
            FriendCancel = "FriendCancel",
            InviterFriendCancel = "InviterFriendCancel",
            NoFriends = "NoFriends",
            FriendList = "FriendList",
            IsNotFriend = "IsNotFriend",
            FriendRemoved = "FriendRemoved",
            NotFound = "NotFound",
            FF = "FF",
            FFOn = "FFOn",
            FFOff = "FFOff",
            FFErrorSyntax = "FFErrorSyntax",
            ErrorSyntax = "ErrorSyntax",
            SamsOn = "SamsOn",
            SamsOff = "SamsOff",
            DoorsOn = "DoorsOn",
            DoorsOff = "DoorsOff",
            TurretsOn = "TurretsOn",
            TurretsOff = "TurretsOff",
            CupboardOn = "CupboardOn",
            CupboardOff = "CupboardOff",
            ContainersOn = "ContainersOn",
            ContainersOff = "ContainersOff",
            Accept = "Accept",
            Cancel = "Cancel",
            FindFriend = "FindFriend",
            Help = "Help",
            MultipleFound = "MultipleFound";

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [UITitle] = "FRIENDS SYSTEM",
                [Online] = "Online",
                [Offline] = "Offline",
                [NotifyTitle] = "Friend System",
                [Pending] = "{0} sent you a friend request",
                [AlreadyPending] =
                    "Your previous friend request has not yet been answered by the player, please wait for a response!",
                [PendingBusy] =
                    "The player already has a request from another player, please wait until the player responds to the other",
                [PendingSuccessSend] = "Request sent successfully, please wait while it accepts it.",
                [PendingNotFound] = "You have no friend requests",
                [AlreadyFriends] = "You are already friends!",
                [CantAddSelf] = "You cannot add yourself as a friend.",
                [MaxFriends] = "You have reached the maximum number of friends",
                [TargetMaxFriends] = "The player has reached the maximum number of friends",
                [TimeLose] = "The player did not have time to accept the invitation!",
                [TargetTimeLose] = "You did not have time to accept the invitation from {0}",
                [FriendAdded] = "{0} has become your friend.",
                [FriendCancel] = "You gave up your friendship with {0}",
                [InviterFriendCancel] = "{0} refused to befriend you.",
                [NoFriends] = "You have no friends = (",
                [FriendList] = "Your friends list: {0}",
                [IsNotFriend] = "The player is not your friend",
                [FriendRemoved] = "You ended your friendship with {0}",
                [NotFound] = "Player '{0}' not found!",
                [FF] = "Attention! {0} Your friend, you cannot hurt him. Enable/Disable damage on friends: /friend ff",
                [FFOn] = "You enabled Friends Damage!",
                [FFOff] = "You turned off damage to friends!",
                [FFErrorSyntax] = "Use: /{0} name/steamid [on/off]",
                [ErrorSyntax] = "Use: /{0} {1} name/steamid",
                [DoorsOn] = "You have enabled friends to access your doors!",
                [DoorsOff] = "You have disabled friends' access to your doors!",
                [TurretsOn] = "You have enabled the authorization of friends in turrets",
                [TurretsOff] = "You have disabled the authorization of friends in turrets",
                [SamsOn] = "You have enabled the authorization of friends in SAMs",
                [SamsOff] = "You have disabled the authorization of friends in SAMs",
                [CupboardOn] = "You have enabled cupboard friends authorization",
                [CupboardOff] = "You have disabled cupboard friends authorization",
                [ContainersOn] = "You have enabled containers friends authorization",
                [ContainersOff] = "You have disabled containers friends authorization",
                [Accept] = "Accept",
                [Cancel] = "Cancel",
                [FindFriend] = "FIND FRIEND",
                [Help] = "FRIEND HELP: /friend add|remove|accept|cancel|list|doors|cupboard|turrets",
                [MultipleFound] = "Found multiple players: {0}\nUse: /{1} {2} {3} [ID]"
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                [UITitle] = "СИСТЕМА ДРУЗЕЙ",
                [Online] = "Онлайн",
                [Offline] = "Оффлайн",
                [NotifyTitle] = "Система друзей",
                [Pending] = "{0} отправил вам запрос в друзья",
                [AlreadyPending] = "На ваш предыдущий запрос дружбы игрок еще не ответил, ожидайте его ответа!",
                [PendingBusy] =
                    "У игрока уже есть запрос от другого игрока, ожидайте пока игрок игрок не ответит другому",
                [PendingSuccessSend] = "Запрос успешно отправлен, ожидайте пока он примет его.",
                [PendingNotFound] = "К вам нет запросов в друзья",
                [AlreadyFriends] = "Вы уже являетесь друзьями!",
                [CantAddSelf] = "Вы не можете добавить себя в друзья.",
                [MaxFriends] = "У вас достигнуто максимальное количество друзей",
                [TargetMaxFriends] = "У игрока достигнуто максимальное количество друзей",
                [TimeLose] = "Игрок не успел принять приглашение!",
                [TargetTimeLose] = "Вы не успели принять приглашение от {0}",
                [FriendAdded] = "{0} стал Вашим другом.",
                [FriendCancel] = "Вы отказались от дружбы с {0}",
                [InviterFriendCancel] = "{0} отказался от дружбы с Вами.",
                [NoFriends] = "У Вас нет друзей =(",
                [FriendList] = "Список ваших друзей: {0}",
                [IsNotFriend] = "Игрок '{0}' не является Вашим другом",
                [FriendRemoved] = "Вы прекратили дружбу с {0}",
                [NotFound] = "Игрок '{0}' не найден!",
                [FF] =
                    "Внимание! {0} Ваш друг, вы не можете его ранить. Включение/Отключение урона по друзьям /friend ff",
                [FFOn] = "Вы включили урон по друзьям!",
                [FFOff] = "Вы выключили урон по друзьям!",
                [FFErrorSyntax] = "Используйте: /{0} name/steamid [on/off]",
                [ErrorSyntax] = "Используйте: /{0} {1} name/steamid",
                [DoorsOn] = "Вы включили доступ друзей к вашим дверям!",
                [DoorsOff] = "Вы выключили доступ друзей к вашим дверям!",
                [TurretsOn] = "Вы включили авторизацию друзей в турелях",
                [TurretsOff] = "Вы выключили авторизацию друзей в турелях",
                [SamsOn] = "Вы включили авторизацию друзей в ПВО",
                [SamsOff] = "Вы выключили авторизацию друзей в ПВО",
                [CupboardOn] = "Вы включили авторизацию друзей в шкафах",
                [CupboardOff] = "Вы выключили авторизацию друзей в шкафах",
                [ContainersOn] = "Вы включили авторизацию друзей в ящиках",
                [ContainersOff] = "Вы выключили авторизацию друзей в ящиках",
                [Accept] = "Принять",
                [Cancel] = "Отклонить",
                [FindFriend] = "НАЙТИ ДРУГА",
                [Help] = "ПОМОЩЬ ПО ДРУЗЬЯМ: /friend add|remove|accept|cancel|list|doors|cupboard|turrets",
                [MultipleFound] = "Найдено несколько игроков: {0}\nИспользуйте: /{1} {2} {3} [ID]"
            }, this, "ru");
        }

        private void Notify(BasePlayer player, float delay, string title, string description, string image)
        {
            if (player == null) return;

            if (Notifications)
                Notifications.Call("ShowNotify", player, delay, title, description, image);
            else
                SendReply(player, description);

            var reply = "";
            if (reply == "14879")
            {
            }
        }

        private void RemoveNotify(BasePlayer player, string guid)
        {
            Notifications?.Call("RemoveNotify", player, guid);
        }

        private void Reply(BasePlayer player, string key, params object[] obj)
        {
            SendReply(player, Msg(key, player.UserIDString, obj));
        }

        private string Msg(string key, string userid = null, params object[] obj)
        {
            return string.Format(lang.GetMessage(key, this, userid), obj);
        }

        #endregion

        #region Cooldown

        private readonly Dictionary<ulong, float> _cooldown = new Dictionary<ulong, float>();

        private bool IsCd(ulong user)
        {
            return GetCd(user) >= 0;
        }

        private int GetCd(ulong user)
        {
            return _cooldown.ContainsKey(user) ? (int) (_cooldown[user] - Time.time) : -1;
        }

        private void SetCd(ulong user)
        {
            var time = Time.time + _config.FFDelay;
            if (_cooldown.ContainsKey(user))
                _cooldown[user] = time;
            else
                _cooldown.Add(user, time);
        }

        #endregion

        #region API

        private ulong[] GetFriends(string playerId)
        {
            return GetFriends(ulong.Parse(playerId));
        }

        private ulong[] GetFriends(ulong playerId)
        {
            return GetPlayerData(playerId)?.Friends.Select(x => x.UserId).ToArray();
        }

        private ulong[] GetFriendList(string playerId)
        {
            return GetFriendList(ulong.Parse(playerId));
        }

        private ulong[] GetFriendList(ulong playerId)
        {
            return GetFriends(playerId);
        }

        private bool AreFriends(string playerId, string friendId)
        {
            return AreFriends(ulong.Parse(playerId), ulong.Parse(friendId));
        }

        private bool AreFriends(ulong playerId, ulong friendId)
        {
            return GetPlayerData(playerId)?.IsFriend(friendId) == true;
        }

        private bool HasFriend(string playerId, string friendId)
        {
            return HasFriend(ulong.Parse(playerId), ulong.Parse(friendId));
        }

        private bool HasFriend(ulong playerId, ulong friendId)
        {
            return AreFriends(playerId, friendId);
        }

        private bool HasFriends(string playerId, string friendId)
        {
            return AreFriends(ulong.Parse(playerId), ulong.Parse(friendId));
        }

        private bool HasFriends(ulong playerId, ulong friendId)
        {
            return AreFriends(playerId, friendId);
        }

        private bool IsFriend(string playerId, string friendId)
        {
            return IsFriend(ulong.Parse(playerId), ulong.Parse(friendId));
        }

        private bool IsFriend(ulong playerId, ulong friendId)
        {
            return AreFriends(playerId, friendId);
        }

        private bool WasFriend(string playerId, string friendId)
        {
            return WasFriend(ulong.Parse(playerId), ulong.Parse(friendId));
        }

        private bool WasFriend(ulong playerId, ulong friendId)
        {
            return GetPlayerData(playerId)?.RemovedFriends.Contains(friendId) == true;
        }

        private int GetMaxFriends()
        {
            return _config.MaxFriendsAmount;
        }

        #endregion
    }
}

// --- End of file: Friends (2).cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SignArtist.cs ---
// --- Original Local Path: SignArtist.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using Oxide.Core;

using UnityEngine;

namespace Oxide.Plugins
{

    [Info("Sign Artist", "Bombardir", "0.3.2", ResourceId = 992)]
    class SignArtist : RustPlugin
    {
        GameObject WebObject;
        UnityWeb UWeb;
        Dictionary<BasePlayer, float> CoolDowns;

        #region Unity WWW

        class QueueItem
        {
            public string url;
            public Signage sign;
            public BasePlayer sender;
            public bool raw;

            public QueueItem(string ur, BasePlayer se, Signage si, bool raw)
            {
                url = ur;
                sender = se;
                sign = si;
                this.raw = raw;
            }
        }

        class UnityWeb : MonoBehaviour
        {
            private Queue<QueueItem> QueueList = new Queue<QueueItem>();
            private byte ActiveLoads;
            private SignArtist SignArtist;

            private void Awake()
            {
                SignArtist = (SignArtist)Interface.Oxide.RootPluginManager.GetPlugin(nameof(SignArtist));
            }

            private void OnDestroy()
            {
                QueueList.Clear();
                SignArtist = null;
            }

            public void Add(string url, BasePlayer player, Signage s, bool raw)
            {
                QueueList.Enqueue(new QueueItem(url, player, s, raw));
                if (ActiveLoads < SignArtist.MaxActiveLoads)
                    Next();
            }

            void Next()
            {
                if (QueueList.Count <= 0) return;
                ActiveLoads++;
                StartCoroutine(WaitForRequest(QueueList.Dequeue()));
            }

            byte[] GetImageBytes(WWW www)
            {
                var tex = www.texture;
                byte[] img;
                if (tex.format == TextureFormat.ARGB32 && !SignArtist.ForceJPG)
                    img = tex.EncodeToPNG();
                else
                    img = tex.EncodeToJPG(SignArtist.JPGCompression);
                //player.ChatMessage(tex.format + " - " + tex + " - " + tex.EncodeToPNG().Length + " - " + tex.GetRawTextureData().Length + " - " + tex.EncodeToJPG(SignArtist.JPGCompression).Length);
                DestroyImmediate(tex);
                return img;
            }

            IEnumerator WaitForRequest(QueueItem info)
            {
                using (var www = new WWW(info.url))
                {
                    yield return www;
                    if (SignArtist == null) yield break;
                    var player = info.sender;
                    if (www.error != null)
                    {
                        player.ChatMessage(string.Format(SignArtist.Error, www.error));
                        //SignArtist.CoolDowns.Remove(player);
                    }
                    else
                    {
                        if (www.size > SignArtist.MaxSize)
                        {
                            player.ChatMessage(SignArtist.SizeError);
                            //SignArtist.CoolDowns.Remove(player);
                            ActiveLoads--;
                            Next();
                            yield break;
                        }

                        var img = info.raw ? www.bytes : GetImageBytes(www);
                        if (img.Length <= SignArtist.MaxSize)
                        {
                            var sign = info.sign;
                            if (sign.textureID > 0U)
                                FileStorage.server.Remove(sign.textureID, FileStorage.Type.png, sign.net.ID);
                            sign.textureID = FileStorage.server.Store(img, FileStorage.Type.png, sign.net.ID);
                            sign.SendNetworkUpdate();
                            Interface.Oxide.CallHook("OnSignUpdated", sign, player);
                            player.ChatMessage(SignArtist.Loaded);

                            if (SignArtist.ConsoleLog)
                                ServerConsole.PrintColoured(System.ConsoleColor.DarkYellow, string.Format(SignArtist.ConsoleLogMsg, player.userID, player.displayName, sign.textureID, info.url));
                            //Resources.UnloadUnusedAssets();
                        }
                        else
                        {
                            player.ChatMessage(SignArtist.SizeError);
                            //SignArtist.CoolDowns.Remove(player);
                        }
                    }
                    ActiveLoads--;
                    Next();
                }
            }
        }

        #endregion

        [ConsoleCommand("sil")]
        void ccmdSil(ConsoleSystem.Arg arg)
        {
            if (arg.Player() == null) return;
            sil(arg.Player(), string.Empty, arg.Args ?? new string[0]);
        }

        #region Chat Commands

        [ChatCommand("sil")]
        void sil(BasePlayer player, string command, string[] args)
        {
            if (args.Length == 0)
            {
                player.ChatMessage(Syntax);
                return;
            }

            if (!HasPerm(player, "signartist.url"))
            {
                player.ChatMessage(NoPerm);
                return;
            }

            float cd;
            if (CoolDowns.TryGetValue(player, out cd) && cd > Time.realtimeSinceStartup && !HasPerm(player, "signartist.cd"))
            {
                player.ChatMessage(string.Format(CooldownMsg, ToReadableString(cd - Time.realtimeSinceStartup)));
                return;
            }

            RaycastHit hit;
            Signage sign = null;
            if (Physics.Raycast(player.eyes.HeadRay(), out hit, MaxDist))
                sign = hit.transform.GetComponentInParent<Signage>();

            if (sign == null)
            {
                player.ChatMessage(NoSignFound);
                return;
            }

            if (!sign.CanUpdateSign(player) && !HasPerm(player, "signartist.owner"))
            {
                player.ChatMessage(NotYourSign);
                return;
            }

            var raw = args.Length > 1 && args[1].Equals("raw", StringComparison.OrdinalIgnoreCase);
            if (raw && !HasPerm(player, "signartist.raw"))
            {
                player.ChatMessage(NoPerm);
                return;
            }
            UWeb.Add(args[0], player, sign, raw);
            player.ChatMessage(AddedToQueue);
            if (UrlCooldown > 0)
                CoolDowns[player] = Time.realtimeSinceStartup + UrlCooldown;
        }

        [ConsoleCommand("silt")]
        void ccmdSilt(ConsoleSystem.Arg arg)
        {
            if (arg.Player() == null) return;
            silt(arg.Player(), string.Empty, arg.Args ?? new string[0]);
        }

        [ChatCommand("silt")]
        void silt(BasePlayer player, string command, string[] args)
        {
            if (args.Length == 0)
            {
                player.ChatMessage(Syntax);
                return;
            }

            if (!HasPerm(player, "signartist.url"))
            {
                player.ChatMessage(NoPerm);
                return;
            }

            float cd;
            if (CoolDowns.TryGetValue(player, out cd) && cd > Time.realtimeSinceStartup && !HasPerm(player, "signartist.cd"))
            {
                player.ChatMessage(string.Format(CooldownMsg, ToReadableString(cd - Time.realtimeSinceStartup)));
                return;
            }

            RaycastHit hit;
            Signage sign = null;
            if (Physics.Raycast(player.eyes.HeadRay(), out hit, MaxDist))
                sign = hit.transform.GetComponentInParent<Signage>();

            if (sign == null)
            {
                player.ChatMessage(NoSignFound);
                return;
            }

            if (!sign.CanUpdateSign(player) && !HasPerm(player, "signartist.owner"))
            {
                player.ChatMessage(NotYourSign);
                return;
            }

            var raw = args.Length > 1 && args[1].Equals("raw", StringComparison.OrdinalIgnoreCase);
            if (raw && !HasPerm(player, "signartist.raw"))
            {
                player.ChatMessage(NoPerm);
                return;
            }
            string txt = Convert.ToBase64String(System.Text.Encoding.UTF8.GetBytes(args[0])).TrimEnd('=');
            int textSize = 80;
            string txtClr = "000";
            string bg = "0FFF";
            if (args.Length > 2) int.TryParse(args[2], out textSize);
            if (args.Length > 3) txtClr = args[3];
            if (args.Length > 4) bg = args[4];
            var width = (int)Math.Round(100 * sign.bounds.size.x * .9);
            var height = (int)Math.Round(100 * sign.bounds.size.y * .9);
            var url = $"http://placeholdit.imgix.net/~text?fm=png32&txtsize={textSize}&txt64={txt}&w={width}&h={height}&txtclr={txtClr}&bg={bg}";
            UWeb.Add(url, player, sign, raw);
            SendReply(player, AddedToQueue);
            if (UrlCooldown > 0)
                CoolDowns[player] = Time.realtimeSinceStartup + UrlCooldown;
        }

        #endregion

        #region Config | Init | Unload

        float MaxDist = 2f;
        float UrlCooldown = 180f;
        uint MaxSize = 2048U;
        byte JPGCompression = 85;
        bool ForceJPG = false;
        string NoPerm = "You don't have permission to use this command!";
        string Syntax = "Syntax: /sil <URL> | /sil s <number>";
        string NoSignFound = "You need to look/get closer to a sign!";
        string NotYourSign = "You can't change this sign! (protected by tool cupboard)";
        string CooldownMsg = "You have recently used this command! You need to wait: {time}";
        string AddedToQueue = "Your picture was added to load queue!";
        string Loaded = "Image was loaded to Sign!";
        string Error = "Image loading fail! Error: {error}";
        string NotExists = "File with this name not exists in storage folder!";
        string SizeError = "This file is too large. Max size: {size}KB";
        bool ConsoleLog = true;
        string ConsoleLogMsg = "Player[{steam} {name}] loaded {id} image from {url}!";
        int MaxActiveLoads = 3;


        void LoadDefaultConfig()
        {
        }

        void OnServerInitialized()
        {
            permission.RegisterPermission("signartist.url", this);
            permission.RegisterPermission("signartist.raw", this);
            permission.RegisterPermission("signartist.owner", this);
            permission.RegisterPermission("signartist.cd", this);

            CheckCfg("Log url console", ref ConsoleLog);
            CheckCfg("Log format", ref ConsoleLogMsg);
            CheckCfg("Max active uploads", ref MaxActiveLoads);
            CheckCfg("Max sign detection distance", ref MaxDist);
            CheckCfg("Max file size(KB)", ref MaxSize);
            CheckCfg("Command cooldown after url", ref UrlCooldown);
            CheckCfg("Command cooldown msg", ref CooldownMsg);
            CheckCfg("NoPermission", ref NoPerm);
            CheckCfg("Syntax", ref Syntax);
            CheckCfg("No sign", ref NoSignFound);
            CheckCfg("Not your sign", ref NotYourSign);
            CheckCfg("Added to queue", ref AddedToQueue);
            CheckCfg("Loaded", ref Loaded);
            CheckCfg("Not Exists", ref NotExists);
            CheckCfg("Error", ref Error);
            CheckCfg("JPGCompression", ref JPGCompression);
            CheckCfg("ForceJPG", ref ForceJPG);
            SaveConfig();

            // Small performance improvements
            ConsoleLogMsg = "[Sign Artist]" + ConsoleLogMsg
                .Replace("{steam}", "{0}")
                .Replace("{name}", "{1}")
                .Replace("{id}", "{2}")
                .Replace("{url}", "{3}");
            Error = Error.Replace("{error}", "{0}");

            CooldownMsg = CooldownMsg.Replace("{time}", "{0}");

            SizeError = SizeError.Replace("{size}", MaxSize.ToString());
            // ----------------------------- //

            MaxSize *= 1024;

            WebObject = new GameObject("WebObject");
            UWeb = WebObject.AddComponent<UnityWeb>();
            CoolDowns = new Dictionary<BasePlayer, float>();
        }

        void Unload()
        {
            UnityEngine.Object.Destroy(WebObject);
            UWeb = null;
            CoolDowns = null;
        }

        #endregion

        #region Util methods

        void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] == null)
                Config[Key] = var;
            else
                try
                {
                    var = (T) Convert.ChangeType(Config[Key], typeof (T));
                }
                catch
                {
                    Config[Key] = var;
                }
        }

        bool HasPerm(BasePlayer p, string pe) => permission.UserHasPermission(p.UserIDString, pe);

        static string ToReadableString(float seconds)
        {
            TimeSpan span = TimeSpan.FromSeconds(seconds).Duration();
            string formatted = string.Format("{0}{1}{2}{3}",
                span.Days > 0 ? $"{span.Days:0} day{(span.Days == 1 ? string.Empty : "s")}, " : string.Empty,
                span.Hours > 0 ? $"{span.Hours:0} hour{(span.Hours == 1 ? string.Empty : "s")}, " : string.Empty,
                span.Minutes > 0 ? $"{span.Minutes:0} minute{(span.Minutes == 1 ? string.Empty : "s")}, " : string.Empty,
                span.Seconds > 0 ? $"{span.Seconds:0} second{(span.Seconds == 1 ? string.Empty : "s")}" : string.Empty);

            if (formatted.EndsWith(", ")) formatted = formatted.Substring(0, formatted.Length - 2);

            if (string.IsNullOrEmpty(formatted)) formatted = "0 seconds";

            return formatted;
        }

        #endregion
    }
}


// --- End of file: SignArtist.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/StackSizeController.cs ---
// --- Original Local Path: StackSizeController.cs ---

using System.Collections.Generic;
using System.Linq;
using System;

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Stack Size Controller", "Waizujin", 1.9, ResourceId = 1185)]
    [Description("Allows you to set the max stack size of every item.")]
    public class StackSizeController : RustPlugin
    {
		protected override void LoadDefaultConfig()
        {
			PrintWarning("Creating a new configuration file.");

			var gameObjectArray = FileSystem.LoadAll<GameObject>("Assets/", ".item");
			var itemList = gameObjectArray.Select(x => x.GetComponent<ItemDefinition>()).Where(x => x != null).ToList();

			foreach (var item in itemList)
			{
				if (item.condition.enabled && item.condition.max > 0) { continue; }

				Config[item.displayName.english] = item.stackable;
			}
		}

        void OnServerInitialized()
        {
            permission.RegisterPermission("stacksizecontroller.canChangeStackSize", this);

			var dirty = false;
			var itemList = ItemManager.itemList;

			foreach (var item in itemList)
			{
				if (item.condition.enabled && item.condition.max > 0) { continue; }

				if (Config[item.displayName.english] == null)
				{
					Config[item.displayName.english] = item.stackable;
					dirty = true;
				}

				item.stackable = (int)Config[item.displayName.english];
			}

			if (dirty == false) { return; }

			PrintWarning("Updating configuration file with new values.");
			SaveConfig();
		}

        [ChatCommand("stack")]
        private void StackCommand(BasePlayer player, string command, string[] args)
        {
            int stackAmount = 0;

            if (!hasPermission(player, "stacksizecontroller.canChangeStackSize"))
			{
				SendReply(player, "You don't have permission to use this command.");

				return;
			}

			if (args.Length <= 1)
			{
                SendReply(player, "Syntax Error: Requires 2 arguments. Syntax Example: /stack ammo_rocket_hv 64 (Use shortname)");

				return;
			}

            if (int.TryParse(args[1], out stackAmount) == false)
            {
                SendReply(player, "Syntax Error: Stack Amount is not a number. Syntax Example: /stack ammo_rocket_hv 64 (Use shortname)");

                return;
            }

            List<ItemDefinition> items = ItemManager.itemList.FindAll(x => x.shortname.Equals(args[0]));

            if (items[0].shortname == args[0])
            {
                if (items[0].condition.enabled && items[0].condition.max > 0) { return; }

                Config[items[0].displayName.english] = Convert.ToInt32(stackAmount);
                items[0].stackable = Convert.ToInt32(stackAmount);

                SaveConfig();

                SendReply(player, "Updated Stack Size for " + items[0].displayName.english + " (" + items[0].shortname + ") to " + stackAmount + ".");
            }
            else
            {
                SendReply(player, "That is an incorrect item name. Please use a valid shortname.");
            }
        }

        [ChatCommand("stackall")]
        private void StackAllCommand(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player, "stacksizecontroller.canChangeStackSize"))
			{
				SendReply(player, "You don't have permission to use this command.");

				return;
			}

			if (args.Length == 0)
			{
                SendReply(player, "Syntax Error: Requires 1 argument. Syntax Example: /stackall 65000");

				return;
			}

            var itemList = ItemManager.itemList;

			foreach (var item in itemList)
			{
                if (item.displayName.english.ToString() == "Salt Water" ||
                item.displayName.english.ToString() == "Water") { continue; }

				Config[item.displayName.english] = Convert.ToInt32(args[0]);
				item.stackable = Convert.ToInt32(args[0]);
			}

            SaveConfig();

            SendReply(player, "The Stack Size of all stackable items has been set to " + args[0]);
        }

        [ConsoleCommand("stack")]
        private void StackConsoleCommand(ConsoleSystem.Arg arg)
        {
            int stackAmount = 0;

            if(arg.isAdmin != true) { return; }

            if (arg.Args.Length <= 1)
            {
                Puts("Syntax Error: Requires 2 arguments. Syntax Example: stack ammo_rocket_hv 64 (Use shortname)");

                return;
            }

            if (int.TryParse(arg.Args[1], out stackAmount) == false)
            {
                Puts("Syntax Error: Stack Amount is not a number. Syntax Example: stack ammo_rocket_hv 64 (Use shortname)");

                return;
            }

            List<ItemDefinition> items = ItemManager.itemList.FindAll(x => x.shortname.Equals(arg.Args[0]));

            if (items[0].shortname == arg.Args[0])
            {
                if (items[0].condition.enabled && items[0].condition.max > 0) { return; }

                Config[items[0].displayName.english] = Convert.ToInt32(stackAmount);
                items[0].stackable = Convert.ToInt32(stackAmount);

                SaveConfig();

                Puts("Updated Stack Size for " + items[0].displayName.english + " (" + items[0].shortname + ") to " + stackAmount + ".");
            }
            else
            {
                Puts("That is an incorrect item name. Please use a valid shortname.");
            }
        }

        [ConsoleCommand("stackall")]
        private void StackAllConsoleCommand(ConsoleSystem.Arg arg)
        {
            if(arg.isAdmin != true) { return; }

            if (arg.Args.Length == 0)
			{
                Puts("Syntax Error: Requires 1 argument. Syntax Example: stackall 65000");

				return;
			}

            var itemList = ItemManager.itemList;

			foreach (var item in itemList)
			{
                if (item.displayName.english.ToString() == "Salt Water" ||
                item.displayName.english.ToString() == "Water") { continue; }

				Config[item.displayName.english] = Convert.ToInt32(arg.Args[0]);
				item.stackable = Convert.ToInt32(arg.Args[0]);
			}

            SaveConfig();

            Puts("The Stack Size of all stackable items has been set to " + arg.Args[0]);
        }

        bool hasPermission(BasePlayer player, string perm)
        {
            if (player.net.connection.authLevel > 1)
            {
                return true;
            }

            return permission.UserHasPermission(player.userID.ToString(), perm);
        }
    }
}


// --- End of file: StackSizeController.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SeedEvent.cs ---
// --- Original Local Path: SeedEvent.cs ---

﻿using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("SeedEvent", "Own3r/Nericai", "1.1.0")]
    [Description("Ивент позволяет выращивать камни на грядках")]
    class SeedEvent : RustPlugin
    {
        private class Random
        {
            [JsonProperty("Название ресурса")] public string DisplayName;

            [JsonProperty("Название объекта (не менять)")]
            public string Prefabs;

            [JsonProperty("Используется в рандоме")]
            public bool Active;
        }

        private class PlantSeedConfig
        {
            [JsonProperty("Время прорастания семечки")]
            public int TimeToUp;

            [JsonProperty("Список выращиваемых предметов")]
            public List<Random> RandomList;

            [JsonProperty("Skin семечки")] public ulong SkinIdPlant;

            [JsonProperty("Максимальное ХП камня (Стандартное 1)")]
            public float startHealth;
        }

        private PlantSeedConfig config;

        protected override void LoadDefaultConfig()
        {
            config = new PlantSeedConfig
            {
                TimeToUp = 20,
                RandomList = new List<Random>
                {
                    new Random
                    {
                        DisplayName = "Металл",
                        Prefabs = "assets/bundled/prefabs/autospawn/resource/ores/metal-ore.prefab",
                        Active = true
                    },
                    new Random
                    {
                        DisplayName = "Сера",
                        Prefabs = "assets/bundled/prefabs/autospawn/resource/ores/sulfur-ore.prefab",
                        Active = true
                    }
                },
                SkinIdPlant = 1562930487,
                startHealth = 1f
            };
            SaveConfig();
            PrintWarning("Создаем дефолтный конфиг");
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PlantSeedConfig>();
        }

        private void SendInfo(BasePlayer player, string message)
        {
            player.SendConsoleCommand("gametip.showgametip", message);
            timer.Once(3f, () => player.SendConsoleCommand("gametip.hidegametip"));
        }

        void OnServerInitialized()
        {
            if (plugins.Exists("Stacks") || plugins.Exists("Stacks")) UnsubscribeSplit();
            else SubscribeSplit();
            permission.RegisterPermission("seedevent.allow", this);
        }

        void OnEntityBuilt(Planner plan, GameObject go)
        {
            if (!go.name.Contains("corn")) return;
            var player = plan.GetOwnerPlayer();
            var isSeed = go.GetComponent<PlantEntity>();
            if (player == null || isSeed == null || isSeed.skinID != config.SkinIdPlant) return;
            if (!permission.UserHasPermission(player.UserIDString, "seedevent.allow"))
            {
                isSeed.Kill();
                player.inventory.GiveItem(ItemManager.CreateByName("clone.corn", 1, config.SkinIdPlant));
                SendInfo(player, "Вы не можете делать этого!");
                return;
            }

            NextTick(() =>
            {
                if (isSeed.skinID != config.SkinIdPlant) return;
                if (!(isSeed.GetParentEntity() is PlanterBox))
                {
                    SendInfo(player, "Вы можете посадить это семечко только на грядках");
                    isSeed.Kill();
                    player.inventory.GiveItem(ItemManager.CreateByName("clone.corn", 1, config.SkinIdPlant));
                    return;
                }

                var ent = go.ToBaseEntity();
                var coords = ent.transform.position;
                var ore = GameManager.server.CreateEntity(GetRandomOre(), coords) as OreResourceEntity;
                if (ore != null)
                {
                    isSeed.Kill();
                    ore.Spawn();
                    ore.gameObject.AddComponent<BaseCombatEntity>();
                    ore.GetComponent<BaseCombatEntity>().InitializeHealth(0.1f, config.startHealth);
                    UpdateVisible(ore.GetComponent<StagedResourceEntity>());
                    StartTimerToThis(ore);
                }

                SendInfo(player, $"Вы успешно посадили семечку, она прорастет через {config.TimeToUp} секунд");
            });
        }

        private void GiveSeeds(BasePlayer player)
        {
            Item x = ItemManager.CreateByName("clone.corn", 1, config.SkinIdPlant);
            player.GiveItem(x, BaseEntity.GiveItemReason.PickedUp);
        }

        private string GetRandomOre()
        {
            return config.RandomList.Where(p => p.Active).ToList().GetRandom().Prefabs;
        }

        private void StartTimerToThis(OreResourceEntity ore)
        {
            var stageComponent = ore.GetComponent<StagedResourceEntity>();
            var healthComponent = ore.GetComponentInParent<BaseCombatEntity>();
            var resComponent = ore.GetComponentInParent<ResourceDispenser>();
            resComponent.containedItems.ForEach(x => x.amount = x.startAmount / (config.startHealth / 0.1f));
            timer.Once(config.TimeToUp / 10f, () => Iterac(ore, stageComponent, healthComponent, resComponent));
        }

        private void Iterac(OreResourceEntity ore, StagedResourceEntity stageComponent,
            BaseCombatEntity healthComponent, ResourceDispenser resComponent)
        {
            if (ore == null || stageComponent == null || healthComponent == null) return;
            healthComponent.health += 0.1f;
            resComponent.containedItems.ForEach(x => x.amount += x.startAmount / (config.startHealth / 0.1f));
            UpdateVisible(stageComponent);
            if (healthComponent.health >= healthComponent.MaxHealth())
            {
                ore.CancelInvoke();
                return;
            }

            timer.Once(config.TimeToUp / 10f, () => Iterac(ore, stageComponent, healthComponent, resComponent));
        }

        private void UpdateVisible(StagedResourceEntity stageComponent)
        {
            var newStage =
                stageComponent.stages.FirstOrDefault(p =>
                    p.health <= stageComponent.GetComponentInParent<BaseCombatEntity>().health) ??
                stageComponent.stages.First();
            stageComponent.stage = stageComponent.stages.IndexOf(newStage);
            newStage.instance.SetActive(true);
            GroundWatch.PhysicsChanged(stageComponent.gameObject);
            stageComponent.SendNetworkUpdate();
        }

        void UnsubscribeSplit()
        {
            Unsubscribe(nameof(OnItemSplit));
            Unsubscribe(nameof(CanStackItem));
        }

        void SubscribeSplit()
        {
            Subscribe(nameof(OnItemSplit));
            Subscribe(nameof(CanStackItem));
        }

        object OnItemSplit(Item thisI, int split_Amount)
        {
            if (thisI.info.itemid != -778875547 && thisI.skin != config.SkinIdPlant) return null;
            Item item = null;
            item = ItemManager.CreateByItemID(thisI.info.itemid, split_Amount, thisI.skin);
            if (item != null)
            {
                thisI.amount -= split_Amount;
                thisI.MarkDirty();
                item.amount = split_Amount;
                item.OnVirginSpawn();
                item.MarkDirty();
                return item;
            }

            return null;
        }

        object CanStackItem(Item thisI, Item item)
        {
            if (thisI.skin == 774) return null;
            if (thisI.skin != item.skin) return false;
            if (thisI.info.itemid != -778875547 && thisI.skin != config.SkinIdPlant) return null;
            if (thisI.skin == item.skin && thisI.skin == config.SkinIdPlant) return true;
            return null;
        }

        [ConsoleCommand("seedevent")]
        private void cmdChange(ConsoleSystem.Arg args)
        {
            ulong pid;
            int count;
            if (!args.IsAdmin && !args.IsRcon && !args.IsServerside) return;
            if (args.Args[0] == null || args.Args[1] == null || args.Args.Length != 2) return;
            if (!ulong.TryParse(args.Args[0], out pid)) return;
            BasePlayer player = BasePlayer.FindByID(pid);
            if (player == null)
            {
                SendReply(player, $"Игрок со SteamID {pid} не найден.");
                return;
            }

            if (!int.TryParse(args.Args[1], out count)) count = 1;

            Item rec = ItemManager.CreateByName("clone.corn", count, config.SkinIdPlant);
            rec.MoveToContainer(player.inventory.containerMain);
            SendReply(player, $"Вы получили {count} семечка.");
        }
    }
}

// --- End of file: SeedEvent.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Cases.cs ---
// --- Original Local Path: Cases.cs ---

using System.Linq;
using System;
using System.Collections.Generic;
using System.Globalization;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Cases", "Drop Dead / Redesign and fix by Deversive", "1.0.2")]
    public class Cases : RustPlugin
    {
        [PluginReference] private Plugin ImageLibrary;
        private static Cases _ins;
        bool addday = false;
        string Layer = "Cases.Main";
                string Case231 = "1";
        private string Case341 = "2";
        private string Case56161 = "3";
        private string Case612354 = "4";
        public Dictionary<ulong, int> time = new Dictionary<ulong, int>();
        public Dictionary<ulong, List<Inventory>> inventory = new Dictionary<ulong, List<Inventory>>();
        public List<int> day = new List<int>();
        public Dictionary<ulong, int> taked = new Dictionary<ulong, int>();
        public List<ulong> openedui = new List<ulong>();


        string MainIMG = "https://imgur.com/uXKc6US.png";
        string InventoryIMG = "https://imgur.com/MV2Za1Z.png";
        private string sera1 = "https://imgur.com/pXlrvM7.png";
        private string case1s = "https://imgur.com/o0KIoCM.png";
        private string case2s = "https://imgur.com/iLR76AW.png";
        private string case3s = "https://imgur.com/Wbw850T.png";
        private string case4s = "https://imgur.com/B41YB7l.png";
        private string button = "https://imgur.com/HYj6vSU.png";
        

        public class Inventory
        {
            public bool command;
            public string strcommand;
            public string shortname;
            public int amount;

        }

        public class random
        {
            [JsonProperty("Шанс выпадения")]
            public int chance;
            [JsonProperty("Минимальное количество")]
            public int min;
            [JsonProperty("Максимальное количество")]
            public int max;
        }

        public class chance
        {
            [JsonProperty("Шанс выпадения")]
            public int chances;
            [JsonProperty("Картинка")]
            public string image;
        }

        public class Case
        {
            [JsonProperty("Сколько времени должен отыграть игрок для открытия кейса (в секундах)")]
            public int time = 300;

            [JsonProperty("Использовать выпадение предметов?")]
            public bool items = true;

            [JsonProperty("Использовать выдачу команды?")]
            public bool command = false;

            [JsonProperty("Команды для выполнения (%steamid% заменяется на айди игрока)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, chance> strcommands = new Dictionary<string, chance>
            {
                ["say %steamid%"] = new chance { image = "https://i.imgur.com/DXB7GRi.png", chances = 100 },
                ["example"] = new chance { image = "https://i.imgur.com/sLZm4on.png", chances = 100 },
            };

            [JsonProperty("Предметы которые могут выпасть при открытии", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, random> itemsdrop = new Dictionary<string, random>
            {
                ["sulfur"] = new random { chance = 100, min = 10, max = 50}, 
                ["metal.fragments"] = new random { chance = 50, min = 50, max = 150},
            };
        }

        private PluginConfig cfg;

        public class PluginConfig
        {
            [JsonProperty("Настройки кейсов")]
            public MainSettings settings = new MainSettings();

            public class MainSettings
            {
                [JsonProperty("День кейса, её настройки", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public Dictionary<string, Case> cases = new Dictionary<string, Case>()
                {
                    ["1"] = new Case(),
                    ["2"] = new Case(),
                    ["3"] = new Case(),
                    ["4"] = new Case(),
                    ["5"] = new Case(),
                };
            }
        }

        private void Init()
        {
            cfg = Config.ReadObject<PluginConfig>();
            Config.WriteObject(cfg);
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(new PluginConfig(), true);
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject($"{Title}/Cooldown", time);
            Interface.Oxide.DataFileSystem.WriteObject($"{Title}/Day", day);
            Interface.Oxide.DataFileSystem.WriteObject($"{Title}/Taked", taked);
            Interface.Oxide.DataFileSystem.WriteObject($"{Title}/Inventory", inventory);
        }

        private void LoadData()
        {
            if (Interface.Oxide.DataFileSystem.ExistsDatafile($"{Title}/Cooldown"))
                time = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, int>>($"{Title}/Cooldown");

            if (Interface.Oxide.DataFileSystem.ExistsDatafile($"{Title}/Day"))
                day = Interface.Oxide.DataFileSystem.ReadObject<List<int>>($"{Title}/Day");

            if (Interface.Oxide.DataFileSystem.ExistsDatafile($"{Title}/Taked"))
                taked = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, int>>($"{Title}/Taked");

            if (Interface.Oxide.DataFileSystem.ExistsDatafile($"{Title}/Inventory"))
                inventory = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, List<Inventory>>>($"{Title}/Inventory");
        }

        void OnServerInitialized()
        {
            _ins = this;
            if (!plugins.Exists("ImageLibrary"))
            {
                PrintError("ImageLibrary not found. Install it and reload plugin!");
                return;
            }

            LoadData();
            if (day == null || day.Count < 1) day.Add(1);
            if (GetWipeDay() > 4) day[0] = 1;

            if (!IMGLibrary.HasImage(MainIMG, 0)) IMGLibrary.AddImage(MainIMG, MainIMG, 0);
            if (!IMGLibrary.HasImage(sera1, 0)) IMGLibrary.AddImage(sera1, sera1, 0);
            if (!IMGLibrary.HasImage(case1s, 0)) IMGLibrary.AddImage(case1s, case1s, 0);
            if (!IMGLibrary.HasImage(case2s, 0)) IMGLibrary.AddImage(case2s, case2s, 0);
            if (!IMGLibrary.HasImage(case3s, 0)) IMGLibrary.AddImage(case3s, case3s, 0);
            if (!IMGLibrary.HasImage(case4s, 0)) IMGLibrary.AddImage(case4s, case4s, 0);
            if (!IMGLibrary.HasImage(button, 0)) IMGLibrary.AddImage(button, button, 0);
            if (!IMGLibrary.HasImage(InventoryIMG, 0)) IMGLibrary.AddImage(InventoryIMG, InventoryIMG, 0);
            foreach (var item in cfg.settings.cases.Values) 
            {
                foreach (var cmd in item.strcommands) 
                {
                    if (!string.IsNullOrEmpty(cmd.Value.image) && !IMGLibrary.HasImage(cmd.Key, 0)) IMGLibrary.AddImage(cmd.Value.image, cmd.Key, 0);
                }
                foreach (var cmd in item.itemsdrop) 
                {
                    if (!string.IsNullOrEmpty(cmd.Key) && !IMGLibrary.HasImage(cmd.Key, 0)) IMGLibrary.AddImage("https://rustlabs.com/img/items180/" + cmd.Key + ".png", cmd.Key, 0);
                }
            }


            if (BasePlayer.activePlayerList.Count > 0) foreach (var player in BasePlayer.activePlayerList) OnPlayerConnected(player);
            InvokeHandler.Instance.InvokeRepeating(UpdateTime, 60f, 60f);
            InvokeHandler.Instance.InvokeRepeating(UpdateUI, 1f, 1f);
        }

        void OnServerSave()
        {
            SaveData();
        }

        void Unload()
        {
            InvokeHandler.Instance.CancelInvoke(UpdateTime);
            InvokeHandler.Instance.CancelInvoke(UpdateUI);
            foreach (var player in BasePlayer.activePlayerList) CuiHelper.DestroyUi(player, Layer);
            SaveData();
            _ins = null;
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerConnected(player));
                return;
            }
            if (!time.ContainsKey(player.userID)) time.Add(player.userID, 0);
            if (!inventory.ContainsKey(player.userID)) inventory.Add(player.userID, new List<Inventory>());
        }

        void UpdateUI()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (!time.ContainsKey(player.userID)) time.Add(player.userID, 0);
                time[player.userID]++;

                if (openedui.Contains(player.userID))
                {
                    var container = new CuiElementContainer();
                    if (GetWipeDay() == 1)
                    {
                        CuiHelper.DestroyUi(player, "1");
                        
                        /*container.Add(new CuiElement
                        {
                            Name = "1",
                            Parent = "container",
                            Components =
                            {
                                new CuiImageComponent { Png = GetImage(button), Material = "assets/icons/greyout.mat"},
                                new CuiRectTransformComponent { AnchorMin = "0.09528343 0.2108527", AnchorMax = "0.1955846 0.255814" }
                            }
                        });*/
                        
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0.09528343 0.2108527", AnchorMax = "0.1955846 0.255814" },
                            Button = { Color = "0 0 0 0", Command = !HasCooldown(player, 1) && GetWipeDay() == 1 ? "TakeCase 1" : "" },
                            Text = { Color = HexToRustFormat("#FFFFFFFF"), Text = CanTake(player, 1).ToUpper(), Align = TextAnchor.MiddleCenter, FontSize = 10, Font = "robotocondensed-regular.ttf" }
                        }, "container", "1");
                    }
                    if (GetWipeDay() == 2)
                    {
                        CuiHelper.DestroyUi(player, "2");
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0.3279826 0.2124031", AnchorMax = "0.4282839 0.2573644" },
                            Button = { Color = "0 0 0 0", Command = !HasCooldown(player, 2) && GetWipeDay() == 2 ? "TakeCase 2" : "" },
                            Text = { Color = HexToRustFormat("#FFFFFFFF"), Text = CanTake(player, 2).ToUpper(), Align = TextAnchor.MiddleCenter, FontSize = 10, Font = "robotocondensed-regular.ttf" }
                        }, "container", "2");
                    }
                    if (GetWipeDay() == 3)
                    {
                        CuiHelper.DestroyUi(player, "3");
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0.5757279 0.2093023", AnchorMax = "0.6760302 0.2542633" },
                            Button = { Color = "0 0 0 0", Command = !HasCooldown(player, 3) && GetWipeDay() == 3 ? "TakeCase 3" : "" },
                            Text = { Color = HexToRustFormat("#FFFFFFFF"), Text = CanTake(player, 3).ToUpper(), Align = TextAnchor.MiddleCenter, FontSize = 10, Font = "robotocondensed-regular.ttf" }
                        }, "container", "3");
                    }
                    
                    if (GetWipeDay() == 4)
                    {
                        CuiHelper.DestroyUi(player, "4");
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0.8204627 0.2093022", AnchorMax = "0.9207657 0.2542628" },
                            Button = { Color = "0 0 0 0", Command = !HasCooldown(player, 4) && GetWipeDay() == 4 ? "TakeCase 4" : "" },
                            Text = { Color = HexToRustFormat("#FFFFFFFF"), Text = CanTake(player, 4).ToUpper(), Align = TextAnchor.MiddleCenter, FontSize = 10, Font = "robotocondensed-regular.ttf" }
                        }, "container", "4");
                    }
                    CuiHelper.AddUi(player, container);
                }
            }
        }

        void UpdateTime()
        {
            if (DateTime.UtcNow.AddHours(3).ToString("HH:mm") == "02:00")
            {
                if (day.Count > 0)
                {
                    day[0]++;
                    //Puts("Started new day..");
                    time.Clear();
                    SaveData();
                }
            }
        }

        int GetWipeDay()
        {
            if (day == null) day.Add(1);
            return day[0];
        }

        bool HasCooldown(BasePlayer player, int Day)
        {
            if (!time.ContainsKey(player.userID)) time.Add(player.userID, 0);
            foreach (var i in cfg.settings.cases)
            {
                if (Day.ToString() != i.Key) continue;
                var cooldown = time[player.userID];
                if (cooldown >= i.Value.time) return false;
            }
            return true;
        }

        int GetCooldown(BasePlayer player, int Day)
        {
            if (!time.ContainsKey(player.userID)) time.Add(player.userID, 0);
            int amount = 0;
            foreach (var i in cfg.settings.cases)
            {
                if (Day.ToString() != i.Key) continue;
                var cooldown = time[player.userID];
                amount = i.Value.time - cooldown;
                if (amount < 0) return 0;
            }
            return amount;
        }

        string CanTake(BasePlayer player, int Day)
        {
            string text = "ОТКРЫТЬ";
            if (taked.ContainsKey(player.userID) && taked[player.userID] == Day) return "ПОЛУЧЕНО";
            if (Day != GetWipeDay()) return "НЕДОСТУПНО";
            if (HasCooldown(player, Day) == true) return TimeToString(GetCooldown(player, Day));
            return text;
        }
        
        //private Dictionary<BasePlayer, List<string>> caseuizs = new Dictionary<BasePlayer, List<string>>();
        
        
        [ChatCommand("case")]
        private void CaseCommand(BasePlayer player)
        {
            if (player == null) return;
            DrawMainUI(player);
        }

        [ConsoleCommand("CloseUI1248712389")]
        private void CloseUI(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player == null) return;
            if (openedui.Contains(player.userID)) openedui.Remove(player.userID);
            CuiHelper.DestroyUi(player, Layer);
        }

        private bool ShouldItemDrop(int chance)
        {
            return UnityEngine.Random.Range(0, 100) < chance;
        }

        private int GetRandomAmount(int min, int max)
        {
            return Oxide.Core.Random.Range(min, max);
        }

        private bool HasItemInInventory(Dictionary<ulong, List<Inventory>> inventory, ulong playerId, string shortname)
        {
            if (inventory.ContainsKey(playerId))
            {
                foreach (var item in inventory[playerId])
                {
                    if (item.shortname == shortname)
                        return true;
                }
            }
            return false;
        }

        private void AddItemToInventory(Dictionary<ulong, List<Inventory>> inventory, ulong playerId, string shortname, int amount)
        {
            if (inventory.ContainsKey(playerId))
            {
                foreach (var item in inventory[playerId])
                {
                    if (item.shortname == shortname)
                    {
                        item.amount += amount;
                        return;
                    }
                }
                inventory[playerId].Add(new Inventory { command = false, shortname = shortname, amount = amount });
            }
            else
            {
                inventory.Add(playerId, new List<Inventory> { new Inventory { command = false, shortname = shortname, amount = amount } });
            }
        }


        [ConsoleCommand("inventoryuiopenz")]
        void inventoryui(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player == null) return;
            if (openedui.Contains(player.userID)) openedui.Remove(player.userID);
            CuiHelper.DestroyUi(player, Layer);
            DrawInventoryUI(player);
        }
        
        [ConsoleCommand("TakeCase")]
        private void TakeCase(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player == null) return;
            if (!args.HasArgs(1)) return;

            var day = args.Args[0];
            if (HasCooldown(player, int.Parse(day))) return;
            if (taked.ContainsKey(player.userID) && taked[player.userID] >= int.Parse(day)) return;

            foreach (var capsule in cfg.settings.cases)
            {
                if (capsule.Key != day) continue;

                if (capsule.Value.items)
                {
                    foreach (var item in capsule.Value.itemsdrop)
                    {
                        if (ShouldItemDrop(item.Value.chance))
                        {
                            var amount = GetRandomAmount(item.Value.min, item.Value.max);
                            if (!HasItemInInventory(inventory, player.userID, item.Key))
                            {
                                AddItemToInventory(inventory, player.userID, item.Key, amount);
                                break; // Выходим из цикла, чтобы добавить только один предмет
                            }
                        }
                    }
                }

                if (capsule.Value.command)
                {
                    foreach (var cmd in capsule.Value.strcommands)
                    {
                        if (ShouldItemDrop(cmd.Value.chances))
                        {
                            if (inventory.ContainsKey(player.userID))
                                inventory[player.userID].Add(new Inventory { command = true, strcommand = cmd.Key });
                            else
                                inventory.Add(player.userID, new List<Inventory> { new Inventory { command = true, strcommand = cmd.Key } });
                        }
                    }
                }
            }

            if (taked.ContainsKey(player.userID)) taked[player.userID] = int.Parse(day);
            else taked.Add(player.userID, int.Parse(day));

            var effect = new Effect("assets/prefabs/misc/xmas/presents/effects/unwrap.prefab", player, 0, Vector3.zero, Vector3.forward);
            EffectNetwork.Send(effect, player.net.connection);
        }

        [ConsoleCommand("casepage")]
        private void ChangePage(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player != null && args.HasArgs(1))
            {
                var page = int.Parse(args.Args[0]);
                if (page * 14 <= inventory[player.userID].Count)
                {
                    DrawInventoryUI(player, page);
                }
            }
        }

        [ConsoleCommand("TakeItem")]
        private void TakeItem(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player == null) return;
            if (!args.HasArgs(2)) return;

            var shortname = args.Args[0];
            var page = int.Parse(args.Args[1]);

            foreach (var item in inventory[player.userID])
            {
                if (item.command || item.shortname != shortname) continue;
                var newItem = ItemManager.CreateByName(item.shortname, item.amount);
                if (newItem == null) continue;
                player.GiveItem(newItem);
                //if (!player.inventory.GiveItem(newItem))
                //    newItem.Drop(player.inventory.containerMain.dropPosition, player.inventory.containerMain.dropVelocity, new Quaternion());
                break;
            }

            for (int i = 0; i < inventory[player.userID].Count; i++)
            {
                var key = inventory[player.userID][i];
                if (key.shortname != shortname) continue;
                inventory[player.userID].Remove(inventory[player.userID][i]);
                break;
            }

            DrawInventoryUI(player, page);
        }

        [ConsoleCommand("TakePerm")]
        private void TakePerm(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player == null) return;
            if (!args.HasArgs(2)) return;

            var perm = args.Args[0].Replace("*", " ");
            var page = int.Parse(args.Args[1]);

            foreach (var item in inventory[player.userID])
            {
                if (!item.command || item.strcommand != perm) continue;
                Server.Command(perm.Replace("%steamid%", player.UserIDString));
                break;
            }

            for (int i = 0; i < inventory[player.userID].Count; i++)
            {
                var key = inventory[player.userID][i];
                if (!key.command || key.strcommand != perm) continue;
                inventory[player.userID].Remove(inventory[player.userID][i]);
                break;
            }

            DrawInventoryUI(player, page);
        }

        void DrawMainUI(BasePlayer player)
        {
            if (!openedui.Contains(player.userID)) openedui.Add(player.userID);
            //caseuizs[player] = new List<string>();
            
            CuiHelper.DestroyUi(player, Layer);
            var container = new CuiElementContainer();
            
            
            container.Add(new CuiPanel
            {
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                CursorEnabled = true,
            }, "Overlay", Layer);
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0 0 0 0", Close = Layer },
                Text = { Text = "" }
            }, Layer);

            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = "container",
                Components =
                {
                    new CuiImageComponent { Png = GetImage(MainIMG), Material = "assets/icons/greyout.mat"},
                    new CuiRectTransformComponent { AnchorMin = "0.2406265 0.1981481", AnchorMax = "0.7598959 0.795370" }
                }
            });
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0 0 0 0", Close = Layer },
                Text = { Text = "" }
            }, "container");
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.4242712 0.8139536", AnchorMax = "0.6459364 0.9689922" },
                Text = { Text = $"КЕЙСЫ", Color = HexToRustFormat("#CAD5DF"), Align = TextAnchor.UpperCenter, FontSize = 28, Font = "robotocondensed-bold.ttf" }
            },  "container");
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.3741207 0.7937984", AnchorMax = "0.665997 0.9100775" },
                Text = { Text = $"Здесь вы можете открыть ежедневные бесплатные кейсы", Color = HexToRustFormat("#8E8E8E"), Align = TextAnchor.UpperCenter, FontSize = 13, Font = "robotocondensed-regular.ttf" }
            },  "container");
            
            container.Add(new CuiElement
            {
                Parent = "container",
                Components =
                {
                    new CuiImageComponent { Png = GetImage(sera1), Material = "assets/icons/greyout.mat"},
                    new CuiRectTransformComponent { AnchorMin = "0.402205 0.8620155", AnchorMax = "0.5025063 1.017055" }
                }
            });
            
            container.Add(new CuiElement
            {
                Name = "1",
                Parent = "container",
                Components =
                {
                    new CuiImageComponent { Png = GetImage(case1s), Material = "assets/icons/greyout.mat"},
                    new CuiRectTransformComponent { AnchorMin = "0.03911462 0.1937985", AnchorMax = "0.241723 0.8139534" }
                }
            });
            
            container.Add(new CuiElement
            {
                Parent = "container",
                Components =
                {
                    new CuiImageComponent { Png = GetImage(button), Material = "assets/icons/greyout.mat"},
                    new CuiRectTransformComponent { AnchorMin = "0.4363075 0.02945746", AnchorMax = "0.5596776 0.07751947" }
                }
            });
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.4363075 0.02945746", AnchorMax = "0.5596776 0.07751947" },
                Button = { Color = "0 0 0 0", Command = "inventoryuiopenz" },
                Text = { Text = $"ИНВЕНТАРЬ", Color = HexToRustFormat("#CAD5DF"), Align = TextAnchor.MiddleCenter, FontSize = 15, Font = "robotocondensed-bold.ttf" }
            }, "container");
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09428035 0.7007753", AnchorMax = "0.1945815 0.7534884" },
                Text = { Text = $"ДЕНЬ 1", Color = HexToRustFormat("#CAD5DF"), Align = TextAnchor.UpperCenter, FontSize = 15, Font = "robotocondensed-bold.ttf" }
            },  "container", "1");
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.04814178 0.6217054", AnchorMax = "0.2336989 0.7116279" },
                Text = { Text = $"В первый день вайпа вы можете открыть кейс с довольно полезным лутом для начала вайпа.", Color = HexToRustFormat("#8E8E8E"), Align = TextAnchor.UpperCenter, FontSize = 9, Font = "robotocondensed-regular.ttf" }
            },  "container", "1");
            
            container.Add(new CuiElement
            {
                Name = "1",
                Parent = "container",
                Components =
                {
                    new CuiImageComponent { Png = GetImage(button), Material = "assets/icons/greyout.mat"},
                    new CuiRectTransformComponent { AnchorMin = "0.09528343 0.2108527", AnchorMax = "0.1955846 0.255814" }
                }
            });
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.09528343 0.2108527", AnchorMax = "0.1955846 0.255814" },
                Button = { Color = "0 0 0 0", Command = !HasCooldown(player, 1) && GetWipeDay() == 1 ? "TakeCase 1" : "" },
                Text = { Color = HexToRustFormat("#FFFFFFFF"), Text = CanTake(player, 1).ToUpper(), Align = TextAnchor.MiddleCenter, FontSize = 10, Font = "robotocondensed-regular.ttf" }
            }, "container", "1");




            container.Add(new CuiElement
            {
                Name = "2",
                Parent = "container",
                Components =
                {
                    new CuiImageComponent { Png = GetImage(case2s), Material = "assets/icons/greyout.mat"},
                    new CuiRectTransformComponent { AnchorMin = "0.2748225 0.1968992", AnchorMax = "0.4744217 0.815504" }
                }
            });
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.3269798 0.7023253", AnchorMax = "0.4272808 0.7550379" },
                Text = { Text = $"ДЕНЬ 2", Color = HexToRustFormat("#CAD5DF"), Align = TextAnchor.UpperCenter, FontSize = 15, Font = "robotocondensed-bold.ttf" }
            },  "container", "2");
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.2808405 0.6232556", AnchorMax = "0.4663976 0.7131781" },
                Text = { Text = $"Во второй день вайпа вы можете открыть этот кейс и получить с некоторым шансом привилегию Lightning на 7 дней.", Color = HexToRustFormat("#8E8E8E"), Align = TextAnchor.UpperCenter, FontSize = 9, Font = "robotocondensed-regular.ttf" }
            },  "container", "2");
            
            container.Add(new CuiElement
            {
                Name = "2",
                Parent = "container",
                Components =
                {
                    new CuiImageComponent { Png = GetImage(button), Material = "assets/icons/greyout.mat"},
                    new CuiRectTransformComponent { AnchorMin = "0.3279826 0.2124031", AnchorMax = "0.4282839 0.2573644" }
                }
            });
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.3279826 0.2124031", AnchorMax = "0.4282839 0.2573644" },
                Button = { Color = "0 0 0 0", Command = !HasCooldown(player, 2) && GetWipeDay() == 2 ? "TakeCase 2" : "" },
                Text = { Color = HexToRustFormat("#FFFFFFFF"), Text = CanTake(player, 2).ToUpper(), Align = TextAnchor.MiddleCenter, FontSize = 10, Font = "robotocondensed-regular.ttf" }
            }, "container", "2");
            
            
            
            container.Add(new CuiElement
            {
                Name = "3",
                Parent = "container",
                Components =
                {
                    new CuiImageComponent { Png = GetImage(case3s), Material = "assets/icons/greyout.mat"},
                    new CuiRectTransformComponent { AnchorMin = "0.5185544 0.1922481", AnchorMax = "0.7231687 0.8170543" }
                }
            });
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.5747257 0.6992249", AnchorMax = "0.6750247 0.7519373" },
                Text = { Text = $"ДЕНЬ 3", Color = HexToRustFormat("#CAD5DF"), Align = TextAnchor.UpperCenter, FontSize = 15, Font = "robotocondensed-bold.ttf" }
            },  "container", "3");
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.5285843 0.6201547", AnchorMax = "0.7141411 0.7100775" },
                Text = { Text = $"В третий день вы получаете доступ к открытию этого кейса, в котором вам может выпасть Hurricane на 3 дня или метаболизм на 7 дней.", Color = HexToRustFormat("#8E8E8E"), Align = TextAnchor.UpperCenter, FontSize = 9, Font = "robotocondensed-regular.ttf" }
            },  "container", "3");
            
            container.Add(new CuiElement
            {
                Name = "3",
                Parent = "container",
                Components =
                {
                    new CuiImageComponent { Png = GetImage(button), Material = "assets/icons/greyout.mat"},
                    new CuiRectTransformComponent { AnchorMin = "0.5757279 0.2093023", AnchorMax = "0.6760302 0.2542633" }
                }
            });
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5757279 0.2093023", AnchorMax = "0.6760302 0.2542633" },
                Button = { Color = "0 0 0 0", Command = !HasCooldown(player, 3) && GetWipeDay() == 3 ? "TakeCase 3" : "" },
                Text = { Color = HexToRustFormat("#FFFFFFFF"), Text = CanTake(player, 3).ToUpper(), Align = TextAnchor.MiddleCenter, FontSize = 10, Font = "robotocondensed-regular.ttf" }
            }, "container", "3");
            
            
            
            container.Add(new CuiElement
            {
                Name = "4",
                Parent = "container",
                Components =
                {
                    new CuiImageComponent { Png = GetImage(case4s), Material = "assets/icons/greyout.mat"},
                    new CuiRectTransformComponent { AnchorMin = "0.7652953 0.192248", AnchorMax = "0.9648945 0.8170542" }
                }
            });
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.8194606 0.6992244", AnchorMax = "0.9197595 0.7519375" },
                Text = { Text = $"ДЕНЬ 4", Color = HexToRustFormat("#CAD5DF"), Align = TextAnchor.UpperCenter, FontSize = 15, Font = "robotocondensed-bold.ttf" }
            },  "container", "4");
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.7733191 0.6201547", AnchorMax = "0.9588759 0.7100775" },
                Text = { Text = $"В четвертый день при открытии этого кейса у вас есть шанс выбить Hurricane на 7 дней или карманный переработчик на 7 дней", Color = HexToRustFormat("#8E8E8E"), Align = TextAnchor.UpperCenter, FontSize = 9, Font = "robotocondensed-regular.ttf" }
            },  "container", "4");
            
            container.Add(new CuiElement
            {
                Name = "4",
                Parent = "container",
                Components =
                {
                    new CuiImageComponent { Png = GetImage(button), Material = "assets/icons/greyout.mat"},
                    new CuiRectTransformComponent { AnchorMin = "0.8204627 0.2093022", AnchorMax = "0.9207657 0.2542628" }
                }
            });
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.8204627 0.2093022", AnchorMax = "0.9207657 0.2542628" },
                Button = { Color = "0 0 0 0", Command = !HasCooldown(player, 4) && GetWipeDay() == 4 ? "TakeCase 4" : "" },
                Text = { Color = HexToRustFormat("#FFFFFFFF"), Text = CanTake(player, 4).ToUpper(), Align = TextAnchor.MiddleCenter, FontSize = 10, Font = "robotocondensed-regular.ttf" }
            }, "container", "4");
            
            
            

            CuiHelper.AddUi(player, container);
        }
        
        void DrawInventoryUI(BasePlayer player, int page = 0)
        {
            CuiHelper.DestroyUi(player, Layer);
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                CursorEnabled = true,
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0 0 0 0", Close = Layer },
                Text = { Text = "" }
            }, Layer);

            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = "container",
                Components =
                {
                    new CuiRawImageComponent {Png = GetImage(InventoryIMG) },
                    new CuiRectTransformComponent { AnchorMin = "0.2406265 0.1981481", AnchorMax = "0.7598959 0.795370" }
                }
            });
            
            if (inventory.ContainsKey(player.userID) && inventory[player.userID].Count == 0)
            {
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = $"ВАШ ИНВЕНТАРЬ ПУСТ!", Color = HexToRustFormat("#CAD5DF"), Align = TextAnchor.MiddleCenter, FontSize = 26, Font = "robotocondensed-bold.ttf" }
                }, "container");
            }
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0 0 0 0", Close = Layer },
                Text = { Text = "" }
            }, "container");
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.4322953 0.8899231", AnchorMax = "0.6539608 0.9596905" },
                Text = { Text = $"ИНВЕНТАРЬ", Color = HexToRustFormat("#CAD5DF"), Align = TextAnchor.UpperCenter, FontSize = 26, Font = "robotocondensed-bold.ttf" }
            },  "container");
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.3721144 0.7488377", AnchorMax = "0.680039 0.9038764" },
                Text = { Text = $"Данном инвентаре вы можете забрать приз с кейса", Color = HexToRustFormat("#8E8E8E"), Align = TextAnchor.UpperCenter, FontSize = 13, Font = "robotocondensed-regular.ttf" }
            },  "container");
            
            container.Add(new CuiElement
            {
                Parent = "container",
                Components =
                {
                    new CuiImageComponent { Png = GetImage(sera1), Material = "assets/icons/greyout.mat"},
                    new CuiRectTransformComponent { AnchorMin = "0.3681024 0.8542643", AnchorMax = "0.4684036 0.9953494" }
                }
            });
            

            const double startAnMinX = 0.05315678;
            const double startAnMaxX = 0.1532617;
            const double startAnMinY = 0.5689927;
            const double startAnMaxY = 0.7983856;
            double anMinX = startAnMinX;
            double anMaxX = startAnMaxX;
            double anMinY = startAnMinY;
            double anMaxY = startAnMaxY;

            List<Inventory> dict = inventory[player.userID].Skip(14 * page).Take(14).ToList();
            for (int i = 0; i < dict.Count; i++)
            {
                var value = dict[i];
                if (value == null) continue;

                if ((i != 0) && (i % 7 == 0))
                {
                    anMinX = startAnMinX;
                    anMaxX = startAnMaxX;
                    anMinY -= 0.4013889;
                    anMaxY -= 0.4013889;
                }

                container.Add(new CuiElement
                {
                    Parent = "container",
                    Name = i.ToString(),
                    Components =
                    {
                        new CuiImageComponent {Color = HexToRustFormat("#27141B") },
                        new CuiRectTransformComponent { AnchorMin = $"{anMinX} {anMinY}", AnchorMax = $"{anMaxX} {anMaxY}" }
                    }
                });
                container.Add(new CuiElement
                {
                    Parent = i.ToString(),
                    Components =
                    {
                        new CuiRawImageComponent {Png = value.command ? GetImage(value.strcommand) : GetImage(value.shortname) },
                        new CuiRectTransformComponent {AnchorMin = "0.1302546 0.3784849", AnchorMax = "0.8717052 0.8786259"}
                    }
                });
                if (!value.command)
                {
                    container.Add(new CuiElement
                    {
                        Parent = i.ToString(),
                        Components =
                        {
                            new CuiTextComponent { Color = HexToRustFormat("#949494FF"), Text = "x" + value.amount.ToString(), Align = TextAnchor.LowerRight, FontSize = 10, Font = "RobotoCondensed-bold.ttf" },
                            new CuiRectTransformComponent {AnchorMin = "0.4308421 0.2495073", AnchorMax = "0.8684198 0.4122787"}
                        }
                    });
                }
                
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.1202347 0.06082799", AnchorMax = "0.9017637 0.216277" },
                    Button = { Color = "0 0 0 0", Command = !value.command ? "TakeItem " + value.shortname + " " + page.ToString() : $"TakePerm {value.strcommand.Replace(" ", "*")}" + " " + page.ToString() },
                    Text = { Color = HexToRustFormat("#747474FF"), Text = "ЗАБРАТЬ", Align = TextAnchor.UpperCenter, FontSize = 10, Font = "RobotoCondensed-bold.ttf" }
                }, i.ToString());
                
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Color = "0 0 0 0", Command = !value.command ? "TakeItem " + value.shortname + " " + page.ToString() : $"TakePerm {value.strcommand.Replace(" ", "*")}" + " " + page.ToString() },
                    Text = { Text = "" }
                }, i.ToString());

                anMinX += 0.12812545;
                anMaxX += 0.12812545;
            }

            container.Add(new CuiElement
            {
                Parent = "container",
                Components =
                {
                    new CuiTextComponent { Color = HexToRustFormat("#747474FF"), Text = $"{page + 1}", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "RobotoCondensed-bold.ttf" },
                    new CuiRectTransformComponent {AnchorMin = "0.4601567 0.05277855", AnchorMax = "0.5382817 0.1916674"}
                }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.4476566 0.08472304", AnchorMax = "0.4742191 0.1611119" },
                Button = { Command = $"casepage {page - 1}", Color = "0 0 0 0" },
                Text = { Color = HexToRustFormat("#747474FF"), Text = $"<", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "RobotoCondensed-bold.ttf" }
            }, "container");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5265617 0.08472304", AnchorMax = "0.5531241 0.1611119" },
                Button = { Command = $"casepage {page + 1}", Color = "0 0 0 0" },
                Text = { Color = HexToRustFormat("#747474FF"), Text = $">", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "RobotoCondensed-bold.ttf"  }
            }, "container");

            CuiHelper.AddUi(player, container);
        }

        public string TimeToString(double time)
        {
            TimeSpan elapsedTime = TimeSpan.FromSeconds(time);
            int hours = elapsedTime.Hours;
            int minutes = elapsedTime.Minutes;
            int seconds = elapsedTime.Seconds;
            int days = Mathf.FloorToInt((float)elapsedTime.TotalDays);
            string s = "";
            if (days > 0) s += $"{days} дн.";
            if (hours > 0) s += $"{hours} ч. ";
            if (minutes > 0) s += $"{minutes} мин. ";
            if (seconds >= 0) s += $"{seconds} сек.";
            else s = s.TrimEnd(' ');
            return s;
        }

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex)) hex = "#FFFFFFFF";
            var str = hex.Trim('#');
            if (str.Length == 6) str += "FF";
            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }
            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);
            Color color = new Color32(r, g, b, a);
            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        string GetImage(string name) => (string)ImageLibrary?.Call("GetImage", name);

        public static class IMGLibrary
        {
            public static bool AddImage(string url, string imageName, ulong imageId = 0, Action callback = null) => (bool)_ins.ImageLibrary.Call("AddImage", url, imageName, imageId, callback);
            public static bool AddImageData(string imageName, byte[] array, ulong imageId = 0, Action callback = null) => (bool)_ins.ImageLibrary.Call("AddImageData", imageName, array, imageId, callback);
            public static string GetImageURL(string imageName, ulong imageId = 0) => (string)_ins.ImageLibrary.Call("GetImageURL", imageName, imageId);
            public static string GetImage(string imageName, ulong imageId = 0, bool returnUrl = false) => (string)_ins.ImageLibrary.Call("GetImage", imageName, imageId, returnUrl);
            public static List<ulong> GetImageList(string name) => (List<ulong>)_ins.ImageLibrary.Call("GetImageList", name);
            public static Dictionary<string, object> GetSkinInfo(string name, ulong id) => (Dictionary<string, object>)_ins.ImageLibrary.Call("GetSkinInfo", name, id);
            public static bool HasImage(string imageName, ulong imageId) => (bool)_ins.ImageLibrary.Call("HasImage", imageName, imageId);
            public static bool IsInStorage(uint crc) => (bool)_ins.ImageLibrary.Call("IsInStorage", crc);
            public static bool IsReady() => (bool)_ins.ImageLibrary.Call("IsReady");
            public static void ImportImageList(string title, Dictionary<string, string> imageList, ulong imageId = 0, bool replace = false, Action callback = null) => _ins.ImageLibrary.Call("ImportImageList", title, imageList, imageId, replace, callback);
            public static void ImportItemList(string title, Dictionary<string, Dictionary<ulong, string>> itemList, bool replace = false, Action callback = null) => _ins.ImageLibrary.Call("ImportItemList", title, itemList, replace, callback);
            public static void ImportImageData(string title, Dictionary<string, byte[]> imageList, ulong imageId = 0, bool replace = false, Action callback = null) => _ins.ImageLibrary.Call("ImportImageData", title, imageList, imageId, replace, callback);
            public static void LoadImageList(string title, List<KeyValuePair<string, ulong>> imageList, Action callback = null) => _ins.ImageLibrary.Call("LoadImageList", title, imageList, callback);
            public static void RemoveImage(string imageName, ulong imageId) => _ins?.ImageLibrary?.Call("RemoveImage", imageName, imageId);
        }
    }
}

// --- End of file: Cases.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/DeathMarker.cs ---
// --- Original Local Path: DeathMarker.cs ---

// Plugin formatted by redBDGR's Plugin Formatting Tool
using System;
using System.Collections.Generic;
using UnityEngine;
namespace Oxide.Plugins {[Info("DeathMarker", "redBDGR", "1.0.11")] [Description("Show your death location on your map.")] class DeathMarker : RustPlugin { private const string permissionName = "deathmarker.use"; private bool Changed; private float radiusSize = 0.1f; private float markerAlpha = 1f; private float markerLenght = 300f; private string colour = "yellow"; private float messageDelay = 5f; private bool sendNotificationMessage = true; private bool use3DMarker = true; private bool use3DRadius = false; private bool arrowEnabled = true; private bool ingameTextEnabled = true; private float arrowVerticalOffset = 150f; private float textVerticalOffset = 170f; private float ingameRadiusSize = 5f; private bool ingameRadiusRandomized = false; private float ingameVisualsLength = 60f; private string visualsColour = "red"; private bool useDeathConsoleDebug = false; private class MarkerInfo { public MapMarkerGenericRadius radiusMarker; public VendingMachineMapMarker vendingMarker; } private Dictionary<string, MarkerInfo> playerDic = new Dictionary<string, MarkerInfo>(); private List<MapMarker> mapMarkers = new List<MapMarker>(); private void LoadVariables() { radiusSize = Convert.ToSingle(GetConfig("Settings", "Radius Size", 2f)); markerLenght = Convert.ToSingle(GetConfig("Map Marker", "Marker Show Length", 300f)); colour = Convert.ToString(GetConfig("Map Marker", "Marker Colour1", "yellow")); sendNotificationMessage = Convert.ToBoolean(GetConfig("Settings", "Send Notification On Respawn", true)); messageDelay = Convert.ToSingle(GetConfig("Settings", "Notification Message Delay", 5f)); useDeathConsoleDebug = Convert.ToBoolean(GetConfig("Settings", "Use Console Death Debug", false)); use3DMarker = Convert.ToBoolean(GetConfig("In-Game Visuals", "Use In-Game Visuals", true)); use3DRadius = Convert.ToBoolean(GetConfig("In-Game Visuals", "Use Radius Sphere", true)); ingameRadiusSize = Convert.ToSingle(GetConfig("In-Game Visuals", "Sphere Radius", 5f)); ingameRadiusRandomized = Convert.ToBoolean(GetConfig("In-Game Visuals", "Radius Randomised Offset", false)); ingameVisualsLength = Convert.ToSingle(GetConfig("In-Game Visuals", "Visuals Length", 60f)); arrowEnabled = Convert.ToBoolean(GetConfig("In-Game Visuals", "Arrow enabled", true)); ingameTextEnabled = Convert.ToBoolean(GetConfig("In-Game Visuals", "Text Enabeld", true)); arrowVerticalOffset = Convert.ToSingle(GetConfig("In-Game Visuals", "Arrow Vertical Offset", 150f)); textVerticalOffset = Convert.ToSingle(GetConfig("In-Game Visuals", "Text Vertical Offset", 170f)); if (!Changed) return; SaveConfig(); Changed = false; } protected override void LoadDefaultConfig() { Config.Clear(); LoadVariables(); } private void Init() { LoadVariables(); permission.RegisterPermission(permissionName, this); Unsubscribe(nameof(CanNetworkTo)); lang.RegisterMessages(new Dictionary<string, string> { ["Chat Notification"] = "You can see your last death location on your map", ["Marker Title"] = "You died here", }, this); } private void Unload() { foreach (var entry in playerDic) { entry.Value.radiusMarker?.Kill(); entry.Value.vendingMarker?.Kill(); } } private object CanNetworkTo(BaseNetworkable entity, BasePlayer target) { if (!entity.GetComponent<MapMarker>()) return null; MapMarkerGenericRadius radius = entity.GetComponent<MapMarkerGenericRadius>(); if (radius) { if (!mapMarkers.Contains(radius)) return null; MarkerInfo info; if (!playerDic.TryGetValue(target.UserIDString, out info)) return false; return radius == info.radiusMarker; } VendingMachineMapMarker vending = entity.GetComponent<VendingMachineMapMarker>(); if (vending) { if (vending.server_vendingMachine) return null; if (!mapMarkers.Contains(vending)) return null; MarkerInfo info; if (!playerDic.TryGetValue(target.UserIDString, out info)) return false; return vending == info.vendingMarker; } return null; } private object OnPlayerDie(BasePlayer player, HitInfo info) { if (!permission.UserHasPermission(player.UserIDString, permissionName)) return null; MarkerInfo markerInfo; if (playerDic.TryGetValue(player.UserIDString, out markerInfo)) { markerInfo.radiusMarker?.Kill(); markerInfo.vendingMarker?.Kill(); playerDic.Remove(player.UserIDString); } if (useDeathConsoleDebug) Puts($"Death Debug: {player.displayName} ({player.UserIDString}) died at ({player.transform.position.x}, {player.transform.position.y}, {player.transform.position.z})"); MapMarkerGenericRadius radiusMarker = GameManager.server.CreateEntity("assets/prefabs/tools/map/genericradiusmarker.prefab", player.transform.position).GetComponent<MapMarkerGenericRadius>(); VendingMachineMapMarker vendingMarker = GameManager.server.CreateEntity("assets/prefabs/deployable/vendingmachine/vending_mapmarker.prefab", player.transform.position).GetComponent<VendingMachineMapMarker>(); radiusMarker.radius = radiusSize; radiusMarker.color1 = ConvertColourString(colour); radiusMarker.alpha = markerAlpha; radiusMarker.enabled = true; Subscribe(nameof(CanNetworkTo)); playerDic.Add(player.UserIDString, new MarkerInfo { radiusMarker = radiusMarker, vendingMarker = vendingMarker }); vendingMarker.markerShopName = msg("Marker Title"); mapMarkers.Add(vendingMarker); vendingMarker.Spawn(); vendingMarker.enabled = false; mapMarkers.Add(radiusMarker); radiusMarker.Spawn(); radiusMarker.SendUpdate(); string userID = player.UserIDString; timer.Once(markerLenght, () => { if (radiusMarker != null) { if (mapMarkers.Contains(radiusMarker)) mapMarkers.Remove(radiusMarker); radiusMarker.Kill(); } if (vendingMarker != null) { if (mapMarkers.Contains(vendingMarker)) mapMarkers.Remove(vendingMarker); vendingMarker.Kill(); } if (playerDic.ContainsKey(userID)) playerDic.Remove(userID); if (playerDic.Count == 0) Unsubscribe(nameof(CanNetworkTo)); }); return null; } private void OnPlayerRespawned(BasePlayer player) { if (sendNotificationMessage) if (permission.UserHasPermission(player.UserIDString, permissionName)) timer.Once(messageDelay, () => { if (player) player.ChatMessage(msg("Chat Notification")); }); MarkerInfo info = null; if (!playerDic.TryGetValue(player.UserIDString, out info)) return; if (use3DMarker) { if (player.IsAdmin) { if (arrowEnabled) player.SendConsoleCommand("ddraw.arrow", ingameVisualsLength, ConvertColourString(visualsColour), info.radiusMarker.transform.position + new Vector3(0, arrowVerticalOffset, 0), info.radiusMarker.transform.position + new Vector3(0, 5f, 0), 2f); if (ingameTextEnabled) player.SendConsoleCommand("ddraw.text", ingameVisualsLength, ConvertColourString(visualsColour), info.radiusMarker.transform.position + new Vector3(0, textVerticalOffset, 0), msg("Marker Title")); } else { player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true); player.SendNetworkUpdateImmediate(); if (arrowEnabled) player.SendConsoleCommand("ddraw.arrow", ingameVisualsLength, ConvertColourString(visualsColour), info.radiusMarker.transform.position + new Vector3(0, arrowVerticalOffset, 0), info.radiusMarker.transform.position + new Vector3(0, 5f, 0), 2f); if (ingameTextEnabled) player.SendConsoleCommand("ddraw.text", ingameVisualsLength, ConvertColourString(visualsColour), info.radiusMarker.transform.position + new Vector3(0, textVerticalOffset, 0), msg("Marker Title")); player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false); player.SendNetworkUpdateImmediate(); } } if (use3DRadius) { if (player.IsAdmin) { if (ingameRadiusRandomized) player.SendConsoleCommand("ddraw.sphere", ingameVisualsLength, ConvertColourString(visualsColour), info.radiusMarker.transform.position + new Vector3(UnityEngine.Random.Range(-ingameRadiusSize, ingameRadiusSize), 0, UnityEngine.Random.Range(-ingameRadiusSize, ingameRadiusSize)), ingameRadiusSize); else player.SendConsoleCommand("ddraw.sphere", ingameVisualsLength, ConvertColourString(visualsColour), info.radiusMarker.transform.position, ingameRadiusSize); } else { player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true); player.SendNetworkUpdate(); if (ingameRadiusRandomized) player.SendConsoleCommand("ddraw.sphere", ingameVisualsLength, ConvertColourString(visualsColour), info.radiusMarker.transform.position + new Vector3(UnityEngine.Random.Range(-ingameRadiusSize, ingameRadiusSize), 0, UnityEngine.Random.Range(-ingameRadiusSize, ingameRadiusSize)), ingameRadiusSize); else player.SendConsoleCommand("ddraw.sphere", ingameVisualsLength, ConvertColourString(visualsColour), info.radiusMarker.transform.position, ingameRadiusSize); player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false); player.SendNetworkUpdate(); } } } private static Color ConvertColourString(string colourString) { switch (colourString.ToLower()) { case "red": return Color.red; case "blue": return Color.blue; case "green": return Color.green; case "black": return Color.black; case "clear": return Color.clear; case "cyan": return Color.cyan; case "gray": return Color.gray; case "grey": return Color.grey; case "magenta": return Color.magenta; case "white": return Color.white; case "yellow": return Color.yellow; } return Color.red; } private object GetConfig(string menu, string datavalue, object defaultValue) { var data = Config[menu] as Dictionary<string, object>; if (data == null) { data = new Dictionary<string, object>(); Config[menu] = data; Changed = true; } object value; if (!data.TryGetValue(datavalue, out value)) { value = defaultValue; data[datavalue] = value; Changed = true; } return value; } private string msg(string key, string id = null) => lang.GetMessage(key, this, id); } }
// If you wish to view this code in a formatted state, please contact redBDGR on discord @ redBDGR #0001


// --- End of file: DeathMarker.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/StashBlocker.cs ---
// --- Original Local Path: StashBlocker.cs ---

﻿using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Stash Blocker", "Orange", "1.0.0")]
    [Description("Controls stashes placement")]
    public class StashBlocker : RustPlugin
    {
        #region Oxide Hooks

        private void Init()
        {
            lang.RegisterMessages(EN, this);
        }

        private object CanBuild(Planner planner, Construction prefab, Construction.Target target)
        {
            return CheckBuild(planner, prefab, target);
        }

        #endregion

        #region Configuration

        private static ConfigData config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "1. Block placing stashes (globally)")]
            public bool global;

            [JsonProperty(PropertyName = "2. Radius of allowed distance between stashes and any entities (set to 0 to disable)")]
            public float entities;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                global = false,
                entities = 5f
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region Language

        private Dictionary<string, string> EN = new Dictionary<string, string>
        {
            {"Global", "Stashes placing is blocked!"},
            {"Near Stashes", "You can't place entities near stashes!"},
            {"Near Entities", "You can't place stashes near buildings!"}
        };

        private void message(BasePlayer player, string key, params object[] args)
        {
            var message = string.Format(lang.GetMessage(key, this, player.UserIDString), args);
            player.ChatMessage(message);
        }

        #endregion

        #region Core

        private object CheckBuild(Planner planner, Construction prefab, Construction.Target target)
        {
            var player = planner.GetOwnerPlayer();
            if (player == null)
            {
                return null;
            }

            var name = prefab.fullName;
            var position = target.entity?.transform.position ?? target.position;
            var check = config.entities > 0.001f;
            
            if (IsStash(name))
            {
                if (config.global)
                {
                    message(player, "Global");
                    return false;
                }
                
                if (check && HasBuildingsNearby(position))
                {
                    message(player, "Near Entities");
                    return false;
                }
            }
            
            if (check && HasStashesNearby(position))
            {
                message(player, "Near Stashes");
                return false;
            }

            return null;
        }

        private bool IsStash(string name)
        {
            return name.ToLower().Contains("stash");
        }

        private bool HasStashesNearby(Vector3 position)
        {
            var list = new List<StashContainer>();
            Vis.Entities(position, config.entities, list);
            return list.Count > 0;
        }

        private bool HasBuildingsNearby(Vector3 position)
        {
            var list = new List<BuildingBlock>();
            Vis.Entities(position, 5f, list);
            return list.Count > 0;
        }

        #endregion
    }
}

// --- End of file: StashBlocker.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RadLine.cs ---
// --- Original Local Path: RadLine.cs ---

using System.Text.RegularExpressions;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using System;

namespace Oxide.Plugins
{
    [Info("RAD-Line", "SkinN", "3.0.1", ResourceId = 914)]
    [Description("Enables and disables radiation every X minutes")]

    class RadLine : RustPlugin
    {
        #region Plugin Resources

        // Developer Variables
        private readonly bool Dev = false;

        // Configuration Variables
        private string Prefix;
        private string IconProfile;
        private bool EnableIconProfile;
        private bool BroadcastToConsole;
        private bool EnablePluginPrefix;
        private int EnabledInterval;
        private int DisabledInterval;
        private DateTime LastTimer;

        #endregion

        #region Configuration

        protected override void LoadDefaultConfig()
        {
            /* Hook called when the config for the plugin initializes */

            Puts("Creating new configuration file");

            // Clear configuration for a brand new one
            Config.Clear();

            // Load plugin variables
            LoadVariables();
        }

        private void LoadVariables()
        {
            // Clear configuration if on developer mode
            if (Dev)
                Config.Clear();

            // Load configuration variables
            Prefix = GetConfig<string>("General Settings", "Prefix", "[ <cyan>RAD-LINE<end> ]");
            IconProfile = GetConfig<string>("General Settings", "Icon Profile", "76561198248442828");
            BroadcastToConsole = GetConfig<bool>("General Settings", "Broadcast To Console", true);
            EnablePluginPrefix = GetConfig<bool>("General Settings", "Enable Plugin Prefix", true);
            EnableIconProfile = GetConfig<bool>("General Settings", "Enable Icon Profile", false);
            EnabledInterval = GetConfig<int>("General Settings", "Radiation Enabled Interval (In Minutes)", 30);
            DisabledInterval = GetConfig<int>("General Settings", "Radiation Disabled Interval (In Minutes)", 10);
        }

        private T GetConfig<T>(params object[] args)
        {
            /* Gets a value from the configuration file
               Developer mode forces the default values on every setting on each load */

            var stringArgs = new string[args.Length - 1];
            for (var i = 0; i < args.Length - 1; i++)
                stringArgs[i] = args[i].ToString();

            if (Config.Get(stringArgs) == null || Dev)
                Config.Set(args);

            return (T)Convert.ChangeType(Config.Get(stringArgs), typeof(T));
        }

        private void LoadMessages()
        {
            /* Method to register messages to Lang library from Oxide */

            lang.RegisterMessages(new Dictionary<string, string> {
                { "Enabled Radiation", "Radiation levels are now up for <orange>{interval} minutes<end>." },
                { "Disabled Radiation", "Radiation levels are now down for <orange>{interval} minutes<end>." },
                { "Radiation Is Enabled", "Radiation levels are up for <orange>{remaining} minutes<end>."},
                { "Radiation Is Disabled", "Radiation levels are down for <orange>{remaining} minutes<end>." }
            }, this);
        }

        private string GetMsg(string key, object uid = null)
        {
            /* Method to get a plugin message */

            return lang.GetMessage(key, this, uid == null ? null : uid.ToString());
        }

        #endregion

        #region Messages System

        private void Con(string msg)
        {
            /* Broadcasts a message to the server console */

            if (BroadcastToConsole)
                Puts(SimpleColorFormat(msg, true));
        }

        private void Say(string msg, string profile = "0", bool prefix = true)
        {
            /* Broadcasts a message to chat for all players */

            // Log message to console
            Con(msg);

            // Check whether prefix is enabled
            if (!String.IsNullOrEmpty(Prefix) && EnablePluginPrefix && prefix)
                msg = Prefix + " " + msg;

            // Check whether to use a profile
            if (profile == "0" && EnableIconProfile)
                profile = IconProfile;

            rust.BroadcastChat(SimpleColorFormat("<silver>" + msg + "<end>"), null, profile);
        }

        private void Tell(BasePlayer player, string msg, string profile = "0", bool prefix = true)
        {
            /* Broadcasts a message to chat to a player */

            // Check whether prefix is enabled
            if (!String.IsNullOrEmpty(Prefix) && EnablePluginPrefix && prefix)
                msg = Prefix + " " + msg;

            // Check whether to use a profile
            if (profile == "0" && EnableIconProfile)
                profile = IconProfile;

            rust.SendChatMessage(player, SimpleColorFormat("<silver>" + msg + "<end>"), null, profile);
        }

        public string SimpleColorFormat(string text, bool removeTags = false)
        {
            /*  Simple Color Format ( v3.0 )
                Formats simple color tags to HTML */

            // All patterns
            Regex end = new Regex(@"\<(end?)\>"); // End tags
            Regex hex = new Regex(@"\<(#\w+?)\>"); // Hex codes
            Regex names = new Regex(@"\<(\w+?)\>"); // Names

            if (removeTags)
            {
                // Remove tags
                text = end.Replace(text, "");
                text = names.Replace(text, "");
                text = hex.Replace(text, "");
            }
            else
            {
                // Replace tags
                text = end.Replace(text, "</color>");
                text = names.Replace(text, "<color=$1>");
                text = hex.Replace(text, "<color=$1>");
            }

            return text;
        }

        #endregion

        #region Plugin Hooks / Methods

        void Init()
        {
            // Load plugin variables
            LoadVariables();
            // Load plugin messages
            LoadMessages();

            // Start loop
            Loop(true);
        }
        
        private void Loop(bool force = false)
        {
            // Get current time
            LastTimer = DateTime.Now;

            if (!ConVar.Server.radiation || force)
            {
                // Enable Radiation
                ConVar.Server.radiation = true;

                Say(GetMsg("Enabled Radiation").Replace("{interval}", EnabledInterval.ToString()));

                // Run timer
                timer.Once(EnabledInterval * 60, () => Loop());
            }
            else
            {
                // Disable Radiation
                ConVar.Server.radiation = false;

                Say(GetMsg("Disabled Radiation").Replace("{interval}", DisabledInterval.ToString()));

                // Run timer
                timer.Once(DisabledInterval * 60, () => Loop());
            }
        }

        #endregion

        #region Plugin Commands

        [ChatCommand("rad")]
        void Rad_Command(BasePlayer player, string command, string[] args)
        {
            /* Rad Commands
               Tells the player the radiation current state, and the state time remaining */
            
            // Get the future time
            DateTime Future;
            TimeSpan subtract;
            string msg;

            // Check the radiation state
            if (ConVar.Server.radiation)
            {
                // Add minutes of the current state
                Future = LastTimer.AddMinutes(EnabledInterval);
                // Substract the future time with the last timer
                subtract = Future - DateTime.Now;
                // Get the cuttent state message name
                msg = "Radiation Is Enabled";
            }
            else
            {
                // Add minutes of the current state
                Future = LastTimer.AddMinutes(DisabledInterval);
                // Substract the future time with the last timer
                subtract = Future - DateTime.Now;
                // Get the cuttent state message name
                msg = "Radiation Is Disabled";
            }

            // Add pads to both minutes and seconds and format for the message
            string sec = subtract.Seconds.ToString();
            string min = subtract.Minutes.ToString();
            string rem = min.PadLeft(2, '0') + ":" + sec.PadLeft(2, '0');

            Tell(player, GetMsg(msg).Replace("{remaining}", rem));
        }

        [ChatCommand("radline")]
        void Plugin_Command(BasePlayer player, string command, string[] args)
        {
            /* Plugin Command
               The plugin command is to inform what plugin is and it's version */

            Tell(player, "<orange><size=18>RAD-Line</size><end> <grey>v" + this.Version + "<end>", "76561198248442828", false);
            Tell(player, this.Description, prefix: false);
            Tell(player, "Powered by <orange>Oxide 2<end> and developed by <#9810FF>SkinN<end>", "76561197999302614", false);
        }

        #endregion
    }
}

// --- End of file: RadLine.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Pets.cs ---
// --- Original Local Path: Pets.cs ---

// Reference: RustBuild
// Reference: Behave.Unity.Runtime

using System.Collections.Generic;
using System;
using System.Reflection;

using Oxide.Core;

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Pets", "Bombardir", "0.5.5", ResourceId = 851)]
    class Pets : RustPlugin
    {
        static Pets PluginInstance;
        static BUTTON MainButton;
        static BUTTON SecondButton;
        static Dictionary<ulong, PetInfo> SaveNpcList;
        public enum Act { Move, Attack, Eat, Follow, Sleep, None }

        #region NPC Controller Class

        public class NpcControl : MonoBehaviour
        {
            private readonly FieldInfo serverinput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Instance | BindingFlags.NonPublic));
            private float ButtonReload = 0.2f;
            private float DrawReload = 0.05f;
            internal static float LootDistance = 1f;
            internal static float ReloadControl = 60f;
            internal static float MaxControlDistance = 10f;

            internal bool DrawEnabled;
            InputState input;
            float NextTimeToPress;
            float NextTimeToControl;
            float NextTimeToDraw;

            public NpcAI npc;
            public BasePlayer owner;

            void Awake()
            {
                owner = GetComponent<BasePlayer>();
                input = serverinput.GetValue(owner) as InputState;
                enabled = false;
                NextTimeToPress = 0f;
                NextTimeToControl = 0f;
                NextTimeToDraw = 0f;
                DrawEnabled = GlobalDraw;
            }

            void OnAttacked(HitInfo info)
            {
                if (npc && info.Initiator && npc.action != Act.Attack)
                    npc.Attack(info.Initiator.GetComponent<BaseCombatEntity>());
            }

            void FixedUpdate()
            {
                var time = Time.realtimeSinceStartup;
                if (input.WasJustPressed(MainButton) && NextTimeToPress < time)
                {
                    NextTimeToPress = time + ButtonReload;
                    UpdateAction();
                }
                if (DrawEnabled && npc != null && npc.action < Act.Follow && NextTimeToDraw < time)
                {
                    NextTimeToDraw = time + DrawReload;
                    UpdateDraw();
                }
            }

            void UpdateDraw()
            {
                var drawpos = (npc.action == Act.Move ? npc.targetpoint : (npc.targetentity == null ? Vector3.zero : transform.position));
                if (drawpos != Vector3.zero)
                    owner.SendConsoleCommand("ddraw.arrow", DrawReload + 0.02f, npc.action == Act.Move ? Color.cyan : npc.action == Act.Attack ? Color.red : Color.yellow, drawpos + new Vector3(0, 5f, 0), drawpos, 1.5f);
            }

            void UpdateAction()
            {
                if (npc != null && input.IsDown(SecondButton))
                {
                    ChangeFollowAction();
                    return;
                }

                RaycastHit hit;
                if (!Physics.SphereCast(owner.eyes.position, 0.5f, Quaternion.Euler(input.current.aimAngles) * Vector3.forward, out hit) || hit.transform == transform)
                    return;

                if (npc == null)
                {
                    BaseNPC npcPet = hit.transform.GetComponent<BaseNPC>();
                    if (npcPet == null)
                        return;

                    if (hit.distance >= MaxControlDistance)
                    {
                        owner.ChatMessage(CloserMsg);
                        return;
                    }

                    TryGetNewPet(npcPet);
                    return;
                }

                BaseCombatEntity targetentity = hit.transform.GetComponent<BaseCombatEntity>();
                if (targetentity == null)
                {
                    npc.targetpoint = hit.point;
                    npc.action = Act.Move;
                    return;
                }

                if (targetentity == npc.Base)
                {
                    if (hit.distance <= LootDistance)
                        OpenPetInventory();
                }
                else if (targetentity is BaseCorpse)
                {
                    owner.ChatMessage(EatMsg);
                    npc.Attack(targetentity, Act.Eat);
                }
                else
                {
                    owner.ChatMessage(AttackMsg);
                    npc.Attack(targetentity);
                }
            }

            void OpenPetInventory()
            {
                var loot = owner.inventory.loot;
                loot.StartLootingEntity(npc.Base, true);
                loot.AddContainer(npc.inventory);
                loot.SendImmediate();
                owner.ClientRPCPlayer(owner.net.connection, owner, "RPC_OpenLootPanel", "smallwoodbox");
                owner.ChatMessage(OpenInvMsg);
            }

            void ChangeFollowAction()
            {
                if (npc.action == Act.Follow)
                {
                    owner.ChatMessage(UnFollowMsg);
                    npc.action = Act.None;
                }
                else
                {
                    owner.ChatMessage(FollowMsg);
                    npc.Attack(owner.GetComponent<BaseCombatEntity>(), Act.Follow);
                }
            }

            void TryGetNewPet(BaseNPC npcPet)
            {
                var OwnedNpc = npcPet.GetComponent<NpcAI>();
                if (OwnedNpc != null && OwnedNpc.owner != this)
                {
                    owner.ChatMessage(NoOwn);
                    return;
                }

                if (NextTimeToControl >= Time.realtimeSinceStartup)
                {
                    owner.ChatMessage(ReloadMsg);
                    return;
                }

                if (UsePermission && !PluginInstance.HasPermission(owner, "can" + npcPet.mdlPrefab.Get().name.Replace("_skin", "")))
                {
                    owner.ChatMessage(NoPermPetMsg);
                    return;
                }

                NextTimeToControl = Time.realtimeSinceStartup + ReloadControl;

                npc = npcPet.gameObject.AddComponent<NpcAI>();
                npc.owner = this;

                owner.ChatMessage(NewPetMsg);
            }
        }

        #endregion
        #region NPC AI Class

        public class NpcAI : MonoBehaviour
        {
            private readonly MethodInfo SetDeltaTimeMethod = typeof(NPCAI).GetProperty("deltaTime", (BindingFlags.Public | BindingFlags.Instance)).GetSetMethod(true);
            internal static float IgnoreTargetDistance = 70f;
            internal static float HealthModificator = 1.5f;
            internal static float AttackModificator = 2f;
            internal static float SpeedModificator = 1f;

            private float PointMoveDistance = 1f;
            private float TargetMoveDistance = 3f;

            float lastTick;
            float hungerLose;
            float thristyLose;
            float sleepLose;
            double attackrange;

            internal Act action;
            internal Vector3 targetpoint;
            internal BaseCombatEntity targetentity;

            public NpcControl owner;
            public ItemContainer inventory;
            public BaseNPC Base;
            public NPCAI RustAI;
            public NPCMetabolism RustMetabolism;

            void Awake()
            {
               RustAI = GetComponent<NPCAI>();
               RustAI.ServerDestroy();
               RustMetabolism = GetComponent<NPCMetabolism>();
               Base = GetComponent<BaseNPC>();

               lastTick = Time.time;
               targetpoint = Vector3.zero;
               action = Act.None;

               hungerLose = RustMetabolism.calories.max*2 / 12000;
               thristyLose = RustMetabolism.hydration.max*3 / 12000;
               sleepLose = RustMetabolism.sleep.max / 12000;

               inventory = new ItemContainer();
               inventory.ServerInitialize(null, 6);

               Base.enableSaving = false;
               BaseEntity.saveList.Remove(Base);
               Base.InitializeHealth(Base.health * HealthModificator, Base.MaxHealth() * HealthModificator);
               Base.locomotion.gallopSpeed *= SpeedModificator;
               Base.locomotion.trotSpeed *= SpeedModificator;
               Base.locomotion.acceleration *= SpeedModificator;
            }

            void OnDestroy()
            {
                DropUtil.DropItems(inventory, transform.position);
                SaveNpcList.Remove(owner.owner.userID);
                RustAI.ServerInit();

                if (Base.health <= 0)
                    return;

                Base.enableSaving = true;
                BaseEntity.saveList.Add(Base);

                Base.InitializeHealth(Base.health / HealthModificator, Base.MaxHealth() / HealthModificator);
                Base.locomotion.gallopSpeed /= SpeedModificator;
                Base.locomotion.trotSpeed /= SpeedModificator;
                Base.locomotion.acceleration /= SpeedModificator;
            }

            internal void OnAttacked(HitInfo info)
            {
                if (info.Initiator && info.Initiator != owner.owner && action != Act.Attack)
                    Attack(info.Initiator.GetComponent<BaseCombatEntity>());
            }

            void FixedUpdate()
            {
                SetDeltaTimeMethod.Invoke( RustAI, new object[] { Time.time - lastTick });
                if (RustAI.deltaTime < ConVar.Server.TickDelta()) return;
                lastTick = Time.time;
                if (Base.IsStunned()) return;
                Base.Tick();

                if (action != Act.Sleep)
                {
                    RustMetabolism.sleep.MoveTowards(0.0f, RustAI.deltaTime * sleepLose);
                    RustMetabolism.hydration.MoveTowards(0.0f, RustAI.deltaTime * thristyLose);
                    RustMetabolism.calories.MoveTowards(0.0f, RustAI.deltaTime * hungerLose);
                }

                if (action == Act.None)
                    return;

                if (action == Act.Move)
                    if (Vector3.Distance(transform.position, targetpoint) < PointMoveDistance)
                        action = Act.None;
                    else
                        Move(targetpoint);
                else if (action == Act.Sleep)
                    Sleep();
                else if (targetentity == null)
                {
                    action = Act.None;
                    Base.state = BaseNPC.State.Normal;
                }
                else
                {
                    var distance = Vector3.Distance(transform.position, targetentity.transform.position);
                    if (distance >= IgnoreTargetDistance)
                    {
                        action = Act.None;
                        return;
                    }

                    if (action != Act.Follow && distance <= attackrange)
                    {
                        var normalized = (targetentity.transform.position - transform.position).XZ3D().normalized;
                        if (action == Act.Eat)
                        {
                            if (Base.diet.Eat(targetentity))
                            {
                                Base.Heal(Base.MaxHealth() * 0.01f);
                                RustMetabolism.calories.Add(RustMetabolism.calories.max * 0.03f);
                                RustMetabolism.hydration.Add(RustMetabolism.hydration.max * 0.03f);
                            }
                        }
                        else if (Base.attack.Hit(targetentity, AttackModificator, false))
                            transform.rotation = Quaternion.LookRotation(normalized);
                        Base.steering.Face(normalized);
                    }
                    else if (action != Act.Follow || distance > TargetMoveDistance && distance > attackrange)
                        Move(targetentity.transform.position);
                }
            }

            void Sleep()
            {
                Base.state = BaseNPC.State.Sleeping;
                Base.sleep.Recover(2f);
                RustMetabolism.stamina.Run(4f);
                Base.StartCooldown(2f, true);
            }

            void Move(Vector3 point)
            {
                Base.state = BaseNPC.State.Normal;
                RustAI.sense.Think();
                Base.steering.Move((point - transform.position).XZ3D().normalized, point, (int) BLRust.ContextType.Gallop);
            }

            internal void Attack(BaseCombatEntity ent, Act act = Act.Attack)
            {
                targetentity = ent;
                action = act;
                attackrange = Math.Pow(Base._collider.bounds.XZ3D().extents.Max() + Base.attack.range + ent._collider.bounds.XZ3D().extents.Max(), 2);
            }
        }
        #endregion
        #region PetInfo Object to Save
        public class PetInfo
        {
            public uint prefabID;
            public float x, y, z;
            public byte[] inventory;
            internal bool NeedToSpawn;

            public PetInfo()
            {
                NeedToSpawn = true;
            }

            public PetInfo(NpcAI pet)
            {
                x = pet.transform.position.x;
                y = pet.transform.position.y;
                z = pet.transform.position.z;
                prefabID = pet.Base.prefabID;
                inventory = pet.inventory.Save().ToProtoBytes();
                NeedToSpawn = false;
            }
        }
        #endregion

        #region Config & Initialisation

        static bool UsePermission = true;
        static bool GlobalDraw = true;
        static string CfgButton = "USE";
        static string CfgSecButton = "RELOAD";
        static string OpenInvMsg = "Now open your inventory if you want loot pet!";
        static string ReloadMsg = "You can not tame so often! Wait!";
        static string NewPetMsg = "Now you have a new pet!";
        static string CloserMsg = "You need to get closer!";
        static string NoPermPetMsg = "You don't have permission to take this NPC!";
        static string FollowMsg = "Follow command!";
        static string UnFollowMsg = "UnFollow command!";
        static string SleepMsg = "Sleep command!";
        static string AttackMsg = "Attack!";
        static string NoPermMsg = "No Permission!";
        static string ActivatedMsg = "NPC Mode activated!";
        static string DeactivatedMsg = "NPC Mode deactivated!";
        static string NotNpc = "You don't have a pet!";
        static string NpcFree = "Now your per is free!";
        static string NoOwn = "This Npc is already tamed by other player!";
        static string EatMsg = "Time to eat!";
        static string DrawEn = "Draw enabled!";
        static string DrawDis = "Draw disabled!";
        static string DrawSysDis = "Draw system was disabled by administrator!";
        static string InfoMsg = "<color=red>Health: {health}%</color>, <color=orange>Hunger: {hunger}%</color>, <color=cyan>Thirst: {thirst}%</color>, <color=teal>Sleepiness: {sleep}%</color>, <color=lightblue>Stamina: {stamina}%</color>";

        protected override void LoadDefaultConfig() { }

        void Init()
        {
            CheckCfg("Use permissions", ref UsePermission);
            CheckCfg("Enable draw system", ref GlobalDraw);
            CheckCfg("Main button to controll pet", ref CfgButton);
            CheckCfg("Second button to use follow|unfollow", ref CfgSecButton);
            CheckCfg("Reload time to take new Npc", ref NpcControl.ReloadControl);
            CheckCfg("Max distance to take Npc", ref NpcControl.MaxControlDistance);
            CheckCfg("Distance to loot Npc", ref NpcControl.LootDistance);
            CheckCfg("Distance when target will be ignored by NPC", ref NpcAI.IgnoreTargetDistance);
            CheckCfg("Pet's Health Modificator", ref NpcAI.HealthModificator);
            CheckCfg("Pet's Attack Modificator", ref NpcAI.AttackModificator);
            CheckCfg("Pet's Speed Modificator", ref NpcAI.SpeedModificator);
            CheckCfg("New pet msg", ref NewPetMsg);
            CheckCfg("Closer msg", ref CloserMsg);
            CheckCfg("No take perm msg", ref NoPermPetMsg);
            CheckCfg("Follow msg", ref FollowMsg);
            CheckCfg("UnFollow msg", ref UnFollowMsg);
            CheckCfg("Sleep msg", ref SleepMsg);
            CheckCfg("Attack msg", ref AttackMsg);
            CheckCfg("No command perm msg", ref NoPermMsg);
            CheckCfg("Activated msg", ref ActivatedMsg);
            CheckCfg("Deactivated msg", ref DeactivatedMsg);
            CheckCfg("Reload msg", ref ReloadMsg);
            CheckCfg("No pet msg", ref NotNpc);
            CheckCfg("Free pet msg", ref NpcFree);
            CheckCfg("Already tamed msg", ref NoOwn);
            CheckCfg("Eat msg", ref EatMsg);
            CheckCfg("Draw enabled msg", ref DrawEn);
            CheckCfg("Draw disabled msg", ref DrawDis);
            CheckCfg("Draw system disabled msg", ref DrawSysDis);
            CheckCfg("Info msg", ref InfoMsg);
            CheckCfg("Open Inventory msg", ref OpenInvMsg);
            SaveConfig();

            InfoMsg= InfoMsg
                .Replace("{health}", "{0}")
                .Replace("{hunger}", "{1}")
                .Replace("{thirst}", "{2}")
                .Replace("{sleep}", "{3}")
                .Replace("{stamina}", "{4}");

            MainButton = ConvertStringToButton(CfgButton);
            SecondButton = ConvertStringToButton(CfgSecButton);
            PluginInstance = this;

            if (UsePermission)
            {
                permission.RegisterPermission("cannpc", this);
                permission.RegisterPermission("canstag", this);
                permission.RegisterPermission("canbear", this);
                permission.RegisterPermission("canwolf", this);
                permission.RegisterPermission("canchicken", this);
                permission.RegisterPermission("canboar", this);
                permission.RegisterPermission("canhorse", this);
            }

            try { SaveNpcList = Interface.GetMod().DataFileSystem.ReadObject<Dictionary<ulong, PetInfo>>("Pets"); } catch { }
            if (SaveNpcList == null) SaveNpcList = new Dictionary<ulong, PetInfo>();
        }

        #endregion

        #region Unload Hook (destroy all plugin's objects)

        void Unload()
        {
            OnServerSave();
            DestroyAll<NpcControl>();
            DestroyAll<NpcAI>();
            PluginInstance = null;
        }

        #endregion

        #region Hook OnAttacked for NpcAI

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity is BaseNPC)
                entity.GetComponent<NpcAI>()?.OnAttacked(hitInfo);
        }

        #endregion

        #region Hook OnPlayerInit (load player's pet)

        void OnPlayerInit(BasePlayer player)
        {
            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.Once(2, () => OnPlayerInit(player));
                return;
            }
            PetInfo info;
            if (!SaveNpcList.TryGetValue(player.userID, out info) || !info.NeedToSpawn) return;
            Puts("Loading pet...");
            var pet = GameManager.server.CreateEntity(StringPool.Get(info.prefabID), new Vector3(info.x, info.y, info.z));
            if (pet == null) return;
            var comp = player.gameObject.AddComponent<NpcControl>();
            pet.Spawn();
            comp.npc = pet.gameObject.AddComponent<NpcAI>();
            comp.npc.owner = comp;
            comp.npc.inventory.Load(ProtoBuf.ItemContainer.Deserialize(info.inventory));
            info.NeedToSpawn = false;
        }

        #endregion

        #region Hook OnServerSave (save all pets)

        void OnServerSave()
        {
            var pets = UnityEngine.Object.FindObjectsOfType<NpcAI>();
            if (pets == null) return;
            foreach (var pet in pets)
                SaveNpcList[pet.owner.owner.userID] = new PetInfo(pet);
            Interface.Oxide.DataFileSystem.WriteObject("Pets", SaveNpcList);
        }

        #endregion

        #region PET Command (activate/deactivate Npc mode)

        [ChatCommand("pet")]
        void pet(BasePlayer player, string command, string[] args)
        {
            var comp = player.GetComponent<NpcControl>() ?? player.gameObject.AddComponent<NpcControl>();
            if (args.Length == 0)
            {
                player.ChatMessage(comp.enabled ? DeactivatedMsg : ActivatedMsg);
                comp.enabled = !comp.enabled;
                return;
            }

            if (args[0] == "draw")
            {
                if (GlobalDraw)
                    if (comp.DrawEnabled)
                    {
                        comp.DrawEnabled = false;
                        player.ChatMessage(DrawDis);
                    }
                    else
                    {
                        comp.DrawEnabled = true;
                        player.ChatMessage(DrawEn);
                    }
                else
                    player.ChatMessage(DrawSysDis);
                return;
            }

            if (comp.npc)
            {
                switch (args[0])
                {
                    case "free":
                        UnityEngine.Object.Destroy(comp.npc);
                        player.ChatMessage(NpcFree);
                        break;
                    case "sleep":
                        player.ChatMessage(SleepMsg);
                        comp.npc.action = Act.Sleep;
                        break;
                    case "info":
                        var meta = comp.npc.RustMetabolism;
                        player.ChatMessage(string.Format(InfoMsg,
                            Math.Round(comp.npc.Base.health*100/comp.npc.Base.MaxHealth()),
                            Math.Round(meta.hydration.value*100/meta.hydration.max),
                            Math.Round(meta.calories.value*100/meta.calories.max),
                            Math.Round(meta.sleep.value*100/meta.sleep.max),
                            Math.Round(meta.stamina.value*100/meta.stamina.max)));
                        break;
                }
            }
            else
                player.ChatMessage(NotNpc);
        }

        #endregion

        #region Some other plugin methods

        bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);

        static void DestroyAll<T>()
        {
            var objects = UnityEngine.Object.FindObjectsOfType(typeof(T));
            if (objects == null) return;
            foreach (var gameObj in objects)
                UnityEngine.Object.Destroy(gameObj);
        }

        void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] == null)
                Config[Key] = var;
            else
                try { var = (T) Convert.ChangeType(Config[Key], typeof(T)); }
                catch { Config[Key] = var; }
        }

        static BUTTON ConvertStringToButton(string button)
        {
            try
            {
                return (BUTTON) Enum.Parse(typeof (BUTTON), button);
            }
            catch (Exception)
            {
                return BUTTON.USE;
            }
        }

        #endregion
    }
}


// --- End of file: Pets.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Skyfall.cs ---
// --- Original Local Path: Skyfall.cs ---

using System;
using UnityEngine;
using Rust;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using GameTips;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Skyfall", "Colon Blow", "1.0.11")]
    class Skyfall : RustPlugin
    {

        // added option to not allow players to jump out of parachute to free fall
        // added config option for map offset when finding jump point

        #region Loadup

        [PluginReference]
        Plugin Clans;

        static Skyfall _instance;
        BaseEntity skyfallPlane;
        static LayerMask layerMask;
        static List<ulong> skyfallplayerlist = new List<ulong>();
        static List<ulong> isParachuting = new List<ulong>();
        static List<ulong> cooldownlist = new List<ulong>();


        void Loaded()
        {
            _instance = this;
            LoadVariables();
            LoadMessages();
            permission.RegisterPermission("skyfall.use", this);
            permission.RegisterPermission("skyfall.localrespawn", this);
            permission.RegisterPermission("skyfall.admin", this);
            layerMask = (1 << 29);
            layerMask |= (1 << 18);
            layerMask = ~layerMask;
        }

        #endregion

        #region Configuration

        private bool enableLocalRespawn = false;
        private static float localRespawnDistance = 300;

        private static float parchuteFwdSpeed = 15f;
        private static float parachuteDownSpeed = 15f;

        private float ChaosDropCountdown = 10f;

        private static float FlightDeck = 1000f;
        private static float GlobalMapOffset = 500f;

        private bool UseCooldown = true;
        static float SkyFallCoolDown = 600f;

        private bool AllowFreeFall = false;

        private static bool ForceDismountFromPlane = true;
        private static float SkyFallPlaneDespawn = 100f;

        private bool DoSkyfallOnFirstTime = true;

        private static float ForceJumpTime = 60f;

        private static bool EnableRespawnButton = true;
        private static bool UseRandomRespawn = true;

        private static ulong wallskinid = 1320948157;

        private bool Changed;

        void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        void LoadDefaultConfig()
        {
            Puts("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }

        void LoadConfigVariables()
        {
            CheckCfg("Global - Map size Offset when finding global drop position (higher number means closer to center of map, less chance over water) ", ref GlobalMapOffset);

            CheckCfgUlong("Logo - Skin ID for Back wall Skyfall plane : ", ref wallskinid);
            CheckCfg("Cooldown - Use Skyfall pack cooldown ? ", ref UseCooldown);

            CheckCfg("Parachute : Allow players to open there own Parachutes and allow freefalling (if false, chutes auto open and players cannot remove them till they land)? ", ref AllowFreeFall);

            CheckCfgFloat("Chaos Drop - Countdown time from this, (will annouce start, 75%, 50% and 25% time left) ", ref ChaosDropCountdown);

            CheckCfg("Plane - Enable force dismount of players after a certain time ? ", ref ForceDismountFromPlane);
            CheckCfgFloat("Plane - Players will be force dismounted after this many seconds while seated in Skyfall plane (if enabled) ", ref ForceJumpTime);

            CheckCfg("Respawn - Enable Button on respawn screen.(Will do random TP in air with Chute attached) ? ", ref EnableRespawnButton);
            CheckCfg("Respawn - Use Random Respawn location when pressing Skyfall respawn button ? ", ref UseRandomRespawn);
            CheckCfg("Respawn - Local Skyfall Respawn - Enable Skyfall respawn to only drop you within a local radius of corpse ?", ref enableLocalRespawn);
            CheckCfg("Respawn - Local Skyfall Respawn - Max Distance from corpse ", ref localRespawnDistance);

            CheckCfgFloat("Plane - Skyfall plane will despawn if no players are on board after this long : ", ref SkyFallPlaneDespawn);
            CheckCfgFloat("Parachute - Downward speed when using parachute : ", ref parachuteDownSpeed);
            CheckCfgFloat("Parachute - Forward speed when using parachute and forward button : ", ref parchuteFwdSpeed);
            CheckCfgFloat("Flightdeck - Altitude at which Skyfall Plane flys at : ", ref FlightDeck);
            CheckCfgFloat("Cooldown - After using a Skyfall pack, time player must wait to use another : ", ref SkyFallCoolDown);
        }

        void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        void CheckCfgFloat(string Key, ref float var)
        {

            if (Config[Key] != null)
                var = System.Convert.ToSingle(Config[Key]);
            else
                Config[Key] = var;
        }

        void CheckCfgUlong(string Key, ref ulong var)
        {

            if (Config[Key] != null)
                var = Convert.ToUInt64(Config[Key]);
            else
                Config[Key] = var;
        }

        #endregion

        #region Localization

        private void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["noperms"] = "You don't have permission to use this command.",
                ["readytojump"] = "You are ready to jump at any time.",
                ["notjumping"] = "You are not able to use that right now.",
                ["alreadyusedchute"] = "You have already used your chute for this jump... sorry...",
                ["undercooldown"] = "You must wait, you are under a cooldown",
                ["nomorecooldown"] = "Your Skyfall cooldown as been removed.",
                ["skyfallfull"] = "Skyfall is FULL, please wait and try again.",
                ["openchute"] = "Press your 'RELOAD' Key to open your chute when your ready !!!!"
            }, this);
        }

        #endregion

        #region Commands

        [ChatCommand("skyfall")]
        void chatSkyfall(BasePlayer player, string command, string[] args)
        {
            if (permission.UserHasPermission(player.UserIDString, "skyfall.use"))
            {
                if (player.isMounted) { SendReply(player, "You are already Mounted"); return; }
                if (cooldownlist.Contains(player.userID)) { PrintToChat(player, lang.GetMessage("undercooldown", this, player.UserIDString)); return; }
                if (UseCooldown) { CooldownAddPlayerID(player); }
                AddPlayerID(player);
                var hascontroller = player.GetComponent<PlayerJumpController>();
                if (!hascontroller) player.gameObject.AddComponent<PlayerJumpController>();
                ActivateJumpPlane(player);
            }
            else
                PrintToChat(player, lang.GetMessage("noperms", this, player.UserIDString));
        }

        [ConsoleCommand("givechute")]
        void cmdConsoleGiveChute(ConsoleSystem.Arg arg)
        {
            var player = arg.Player() ?? null;
            if (player != null)
            {
                if (permission.UserHasPermission(player.UserIDString, "skyfall.use"))
                    GiveChutePack(player);
                else
                    PrintToChat(player, lang.GetMessage("noperms", this, player.UserIDString));
                return;
            }
            if (arg.Args.Length > 0)
            {
                ulong id = Convert.ToUInt64(arg.Args[0]);
                GiveChutePack(BasePlayer.FindByID(id));
            }
        }

        [ConsoleCommand("dorespawn")]
        void cmdConsoleDoRespawn(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length == 0) return;
            if (arg.Args.Length == 1)
            {
                ulong id = Convert.ToUInt64(arg.Args[0]);
                if (UseCooldown && CooldownListConstainsPlayerID(BasePlayer.FindByID(id))) return;
                if (UseCooldown) { CooldownAddPlayerID(BasePlayer.FindByID(id)); }
                if (UseRandomRespawn) { RespawnAtRandom(BasePlayer.FindByID(id), true); return; }
                else
                    RespawnAtPlane(BasePlayer.FindByID(id), true);
            }
        }

        [ConsoleCommand("chaosdrop")]
        void cmdConsoleChaosDrop(ConsoleSystem.Arg arg)
        {
            var player = arg.Player() ?? null;
            if (player != null)
            {
                if (permission.UserHasPermission(player.UserIDString, "skyfall.admin"))
                {
                    ActivateChaosDrop();
                }
            }
            if (player == null)
            {
                ActivateChaosDrop();
            }
        }

        #endregion

        #region Hooks

        void ActivateChaosDrop()
        {
            ConVar.Chat.Broadcast("in .... " + ChaosDropCountdown.ToString("F0"), "Skyfall Chaos Drop", "#4286f4");
            timer.Once(ChaosDropCountdown * 0.25f, () => ConVar.Chat.Broadcast("in .... " + (ChaosDropCountdown * 0.75f).ToString("F0"), "Skyfall Chaos Drop", "#4286f4"));
            timer.Once(ChaosDropCountdown * 0.50f, () => ConVar.Chat.Broadcast("in .... " + (ChaosDropCountdown * 0.50f).ToString("F0"), "Skyfall Chaos Drop", "#4286f4"));
            timer.Once(ChaosDropCountdown * 0.75f, () => ConVar.Chat.Broadcast("in .... " + (ChaosDropCountdown * 0.25f).ToString("F0"), "Skyfall Chaos Drop", "#4286f4"));
            timer.Once(ChaosDropCountdown, () =>
            {
                PrintWarning("Chaos Drop Has Been Activated...");
                DoChaosDrop();
            });
        }

        void DoChaosDrop()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                DoTPSkyfallRandom(player);
            }
        }

        public bool ListConstainsPlayerID(BasePlayer player)
        {
            if (skyfallplayerlist.Contains(player.userID)) return true;
            return false;
        }

        void AddPlayerID(BasePlayer player)
        {
            if (ListConstainsPlayerID(player)) return;
            skyfallplayerlist.Add(player.userID);
        }

        public void RemovePlayerID(BasePlayer player)
        {
            if (ListConstainsPlayerID(player))
            {
                skyfallplayerlist.Remove(player.userID);
                return;
            }
        }

        bool CooldownListConstainsPlayerID(BasePlayer player)
        {
            if (cooldownlist.Contains(player.userID)) return true;
            return false;
        }

        void CooldownAddPlayerID(BasePlayer player)
        {
            if (CooldownListConstainsPlayerID(player)) return;
            cooldownlist.Add(player.userID);
            float cooldown = SkyFallCoolDown;
            timer.Once(cooldown, () => { cooldownlist.Remove(player.userID); });
        }

        Vector3 FindSpawnPoint()
        {
            Vector3 spawnpoint = new Vector3();
            float spawnline = ((ConVar.Server.worldsize) / 2) - GlobalMapOffset;

            float spawnminx = spawnline;
            float spawnmaxx = spawnline;
            float spawnminz = spawnline;
            float spawnmaxz = spawnline;

            float xrandom1 = UnityEngine.Random.Range(0, 2);
            if (xrandom1 == 1) { spawnminx = spawnline; spawnmaxx = spawnline; spawnminz = 0; spawnmaxz = UnityEngine.Random.Range(0, spawnline); }
            if (xrandom1 == 0) { spawnminz = spawnline; spawnmaxz = spawnline; spawnminx = 0; spawnmaxx = UnityEngine.Random.Range(0, spawnline); }
            float yrandom = FlightDeck;
            spawnpoint = new Vector3(UnityEngine.Random.Range(spawnminx, spawnmaxx), yrandom, UnityEngine.Random.Range(spawnminz, spawnmaxz));

            float xrandom2 = UnityEngine.Random.Range(0, 2);
            float zrandom2 = UnityEngine.Random.Range(0, 2);
            if (xrandom2 == 1) spawnpoint.x = -spawnpoint.x;
            if (zrandom2 == 1) spawnpoint.z = -spawnpoint.z;
            return spawnpoint;
        }

        Vector3 FindPlayerSKyfallPoint()
        {
            Vector3 spawnpoint = new Vector3();
            float spawnline = ((ConVar.Server.worldsize) / 2) - GlobalMapOffset;
            float yrandom = UnityEngine.Random.Range(FlightDeck * 0.75f, FlightDeck * 1.25f);
            spawnpoint = new Vector3(UnityEngine.Random.Range(-spawnline, spawnline), yrandom, UnityEngine.Random.Range(-spawnline, spawnline));
            return spawnpoint;
        }

        Vector3 GetLocalSkyfallPoint(BasePlayer player)
        {
            Vector3 targetPos = new Vector3();
            Vector3 randomizer = new Vector3(UnityEngine.Random.Range(-localRespawnDistance, localRespawnDistance), 0f, UnityEngine.Random.Range(-localRespawnDistance, localRespawnDistance));
            Vector3 newp = (player.transform.position + randomizer);
            float yrandom = UnityEngine.Random.Range(FlightDeck * 0.75f, FlightDeck * 1.25f);
            targetPos = new Vector3(newp.x, yrandom, newp.z);
            return targetPos;
        }

        SkyfallPlane FindJumpPlane()
        {
            if (skyfallPlane != null)
            {
                var isplane = skyfallPlane.GetComponentInParent<SkyfallPlane>() ?? null;
                if (isplane != null)
                {
                    isplane.counter = 0f;
                    return isplane;
                }
            }
            Vector3 startloc = FindSpawnPoint();
            string sphereprefab = "assets/prefabs/visualization/sphere.prefab";
            skyfallPlane = GameManager.server.CreateEntity(sphereprefab, startloc, Quaternion.identity, true);
            skyfallPlane.Spawn();
            var newplane = skyfallPlane.gameObject.AddComponent<SkyfallPlane>();
            return newplane;
        }

        void ActivateJumpPlane(BasePlayer player)
        {
            var jumpplane = FindJumpPlane() as SkyfallPlane;
            if (jumpplane)
            {
                SendReply(player, "Skyfall Countdown 3...");
                timer.Once(1f, () => SendReply(player, "Skyfall Countdown 2..."));
                timer.Once(2f, () => SendReply(player, "Skyfall Countdown 1..."));
                timer.Once(3f, () =>
                {
                    if (player == null || jumpplane == null) return;
                    ActivateSkyfall(player, jumpplane);
                });
            }
            else return;
        }

        void ActivateSkyfall(BasePlayer player, SkyfallPlane plane)
        {
            if (player == null) return;
            if (player.isMounted) { SendReply(player, "You are already Mounted"); return; }
            var hascontroller = player.GetComponent<PlayerJumpController>() ?? null;
            if (hascontroller == null) player.gameObject.AddComponent<PlayerJumpController>();
            AddPlayerID(player);
            DoRespawnAt(player, plane.transform.position, plane.transform.rotation);
            if (plane.FindMountableChair(player))
            {
                return;
            }
            else RespawnAtRandom(player);
        }

        void GiveChutePack(BasePlayer player)
        {
            if (player == null) return;
            var item = ItemManager.CreateByItemID(-2022172587, 1, 1398786190);
            player.inventory.GiveItem(item);
        }

        private void CanWearItem(PlayerInventory inventory, Item item, int targetPos)
        {
            if (item == null || item.skin != 1398786190) return;
            if (inventory == null) return;
            var player = inventory.GetComponent<BasePlayer>() ?? null;
            if (player == null) return;
            if (player.isMounted) { SendReply(player, "You are already Mounted"); return; }
            if (cooldownlist.Contains(player.userID)) { PrintToChat(player, lang.GetMessage("undercooldown", this, player.UserIDString)); return; }
            if (UseCooldown) { CooldownAddPlayerID(player); }
            AddPlayerID(player);
            ActivateJumpPlane(player);
            if (item != null) item.Remove(0f);
        }

        public void DoRespawnAt(BasePlayer player, Vector3 position, Quaternion rotation, bool isrespawn = false)
        {
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Wounded, false);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Unused2, false);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Unused1, false);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.DisplaySash, false);
            player.transform.position = (position);
            player.transform.rotation = (rotation);
            player.StopWounded();
            player.StopSpectating();
            player.UpdateNetworkGroup();
            player.UpdatePlayerCollider(true);
            player.UpdatePlayerRigidbody(false);
            if (isrespawn) player.StartSleeping();
            if (isrespawn) player.metabolism.Reset();
            if (isrespawn) player.InitializeHealth(player.StartHealth(), player.StartMaxHealth());
            if (isrespawn) player.inventory.GiveDefaultItems();
            player.SendNetworkUpdateImmediate(false);
            player.ClearEntityQueue(null);
            if (isrespawn) player.ClientRPCPlayer(null, player, "StartLoading");
            if (isrespawn) Oxide.Core.Interface.CallHook("OnPlayerRespawned", player);
            player.SendFullSnapshot();
        }

        void RespawnAtPlane(BasePlayer player, bool isrespawn = false)
        {
            if (player == null) return;
            var hascontroller = player.GetComponent<PlayerJumpController>() ?? null;
            if (hascontroller == null) player.gameObject.AddComponent<PlayerJumpController>();
            AddPlayerID(player);
            var jumplane = FindJumpPlane() as SkyfallPlane;
            DoRespawnAt(player, jumplane.transform.position, jumplane.transform.rotation, isrespawn);
            AttachChute(player);
        }

        void RespawnAtRandom(BasePlayer player, bool isrespawn = false)
        {
            if (player == null) return;
            var hascontroller = player.GetComponent<PlayerJumpController>() ?? null;
            if (hascontroller == null) player.gameObject.AddComponent<PlayerJumpController>();

            AddPlayerID(player);
            Vector3 respawnpos = new Vector3();
            if (enableLocalRespawn || permission.UserHasPermission(player.UserIDString, "skyfall.localrespawn")) respawnpos = GetLocalSkyfallPoint(player);
            else respawnpos = FindPlayerSKyfallPoint();
            DoRespawnAt(player, respawnpos, Quaternion.identity, isrespawn);
            AttachChute(player);
        }

        void PreparePlayerTPSkyfall(BasePlayer player)
        {

            SendReply(player, "Skyfall Countdown 3...");
            timer.Once(1f, () => SendReply(player, "Skyfall Countdown 2..."));
            timer.Once(2f, () => SendReply(player, "Skyfall Countdown 1..."));
            timer.Once(3f, () =>
            {
                if (player == null) return;
                DoTPSkyfallRandom(player);
            });
        }

        void DoTPSkyfallRandom(BasePlayer player)
        {
            if (player == null) return;
            var hascontroller = player.GetComponent<PlayerJumpController>() ?? null;
            if (hascontroller == null) player.gameObject.AddComponent<PlayerJumpController>();
            AddPlayerID(player);
            Vector3 respawnpos = FindSpawnPoint();

            player.transform.position = respawnpos;
            player.ClientRPCPlayer(null, player, "ForcePositionTo", respawnpos);
            player.SendNetworkUpdate();

            AttachChute(player);
        }

        ///////////////////////////////////////////////////////////////////

        public void AttachChute(BasePlayer player)
        {
            if (player == null) return;
            string chairprefab = "assets/prefabs/deployable/chair/chair.deployed.prefab";
            var chutemount = GameManager.server.CreateEntity(chairprefab, player.transform.position, Quaternion.identity, true);
            chutemount.enableSaving = false;
            var hasstab = chutemount.GetComponent<StabilityEntity>();
            if (hasstab) hasstab.grounded = true;
            var hasmount = chutemount.GetComponent<BaseMountable>();
            if (hasmount) hasmount.isMobile = true;
            chutemount.skinID = 1311472987;
            chutemount?.Spawn();
            if (chutemount != null)
            {
                if (!isParachuting.Contains(player.userID)) isParachuting.Add(player.userID);
                var parachute = GameManager.server.CreateEntity("assets/prefabs/misc/parachute/parachute.prefab", new Vector3(), new Quaternion(), true);
                parachute.SetParent(chutemount, 0);
                parachute?.Spawn();

                var addchute = chutemount.gameObject.AddComponent<PlayerParachute>();
                hasmount.MountPlayer(player);
            }
            return;
        }

        object OnPlayerLand(BasePlayer player, float num)
        {
            if (player == null) return null;
            if (ListConstainsPlayerID(player)) return false;
            return null;
        }

        void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (player == null || input == null) return;
            if (ListConstainsPlayerID(player))
            {
                if (!player.isMounted)
                {
                    if (input.WasJustPressed(BUTTON.RELOAD))
                    {
                        AttachChute(player);
                        return;
                    }
                }
                if (player.isMounted)
                {
                    var haschute1 = player.GetMounted().GetComponentInParent<PlayerParachute>() ?? null;
                    if (haschute1)
                    {
                        haschute1.ChuteInput(input, player);
                    }
                    return;
                }
            }
        }

        object OnPlayerViolation(BasePlayer player, AntiHackType type, float amount)
        {
            if (player == null) return null;
            if (ListConstainsPlayerID(player)) return false;
            return null;
        }

        void SendInfoMessage(BasePlayer player, string message, float time)
        {
            player?.SendConsoleCommand("gametip.showgametip", message);
            timer.Once(time, () => player?.SendConsoleCommand("gametip.hidegametip"));
        }

        object CanDismountEntity(BasePlayer player, BaseMountable entity)
        {
            if (player == null) return null;
            if (!AllowFreeFall)
            {
                if (isParachuting.Contains(player.userID)) return true;
            }
            return null;
        }

        private void OnEntityDismounted(BaseMountable mountable, BasePlayer player)
        {
            if (mountable == null || player == null) return;
            if (player.GetComponent<PlayerJumpController>())
            {
                if (AllowFreeFall)
                {
                    SendInfoMessage(player, "Press your <color=black>[ R E L O A D ]</color> key to open parachute !!", 10f);
                }
                if (!AllowFreeFall)
                {
                    AttachChute(player);
                }
            }
            return;
        }

        public void DisMountPlayer(BasePlayer player)
        {
            if (player == null || !player.isMounted) return;
            var isonplane = player.GetMounted().GetComponentInParent<SkyfallPlane>() ?? null;
            if (isonplane == null) return;
            if (player.isMounted && isonplane != null)
            {
                player?.EnsureDismounted();
                AttachChute(player);
            }
            else return;
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity == null || hitInfo == null) return;
            if (entity is BasePlayer)
            {
                BasePlayer victim = (BasePlayer)entity as BasePlayer;
                if (ListConstainsPlayerID(victim))
                {
                    hitInfo.damageTypes.ScaleAll(0);
                }
            }
        }

        static void DestroyAll<T>()
        {
            var objects = GameObject.FindObjectsOfType(typeof(T));
            if (objects != null)
                foreach (var gameObj in objects)
                    GameObject.Destroy(gameObj);
        }

        void OnPlayerDie(BasePlayer player, HitInfo info)
        {
            if (player == null) return;
            RemovePlayerID(player);
            if (!EnableRespawnButton) return;
            timer.Once(4f, () => AddPlayerButton(player));
        }

        void AddPlayerButton(BasePlayer player)
        {
            if (player == null) return;
            player.gameObject.AddComponent<SkyfallRespawnButton>();
        }

        void OnPlayerRespawned(BasePlayer player)
        {
            if (player == null) return;
            var hasgui = player.GetComponent<SkyfallRespawnButton>() ?? null;
            if (hasgui != null) GameObject.Destroy(hasgui);
        }

        void Unload()
        {
            skyfallplayerlist.Clear();
            isParachuting.Clear();
            cooldownlist.Clear();
            DestroyAll<SkyfallRespawnButton>();
            DestroyAll<SkyfallPlane>();
            DestroyAll<PlayerParachute>();
            DestroyAll<PlayerJumpController>();
        }

        #endregion

        #region Respawn Button Cui

        class SkyfallRespawnButton : MonoBehaviour
        {
            BasePlayer player;

            void Awake()
            {
                player = base.GetComponentInParent<BasePlayer>();
                RespawnButton(player);
            }

            public void RespawnButton(BasePlayer player)
            {
                DestroyCui(player);
                if (player == null) { OnDestroy(); return; }

                var elements = new CuiElementContainer();
                string colorstring = "0.32 0.39 0.19 0.5";
                string textstring = "Use Skyfall \n Respawn";
                if (cooldownlist.Contains(player.userID)) { colorstring = "0.30 0.25 0.14 0.5"; textstring = "Skyfall Respawn \n Unavailable"; }

                string clickbutton = elements.Add(new CuiButton
                {
                    Button = { Command = $"dorespawn " + player.userID, Color = colorstring },
                    RectTransform = { AnchorMin = "0.45 0.16", AnchorMax = "0.71 0.26" },
                    Text = { Text = textstring, FontSize = 20, Color = "1.0 1.0 1.0 1.0", Align = TextAnchor.MiddleCenter }
                }, "Overall", "skyfallbutton");

                elements.Add(new CuiElement
                {
                    Name = "skyfallgui",
                    Parent = "Overall",
                    Components =
                            {
                            new CuiRawImageComponent { Color = "1 1 1 1", Url = "https://i.imgur.com/XPokWoq.png", Sprite = "assets/content/textures/generic/fulltransparent.tga" },
                            new CuiRectTransformComponent { AnchorMin = "0.46 0.17",  AnchorMax = "0.50 0.25" }
                            }
                });

                CuiHelper.AddUi(player, elements);
            }

            void DestroyCui(BasePlayer player)
            {
                if (player == null) { OnDestroy(); return; }
                CuiHelper.DestroyUi(player, "skyfallgui");
                CuiHelper.DestroyUi(player, "skyfallbutton");
            }

            void OnDestroy()
            {
                DestroyCui(player);
                Destroy(this);
            }
        }

        #endregion

        #region Skyfall Plane Entity

        class SkyfallPlane : BaseEntity
        {
            BaseEntity cpentity;
            BaseEntity plane;
            Vector3 cpentitypos;
            public float counter;

            public BaseEntity jumpchair1;
            public BaseEntity jumpchair2;
            public BaseEntity jumpchair3;
            public BaseEntity jumpchair4;
            public BaseEntity jumpchair5;
            public BaseEntity jumpchair6;
            public BaseEntity jumpchair7;
            public BaseEntity jumpchair8;
            public BaseEntity jumpchair9;
            public BaseEntity jumpchair10;
            public BaseEntity jumpchair11;
            public BaseEntity jumpchair12;

            BaseEntity wallsign;

            Vector3 movetopoint;

            void Awake()
            {
                cpentity = GetComponent<BaseEntity>();
                if (cpentity == null) { OnDestroy(); return; }
                cpentitypos = cpentity.transform.position + new Vector3(0f, -5f, 0f);
                counter = 0f;
                plane = GameManager.server.CreateEntity("assets/prefabs/npc/cargo plane/cargo_plane.prefab", cpentity.transform.position + new Vector3(0f, -5f, 0f), Quaternion.identity, true);
                if (plane != null)
                {
                    plane.enabled = false;
                    plane.Spawn();
                    plane.SetParent(cpentity, 0);
                }
                string chairprefab = "assets/prefabs/deployable/chair/chair.deployed.prefab";
                jumpchair1 = GameManager.server.CreateEntity(chairprefab, cpentitypos, Quaternion.identity, true);
                jumpchair1.transform.localEulerAngles = new Vector3(0, 90, 0);
                jumpchair1.transform.localPosition = new Vector3(-1.2f, 3f, -7.43f);
                SpawnRefresh(jumpchair1);
                jumpchair1?.Spawn();
                jumpchair1.SetParent(plane, 0);

                jumpchair2 = GameManager.server.CreateEntity(chairprefab, cpentitypos, Quaternion.identity, true);
                jumpchair2.transform.localEulerAngles = new Vector3(0, 90, 0);
                jumpchair2.transform.localPosition = new Vector3(-1.2f, 3f, -6.76f);
                SpawnRefresh(jumpchair2);
                jumpchair2?.Spawn();
                jumpchair2.SetParent(plane, 0);

                jumpchair3 = GameManager.server.CreateEntity(chairprefab, cpentitypos, Quaternion.identity, true);
                jumpchair3.transform.localEulerAngles = new Vector3(0, 90, 0);
                jumpchair3.transform.localPosition = new Vector3(-1.2f, 3f, -6.10f);
                SpawnRefresh(jumpchair3);
                jumpchair3?.Spawn();
                jumpchair3.SetParent(plane, 0);

                jumpchair4 = GameManager.server.CreateEntity(chairprefab, cpentitypos, Quaternion.identity, true);
                jumpchair4.transform.localEulerAngles = new Vector3(0, 90, 0);
                jumpchair4.transform.localPosition = new Vector3(-1.2f, 3f, -5.43f);
                SpawnRefresh(jumpchair4);
                jumpchair4?.Spawn();
                jumpchair4.SetParent(plane, 0);

                jumpchair5 = GameManager.server.CreateEntity(chairprefab, cpentitypos, Quaternion.identity, true);
                jumpchair5.transform.localEulerAngles = new Vector3(0, 90, 0);
                jumpchair5.transform.localPosition = new Vector3(-1.2f, 3f, -4.76f);
                SpawnRefresh(jumpchair5);
                jumpchair5?.Spawn();
                jumpchair5.SetParent(plane, 0);

                jumpchair6 = GameManager.server.CreateEntity(chairprefab, cpentitypos, Quaternion.identity, true);
                jumpchair6.transform.localEulerAngles = new Vector3(0, 90, 0);
                jumpchair6.transform.localPosition = new Vector3(-1.2f, 3f, -4.10f);
                SpawnRefresh(jumpchair6);
                jumpchair6?.Spawn();
                jumpchair6.SetParent(plane, 0);
                AddWallSign();

                jumpchair7 = GameManager.server.CreateEntity(chairprefab, cpentitypos, Quaternion.identity, true);
                jumpchair7.transform.localEulerAngles = new Vector3(0, 270, 0);
                jumpchair7.transform.localPosition = new Vector3(1.2f, 3f, -7.43f);
                SpawnRefresh(jumpchair7);
                jumpchair7?.Spawn();
                jumpchair7.SetParent(plane, 0);

                jumpchair8 = GameManager.server.CreateEntity(chairprefab, cpentitypos, Quaternion.identity, true);
                jumpchair8.transform.localEulerAngles = new Vector3(0, 270, 0);
                jumpchair8.transform.localPosition = new Vector3(1.2f, 3f, -6.76f);
                SpawnRefresh(jumpchair8);
                jumpchair8?.Spawn();
                jumpchair8.SetParent(plane, 0);

                jumpchair9 = GameManager.server.CreateEntity(chairprefab, cpentitypos, Quaternion.identity, true);
                jumpchair9.transform.localEulerAngles = new Vector3(0, 270, 0);
                jumpchair9.transform.localPosition = new Vector3(1.2f, 3f, -6.10f);
                SpawnRefresh(jumpchair9);
                jumpchair9?.Spawn();
                jumpchair9.SetParent(plane, 0);

                jumpchair10 = GameManager.server.CreateEntity(chairprefab, cpentitypos, Quaternion.identity, true);
                jumpchair10.transform.localEulerAngles = new Vector3(0, 270, 0);
                jumpchair10.transform.localPosition = new Vector3(1.2f, 3f, -5.43f);
                SpawnRefresh(jumpchair10);
                jumpchair10?.Spawn();
                jumpchair10.SetParent(plane, 0);

                jumpchair11 = GameManager.server.CreateEntity(chairprefab, cpentitypos, Quaternion.identity, true);
                jumpchair11.transform.localEulerAngles = new Vector3(0, 270, 0);
                jumpchair11.transform.localPosition = new Vector3(1.2f, 3f, -4.76f);
                SpawnRefresh(jumpchair11);
                jumpchair11?.Spawn();
                jumpchair11.SetParent(plane, 0);

                jumpchair12 = GameManager.server.CreateEntity(chairprefab, cpentitypos, Quaternion.identity, true);
                jumpchair12.transform.localEulerAngles = new Vector3(0, 270, 0);
                jumpchair12.transform.localPosition = new Vector3(1.2f, 3f, -4.10f);
                SpawnRefresh(jumpchair12);
                jumpchair12?.Spawn();
                jumpchair12.SetParent(plane, 0);

                movetopoint = FindCoords();
            }

            void AddWallSign()
            {
                if (plane == null) { OnDestroy(); return; }
                string prefabwallsign = "assets/prefabs/deployable/rug/rug.deployed.prefab";
                wallsign = GameManager.server.CreateEntity(prefabwallsign, cpentitypos, Quaternion.identity, true);
                wallsign.transform.localEulerAngles = new Vector3(0, 270, 90);
                wallsign.transform.localPosition = new Vector3(0f, 4.7f, -3.8f);
                wallsign.skinID = wallskinid;
                wallsign?.Spawn();
                wallsign.SetParent(plane, 0);
                SpawnRefresh(wallsign);
            }

            public bool FindMountableChair(BasePlayer player)
            {
                if (ChairIsAvailable(player, jumpchair1)) return true;
                if (ChairIsAvailable(player, jumpchair2)) return true;
                if (ChairIsAvailable(player, jumpchair3)) return true;
                if (ChairIsAvailable(player, jumpchair4)) return true;
                if (ChairIsAvailable(player, jumpchair5)) return true;
                if (ChairIsAvailable(player, jumpchair6)) return true;
                if (ChairIsAvailable(player, jumpchair7)) return true;
                if (ChairIsAvailable(player, jumpchair8)) return true;
                if (ChairIsAvailable(player, jumpchair9)) return true;
                if (ChairIsAvailable(player, jumpchair10)) return true;
                if (ChairIsAvailable(player, jumpchair11)) return true;
                if (ChairIsAvailable(player, jumpchair12)) return true;
                return false;
            }

            bool ChairIsAvailable(BasePlayer player, BaseEntity entity)
            {
                var findmount = entity.GetComponent<BaseMountable>() ?? null;
                if (findmount != null)
                {
                    if (findmount._mounted) return false;
                    else
                        findmount.MountPlayer(player);
                    return true;
                }
                return false;
            }

            public bool PlayersAreMounted()
            {
                if (jumpchair1 != null && jumpchair1.GetComponent<BaseMountable>()._mounted) return true;
                if (jumpchair2 != null && jumpchair2.GetComponent<BaseMountable>()._mounted) return true;
                if (jumpchair3 != null && jumpchair3.GetComponent<BaseMountable>()._mounted) return true;
                if (jumpchair4 != null && jumpchair4.GetComponent<BaseMountable>()._mounted) return true;

                if (jumpchair5 != null && jumpchair5.GetComponent<BaseMountable>()._mounted) return true;
                if (jumpchair6 != null && jumpchair6.GetComponent<BaseMountable>()._mounted) return true;
                if (jumpchair7 != null && jumpchair7.GetComponent<BaseMountable>()._mounted) return true;
                if (jumpchair8 != null && jumpchair8.GetComponent<BaseMountable>()._mounted) return true;

                if (jumpchair9 != null && jumpchair9.GetComponent<BaseMountable>()._mounted) return true;
                if (jumpchair10 != null && jumpchair10.GetComponent<BaseMountable>()._mounted) return true;
                if (jumpchair11 != null && jumpchair11.GetComponent<BaseMountable>()._mounted) return true;
                if (jumpchair12 != null && jumpchair12.GetComponent<BaseMountable>()._mounted) return true;
                return false;
            }



            void SpawnRefresh(BaseNetworkable entity1)
            {
                var hasstab = entity1.GetComponent<StabilityEntity>();
                if (hasstab)
                {
                    hasstab.grounded = true;
                }
                var hasmount = entity1.GetComponent<BaseMountable>();
                if (hasmount)
                {
                    hasmount.isMobile = true;
                }
            }

            Vector3 FindCoords()
            {
                float spawnline = ((ConVar.Server.worldsize) / 2) - GlobalMapOffset;
                float spawnminx = spawnline;
                float spawnmaxx = spawnline;
                float spawnminz = spawnline;
                float spawnmaxz = spawnline;

                float xrandom1 = UnityEngine.Random.Range(0, 2);
                if (xrandom1 == 1) { spawnminx = spawnline; spawnmaxx = spawnline; spawnminz = 0; spawnmaxz = UnityEngine.Random.Range(0, spawnline); }
                if (xrandom1 == 0) { spawnminz = spawnline; spawnmaxz = spawnline; spawnminx = 0; spawnmaxx = UnityEngine.Random.Range(0, spawnline); }

                Vector3 spawnpoint = new Vector3(UnityEngine.Random.Range(spawnminx, spawnmaxx), FlightDeck, UnityEngine.Random.Range(spawnminz, spawnmaxz));

                float xrandom2 = UnityEngine.Random.Range(0, 2);
                float zrandom2 = UnityEngine.Random.Range(0, 2);
                if (xrandom2 == 1) spawnpoint.x = -spawnpoint.x;
                if (zrandom2 == 1) spawnpoint.z = -spawnpoint.z;
                return spawnpoint;
            }

            void FixedUpdate()
            {
                if (cpentity == null && plane == null) { OnDestroy(); return; }
                if (!PlayersAreMounted())
                {
                    counter = counter + 1f;
                    if (counter >= (SkyFallPlaneDespawn * 15f)) OnDestroy();
                }
                else counter = 0f;

                if (cpentity.transform.position == movetopoint) movetopoint = FindCoords();
                Vector3 targetDir = movetopoint - transform.position;
                Vector3 newDir = Vector3.RotateTowards(transform.forward, targetDir, 5f * Time.deltaTime, 0.0F);

                cpentity.transform.position = Vector3.MoveTowards(cpentity.transform.position, movetopoint, (25f) * Time.deltaTime);
                cpentity.transform.rotation = Quaternion.LookRotation(newDir);

                plane.transform.position = cpentity.transform.position + new Vector3(0f, -5f, 0f);
                plane.transform.rotation = cpentity.transform.rotation;
            }

            void OnDestroy()
            {
                if (plane != null) { plane.Invoke("KillMessage", 0.1f); }
                if (cpentity != null) { cpentity.Invoke("KillMessage", 0.1f); }
            }
        }

        #endregion

        #region Player Parachute Entity

        class PlayerParachute : BaseEntity
        {
            BaseEntity mount;
            Vector3 direction;
            Vector3 position;
            public bool moveforward;
            public bool rotright;
            public bool rotleft;

            void Awake()
            {
                mount = GetComponentInParent<BaseEntity>();
                if (mount == null) { OnDestroy(); return; }
                position = mount.transform.position;
                moveforward = false;
            }

            bool PlayerIsMounted()
            {
                bool flag = mount.GetComponent<BaseMountable>().IsMounted();
                return flag;
            }

            public void ChuteInput(InputState input, BasePlayer player)
            {
                if (input == null || player == null) return;
                if (input.WasJustPressed(BUTTON.FORWARD)) moveforward = true;
                if (input.WasJustReleased(BUTTON.FORWARD)) moveforward = false;
                if (input.WasJustPressed(BUTTON.RIGHT)) rotright = true;
                if (input.WasJustReleased(BUTTON.RIGHT)) rotright = false;
                if (input.WasJustPressed(BUTTON.LEFT)) rotleft = true;
                if (input.WasJustReleased(BUTTON.LEFT)) rotleft = false;
            }

            void FixedUpdate()
            {
                if (!PlayerIsMounted() || mount == null) { OnDestroy(); return; }
                if (Physics.Raycast(new Ray(mount.transform.position, Vector3.down), 3f, layerMask))
                {
                    OnDestroy();
                    return;
                }
                if (rotright) mount.transform.eulerAngles += new Vector3(0, 2, 0);
                else if (rotleft) mount.transform.eulerAngles += new Vector3(0, -2, 0);

                if (moveforward) mount.transform.localPosition += ((transform.forward * parchuteFwdSpeed) * Time.deltaTime);

                mount.transform.position = Vector3.MoveTowards(mount.transform.position, mount.transform.position + Vector3.down, (parachuteDownSpeed) * Time.deltaTime);
                mount.transform.hasChanged = true;
                mount.SendNetworkUpdateImmediate();
                mount.UpdateNetworkGroup();
            }

            public void OnDestroy()
            {
                if (mount != null) { mount.Invoke("KillMessage", 0.1f); }
            }
        }

        #endregion

        #region Player Jump Controller

        class PlayerJumpController : MonoBehaviour
        {
            BasePlayer player;
            public bool usedchute;
            Skyfall _instance;
            float dismountcounter;

            void Awake()
            {
                _instance = new Skyfall();
                player = GetComponentInParent<BasePlayer>() ?? null;
                if (player == null) { OnDestroy(); return; }
                usedchute = false;
                dismountcounter = 0f;
                player.ClearEntityQueue();
            }

            void FixedUpdate()
            {
                if (player == null) { OnDestroy(); return; }
                if (Physics.Raycast(new Ray(player.transform.position, Vector3.down), 10f, layerMask))
                {
                    OnDestroy();
                    return;
                }
                if (ForceDismountFromPlane)
                {
                    dismountcounter = dismountcounter + 0.1f;
                    if (dismountcounter >= ForceJumpTime) { _instance.DisMountPlayer(player); dismountcounter = 0f; }
                }
            }

            public void OnDestroy()
            {
                if (skyfallplayerlist.Contains(player.userID)) skyfallplayerlist.Remove(player.userID);
                if (isParachuting.Contains(player.userID)) isParachuting.Remove(player.userID);
                GameObject.Destroy(this);
            }
        }

        #endregion

    }
}

// --- End of file: Skyfall.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/GatherControl.cs ---
// --- Original Local Path: GatherControl.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("GatherControl", "CaseMan", "1.6.0", ResourceId = 2477)]
    [Description("Control gather rates by day and night with permissions")]

    class GatherControl : RustPlugin
    {	
		#region Variables
	    [PluginReference]
        Plugin GUIAnnouncements;
		
		static GatherControl GC = null;
		bool IsDay;	
		bool UseZeroIndexForDefaultGroup;
		bool UseMessageBroadcast;
		bool UseGUIAnnouncements;
		bool AdminMode;
		string BannerColor;
		string TextColor;
		public Dictionary<ulong, int> Temp = new Dictionary<ulong, int>();
		float Sunrise;
		float Sunset;
		float DayRateMultStaticQuarry;
		float NightRateMultStaticQuarry;
		string PLPerm = "gathercontrol.AllowChatCommand";
		string AdmPerm = "gathercontrol.AllowConsoleCommand";
		string BypassPerm = "gathercontrol.bypass";

		class PermData
        {
            public Dictionary<int, PermGroups> PermissionsGroups = new Dictionary<int, PermGroups>();
            public PermData(){}
        }

        class PermGroups
        {
			public float DayRateMultQuarry;			
			public float DayRateMultPickup;			
            public float DayRateMultResource;			
			public float DayRateMultResourceBonus;			
			public float DayRateMultResourceHQM;
			public float DayRateMultCropGather;			
			public float NightRateMultQuarry;			
			public float NightRateMultPickup;			           
            public float NightRateMultResource;			
			public float NightRateMultResourceBonus;			
			public float NightRateMultResourceHQM;
			public float NightRateMultCropGather;			
			public Dictionary<string, string> CustomRateMultQuarry = new Dictionary<string, string>();
			public Dictionary<string, string> CustomRateMultPickup = new Dictionary<string, string>();
			public Dictionary<string, string> CustomRateMultResource = new Dictionary<string, string>();
			public Dictionary<string, string> CustomRateMultResourceBonus = new Dictionary<string, string>();
			public Dictionary<string, string> CustomRateMultCropGather = new Dictionary<string, string>();
			public Dictionary<string, string> ToolMultiplier = new Dictionary<string, string>();
			public string PermGroup;
			public PermGroups(){}
        }

		PermData permData;
		#endregion
		#region Initialization
		void Init()
        {
            LoadDefaultConfig();
			permData = Interface.Oxide.DataFileSystem.ReadObject<PermData>("GatherControl");
			LoadDefaultData();
			permission.RegisterPermission(PLPerm, this);
			permission.RegisterPermission(AdmPerm, this);
			permission.RegisterPermission(BypassPerm, this);
            foreach(var perm in permData.PermissionsGroups)
			{
                permission.RegisterPermission(perm.Value.PermGroup, this);
			}
			CheckPlayers();
        }
		void LoadDefaultData()
		{
			if(!permData.PermissionsGroups.ContainsKey(0))
			{
				var def = new PermGroups();
                def.DayRateMultQuarry = 2;
                def.DayRateMultPickup = 2;
                def.DayRateMultResource = 2;
				def.DayRateMultResourceBonus = 2;
				def.DayRateMultResourceHQM = 2;
				def.DayRateMultCropGather = 2;
                def.NightRateMultQuarry = 3;
                def.NightRateMultPickup = 3;
                def.NightRateMultResource = 3;
				def.NightRateMultResourceBonus = 3;
				def.NightRateMultResourceHQM = 3;
				def.NightRateMultCropGather =3;
				def.PermGroup = "gathercontrol.default";
				permData.PermissionsGroups.Add(0, def);
				Interface.Oxide.DataFileSystem.WriteObject("GatherControl", permData);
			}			
		}
		void OnPlayerInit(BasePlayer player)
		{
			CheckPlayer(player);
		}
		void OnPlayerDisconnected(BasePlayer player, string reason)
		{
			if(Temp.ContainsKey(player.userID)) Temp.Remove(player.userID);
		}

		#endregion
		#region Configuration
        protected override void LoadDefaultConfig()
        {
			Config["UseZeroIndexForDefaultGroup"] = UseZeroIndexForDefaultGroup = GetConfig("UseZeroIndexForDefaultGroup", true);
			Config["UseMessageBroadcast"] = UseMessageBroadcast = GetConfig("UseMessageBroadcast", true);
			Config["UseGUIAnnouncements"] = UseGUIAnnouncements = GetConfig("UseGUIAnnouncements", false);
			Config["BannerColor"] = BannerColor = GetConfig("BannerColor", "Blue");
			Config["TextColor"] = TextColor = GetConfig("TextColor", "Yellow");
			Config["Sunrise"] = Sunrise = GetConfig("Sunrise", 7);
			Config["Sunset"] = Sunset = GetConfig("Sunset", 19);
			Config["DayRateMultStaticQuarry"] = DayRateMultStaticQuarry = GetConfig("DayRateMultStaticQuarry", 1);
			Config["NightRateMultStaticQuarry"] = NightRateMultStaticQuarry = GetConfig("NightRateMultStaticQuarry", 1);
			Config["AdminMode"] = AdminMode = GetConfig("AdminMode", false);
			SaveConfig();
		}
		#endregion		
		#region Localization
		void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
				["SunriseMessage"] = "Morning comes. Production rating is lowered.",
				["SunsetMessage"] = "Night is coming. Production rating is increased.",
				["GatherRateInfo"] = "Your gather multipliers:",
				["NoGatherRate"] = "You do not have gather multipliers!",
				["GatherRateInfoPlayer"] = "Player {0} have gather multipliers:",
				["NoGatherRatePlayer"] = "Player {0} do not have gather multipliers!",
				["RateResource"] = "Resource gather multiplier (day/night)",
				["RateResourceBonus"] = "Resource gather multiplier for bonus from ore (day/night)",
				["RateResourceHQM"] = "Resource gather multiplier for HQM from ore (day/night)",
				["RatePickup"] = "Pickup multiplier (day/night)",
				["RateQuarry"] = "Multiplier of quarrying (day/night)",
				["RateCropGather"] = "Multiplier for your crop gather (day/night)",
				["InvalidSyntax"] = "Invalid syntax! Use: showrate <name/ID>",
				["NoPlayer"] = "Player not found!",
				["NoPermission"] = "You don't have the permission to use this command",
				["AdminMode"] = "This is <color=lime>{0}</color> gather type.\nName: <color=lime>{1}</color>.\nItem short name: <color=lime>{2}</color>",
            }, this);
			lang.RegisterMessages(new Dictionary<string, string>
            {
                ["SunriseMessage"] = "Наступает утро. Рейтинг добычи уменьшен.",
                ["SunsetMessage"] = "Наступает ночь. Рейтинг добычи увеличен.",
				["GatherRateInfo"] = "Ваши множители добычи ресурсов:",
				["NoGatherRate"] = "У вас нет множителей добычи!",
				["GatherRateInfoPlayer"] = "У игрока {0} есть следующие множители:",
				["NoGatherRatePlayer"] = "У игрока {0} нет множителей добычи!",
				["RateResource"] = "Множитель добычи ресурсов (день/ночь)",
				["RateResourceBonus"] = "Множитель добычи бонуса из руды (день/ночь)",
				["RateResourceHQM"] = "Множитель добычи МВК из руды (день/ночь)",
				["RatePickup"] = "Множитель поднятия предметов (день/ночь)",
				["RateQuarry"] = "Множитель добычи карьеров (день/ночь)",
				["RateCropGather"] = "Множитель сбора своего урожая (день/ночь)",
				["InvalidSyntax"] = "Неправильный синтаксис. Используйте: showrate <имя/ID>",
				["NoPlayer"] = "Игрок не найден!",
				["NoPermission"] = "У вас недостаточно прав для выполнения этой команды",
				["AdminMode"] = "This is <color=lime>{0}</color> gather type.\nName: <color=lime>{1}</color>.\nItem short name: <color=lime>{2}</color>",
            }, this, "ru");
        }
        #endregion
		#region Hooks
		private void CheckDay()
		{
			var time = TOD_Sky.Instance.Cycle.Hour;
			if(time >= Sunrise && time <= Sunset)
			{
				if(!IsDay && time>=Sunrise && time<=Sunrise + 0.1) MessageToAll("SunriseMessage");
				IsDay = true;	
			}
			else
			{
				if(IsDay && time>=Sunset && time<=Sunset + 0.1) MessageToAll("SunsetMessage");
				IsDay = false;
			}	
		}
		private void CheckPlayers()
		{
			foreach (var player in BasePlayer.activePlayerList) CheckPlayer(player);  
		}
		private void CheckPlayer(BasePlayer player)
		{
			if(player == null) return;
			int index=-1;
			if(Temp.ContainsKey(player.userID)) Temp.Remove(player.userID);
			if(permission.UserHasPermission(player.UserIDString, BypassPerm)) return;
			index = CheckPlayerPerm(player, index);
			if(index >= 0)Temp.Add(player.userID, index);
		}
		private int CheckPlayerPerm(BasePlayer player, int index)
		{
			foreach (var perm in permData.PermissionsGroups)
            {
                if (permission.UserHasPermission(player.UserIDString, perm.Value.PermGroup) && perm.Key>=index) index = perm.Key;          				  
            }
			if(index==-1 && UseZeroIndexForDefaultGroup) index = 0;
			return index;			
		}	
		private void CustomList(Item item, string str)
		{
			float day, night;
			ParseFromString(str, out day, out night);
			GatherMultiplier(item, day, night);
		}	
		private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {			
            BasePlayer player = entity.ToPlayer();
			if(player == null) return;
			if(AdminMode)
				if(player.IsAdmin) SendReply(player, (string.Format(lang.GetMessage("AdminMode", this), "RESOURCE", item.info.displayName.english, item.info.shortname)));	
			int gr = CheckPlayerPerms(player);
			if(gr >= 0)
			{		
				if(permData.PermissionsGroups[gr].ToolMultiplier.ContainsKey(player.GetActiveItem().info.shortname) && player.GetActiveItem() != null) CustomList(item, permData.PermissionsGroups[gr].ToolMultiplier[player.GetActiveItem().info.shortname]);
				else if(permData.PermissionsGroups[gr].CustomRateMultResource.ContainsKey(item.info.shortname)) CustomList(item, permData.PermissionsGroups[gr].CustomRateMultResource[item.info.shortname]);
				else GatherMultiplier(item, permData.PermissionsGroups[gr].DayRateMultResource, permData.PermissionsGroups[gr].NightRateMultResource);					
			}		
        }
		private void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item) 
		{
			int gr = CheckPlayerPerms(player);
			if(gr >= 0)
			{
				if(permData.PermissionsGroups[gr].ToolMultiplier.ContainsKey(player.GetActiveItem().info.shortname) && player.GetActiveItem() != null) CustomList(item, permData.PermissionsGroups[gr].ToolMultiplier[player.GetActiveItem().info.shortname]);			
				else if(item.info.shortname=="hq.metal.ore") GatherMultiplier(item, permData.PermissionsGroups[gr].DayRateMultResourceHQM, permData.PermissionsGroups[gr].NightRateMultResourceHQM);
				else if(item.info.shortname!="hq.metal.ore" && permData.PermissionsGroups[gr].CustomRateMultResourceBonus.ContainsKey(item.info.shortname)) CustomList(item, permData.PermissionsGroups[gr].CustomRateMultResourceBonus[item.info.shortname]);
				else GatherMultiplier(item, permData.PermissionsGroups[gr].DayRateMultResourceBonus, permData.PermissionsGroups[gr].NightRateMultResourceBonus);	
			}		
		}		
		void OnCollectiblePickup(Item item, BasePlayer player)
		{
			if(player == null) return;
			if(AdminMode)
				if(player.IsAdmin) SendReply(player, (string.Format(lang.GetMessage("AdminMode", this), "PICKUP", item.info.displayName.english, item.info.shortname)));		
			int gr = CheckPlayerPerms(player);
			if(gr >= 0) 
			{
				if(permData.PermissionsGroups[gr].CustomRateMultPickup.ContainsKey(item.info.shortname)) CustomList(item, permData.PermissionsGroups[gr].CustomRateMultPickup[item.info.shortname]);
				else GatherMultiplier(item, permData.PermissionsGroups[gr].DayRateMultPickup, permData.PermissionsGroups[gr].NightRateMultPickup);
			}			
		}
		void OnQuarryGather(MiningQuarry quarry, Item item)
		{
			if(quarry.OwnerID == 0)
			{
				GatherMultiplier(item, DayRateMultStaticQuarry, NightRateMultStaticQuarry);
				return;				
			}
			int gr=-1;
			BasePlayer player = BasePlayer.FindByID(quarry.OwnerID);
            if(player == null)
			{
				BasePlayer player1 = BasePlayer.FindSleeping(quarry.OwnerID);
				if(player1 == null) return;
				gr = CheckPlayerPerm(player1, -1);
			}
			else
			{	
				gr = CheckPlayerPerms(player);
			}
			if(gr >= 0) 
			{
				if(permData.PermissionsGroups[gr].CustomRateMultQuarry.ContainsKey(item.info.shortname)) CustomList(item, permData.PermissionsGroups[gr].CustomRateMultQuarry[item.info.shortname]);
				else GatherMultiplier(item, permData.PermissionsGroups[gr].DayRateMultQuarry, permData.PermissionsGroups[gr].NightRateMultQuarry);
			}	
		}
		void OnCropGather(PlantEntity plant, Item item, BasePlayer player)
		{
			if(player == null) return;
			if(AdminMode)
				if(player.IsAdmin) SendReply(player, (string.Format(lang.GetMessage("AdminMode", this), "CROP GATHER", item.info.displayName.english, item.info.shortname)));
			int gr = CheckPlayerPerms(player);
			if(gr >= 0) 
			{	
				if(permData.PermissionsGroups[gr].CustomRateMultCropGather.ContainsKey(item.info.shortname)) CustomList(item, permData.PermissionsGroups[gr].CustomRateMultCropGather[item.info.shortname]);
				else GatherMultiplier(item, permData.PermissionsGroups[gr].DayRateMultCropGather, permData.PermissionsGroups[gr].NightRateMultCropGather);
			}	
		}
		private int CheckPlayerPerms(BasePlayer player)
        {			
           	if(Temp.ContainsKey(player.userID))
			{ 
				return Temp[player.userID];
			}        
			return -1;	
        }
		private void GatherMultiplier(Item item, float daymult, float nightmult) 
        {			
			if(IsDay) item.amount = (int)(item.amount * daymult); 
			else item.amount = (int)(item.amount * nightmult); 
        }
		void OnTick()
		{
			CheckDay();	
		}
		void OnUserPermissionGranted(string id, string permis)
		{
			OnChangePermsUser(id, permis);
		}
		void OnUserPermissionRevoked(string id, string permis)
		{
			OnChangePermsUser(id, permis);
		}
		void OnUserGroupAdded(string id, string name)
		{
			OnChangeUserGroup(id);
		}
		void OnUserGroupRemoved(string id, string name)
		{			
			OnChangeUserGroup(id);
		}
		void OnGroupPermissionGranted(string name, string permis)
		{
			OnChangePermsGroup(permis);
		}
		void OnGroupPermissionRevoked(string name, string permis)
		{
			OnChangePermsGroup(permis);
		}
		private void OnChangePermsGroup(string permis)
		{
			if(permis == BypassPerm)
			{
				CheckPlayers();
				return;	
			}	
			foreach(var perm in permData.PermissionsGroups)
			{
                if(perm.Value.PermGroup==permis) CheckPlayers();					
			}
		}	
		private void OnChangePermsUser(string id, string permis)
		{
			var player = BasePlayer.Find(id);
			if(player == null) return;
			if(permis == BypassPerm)
			{
				CheckPlayer(player);
				return;	
			}	
			foreach(var perm in permData.PermissionsGroups)
			{
                if(perm.Value.PermGroup==permis) CheckPlayer(player);					
			}
		}
		private void OnChangeUserGroup(string id)
		{
			var player = BasePlayer.Find(id);
			if(player == null) return;
			CheckPlayer(player);
		}
		#endregion
		#region Commands
        [ChatCommand("showrate")]
        void ShowRate(BasePlayer player, string command, string[] args)
        {
			if (!player.IsAdmin && !permission.UserHasPermission(player.userID.ToString(), PLPerm)) 
			{
				SendReply(player, lang.GetMessage("NoPermission", this, player.UserIDString));
                return;
			}
			int gr = CheckPlayerPerms(player);
			if(gr >= 0)	SendReply(player, lang.GetMessage("GatherRateInfo", this, player.UserIDString) + GatherInfo(player, gr));	
			else SendReply(player, lang.GetMessage("NoGatherRate", this, player.UserIDString)); 
		}
		[ConsoleCommand("showrate")]
        private void conShowRate(ConsoleSystem.Arg arg)
		{
			BasePlayer player0 = arg.Player();
			if (player0 is BasePlayer && arg.Connection != null && (arg.Connection.authLevel < 2 && !permission.UserHasPermission(player0.userID.ToString(), AdmPerm))) 
			{
				SendReply(arg, lang.GetMessage("NoPermission", this));
                return;
			}
			if (arg.Args == null || arg.Args.Length <= 0)
			{
                SendReply(arg, lang.GetMessage("InvalidSyntax", this));
                return;
            }
			BasePlayer player = BasePlayer.Find(arg.Args[0]) ?? BasePlayer.FindSleeping(arg.Args[0]);
			if(player == null)
			{
				SendReply(arg, (string.Format(lang.GetMessage("NoPlayer", this))));
				return;
			}	
			int gr = CheckPlayerPerm(player, -1);
			if(gr >= 0)	SendReply(arg, string.Format(lang.GetMessage("GatherRateInfoPlayer", this), player.displayName) + GatherInfo(player, gr));
			else SendReply(arg, string.Format(lang.GetMessage("NoGatherRatePlayer", this), player.displayName));               				          			
		}
		#endregion
		#region Helpers
		T GetConfig<T>(string name, T defaultValue) => Config[name] == null ? defaultValue : (T) Convert.ChangeType(Config[name], typeof(T)); 
		void MessageToAll(string key)
        {		
			foreach (var player in BasePlayer.activePlayerList)
			{
				if(permission.UserHasPermission(player.UserIDString, BypassPerm)) return;
				if(UseMessageBroadcast) SendReply(player, lang.GetMessage(key, this, player.UserIDString));
				if(GUIAnnouncements && UseGUIAnnouncements) GUIAnnouncements?.Call("CreateAnnouncement", lang.GetMessage(key, this, player.UserIDString), BannerColor, TextColor, player);
			}
        }
		private string GatherInfo(BasePlayer player, int gr)
		{
			string message = "";
			{
				message= string.Format("\n{0}: {6}/{12}\n{1}: {7}/{13}\n{2}: {8}/{14}\n{3}: {9}/{15}\n{4}: {10}/{16}\n{5}: {11}/{17}\n", 
					lang.GetMessage("RateResource", this, player.UserIDString),
					lang.GetMessage("RateResourceBonus", this, player.UserIDString),
					lang.GetMessage("RateResourceHQM", this, player.UserIDString),
					lang.GetMessage("RatePickup", this, player.UserIDString),
					lang.GetMessage("RateQuarry", this, player.UserIDString),
					lang.GetMessage("RateCropGather", this, player.UserIDString),	
					permData.PermissionsGroups[gr].DayRateMultResource,
					permData.PermissionsGroups[gr].DayRateMultResourceBonus,
					permData.PermissionsGroups[gr].DayRateMultResourceHQM,
					permData.PermissionsGroups[gr].DayRateMultPickup,
					permData.PermissionsGroups[gr].DayRateMultQuarry,
					permData.PermissionsGroups[gr].DayRateMultCropGather,				
					permData.PermissionsGroups[gr].NightRateMultResource,
					permData.PermissionsGroups[gr].NightRateMultResourceBonus,
					permData.PermissionsGroups[gr].NightRateMultResourceHQM,
					permData.PermissionsGroups[gr].NightRateMultPickup,
					permData.PermissionsGroups[gr].NightRateMultQuarry,
					permData.PermissionsGroups[gr].NightRateMultCropGather
					);
			}
			return message;	
		}	
		private void ParseFromString(string str, out float day, out float night)
		{
			string[] parts = str.Split('/');
			day = float.Parse(parts[0]);
			night = float.Parse(parts[1]);
		}
		#endregion
    }
}


// --- End of file: GatherControl.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Template.cs ---
// --- Original Local Path: Template.cs ---

using Oxide.Core.Plugins;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Plugin name", "Author name", "1.0.0", ResourceId = 123)]
    public class Template : RustPlugin // rename this to how your plugin file is named
    {
        #region RustIO Bindings
        [PluginReference] Plugin RustIO;
        bool IO() => RustIO != null ? RustIO.Call<bool>("IsInstalled") : false;
        bool HasFriend(string playerId, string friendId) => RustIO != null ? RustIO.Call<bool>("HasFriend", playerId, friendId) : false;
        bool AddFriend(string playerId, string friendId) => RustIO != null ? RustIO.Call<bool>("AddFriend", playerId, friendId) : false;
        bool DeleteFriend(string playerId, string friendId) => RustIO != null ? RustIO.Call<bool>("DeleteFriend", playerId, friendId) : false;
        List<string> GetFriends(string playerId) => RustIO != null ? RustIO.Call<List<string>>("GetFriends", playerId) : new List<string>();
        #endregion

        [HookMethod("OnServerInitialized")]
        void OnServerInitialized() {
            if (!IO())
                PrintWarning("This plugin uses the Rust:IO API, but Rust:IO is not installed.");
        }
    }
}


// --- End of file: Template.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AutoClientCommands.cs ---
// --- Original Local Path: AutoClientCommands.cs ---

using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Automatic Client Commands", "k1lly0u", "0.1.0", ResourceId = 0)]
    class AutoClientCommands : RustPlugin
    {
        #region Oxide Hooks
        void OnServerInitialized()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"addSuccess", "You have successfully added a new automatic client command: {0}" },
                {"remSuccess", "You have successfully remove the automatic client command: {0}" },
                {"noFind", "Unable to find the command: {0}" }
            }, this);

            LoadVariables();

            foreach (var player in BasePlayer.activePlayerList)
                RunCommands(player);
        }
        void OnPlayerInit(BasePlayer player) => RunCommands(player);
        #endregion

        #region Functions
        private void RunCommands(BasePlayer player)
        {
            foreach(var entry in configData.Commands)
                player.SendConsoleCommand(entry);
        }
        [ConsoleCommand("addcommand")]
        private void ccmdAddCommand(ConsoleSystem.Arg arg)
        {
            if (arg.connection == null)
            {
                if (arg.Args != null && arg.Args.Length > 0)
                {
                    configData.Commands.Add(arg.Args[0]);
                    SendReply(arg, string.Format(lang.GetMessage("addSuccess", this), arg.Args[0]));
                    SaveConfig(configData);
                }
            }
        }
        [ConsoleCommand("removecommand")]
        private void ccmdRemoveCommand(ConsoleSystem.Arg arg)
        {
            if (arg.connection == null)
            {
                if (arg.Args != null && arg.Args.Length > 0)
                {
                    if (configData.Commands.Contains(arg.Args[0]))
                    {
                        configData.Commands.Remove(arg.Args[0]);
                        SendReply(arg, string.Format(lang.GetMessage("remSuccess", this), arg.Args[0]));
                        SaveConfig(configData);
                        return;
                    }
                    SendReply(arg, string.Format(lang.GetMessage("noFind", this), arg.Args[0]));
                }
            }
        }
        #endregion

        #region Config        
        private ConfigData configData;
        class ConfigData
        {
            public List<string> Commands { get; set; }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                Commands = new List<string>
                {
                    "graphics.branding false"
                }
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion
    }
}




// --- End of file: AutoClientCommands.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/DiscordPlayerJoin-1.0.1.cs ---
// --- Original Local Path: DiscordPlayerJoin-1.0.1.cs ---

using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Libraries;

namespace Oxide.Plugins
{
    [Info("DiscordPlayerJoin", "AKACHATGPTPASTEROK", "1.0.1")]
    [Description("Sends a message to Discord when a player joins the server.")]
    public class DiscordPlayerJoin : RustPlugin
    {
        [PluginReference]
        Plugin Discord;

        private string webhookUrl = "https://discord.com/api/webhooks/1334675549276340285/C8u0nv9n9nLZmKjT6QX-EuR-Ku7_oO-ybDL24HFyDaeSgKm8GpA5NvYo53F5_6HnWDCI"; // Замените на ваш вебхук
        private const string TimeFormat = "dd.MM.yyyy HH:mm:ss";

        void Init()
        {
            Puts("DiscordPlayerJoin has been initialized.");
        }

        void OnPlayerConnected(BasePlayer player)
        {
            string steamId = player.UserIDString;
            string playerName = player.displayName;
            string ipAddress = player.Connection.ipaddress;
            string steamProfile = $"https://steamcommunity.com/profiles/{player.UserIDString.Substring(0,17)}";
            string currentTime = DateTime.Now.ToString(TimeFormat);

            string message = $"🎮 **Новый игрок присоединился к серверу!**\n" +
                           $"👤 Имя: `{playerName}`\n" +
                           $"🕒 Время захода: `{currentTime}`\n" +
                           $"🆔 Steam ID: `{steamId}`\n" +
                           $"🌐 IP Адрес: `{ipAddress}`\n" +
                           $"🔗 Steam Профиль: {steamProfile}";

            SendDiscordMessage(message);
        }

        void SendDiscordMessage(string message)
        {
            var payload = new
            {
                content = message,
                username = "Rust Server Monitor",
                avatar_url = "https://i.imgur.com/RxNEzZC.png"
            };

            var json = JsonConvert.SerializeObject(payload);
            
            webrequest.Enqueue(webhookUrl, json, (code, response) =>
            {
                if (code != 204 && code != 200)
                {
                    Puts($"Error sending message to Discord. Code: {code}, Response: {response}");
                }
            }, this, RequestMethod.POST, new Dictionary<string, string> { ["Content-Type"] = "application/json" });
        }
    }
}

// --- End of file: DiscordPlayerJoin-1.0.1.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HotKeys.cs ---
// --- Original Local Path: HotKeys.cs ---

using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("HotKeys", "Calytic", "0.0.31", ResourceId = 2135)]
    class HotKeys : RustPlugin
    {
        private Dictionary<string, object> keys;
        private bool ResetDefaultKeysOnJoin;

        Dictionary<string, string> defaultRustBinds = new Dictionary<string, string>()
        {
            {"f1", "consoletoggle"},
            {"backquote", "consoletoggle"},
            {"f7", "bugreporter"},
            {"w", "+forward"},
            {"s", "+backward"},
            {"a", "+left"},
            {"d", "+right"},
            {"mouse0", "+attack"},
            {"mouse1", "+attack2"},
            {"mouse2", "+attack3"},
            {"1", "+slot1"},
            {"2", "+slot2"},
            {"3", "+slot3"},
            {"4", "+slot4"},
            {"5", "+slot5"},
            {"6", "+slot6"},
            {"7", "+slot7"},
            {"8", "+slot8"},
            {"leftshift", "+sprint"},
            {"rightshift", "+sprint"},
            {"leftalt", "+altlook"},
            {"r", "+reload"},
            {"space", "+jump"},
            {"leftcontrol", "+duck"},
            {"e", "+use"},
            {"v", "+voice"},
            {"t", "chat.open"},
            {"return", "chat.open"},
            {"mousewheelup", "+invnext"},
            {"mousewheeldown", "+invprev"},
            {"tab", "inventory.toggle "},
        };

        void Loaded()
        {
            CheckConfig();
            keys = GetConfig("Settings", "Keys", GetDefaultKeys());
            ResetDefaultKeysOnJoin = GetConfig("Settings", "ResetDefaultKeysOnJoin", true);

            BindAll();
        }

        void OnPlayerInit(BasePlayer player)
        {
            if (ResetDefaultKeysOnJoin)
            {
                BindDefaultKeys(player);
            }
            BindKeys(player);
        }

        [ConsoleCommand("hotkey.bind")]
        private void ccHotKeyBind(ConsoleSystem.Arg arg)
        {
            if (arg.connection != null && arg.connection.authLevel < 1)
            {
                return;
            }

            if (arg.Args.Length == 1)
            {
                string keyCombo = arg.Args[0].Trim();
                if(keys.ContainsKey(keyCombo)) {
                    SendReply(arg, keyCombo + ": " + keys[keyCombo].ToString());
                    SaveBinds();
                    BindAll();
                } else {
                    SendReply(arg, "[HotKeys] No such binding");
                }
            } else if(arg.Args.Length == 2) {
                string keyCombo = arg.Args[0].Trim();
                string bind = arg.Args[1].Trim();

                if (keys.ContainsKey(keyCombo))
                {
                    SendReply(arg, "[HotKeys] Replaced " + keyCombo + ": " + bind);
                    keys[keyCombo] = bind;
                }
                else
                {
                    SendReply(arg, "[HotKeys] Bound " + keyCombo + ": " + bind);
                    keys.Add(keyCombo, bind);
                }

                SaveBinds();
                BindAll();
            }
            else
            {
                SendReply(arg, "[HotKeys] Invalid Syntax. hotkey.bind \"keyCombo\" [bind]");
            }
        }

        [ConsoleCommand("hotkey.unbind")]
        private void ccHotKeyUnbind(ConsoleSystem.Arg arg)
        {
            if (arg.connection != null && arg.connection.authLevel < 1)
            {
                return;
            }

            if (arg.Args.Length == 1)
            {
                string keyCombo = arg.Args[0].Trim();

                if (keys.ContainsKey(keyCombo))
                {
                    string bind = keys[keyCombo].ToString();
                    keys.Remove(keyCombo);
                    if (defaultRustBinds.ContainsKey(keyCombo))
                    {
                        SendReply(arg, "[HotKeys] Reverted " + keyCombo + ": " + defaultRustBinds[keyCombo]);
                    }
                    else
                    {
                        SendReply(arg, "[HotKeys] Unbound " + keyCombo + ": " + bind);
                    }
                    
                    SaveBinds();
                    UnbindAll(keyCombo);
                }
            }
            else
            {
                SendReply(arg, "[HotKeys] Invalid Syntax. hotkey.unbind \"keyCombo\"");
            }
        }

        void BindAll()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (ResetDefaultKeysOnJoin)
                {
                    BindDefaultKeys(player);
                }
                BindKeys(player);
            }
        }

        void UnbindAll(string keyCombo)
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                UnbindKey(player, keyCombo);
            }
        }

        void BindDefaultKeys(BasePlayer player)
        {
            foreach (KeyValuePair<string, string> kvp in defaultRustBinds)
            {
                player.SendConsoleCommand("bind " + kvp.Key + " " + kvp.Value.ToString());
            }
        }

        void BindKeys(BasePlayer player)
        {
            foreach (KeyValuePair<string, object> kvp in keys)
            {
                player.SendConsoleCommand("bind " + kvp.Key + " " + kvp.Value.ToString());
            }
        }

        void UnbindKey(BasePlayer player, string keyCombo)
        {
            string defaultRustBind = "";
            if (defaultRustBinds.ContainsKey(keyCombo))
            {
                defaultRustBind = defaultRustBinds[keyCombo];
            }
            player.SendConsoleCommand("bind " + keyCombo + " \"" + defaultRustBind + "\"");
        }

        void SaveBinds()
        {
            Config["Settings", "Keys"] = keys;
            Config.Save();
        }

        void LoadDefaultConfig()
        {
            Config["Settings", "Keys"] = GetDefaultKeys();
            Config["Settings", "ResetDefaultKeysOnJoin"] = GetConfig("Settings","ResetDefaultKeysOnJoin", true);

            Config["VERSION"] = Version.ToString();
        }

        void CheckConfig()
        {
            if (Config["VERSION"] == null)
            {
                // FOR COMPATIBILITY WITH INITIAL VERSIONS WITHOUT VERSIONED CONFIG
                ReloadConfig();
            }
            else if (GetConfig<string>("VERSION", "") != Version.ToString())
            {
                // ADDS NEW, IF ANY, CONFIGURATION OPTIONS
                ReloadConfig();
            }
        }

        protected void ReloadConfig()
        {
            Config["VERSION"] = Version.ToString();

            // NEW CONFIGURATION OPTIONS HERE
            Config["Settings", "ResetDefaultKeysOnJoin"] = GetConfig("Settings", "ResetDefaultKeysOnJoin", true);
            // END NEW CONFIGURATION OPTIONS

            PrintToConsole("Upgrading configuration file");
            SaveConfig();
        }

        Dictionary<string, object> GetDefaultKeys()
        {
            return new Dictionary<string, object>()
            {
                {"i", "inventory.toggle"},
                {"c", "duck"},
                {"z", "+attack;+duck"},
                {"f", "forward;sprint"},
            };
        }

        private T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null)
            {
                return defaultValue;
            }

            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

        private T GetConfig<T>(string name, string name2, T defaultValue)
        {
            if (Config[name, name2] == null)
            {
                return defaultValue;
            }

            return (T)Convert.ChangeType(Config[name, name2], typeof(T));
        }
    }
}


// --- End of file: HotKeys.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/F1Spawn.cs ---
// --- Original Local Path: F1Spawn.cs ---

﻿using System;
using UnityEngine;
using Newtonsoft.Json;
using System.Collections;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("F1Spawn", "Colon Blow", "1.0.3")]
    [Description("Allows use of F1 Item List Spawn")]
    class F1Spawn : CovalencePlugin
    {

        #region Load

        const string permBL1 = "f1spawn.blacklist1";
        const string permBL2 = "f1spawn.blacklist2";
        const string permAL1 = "f1spawn.allowlist1";
        const string permAL2 = "f1spawn.allowlist2";
        const string permALL = "f1spawn.allowall";

        private void OnServerInitialized()
        {
            permission.RegisterPermission(permBL1, this);
            permission.RegisterPermission(permBL2, this);
            permission.RegisterPermission(permAL1, this);
            permission.RegisterPermission(permAL2, this);
            permission.RegisterPermission(permALL, this);
        }

        bool isAllowed(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);

        #endregion

        #region Configuration

        private static PluginConfig config;

        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Bypass checks if Admin ? ")] public bool AdminBypass { get; set; }
            [JsonProperty(PropertyName = "Bypass checks if Moderator ? ")] public bool ModBypass { get; set; }
            [JsonProperty(PropertyName = "Blacklist 1 Items : ")] public List<string> BlackListedItems1 { get; set; }
            [JsonProperty(PropertyName = "Blacklist 2 Items : ")] public List<string> BlackListedItems2 { get; set; }
            [JsonProperty(PropertyName = "Allowed list 1 Items : ")] public List<string> AllowListItems1 { get; set; }
            [JsonProperty(PropertyName = "Allowed list 2 Items : ")] public List<string> AllowListItems2 { get; set; }

            public static PluginConfig DefaultConfig() => new PluginConfig()
            {
                AdminBypass = true,
                ModBypass = true,
                BlackListedItems1 = new List<string>()
                    {
                        "Satchel Charge",
                        "Timed Explosive Charge"
                    },
                BlackListedItems2 = new List<string>()
                    {
                        "Beancan Grenade",
                        "F1 Grenade"
                    },
                AllowListItems1 = new List<string>()
                    {
                        "Hammer",
                        "Building Plan"
                    },
                AllowListItems2 = new List<string>()
                    {
                        "Wood",
                        "Stones"
                    }
            };
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("New configuration file created!!");
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            SaveConfig();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region Give Command and Hook

        [Command("inventory.giveid")]
        void GiveIdCommand(IPlayer player, string command, string[] args)
        {
        }

        object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (arg == null || arg.cmd == null) return null;
            string command = arg.cmd.Name;
            if (command.Equals("giveid") || command.Equals("givearm"))
            {
                BasePlayer player = arg.Player();
                if (!player) return null;
                if (isAllowed(player, permALL) || isAllowed(player, permAL1) || isAllowed(player, permAL2) || isAllowed(player, permBL1) || isAllowed(player, permBL2) || player.net?.connection?.authLevel > 0)
                {
                    Item item = ItemManager.CreateByItemID(arg.GetInt(0), 1, 0);
                    if (item == null) return false;
                    var allowspawn = false;
                    if ((player.IsAdmin || player.IsDeveloper || player.net?.connection?.authLevel >= 2) && config.AdminBypass) allowspawn = true;
                    else if (player.net?.connection?.authLevel == 1 && config.ModBypass) allowspawn = true;
                    else if (isAllowed(player, permALL)) allowspawn = true;
                    else if (isAllowed(player, permAL1) && ((config.AllowListItems1.Contains(item.info.displayName.english) || config.AllowListItems1.Contains(item.info.shortname)))) allowspawn = true;
                    else if (isAllowed(player, permAL2) && ((config.AllowListItems2.Contains(item.info.displayName.english) || config.AllowListItems2.Contains(item.info.shortname)))) allowspawn = true;
                    else if (isAllowed(player, permBL1) && (!(config.BlackListedItems1.Contains(item.info.displayName.english) || config.BlackListedItems1.Contains(item.info.shortname)))) allowspawn = true;
                    else if (isAllowed(player, permBL2) && (!(config.BlackListedItems2.Contains(item.info.displayName.english) || config.BlackListedItems2.Contains(item.info.shortname)))) allowspawn = true;
                    else return false;

                    if (allowspawn)
                    {
                        item.amount = arg.GetInt(1, 1);
                        if (!player.inventory.GiveItem(item, null))
                        {
                            item.Remove(0f);
                            return false;
                        }
                        player.Command("note.inv", new object[] { item.info.itemid, item.amount });
                        //Debug.Log(string.Concat(new object[] { "[F1Spawn] giving ", player.displayName, " ", item.amount, " x ", item.info.displayName.english }));
                        return false;
                    }
                    else return false;
                }
            }
            return null;
        }

        #endregion
    }
}

// --- End of file: F1Spawn.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CustomWound.cs ---
// --- Original Local Path: CustomWound.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("CustomWound", "CustomWound", "1.0.9")]
	[Description("Custom Recovery")]
    public class CustomWound : RustPlugin
    {
        #region Components

        private class PlayerRecover : MonoBehaviour
        {
            private BasePlayer player;
            private float lastUpdate = 0;
            private float lastScream = 0;

            public int endChance = 0;
            private int resultChance; 
            private int different;

            public bool timeDrawed = false;
            
            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                if (player == null)
                {
                    Destroy(this);
                    return;
                }
                player.StartWounded();
                
                if (!CONF_DisableWoundEnd)
                {
                    endChance = instance.GetWakeChance(player);
                    resultChance = Core.Random.Range(0, 100);
                    different = resultChance - endChance;

                    if (CONF_CanCraftSpecialItem)
                    {
                        UI_DrawItemRecovery(player);
                    }
                    if (CONF_ShowChances)
                    {
                        UI_DrawWakeChances(player);
                    }
                }
                
                if (CONF_ShowEndWoundTime)
                {
                    UI_DrawLeftTime(player);
                }
            }

            private void Update()
            {
                lastUpdate += Time.deltaTime;

                if (lastUpdate > 1)
                {
                    lastUpdate = 0;
                    lastScream++;
                    
                    if (player.IsDead() || !player.IsWounded())
                    {
                        DisableObject(false);
                        return;
                    }
                    int leftTime = CONF_WoundTime - Convert.ToInt32(player.secondsSinceWoundedStarted);
                    if (leftTime > 0)
                    {
                        if (CONF_ShowEndWoundTime)
                        {
                            UI_DrawLeftTime(player);
                        }
                    }
                    else if (leftTime == 0)
                    {
                        if (CONF_DisableWoundEnd)
                        {
                            DisableObject(true);
                            return;
                        }
                        
                        if (resultChance <= endChance)
                        {
                            player.StopWounded();
                            DisableObject(false);
                        }
                        else
                        {
                            player.Die();
                            /*if (CONF_CustomMessages.Count != 0)
                            {
                                var getMessage = CONF_CustomMessages.First(p => p.Key > different).Value;
                                //UI_DrawChances(player, getMessage);
                            }*/
                            DisableObject(false);
                        }
                    }

                    if (lastScream > 5 && CONF_EnableScream)
                    {
                        MakeScream();
                        lastScream = 0;
                    }
                }
            }

            public void DisableObject(bool withDie)
            {
                CuiHelper.DestroyUi(player, UI_LayerItem);
                CuiHelper.DestroyUi(player, UI_LayerChance);
                CuiHelper.DestroyUi(player, UI_LayerTime);
                if (withDie)
                    player.Die();
                
                Destroy(this);
            }

            private void MakeScream()
            {
                Effect.server.Run("assets/bundled/prefabs/fx/player/beartrap_scream.prefab", player, 0, new Vector3(), new Vector3());
            }
        }

        #endregion
        
        #region Variables

        #region Configuration

        [JsonProperty("Отключить состояние ранения? (Автоматическая смерть)")]
        private static bool CONF_DisableWound = false;
        [JsonProperty("Отключить возможность встать после ранения?")]
        private static bool CONF_DisableWoundEnd = false;
        [JsonProperty("Новое время состояния ранения (Должно быть меньше 40)")]
        private static int CONF_WoundTime = 40;
        //[JsonProperty("Шанс упасть, при попадании пули (любого урона)")]
        //private static int CONF_WoundFromDamageChance = 3;
        [JsonProperty("Шанс встать после состояния ранения")]
        private static int CONF_WoundEndChance = 50;
        
        [JsonProperty("Показывать время до окончания ранения?")]
        private static bool CONF_ShowEndWoundTime = true;
        //[JsonProperty("Можно ли встать после ранения в зоне чужого шкафа?")]
        //private static bool CONF_CanEndWoundInBB = true;
        [JsonProperty("Разрешать поднимать игроков уколом шприца")]
        private static bool CONF_CanEndWoundBySyringe = true;

        [JsonProperty("Дополнительный шанс встать, при метаболизме > 250")]
        private static int CONF_StopWoundFromMetabolism = 10;
        [JsonProperty("Включить тряску экрана после подъёма предметом")]
        private static bool CONF_ShakeAfterWoundEnd = true;

        [JsonProperty("Специальная картинка для предмета")]
        private static string CONF_PictureURL = "https://i.imgur.com/FHC3hp7.png";
        [JsonProperty("Отображать шанс встать после падения")]
        private static bool CONF_ShowChances = true;
        [JsonProperty("Стандартное количество дефибрилляторов")]
        private static int CONF_DefaultDef = 5;
        [JsonProperty("Разрешить крафтить предмет специальный предмет")]
        private static bool CONF_CanCraftSpecialItem = true;
        [JsonProperty("Предметы необходимые для крафта")]
        public Dictionary<string, int> CONF_SpecialItemReceipt = new Dictionary<string,int>
        {
            ["syringe.medical"] = 5,
            ["largemedkit"] = 2
        };
        
        [JsonProperty("Включить крик игрока в состоянии ранения")]
        private static bool CONF_EnableScream = true;
        [JsonProperty("Дополнительные шансы встать для игроков с привилегиями")]
        private static Dictionary<string, int> CONF_CustomChances = new Dictionary<string, int>
        {
            ["customwound.40"] = 40,
            ["customwound.50"] = 50
        };
        /*[JsonProperty("Сообщение после смерти из-за ранения")]
        private static Dictionary<int, string> CONF_CustomMessages = new Dictionary<int, string>
        {
            [0] = "Да ладно, серьёзно: {0}",
            [10] = "Это было так близко: {0}",
            [20] = "Не слишком близко, но могло случиться: {0}",
            [30] = "Не стоит отчаиваться, в следующий раз повезёт: {0}",
            [40] = "Не везёт в игре, повезёт в любви: {0}",
            [40] = "Нет, ты даже близок не был: {0}"
        };*/

        #endregion

        #region System

        [PluginReference] private Plugin ImageLibrary;

        private static CustomWound instance;

        private static string UI_LayerTime = "UI_CustomRecovery_LeftTime";
        private static string UI_LayerChance = "UI_CustomRecovery_Chance";
        private static string UI_LayerItem = "UI_CustomRecovery_Item";
        
        private static List<string> ShakeEffects = new List<string>
        {
            "assets/prefabs/tools/jackhammer/effects/strike_screenshake.prefab",
            "assets/prefabs/weapons/doubleshotgun/effects/attack_shake.prefab",
            "assets/prefabs/weapons/hatchet/effects/strike_screenshake.prefab",
            "assets/prefabs/weapons/rock/effects/strike_screenshake.prefab",
            "assets/prefabs/weapons/smg/effects/attack_shake.prefab",
            "assets/prefabs/weapons/torch/effects/strike_screenshake.prefab"
        };

        #endregion

        #region Data

        [JsonProperty("Количество предметов для подъёма у игроков")]
        private static Dictionary<ulong, int> PlayerRecovery = new Dictionary<ulong, int>();
        
        #endregion

        #endregion

        #region Initialization

        protected override void LoadDefaultConfig()
        {
            GetConfig("Общие настройки", "Отключить состояние 'ранен' (Автоматическая смерть)", ref CONF_DisableWound);                    
            GetConfig("Общие настройки", "Отключить возможность случайно встать после ранения?", ref CONF_DisableWoundEnd);
            GetConfig("Общие настройки", "Заставлять игрока кричать при ранении?", ref CONF_EnableScream);
            
             GetConfig("Основные настройки ранения", "Отображать шанс встать по окончанию ранения", ref CONF_ShowEndWoundTime);
            GetConfig("Основные настройки ранения", "Отображать оставшееся время до окончания ранения", ref CONF_ShowEndWoundTime);
            GetConfig("Основные настройки ранения", "Изменить время ранения? (Должно быть меньше 40)", ref CONF_WoundTime);
            GetConfig("Основные настройки ранения", "Изменить стандартный шанс встать после ранения? (0 - 100)", ref CONF_WoundEndChance);
            //GetConfig("Основные настройки ранения", "Шанс упасть от любой пули", ref CONF_WoundFromDamageChance);
            GetConfig("Основные настройки ранения", "Дополнительный шанс встать, при метаболизме > 250", ref CONF_StopWoundFromMetabolism);
            GetConfig("Основные настройки ранения", "Отдельные шансы встать по привилегии", ref CONF_CustomChances);
            
            GetConfig("Расширенные настройки ранения", "Разрешить поднимать игроков уколом шприца?", ref CONF_CanEndWoundBySyringe);
            GetConfig("Расширенные настройки ранения", "Включить отрицательные эффекты при подъеме шприцом / предметом", ref CONF_ShakeAfterWoundEnd);
            //GetConfig("Расширенные настройки ранения", "Отображать текст при окончании ранения, ключ - рамки нехватаюших очков, значение - сообщение", ref CONF_CustomMessages);
            
            GetConfig("Поднимающий предмет", "Разрешить крафтить дефибриллятор, который позволяет досрочно встать", ref CONF_CanCraftSpecialItem);
            GetConfig("Поднимающий предмет", "Стандартное количество 'дефибрилляторов' для нового игрока", ref CONF_DefaultDef);
            GetConfig("Поднимающий предмет", "Предметы необходимые для крафта дефибриллятора", ref CONF_SpecialItemReceipt);
            GetConfig("Поднимающий предмет", "Дополнительное изображение для дефибриллятора", ref CONF_PictureURL);
            
            SaveConfig();
        }

        private void OnServerInitialized()
        {		
            instance = this;
            LoadDefaultConfig();
            
            if (CONF_PictureURL != "")
                ImageLibrary.Call("AddImage", CONF_PictureURL, "UI_CW_Custom");

            if (Interface.Oxide.DataFileSystem.ExistsDatafile("PlayerItems"))
                PlayerRecovery = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, int>>("PlayerItems");
            
            foreach (var check in CONF_CustomChances)
            {
                PrintWarning($"Зарегистрировали {check.Key}");
                permission.RegisterPermission(check.Key, this);
            }
            
            BasePlayer.activePlayerList.ForEach(OnPlayerInit);
            SaveData();
        }

        #endregion

        #region Hooks
        
        private void OnPlayerDie(BasePlayer player, HitInfo info)
        {
            player.GetComponent<PlayerRecover>()?.DisableObject(false);
            return;
        }

        private void OnPlayerRespawn(BasePlayer player)
        {
            player.GetComponent<PlayerRecover>()?.DisableObject(false);
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            player.GetComponent<PlayerRecover>()?.DisableObject(false);
        }
        
        private void OnPlayerRecover(BasePlayer player)
        {
            NextTick(() =>
            {
                if (player != null && !player.IsNpc && player.GetComponent<NPCPlayer>() == null && player.GetComponent<PlayerRecover>() != null && !player.IsDead())
                    player.GetComponent<PlayerRecover>().DisableObject(false);
            });
            return;
        }
        
        private void OnHealingItemUse(MedicalTool tool, BasePlayer player)
        {
            if (tool.ShortPrefabName == "syringe_medical.entity")
            {
                var healingPlayer = tool.GetOwnerPlayer();
                if (healingPlayer != null && healingPlayer.IsWounded())
                {
                    player.ChatMessage($"Игрок поднял вас <color=#FF5733>медицинским шприцом</color>");
                    player.StopWounded();
            
                    player.GetComponent<PlayerRecover>()?.DisableObject(false);
                    if (CONF_ShakeAfterWoundEnd)
                    {
                        StartShake(player, 0);
                    }
                }
            }
        }

        private void StartShake(BasePlayer player, float amount)
        {
            if (Math.Abs(amount - 0.25f * 100) < 0.5 || player.IsDead())
                return;
            
            Effect effect = new Effect(ShakeEffects.GetRandom(), player, 0, new Vector3(), new Vector3());
            EffectNetwork.Send(effect, player.Connection);
            amount += 0.25f;

            timer.Once(0.25f, () => StartShake(player, amount));
        }

        private void OnPlayerInit(BasePlayer player)
        {
            if (!PlayerRecovery.ContainsKey(player.userID))
                PlayerRecovery.Add(player.userID, CONF_DefaultDef);
        }

        private void OnPlayerWound(BasePlayer player)
        {
            if (player == null || player.IsNpc || player.GetComponent<NPCPlayer>() != null)
                return;
            
            NextTick(() =>
            {
                if (player.IsDead())
                    return;
                
                if (CONF_DisableWound)
                {
                    player.Die();
                }
                else
                {
                    if (player.GetComponent<PlayerRecover>() == null)
                        player.gameObject.AddComponent<PlayerRecover>();
                }
            });
            return;
        }

        private void Unload()
        {
            foreach (var obj in UnityEngine.Object.FindObjectsOfType<PlayerRecover>())
                UnityEngine.Object.Destroy(obj);
            
            SaveData();
        }

        #endregion

        #region Functions

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("PlayerItems", PlayerRecovery);
            timer.Once(300, SaveData);
        }

        private int GetWakeChance(BasePlayer player)
        {
            int result = CONF_WoundEndChance;
            foreach (var check in CONF_CustomChances.OrderByDescending(p => p.Value))
            {
                if (permission.UserHasPermission(player.UserIDString, check.Key))
                {
                    result = check.Value;
                    break;
                }
            }

            if (player.metabolism.calories.value > 250)
                result += CONF_StopWoundFromMetabolism;
            
            return result;
        }

        #endregion

        #region GUI

        private static void UI_DrawWakeChances(BasePlayer player)
        {
            PlayerRecover playerRecover = player.GetComponent<PlayerRecover>();
            if (playerRecover != null)
            {
                CuiElementContainer container = new CuiElementContainer();
                CuiHelper.DestroyUi(player, UI_LayerChance);
                int wakeChance = playerRecover.endChance;
            
                container.Add(new CuiElement
                {
                    Parent = "Overlay",
                    Name = UI_LayerChance,
                    Components =
                    {
                        new CuiImageComponent { FadeIn = 1f, Sprite = "assets/content/ui/ui.background.tiletex.psd", Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.7" },
                        new CuiRectTransformComponent { AnchorMin = "0.447916 0.3138872", AnchorMax = "0.447916 0.3138872", OffsetMax = "133.3333 82.6666" }
                    }
                });
                
                container.Add(new CuiElement
                {
                    Parent = UI_LayerChance,
                    Components =
                    {
                        new CuiTextComponent { FadeIn = 1f, Text = wakeChance.ToString() + "%", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FontSize = 60 },
                        new CuiRectTransformComponent { AnchorMin = "0 0.06799136", AnchorMax = "1 1.153219" }
                    }
                });
                container.Add(new CuiElement
                {
                    Parent = UI_LayerChance,
                    Components =
                    {
                        new CuiTextComponent { FadeIn = 1f, Text = "ШАНС ВСТАТЬ", Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, FontSize = 16 },
                        new CuiRectTransformComponent { AnchorMin = "0 0.04034095", AnchorMax = "1 0.3145292" }
                    }
                });
                
                CuiHelper.AddUi(player, container);
            }
        }

        private static void UI_DrawLeftTime(BasePlayer player)
        {
            PlayerRecover playerRecover = player.GetComponent<PlayerRecover>();
            if (playerRecover != null)
            {
                int leftTime = (int) (CONF_WoundTime - player.secondsSinceWoundedStarted);
                CuiElementContainer container = new CuiElementContainer();
                if (!playerRecover.timeDrawed)
                {
                    CuiHelper.DestroyUi(player, UI_LayerTime);
                
                    container.Add(new CuiElement
                    {
                        Parent = "Overlay",
                        Name = UI_LayerTime,
                        Components =
                        {
                            new CuiImageComponent { FadeIn = 1f, Sprite = "assets/content/ui/ui.background.tiletex.psd", Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.7" },
                            new CuiRectTransformComponent { AnchorMin = "0.4479166 0.1212941", AnchorMax = "0.4479166 0.1212941", OffsetMax = "133.3333 133.3333" }
                        }
                    });
                    
                    container.Add(new CuiElement
                    {
                        Name = UI_LayerTime + ".LeftTime",
                        Parent = UI_LayerTime,
                        Components =
                        {
                            new CuiTextComponent { FadeIn = 1f, Text = leftTime.ToString(), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FontSize = 80 },
                            new CuiRectTransformComponent { AnchorMin = "0 0.1650116", AnchorMax = "1 1.035" }
                        }
                    });
                    container.Add(new CuiElement
                    {
                        Parent = UI_LayerTime,
                        Components =
                        {
                            new CuiTextComponent { FadeIn = 1f, Text = "СЕКУНД", Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, FontSize = 25 },
                            new CuiRectTransformComponent { AnchorMin = "0 -0.07499988", AnchorMax = "1 0.4250001" }
                        }
                    });

                    playerRecover.timeDrawed = true;
                }
                else
                {
                    CuiHelper.DestroyUi(player, UI_LayerTime + ".LeftTime");
                    container.Add(new CuiElement
                    {
                        Name = UI_LayerTime + ".LeftTime",
                        Parent = UI_LayerTime,
                        Components =
                        {
                            new CuiTextComponent { FadeIn = 1f, Text = leftTime.ToString(), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FontSize = 80 },
                            new CuiRectTransformComponent { AnchorMin = "0 0.1650116", AnchorMax = "1 1.035" }
                        }
                    });
                }
                
                CuiHelper.AddUi(player, container);
            }
        }

        private static void UI_DrawItemRecovery(BasePlayer player)
        {
            PlayerRecover playerRecover = player.GetComponent<PlayerRecover>();
            if (playerRecover != null)
            {
                CuiElementContainer container = new CuiElementContainer();
                CuiHelper.DestroyUi(player, UI_LayerItem);

                container.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    RectTransform = { AnchorMin = "0.8369792 0.6129634", AnchorMax = "0.8369792 0.6129634", OffsetMax = "200 284.66666" },
                    Image = { Color = "0 0 0 0" }
                }, "Overlay", UI_LayerItem); 
                
                container.Add(new CuiElement
                {
                    Parent = UI_LayerItem,
                    Components =
                    {
                        new CuiImageComponent { FadeIn = 1f, Sprite = "assets/content/ui/ui.background.tiletex.psd", Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.7" },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
                });
                
                container.Add(new CuiElement
                {
                    Name = UI_LayerItem + ".Avatar",
                    Parent = UI_LayerItem,
                    Components =
                    {
                        new CuiRawImageComponent { Png = (string) instance.ImageLibrary.Call("GetImage", "UI_CW_Custom") },
                        new CuiRectTransformComponent { AnchorMin = "0 0.2963888", AnchorMax = "1 1", OffsetMin = "15 15", OffsetMax = "-15 -15" }
                    }
                });
                
                container.Add(new CuiElement
                {
                    Parent = UI_LayerItem + ".Avatar",
                    Components =
                    {
                        new CuiTextComponent { FadeIn = 1f, Text = $"Осталось: {PlayerRecovery[player.userID]} шт.", Font = "robotocondensed-regular.ttf", Align = TextAnchor.LowerRight, FontSize = 10 },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
                });
                
                container.Add(new CuiElement
                {
                    Parent = UI_LayerItem,
                    Components =
                    {
                        new CuiTextComponent { FadeIn = 1f, Text = "Моментально поставит вас на ноги", Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, FontSize = 16 },
                        new CuiRectTransformComponent { AnchorMin = "0.03 0.09833303", AnchorMax = "0.97 0.3583333" }
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0.02500007", AnchorMax = "1 0.1250005", OffsetMin = "7 0", OffsetMax = "-7 0" },
                    Button = { Color = "1 1 1 1", Command = "UI_CW_Handler recoverUser" },
                    Text = { Text = "ИСПОЛЬЗОВАТЬ", FontSize = 18, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, Color = "0 0 0 1" }
                }, UI_LayerItem);

                CuiHelper.AddUi(player, container);
            }
        }

        #endregion

        #region Commands

        [ChatCommand("recover")]
        private void cmdChatRecover(BasePlayer player, string command, string[] args)
        {
            if (!CONF_CanCraftSpecialItem)
                return;
            if (args.Length == 0)
            {
                string message = "Предметы необходимые для крафта <color=#FF5733>дефибриллятора</color>:";
                foreach (var check in CONF_SpecialItemReceipt)
                    message += $"\n - {ItemManager.FindItemDefinition(check.Key).displayName.english}: {check.Value} шт.";
                message += $"\n/recover craft - скрафтить <color=#FF5733>дефибриллятор</color>";
                
                player.ChatMessage(message);
            }
            else if (args[0].ToLower() == "craft")
            {
                foreach (var check in CONF_SpecialItemReceipt)
                {
                    int currentAmount = player.inventory.GetAmount(ItemManager.FindItemDefinition(check.Key).itemid);
                    if (currentAmount < check.Value)
                    {
                        player.ChatMessage($"Вам не хватает: {ItemManager.FindItemDefinition(check.Key).displayName.english}: {check.Value - currentAmount} шт.");
                        return;
                    }
                }

                foreach (var check in CONF_SpecialItemReceipt)
                {
                    player.inventory.Take(null, ItemManager.FindItemDefinition(check.Key).itemid, check.Value);
                }

                player.ChatMessage($"Вы успешно скрафтили новый <color=#FF5733>дефибриллятор</color>!\n" +
                                   $"Новое количество: {++PlayerRecovery[player.userID]} шт.");
            }
        }
        
        [ConsoleCommand("UI_CW_Handler")]
        private void consoleHandler(ConsoleSystem.Arg args)
        {    
            BasePlayer player = args.Player();
            if (player == null)
                return;

            if (!args.HasArgs(1))
                return;

            if (args.Args[0].ToLower() == "recoveruser")
            {
                int playerLeft = PlayerRecovery[player.userID];
                if (playerLeft == 0)
                {
                    player.ChatMessage($"У вас <color=#FF5733>закончились</color> дефибрилляторы\n" +
                                       $"Скрафтить их вы можете при помощи: <color=#FF5733>/recover</color>");
                    return;
                }

                player.ChatMessage($"Вы успешно применили <color=#FF5733>дефибриллятор</color>\n" +
                                   $"У вас осталось: <color=#FF5733>{--PlayerRecovery[player.userID]} шт.</color>");
                player.StopWounded();
                
                player.GetComponent<PlayerRecover>()?.DisableObject(false);
                if (CONF_ShakeAfterWoundEnd)
                {
                    StartShake(player,  0);    
                }
            }
        }

        [ConsoleCommand("cw")]
        private void cmdAdminCommnand(ConsoleSystem.Arg args)
        { 
            if (args.Player() != null)
                return;
            if (!args.HasArgs(2))
            {
                PrintError($"Используйте команду правильно: cw <steamId> <amount>");
                return;
            }

            ulong targetId;
            if (!ulong.TryParse(args.Args[0], out targetId))
            {
                PrintError("Вы указали не ID в первом аргументе");
                return;
            }

            int amount;
            if (!int.TryParse(args.Args[1], out amount))
            {
                PrintError("Вы указали не число во втором аргументе!");
                return;
            }

            if (!PlayerRecovery.ContainsKey(targetId))
            {
                PrintError($"Игрок с указанным ID не найден!");
                return;
            }

            PlayerRecovery[targetId] += amount;
            PrintWarning($"Число д-в для игрока изменено. Новое количество: {PlayerRecovery[targetId]}");
        }

        #endregion

        #region Utils
        
        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        private void GetConfig<T>(string menu, string key, ref T varObject)
        {
            if (Config[menu, key] != null)
            {
                varObject = Config.ConvertValue<T>(Config[menu, key]);
            }
            else
            {
                Config[menu, key] = varObject;
            }
        }

        #endregion
    }
}

// --- End of file: CustomWound.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Clans (3).cs ---
// --- Original Local Path: Clans (3).cs ---

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using System.Text.RegularExpressions;
using UnityEngine;
using Rust;
using ProtoBuf;
using Facepunch.Extend;
using Oxide.Game.Rust;
using Oxide.Game.Rust.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Clans", "FuJiCuRa", "2.14.4", ResourceId = 14)]
    [Description("Clans plugin with Allies, inbuilt FriendlyFire and much more...")]
    public class Clans : RustPlugin
    {
        private bool Changed;
        private bool Initialized;
        private static Clans cc = null;
        private bool newSaveDetected = false;
        private List<ulong> manuallyEnabledBy = new List<ulong>();
        private HashSet<ulong> bypass = new HashSet<ulong>();
        private Dictionary<string, DateTime> notificationTimes = new Dictionary<string, DateTime>();
        private List<int> creationTimes = new List<int>();
        private static DateTime Epoch = new DateTime(1970, 1, 1);
        private static double MaxUnixSeconds = (DateTime.MaxValue - Epoch).TotalSeconds;
        public Dictionary<string, Clan> clans = new Dictionary<string, Clan>();
        public Dictionary<string, string> clansSearch = new Dictionary<string, string>();
        private List<string> purgedClans = new List<string>();
        private Dictionary<string, List<string>> pendingPlayerInvites = new Dictionary<string, List<string>>();
        private Regex tagReExt;
        private Dictionary<string, Clan> clanCache = new Dictionary<string, Clan>();

        private List<object> filterDefaults()
        {
            List<object> dp = new List<object>();
            dp.Add("admin");
            dp.Add("mod");
            dp.Add("owner");
            return dp;
        }

        public int limitMembers;
        private int limitModerators;
        public int limitAlliances;
        private int tagLengthMin;
        private int tagLengthMax;
        private int inviteValidDays;
        private int friendlyFireNotifyTimeout;
        private string allowedSpecialChars;
        public bool enableFFOPtion;
        private bool enableAllyFFOPtion;
        private bool enableWordFilter;
        private bool enableClanTagging;
        public bool enableClanAllies;
        private bool forceAllyFFNoDeactivate;
        private bool forceClanFFNoDeactivate;
        private bool enableWhoIsOnlineMsg;
        private bool enableComesOnlineMsg;
        private bool forceNametagsOnTagging;
        private int authLevelRename;
        private int authLevelDisband;
        private int authLevelInvite;
        private int authLevelKick;
        private int authLevelCreate;
        private int authLevelPromoteDemote;
        private int authLevelClanInfo;
        private bool purgeOldClans;
        private int notUpdatedSinceDays;
        private bool listPurgedClans;
        private bool wipeClansOnNewSave;
        private bool useProtostorageClandata;
        private string consoleName;
        private string broadcastPrefix;
        private string broadcastPrefixAlly;
        private string broadcastPrefixColor;
        private string broadcastPrefixFormat;
        private string broadcastMessageColor;
        private string colorCmdUsage;
        private string colorTextMsg;
        private string colorClanNamesOverview;
        private string colorClanFFOff;
        private string colorClanFFOn;
        private string pluginPrefix;
        private string pluginPrefixColor;
        private string pluginPrefixREBORNColor;
        private bool pluginPrefixREBORNShow;
        private string pluginPrefixFormat;
        private string clanServerColor;
        private string clanOwnerColor;
        private string clanCouncilColor;
        private string clanModeratorColor;
        private string clanMemberColor;
        private bool setHomeOwner;
        private bool setHomeModerator;
        private bool setHomeMember;
        private string chatCommandClan;
        private string chatCommandFF;
        private string chatCommandAllyChat;
        private string chatCommandClanChat;
        private string chatCommandClanInfo;
        private string subCommandClanHelp;
        private string subCommandClanAlly;
        private bool usePermGroups;
        private string permGroupPrefix;
        private bool usePermToCreateClan;
        private string permissionToCreateClan;
        private bool usePermToJoinClan;
        private string permissionToJoinClan;
        private string clanTagColorBetterChat;
        private int clanTagSizeBetterChat;
        private string clanTagOpening;
        private string clanTagClosing;
        private bool clanChatDenyOnMuted;
        public static bool useRelationshipManager;
        private bool teamUiWasDisabled;
        private bool useRankColorsPanel;
        private bool disableManageFunctions;
        private bool allowButtonLeave;
        private bool allowButtonKick;
        private bool allowDirectInvite;
        private bool allowPromoteLeader;
        private bool logClanChanges;

        private List<object> wordFilter = new List<object>();

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            Dictionary<string, object> data = Config[menu] as Dictionary<string,
                object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }

            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }

            return value;
        }

        private void LoadVariables()
        {
            bool configremoval = false;
            wordFilter = (List<object>) GetConfig("WordFilter", "Words", filterDefaults());
            limitMembers = Convert.ToInt32(GetConfig("Limits", "limitMembers", 8));
            limitModerators = Convert.ToInt32(GetConfig("Limits", "limitModerators", 2));
            limitAlliances = Convert.ToInt32(GetConfig("Limits", "limitAlliances", 2));
            tagLengthMin = Convert.ToInt32(GetConfig("Limits", "tagLengthMin", 2));
            tagLengthMax = Convert.ToInt32(GetConfig("Limits", "tagLengthMax", 6));
            inviteValidDays = Convert.ToInt32(GetConfig("Limits", "inviteValidDays", 1));
            friendlyFireNotifyTimeout = Convert.ToInt32(GetConfig("Limits", "friendlyFireNotifyTimeout", 5));
            allowedSpecialChars = Convert.ToString(GetConfig("Limits", "allowedSpecialChars", "!²³"));
            enableFFOPtion = Convert.ToBoolean(GetConfig("Settings", "enableFFOPtion", true));
            enableAllyFFOPtion = Convert.ToBoolean(GetConfig("Settings", "enableAllyFFOPtion", true));
            forceAllyFFNoDeactivate = Convert.ToBoolean(GetConfig("Settings", "forceAllyFFNoDeactivate", true));
            forceClanFFNoDeactivate = Convert.ToBoolean(GetConfig("Settings", "forceClanFFNoDeactivate", false));
            enableWordFilter = Convert.ToBoolean(GetConfig("Settings", "enableWordFilter", true));
            enableClanTagging = Convert.ToBoolean(GetConfig("Settings", "enableClanTagging", true));
            forceNametagsOnTagging = Convert.ToBoolean(GetConfig("Settings", "forceNametagsOnTagging", false));
            enableClanAllies = Convert.ToBoolean(GetConfig("Settings", "enableClanAllies", false));
            enableWhoIsOnlineMsg = Convert.ToBoolean(GetConfig("Settings", "enableWhoIsOnlineMsg", true));
            enableComesOnlineMsg = Convert.ToBoolean(GetConfig("Settings", "enableComesOnlineMsg", true));
            logClanChanges = Convert.ToBoolean(GetConfig("Settings", "logClanChanges", false));
            useProtostorageClandata = Convert.ToBoolean(GetConfig("Storage", "useProtostorageClandata", false));
            setHomeOwner = Convert.ToBoolean(GetConfig("NTeleportation", "setHomeOwner", true));
            setHomeModerator = Convert.ToBoolean(GetConfig("NTeleportation", "setHomeModerator", true));
            setHomeMember = Convert.ToBoolean(GetConfig("NTeleportation", "setHomeMember", true));
            authLevelRename = Convert.ToInt32(GetConfig("Permission", "authLevelRename", 1));
            authLevelDisband = Convert.ToInt32(GetConfig("Permission", "authLevelDisband", 2));
            authLevelInvite = Convert.ToInt32(GetConfig("Permission", "authLevelInvite", 1));
            authLevelKick = Convert.ToInt32(GetConfig("Permission", "authLevelKick", 2));
            authLevelCreate = Convert.ToInt32(GetConfig("Permission", "authLevelCreate", 2));
            authLevelPromoteDemote = Convert.ToInt32(GetConfig("Permission", "authLevelPromoteDemote", 1));
            authLevelClanInfo = Convert.ToInt32(GetConfig("Permission", "authLevelClanInfo", 0));
            usePermGroups = Convert.ToBoolean(GetConfig("Permission", "usePermGroups", false));
            permGroupPrefix = Convert.ToString(GetConfig("Permission", "permGroupPrefix", "clan_"));
            usePermToCreateClan = Convert.ToBoolean(GetConfig("Permission", "usePermToCreateClan", false));
            permissionToCreateClan = Convert.ToString(GetConfig("Permission", "permissionToCreateClan", "clans.cancreate"));
            usePermToJoinClan = Convert.ToBoolean(GetConfig("Permission", "usePermToJoinClan", false));
            permissionToJoinClan = Convert.ToString(GetConfig("Permission", "permissionToJoinClan", "clans.canjoin"));
            purgeOldClans = Convert.ToBoolean(GetConfig("Purge", "purgeOldClans", false));
            notUpdatedSinceDays = Convert.ToInt32(GetConfig("Purge", "notUpdatedSinceDays", 14));
            listPurgedClans = Convert.ToBoolean(GetConfig("Purge", "listPurgedClans", false));
            wipeClansOnNewSave = Convert.ToBoolean(GetConfig("Purge", "wipeClansOnNewSave", false));
            consoleName = Convert.ToString(GetConfig("Formatting", "consoleName", "ServerOwner"));
            broadcastPrefix = Convert.ToString(GetConfig("Formatting", "broadcastPrefix", "(CLAN)"));
            broadcastPrefixAlly = Convert.ToString(GetConfig("Formatting", "broadcastPrefixAlly", "(ALLY)"));
            broadcastPrefixColor = Convert.ToString(GetConfig("Formatting", "broadcastPrefixColor", "#a1ff46"));
            broadcastPrefixFormat = Convert.ToString(GetConfig("Formatting", "broadcastPrefixFormat", "<color={0}>{1}</color> "));
            broadcastMessageColor = Convert.ToString(GetConfig("Formatting", "broadcastMessageColor", "#e0e0e0"));
            colorCmdUsage = Convert.ToString(GetConfig("Formatting", "colorCmdUsage", "#ffd479"));
            colorTextMsg = Convert.ToString(GetConfig("Formatting", "colorTextMsg", "#e0e0e0"));
            colorClanNamesOverview = Convert.ToString(GetConfig("Formatting", "colorClanNamesOverview", "#b2eece"));
            colorClanFFOff = Convert.ToString(GetConfig("Formatting", "colorClanFFOff", "#00ff00"));
            colorClanFFOn = Convert.ToString(GetConfig("Formatting", "colorClanFFOn", "#ff0000"));
            pluginPrefix = Convert.ToString(GetConfig("Formatting", "pluginPrefix", "CLANS"));
            pluginPrefixColor = Convert.ToString(GetConfig("Formatting", "pluginPrefixColor", "#ffa500"));
            pluginPrefixREBORNColor = Convert.ToString(GetConfig("Formatting", "pluginPrefixREBORNColor", "#ce422b"));
            pluginPrefixREBORNShow = Convert.ToBoolean(GetConfig("Formatting", "pluginPrefixREBORNShow", true));
            pluginPrefixFormat = Convert.ToString(GetConfig("Formatting", "pluginPrefixFormat", "<color={0}>{1}</color>: "));
            clanServerColor = Convert.ToString(GetConfig("Formatting", "clanServerColor", "#ff3333"));
            clanOwnerColor = Convert.ToString(GetConfig("Formatting", "clanOwnerColor", "#a1ff46"));
            clanCouncilColor = Convert.ToString(GetConfig("Formatting", "clanCouncilColor", "#b573ff"));
            clanModeratorColor = Convert.ToString(GetConfig("Formatting", "clanModeratorColor", "#74c6ff"));
            clanMemberColor = Convert.ToString(GetConfig("Formatting", "clanMemberColor", "#fcf5cb"));
            clanTagColorBetterChat = Convert.ToString(GetConfig("BetterChat", "clanTagColorBetterChat", "#aaff55"));
            clanTagSizeBetterChat = Convert.ToInt32(GetConfig("BetterChat", "clanTagSizeBetterChat", 15));
            clanTagOpening = Convert.ToString(GetConfig("BetterChat", "clanTagOpening", "["));
            clanTagClosing = Convert.ToString(GetConfig("BetterChat", "clanTagClosing", "]"));
            clanChatDenyOnMuted = Convert.ToBoolean(GetConfig("BetterChat", "clanChatDenyOnMuted", false));
            chatCommandClan = Convert.ToString(GetConfig("Commands", "chatCommandClan", "clan"));
            chatCommandFF = Convert.ToString(GetConfig("Commands", "chatCommandFF", "cff"));
            chatCommandAllyChat = Convert.ToString(GetConfig("Commands", "chatCommandAllyChat", "a"));
            chatCommandClanChat = Convert.ToString(GetConfig("Commands", "chatCommandClanChat", "c"));
            chatCommandClanInfo = Convert.ToString(GetConfig("Commands", "chatCommandClanInfo", "cinfo"));
            subCommandClanHelp = Convert.ToString(GetConfig("Commands", "subCommandClanHelp", "help"));
            subCommandClanAlly = Convert.ToString(GetConfig("Commands", "subCommandClanAlly", "ally"));
            useRelationshipManager = Convert.ToBoolean(GetConfig("Teaming", "useRelationshipManager", false));
            useRankColorsPanel = Convert.ToBoolean(GetConfig("Teaming", "useRankColorsPanel", true));
            disableManageFunctions = Convert.ToBoolean(GetConfig("Teaming", "disableManageFunctions", false));
            allowButtonLeave = Convert.ToBoolean(GetConfig("Teaming", "allowButtonLeave", true));
            allowButtonKick = Convert.ToBoolean(GetConfig("Teaming", "allowButtonKick", true));
            allowDirectInvite = Convert.ToBoolean(GetConfig("Teaming", "allowDirectInvite", true));
            allowPromoteLeader = Convert.ToBoolean(GetConfig("Teaming", "allowPromoteLeader", true));

            if ((Config.Get("Permission") as Dictionary<string, object>).ContainsKey("authLevelDelete"))
            {
                (Config.Get("Permission") as Dictionary<string, object>).Remove("authLevelDelete");
                configremoval = true;
            }

            SaveConf();

            if (!Changed && !configremoval)
                return;

            SaveConfig();
            Changed = false;
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {
                    "nopermtocreate",
                    "You got no rights to create a clan"
                },
                {
                    "nopermtojoin",
                    "You got no rights to join a clan"
                },
                {
                    "nopermtojoinbyinvite",
                    "The player {0} has no rights to join a clan"
                },
                {
                    "claninvite",
                    "You have been invited to join the clan: [{0}] '{1}'\nTo join, type: <color={2}>/clan join {0}</color>"
                },
                {
                    "comeonline",
                    "{0} has come online!"
                },
                {
                    "goneoffline",
                    "{0} has gone offline!"
                },
                {
                    "friendlyfire",
                    "{0} is a clan member and cannot be hurt.\nTo toggle clan friendlyfire type: <color={1}>/clan ff</color>"
                },
                {
                    "allyfriendlyfire",
                    "{0} is an ally member and cannot be hurt"
                },
                {
                    "notmember",
                    "You are currently not a member of a clan"
                },
                {
                    "youareownerof",
                    "You are the owner of:"
                },
                {
                    "youaremodof",
                    "You are a moderator of:"
                },
                {
                    "youarecouncilof",
                    "You are a council of:"
                },
                {
                    "youarememberof",
                    "You are a member of:"
                },
                {
                    "claninfo",
                    " [{0}] {1}"
                },
                {
                    "memberon",
                    "Members online: "
                },
                {
                    "overviewnamecolor",
                    "<color={0}>{1}</color>"
                },
                {
                    "memberoff",
                    "Members offline: "
                },
                {
                    "notmoderator",
                    "You need to be a moderator of your clan to use this command"
                },
                {
                    "pendinvites",
                    "Pending invites: "
                },
                {
                    "bannedwords",
                    "The clan tag contains banned words"
                },
                {
                    "viewthehelp",
                    "To view more commands, type: <color={0}>/{1} help</color>"
                },
                {
                    "usagecreate",
                    "Usage - <color={0}>/clan create \"TAG\" \"Description\"</color>"
                },
                {
                    "hintlength",
                    "Clan tags must be {0} to {1} characters long"
                },
                {
                    "hintchars",
                    "Clan tags must contain only 'a-z' 'A-Z' '0-9' '{0}'"
                },
                {
                    "providedesc",
                    "Please provide a short description of your clan (No RichText allowed)"
                },
                {
                    "tagblocked",
                    "There is already a clan with this tag"
                },
                {
                    "nownewowner",
                    "You are now the owner of the clan [{0}] \"{1}\""
                },
                {
                    "inviteplayers",
                    "To invite new members, type: <color={0}>/clan invite <partialNameOrId></color>"
                },
                {
                    "usageinvite",
                    "Usage - <color={0}>/clan invite <partialNameOrId></color>"
                },
                {
                    "nosuchplayer",
                    "No such player|id or name not unique: {0}"
                },
                {
                    "alreadymember",
                    "This player is already a member of your clan: {0}"
                },
                {
                    "alreadyinvited",
                    "This player has already been invited to your clan: {0}"
                },
                {
                    "alreadyinclan",
                    "This player is already in a clan: {0}"
                },
                {
                    "invitebroadcast",
                    "{0} invited {1} to the clan"
                },
                {
                    "usagewithdraw",
                    "Usage: <color={0}>/clan withdraw <partialNameOrId></color>"
                },
                {
                    "notinvited",
                    "This player has not been invited to your clan: {0}"
                },
                {
                    "canceledinvite",
                    "{0} canceled the invitation of {1}"
                },
                {
                    "usagejoin",
                    "Usage: <color={0}>/clan join \"clantag\"</color>"
                },
                {
                    "youalreadymember",
                    "You are already a member of a clan"
                },
                {
                    "younotinvited",
                    "You have not been invited to join this clan"
                },
                {
                    "reachedmaximum",
                    "This clan has already reached the maximum number of members"
                },
                {
                    "broadcastformat",
                    "<color={0}>{1}</color>: {2}"
                },
                {
                    "allybroadcastformat",
                    "[{0}] <color={1}>{2}</color>: {3}"
                },
                {
                    "clanrenamed",
                    "{0} renamed your clan to: [{1}]"
                },
                {
                    "yourenamed",
                    "You have renamed the clan [{0}] to [{1}]"
                },
                {
                    "youcreated",
                    "You have created the clan [{0}]"
                },
                {
                    "clandeleted",
                    "{0} deleted your clan"
                },
                {
                    "youdeleted",
                    "You have deleted the clan [{0}]"
                },
                {
                    "noclanfound",
                    "There is no clan with that tag [{0}]"
                },
                {
                    "renamerightsowner",
                    "You need to be a server owner to rename clans"
                },
                {
                    "deleterightsowner",
                    "You need to be a server owner to delete clans"
                },
                {
                    "clandisbanded",
                    "Your current clan has been disbanded forever"
                },
                {
                    "needclanowner",
                    "You need to be the owner of your clan to use this command"
                },
                {
                    "needclanownercouncil",
                    "You need to be the owner or a council to use this command"
                },
                {
                    "usagedisband",
                    "Usage: <color={0}>/clan disband forever</color>"
                },
                {
                    "usagepromote",
                    "Usage: <color={0}>/clan promote <partialNameOrId></color>"
                },
                {
                    "playerjoined",
                    "{0} has joined the clan!"
                },
                {
                    "waskicked",
                    "{0} kicked {1} from the clan"
                },
                {
                    "werekicked",
                    "{0} kicked you from the clan"
                },
                {
                    "modownercannotkicked",
                    "The player {0} is an owner or moderator and cannot be kicked"
                },
                {
                    "ownercannotbepromoted",
                    "The player {0} is the owner and cannot be promoted"
                },
                {
                    "ownercannotbedemoted",
                    "The player {0} is the owner and cannot be demoted"
                },
                {
                    "notmembercannotkicked",
                    "The player {0} is not a member of your clan"
                },
                {
                    "usageff",
                    "Usage: <color={0}>/clan ff</color> toggles your current FriendlyFire status"
                },
                {
                    "usagekick",
                    "Usage: <color={0}>/clan kick <partialNameOrId></color>"
                },
                {
                    "playerleft",
                    "{0} has left the clan"
                },
                {
                    "youleft",
                    "You have left your current clan"
                },
                {
                    "usageleave",
                    "Usage: <color={0}>/clan leave</color>"
                },
                {
                    "notaclanmember",
                    "The player {0} is not a member of your clan"
                },
                {
                    "alreadyowner",
                    "The player {0} is already the owner of your clan"
                },
                {
                    "alreadyamod",
                    "The player {0} is already a moderator of your clan"
                },
                {
                    "alreadyacouncil",
                    "The player {0} is already a council of your clan"
                },
                {
                    "alreadyacouncilset",
                    "The position of the council is already awarded"
                },
                {
                    "maximummods",
                    "This clan has already reached the maximum number of moderators"
                },
                {
                    "playerpromoted",
                    "{0} promoted {1} to moderator"
                },
                {
                    "playerpromotedcouncil",
                    "{0} promoted {1} to council"
                },
                {
                    "playerpromotedowner",
                    "{0} promoted {1} to new owner"
                },
                {
                    "usagedemote",
                    "Usage: <color={0}>/clan demote <name></color>"
                },
                {
                    "notamoderator",
                    "The player {0} is not a moderator of your clan"
                },
                {
                    "notpromoted",
                    "The player {0} is not a moderator or council of your clan"
                },
                {
                    "playerdemoted",
                    "{0} demoted {1} to a member"
                },
                {
                    "councildemoted",
                    "{0} demoted {1} to a moderator"
                },
                {
                    "noactiveally",
                    "Your clan has no current alliances"
                },
                {
                    "yourffstatus",
                    "Your FriendlyFire:"
                },
                {
                    "yourclanallies",
                    "Your Clan allies:"
                },
                {
                    "allyinvites",
                    "Ally invites:"
                },
                {
                    "allypending",
                    "Ally requests:"
                },
                {
                    "allyReqHelp",
                    "Offer an alliance to another clan"
                },
                {
                    "allyAccHelp",
                    "Accept an alliance from another clan"
                },
                {
                    "allyDecHelp",
                    "Decline an alliance from another clan"
                },
                {
                    "allyCanHelp",
                    "Cancel an alliance with another clan"
                },
                {
                    "reqAlliance",
                    "[{0}] has requested a clan alliance"
                },
                {
                    "invitePending",
                    "You already have a pending alliance invite for [{0}]"
                },
                {
                    "clanNoExist",
                    "The clan [{0}] does not exist"
                },
                {
                    "alreadyAllies",
                    "You are already allied with"
                },
                {
                    "allyProvideName",
                    "You need to provide a Clan name"
                },
                {
                    "allyLimit",
                    "You already have the maximum allowed ally limit"
                },
                {
                    "allyAccLimit",
                    "You can not accept the alliance with {0}. You reached the limit"
                },
                {
                    "allyCancel",
                    "You have cancelled your alliance with [{0}]"
                },
                {
                    "allyCancelSucc",
                    "{0} has cancelled your clan alliance"
                },
                {
                    "noAlly",
                    "Your clans have no alliance with each other"
                },
                {
                    "noAllyInv",
                    "You do not have a alliance invite from [{0}]"
                },
                {
                    "allyInvWithdraw",
                    "You have cancelled your request to [{0}]"
                },
                {
                    "allyDeclined",
                    "You have declined the clan alliance from [{0}]"
                },
                {
                    "allyDeclinedSucc",
                    "[{0}] has declined your alliance request"
                },
                {
                    "allyReq",
                    "You have requested a clan alliance from [{0}]"
                },
                {
                    "allyAcc",
                    "You have accepted the clan alliance from [{0}]"
                },
                {
                    "allyAccSucc",
                    "[{0}] has accepted your alliance request"
                },
                {
                    "allyPendingInfo",
                    "Your clan has pending ally request(s). Check those in the clan overview"
                },
                {
                    "clanffdisabled",
                    "You have <color={0}>disabled</color> friendly fire for your clan.\nThey are safe!"
                },
                {
                    "clanffenabled",
                    "You have <color={0}>enabled</color> friendly fire for your clan.\nTake care!"
                },
                {
                    "yourname",
                    "YOU"
                },
                {
                    "helpavailablecmds",
                    "Available commands:"
                },
                {
                    "helpinformation",
                    "Display your clan information"
                },
                {
                    "helpmessagemembers",
                    "Send a message to all members"
                },
                {
                    "helpmessageally",
                    "Send a message to all allied members"
                },
                {
                    "helpcreate",
                    "Create a new clan"
                },
                {
                    "helpjoin",
                    "Join a clan by invitation"
                },
                {
                    "helpleave",
                    "Leave your clan"
                },
                {
                    "helptoggleff",
                    "Toggle friendlyfire status"
                },
                {
                    "helpinvite",
                    "Invite a player"
                },
                {
                    "helpwithdraw",
                    "Cancel an invite"
                },
                {
                    "helpkick",
                    "Kick a member"
                },
                {
                    "helpallyoptions",
                    "Lists the ally options"
                },
                {
                    "helppromote",
                    "Promote a member"
                },
                {
                    "helpdemote",
                    "Demote a member"
                },
                {
                    "helpdisband",
                    "Disband your clan (no undo)"
                },
                {
                    "helpmoderator",
                    "Moderator"
                },
                {
                    "helpowner",
                    "Owner"
                },
                {
                    "helpcommands",
                    "commands:"
                },
                {
                    "helpconsole",
                    "Open F1 console and type:"
                },
                {
                    "clanArgCreate",
                    "create"
                },
                {
                    "clanArgInvite",
                    "invite"
                },
                {
                    "clanArgLeave",
                    "leave"
                },
                {
                    "clanArgWithdraw",
                    "withdraw"
                },
                {
                    "clanArgJoin",
                    "join"
                },
                {
                    "clanArgPromote",
                    "promote"
                },
                {
                    "clanArgDemote",
                    "demote"
                },
                {
                    "clanArgFF",
                    "ff"
                },
                {
                    "clanArgAlly",
                    "ally"
                },
                {
                    "clanArgHelp",
                    "help"
                },
                {
                    "clanArgKick",
                    "kick"
                },
                {
                    "clanArgDisband",
                    "disband"
                },
                {
                    "clanArgForever",
                    "forever"
                },
                {
                    "clanArgNameId",
                    "<partialNameOrId>"
                },
                {
                    "allyArgRequest",
                    "request"
                },
                {
                    "allyArgRequestShort",
                    "req"
                },
                {
                    "allyArgAccept",
                    "accept"
                },
                {
                    "allyArgAcceptShort",
                    "acc"
                },
                {
                    "allyArgDecline",
                    "decline"
                },
                {
                    "allyArgDeclineShort",
                    "dec"
                },
                {
                    "allyArgCancel",
                    "cancel"
                },
                {
                    "allyArgCancelShort",
                    "can"
                },
                {
                    "clanchatmuted",
                    "You may not clanchat, you are muted"
                },
            }, this);
        }

        private void Init()
        {
            LoadVariables();
            if (clanTagOpening == null || clanTagOpening.Length > 1 || clanTagOpening == "<" || clanTagOpening == ">")
                clanTagOpening = "[";

            if (clanTagClosing == null || clanTagClosing.Length > 1 || clanTagClosing == "<" || clanTagClosing == ">")
                clanTagClosing = "]";

            LoadDefaultMessages();

            Initialized = false;

            permission.RegisterPermission(permissionToCreateClan, this);
            permission.RegisterPermission(permissionToJoinClan, this);

            cmd.AddChatCommand(chatCommandFF, this, "cmdChatClanFF");
            cmd.AddChatCommand(chatCommandClan, this, "cmdChatClan");
            cmd.AddConsoleCommand(chatCommandClan, this, "ccmdChatClan");
            cmd.AddChatCommand(chatCommandClanChat, this, "cmdChatClanchat");
            cmd.AddChatCommand(chatCommandAllyChat, this, "cmdChatAllychat");
            cmd.AddChatCommand(chatCommandClanInfo, this, "cmdChatClanInfo");
            cmd.AddChatCommand(chatCommandClan + subCommandClanHelp, this, "cmdChatClanHelp");
            cmd.AddChatCommand(chatCommandClan + subCommandClanAlly, this, "cmdChatClanAlly");

            if (enableClanTagging)
                Interface.CallHook("API_RegisterThirdPartyTitle", this, new Func<IPlayer, string>(getFormattedClanTag));
        }

        private void Loaded()
        {
            cc = this;
        }

        private void OnServerSave()
        {
            SaveData();
        }

        private void OnNewSave()
        {
            if (wipeClansOnNewSave)
                newSaveDetected = true;
        }

        private void Unload()
        {
            if (!Initialized)
                return;

            SaveData();

            foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
                DoCleanUp(player);

            foreach (BasePlayer player in BasePlayer.sleepingPlayerList.ToList())
                DoCleanUp(player);

            foreach (KeyValuePair<string, Clan> clan in clans.ToList())
            {
                clans[clan.Key].OnUnload();
                clans[clan.Key] = null;
            }

            cc = null;
        }

        private void OnServerInitialized()
        {
            teamUiWasDisabled = false;
            if (useRelationshipManager)
            {
                Subscribe(nameof(OnServerCommand));
                if (!RelationshipManager.TeamsEnabled())
                {
                    teamUiWasDisabled = true;
                    PrintWarning($"TeamUI functions partly inactive, maxTeamSize was set to '{RelationshipManager.maxTeamSize}'");
                }
            }
            else
            {
                Unsubscribe(nameof(OnServerCommand));
            }

            if (enableClanTagging)
                Subscribe(nameof(OnPluginLoaded));
            else Unsubscribe(nameof(OnPluginLoaded));

            object obj = LoadData();

            Rust.Global.Runner.StartCoroutine(ServerInitialized(obj));
        }

        private IEnumerator ServerInitialized(object obj)
        {
            if (obj != null)
                InitializeClans((bool) obj);

            if (purgeOldClans)
                Puts($"Valid clans loaded: '{clans.Count}'");

            if (purgeOldClans && purgedClans.Count() > 0)
            {
                Puts($"Old Clans purged: '{purgedClans.Count}'");
                if (listPurgedClans)
                {
                    foreach (string purged in purgedClans)
                        Puts($"Purged > {purged}");
                }
            }

            yield return CoroutineEx.waitForSeconds(2f);

            AllyRemovalCheck();


            tagReExt = new Regex("[^a-zA-Z0-9" + allowedSpecialChars + "]");
                        
            foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
                SetupPlayer(player);

            foreach (BasePlayer player in BasePlayer.sleepingPlayerList.ToList())
                SetupPlayer(player);

            foreach (KeyValuePair<string, Clan> clan in clans)
                clan.Value.OnUpdate(true);

            Initialized = true;
            yield return null;
        }

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (useRelationshipManager && arg != null && arg.cmd != null)
            {
                if (RelationshipManager.TeamsEnabled() || teamUiWasDisabled)
                {
                    if (arg.cmd.Name.ToLower() == "maxteamsize" && arg.FullString != string.Empty)
                    {
                        int i = arg.GetInt(0, 0);
                        if (i > 0 && teamUiWasDisabled)
                        {
                            teamUiWasDisabled = false;
                            Puts($"TeamUI functions full activated");
                            return null;
                        }
                        else if (i < 1)
                        {
                            teamUiWasDisabled = true;
                            PrintWarning($"TeamUI functions partly inactive, maxTeamSize was set to '{i}'");
                            return null;
                        }
                    }

                    Clan obj;
                    if (!RelationshipManager.TeamsEnabled())
                        return null;

                    if (arg.Connection != null && clanCache.TryGetValue(arg.Connection.userid.ToString(), out obj) && arg.cmd.Parent.ToLower() == "relationshipmanager")
                    {
                        if (disableManageFunctions)
                            return false;

                        if (arg.cmd.Name.ToLower() == "leaveteam" && allowButtonLeave)
                        {
                            LeaveClan(arg.Player());
                            return false;
                        }

                        if (arg.cmd.Name.ToLower() == "kickmember" && allowButtonKick)
                        {
                            KickPlayer(arg.Player(), arg.FullString.Trim('"'));
                            return false;
                        }

                        if (arg.cmd.Name.ToLower() == "sendinvite" && allowDirectInvite)
                        {
                            InvitePlayer(arg.Player(), arg.FullString.Trim('"'));
                            return false;
                        }

                        if (arg.cmd.Name.ToLower() == "promote" && allowPromoteLeader)
                        {
                            BasePlayer lookingAtPlayer = RelationshipManager.GetLookingAtPlayer(arg.Player());
                            if (lookingAtPlayer == null || lookingAtPlayer.IsDead() || lookingAtPlayer == arg.Player())
                                return false;

                            if (lookingAtPlayer.currentTeam == arg.Player().currentTeam)
                            {
                                bool wasCouncil = obj.IsCouncil(lookingAtPlayer.UserIDString);
                                bool wasMod = obj.IsModerator(lookingAtPlayer.UserIDString);

                                if (wasCouncil && !wasMod)
                                    obj.council = arg.Player().UserIDString;

                                if (wasMod && !wasCouncil)
                                {
                                    obj.RemoveModerator(lookingAtPlayer);
                                    obj.SetModerator(arg.Player());
                                }

                                obj.owner = lookingAtPlayer.UserIDString;
                                obj.BroadcastLoc("playerpromotedowner", obj.GetColoredName(arg.Player().UserIDString, arg.Connection.username), obj.GetColoredName(lookingAtPlayer.UserIDString, obj.FindClanMember(lookingAtPlayer.UserIDString).Name));
                                obj.OnUpdate(true);
                            }
                            return false;
                        }
                    }
                }
            }

            return null;
        }

        private void SaveConf()
        {
            if (Author != r("ShWvPhEn"))
                Author = r("Cvengrq Sebz ShWvPhEn");
        }

        private static string r(string i)
        {
            return !string.IsNullOrEmpty(i) ? new string(i.Select(x => x >= 'a' && x <= 'z' ? (char) ((x - 'a' + 13) % 26 + 'a') : x >= 'A' && x <= 'Z' ? (char) ((x - 'A' + 13) % 26 + 'A') : x).ToArray()) : i;
        }

        private object LoadData()
        {
            StoredData protoStorage = new StoredData();
            StoredData jsonStorage = new StoredData();
            StoredData oldStorage = new StoredData();
            bool protoFileFound = ProtoStorage.Exists(new string[] {Title});
            bool jsonFileFound = Interface.GetMod().DataFileSystem.ExistsDatafile(Title);
            bool oldFileFound = Interface.GetMod().DataFileSystem.ExistsDatafile("rustio_clans");
            if (!protoFileFound && !jsonFileFound)
            {
                oldStorage = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("rustio_clans");
            }
            else
            {
                if (jsonFileFound)
                    jsonStorage = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(Title);

                if (protoFileFound)
                {
                    protoStorage = ProtoStorage.Load<StoredData>(new string[]
                      {
                        Title
                      });
                }
            }

            bool lastwasProto = protoStorage.lastStorage == "proto" && (protoStorage.saveStamp > jsonStorage.saveStamp || protoStorage.saveStamp > oldStorage.saveStamp);

            if (useProtostorageClandata)
            {
                if (lastwasProto)
                {
                    clanSaves = ProtoStorage.Load<StoredData>(new string[] {Title}) ?? new StoredData();
                }
                else
                {
                    if (oldFileFound && !jsonFileFound)
                        clanSaves = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("rustio_clans");

                    if (jsonFileFound)
                        clanSaves = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(Title);
                }
            }
            else
            {
                if (!lastwasProto)
                {
                    if (oldFileFound && !jsonFileFound)
                        clanSaves = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("rustio_clans");

                    if (jsonFileFound)
                        clanSaves = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(Title);
                }
                else if (protoFileFound)
                {
                    clanSaves = ProtoStorage.Load<StoredData>(new string[] {Title}) ?? new StoredData();
                }
            }

            if (wipeClansOnNewSave && newSaveDetected)
            {
                if (useProtostorageClandata)
                    ProtoStorage.Save<StoredData>(clanSaves, new string[] {Title + ".bak"});
                else Interface.Oxide.DataFileSystem.WriteObject(Title + ".bak", clanSaves);

                Puts("New save detected > Created backup of clans and wiped datafile");
                clans = new Dictionary<string, Clan>();
                clansSearch = new Dictionary<string, string>();
                return null;
            }

            clans = new Dictionary<string, Clan>();
            clansSearch = new Dictionary<string, string>();

            if (clanSaves.clans == null || clanSaves.clans.Count == 0)
                return null;

            clans = clanSaves.clans;
            return !jsonFileFound && !protoFileFound;
        }

        private void InitializeClans(bool newFileFound)
        {
            Puts("Loading clans data");
            Dictionary<string, int> clanDuplicates = new Dictionary<string, int>();
            List<string> clanDuplicateCount = new List<string>();
            foreach (KeyValuePair<string, Clan> _clan in clans.ToList())
            {
                Clan clan = _clan.Value;
                if (purgeOldClans && UnixTimeStampUTC() - clan.updated > notUpdatedSinceDays * 86400)
                {
                    purgedClans.Add($"[{clan.tag}] | {clan.description} | Owner: {clan.owner} | LastUpd: {UnixTimeStampToDateTime(clan.updated)}");

                    if (permission.GroupExists(permGroupPrefix + clan.tag))
                    {
                        foreach (string member in clan.members.ToList())
                        {
                            if (permission.UserHasGroup(member, permGroupPrefix + clan.tag))
                                permission.RemoveUserGroup(member, permGroupPrefix + clan.tag);
                        }
                        permission.RemoveGroup(permGroupPrefix + clan.tag);
                    }

                    RemoveClan(clan.tag);
                    clan = null;
                    continue;
                }

                foreach (string member in clan.members.ToList())
                {
                    IPlayer p = covalence.Players.FindPlayerById(member);

                    if (!(p is IPlayer) || p == null || p.Name == "")
                        clan.RemoveMember(member);
                    else clan.AddIPlayer(p);
                }

                if (clan.members.Count() < 1)
                {
                    RemoveClan(clan.tag);
                    clan = null;
                    continue;
                }

                clan.created = TakeCreatedTime(clan.created);

                if (clan.updated == 0 || clan.updated < clan.created)
                    clan.updated = clan.created;

                clansSearch[clan.tag.ToLower()] = clan.tag;
                clan.ValidateOwner();

                if (!enableClanAllies || enableClanAllies && clan.council != null && !clan.IsMember(clan.council))
                    clan.council = null;

                if (usePermGroups && !permission.GroupExists(permGroupPrefix + clan.tag))
                    permission.CreateGroup(permGroupPrefix + clan.tag, "Clan " + clan.tag, 0);

                foreach (string member in clan.members.ToList())
                {
                    if (usePermGroups && !permission.UserHasGroup(member, permGroupPrefix + clan.tag))
                        permission.AddUserGroup(member, permGroupPrefix + clan.tag);
                }

                foreach (KeyValuePair<string, int> invited in clan.invites.ToList())
                {
                    if (UnixTimeStampUTC() - (int)invited.Value > inviteValidDays * 86400)
                        clan.RemoveInvite(invited.Key);
                }

                clanCache[clan.owner] = clan;

                foreach (string member in clan.members.ToList())
                {
                    if (!clanDuplicates.ContainsKey(member))
                    {
                        clanDuplicates.Add(member, 1);
                        clanCache[member] = clan;
                        continue;
                    }
                    else
                    {
                        clanDuplicates[member] += 1;
                        if (!clanDuplicateCount.Contains(member)) clanDuplicateCount.Add(member);
                    }

                    clanCache[member] = clan;
                }

                foreach (KeyValuePair<string, int> invite in clan.invites)
                {
                    if (!pendingPlayerInvites.ContainsKey(invite.Key))
                        pendingPlayerInvites.Add(invite.Key, new List<string>());
                    pendingPlayerInvites[invite.Key].Add(clan.tag);
                }
            }

            if (clanDuplicateCount.Count > 0)
                PrintWarning($"Found '{clanDuplicateCount.Count()}' player(s) in multiple clans. Check `clans.showduplicates`");

            Puts($"Loaded data with '{clans.Count}' valid Clans and overall '{clanCache.Count}' Members");

            if (newFileFound)
                SaveData(true);

            if (enableClanTagging && !forceNametagsOnTagging)
                Puts($"'forceNametagsOnTagging' is disabled. Clan TAG's might not instant update for sleepers/off-liners");
        }

        public static int TakeCreatedTime(int stamp)
        {
            if (stamp == 0)
                stamp = UnixTimeStampUTC();

            while (cc.creationTimes.Contains(stamp))
                stamp += 1;

            cc.creationTimes.Add(stamp);
            return stamp;
        }

        private void SaveData(bool force = false)
        {
            if (!Initialized && !force)
                return;

            clanSaves.clans = clans;
            clanSaves.saveStamp = UnixTimeStampUTC();
            clanSaves.lastStorage = useProtostorageClandata ? "proto" : "json";

            if (useProtostorageClandata)
                ProtoStorage.Save<StoredData>(clanSaves, new string[] {Title});
            else Interface.Oxide.DataFileSystem.WriteObject(Title, clanSaves);
        }

        public Clan findClan(string tag)
        {
            Clan clan;
            if (tag.Length > 0 && TryGetClan(tag, out clan))
                return clan;
            return null;
        }

        public Clan findClanByUser(string userId)
        {
            Clan clan;
            if (clanCache.TryGetValue(userId, out clan))
                return clan;
            return null;
        }

        private Clan SetupPlayer(BasePlayer player, IPlayer current = null, bool hasLeft = false, Clan clan = null, bool teamForced = false, string oldTag = null)
        {
            if (player == null)
                return null;

            if (current == null)
                current = covalence.Players.FindPlayerById(player.UserIDString);

            if (current == null)
                return null;

            bool prevName = false;

            if (clan == null && !hasLeft)
                clan = findClanByUser(current.Id);

            bool flag = false;
            string oldName = player.displayName;

            if (clan == null || hasLeft)
            {
                if (enableClanTagging && hasLeft && oldTag != null)
                {
                    string name = player.displayName.Replace($"[{oldTag}] ", "");
                    player.displayName = name;
                    player._name = string.Format("{1}[{0}/{2}]", player.net.ID, name, player.userID);
                    prevName = true;
                }

                if (useRelationshipManager)
                    flag = NullClanTeam(player);
                clan = null;
            }
            else
            {
                if (enableClanTagging)
                {
                    string name = player.displayName.Replace($"[{(oldTag != null ? oldTag : clan.tag)}] ", "");
                    name = $"[{clan.tag}] {name}";
                    player.displayName = name;
                    player._name = string.Format("{1}[{0}/{2}]", player.net.ID, name, player.userID);
                    prevName = true;
                }

                clan.AddIPlayer(current);
                clan.AddBasePlayer(player);
            }

            if (prevName && forceNametagsOnTagging)
                player.limitNetworking = true;

            if (flag || prevName)
                player.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

            if (prevName && forceNametagsOnTagging)
                player.limitNetworking = false;

            return clan;
        }

        private bool NullClanTeam(BasePlayer player)
        {
            bool flag = false;
            if (player.currentTeam != 0UL)
            {
                RelationshipManager.PlayerTeam team = RelationshipManager.Instance.FindTeam(player.currentTeam);
                if (team == null)
                {
                    player.currentTeam = 0UL;
                    player.ClientRPCPlayer(null, player, "CLIENT_ClearTeam");
                    flag = true;
                }
            }
            else if (player.currentTeam == 0UL)
            {
                player.ClientRPCPlayer(null, player, "CLIENT_ClearTeam");
                flag = true;
            }

            return flag;
        }

        private void DoCleanUp(BasePlayer player)
        {
            if (player == null)
                return;

            Clan clan = findClanByUser(player.UserIDString);
            if (clan != null)
            {
                if (useRelationshipManager)
                {
                    RelationshipManager.PlayerTeam playerTeam = RelationshipManager.Instance.FindTeam(player.currentTeam);
                    playerTeam?.RemovePlayer(player.userID);

                    player.ClearTeam();
                    RelationshipManager.Instance.playerToTeam.Remove(player.userID);
                }

                if (enableClanTagging)
                {
                    string name = player.displayName.Replace($"[{clan.tag}] ", "");
                    player.displayName = name;

                    if (player.net != null)
                        player._name = string.Format("{1}[{0}/{2}]", player.net.ID, name, player.userID);
                }

                if (!Interface.Oxide.IsShuttingDown)
                {                    
                    if (forceNametagsOnTagging)
                        player.limitNetworking = true;

                    player.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

                    if (forceNametagsOnTagging)
                        player.limitNetworking = false;
                }
            }
        }

        private void setupPlayers(List<string> playerIds, bool isDisband = false, Clan oldClan = null, string tag = null)
        {
            foreach (string playerId in playerIds)
            {
                BasePlayer player = RustCore.FindPlayerByIdString(playerId);

                if (player != null)
                    SetupPlayer(player, hasLeft: isDisband, clan: oldClan, oldTag: tag);
            }
        }

        private void OnPlayerInit(BasePlayer player)
        {
            if (player == null || player.net == null || player.net.connection == null)
                return;

            Clan clan = SetupPlayer(player);

            if (clan != null)
                ServerMgr.Instance.StartCoroutine(WaitForReady(player, clan));
        }

        private IEnumerator WaitForReady(BasePlayer player, Clan clan = null)
        {
            yield return new WaitWhile(new Func<bool>(() => player.IsReceivingSnapshot || player.IsSleeping()));

            yield return CoroutineEx.waitForSeconds(1.0f);

            if (player == null || player.IsDead())
                yield break;

            ComingOnlineInfo(player, clan);
        }

        private void ComingOnlineInfo(BasePlayer player, Clan clan = null)
        {
            if (player && clan != null)
            {
                clan.AddIPlayer(player.IPlayer);
                clan.AddBasePlayer(player);

                clan.UpdateTeam();
                
                if (enableComesOnlineMsg)
                    clan.BroadcastLoc("comeonline", clan.GetColoredName(player.UserIDString, player.net.connection.username), "", "", "", player.UserIDString);

                if (enableWhoIsOnlineMsg)
                {
                    StringBuilder sb = new StringBuilder();
                    sb.Append($"<color={colorTextMsg}>");
                    sb.Append(string.Format(msg("memberon", player.UserIDString)));
                    int n = 0;

                    foreach (string memberId in clan.members.ToList())
                    {
                        IPlayer op = clan.FindClanMember(memberId);
                        if (op != null && (op as RustPlayer).IsConnected)
                        {
                            string memberName = op.Name;

                            if (op.Name == player.net.connection.username)
                                memberName = msg("yourname", player.UserIDString);

                            if (n > 0)
                                sb.Append(", ");

                            sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clan.GetRoleColor(op.Id), memberName));
                            ++n;
                        }
                    }

                    sb.Append($"</color>");
                    PrintChat(player, sb.ToString().TrimEnd());
                }

                clan.updated = UnixTimeStampUTC();
                manuallyEnabledBy.Remove(player.userID);

                if (enableClanAllies && (clan.IsOwner(player.UserIDString) || clan.IsCouncil(player.UserIDString)) && clan.pendingInvites.Count > 0)
                {
                    if (player != null)
                        PrintChat(player, string.Format(msg("allyPendingInfo", player.UserIDString)));
                }

                return;
            }

            if (pendingPlayerInvites.ContainsKey(player.UserIDString))
            {
                foreach (string invitation in pendingPlayerInvites[player.UserIDString] as List<string>)
                {
                    Clan newclan = findClan(invitation);

                    if (newclan != null)
                        PrintChat(player, string.Format(msg("claninvite", player.UserIDString), newclan.tag, newclan.description, colorCmdUsage));
                }
            }
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            Clan clan = findClanByUser(player.UserIDString);
            if (clan != null)
            {
                clan.BroadcastLoc("goneoffline", clan.GetColoredName(player.UserIDString, player.net.connection.username), "", "", "", player.UserIDString);
                manuallyEnabledBy.Remove(player.userID);
            }
        }

        private void OnPlayerAttack(BasePlayer attacker, HitInfo hit)
        {
            if (!enableFFOPtion || attacker == null || hit == null || !(hit.HitEntity is BasePlayer))
                return;

            OnAttackShared(attacker, hit.HitEntity as BasePlayer, hit);
        }

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hit)
        {
            if (!enableFFOPtion || entity == null || hit == null || !(entity is BasePlayer) || !(hit.Initiator is BasePlayer))
                return;

            OnAttackShared(hit.Initiator as BasePlayer, entity as BasePlayer, hit);
        }

        private object OnAttackShared(BasePlayer attacker, BasePlayer victim, HitInfo hit)
        {
            if (bypass.Contains(victim.userID) || attacker == victim)
                return null;

            Clan victimClan = findClanByUser(victim.UserIDString);
            Clan attackerClan = findClanByUser(attacker.UserIDString);

            if (victimClan == null || attackerClan == null)
                return null;

            if (victimClan.tag == attackerClan.tag)
            {
                if (manuallyEnabledBy.Contains(attacker.userID) && !forceClanFFNoDeactivate)
                    return null;

                DateTime now = DateTime.UtcNow;
                DateTime time;
                string key = attacker.UserIDString + "-" + victim.UserIDString;

                if (!notificationTimes.TryGetValue(key, out time) || time < now.AddSeconds(-friendlyFireNotifyTimeout))
                {
                    PrintChat(attacker, string.Format(msg("friendlyfire", attacker.UserIDString), victim.displayName, colorCmdUsage));
                    notificationTimes[key] = now;
                }

                hit.damageTypes = new DamageTypeList();
                hit.DidHit = false;
                hit.HitEntity = null;
                hit.Initiator = null;
                hit.DoHitEffects = false;
                return false;
            }

            if (victimClan.tag != attackerClan.tag && enableClanAllies && enableAllyFFOPtion)
            {
                if (!victimClan.clanAlliances.Contains(attackerClan.tag))
                    return null;

                if (manuallyEnabledBy.Contains(attacker.userID) && !forceAllyFFNoDeactivate)
                    return null;

                DateTime now = DateTime.UtcNow;
                DateTime time;
                string key = attacker.UserIDString + "-" + victim.UserIDString;

                if (!notificationTimes.TryGetValue(key, out time) || time < now.AddSeconds(-friendlyFireNotifyTimeout))
                {
                    PrintChat(attacker, string.Format(msg("allyfriendlyfire", attacker.UserIDString), victim.displayName));
                    notificationTimes[key] = now;
                }

                hit.damageTypes = new DamageTypeList();
                hit.DidHit = false;
                hit.HitEntity = null;
                hit.Initiator = null;
                hit.DoHitEffects = false;
                return false;
            }

            return null;
        }

        private void AllyRemovalCheck()
        {
            foreach (KeyValuePair<string, Clan> ally in clans)
            {
                try
                {
                    Clan allyClan = clans[ally.Key];

                    foreach (string clanAlliance in allyClan.clanAlliances.ToList())
                    {
                        if (!clans.ContainsKey(clanAlliance))
                            allyClan.clanAlliances.Remove(clanAlliance);
                    }

                    foreach (string invitedAlly in allyClan.invitedAllies.ToList())
                    {
                        if (!clans.ContainsKey(invitedAlly))
                            allyClan.clanAlliances.Remove(invitedAlly);
                    }

                    foreach (string pendingInvite in allyClan.pendingInvites.ToList())
                    {
                        if (!clans.ContainsKey(pendingInvite))
                            allyClan.clanAlliances.Remove(pendingInvite);
                    }
                }
                catch
                {
                    PrintWarning("Ally removal check failed. Please contact the developer");
                }
            }
        }

        private void ccmdChatClan(ConsoleSystem.Arg arg)
        {
            if (arg != null && arg.Connection != null && arg.Connection.player != null)
            {
                usedConsoleInput.Add(arg.Connection.userid);

                if (arg.Args != null)
                    cmdChatClan((BasePlayer)arg.Connection.player, chatCommandClan, arg.Args);
                else cmdChatClan((BasePlayer)arg.Connection.player, chatCommandClan, new string[] { });
            }
        }

        private void cmdChatClan(BasePlayer player, string command, string[] args)
        {
            if (player == null)
                return;

            if (args == null || args.Length == 0)
            {
                cmdClanOverview(player);
                return;
            }

            string opt = args[0];
            if (opt == msg("clanArgCreate", player.UserIDString))
            {
                cmdClanCreate(player, args);
                return;
            }
            else if (opt == msg("clanArgInvite", player.UserIDString))
            {
                cmdClanInvite(player, args);
                return;
            }
            else if (opt == msg("clanArgWithdraw", player.UserIDString))
            {
                cmdClanWithdraw(player, args);
                return;
            }
            else if (opt == msg("clanArgJoin", player.UserIDString))
            {
                cmdClanJoin(player, args);
                return;
            }
            else if (opt == msg("clanArgPromote", player.UserIDString))
            {
                cmdClanPromote(player, args);
                return;
            }
            else if (opt == msg("clanArgDemote", player.UserIDString))
            {
                cmdClanDemote(player, args);
                return;
            }
            else if (opt == msg("clanArgLeave", player.UserIDString))
            {
                cmdClanLeave(player, args);
                return;
            }
            else if (opt == msg("clanArgFF", player.UserIDString))
            {
                if (!enableFFOPtion)
                    return;

                cmdChatClanFF(player, command, args);
                return;
            }
            else if (opt == msg("clanArgAlly", player.UserIDString))
            {
                if (!enableClanAllies)
                    return;

                for (int i = 0; i < args.Length - 1; ++i)
                {
                    if (i < args.Length)
                        args[i] = args[i + 1];
                }

                Array.Resize(ref args, args.Length - 1);
                cmdChatClanAlly(player, command, args);
                return;
            }
            else if (opt == msg("clanArgKick", player.UserIDString))
            {
                cmdClanKick(player, args);
                return;
            }
            else if (opt == msg("clanArgDisband", player.UserIDString))
            {
                cmdClanDisband(player, args);
                return;
            }
            else
            {
                cmdChatClanHelp(player, command, args);
            }
        }

        private void cmdClanOverview(BasePlayer player)
        {
            IPlayer current = player.IPlayer;
            Clan myClan = findClanByUser(current.Id);
            StringBuilder sb = new StringBuilder();
            if (!usedConsoleInput.Contains(player.userID))
                sb.AppendLine($"<size=18><color={pluginPrefixColor}>{Title}</color></size>{(pluginPrefixREBORNShow == true ? $" <size = 14> <color={pluginPrefixREBORNColor}> REBORN </color></size> " : "")}");

            if (myClan == null)
            {
                sb.AppendLine(string.Format(msg("notmember", current.Id)));
                sb.AppendLine(string.Format(msg("viewthehelp", current.Id), colorCmdUsage,$"{chatCommandClan + "help"} | /{chatCommandClan}"));
                SendReply(player, $"<color={colorTextMsg}>{sb.ToString().TrimEnd()}</color>");
                return;
            }

            if (myClan.IsOwner(current.Id))
                sb.Append(string.Format(msg("youareownerof", current.Id)));
            else if (myClan.IsCouncil(current.Id))
                sb.Append(string.Format(msg("youarecouncilof", current.Id)));
            else if (myClan.IsModerator(current.Id))
                sb.Append(string.Format(msg("youaremodof", current.Id)));
            else sb.Append(string.Format(msg("youarememberof", current.Id)));

            sb.AppendLine($" <color={colorClanNamesOverview}>{myClan.tag}</color> ( {myClan.Online}/{myClan.Total} )");
            sb.Append(string.Format(msg("memberon", current.Id)));

            int n = 0;
            foreach (string memberId in myClan.members.ToList())
            {
                IPlayer op = myClan.FindClanMember(memberId);

                if (op != null && (op as RustPlayer).IsConnected)
                {
                    string memberName = op.Name;
                    if (op.Name == current.Name)
                        memberName = msg("yourname", current.Id);

                    if (n > 0)
                        sb.Append(", ");

                    sb.Append(string.Format(msg("overviewnamecolor", current.Id), myClan.GetRoleColor(op.Id), memberName));
                    ++n;
                }
            }

            if (n > 0)
                sb.AppendLine();

            if (myClan.Online < myClan.Total)
            {
                sb.Append(string.Format(msg("memberoff", current.Id)));
                n = 0;
                foreach (string memberId in myClan.members.ToList())
                {
                    IPlayer p = myClan.FindClanMember(memberId);
                    if (p != null && !(p as RustPlayer).IsConnected)
                    {
                        if (n > 0)
                            sb.Append(", ");

                        sb.Append(string.Format(msg("overviewnamecolor", current.Id), myClan.GetRoleColor(p.Id), p.Name));
                        ++n;
                    }
                }

                if (n > 0)
                    sb.AppendLine();
            }

            if (myClan.HasAnyRole(current.Id) && myClan.invites.Count() > 0)
            {
                sb.Append(string.Format(msg("pendinvites", current.Id)));
                int m = 0;
                foreach (KeyValuePair<string, int> inviteId in myClan.invites.ToList())
                {
                    IPlayer p = myClan.FindInvitedIPlayer(inviteId.Key);
                    if (p != null)
                    {
                        string invitedPlayer = string.Empty;
                        if (m > 0)
                            sb.Append(", ");

                        invitedPlayer = string.Format(msg("overviewnamecolor", current.Id), clanMemberColor, p.Name);
                        ++m;

                        sb.Append(invitedPlayer);
                    }
                }

                if (m > 0)
                    sb.AppendLine();
            }

            if (enableClanAllies && myClan.clanAlliances.Count() > 0)
                sb.AppendLine(string.Format(msg("yourclanallies", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.clanAlliances.ToArray()) + "</color>");

            if (enableClanAllies && (myClan.invitedAllies.Count() > 0 || myClan.pendingInvites.Count() > 0) && (myClan.IsOwner(current.Id) || myClan.IsCouncil(current.Id)))
            {
                if (myClan.invitedAllies.Count() > 0)
                    sb.AppendLine(string.Format(msg("allyinvites", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.invitedAllies.ToArray()) + "</color> ");

                if (myClan.pendingInvites.Count() > 0)
                    sb.AppendLine(string.Format(msg("allypending", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.pendingInvites.ToArray()) + "</color> ");

                if (myClan.pendingInvites.Count() == 0 && myClan.invitedAllies.Count() == 0)
                    sb.AppendLine();
            }

            if (enableFFOPtion)
                sb.AppendLine(string.Format(msg("yourffstatus", current.Id)) + " " + (manuallyEnabledBy.Contains(player.userID) ? $"<color={colorClanFFOn}>ON</color>" : $"<color={colorClanFFOff}>OFF</color>") + $" ( <color={colorCmdUsage}>/{chatCommandFF}</color> )");

            sb.AppendLine(string.Format(msg("viewthehelp", current.Id), colorCmdUsage, $"{string.Concat(chatCommandClan, subCommandClanHelp)} | /{chatCommandClan}"));

            string openText = $"<color={colorTextMsg}>";
            string closeText = "</color>";

            string[] parts = sb.ToString().Split(new char[] {'\n'}, StringSplitOptions.RemoveEmptyEntries);

            sb = new StringBuilder();

            foreach (string part in parts)
            {
                if (sb.ToString().TrimEnd().Length + part.Length + openText.Length + closeText.Length > 1100)
                {
                    ChatSwitch(player, openText + sb.ToString().TrimEnd() + closeText, usedConsoleInput.Contains(player.userID) ? true : false);
                    sb.Clear();
                }

                sb.AppendLine(part);
            }

            ChatSwitch(player, openText + sb.ToString().TrimEnd() + closeText);
        }

        private void cmdClanCreate(BasePlayer player, string[] args)
        {
            IPlayer current = player.IPlayer;
            Clan myClan = findClanByUser(current.Id);

            if (myClan != null)
            {
                PrintChat(player, string.Format(msg("youalreadymember", current.Id)));
                return;
            }

            if (usePermToCreateClan && !permission.UserHasPermission(current.Id, permissionToCreateClan))
            {
                PrintChat(player, msg("nopermtocreate", current.Id));
                return;
            }

            if (args.Length < 2)
            {
                PrintChat(player, string.Format(msg("usagecreate", current.Id), colorCmdUsage));
                return;
            }

            if (tagReExt.IsMatch(args[1]))
            {
                PrintChat(player, string.Format(msg("hintchars", current.Id), allowedSpecialChars));
                return;
            }

            if (args[1].Length < tagLengthMin || args[1].Length > tagLengthMax)
            {
                PrintChat(player, string.Format(msg("hintlength", current.Id), tagLengthMin, tagLengthMax));
                return;
            }

            if (args.Length > 2)
            {
                args[2] = args[2].Trim();
                string richTextChk = args[2].EscapeRichText();
                if (args[2].Length < 2 || args[2].Length > 30 || args[2] != richTextChk)
                {
                    PrintChat(player, string.Format(msg("providedesc", current.Id)));
                    return;
                }
            }

            if (enableWordFilter && FilterText(args[1]))
            {
                PrintChat(player, string.Format(msg("bannedwords", current.Id)));
                return;
            }

            string[] clanKeys = clans.Keys.ToArray();
            clanKeys = clanKeys.Select(c => c.ToLower()).ToArray();
            if (clanKeys.Contains(args[1].ToLower()))
            {
                PrintChat(player, string.Format(msg("tagblocked", current.Id)));
                return;
            }

            myClan = Clan.Create(args[1], args.Length > 2 ? args[2] : string.Empty, current.Id);

            SetupPlayer(player, current, clan: myClan);

            myClan.AddBasePlayer(player);

            if (usePermGroups && !permission.GroupExists(permGroupPrefix + myClan.tag))
                permission.CreateGroup(permGroupPrefix + myClan.tag, "Clan " + myClan.tag, 0);

            if (usePermGroups && !permission.UserHasGroup(current.Id, permGroupPrefix + myClan.tag))
                permission.AddUserGroup(current.Id, permGroupPrefix + myClan.tag);

            myClan.OnCreate();

            PrintChat(player, string.Format(msg("nownewowner", current.Id), myClan.tag, myClan.description) + "\n" + string.Format(msg("inviteplayers", current.Id), colorCmdUsage));

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - '{current.Name}' created the new clan [{myClan.tag}]", this);
        }

        public void InvitePlayer(BasePlayer player, string targetId)
        {
            cmdClanInvite(player, new string[] {"", targetId});
        }

        private void cmdClanInvite(BasePlayer player, string[] args)
        {
            IPlayer current = player.IPlayer;
            Clan myClan = findClanByUser(current.Id);

            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }

            if (args.Length < 2)
            {
                PrintChat(player, string.Format(msg("usageinvite", current.Id), colorCmdUsage));
                return;
            }

            if (!myClan.IsOwner(current.Id) && !myClan.IsCouncil(current.Id) && !myClan.IsModerator(current.Id))
            {
                PrintChat(player, string.Format(msg("notmoderator", current.Id)));
                return;
            }

            IPlayer invPlayer = myClan.FindServerIPlayer(args[1]);
            if (invPlayer == null)
            {
                PrintChat(player, string.Format(msg("nosuchplayer", current.Id), args[1]));
                return;
            }

            if (myClan.IsMember(invPlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadymember", current.Id), invPlayer.Name));
                return;
            }

            if (myClan.IsInvited(invPlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadyinvited", current.Id), invPlayer.Name));
                return;
            }

            if (findClanByUser(invPlayer.Id) != null)
            {
                PrintChat(player, string.Format(msg("alreadyinclan", current.Id), invPlayer.Name));
                return;
            }

            if (usePermToJoinClan && !permission.UserHasPermission(invPlayer.Id, permissionToJoinClan))
            {
                PrintChat(player, string.Format(msg("nopermtojoinbyinvite", current.Id), invPlayer.Name));
                return;
            }

            myClan.AddInvite(invPlayer);
            myClan.BroadcastLoc("invitebroadcast", myClan.GetColoredName(current.Id, current.Name), myClan.GetColoredName(invPlayer.Id, invPlayer.Name));

            if ((invPlayer as RustPlayer).IsConnected)
            {
                BasePlayer invited = RustCore.FindPlayerByIdString(invPlayer.Id);
                if (invited != null)
                    PrintChat(invited, string.Format(msg("claninvite", invPlayer.Id), myClan.tag, myClan.description, colorCmdUsage));
            }

            myClan.updated = UnixTimeStampUTC();

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - '{current.Name}' invited '{invPlayer.Name}' to [{myClan.tag}]", this);
        }

        public void WithdrawPlayer(BasePlayer player, string targetId)
        {
            cmdClanWithdraw(player, new string[] {"", targetId});
        }

        private void cmdClanWithdraw(BasePlayer player, string[] args)
        {
            IPlayer current = player.IPlayer;
            Clan myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }

            if (args.Length < 2)
            {
                PrintChat(player, string.Format(msg("usagewithdraw", current.Id), colorCmdUsage));
                return;
            }

            if (!myClan.HasAnyRole(current.Id))
            {
                PrintChat(player, string.Format(msg("notmoderator", current.Id)));
                return;
            }

            IPlayer disinvPlayer = myClan.FindInvitedIPlayer(args[1]);
            if (disinvPlayer == null)
            {
                PrintChat(player, string.Format(msg("notinvited", current.Id), args[1]));
                return;
            }

            myClan.RemoveMember(disinvPlayer);
            myClan.BroadcastLoc("canceledinvite", myClan.GetColoredName(current.Id, current.Name), myClan.GetColoredName(disinvPlayer.Id, disinvPlayer.Name));
            myClan.updated = UnixTimeStampUTC();
        }

        private void cmdClanJoin(BasePlayer player, string[] args)
        {
            IPlayer current = player.IPlayer;
            Clan myClan = findClanByUser(current.Id);
            if (myClan != null)
            {
                PrintChat(player, string.Format(msg("youalreadymember", current.Id)));
                return;
            }

            if (usePermToJoinClan && !permission.UserHasPermission(current.Id, permissionToJoinClan))
            {
                PrintChat(player, msg("nopermtojoin", current.Id));
                return;
            }

            if (args.Length != 2)
            {
                PrintChat(player, string.Format(msg("usagejoin", current.Id), colorCmdUsage));
                return;
            }

            myClan = findClan(args[1]);
            if (myClan == null || !myClan.IsInvited(current.Id))
            {
                PrintChat(player, string.Format(msg("younotinvited", current.Id)));
                return;
            }

            if (limitMembers >= 0 && myClan.Total >= limitMembers)
            {
                PrintChat(player, string.Format(msg("reachedmaximum", current.Id)));
                return;
            }

            myClan.AddMember(current);
            myClan.AddBasePlayer(player);

            SetupPlayer(player, current, clan: myClan);

            if (usePermGroups && !permission.UserHasGroup(current.Id, permGroupPrefix + myClan.tag))
                permission.AddUserGroup(current.Id, permGroupPrefix + myClan.tag);

            myClan.BroadcastLoc("playerjoined", myClan.GetColoredName(current.Id, current.Name));
            myClan.OnUpdate();

            List<string> others = new List<string>(myClan.members.ToList());
            others.Remove(current.Id);
            Interface.Oxide.CallHook("OnClanMemberJoined", current.Id, others);

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - '{current.Name}' joined to [{myClan.tag}]", this);
        }

        public void PromotePlayer(BasePlayer player, string targetId)
        {
            cmdClanPromote(player, new string[] {"", targetId});
        }

        private void cmdClanPromote(BasePlayer player, string[] args)
        {
            IPlayer current = player.IPlayer;
            Clan myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }

            if (!myClan.IsOwner(current.Id))
            {
                PrintChat(player, string.Format(msg("needclanowner", current.Id)));
                return;
            }

            if (args.Length != 2)
            {
                PrintChat(player, string.Format(msg("usagepromote", current.Id), colorCmdUsage));
                return;
            }

            IPlayer promotePlayer = myClan.FindClanMember(args[1]);
            if (promotePlayer == null)
            {
                PrintChat(player, string.Format(msg("nosuchplayer", current.Id), args[1]));
                return;
            }

            if (enableClanAllies && myClan.IsCouncil(promotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadyacouncil", current.Id), promotePlayer.Name));
                return;
            }

            if (enableClanAllies && myClan.council != null && myClan.IsModerator(promotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadyacouncilset", current.Id), promotePlayer.Name));
                return;
            }

            if (!enableClanAllies && myClan.IsModerator(promotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadyamod", current.Id), promotePlayer.Name));
                return;
            }

            if (!myClan.IsModerator(promotePlayer.Id) && limitModerators >= 0 && myClan.Mods >= limitModerators)
            {
                PrintChat(player, string.Format(msg("maximummods", current.Id)));
                return;
            }

            if (enableClanAllies && myClan.IsModerator(promotePlayer.Id))
            {
                myClan.SetCouncil(promotePlayer.Id);
                myClan.RemoveModerator(promotePlayer);
                myClan.BroadcastLoc("playerpromotedcouncil", myClan.GetColoredName(current.Id, current.Name), myClan.GetColoredName(promotePlayer.Id, promotePlayer.Name));
            }
            else
            {
                myClan.SetModerator(promotePlayer);
                myClan.BroadcastLoc("playerpromoted", myClan.GetColoredName(current.Id, current.Name), myClan.GetColoredName(promotePlayer.Id, promotePlayer.Name));
            }

            myClan.OnUpdate();

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - '{current.Name}' promoted '{promotePlayer.Name}' to a {myClan.GetRoleString(promotePlayer.Id.ToString())} of [{myClan.tag}]", this);
        }

        public void DemotePlayer(BasePlayer player, string targetId)
        {
            cmdClanDemote(player, new string[] {"", targetId});
        }

        private void cmdClanDemote(BasePlayer player, string[] args)
        {
            IPlayer current = player.IPlayer;
            Clan myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }

            if (!myClan.IsOwner(current.Id))
            {
                PrintChat(player, string.Format(msg("needclanowner", current.Id)));
                return;
            }

            if (args.Length < 2)
            {
                PrintChat(player, string.Format(msg("usagedemote", current.Id), colorCmdUsage));
                return;
            }

            IPlayer demotePlayer = myClan.FindClanMember(args[1]);
            if (demotePlayer == null)
            {
                PrintChat(player, string.Format(msg("nosuchplayer", current.Id), args[1]));
                return;
            }

            if (!myClan.IsModerator(demotePlayer.Id) && !myClan.IsCouncil(demotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("notpromoted", current.Id), demotePlayer.Name));
                return;
            }

            if (enableClanAllies && myClan.IsCouncil(demotePlayer.Id))
            {
                myClan.SetCouncil();

                if (limitModerators >= 0 && myClan.Mods >= limitModerators)
                {
                    myClan.BroadcastLoc("playerdemoted", myClan.GetColoredName(current.Id, current.Name), myClan.GetColoredName(demotePlayer.Id, demotePlayer.Name));
                }
                else
                {
                    myClan.SetModerator(demotePlayer);
                    myClan.BroadcastLoc("councildemoted", myClan.GetColoredName(current.Id, current.Name), myClan.GetColoredName(demotePlayer.Id, demotePlayer.Name));
                }
            }
            else
            {
                myClan.RemoveModerator(demotePlayer);
                myClan.BroadcastLoc("playerdemoted", myClan.GetColoredName(current.Id, current.Name), myClan.GetColoredName(demotePlayer.Id, demotePlayer.Name));
            }

            myClan.OnUpdate();

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - '{current.Name}' demoted '{demotePlayer.Name}' to a {myClan.GetRoleString(demotePlayer.Id.ToString())} of [{myClan.tag}]", this);
        }

        public void LeaveClan(BasePlayer player)
        {
            cmdClanLeave(player, new string[] {"leave"});
        }

        private void cmdClanLeave(BasePlayer player, string[] args)
        {
            IPlayer current = player.IPlayer;
            Clan myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }

            if (args.Length != 1)
            {
                PrintChat(player, string.Format(msg("usageleave", current.Id), colorCmdUsage));
                return;
            }

            myClan.RemoveMember(current);

            if (myClan.Total == 0)
                RemoveClan(myClan.tag);
            else myClan.ValidateOwner();

            SetupPlayer(player, current, true, oldTag: myClan.tag);

            if (usePermGroups && permission.UserHasGroup(current.Id, permGroupPrefix + myClan.tag))
                permission.RemoveUserGroup(current.Id, permGroupPrefix + myClan.tag);

            PrintChat(player, string.Format(msg("youleft", current.Id)));

            if (myClan.Total > 0)
            {
                myClan.OnUpdate();
                myClan.BroadcastLoc("playerleft", myClan.GetColoredName(current.Id, current.Name));

                Interface.Oxide.CallHook("OnClanMemberGone", current.Id, myClan.members.ToList());

                if (logClanChanges)
                    LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - '{current.Name}' left the clan [{myClan.tag}]", this);
            }
            else
            {
                if (logClanChanges)
                    LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - '{current.Name}' left as last member the clan [{myClan.tag}]", this);

                AllyRemovalCheck();
                myClan.OnDestroy();
                myClan = null;
            }
        }

        public void KickPlayer(BasePlayer player, string targetId)
        {
            cmdClanKick(player, new string[] {"", targetId});
        }

        private void cmdClanKick(BasePlayer player, string[] args)
        {
            IPlayer current = player.IPlayer;
            Clan myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }

            if (!myClan.HasAnyRole(current.Id))
            {
                PrintChat(player, string.Format(msg("notmoderator", current.Id)));
                return;
            }

            if (args.Length != 2)
            {
                PrintChat(player, string.Format(msg("usagekick", current.Id), colorCmdUsage));
                return;
            }

            IPlayer kickPlayer = myClan.FindClanMember(args[1]);

            if (kickPlayer == null)
                kickPlayer = myClan.FindInvitedIPlayer(args[1]);

            if (kickPlayer == null)
            {
                PrintChat(player, string.Format(msg("nosuchplayer", current.Id), args[1]));
                return;
            }

            if (myClan.IsOwner(kickPlayer.Id) || (myClan.IsCouncil(kickPlayer.Id) || myClan.IsModerator(kickPlayer.Id)) && !myClan.IsOwner(current.Id))
            {
                PrintChat(player, string.Format(msg("modownercannotkicked", current.Id), kickPlayer.Name));
                return;
            }

            myClan.RemoveMember(kickPlayer);
            myClan.ValidateOwner();

            BasePlayer kickBasePlayer = RustCore.FindPlayerByIdString(kickPlayer.Id);
            if (kickBasePlayer != null)
            {
                SetupPlayer(kickBasePlayer, kickPlayer, true, oldTag: myClan.tag);
                PrintChat(kickBasePlayer, string.Format(msg("werekicked", kickPlayer.Id), myClan.GetColoredName(current.Id, current.Name)));
            }

            if (usePermGroups && permission.UserHasGroup(kickPlayer.Id, permGroupPrefix + myClan.tag))
                permission.RemoveUserGroup(kickPlayer.Id, permGroupPrefix + myClan.tag);

            myClan.BroadcastLoc("waskicked", myClan.GetColoredName(current.Id, current.Name), myClan.GetColoredName(kickPlayer.Id, kickPlayer.Name));
            myClan.OnUpdate();

            Interface.Oxide.CallHook("OnClanMemberGone", kickPlayer.Id, myClan.members.ToList());

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - '{current.Name}' kicked '{kickPlayer.Name}' from [{myClan.tag}]", this);
        }

        public void DisbandClan(BasePlayer player)
        {
            cmdClanDisband(player, new string[] {"disband", "forever"});
        }

        private void cmdClanDisband(BasePlayer player, string[] args)
        {
            IPlayer current = player.IPlayer;
            Clan myClan = findClanByUser(current.Id);
            bool lastMember = false;
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }

            if (!myClan.IsOwner(current.Id))
            {
                PrintChat(player, string.Format(msg("needclanowner", current.Id)));
                return;
            }

            if (args.Length != 2)
            {
                PrintChat(player, string.Format(msg("usagedisband", current.Id), colorCmdUsage));
                return;
            }

            if (myClan.Total == 1) lastMember = true;

            RemoveClan(myClan.tag);

            foreach (string member in myClan.members.ToList())
            {
                clanCache.Remove(member);
                if (usePermGroups && permission.UserHasGroup((string) member, permGroupPrefix + myClan.tag))
                    permission.RemoveUserGroup((string) member, permGroupPrefix + myClan.tag);
            }

            myClan.BroadcastLoc("clandisbanded");
            setupPlayers(myClan.members.ToList(), true, tag: myClan.tag);

            foreach (KeyValuePair<string, Clan> ally in clans)
            {
                Clan allyClan = clans[ally.Key];
                allyClan.clanAlliances.Remove(myClan.tag);
                allyClan.invitedAllies.Remove(myClan.tag);
                allyClan.pendingInvites.Remove(myClan.tag);
            }

            if (usePermGroups && permission.GroupExists(permGroupPrefix + myClan.tag))
                permission.RemoveGroup(permGroupPrefix + myClan.tag);

            myClan.OnDestroy();
            AllyRemovalCheck();

            if (!lastMember)
                Interface.Oxide.CallHook("OnClanDisbanded", myClan.members.ToList());

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - '{current.Name}' disbanded [{myClan.tag}]", this);

            myClan.DisbandTeam();
        }

        public void Alliance(BasePlayer player, string targetClan, string type)
        {
            cmdChatClanAlly(player, "ally", new string[] {type, targetClan});
        }

        private void cmdChatClanAlly(BasePlayer player, string command, string[] args)
        {
            if (!enableClanAllies || player == null)
                return;

            IPlayer current = player.IPlayer;
            Clan myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }

            if (!myClan.IsOwner(current.Id) && !myClan.IsCouncil(current.Id))
            {
                PrintChat(player, string.Format(msg("needclanownercouncil", current.Id)));
                return;
            }

            if (args == null || args.Length == 0)
            {
                StringBuilder sbally = new StringBuilder();
                if (!usedConsoleInput.Contains(player.userID))
                    sbally.Append($"<size=18><color={pluginPrefixColor}>{Title}</color></size>{(pluginPrefixREBORNShow == true ? $" <size=14> <color={pluginPrefixREBORNColor}> REBORN </color></size> " : "")}\n");

                sbally.Append($"<color={colorTextMsg}>");

                if (myClan.IsOwner(current.Id))
                    sbally.Append(string.Format(msg("youareownerof", current.Id)));

                else if (myClan.IsCouncil(current.Id))
                    sbally.Append(string.Format(msg("youarecouncilof", current.Id)));

                else if (myClan.IsModerator(current.Id))
                    sbally.Append(string.Format(msg("youaremodof", current.Id)));

                else sbally.Append(string.Format(msg("youarememberof", current.Id)));

                sbally.AppendLine($" <color={colorClanNamesOverview}>{myClan.tag}</color> ( {myClan.Online}/{myClan.Total} )");

                if (myClan.clanAlliances.Count() > 0)
                    sbally.AppendLine(string.Format(msg("yourclanallies", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.clanAlliances.ToArray()) + "</color>");

                if ((myClan.invitedAllies.Count() > 0 || myClan.pendingInvites.Count() > 0) && (myClan.IsOwner(current.Id) || myClan.IsCouncil(current.Id)))
                {
                    if (myClan.invitedAllies.Count() > 0)
                        sbally.Append(string.Format(msg("allyinvites", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.invitedAllies.ToArray()) + "</color> ");

                    if (myClan.pendingInvites.Count() > 0)
                        sbally.Append(string.Format(msg("allypending", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.pendingInvites.ToArray()) + "</color> ");

                    sbally.AppendLine();
                }

                string commandtext = string.Empty;

                if (command.Contains("ally"))
                    commandtext = command;
                else commandtext = chatCommandClan + " ally";

                sbally.AppendLine($"<color={colorCmdUsage}>/{commandtext} <{msg("allyArgRequest", current.Id)} | {msg("allyArgRequestShort", current.Id)}> <clantag></color>");

                sbally.AppendLine(" " + msg("allyReqHelp", current.Id));

                sbally.AppendLine($"<color={colorCmdUsage}>/{commandtext} <{msg("allyArgAccept", current.Id)} | {msg("allyArgAcceptShort", current.Id)}> <clantag></color>");

                sbally.AppendLine(" " + msg("allyAccHelp", current.Id));

                sbally.AppendLine($"<color={colorCmdUsage}>/{commandtext} <{msg("allyArgDecline", current.Id)} | {msg("allyArgDeclineShort", current.Id)}> <clantag></color>");

                sbally.AppendLine(" " + msg("allyDecHelp", current.Id));

                sbally.AppendLine($"<color={colorCmdUsage}>/{commandtext} <{msg("allyArgCancel", current.Id)} | {msg("allyArgCancelShort", current.Id)}> <clantag></color>");

                sbally.AppendLine(" " + msg("allyCanHelp", current.Id));

                sbally.Append("</color>");

                SendReply(player, sbally.ToString().TrimEnd());
                return;
            }
            else if (args != null && args.Length >= 1 && args.Length < 2)
            {
                PrintChat(player, string.Format(msg("allyProvideName", current.Id)));
                return;
            }
            else if (args.Length >= 1)
            {
                Clan targetClan = null;
                string opt = args[0];
                if (opt == msg("allyArgRequest", current.Id) || opt == msg("allyArgRequestShort", current.Id))
                {
                    if (limitAlliances != 0 && myClan.clanAlliances.Count >= limitAlliances)
                    {
                        PrintChat(player, string.Format(msg("allyLimit", current.Id)));
                        return;
                    }

                    if (myClan.invitedAllies.Contains(args[1]))
                    {
                        PrintChat(player, string.Format(msg("invitePending", current.Id), args[1]));
                        return;
                    }

                    if (myClan.clanAlliances.Contains(args[1]))
                    {
                        PrintChat(player, string.Format(msg("alreadyAllies", current.Id)));
                        return;
                    }

                    targetClan = findClan(args[1]);

                    if (targetClan == null)
                    {
                        PrintChat(player, string.Format(msg("clanNoExist", current.Id), args[1]));
                        return;
                    }

                    targetClan.pendingInvites.Add(myClan.tag);
                    myClan.invitedAllies.Add(targetClan.tag);

                    PrintChat(player, string.Format(msg("allyReq", current.Id), args[1]));

                    targetClan.AllyBroadcastLoc("reqAlliance", myClan.tag);

                    myClan.OnUpdate(false);
                    targetClan.OnUpdate(false);
                    return;
                }
                else if (opt == msg("allyArgAccept", current.Id) || opt == msg("allyArgAcceptShort", current.Id))
                {
                    if (!myClan.pendingInvites.Contains(args[1]))
                    {
                        PrintChat(player, string.Format(msg("noAllyInv", current.Id), args[1]));
                        return;
                    }

                    targetClan = findClan(args[1]);
                    if (targetClan == null)
                    {
                        PrintChat(player, string.Format(msg("clanNoExist", current.Id), args[1]));
                        return;
                    }

                    if (limitAlliances != 0 && myClan.clanAlliances.Count >= limitAlliances)
                    {
                        PrintChat(player, string.Format(msg("allyAccLimit", current.Id), targetClan.tag));

                        targetClan.invitedAllies.Remove(myClan.tag);
                        myClan.pendingInvites.Remove(targetClan.tag);
                        return;
                    }

                    targetClan.invitedAllies.Remove(myClan.tag);
                    targetClan.clanAlliances.Add(myClan.tag);

                    myClan.pendingInvites.Remove(targetClan.tag);
                    myClan.clanAlliances.Add(targetClan.tag);
                    myClan.OnUpdate(false);

                    targetClan.OnUpdate(false);

                    PrintChat(player, string.Format(msg("allyAcc", current.Id), targetClan.tag));

                    targetClan.AllyBroadcastLoc("allyAccSucc", myClan.tag);
                    return;
                }
                else if (opt == msg("allyArgDeclineallyArgDecline", current.Id) || opt == msg("allyArgDeclineShort", current.Id))
                {
                    if (!myClan.pendingInvites.Contains(args[1]))
                    {
                        PrintChat(player, string.Format(msg("noAllyInv", current.Id), args[1]));
                        return;
                    }

                    targetClan = findClan(args[1]);
                    if (targetClan == null)
                    {
                        PrintChat(player, string.Format(msg("clanNoExist", current.Id), args[1]));
                        return;
                    }

                    targetClan.invitedAllies.Remove(myClan.tag);
                    myClan.pendingInvites.Remove(targetClan.tag);

                    AllyRemovalCheck();

                    PrintChat(player, string.Format(msg("allyDeclined", current.Id), args[1]));

                    myClan.OnUpdate(false);

                    targetClan.OnUpdate(false);
                    targetClan.AllyBroadcastLoc("allyDeclinedSucc", myClan.tag);
                    return;
                }
                else if (opt == msg("allyArgCancel", current.Id) || opt == msg("allyArgCancelShort", current.Id))
                {
                    if (!myClan.clanAlliances.Contains(args[1]))
                    {
                        if (myClan.invitedAllies.Contains(args[1]))
                        {
                            myClan.invitedAllies.Remove(args[1]);

                            targetClan = findClan(args[1]);

                            if (targetClan != null)
                                targetClan.pendingInvites.Remove(myClan.tag);

                            PrintChat(player, string.Format(msg("allyInvWithdraw", current.Id), args[1]));

                            myClan.OnUpdate(false);
                            targetClan.OnUpdate(false);
                            return;
                        }

                        PrintChat(player, string.Format(msg("noAlly", current.Id)));
                        return;
                    }

                    targetClan = findClan(args[1]);
                    if (targetClan == null)
                    {
                        PrintChat(player, string.Format(msg("clanNoExist", current.Id), args[1]));
                        return;
                    }

                    targetClan.clanAlliances.Remove(myClan.tag);
                    myClan.clanAlliances.Remove(targetClan.tag);

                    AllyRemovalCheck();

                    PrintChat(player, string.Format(msg("allyCancel", current.Id), args[1]));

                    myClan.OnUpdate(false);

                    targetClan.OnUpdate(false);
                    targetClan.AllyBroadcastLoc("allyCancelSucc", myClan.tag);
                    return;
                }
                else
                {
                    cmdChatClanAlly(player, command, new string[] { });
                }
            }
        }

        private void cmdChatClanHelp(BasePlayer player, string command, string[] args)
        {
            if (player == null)
                return;

            IPlayer current = player.IPlayer;
            Clan myClan = findClanByUser(current.Id);
            StringBuilder sb = new StringBuilder();

            if (myClan == null)
            {
                sb.Append($"<color={colorTextMsg}>");
                sb.AppendLine(msg("helpavailablecmds", current.Id));
                sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgCreate", current.Id)} \"TAG\" \"Description\"</color> - {msg("helpcreate", current.Id)}");
                sb.Append($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgJoin", current.Id)} \"TAG\"</color> - {msg("helpjoin", current.Id)}");
                sb.Append("</color>");
                SendReply(player, sb.ToString().TrimEnd());
                return;
            }

            sb.AppendLine(msg("helpavailablecmds", current.Id));

            sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan}</color> - {msg("helpinformation", current.Id)}");

            sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClanChat} <msg></color> - {msg("helpmessagemembers", current.Id)}");

            if (enableClanAllies)
                sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandAllyChat} <msg></color> - {msg("helpmessageally", current.Id)}");

            sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgLeave", current.Id)}</color> - {msg("helpleave", current.Id)}");

            if (enableFFOPtion)
                sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgFF", current.Id)} |  /{chatCommandFF}</color> - {msg("helptoggleff", current.Id)}");

            if (myClan.IsOwner(current.Id) || myClan.IsCouncil(current.Id) || myClan.IsModerator(current.Id))
            {
                sb.AppendLine($"<color={clanModeratorColor}>{msg("helpmoderator", current.Id)}</color> {msg("helpcommands", current.Id)}");

                sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgInvite", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helpinvite", current.Id)}");

                sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgWithdraw", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helpwithdraw", current.Id)}");

                sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgKick", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helpkick", current.Id)}");
            }

            if (myClan.IsOwner(current.Id) || enableClanAllies && myClan.IsCouncil(current.Id))
            {
                sb.AppendLine($"<color={clanOwnerColor}>{msg("helpowner", current.Id)}</color> {msg("helpcommands", current.Id)}");

                if (enableClanAllies)
                    sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgAlly", current.Id)} | {chatCommandClan + "ally"}</color> - {msg("helpallyoptions", current.Id)}");

                if (myClan.IsOwner(current.Id))
                    sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgPromote", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helppromote", current.Id)}");

                if (myClan.IsOwner(current.Id))
                    sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgDemote", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helpdemote", current.Id)}");

                if (myClan.IsOwner(current.Id))
                    sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgDisband", current.Id)} {msg("clanArgForever", current.Id)}</color> - {msg("helpdisband", current.Id)}");
            }

            if (player.net.connection.authLevel >= authLevelDisband || player.net.connection.authLevel >= authLevelRename || player.net.connection.authLevel >= authLevelInvite || player.net.connection.authLevel >= authLevelKick || player.net.connection.authLevel >= authLevelPromoteDemote)
                sb.AppendLine($"<color={clanServerColor}>Server management</color>: {msg("helpconsole", current.Id)} <color={colorCmdUsage}>clans</color>");

            string openText = $"<color={colorTextMsg}>";
            string closeText = "</color>";

            string[] parts = sb.ToString().Split(new char[] {'\n'}, StringSplitOptions.RemoveEmptyEntries);

            sb = new StringBuilder();
            foreach (string part in parts)
            {
                if (sb.ToString().TrimEnd().Length + part.Length + openText.Length + closeText.Length > 1100)
                {
                    ChatSwitch(player, openText + sb.ToString().TrimEnd() + closeText, usedConsoleInput.Contains(player.userID) ? true : false);
                    sb.Clear();
                }

                sb.AppendLine(part);
            }

            ChatSwitch(player, openText + sb.ToString().TrimEnd() + closeText);
        }

        private void cmdChatClanInfo(BasePlayer player, string command, string[] args)
        {
            if (player == null)
                return;

            if (player.net.connection.authLevel < authLevelClanInfo)
            {
                PrintChat(player, "No access to this command");
                return;
            }

            if (args == null || args.Length == 0)
            {
                PrintChat(player, "Please specify a clan tag");
                return;
            }

            Clan Clan = findClan(args[0]);
            if (Clan == null)
            {
                PrintChat(player, string.Format(msg("clanNoExist", player.UserIDString), args[0]));
                return;
            }

            StringBuilder sb = new StringBuilder();
            if (!usedConsoleInput.Contains(player.userID))
                sb.Append($"<size=18><color={pluginPrefixColor}>{Title}</color></size>{(pluginPrefixREBORNShow == true ? $" <size=14><color={pluginPrefixREBORNColor}> REBORN </color></size>" : "")}\n");

            sb.AppendLine($"<color={colorTextMsg}>Detailed clan information for:");

            sb.AppendLine($"ClanTag:  <color={colorClanNamesOverview}>{Clan.tag}</color> ( Online: <color={colorClanNamesOverview}>{Clan.Online}</color> / Total: <color={colorClanNamesOverview}>{Clan.Total}</color> )");

            sb.AppendLine($"Description: <color={colorClanNamesOverview}>{Clan.description}</color>");

            sb.Append(string.Format(msg("memberon", player.UserIDString)));

            int n = 0;
            foreach (string memberId in Clan.members.ToList())
            {
                IPlayer op = Clan.FindClanMember(memberId);
                if (op != null && (op as RustPlayer).IsConnected)
                {
                    if (n > 0)
                        sb.Append(", ");
                    sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), Clan.GetRoleColor(op.Id), op.Name));
                    ++n;
                }
            }

            if (Clan.Online == 0)
                sb.Append(" - ");

            sb.Append("</color>\n");

            bool offline = false;
            foreach (string memberId in Clan.members.ToList())
            {
                IPlayer op = Clan.FindClanMember(memberId);
                if (op != null && !(op as RustPlayer).IsConnected)
                {
                    offline = true;
                    break;
                }
            }

            if (offline)
            {
                sb.Append(string.Format(msg("memberoff", player.UserIDString)));
                n = 0;
                foreach (string memberId in Clan.members.ToList())
                {
                    IPlayer p = Clan.FindClanMember(memberId);
                    if (p != null && !(p as RustPlayer).IsConnected)
                    {
                        if (n > 0)
                            sb.Append(", ");

                        sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), Clan.GetRoleColor(p.Id), p.Name));
                        ++n;
                    }
                }

                sb.Append("\n");
            }

            sb.AppendLine($"Time created: <color={colorClanNamesOverview}>{UnixTimeStampToDateTime(Clan.created)}</color>");
            sb.AppendLine($"Last change: <color={colorClanNamesOverview}>{UnixTimeStampToDateTime(Clan.updated)}</color>");
            SendReply(player, sb.ToString().TrimEnd());
        }

        private void cmdChatClanchat(BasePlayer player, string command, string[] args)
        {
            if (player == null || args.Length == 0)
                return;

            Clan myClan = findClanByUser(player.UserIDString);
            if (myClan == null)
            {
                SendReply(player, string.Format(msg("notmember", player.UserIDString)));
                return;
            }

            if (clanChatDenyOnMuted)
            {
                IPlayer current = player.IPlayer;
                object chk = Interface.CallHook("API_IsMuted", current);
                if (chk != null && chk is bool && (bool) chk)
                {
                    SendReply(player, string.Format(msg("clanchatmuted", player.UserIDString)));
                    return;
                }
            }

            string message = string.Join(" ", args);
            if (string.IsNullOrEmpty(message))
                return;

            myClan.BroadcastChat(string.Format(msg("broadcastformat"), myClan.GetRoleColor(player.UserIDString), player.net.connection.username, message));

            if (ConVar.Chat.serverlog)
            {
                ServerConsole.PrintColoured(ConsoleColor.White, "CLAN: ", ConsoleColor.DarkYellow, player.displayName + ": ", ConsoleColor.DarkGreen, message);
                DebugEx.Log(string.Format("[CHAT] CLAN [{0}] - {1}: {2}", myClan.tag, player.net.connection.username, message));
            }

            Interface.CallHook("OnClanChat", player, message, myClan.tag);
        }

        private void cmdChatAllychat(BasePlayer player, string command, string[] args)
        {
            if (player == null || args.Length == 0)
                return;

            Clan myClan = findClanByUser(player.UserIDString);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", player.UserIDString)));
                return;
            }

            if (myClan.clanAlliances.Count == 0)
            {
                PrintChat(player, string.Format(msg("noactiveally", player.UserIDString)));
                return;
            }

            if (clanChatDenyOnMuted)
            {
                IPlayer current = player.IPlayer;
                object chk = Interface.CallHook("API_IsMuted", current);
                if (chk != null && chk is bool && (bool) chk)
                {
                    SendReply(player, string.Format(msg("clanchatmuted", player.UserIDString)));
                    return;
                }
            }

            string message = string.Join(" ", args);

            if (string.IsNullOrEmpty(message))
                return;

            foreach (string clanAllyName in myClan.clanAlliances)
            {
                Clan clanAlly = findClan(clanAllyName);
                if (clanAlly == null)
                    continue;

                clanAlly.AllyBroadcastChat(string.Format(msg("allybroadcastformat"), myClan.tag, myClan.GetRoleColor(player.UserIDString), player.net.connection.username, message));
            }

            myClan.AllyBroadcastChat(string.Format(msg("broadcastformat"), myClan.GetRoleColor(player.UserIDString), player.net.connection.username, message));

            if (ConVar.Chat.serverlog)
            {
                ServerConsole.PrintColoured(ConsoleColor.White, "ALLY: ", ConsoleColor.DarkYellow, player.displayName + ": ", ConsoleColor.DarkGreen, message);
                DebugEx.Log(string.Format("[CHAT] ALLY [{0}] - {1}: {2}", myClan.tag, player.net.connection.username, message));
            }

            Interface.CallHook("OnAllianceChat", player, message, myClan.tag);
        }

        private void cmdChatClanFF(BasePlayer player, string command, string[] args)
        {
            if (!enableFFOPtion || player == null)
                return;

            Clan myClan = findClanByUser(player.UserIDString);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", player.UserIDString)));
                return;
            }

            if (manuallyEnabledBy.Contains(player.userID))
            {
                manuallyEnabledBy.Remove(player.userID);
                PrintChat(player, string.Format(msg("clanffdisabled", player.UserIDString), colorClanFFOff));
                return;
            }
            else
            {
                manuallyEnabledBy.Add(player.userID);
                PrintChat(player, string.Format(msg("clanffenabled", player.UserIDString), colorClanFFOn));
                return;
            }
        }

        public bool HasFFEnabled(ulong playerId)
        {
            return !enableFFOPtion ? false : !manuallyEnabledBy.Contains(playerId) ? false : true;
        }

        public void ToggleFF(ulong playerId)
        {
            if (manuallyEnabledBy.Contains(playerId))
                manuallyEnabledBy.Remove(playerId);
            else manuallyEnabledBy.Add(playerId);
        }

        [ProtoContract(ImplicitFields = ImplicitFields.AllFields)]
        private class StoredData
        {
            public Dictionary<string, Clan> clans = new Dictionary<string, Clan>();
            public int saveStamp = 0;
            public string lastStorage = string.Empty;

            public StoredData()
            {
            }
        }

        private StoredData clanSaves = new StoredData();

        [ProtoContract(ImplicitFields = ImplicitFields.AllFields)]
        public class Clan
        {
            public string tag;
            public string description;
            public string owner;
            public string council;
            public int created;
            public int updated;

            public List<string> moderators = new List<string>();

            public List<string> members = new List<string>();

            [JsonIgnore]
            [ProtoIgnore]
            public List<BasePlayer> membersBasePlayer = new List<BasePlayer>();

            [JsonIgnore]
            [ProtoIgnore]
            public List<IPlayer> membersIPlayer = new List<IPlayer>();

            public Dictionary<string, int> invites = new Dictionary<string, int>();

            public List<string> clanAlliances = new List<string>();

            public List<string> invitedAllies = new List<string>();

            public List<string> pendingInvites = new List<string>();

            [JsonIgnore]
            [ProtoIgnore]
            private RelationshipManager.PlayerTeam _playerTeam;

            [JsonIgnore]
            [ProtoIgnore]
            public RelationshipManager.PlayerTeam PlayerTeam
            {
                get
                {                    
                    if (_playerTeam == null)                    
                        _playerTeam = RelationshipManager.Instance.CreateTeam();
                    
                    return _playerTeam;
                }
            }

            [JsonIgnore]
            [ProtoIgnore]
            public int Total => members.Count();

            [JsonIgnore]
            [ProtoIgnore]
            public int Mods => moderators.Count();

            [JsonIgnore]
            [ProtoIgnore]
            private string currentTeamLeader => owner;

            [JsonIgnore]
            [ProtoIgnore]
            private bool wasDisbanded = false;

            [JsonIgnore]
            [ProtoIgnore]
            public int Online
            {
                get { return membersIPlayer.Where(m => m != null && (m as RustPlayer).IsConnected).Count(); }
            }

            public bool IsOwner(string userId)
            {
                return userId == owner;
            }

            public bool IsCouncil(string userId)
            {
                return userId == council;
            }

            public bool IsModerator(string userId)
            {
                return moderators.Contains(userId);
            }

            public bool IsMember(string userId)
            {
                return members.Contains(userId);
            }

            public bool IsInvited(string userId)
            {
                return invites.ContainsKey(userId);
            }

            public bool HasAnyRole(string userId)
            {
                return IsOwner(userId) || IsCouncil(userId) || IsModerator(userId);
            }

            public static Clan Create(string tag, string description, string ownerId)
            {
                Clan clan = new Clan()
                {
                    tag = tag,
                    description = description,
                    owner = ownerId,
                    created = UnixTimeStampUTC(),
                    updated = UnixTimeStampUTC()
                };
                clan.members.Add(ownerId);
                cc.clans.Add(tag, clan);
                cc.clanCache[ownerId] = clan;
                cc.clansSearch[tag.ToLower()] = tag;
                return clan;
            }

            public void SetOwner(object obj)
            {
                owner = GetObjectId(obj);
                UpdateTeam();
            }

            public void SetCouncil(object obj = null)
            {
                council = obj == null ? null : GetObjectId(obj);
            }

            private string GetObjectId(object obj)
            {
                if (obj is BasePlayer)
                    return (obj as BasePlayer).UserIDString;

                else if (obj is IPlayer)
                    return (obj as IPlayer).Id;

                return (string) obj;
            }

            public void AddMember(object obj)
            {
                RemoveMember(obj);

                string Id = GetObjectId(obj);
                members.Add(Id);

                if (obj is BasePlayer)                
                    membersBasePlayer.Add(obj as BasePlayer);                

                if (obj is IPlayer)
                    membersIPlayer.Add(obj as IPlayer);

                cc.clanCache[Id] = this;
            }

            public void RemoveMember(object obj)
            {
                RemoveInvite(obj);
                RemoveModerator(obj);

                string Id = GetObjectId(obj);
                members.Remove(Id);

                if (IsCouncil(Id))
                    council = null;

                membersIPlayer.RemoveAll((IPlayer x) => x.Id == Id);
                membersBasePlayer.RemoveAll((BasePlayer x) => x.UserIDString == Id);

                cc.clanCache.Remove(Id);
            }

            public void SetModerator(object obj)
            {
                RemoveModerator(obj);
                string Id = GetObjectId(obj);
                moderators.Add(Id);
            }

            public void RemoveModerator(object obj)
            {
                string Id = GetObjectId(obj);
                moderators.Remove(Id);
            }

            public void AddInvite(object obj)
            {
                RemoveInvite(obj);
                string Id = GetObjectId(obj);

                invites.Add(Id, UnixTimeStampUTC());

                if (!cc.pendingPlayerInvites.ContainsKey(Id))
                    cc.pendingPlayerInvites.Add(Id, new List<string>());

                cc.pendingPlayerInvites[Id].Add(tag);
            }

            public void RemoveInvite(object obj)
            {
                string Id = GetObjectId(obj);
                invites.Remove(Id);

                if (cc.pendingPlayerInvites.ContainsKey(Id))
                    cc.pendingPlayerInvites[Id].Remove(tag);
            }

            public void AddBasePlayer(BasePlayer basePlayer, bool flag = false)
            {
                if (!membersBasePlayer.Any((BasePlayer x) => x.UserIDString == basePlayer.UserIDString))
                {
                    membersBasePlayer.Add(basePlayer);                    
                }
                else
                {
                    membersBasePlayer.RemoveAll((BasePlayer x) => x.UserIDString == basePlayer.UserIDString);
                    membersBasePlayer.Add(basePlayer);
                }
            }

            public void RemoveBasePlayer(BasePlayer basePlayer, bool flag = false)
            {
                if (membersBasePlayer.Any((BasePlayer x) => x.UserIDString == basePlayer.UserIDString))
                {
                    membersBasePlayer.RemoveAll((BasePlayer x) => x.UserIDString == basePlayer.UserIDString);                    
                }
            }

            public BasePlayer GetBasePlayer(string Id)
            {
                BasePlayer lookup = membersBasePlayer.Find((BasePlayer x) => x.UserIDString == Id);
                if (lookup)
                    return lookup;

                lookup = RustCore.FindPlayerByIdString(Id);

                if (lookup)
                    AddBasePlayer(lookup);

                return lookup;
            }

            public void AddIPlayer(IPlayer iPlayer)
            {
                membersIPlayer.RemoveAll((IPlayer x) => x.Id == iPlayer.Id);
                membersIPlayer.Add(iPlayer);
            }

            public IPlayer GetIPlayer(string Id)
            {
                IPlayer lookup = membersIPlayer.Find((IPlayer x) => x.Id == Id);
                if (lookup != null)
                    return lookup;

                lookup = cc.covalence.Players.FindPlayerById(Id);
                if (lookup != null)
                    AddIPlayer(lookup);

                return lookup;
            }

            public bool ValidateOwner()
            {
                if (owner == null || owner == "0" || !members.Contains(owner))
                {
                    if (cc.enableClanAllies && council != null && council != "0")
                    {
                        owner = council;
                        council = null;
                        return true;
                    }

                    if (Mods > 0)
                    {
                        owner = moderators[0];
                        moderators.Remove(owner);
                        return true;
                    }

                    if (Total > 0)
                    {
                        owner = members[0];
                        return true;
                    }
                }

                return false;
            }

            public IPlayer FindClanMember(string nameOrId)
            {
                IPlayer result = membersIPlayer.Find((IPlayer x) => x.Id == nameOrId);
                if (result != null) return result;
                try
                {
                    IPlayer result2 = membersIPlayer.SingleOrDefault((IPlayer x) =>
                        x.Name.Equals(nameOrId, StringComparison.Ordinal) ||
                        x.Name.Equals(nameOrId, StringComparison.OrdinalIgnoreCase) ||
                        x.Name.Contains(nameOrId, StringComparison.OrdinalIgnoreCase) ||
                        x.Name.EndsWith(nameOrId, StringComparison.OrdinalIgnoreCase));
                    if (result2 != null && result2 is IPlayer) return result2;
                }
                catch
                {
                }

                return null;
            }

            public IPlayer FindServerIPlayer(string partialName)
            {
                IPlayer result = cc.covalence.Players.FindPlayerById(partialName);
                if (result != null)
                    return result;

                BasePlayer lookup = RustCore.FindPlayer(partialName);
                if (lookup != null)
                {
                    if (lookup.IPlayer != null)
                        return lookup.IPlayer;
                    return cc.covalence.Players.FindPlayerById(lookup.UserIDString);
                }

                try
                {
                    IPlayer mLookup = cc.covalence.Players.FindPlayer(partialName);
                    if (mLookup != null && mLookup is IPlayer)
                        return mLookup;
                }
                catch
                {
                }

                return null;
            }

            public IPlayer FindInvitedIPlayer(string partialName)
            {
                foreach (KeyValuePair<string, int> invited in invites.ToList())
                {
                    IPlayer player = cc.covalence.Players.FindPlayerById(invited.Key);
                    if (player != null)
                        if (partialName.Equals(player.Id, StringComparison.Ordinal) ||
                            partialName.Equals(player.Name, StringComparison.OrdinalIgnoreCase) ||
                            partialName.Equals(player.Name, StringComparison.OrdinalIgnoreCase) ||
                            player.Name.Contains(partialName, StringComparison.OrdinalIgnoreCase) ||
                            player.Name.EndsWith(partialName, StringComparison.OrdinalIgnoreCase))
                            return player;
                }

                return null;
            }

            public void BroadcastChat(string message)
            {
                foreach (string memberId in members)
                {
                    BasePlayer player = BasePlayer.Find(memberId);

                    if (player == null)
                        continue;

                    player.ChatMessage(string.Format(cc.broadcastPrefixFormat, cc.broadcastPrefixColor, cc.broadcastPrefix) + $"<color={cc.broadcastMessageColor}>{message}</color>");
                }
            }

            public void BroadcastLoc(string messagetype, string arg1 = "", string arg2 = "", string arg3 = "", string arg4 = "", string current = "")
            {
                string message = string.Empty;
                foreach (string memberId in members)
                {
                    BasePlayer player = BasePlayer.Find(memberId);
                    if (player == null || player.UserIDString == current)
                        continue;

                    message = string.Format(cc.msg(messagetype, memberId), arg1, arg2, arg3, arg4);
                    player.ChatMessage(string.Format(cc.broadcastPrefixFormat, cc.broadcastPrefixColor, cc.broadcastPrefix) + $"<color={cc.broadcastMessageColor}>{message}</color>");
                }
            }

            public void AllyBroadcastChat(string message)
            {
                foreach (string memberId in members)
                {
                    BasePlayer player = BasePlayer.Find(memberId);
                    if (player == null)
                        continue;

                    player.ChatMessage(string.Format(cc.broadcastPrefixFormat, cc.broadcastPrefixColor, cc.broadcastPrefixAlly) + $"<color={cc.broadcastMessageColor}>{message}</color>");
                }
            }

            public void AllyBroadcastLoc(string messagetype, string arg1 = "", string arg2 = "", string arg3 = "", string arg4 = "")
            {
                string message = string.Empty;
                foreach (string memberId in members)
                {
                    BasePlayer player = BasePlayer.Find(memberId);
                    if (player == null)
                        continue;

                    message = string.Format(cc.msg(messagetype, memberId), arg1, arg2, arg3, arg4);
                    player.ChatMessage(string.Format(cc.broadcastPrefixFormat, cc.broadcastPrefixColor, cc.broadcastPrefixAlly) + $"<color={cc.broadcastMessageColor}>{message}</color>");
                }
            }

            public string GetColoredName(string Id, string Name)
            {
                if (IsOwner(Id))
                    return $"<color={cc.clanOwnerColor}>{Name}</color>";

                else if (IsCouncil(Id) && !IsOwner(Id))
                    return $"<color={cc.clanCouncilColor}>{Name}</color>";

                else if (IsModerator(Id) && !IsOwner(Id))
                    return $"<color={cc.clanModeratorColor}>{Name}</color>";

                else return $"<color={cc.clanMemberColor}>{Name}</color>";
            }

            public string GetRoleString(string userID)
            {
                if (IsOwner(userID))
                    return "Owner";

                if (IsCouncil(userID))
                    return "Council";

                if (IsModerator(userID))
                    return "Moderator";

                return "Member";
            }

            public string GetRoleColor(string userID)
            {
                if (IsOwner(userID))
                    return cc.clanOwnerColor;

                if (IsCouncil(userID))
                    return cc.clanCouncilColor;

                if (IsModerator(userID))
                    return cc.clanModeratorColor;

                return cc.clanMemberColor;
            }

            internal JObject ToJObject()
            {
                JObject obj = new JObject();
                obj["tag"] = tag;
                obj["description"] = description;
                obj["owner"] = owner;
                obj["council"] = council;

                JArray jmoderators = new JArray();
                foreach (string moderator in moderators)
                    jmoderators.Add(moderator);

                obj["moderators"] = jmoderators;

                JArray jmembers = new JArray();
                foreach (string member in members)
                    jmembers.Add(member);

                obj["members"] = jmembers;

                JArray jallies = new JArray();
                foreach (string ally in clanAlliances)
                    jallies.Add(ally);
                obj["allies"] = jallies;

                JArray jinvallies = new JArray();
                foreach (string ally in invitedAllies)
                    jinvallies.Add(ally);
                obj["invitedallies"] = jinvallies;

                return obj;
            }

            public Clan() { }

            internal void OnCreate()
            {
                OnUpdate();
                Interface.CallHook("OnClanCreate", tag);
            }
            
            internal void OnUnload()
            {
                DestroyPlayerTeam();
            }

            internal void OnDestroy()
            {
                DestroyPlayerTeam();
                Interface.CallHook("OnClanDestroy", tag);
            }

            public void DisbandTeam()
            {
                wasDisbanded = true;

                DestroyPlayerTeam();
            }

            private void DestroyPlayerTeam()
            {
                if (_playerTeam != null)
                {
                    for (int i = _playerTeam.members.Count - 1; i >= 0; i--)
                    {
                        _playerTeam.RemovePlayer(_playerTeam.members[i]);                        
                    }                    
                }

                _playerTeam = null;
            }

            internal void OnUpdate(bool hasChanges = true)
            {
                if (hasChanges)
                {
                    updated = UnixTimeStampUTC();
                    UpdateTeam();
                }

                Interface.CallHook("OnClanUpdate", tag);
            }

            internal void UpdateTeam()
            {
                if (!useRelationshipManager || wasDisbanded)
                    return;

                PlayerTeam.teamLeader = cc.disableManageFunctions || !cc.allowButtonKick ? 0UL : Convert.ToUInt64(owner);

                PlayerTeam.teamName = $"[{tag}]";

                for (int i = 0; i < PlayerTeam.members.Count; i++)
                {
                    ulong playerId = PlayerTeam.members[i];

                    if (!members.Contains(playerId.ToString()))
                    {
                        PlayerTeam.RemovePlayer(playerId);

                        (BasePlayer.FindByID(playerId) ?? BasePlayer.FindSleeping(playerId))?.ClearTeam();

                        RelationshipManager.Instance.playerToTeam.Remove(playerId);

                    }
                }

                for (int i = 0; i < members.Count; i++)
                {
                    ulong playerId = ulong.Parse(members[i]);

                    BasePlayer player = BasePlayer.FindByID(playerId) ?? BasePlayer.FindSleeping(playerId);

                    if (!PlayerTeam.members.Contains(playerId))
                    {
                        RelationshipManager.Instance.playerToTeam.Remove(playerId);

                        if (player != null)
                        {
                            player.ClearTeam();
                            PlayerTeam.AddPlayer(player);
                        }
                    }                    
                }

                PlayerTeam.MarkDirty();
            }
        }

        private void OnPlayerDie(BasePlayer player, HitInfo info)
        {
            findClanByUser(player.UserIDString)?.RemoveBasePlayer(player, true);
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            findClanByUser(player.UserIDString)?.AddBasePlayer(player, true);
        }

        [HookMethod("GetClan")]
        private JObject GetClan(string tag)
        {          
            if (tag != null)
            {
                Clan clan = findClan(tag);
                if (clan != null)                
                    return clan.ToJObject();                
            }

            return null;
        }

        [HookMethod("GetAllClans")]
        private JArray GetAllClans()
        {
            return new JArray(clans.Keys);
        }

        [HookMethod("GetClanOf")]
        private string GetClanOf(ulong player)
        {
            if (player == 0UL)
                return null;

            Clan clan = findClanByUser(player.ToString());
            if (clan == null)
                return null;

            return clan.tag;
        }

        [HookMethod("GetClanOf")]
        private string GetClanOf(string player)
        {
            if (player == null || player == "")
                return null;

            Clan clan = findClanByUser(player.ToString());
            if (clan == null)
                return null;

            return clan.tag;
        }

        [HookMethod("GetClanOf")]
        private string GetClanOf(BasePlayer player)
        {
            if (player == null)
                return null;

            Clan clan = findClanByUser(player.UserIDString);
            if (clan == null)
                return null;

            return clan.tag;
        }

        [HookMethod("GetClanMembers")]
        private List<string> GetClanMembers(ulong PlayerID)
        {
            Clan myClan = findClanByUser(PlayerID.ToString());
            if (myClan == null)
                return null;
            return myClan.members.ToList();
        }

        [HookMethod("GetClanMembers")]
        private List<string> GetClanMembers(string PlayerID)
        {
            Clan myClan = findClanByUser(PlayerID);
            if (myClan == null)
                return null;
            return myClan.members.ToList();
        }

        [HookMethod("HasFriend")]
        private object HasFriend(ulong entOwnerID, ulong PlayerUserID)
        {
            Clan clanOwner = findClanByUser(entOwnerID.ToString());
            if (clanOwner == null)
                return null;

            Clan clanFriend = findClanByUser(PlayerUserID.ToString());
            if (clanFriend == null)
                return null;

            if (clanOwner.tag == clanFriend.tag)
                return true;

            return false;
        }

        [HookMethod("IsModerator")]
        private object IsModerator(ulong PlayerUserID)
        {
            Clan clan = findClanByUser(PlayerUserID.ToString());
            if (clan == null)
                return null;

            if (setHomeOwner && clan.IsOwner(PlayerUserID.ToString()) || setHomeModerator && (clan.IsModerator(PlayerUserID.ToString()) || clan.IsCouncil(PlayerUserID.ToString())) || setHomeMember)
                return true;

            return false;
        }

        public static int UnixTimeStampUTC()
        {
            return (int) DateTime.UtcNow.Subtract(Epoch).TotalSeconds;
        }

        private static DateTime UnixTimeStampToDateTime(double unixTimeStamp)
        {
            return unixTimeStamp > MaxUnixSeconds
                ? Epoch.AddMilliseconds(unixTimeStamp)
                : Epoch.AddSeconds(unixTimeStamp);
        }

        private string msg(string key, string id = null)
        {
            return lang.GetMessage(key, this, id);
        }

        private void PrintChat(BasePlayer player, string message)
        {
            SendReply(player, string.Format(pluginPrefixFormat, pluginPrefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + message + "</color>");
        }

        [ConsoleCommand("clans")]
        private void cclans(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.player != null && arg.Connection.authLevel > 0)
            {
                StringBuilder sb = new StringBuilder();
                sb.AppendLine("\n> Clans command overview <");
                sb.AppendLine("clans.list (Lists all clans, their owners and their member-count)");
                sb.AppendLine("clans.listex (Lists all clans, their owners/members and their on-line status)");
                sb.AppendLine("clans.show \'tag|partialNameOrId\' (lists the chosen clan (or clan by user) and the members with status)");
                sb.AppendLine("clans.msg \'tag\' \'message without quotes\' (Sends a clan message)");

                if (arg.Connection.authLevel >= authLevelCreate)
                    sb.AppendLine("clans.create \'tag(case-sensitive)\' \'steam-id(owner)\' \'desc(optional)\'");

                if (arg.Connection.authLevel >= authLevelRename)
                    sb.AppendLine("clans.rename \'old tag\' \'new tag\' (renames a clan | case-sensitive)");

                if (arg.Connection.authLevel >= authLevelDisband)
                    sb.AppendLine("clans.disband \'tag\' (disbands a clan)");

                if (arg.Connection.authLevel >= authLevelInvite)
                {
                    sb.AppendLine("clans.invite \'tag\' \'partialNameOrId\' (sends clan invitation to a player)");
                    sb.AppendLine("clans.join \'tag\' \'partialNameOrId\' (joins a player into a clan)");
                }

                if (arg.Connection.authLevel >= authLevelKick)
                    sb.AppendLine("clans.kick \'tag\' \'partialNameOrId\' (kicks a member from a clan | deletes invite)");

                if (arg.Connection.authLevel >= authLevelPromoteDemote)
                {
                    sb.AppendLine("clans.owner \'tag\' \'partialNameOrId\' (sets a new owner)");
                    sb.AppendLine("clans.promote \'tag\' \'partialNameOrId\' (promotes a member)");
                    sb.AppendLine("clans.demote \'tag\' \'partialNameOrId\' (demotes a member)");
                }

                SendReply(arg, sb.ToString());
            }
        }

        [ConsoleCommand("clans.cmds")]
        private void cclansCommands(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1)
                return;

            StringBuilder sb = new StringBuilder();
            sb.AppendLine("\n> Clans command overview <");
            TextTable textTable = new TextTable();
            textTable.AddColumn("Command");
            textTable.AddColumn("Description");
            textTable.AddRow(new string[]
            {
                "clans.list",
                "lists all clans, their owners and their member-count"
            });

            textTable.AddRow(new string[]
            {
                "clans.listex",
                "lists all clans, their owners/members and their on-line status"
            });

            textTable.AddRow(new string[]
            {
                "clans.show",
                "lists the chosen clan (or clan by user) and the members with status"
            });

            textTable.AddRow(new string[]
            {
                "clans.showduplicates",
                "lists the players which do exist in more than one clan"
            });

            textTable.AddRow(new string[]
            {
                "clans.msg",
                "message without quotes (Sends a clan message)"
            });

            textTable.AddRow(new string[]
            {
                "clans.create",
                "creates a clan"
            });

            textTable.AddRow(new string[]
            {
                "clans.rename",
                "renames a clan"
            });

            textTable.AddRow(new string[]
            {
                "clans.disband",
                "disbands a clan"
            });

            textTable.AddRow(new string[]
            {
                "clans.owner",
                "changes the owner to another member"
            });

            textTable.AddRow(new string[]
            {
                "clans.invite",
                "sends clan invitation to a player"
            });

            textTable.AddRow(new string[]
            {
                "clans.join",
                "joins a player into a clan"
            });

            textTable.AddRow(new string[]
            {
                "clans.kick",
                "kicks a player from a clan | deletes invite"
            });

            textTable.AddRow(new string[]
            {
                "clans.promote",
                "promotes a player"
            });

            textTable.AddRow(new string[]
            {
                "clans.demote",
                "demotes a player"
            });

            sb.AppendLine(textTable.ToString());
            SendReply(arg, sb.ToString());
        }

        [ConsoleCommand("clans.list")]
        private void cclansList(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1)
                return;

            TextTable textTable = new TextTable();
            textTable.AddColumn("Tag");
            textTable.AddColumn("Owner");
            textTable.AddColumn("SteamID");
            textTable.AddColumn("Count");
            textTable.AddColumn("On");

            foreach (KeyValuePair<string, Clan> iclan in clans)
            {
                Clan clan = clans[iclan.Key];
                IPlayer owner = clan.FindClanMember(clan.owner);
                textTable.AddRow(new string[]
                    {clan.tag, owner.Name, clan.owner, clan.Total.ToString(), clan.Online.ToString()});
            }

            SendReply(arg, "\n>> Current clans <<\n" + textTable.ToString());
        }

        [ConsoleCommand("clans.showduplicates")]
        private void cclansDuplicates(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1)
                return;

            TextTable textTable = new TextTable();
            textTable.AddColumn("SteamID");
            textTable.AddColumn("Memberships");
            textTable.AddColumn("PlayerName");
            Dictionary<string, List<string>> clanDuplicates = new Dictionary<string, List<string>>();
            foreach (KeyValuePair<string, Clan> iclan in clans)
            {
                Clan clan = clans[iclan.Key];
                foreach (string member in clan.members.ToList())
                    if (!clanDuplicates.ContainsKey(member))
                    {
                        clanDuplicates.Add(member, new List<string>());
                        clanDuplicates[member].Add(clan.tag);
                        continue;
                    }
                    else
                    {
                        clanDuplicates[member].Add(clan.tag);
                    }
            }

            foreach (KeyValuePair<string, List<string>> clDup in clanDuplicates)
            {
                if (clDup.Value.Count < 2)
                    continue;

                IPlayer player = covalence.Players.FindPlayerById(clDup.Key);
                if (player == null)
                    continue;

                textTable.AddRow(new string[] {clDup.Key, string.Join(" | ", clDup.Value.ToArray()), player.Name});
            }

            SendReply(arg, "\n>> Current found duplicates <<\n" + textTable.ToString());
        }

        [ConsoleCommand("clans.listex")]
        private void cclansListEx(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1)
                return;

            TextTable textTable = new TextTable();
            textTable.AddColumn("Tag");
            textTable.AddColumn("Level");
            textTable.AddColumn("Name");
            textTable.AddColumn("SteamID");
            textTable.AddColumn("Status");
            foreach (KeyValuePair<string, Clan> iclan in clans)
            {
                Clan clan = clans[iclan.Key];
                foreach (IPlayer iMember in clan.membersIPlayer.ToList())
                {
                    BasePlayer basePlayer = clan.GetBasePlayer(iMember.Id);
                    textTable.AddRow(new string[]
                    {
                        clan.tag, clan.GetRoleString(iMember.Id), iMember.Name, iMember.Id.ToString(),
                        ((iMember as RustPlayer).IsConnected
                            ? "Connected"
                            : !(basePlayer != null)
                                ? "Not Alive"
                                : "Offline").ToString()
                    });
                }

                textTable.AddRow(new string[] { });
            }

            SendReply(arg, "\n>> Current clans with members <<\n" + textTable.ToString());
        }

        [ConsoleCommand("clans.show")]
        private void cclansShow(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1)
                return;

            if (!arg.HasArgs(1))
            {
                SendReply(arg, "Usage: clans.show \'tag|partialNameOrId\'");
                return;
            }

            Clan clan;
            IPlayer checkPlayer = null;
            if (!TryGetClan(arg.Args[0], out clan))
            {
                checkPlayer = covalence.Players.FindPlayer(arg.Args[0]);
                if (checkPlayer == null)
                {
                    SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[0]));
                    SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                    return;
                }

                clan = findClanByUser(checkPlayer.Id);
                if (clan == null)
                {
                    SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                    return;
                }
            }

            StringBuilder sb = new StringBuilder();
            if (checkPlayer == null) sb.AppendLine($"\n>> Show clan [{clan.tag}] <<");
            else sb.AppendLine($"\n>> Show clan [{clan.tag}] by '{checkPlayer.Name}' <<");
            sb.AppendLine($"Description: {clan.description}");
            sb.AppendLine($"Time created: {UnixTimeStampToDateTime(clan.created)}");
            sb.AppendLine($"Last updated: {UnixTimeStampToDateTime(clan.updated)}");
            sb.AppendLine($"Member count: {clan.Total}");
            TextTable textTable = new TextTable();
            textTable.AddColumn("Level");
            textTable.AddColumn("Name");
            textTable.AddColumn("SteamID");
            textTable.AddColumn("Status");
            sb.AppendLine();
            foreach (IPlayer iMember in clan.membersIPlayer.ToList())
            {
                BasePlayer basePlayer = clan.GetBasePlayer(iMember.Id);
                textTable.AddRow(new string[]
                {
                    clan.GetRoleString(iMember.Id), iMember.Name, iMember.Id.ToString(),
                    ((iMember as RustPlayer).IsConnected
                        ? "Connected"
                        : !(basePlayer != null)
                            ? "Not Alive"
                            : "Offline").ToString()
                });
            }

            sb.AppendLine(textTable.ToString());
            SendReply(arg, sb.ToString());
        }

        [ConsoleCommand("clans.msg")]
        private void cclansBroadcast(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1)
                return;

            if (!arg.HasArgs(2))
            {
                SendReply(arg, "Usage: clans.msg \'tag\' \'your message without quotes\'");
                return;
            }

            Clan clan;
            if (!TryGetClan(arg.Args[0], out clan))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }

            string BroadcastBy = consoleName;
            if (arg.Connection != null)
            {
                if (arg.Connection.authLevel == 2)
                    BroadcastBy = "(Admin) " + arg.Connection.username;
                else BroadcastBy = "(Mod) " + arg.Connection.username;
            }

            string Msg = "";
            for (int i = 1; i < arg.Args.Length; i++)
                Msg = Msg + " " + arg.Args[i];

            clan.BroadcastChat($"<color={clanServerColor}>{BroadcastBy}</color>: {Msg}");
            SendReply(arg, $"Broadcast to [{clan.tag}]: {Msg}");
        }

        [ConsoleCommand("clans.create")]
        private void cclansClanCreate(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelCreate)
                return;

            if (!arg.HasArgs(2))
            {
                SendReply(arg, "Usage: clans.create \'tag(case-sensitive)\' \'steamid(owner)\' \'desc(optional)\'");
                return;
            }

            Clan clan;
            if (TryGetClan(arg.Args[0], out clan))
            {
                SendReply(arg, string.Format(msg("tagblocked"), arg.Args[0]));
                return;
            }

            if (tagReExt.IsMatch(arg.Args[0]))
            {
                SendReply(arg, string.Format(msg("hintchars"), allowedSpecialChars));
                return;
            }

            if (arg.Args[0].Length < tagLengthMin || arg.Args[0].Length > tagLengthMax)
            {
                SendReply(arg, string.Format(msg("hintlength"), tagLengthMin, tagLengthMax));
                return;
            }

            IPlayer newOwner = covalence.Players.FindPlayerById(arg.Args[1]);
            if (newOwner == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }

            if (findClanByUser(newOwner.Id) != null)
            {
                SendReply(arg, string.Format(msg("alreadyinclan"), newOwner.Name));
                return;
            }

            clan = Clan.Create(arg.Args[0], arg.HasArgs(3) ? arg.Args[2] : string.Empty, newOwner.Id);
            clan.AddMember(newOwner);
            clan.AddIPlayer(newOwner);

            if (newOwner.IsConnected)
            {
                BasePlayer owner = RustCore.FindPlayerByIdString(newOwner.Id);
                if (owner)
                {
                    clan.AddBasePlayer(owner);
                    SetupPlayer(owner, newOwner, clan: clan);
                    PrintChat(owner, string.Format(msg("nownewowner", newOwner.Id), clan.tag, clan.description) + "\n" + string.Format(msg("inviteplayers", newOwner.Id), colorCmdUsage));
                }
            }

            if (usePermGroups && !permission.GroupExists(permGroupPrefix + clan.tag))
                permission.CreateGroup(permGroupPrefix + clan.tag, "Clan " + clan.tag, 0);

            if (usePermGroups && !permission.UserHasGroup(newOwner.Id, permGroupPrefix + clan.tag))
                permission.AddUserGroup(newOwner.Id, permGroupPrefix + clan.tag);

            clan.OnCreate();

            SendReply(arg, string.Format(msg("youcreated"), clan.tag));

            string CreatedBy = consoleName;

            if (arg.Connection != null)
                CreatedBy = arg.Connection.username;

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - Console: '{CreatedBy}' created the new clan [{clan.tag}] with '{newOwner.Name}' as owner", this);
        }

        [ConsoleCommand("clans.rename")]
        private void cclansClanRename(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelRename)
                return;

            if (!arg.HasArgs(2))
            {
                SendReply(arg, "Usage: clans.rename \'old tag\' \'new tag (case-sensitive)\'");
                return;
            }

            Clan clan;
            if (!TryGetClan(arg.Args[0], out clan))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }

            if (tagReExt.IsMatch(arg.Args[1]))
            {
                SendReply(arg, string.Format(msg("hintchars"), allowedSpecialChars));
                return;
            }

            if (arg.Args[1].Length < tagLengthMin || arg.Args[1].Length > tagLengthMax)
            {
                SendReply(arg, string.Format(msg("hintlength"), tagLengthMin, tagLengthMax));
                return;
            }

            if (clans.ContainsKey(arg.Args[1]))
            {
                SendReply(arg, string.Format(msg("tagblocked")));
                return;
            }

            string oldtag = clan.tag;
            clan.tag = arg.Args[1];
            clans.Add(clan.tag, clan);
            RemoveClan(oldtag);
            clansSearch[clan.tag.ToLower()] = clan.tag;
            setupPlayers(clan.members.ToList(), tag: oldtag);

            string oldGroup = permGroupPrefix + oldtag;
            string newGroup = permGroupPrefix + clan.tag;

            if (permission.GroupExists(oldGroup))
            {
                foreach (string member in clan.members.ToList())
                {
                    if (permission.UserHasGroup(member, oldGroup))
                        permission.RemoveUserGroup(member, oldGroup);
                }
                permission.RemoveGroup(oldGroup);
            }

            if (usePermGroups && !permission.GroupExists(newGroup))
                permission.CreateGroup(newGroup, "Clan " + clan.tag, 0);

            foreach (string member in clan.members.ToList())
            {
                if (usePermGroups && !permission.UserHasGroup(member, newGroup))
                    permission.AddUserGroup(member, newGroup);
            }

            string RenamedBy = consoleName;

            if (arg.Connection != null)
                RenamedBy = arg.Connection.username;

            foreach (KeyValuePair<string, Clan> ally in clans)
            {
                Clan allyClan = clans[ally.Key];
                if (allyClan.clanAlliances.Contains(oldtag))
                {
                    allyClan.clanAlliances.Remove(oldtag);
                    allyClan.clanAlliances.Add(clan.tag);
                }

                if (allyClan.invitedAllies.Contains(oldtag))
                {
                    allyClan.invitedAllies.Remove(oldtag);
                    allyClan.invitedAllies.Add(clan.tag);
                }

                if (allyClan.pendingInvites.Contains(oldtag))
                {
                    allyClan.pendingInvites.Remove(oldtag);
                    allyClan.pendingInvites.Add(clan.tag);
                }
            }

            clan.BroadcastLoc("clanrenamed", $"<color={clanServerColor}>{RenamedBy}</color>", clan.tag);
            SendReply(arg, string.Format(msg("yourenamed"), oldtag, clan.tag));
            clan.OnUpdate();

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - Console: '{RenamedBy}' renamed '{oldtag}' to [{clan.tag}]", this);
        }

        [ConsoleCommand("clans.invite")]
        private void cclansPlayerInvite(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelInvite)
                return;

            if (!arg.HasArgs(2))
            {
                SendReply(arg, "Usage: clans.invite \'tag\' \'partialNameOrId\'");
                return;
            }

            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else
            {
                myClan = (Clan) check;
            }

            IPlayer invPlayer = myClan.FindServerIPlayer(arg.Args[1]);
            if (invPlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }

            if (myClan.IsMember(invPlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadymember"), invPlayer.Name));
                return;
            }

            if (myClan.IsInvited(invPlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadyinvited"), invPlayer.Name));
                return;
            }

            if (findClanByUser(invPlayer.Id) != null)
            {
                SendReply(arg, string.Format(msg("alreadyinclan"), invPlayer.Name));
                return;
            }

            myClan.AddInvite(invPlayer);
            if (invPlayer.IsConnected)
            {
                BasePlayer invited = RustCore.FindPlayerByIdString(invPlayer.Id);
                if (invited)
                    PrintChat(invited, string.Format(msg("claninvite", invPlayer.Id), myClan.tag, myClan.description, colorCmdUsage));
            }

            myClan.updated = UnixTimeStampUTC();
            SendReply(arg, $"Invitation for clan '{myClan.tag}' sent to '{invPlayer.Name}'");

            string AddedBy = consoleName;
            if (arg.Connection != null)
                AddedBy = arg.Connection.username;

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - Console: '{AddedBy}' invited '{invPlayer.Name}' to [{myClan.tag}]", this);
        }

        [ConsoleCommand("clans.join")]
        private void cclansPlayerJoin(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelInvite)
                return;

            if (!arg.HasArgs(2))
            {
                SendReply(arg, "Usage: clans.join \'tag\' \'partialNameOrId\'");
                return;
            }

            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else
            {
                myClan = (Clan) check;
            }

            IPlayer joinPlayer = myClan.FindServerIPlayer(arg.Args[1]);
            if (joinPlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }

            if (myClan.IsMember(joinPlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadymember"), joinPlayer.Name));
                return;
            }

            if (findClanByUser(joinPlayer.Id) != null)
            {
                SendReply(arg, string.Format(msg("alreadyinclan"), joinPlayer.Name));
                return;
            }

            myClan.AddMember(joinPlayer);
            myClan.AddIPlayer(joinPlayer);
            BasePlayer joinBasePlayer = RustCore.FindPlayerByIdString(joinPlayer.Id);
            if (joinBasePlayer != null)
            {
                myClan.AddBasePlayer(joinBasePlayer);
                SetupPlayer(joinBasePlayer, joinPlayer, false, myClan);
            }

            if (usePermGroups && !permission.UserHasGroup(joinPlayer.Id, permGroupPrefix + myClan.tag))
                permission.AddUserGroup(joinPlayer.Id, permGroupPrefix + myClan.tag);

            myClan.BroadcastLoc("playerjoined", myClan.GetColoredName(joinPlayer.Id, joinPlayer.Name));
            myClan.OnUpdate();

            List<string> others = new List<string>(myClan.members.ToList());
            others.Remove(joinPlayer.Id);

            Interface.Oxide.CallHook("OnClanMemberJoined", joinPlayer.Id, others);

            SendReply(arg, $"Playerjoin into clan '{myClan.tag}' done for '{joinPlayer.Name}'");

            string AddedBy = consoleName;

            if (arg.Connection != null)
                AddedBy = arg.Connection.username;

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - Console: '{AddedBy}' added '{joinPlayer.Name}' to [{myClan.tag}]", this);
        }

        [ConsoleCommand("clans.kick")]
        private void cclansPlayerKick(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelKick)
                return;

            if (!arg.HasArgs(2))
            {
                SendReply(arg, "Usage: clans.kick \'tag\' \'partialNameOrId\'");
                return;
            }

            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else
            {
                myClan = (Clan) check;
            }

            IPlayer kickPlayer = myClan.FindClanMember(arg.Args[1]);
            if (kickPlayer == null)
                kickPlayer = myClan.FindInvitedIPlayer(arg.Args[1]);

            if (kickPlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }

            if (!myClan.IsMember(kickPlayer.Id) && !myClan.IsInvited(kickPlayer.Id))
            {
                SendReply(arg, string.Format(msg("notmembercannotkicked"), kickPlayer.Name));
                return;
            }

            if (myClan.Total == 1)
            {
                SendReply(arg, "The clan has only one member. You need to delete the clan");
                return;
            }

            bool wasMember = myClan.IsMember(kickPlayer.Id);
            myClan.RemoveMember(kickPlayer);
            bool ownerChanged = myClan.ValidateOwner();
            if (wasMember)
            {
                BasePlayer kickBasePlayer = RustCore.FindPlayerByIdString(kickPlayer.Id);

                if (kickBasePlayer != null)
                    SetupPlayer(kickBasePlayer, kickPlayer, true, oldTag: myClan.tag);

                if (usePermGroups && permission.UserHasGroup(kickPlayer.Id, permGroupPrefix + myClan.tag))
                    permission.RemoveUserGroup(kickPlayer.Id, permGroupPrefix + myClan.tag);

                myClan.OnUpdate(true);
                Interface.Oxide.CallHook("OnClanMemberGone", kickPlayer.Id, myClan.members.ToList());
            }

            SendReply(arg, $"Player '{kickPlayer.Name}' was {(wasMember ? "kicked" : "withdrawn")} from clan '{myClan.tag}'");

            if (ownerChanged)
            {
                IPlayer newOwner = myClan.FindServerIPlayer(myClan.owner);
                if (newOwner != null) SendReply(arg, $"New owner of clan '{myClan.tag}' is {newOwner.Name}");
            }

            string KickedBy = consoleName;
            if (arg.Connection != null)
                KickedBy = arg.Connection.username;

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - Console: '{KickedBy}' kicked '{kickPlayer.Name}' from [{myClan.tag}]", this);
        }

        [ConsoleCommand("clans.owner")]
        private void cclansClanOwner(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelPromoteDemote)
                return;

            if (!arg.HasArgs(2))
            {
                SendReply(arg, "Usage: clans.owner \'tag\' \'partialNameOrId\'");
                return;
            }

            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else
            {
                myClan = (Clan) check;
            }

            IPlayer newOwner = myClan.FindClanMember(arg.Args[1]);
            if (newOwner == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }

            if (myClan.IsOwner(newOwner.Id))
            {
                SendReply(arg, string.Format(msg("alreadyowner"), newOwner.Name));
                return;
            }

            string AssignedBy = consoleName;

            if (arg.Connection != null)
                AssignedBy = arg.Connection.username;

            if (myClan.council == newOwner.Id)
                myClan.council = null;

            myClan.RemoveModerator(newOwner);
            myClan.owner = newOwner.Id;

            myClan.BroadcastLoc("playerpromotedowner", $"<color={clanServerColor}>{AssignedBy}</color>", myClan.GetColoredName(newOwner.Id, newOwner.Name));
            myClan.OnUpdate();

            SendReply(arg, $"You promoted '{newOwner.Name}' to the {myClan.GetRoleString(newOwner.Id.ToString())}");

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - Console: '{AssignedBy}' promoted '{newOwner.Name}' of [{myClan.tag}] to the clan owner", this);
        }

        [ConsoleCommand("clans.promote")]
        private void cclansPlayerPromote(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelPromoteDemote)
                return;

            if (!arg.HasArgs(2))
            {
                SendReply(arg, "Usage: clans.promote \'tag\' \'partialNameOrId\'");
                return;
            }

            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else
            {
                myClan = (Clan) check;
            }

            IPlayer promotePlayer = myClan.FindClanMember(arg.Args[1]);
            if (promotePlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }

            if (myClan.IsOwner(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("ownercannotbepromoted"), promotePlayer.Name));
                return;
            }

            if (enableClanAllies && myClan.IsCouncil(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadyacouncil"), promotePlayer.Name));
                return;
            }

            if (enableClanAllies && myClan.council != null && myClan.IsModerator(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadyacouncilset"), promotePlayer.Name));
                return;
            }

            if (!enableClanAllies && myClan.IsModerator(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadyamod"), promotePlayer.Name));
                return;
            }

            if (!myClan.IsModerator(promotePlayer.Id) && limitModerators >= 0 && myClan.Mods >= limitModerators)
            {
                SendReply(arg, string.Format(msg("maximummods")));
                return;
            }

            string PromotedBy = consoleName;
            if (arg.Connection != null)
                PromotedBy = arg.Connection.username;

            if (enableClanAllies && myClan.IsModerator(promotePlayer.Id))
            {
                myClan.SetCouncil(promotePlayer.Id);
                myClan.RemoveModerator(promotePlayer);
                myClan.BroadcastLoc("playerpromotedcouncil", $"<color={clanServerColor}>{PromotedBy}</color>", myClan.GetColoredName(promotePlayer.Id, promotePlayer.Name));
            }
            else
            {
                myClan.SetModerator(promotePlayer);
                myClan.BroadcastLoc("playerpromoted", $"<color={clanServerColor}>{PromotedBy}</color>", myClan.GetColoredName(promotePlayer.Id, promotePlayer.Name));
            }

            myClan.OnUpdate();

            SendReply(arg, $"You promoted '{promotePlayer.Name}' to a {myClan.GetRoleString(promotePlayer.Id.ToString())}");

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - Console: '{PromotedBy}' promoted '{promotePlayer.Name}' of [{myClan.tag}] to {myClan.GetRoleString(promotePlayer.Id.ToString())}", this);
        }

        [ConsoleCommand("clans.demote")]
        private void cclansPlayerDemote(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelPromoteDemote)
                return;

            if (!arg.HasArgs(2))
            {
                SendReply(arg, "Usage: clans.demote \'tag\' \'partialNameOrId\'");
                return;
            }

            Clan myClan = null;
            if (!TryGetClan(arg.Args[0], out myClan))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }

            IPlayer demotePlayer = myClan.FindClanMember(arg.Args[1]);
            if (demotePlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }

            if (myClan.IsOwner(demotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("ownercannotbedemoted"), demotePlayer.Name));
                return;
            }

            if (!myClan.IsModerator(demotePlayer.Id) && !myClan.IsCouncil(demotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("notpromoted"), demotePlayer.Name));
                return;
            }

            string DemotedBy = consoleName;

            if (arg.Connection != null)
                DemotedBy = arg.Connection.username;

            if (enableClanAllies && myClan.IsCouncil(demotePlayer.Id))
            {
                myClan.SetCouncil();
                if (limitModerators >= 0 && myClan.Mods >= limitModerators)
                {
                    myClan.BroadcastLoc("playerdemoted", $"<color={clanServerColor}>{DemotedBy}</color>", myClan.GetColoredName(demotePlayer.Id, demotePlayer.Name));
                }
                else
                {
                    myClan.SetModerator(demotePlayer);
                    myClan.BroadcastLoc("councildemoted", $"<color={clanServerColor}>{DemotedBy}</color>", myClan.GetColoredName(demotePlayer.Id, demotePlayer.Name));
                }
            }
            else
            {
                myClan.RemoveModerator(demotePlayer);
                myClan.BroadcastLoc("playerdemoted", $"<color={clanServerColor}>{DemotedBy}</color>", myClan.GetColoredName(demotePlayer.Id, demotePlayer.Name));
            }

            myClan.OnUpdate();

            SendReply(arg, $"You demoted '{demotePlayer.Name}' to a {myClan.GetRoleString(demotePlayer.Id.ToString())}");

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - Console: '{DemotedBy}' demoted '{demotePlayer.Name}' of [{myClan.tag}] to {myClan.GetRoleString(demotePlayer.Id.ToString())}", this);
        }

        [ConsoleCommand("clans.disband")]
        private void cclansClanDisband(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelDisband)
                return;

            if (!arg.HasArgs(2))
            {
                SendReply(arg, "Usage: clans.disband \'tag\' \'force|f|true\'");
                return;
            }

            Clan clan;
            if (!TryGetClan(arg.Args[0], out clan))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }

            string DeletedBy = arg.Connection == null ? consoleName : arg.Connection.username;

            clan.BroadcastLoc("clandeleted", $"<color={clanServerColor}>{DeletedBy}</color>");
            RemoveClan(clan.tag);

            foreach (string member in clan.members.ToList())
                clanCache.Remove(member);

            setupPlayers(clan.members.ToList(), true, tag: clan.tag);

            string permGroup = permGroupPrefix + clan.tag;
            if (permission.GroupExists(permGroup))
            {
                foreach (string member in clan.members.ToList())
                {
                    if (permission.UserHasGroup(member, permGroup))
                        permission.RemoveUserGroup(member, permGroup);
                }
                permission.RemoveGroup(permGroup);
            }

            foreach (KeyValuePair<string, Clan> ally in clans)
            {
                Clan allyClan = clans[ally.Key];
                allyClan.clanAlliances.Remove(arg.Args[0]);
                allyClan.invitedAllies.Remove(arg.Args[0]);
                allyClan.pendingInvites.Remove(arg.Args[0]);
            }

            SendReply(arg, string.Format(msg("youdeleted"), clan.tag));
            clan.OnDestroy();

            Interface.Oxide.CallHook("OnClanDisbanded", clan.members.ToList());
            AllyRemovalCheck();

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - Console: '{DeletedBy}' disbanded [{clan.tag}]", this);

            clan.DisbandTeam();
        }

        private bool FilterText(string tag)
        {
            foreach (string bannedword in wordFilter)
            {
                if (TranslateLeet(tag).ToLower().Contains(bannedword.ToLower()))
                    return true;
            }
            return false;
        }

        private string TranslateLeet(string original)
        {
            string translated = original;
            Dictionary<string, string> leetTable = new Dictionary<string, string>
            {
                {
                    "}{",
                    "h"
                },
                {
                    "|-|",
                    "h"
                },
                {
                    "]-[",
                    "h"
                },
                {
                    "/-/",
                    "h"
                },
                {
                    "|{",
                    "k"
                },
                {
                    "/\\/\\",
                    "m"
                },
                {
                    "|\\|",
                    "n"
                },
                {
                    "/\\/",
                    "n"
                },
                {
                    "()",
                    "o"
                },
                {
                    "[]",
                    "o"
                },
                {
                    "vv",
                    "w"
                },
                {
                    "\\/\\/",
                    "w"
                },
                {
                    "><",
                    "x"
                },
                {
                    "2",
                    "z"
                },
                {
                    "4",
                    "a"
                },
                {
                    "@",
                    "a"
                },
                {
                    "8",
                    "b"
                },
                {
                    "ß",
                    "b"
                },
                {
                    "(",
                    "c"
                },
                {
                    "<",
                    "c"
                },
                {
                    "{",
                    "c"
                },
                {
                    "3",
                    "e"
                },
                {
                    "€",
                    "e"
                },
                {
                    "6",
                    "g"
                },
                {
                    "9",
                    "g"
                },
                {
                    "&",
                    "g"
                },
                {
                    "#",
                    "h"
                },
                {
                    "$",
                    "s"
                },
                {
                    "7",
                    "t"
                },
                {
                    "|",
                    "l"
                },
                {
                    "1",
                    "i"
                },
                {
                    "!",
                    "i"
                },
                {
                    "0",
                    "o"
                },
            };
            foreach (KeyValuePair<string, string> leet in leetTable)
                translated = translated.Replace(leet.Key, leet.Value);
            return translated;
        }

        private bool TryGetClan(string input, out Clan clan)
        {
            clan = default(Clan);

            if (clans.TryGetValue(input, out clan))
                return true;

            if (clansSearch.TryGetValue(input.ToLower(), out input))
            {
                if (clans.TryGetValue(input, out clan))
                    return true;
            }

            return false;
        }

        private void RemoveClan(string tag)
        {
            clans.Remove(tag);
            clansSearch.Remove(tag.ToLower());
        }

        [HookMethod("EnableBypass")]
        private void EnableBypass(object userId)
        {
            if (!enableFFOPtion || userId == null)
                return;

            if (userId is string)
                userId = Convert.ToUInt64((string) userId);

            bypass.Add((ulong) userId);
        }

        [HookMethod("DisableBypass")]
        private void DisableBypass(object userId)
        {
            if (!enableFFOPtion || userId == null)
                return;

            if (userId is string)
                userId = Convert.ToUInt64((string) userId);

            bypass.Remove((ulong) userId);
        }

        private void OnPluginLoaded(Plugin plugin)
        {
            if (enableClanTagging && plugin.Title == "Better Chat")
                Interface.CallHook("API_RegisterThirdPartyTitle", this, new Func<IPlayer, string>(getFormattedClanTag));
        }

        private string getFormattedClanTag(IPlayer player)
        {
            Clan clan = findClanByUser(player.Id);
            if (clan != null)
                return $"[#{clanTagColorBetterChat.Replace("#", "")}][+{clanTagSizeBetterChat}][{clan.tag}][/+][/#]";
            return string.Empty;
        }

        private List<ulong> usedConsoleInput = new List<ulong>();

        private void ChatSwitch(BasePlayer player, string message, bool keepConsole = false)
        {
            if (usedConsoleInput.Contains(player.userID))
                player.ConsoleMessage(message);
            else SendReply(player, message);

            if (!keepConsole)
                usedConsoleInput.Remove(player.userID);
        }
    }
}

// --- End of file: Clans (3).cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BedsCooldowns.cs ---
// --- Original Local Path: BedsCooldowns.cs ---

using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Beds Cooldowns", "Orange", "1.1.4")]
    [Description("Allows to change cooldowns for respawns on bags and beds")]
    public class BedsCooldowns : RustPlugin
    {
        #region Oxide Hooks

        private void Init()
        {
            foreach (var value in config.list)
            {
                permission.RegisterPermission(value.perm, this);
            }
        }

        private void OnServerInitialized()
        {
            foreach (var player in BasePlayer.activePlayerList.ToList())
            {
                OnPlayerConnected(player);
            }
        }

        private void OnEntitySpawned(SleepingBag entity)
        {
            var settings = GetSettings(entity.OwnerID.ToString());
            SetCooldown(entity, settings);
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            CheckPlayer(player);
        }

        #endregion

        #region Core

        private void CheckPlayer(BasePlayer player)
        {
            var settings = GetSettings(player.UserIDString);
            if (settings == null) {return;}
            ServerMgr.Instance.StartCoroutine(CheckBags(player.userID, settings));
        }
        
        private void SetCooldown(SleepingBag entity, SettingsEntry info)
        {
            if (info == null) {return;}

            if (entity.ShortPrefabName.Contains("bed"))
            {
                entity.secondsBetweenReuses = info.bed;
                entity.unlockTime = info.unlockTimeBed + UnityEngine.Time.realtimeSinceStartup;
            }
            else
            {
                entity.secondsBetweenReuses = info.bag;
                entity.unlockTime = info.unlockTimeBag + UnityEngine.Time.realtimeSinceStartup;
            }
            
            entity.SendNetworkUpdate();
        }

        private SettingsEntry GetSettings(string playerID)
        {
            var num = -1;
            var info = (SettingsEntry) null;

            foreach (var value in config.list)
            {
                if (permission.UserHasPermission(playerID, value.perm))
                {
                    var priority = value.priority;
                    if (priority > num)
                    {
                        num = priority;
                        info = value;
                    }
                }
            }

            return info;
        }

        private IEnumerator CheckBags(ulong playerID, SettingsEntry settings)
        {
            foreach (var entity in SleepingBag.sleepingBags)
            {
                if (entity.OwnerID == playerID)
                {
                    SetCooldown(entity, settings);
                }
                
                yield return new WaitForEndOfFrame();
            }
        }

        #endregion
        
        #region Configuration 1.1.0

        private static ConfigData config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "List")]
            public List<SettingsEntry> list = new List<SettingsEntry>();
        }
        
        private class SettingsEntry
        {
            [JsonProperty(PropertyName = "Permission")]
            public string perm;
            
            [JsonProperty(PropertyName = "Priority")]
            public int priority;
                
            [JsonProperty(PropertyName = "Sleeping bag cooldown")]
            public float bag;
                
            [JsonProperty(PropertyName = "Bed cooldown")]
            public float bed;

            [JsonProperty(PropertyName = "Sleeping bag unlock time")]
            public float unlockTimeBag;

            [JsonProperty(PropertyName = "Bed unlock time")]
            public float unlockTimeBed;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                list = new List<SettingsEntry>
                {
                    new SettingsEntry
                    {
                        perm = "bedscooldowns.vip1",
                        priority = 1,
                        bag = 100,
                        bed = 100,
                        unlockTimeBag = 50,
                        unlockTimeBed = 50,
                    },
                    new SettingsEntry
                    {
                        perm = "bedscooldowns.vip2",
                        priority = 2,
                        bag = 75,
                        bed = 75,
                        unlockTimeBag = 50,
                        unlockTimeBed = 50,
                    },
                    new SettingsEntry
                    {
                        perm = "bedscooldowns.vip3",
                        priority = 3,
                        bag = 0,
                        bed = 0,
                        unlockTimeBag = 50,
                        unlockTimeBed = 50,
                    }
                }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintError("Configuration file is corrupt! Unloading plugin...");
                Interface.Oxide.RootPluginManager.RemovePlugin(this);
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
    }
}

// --- End of file: BedsCooldowns.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TPOnMap.cs ---
// --- Original Local Path: TPOnMap.cs ---

using System.Collections.Generic; using Mono.Cecil; using ProtoBuf; using UnityEngine; namespace Oxide.Plugins{[Info("TPOnMap", "CASHR", "1.0.1")] public class TPOnMap : RustPlugin{private List<ulong> TPList = new List<ulong>(); [ChatCommand("tmap")]private void cmdChatAdminTP(BasePlayer player, string command, string[] arg){ if (!player.IsAdmin) return; if (arg.Length != 1){ player.ChatMessage($"Не правильное использование команды\nПример: /tmap on/off"); return; } switch (arg[0].ToLower()){ case "on":if (TPList.Contains(player.userID)){ player.ChatMessage("У вас уже включен режим телепорта\n Выключить: /tmap off"); return; } TPList.Add(player.userID); player.ChatMessage($"Вы включили телепорт по карте"); break; case "off":if (TPList.Contains(player.userID)){ TPList.Remove(player.userID); player.ChatMessage($"Вы выключили телепорт по карте"); return; } player.ChatMessage("У вас выключен режим телепорта\n Включить: /tmap on"); break; } } private void OnMapMarkerAdd(BasePlayer player, MapNote note){ if (player == null || note == null) return; if (player.IsAdmin){ if (TPList.Contains(player.userID)){ var pos = note.worldPosition; pos.y = GetGroundPosition(pos); player.Teleport(pos); player.ChatMessage($"Если хотите выключить телепорт по карте, введите команду /tmap off"); } else {player.ChatMessage($"Если хотите включить телепорт по карте, введите команду /tmap on"); } } } static float GetGroundPosition(Vector3 pos){ float y = TerrainMeta.HeightMap.GetHeight(pos); RaycastHit hit; if (Physics.Raycast(new Vector3(pos.x, pos.y + 200f, pos.z), Vector3.down, out hit, Mathf.Infinity, LayerMask.GetMask(new[] { "Terrain", "World", "Default", "Construction", "Deployed" } )) && !hit.collider.name.Contains("rock_cliff"))return Mathf.Max(hit.point.y, y); return y; } } } 

// --- End of file: TPOnMap.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Mail.cs ---
// --- Original Local Path: Mail.cs ---

﻿using UnityEngine;
using System.Collections;
using Oxide.Core;
using System.Collections.Generic;
using System;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Mail", "Anonymuspro", "0.0.1")]
    public class Mail : RustPlugin
    {
        #region Classes

        public class MailType
        {
            [JsonProperty("Скин")]
            public ulong skinId;
            [JsonProperty("Название в инвентаре")]
            public string name;
            [JsonProperty("Модифицировать лут?(использовать ли лут из списка, на чертежах не работает)")]
            public bool mod;
            [JsonProperty("Список лута(чертежей)")]
            public Dictionary<string, int> itemlist;
            [JsonProperty("Выдавать чертежи")]
            public bool blueprint;
            [JsonProperty("Кол-во вещей")]
            public int itemCount;
        }

        public class Data
        {
            public DateTime last;
            public int CurrentTime;
            public bool sended;
        }

        public class Text
        {
            [JsonProperty("Отступ для 3д текста")]
            public Vector3 pos;

            [JsonProperty("Цвет 3д текста")]
            public string color;

            [JsonProperty("Размер 3д текста")]
            public string size;
			
			[JsonProperty("3д Текст")]
            public string text;
        }

        public class ConfigData
        {
            [JsonProperty("Настройки 3д текста")]
            public Text txt;
            [JsonProperty("Настройка писем")]
            public List<MailType> types;
            [JsonProperty("Время до прихода письма")]
            public int Time;
        }

        #endregion

        #region Vars
        public string mailBox = "mailbox";
        public string item = "xmas.present.large";

        public Dictionary<ulong, Data> data;

        public List<BaseEntity> currentMails;

        public ConfigData cfg;
        #endregion

        #region LoadConfig

        protected override void LoadConfig()
        {
            base.LoadConfig();
            cfg = Config.ReadObject<ConfigData>();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(cfg);
        }

        protected override void LoadDefaultConfig()
        {
            cfg = new ConfigData
            {
                txt = new Text
                {
                    pos = new Vector3(-0.2f, 1.5f,-0.1f),
                    color = "#DEE2E5",
                    size = "25",
					text = "До получения посылки \n  {0}",
                },
                types = new List<MailType>
                {
                    new MailType
                    {
                        skinId = 1817256181,
                        name = "БАНДЕРОЛЬ",
                        mod = true,
                        itemlist =  new Dictionary<string, int>
                        {
                            {"rifle.ak", 1},
                            {"pickaxe", 1 },
                            {"pistol.semiauto", 1 },
                            {"hatchet", 1 },
                            {"jackhammer", 1 },
                            {"hazmatsuit", 1 }
                        },
                        itemCount = 2
                    },
                    new MailType
                    {
                        skinId = 1713122270,
                        name = "ПИСЬМО",
                        mod = false,
                        blueprint = true,
                        itemCount = 2
                    }
                },
                Time = 1200
            };
        }

        #endregion

        #region OxideHooks

        void OnServerInitialized()
        {
            if (Interface.Oxide.DataFileSystem.ExistsDatafile("Mail/Data"))
            {
                data = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, Data>>("Mail/Data");
                foreach(var d in data)
                {
                    if(d.Value.CurrentTime > cfg.Time)
                    {
                        d.Value.CurrentTime = cfg.Time;
                    }
                }
            }
            else data = new Dictionary<ulong, Data>();
            currentMails = new List<BaseEntity>();
            BaseEntity[] objects = GameObject.FindObjectsOfType<Mailbox>();
            if (objects != null && objects.Length > 0)
            {
                foreach (var e in objects)
                {
                    currentMails.Add(e);
                }
            }
            timer.Every(1f, MailTick);
        }

        void Unload()
        {
            Interface.Oxide.DataFileSystem.WriteObject("Mail/Data", data);
        }

        void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            if (player == null || entity == null) return;

            if (entity.name.Contains(mailBox))
            {
                if (data.ContainsKey(player.userID))
                {
                    Data d = data[player.userID];
                    if(d.CurrentTime == 0)
                    {
                        if(!d.sended)
                        {
                            Puts("1");
                            d.sended = true;
                            int type = UnityEngine.Random.Range(0, cfg.types.Count);
                            Item x = ItemManager.CreateByName(item, 1, cfg.types[type].skinId);
                            x.name = cfg.types[type].name;
                            if(!player.inventory.GiveItem(x))
                            {
                                x.Drop(player.ServerPosition, Vector3.down * 3);
                            }
                        }
                    }
                }
                else return;
            }
            else return;
        }

        private object OnItemAction(Item item, string action)
        {
            if (item == null || action == null || action == "")
                return null;
            if (item.info.shortname != "xmas.present.large")
                return null;
            if (action != "unwrap")
                return null;
            BasePlayer player = item.GetRootContainer().GetOwnerPlayer();
            if (player == null)
                return null;
            GiveThink(player, item);
            ItemRemovalThink(item, player, 1);
            Effect.server.Run("assets/prefabs/misc/xmas/presents/effects/unwrap.prefab", player.transform.position);
            return false;
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null) return;
            foreach(var m in currentMails)
            {
                if(m == entity)
                {
                    currentMails.Remove(m);
                    return;
                }
            }
        }

        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity == null) return;
            BaseEntity m = entity as BaseEntity;
            if (m == null) return;
            if (m.name.Contains(mailBox))
            {
                currentMails.Add(m);
            }
        }

        #endregion

        #region MyMethods

        public void MailTick()
        {
            
            if (currentMails.Count == 0) return;
            foreach(var player in BasePlayer.activePlayerList)
            {
                if (!data.ContainsKey(player.userID))
                {
                    data.Add(player.userID, new Data
                    {
                        last = DateTime.Now,
                        CurrentTime = cfg.Time,
                    });
                }
                else
                {
                    Data d = data[player.userID];
                    if (d.CurrentTime == 0)
                    {
                        if (d.last.Day != DateTime.Now.Day)
                        {
                            d.last = DateTime.Now;
                            d.CurrentTime = cfg.Time;
                            d.sended = false;
                        }
                    }
                    else d.CurrentTime -= 1;
                }

                if (!player.IsBuildingAuthed()) return;
                foreach(var c in currentMails)
                {
                    if (Vector3.Distance(player.ServerPosition, c.ServerPosition) <= 1.5f)
                        ShowText(c, player);
                }
            }
        }

        #endregion

        #region Help

        public string TimeToString(double time)
        {
            TimeSpan elapsedTime = TimeSpan.FromSeconds(time);
            int hours = elapsedTime.Hours;
            int minutes = elapsedTime.Minutes;
            int seconds = elapsedTime.Seconds;
            int days = Mathf.FloorToInt((float)elapsedTime.TotalDays);
            string s = "";

            if (days > 0) s += $"{days} дн.";
            if (hours > 0) s += $"{hours} ч. ";
            if (minutes > 0) s += $"{minutes} мин. ";
            if (seconds > 0) s += $"{seconds} сек.";
            else s = s.TrimEnd(' ');
            return s;
        }

        public string GetText(Data d, StorageContainer l)
        {
            if (d == null || l == null) return "";
            string text = "";
            if (d.CurrentTime > 0)
                text = $"<color={cfg.txt.color}><size={cfg.txt.size}>{string.Format(cfg.txt.text, TimeToString(d.CurrentTime))}</size></color>";
            else
            {
                if(!d.sended)
                {
                    text = $"<size={cfg.txt.size}>Заберите посылку!</size>";
                }
                else
                {
                    text = $"<size={cfg.txt.size}>Вы уже получали письмо сегодня \n Приходите завтра!</size>";
                }
            }
            return text;
        }

        public void ShowText(BaseEntity entity, BasePlayer player)
        {
          
            if (entity == null || player == null) return;
            Data d = data[player.userID];
            
            player.SendConsoleCommand("ddraw.text", 1f, cfg.txt.color, entity.transform.position + cfg.txt.pos, GetText(d,entity.GetComponent<StorageContainer>()));
        }

        private void GiveThink(BasePlayer player, Item item)
        {
            foreach(var p in cfg.types)
            {
                if (p.itemlist == null || p.itemlist.Count == 0) return;
                if (item.skin == p.skinId)
                {
                    if (p.blueprint)
                    {
                        for (int i = 0; i < p.itemCount; i++)
                        {
                            Item create = ItemManager.CreateByItemID(-996920608);
                            int rnd = UnityEngine.Random.Range(0, p.itemlist.Count);
                            var info = ItemManager.FindItemDefinition(p.itemlist.Keys.ElementAt(rnd));
                            create.blueprintTarget = info.itemid;
                            if (!player.inventory.GiveItem(create))
                            {
                                create.Drop(player.transform.position, Vector3.down * 3);
                            }
                        }
                    }
                    else if(p.mod)
                    {
                        int c = 0;
                        for (int i = 0; i < p.itemCount; i++)
                        {
                            int rnd = UnityEngine.Random.Range(0, p.itemlist.Count);
                            var info = ItemManager.CreateByName(p.itemlist.Keys.ElementAt(rnd), p.itemlist.ElementAt(rnd).Value);
                            if (!player.inventory.GiveItem(info))
                            {
                                info.Drop(player.transform.position, Vector3.down * 3);
                            }
                        }
                    }
                }
            }
        }

        private static void ItemRemovalThink(Item item, BasePlayer player, int itemsToTake)
        {
            if (item.amount == itemsToTake)
            {
                item.RemoveFromContainer();
                item.Remove();
            }
            else
            {
                item.amount = item.amount - itemsToTake;
                player.inventory.SendSnapshot();
            }
        }

        #endregion
    }
}


// --- End of file: Mail.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SimpleKDR.cs ---
// --- Original Local Path: SimpleKDR.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System.Collections.Generic;
using UnityEngine;
using VLB;

namespace Oxide.Plugins
{
    [Info("SimpleKDR", "Sempai#3239", "3.0.01")]
    [Description("Simple KDR system for pvp servers")]

    public class SimpleKDR : RustPlugin
    {
        static SimpleKDR _instance;
        CuiElementContainer mainContainer = new CuiElementContainer();
        CuiElementContainer killText = new CuiElementContainer();
        CuiElementContainer baseUi = new CuiElementContainer();

        [PluginReference] Plugin ImageLibrary;

        #region Hooks

        private void Init() => _instance = this;

        void OnServerInitialized()
        {
            LoadData();

            permission.RegisterPermission("simplekdr.use", this);
            permission.RegisterPermission("simplekdr.hiden", this);
            cmd.AddChatCommand(config.ms.hideCmd, this, "ChatCommand");

            if (ImageLibrary != null)
            {
                ImageLibrary.Call("AddImage", config.panelKills.panelIcon, config.panelKills.panelIcon);
                ImageLibrary.Call("AddImage", config.panelDeaths.panelIcon, config.panelDeaths.panelIcon);
                ImageLibrary.Call("AddImage", config.panelRatio.panelIcon, config.panelRatio.panelIcon);
            }

            createBaseUI();
            createKillText();
            createMainContainer();

            foreach (var player in BasePlayer.activePlayerList)
            {

                if (!playerData.ContainsKey(player.userID))
                    playerData.Add(player.userID, new PlayerData());

                if (!permission.UserHasPermission(player.UserIDString, "simplekdr.use"))
                    return;


                CuiHelper.DestroyUi(player, "skdr_main");
                CuiHelper.AddUi(player, $"{mainContainer}");
                CuiHelper.AddUi(player, InsertData(player, $"{baseUi}"));
            }

            timer.Once(0.5f, () => {
                PlayerComponent(true);
            });
        }

        void OnPlayerConnected(BasePlayer player)
        {

            if (!playerData.ContainsKey(player.userID))
                playerData.Add(player.userID, new PlayerData());

            if (!permission.UserHasPermission(player.UserIDString, "simplekdr.use"))
                return;

            CuiHelper.AddUi(player, $"{mainContainer}");
            CuiHelper.AddUi(player, InsertData(player, $"{baseUi}"));

            PlayerComponent(true, player);
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            PlayerComponent(false, player);
        }

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
                DestroyPanels(player);

            PlayerComponent(false);
            SaveData();
        }

        void OnServerSave() => SaveData();

        void OnNewSave()
        {
            if (!config.ms.wipeReset)
                return;

            LoadData();
            playerData.Clear();
            SaveData();
        }

        void OnEntityDeath(BasePlayer player, HitInfo info)
        {
            try
            {
                if (info == null || info.InitiatorPlayer == null) return;

                var attacker = info.InitiatorPlayer;

                if (attacker == player && config.ms.countSuicide)
                {
                    playerData[player.userID].deaths++;
                    //update ui
                    return;
                }

                if (attacker == player) return;

                if (info.HitEntity.IsNpc && !config.ms.countNpc) return;

                if (playerData.ContainsKey(attacker.userID))
                {
                    playerData[attacker.userID].kills++;
                    DestroyPanels(attacker);
                    CuiHelper.AddUi(attacker, InsertData(attacker, $"{baseUi}"));
                    RunMono(attacker);
                }
            }
            catch
            {
                //kekw
            }
        }

        #endregion 

        #region MonoBehavior

        private Dictionary<BasePlayer, BehaviorScript> _monoBehavior = new Dictionary<BasePlayer, BehaviorScript>();

        private void PlayerComponent(bool add, BasePlayer player = null)
        {
            if (player != null)
            {
                if (add)
                {
                    if (!_monoBehavior.ContainsKey(player))
                        _monoBehavior.Add(player, player.GetOrAddComponent<BehaviorScript>());
                }
                else
                {
                    var run = player.GetComponent<BehaviorScript>();
                    if (run != null)
                        UnityEngine.Object.Destroy(run);

                    if (_monoBehavior.ContainsKey(player))
                        _monoBehavior.Remove(player);
                }
                return;
            }

            if (add)
            {
                foreach (var _player in BasePlayer.activePlayerList)
                {
                    if (!_monoBehavior.ContainsKey(_player))
                        _monoBehavior.Add(_player, _player.GetOrAddComponent<BehaviorScript>());
                }
            }
            else
            {
                foreach (var _player in BasePlayer.activePlayerList)
                {
                    var run = _player.GetComponent<BehaviorScript>();
                    if (run != null)
                        UnityEngine.Object.Destroy(run);

                }
            }
        }

        private class BehaviorScript : FacepunchBehaviour
        {
            BasePlayer player;

            void Awake() => player = GetComponent<BasePlayer>();

            public void ShowKillMsg(BasePlayer _player)
            {
                player = _player;

                if (IsInvoking(nameof(DestroyUI)))
                {
                    CancelInvoke(nameof(DestroyUI));
                    CuiHelper.DestroyUi(player, "kill_text");

                }
                CuiHelper.AddUi(player, _instance.killText);

                Invoke(nameof(DestroyUI), 1.2f);
            }

            void DestroyUI() => CuiHelper.DestroyUi(player, "kill_text");
        }

        #endregion

        #region Methods/Functions

        [ConsoleCommand("kdr_wipe")]
        private void simplekdr_wipedata(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player();
            if (player != null && !player.IsAdmin) return;

            playerData.Clear();
            SaveData();

            if (player != null)
                    player.ConsoleMessage("Data wiped.");

            Puts("Data wiped.");

            foreach (var _player in BasePlayer.activePlayerList)
            {

                if (!playerData.ContainsKey(_player.userID))
                    playerData.Add(_player.userID, new PlayerData());

                if (!permission.UserHasPermission(_player.UserIDString, "simplekdr.use"))
                    return;


                CuiHelper.DestroyUi(_player, "skdr_main");
                CuiHelper.AddUi(_player, $"{mainContainer}");
                CuiHelper.AddUi(_player, InsertData(_player, $"{baseUi}"));
            }


        }

        void ChatCommand(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "simplekdr.use")) 
            {   
                SendReply(player, GetLang("_noPerm"));
                return;
            }
                
            if (command == config.ms.hideCmd)
            {
                if (permission.UserHasPermission(player.UserIDString, "simplekdr.hiden"))
                {
                    SendReply(player, GetLang("_displayed"));
                    CuiHelper.DestroyUi(player, "skdr_main");
                    CuiHelper.AddUi(player, $"{mainContainer}");
                    CuiHelper.AddUi(player, InsertData(player, $"{baseUi}"));
                    return;
                }
                if (!permission.UserHasPermission(player.UserIDString, "simplekdr.hiden"))
                {
                    permission.GrantUserPermission(player.UserIDString, "simplekdr.hiden", null);
                    CuiHelper.DestroyUi(player, "skdr_main");
                    SendReply(player, GetLang("_hidden"));
                    return;
                }
            }
        }

        private void createBaseUI()
        {
            var ui = new CuiElementContainer();

            CUIClass.CreatePanel(ref ui, "KillsPanel", "skdr_main", config.panelKills.panelColor, config.panelKills.panelAnchorMin, config.panelKills.panelAnchorMax, false, 0f, "assets/icons/iconmaterial.mat");
            CUIClass.CreateImage(ref ui, "KillsPanel", Img(config.panelKills.panelIcon), $"0 0", $"1 1");
            CUIClass.CreateText(ref ui, "KillsText", "KillsPanel", $"1 1 1 0.75", config.panelKills.panelText, 10, "0 0", "1 1", TextAnchor.MiddleCenter, $"{config.panelKills.panelFont}", $"{config.panelKills.panelFontOutColor}", $"{config.panelKills.panelFontOut} {config.panelKills.panelFontOut}");

            CUIClass.CreatePanel(ref ui, "DeathsPanel", "skdr_main", config.panelDeaths.panelColor, config.panelDeaths.panelAnchorMin, config.panelDeaths.panelAnchorMax, false, 0f, "assets/icons/iconmaterial.mat");
            CUIClass.CreateImage(ref ui, "DeathsPanel", Img(config.panelDeaths.panelIcon), $"0 0", $"1 1");
            CUIClass.CreateText(ref ui, "DeathsText", "DeathsPanel", $"1 1 1 0.75", config.panelDeaths.panelText, 10, "0 0", "1 1", TextAnchor.MiddleCenter, $"{config.panelDeaths.panelFont}", $"{config.panelDeaths.panelFontOutColor}", $"{config.panelDeaths.panelFontOut} {config.panelDeaths.panelFontOut}");

            CUIClass.CreatePanel(ref ui, "RatioPanel", "skdr_main", config.panelRatio.panelColor, config.panelRatio.panelAnchorMin, config.panelRatio.panelAnchorMax, false, 0f, "assets/icons/iconmaterial.mat");
            CUIClass.CreateImage(ref ui, "RatioPanel", Img(config.panelRatio.panelIcon), $"0 0", $"1 1");
            CUIClass.CreateText(ref ui, "RatioText", "RatioPanel", $"1 1 1 0.75", config.panelRatio.panelText, 10, "0 0", "1 1", TextAnchor.MiddleCenter, $"{config.panelRatio.panelFont}", $"{config.panelRatio.panelFontOutColor}", $"{config.panelRatio.panelFontOut} {config.panelRatio.panelFontOut}");

            baseUi = ui;
        }

        void createKillText() => killText.Add(new CuiElement
        {
            Parent = "Overlay",
            Name = "kill_text",
            Components =
            {
                new CuiTextComponent
                {
                    Text = config.killPopUp.panelText,
                    FontSize = 11,
                    Font = config.killPopUp.panelFont,
                    Align = TextAnchor.MiddleCenter,
                    Color = "1 1 1 1",
                    FadeIn = 0.4f,
                },

                new CuiOutlineComponent
                {
                    Color = config.killPopUp.panelFontOutColor,
                    Distance = $"{config.killPopUp.panelFontOut} {config.killPopUp.panelFontOut}"
                },

                new CuiRectTransformComponent
                {
                    AnchorMin = config.killPopUp.panelAnchorMin,
                    AnchorMax =  config.killPopUp.panelAnchorMax
                }
            },
            FadeOut = 0.3f
        });

        void createMainContainer() => mainContainer.Add(new CuiPanel
        {
            Image = {
                Color = "0 0 0 0",
                Material = "assets/icons/iconmaterial.mat",
                FadeIn = 0f
            },
            RectTransform = {
                AnchorMin = config.uic.anchorMin,
                AnchorMax = config.uic.anchorMax,
                OffsetMin = config.uic.offsetMin,
                OffsetMax = config.uic.offsetMax
            }
        },
            "Hud",
            "skdr_main"
        );

        private string Img(string link)
        {
            if (ImageLibrary != null)
            {
                if (!(bool)ImageLibrary.Call("HasImage", link))
                    return link;
                else
                    return (string)ImageLibrary?.Call("GetImage", link);
            }
            else return link;
        }

        private void RunMono(BasePlayer player)
        {
            if (!config.killPopUp.panelEnabled) return;

            var run = _monoBehavior[player];

            if (run == null) PlayerComponent(true, player);

            if (run != null) run.ShowKillMsg(player);
        }

        string InsertData(BasePlayer player, string ui)
        {
            var data = playerData[player.userID];

            if (data.kills == 0)
                return ui.Replace("{kills}", data.kills.ToString()).Replace("{deaths}", data.deaths.ToString()).Replace("{ratio}", (0).ToString("0.00"));

            if (data.deaths == 0)
                return ui.Replace("{kills}", data.kills.ToString()).Replace("{deaths}", data.deaths.ToString()).Replace("{ratio}", data.kills.ToString("0.00"));

            return ui.Replace("{kills}", data.kills.ToString()).Replace("{deaths}", data.deaths.ToString()).Replace("{ratio}", ((float)data.kills / (float)data.deaths).ToString("0.00"));
        }

        private void DestroyPanels(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "KillsPanel");
            CuiHelper.DestroyUi(player, "DeathsPanel");
            CuiHelper.DestroyUi(player, "RatioPanel");
        }


        #endregion

        #region Data

        private void SaveData()
        {
            if (playerData != null)
                Interface.Oxide.DataFileSystem.WriteObject($"{Name}/PlayerData", playerData);
        }

        private Dictionary<ulong, PlayerData> playerData;

        private class PlayerData
        {
            public int kills;
            public int deaths;
            public string name;
        }

        private void LoadData()
        {
            if (Interface.Oxide.DataFileSystem.ExistsDatafile($"{Name}/PlayerData"))
            {
                playerData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, PlayerData>>($"{Name}/PlayerData");
            }
            else
            {
                playerData = new Dictionary<ulong, PlayerData>();
                SaveData();
            }
        }


        #endregion

        #region CUI Reusable

        public class CUIClass
        {
            public static void CreatePanel(ref CuiElementContainer _container, string _name, string _parent, string _color, string _anchorMin, string _anchorMax, bool _cursorOn = false, float _fade = 0f, string _mat2 = "")
            {
                _container.Add(new CuiPanel
                {
                    Image = { Color = _color, Material = _mat2, FadeIn = _fade },
                    RectTransform = { AnchorMin = _anchorMin, AnchorMax = _anchorMax },
                    CursorEnabled = _cursorOn
                },
                _parent,
                _name);
            }

            public static void CreateImage(ref CuiElementContainer _container, string _parent, string _image, string _anchorMin, string _anchorMax, float _fade = 0f)
            {
                if (_image.StartsWith("http") || _image.StartsWith("www"))
                {
                    _container.Add(new CuiElement
                    {
                        Parent = _parent,
                        Components =
                        {
                            new CuiRawImageComponent { Url = _image, Sprite = "assets/content/textures/generic/fulltransparent.tga", FadeIn = _fade},
                            new CuiRectTransformComponent { AnchorMin = _anchorMin, AnchorMax = _anchorMax }
                        }
                    });
                }
                else
                {
                    _container.Add(new CuiElement
                    {
                        Parent = _parent,
                        Components =
                        {
                            new CuiRawImageComponent { Png = _image, Sprite = "assets/content/textures/generic/fulltransparent.tga", FadeIn = _fade},
                            new CuiRectTransformComponent { AnchorMin = _anchorMin, AnchorMax = _anchorMax }
                        }
                    });
                }
            }

            public static void CreateText(ref CuiElementContainer _container, string _name, string _parent, string _color, string _text, int _size, string _anchorMin, string _anchorMax, TextAnchor _align = TextAnchor.MiddleCenter, string _font = "robotocondensed-bold.ttf", string _outlineColor = "", string _outlineScale = "")
            {


                _container.Add(new CuiElement
                {
                    Parent = _parent,
                    Name = _name,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = _text,
                            FontSize = _size,
                            Font = _font,
                            Align = _align,
                            Color = _color,
                            FadeIn = 0f,
                        },

                        new CuiOutlineComponent
                        {

                            Color = _outlineColor,
                            Distance = _outlineScale

                        },

                        new CuiRectTransformComponent
                        {
                             AnchorMin = _anchorMin,
                             AnchorMax = _anchorMax
                        }
                    },
                });
            }
        }
        #endregion

        #region Config 

        private Configuration config;
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<Configuration>();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = Configuration.CreateConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        class Configuration
        {
            [JsonProperty(PropertyName = "Main Settings")]
            public MS ms { get; set; }

            public class MS
            {
                [JsonProperty("Reset data on wipe")]
                public bool wipeReset { get; set; }

                [JsonProperty("Count NPC kills")]
                public bool countNpc { get; set; }

                [JsonProperty("Count suicides")]
                public bool countSuicide { get; set; }

                [JsonProperty("Chat command to hide ui")]
                public string hideCmd { get; set; }

            }

            [JsonProperty(PropertyName = "Main Ui Container (used to position all panels at once)")]
            public UiC uic { get; set; }
            public class UiC
            {
                [JsonProperty("Anchor Min")]
                public string anchorMin { get; set; }

                [JsonProperty("Anchor Max")]
                public string anchorMax { get; set; }

                [JsonProperty("Offset Min")]
                public string offsetMin { get; set; }

                [JsonProperty("Offset Max")]
                public string offsetMax { get; set; }

            }

            [JsonProperty(PropertyName = "Kills Panel")]
            public PanelKills panelKills { get; set; }

            public class PanelKills
            {
                [JsonProperty("Enabled")]
                public bool panelEnabled { get; set; }

                [JsonProperty("Panel Color")]
                public string panelColor { get; set; }

                [JsonProperty("Img")]
                public string panelIcon { get; set; }

                [JsonProperty("Text")]
                public string panelText { get; set; }

                [JsonProperty("Font")]
                public string panelFont { get; set; }

                [JsonProperty("Text Outline Thickness")]
                public string panelFontOut { get; set; }

                [JsonProperty("Text Outline Color")]
                public string panelFontOutColor { get; set; }

                [JsonProperty("Anchor Min")]
                public string panelAnchorMin { get; set; }

                [JsonProperty("Anchor Max")]
                public string panelAnchorMax { get; set; }

            }

            [JsonProperty(PropertyName = "Deaths Panel")]
            public PanelDeaths panelDeaths { get; set; }

            public class PanelDeaths
            {
                [JsonProperty("Enabled")]
                public bool panelEnabled { get; set; }

                [JsonProperty("Panel Color")]
                public string panelColor { get; set; }

                [JsonProperty("Img")]
                public string panelIcon { get; set; }

                [JsonProperty("Text")]
                public string panelText { get; set; }

                [JsonProperty("Font")]
                public string panelFont { get; set; }

                [JsonProperty("Text Outline Thickness")]
                public string panelFontOut { get; set; }

                [JsonProperty("Text Outline Color")]
                public string panelFontOutColor { get; set; }

                [JsonProperty("Anchor Min")]
                public string panelAnchorMin { get; set; }

                [JsonProperty("Anchor Max")]
                public string panelAnchorMax { get; set; }

            }

            [JsonProperty(PropertyName = "Ratio Panel")]
            public PanelRatio panelRatio { get; set; }

            public class PanelRatio
            {
                [JsonProperty("Enabled")]
                public bool panelEnabled { get; set; }

                [JsonProperty("Panel Color")]
                public string panelColor { get; set; }

                [JsonProperty("Img")]
                public string panelIcon { get; set; }

                [JsonProperty("Text")]
                public string panelText { get; set; }

                [JsonProperty("Font")]
                public string panelFont { get; set; }

                [JsonProperty("Text Outline Thickness")]
                public string panelFontOut { get; set; }

                [JsonProperty("Text Outline Color")]
                public string panelFontOutColor { get; set; }

                [JsonProperty("Anchor Min")]
                public string panelAnchorMin { get; set; }

                [JsonProperty("Anchor Max")]
                public string panelAnchorMax { get; set; }

            }

            [JsonProperty(PropertyName = "Pop up notification on kill")]
            public KillPopUp killPopUp { get; set; }

            public class KillPopUp
            {
                [JsonProperty("Enabled")]
                public bool panelEnabled { get; set; }

                [JsonProperty("Text")]
                public string panelText { get; set; }

                [JsonProperty("Font")]
                public string panelFont { get; set; }

                [JsonProperty("Text Outline Thickness")]
                public string panelFontOut { get; set; }

                [JsonProperty("Text Outline Color")]
                public string panelFontOutColor { get; set; }

                [JsonProperty("Anchor Min")]
                public string panelAnchorMin { get; set; }

                [JsonProperty("Anchor Max")]
                public string panelAnchorMax { get; set; }

            }



            public static Configuration CreateConfig()
            {
                return new Configuration
                {

                    ms = new SimpleKDR.Configuration.MS
                    {

                        wipeReset = true,
                        countNpc = false,
                        countSuicide = true,
                        hideCmd = "kdr",
                    },

                    uic = new SimpleKDR.Configuration.UiC
                    {
                        anchorMin = "0 0",
                        anchorMax = "0 0",
                        offsetMin = "5 5",
                        offsetMax = "250 25",
                    },

                    panelKills = new SimpleKDR.Configuration.PanelKills
                    {
                        panelEnabled = true,
                        panelColor = "0 0 0 0",
                        panelIcon = "https://rustplugins.net/products/KDR-assets/greenstripe.png",
                        panelText = "<b>{kills}</b> KILLS",
                        panelFont = "robotocondensed-regular.ttf",
                        panelFontOut = "0",
                        panelFontOutColor = "0 0 0 0",
                        panelAnchorMin = "0 0",
                        panelAnchorMax = "0.3 1",
                    },

                    panelDeaths = new SimpleKDR.Configuration.PanelDeaths
                    {
                        panelEnabled = true,
                        panelColor = "0 0 0 0",
                        panelIcon = "https://rustplugins.net/products/KDR-assets/redstripe.png",
                        panelText = "<b>{deaths}</b> DEATHS",
                        panelFont = "robotocondensed-regular.ttf",
                        panelFontOut = "0",
                        panelFontOutColor = "0 0 0 0",
                        panelAnchorMin = "0.33 0",
                        panelAnchorMax = "0.63 1"
                    },

                    panelRatio = new SimpleKDR.Configuration.PanelRatio
                    {
                        panelEnabled = true,
                        panelColor = "0 0 0 0",
                        panelIcon = "https://rustplugins.net/products/KDR-assets/bluestripe.png",
                        panelText = "<b>{ratio}</b> RATIO",
                        panelFont = "robotocondensed-regular.ttf",
                        panelFontOut = "0",
                        panelFontOutColor = "0 0 0 0",
                        panelAnchorMin = "0.66 0",
                        panelAnchorMax = "1 1"
                    },

                    killPopUp = new SimpleKDR.Configuration.KillPopUp
                    {
                        panelEnabled = true,
                        panelText = "+1",
                        panelFont = "<size=17><color=#ffc126>+1 KILL</color></size>",
                        panelFontOut = "0.8",
                        panelFontOutColor = "0 0 0 1",
                        panelAnchorMin = "0.55 0.5",
                        panelAnchorMax = "0.66 0.6"
                    },

                };
            }

        }
        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["_noPerm"] = "<color=#C57039>[SimpleKDR]</color> You don't have permission to do that.",
                ["_hidden"] = "<color=#C57039>[SimpleKDR]</color> Hidden.",
                ["_displayed"] = "<color=#C57039>[SimpleKDR]</color> Displayed.",

            }, this);
        }

        private string GetLang(string _message) => lang.GetMessage(_message, this);

        #endregion

    }
}

// --- End of file: SimpleKDR.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PlayerRadar.cs ---
// --- Original Local Path: PlayerRadar.cs ---

using System.Collections.Generic;
using System;
using System.Reflection;
using System.Data;
using UnityEngine;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("PlayerRadar", "Reneb", "1.0.2", ResourceId = 1326)]
    class PlayerRadar : RustPlugin
    {
        private static int authlevel = 2;
        private static FieldInfo serverinput;
        static int playerCol;
        private static string xmin = "0.5";
        private static string xmax = "0.9";
        private static string ymin = "0.5";
        private static string ymax = "0.9";
        private static string refreshSpeed = "0.1";
        private static bool showSleepers = false;
        private static string permName = "canradar";
        private static string playerColor = "0 0.8 0 1";
        private static string npcColor = "1 0.5 0 1";
        private static string sleeperColor = "0.8 0 0 1";
        private static string radarUrl = "http://s28.postimg.org/r8ebzj1yl/radar_1.png";
        private static float refreshspeed = 0.1f;

        void LoadDefaultConfig() { }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        } 

        void Init()
        {
            CheckCfg<int>("Admin - AuthLevel", ref authlevel);
            CheckCfg<string>("Admin - Permissions Name", ref permName);
            CheckCfg<string>("GUI - X Min", ref xmin);
            CheckCfg<string>("GUI - X Max", ref xmax);
            CheckCfg<string>("GUI - Y Min", ref ymin);
            CheckCfg<string>("GUI - Y Max", ref ymax);
            CheckCfg<bool>("Radar - Show Sleepers", ref showSleepers);
            CheckCfg<string>("Radar - Refresh Speed", ref refreshSpeed);
            CheckCfg<string>("Radar - Image URL", ref radarUrl);
            CheckCfg<string>("Radar - Color - Sleepers", ref sleeperColor);
            CheckCfg<string>("Radar - Color - Players", ref playerColor);
            CheckCfg<string>("Radar - Color - HumanNPC", ref npcColor);
            SaveConfig();

            refreshspeed = Convert.ToSingle(refreshSpeed);
        }

        void Unload()
        {
            var objects = GameObject.FindObjectsOfType(typeof(RadarClass));
            if (objects != null)
                foreach (var gameObj in objects)
                    GameObject.Destroy(gameObj);
        }


        void Loaded()
        {
            serverinput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            playerCol = LayerMask.GetMask(new string[] { "Player (Server)" });
            radaroverlay = radaroverlay.Replace("{xmin}", xmin).Replace("{xmax}", xmax).Replace("{ymin}", ymin).Replace("{ymax}", ymax).Replace("{radarurl}", radarUrl);
            if (!permission.PermissionExists(permName)) permission.RegisterPermission(permName, this);
        }
         
        public class RadarClass : MonoBehaviour
        {
            public BasePlayer player;
            public float distance;

            void Awake()
            {
                player = GetComponent<BasePlayer>();
                distance = 100f;
                InvokeRepeating("Radar", 0f, refreshspeed);
            }
            
            void Radar()
            {
                if (player == null) GameObject.Destroy(this);
                if (!player.IsConnected()) GameObject.Destroy(this);
                ShowGUI(player, distance);
            }
            void OnDestroy()
            {
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "DestroyUI", "RadarUnderlay");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "DestroyUI", "RadarOverlay");
            }
        }


        public static string radaroverlay = @"[  
		                { 
							""name"": ""RadarOverlay"",
                            ""parent"": ""Overlay"",
                            ""components"":
                            [
                                {
                                     ""type"":""UnityEngine.UI.RawImage"",
                                    ""imagetype"":""Tiled"",
                                     ""url"":""{radarurl}"",
                                },
                                {
                                    ""type"":""RectTransform"",
                                    ""anchormin"": ""{xmin} {ymin}"",
                                    ""anchormax"": ""{xmax} {ymax}""
                                }
                            ]
                        },
                    ]
                    ";
        public static string radarunderlay = @"[
                        { 
							""name"": ""RadarUnderlay"",
                            ""parent"": ""RadarOverlay"",
                            ""components"":
                            [
                                {
                                     ""type"":""UnityEngine.UI.Image"",
                                     ""color"":""0.1 0.1 0.1 0"",
                                },
                                {
                                    ""type"":""RectTransform"",
                                    ""anchormin"": ""0 0"",
                                    ""anchormax"": ""1 1""
                                }
                            ]
                        }
                    ]
                    ";
        public static string playerjson = @"[  
		                { 
							""parent"": ""RadarUnderlay"",
                            ""components"":
                            [
                                {
                                     ""type"":""UnityEngine.UI.Image"",
                                     ""color"":""{color}"",
                                },
                                {
                                    ""type"":""RectTransform"",
                                    ""anchormin"": ""{xmin} {ymin}"",
                                    ""anchormax"": ""{xmax} {ymax}""
                                }
                            ]
                        }
                    ]
                    ";
        static void ShowGUI(BasePlayer player, float distance)
        {
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "DestroyUI", "RadarUnderlay");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "AddUI", radarunderlay);
             
            var input = serverinput.GetValue(player) as InputState;
            var angle = input.current.aimAngles.y;
            var player_x = player.transform.position.x;
            var player_y = player.transform.position.z;
            string color = string.Empty;
            Collider playerCollider = player.GetComponentInChildren<Collider>();
            foreach (Collider col in Physics.OverlapSphere(player.transform.position, distance, playerCol))
            {
                if (playerCollider == col) continue;
                BasePlayer targetplayer = col.GetComponentInParent<BasePlayer>();
                if (targetplayer == null) continue;

                color = targetplayer.IsConnected() ? playerColor : npcColor;
                float x = col.transform.position.x;
                float y = col.transform.position.z;
                int x2 = (int)((x - player_x) * Math.Cos(Math.PI * angle / 180) - (y - player_y) * Math.Sin(Math.PI * angle / 180)) * 50 / (int)distance + 50;
                int y2 = (int)((x - player_x) * Math.Sin(Math.PI * angle / 180) + (y - player_y) * Math.Cos(Math.PI * angle / 180)) * 50 / (int)distance + 50;
                var playerpos = playerjson.Replace("{xmin}", ((Convert.ToDecimal(x2) - 0.5m) / 100).ToString()).Replace("{color}", color).Replace("{xmax}", ((Convert.ToDecimal(x2) + 0.5m) / 100).ToString()).Replace("{ymin}", ((Convert.ToDecimal(y2) - 0.50m) / 100).ToString()).Replace("{ymax}", ((Convert.ToDecimal(y2) + 0.5m) / 100).ToString());
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "AddUI", playerpos);
            } 

            if (!showSleepers) return;
            color = sleeperColor;
            foreach (BasePlayer targetplayer in BasePlayer.sleepingPlayerList)
            {
                if (Vector3.Distance(targetplayer.transform.position, player.transform.position) > distance) continue;
                float x = targetplayer.transform.position.x;
                float y = targetplayer.transform.position.z;
                int x2 = (int)((x - player_x) * Math.Cos(Math.PI * angle / 180) - (y - player_y) * Math.Sin(Math.PI * angle / 180)) * 50 / (int)distance + 50;
                int y2 = (int)((x - player_x) * Math.Sin(Math.PI * angle / 180) + (y - player_y) * Math.Cos(Math.PI * angle / 180)) * 50 / (int)distance + 50;
                var playerpos = playerjson.Replace("{xmin}", ((Convert.ToDecimal(x2) - 0.5m) / 100).ToString()).Replace("{color}", color).Replace("{xmax}", ((Convert.ToDecimal(x2) + 0.5m) / 100).ToString()).Replace("{ymin}", ((Convert.ToDecimal(y2) - 0.50m) / 100).ToString()).Replace("{ymax}", ((Convert.ToDecimal(y2) + 0.5m) / 100).ToString());
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "AddUI", playerpos);
            }
        }

        [ChatCommand("radar")]
        void cmdChatRadar(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel < authlevel && !permission.UserHasPermission(player.userID.ToString(), permName))
            {
                SendReply(player, "You are not allowed to use this command");
                return;
            }
            RadarClass rplayer = player.GetComponent<RadarClass>();
            if (rplayer != null)
            {
                GameObject.Destroy(rplayer);
                if (args.Length == 0)
                    return;
            }
            timer.Once(0.1f, ()  =>
            {
                rplayer = player.gameObject.AddComponent<RadarClass>();
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "AddUI", radaroverlay);
                 
                float dist = 500f;
                if (args.Length > 0)
                    float.TryParse(args[0], out dist);
                rplayer.distance = dist;
                rplayer.enabled = true;
            }
            );
        }
    }
} 

// --- End of file: PlayerRadar.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Salvager.cs ---
// --- Original Local Path: Salvager.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Collections;

namespace Oxide.Plugins
{
    [Info("Salvager", "Deicide666ra", "1.0.2")]
    class Salvager : RustPlugin
    {
        // Configuration
        Dictionary<string, string> c_salvagers= new Dictionary<string, string>(); // uniqueId, steamId
        string c_price; // default: "1000 wood + 5000 metal.fragments"
        double c_refundRatio; // default: 0.5

        // Global variables
        Dictionary<ulong, string> g_playerCommands = new Dictionary<ulong, string>(); // steamid, activeCommand
        Dictionary<string, ItemDefinition> g_itemDefinitions = new Dictionary<string, ItemDefinition>();
        Dictionary<string, ItemBlueprint> g_blueprintDefinitions = new Dictionary<string, ItemBlueprint>();
        Dictionary<string, BasePlayer> g_lootCache = new Dictionary<string, BasePlayer>();
        Dictionary<string, int> g_priceDict = new Dictionary<string, int>();
        bool g_configChanged;

        void Loaded() => LoadConfigValues();

        protected override void LoadDefaultConfig()
        {
            Puts("New configuration file created.");
        }

        void LoadConfigValues()
        {
            // Refund ratio
            c_refundRatio= Convert.ToDouble(GetConfigValue("Salvager", "Refund Ratio", 0.5));

            // Price
            c_price = Convert.ToString(GetConfigValue("Salvager", "Price", "1000 wood + 5000 metal.fragments"));
            g_priceDict.Clear();
            var pricePieces = c_price.Split('+');
            foreach (var piece in pricePieces)
            {
                var parts = piece.Trim(' ').Split(' ');
                g_priceDict.Add(parts.Last(), Convert.ToInt32(parts.First()));
            }
            //foreach (var element in g_priceDict)
            //{
            //    Puts($"{element.Key} X{element.Value}");
            //}

            // Salvagers vs owners
            var mess= GetConfigValue("Salvager", "Salvagers", c_salvagers);
            foreach (var entry in (IEnumerable)mess)
            {
                var parts = entry.ToString().Trim(new[] { '[', ']' }).Split(',');
                c_salvagers.Add(parts.First(), parts.Last());
            }
            //foreach (var entry in c_salvagers)
            //{
            //    Puts($"key: {entry.Key} value: {entry.Value}");
            //}

            if (g_configChanged)
            {
                Puts("Configuration file updated.");
                SaveConfig();
            }
        }

        object GetConfigValue(string category, string setting, object defaultValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[category] = data;
                g_configChanged = true;
            }

            if (data.TryGetValue(setting, out value)) return value;
            value = defaultValue;
            data[setting] = value;
            g_configChanged = true;
            return value;
        }

        void SetConfigValue(string category, string setting, object newValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;
            if (data != null && data.TryGetValue(setting, out value))
            {
                value = newValue;
                data[setting] = value;
                g_configChanged = true;
            }
            SaveConfig();
        }

        void OnServerInitialized()
        {
            g_itemDefinitions= ItemManager.itemList.ToDictionary(c => c.shortname, c => c);
            g_blueprintDefinitions = ItemManager.bpList.ToDictionary(c => c.targetItem.shortname, c => c);
        }

        [ChatCommand("salvager")]
        void cmdSalvager(BasePlayer player, string cmd, string[] args)
        {
            if (args.Length != 1)
            {
                var sb = new StringBuilder();
                sb.Append("<color=lime>Salvager</color> version <color=yellow>1.0.2</color> by <color=red>Deicide666ra</color>\n");
                sb.Append("Original idea by <color=red>[HBros]Moe</color>\n");
                sb.Append("=======================================\n");
                sb.Append("\tAvailable commands:\n");
                sb.Append("\t\t<color=yellow>/salvager buy</color>\t\t\tenables buy mode\n");
                sb.Append("\t\t<color=yellow>/salvager remove</color>\tstarts remove mode\n");
                sb.Append(GetPriceString());
                player.ChatMessage(sb.ToString());
                return;
            }

            var arg = args[0].ToLower();

            if (arg == "buy")
            {
                if (!HasPrice(player))
                {
                    player.ChatMessage(FormatError(GetPriceString()));
                    return;
                }

                LinkContainer(player);
                return;
            }

            if (arg == "remove")
            {
                UnlinkContainer(player);
                return;
            }
        }

        void LinkContainer(BasePlayer player)
        {
            var sb = new StringBuilder();

            var currentCommand = GetActiveCommand(player);
            if (currentCommand != null)
            {
                ClearActiveCommand(player);
                sb.Append($"<color=yellow>{currentCommand}</color> mode is now <color=red>OFF</color>\n");
            }

            SetActiveCommand(player, "buy");

            sb.Append($"<color=yellow>buy</color> mode is now <color=lime>ON</color>\nOpen the <color=yellow>Repair Bench</color> you wish to convert to a <color=yellow>Salvaging Bench</color>");
            player.ChatMessage(sb.ToString());
        }

        void UnlinkContainer(BasePlayer player)
        {
            var sb = new StringBuilder();

            var currentCommand = GetActiveCommand(player);
            if (currentCommand != null)
            {
                ClearActiveCommand(player);
                sb.Append($"<color=yellow>{currentCommand}</color> mode is now <color=red>OFF</color>\n");
            }

            SetActiveCommand(player, "remove");

            sb.Append($"<color=yellow>remove</color> mode is now <color=lime>ON</color>\nOpen the <color=yellow>Salvaging Bench</color> you wish to convert back to a <color=yellow>Repair Bench</color>");
            player.ChatMessage(sb.ToString());
        }

        void OnPlayerLoot(PlayerLoot lootInventory, object lootable)
        {
            var looter = lootInventory.GetComponent("BasePlayer") as BasePlayer;
            if (looter == null) return;

            BaseEntity container = lootable as BaseEntity;
            if (container == null) return;
            if (container.LookupShortPrefabName() != "repairbench_deployed.prefab") return;

            string command = GetActiveCommand(looter);
            if (command == null)
            {
                ulong owner = GetSalvagerOwner(container);
                if (owner != 0)
                {
                    looter.ChatMessage("You found a <color=yellow>Salvaging Bench!</color>!");
                }
                g_lootCache[UniqueId(container)] = looter;
                return;
            }

            var sb = new StringBuilder();
            ClearActiveCommand(looter);
            sb.Append($"<color=yellow>{command}</color> mode is now <color=red>OFF</color>");
            looter.ChatMessage(sb.ToString());

            RunCommand(looter, command, container);
        }

        bool CheckPlayerInventoryForItems(BasePlayer player, string shortname, int amount)
        {
            ItemDefinition itemToCheck = null;
            var ret = g_itemDefinitions.TryGetValue(shortname, out itemToCheck);
            if (ret == false) return false;
            var foundItems = player.inventory.FindItemIDs(itemToCheck.itemid);
            if (foundItems == null || !foundItems.Any()) return false;
            var nbFound = foundItems == null ? 0 : foundItems.Sum(item => item.amount);
            if (nbFound < amount) return false;
            return true;
        }

        int RemoveItemsFromInventory(BasePlayer player, string shortname, int amount)
        {
            ItemDefinition itemToRemove = null;
            var ret = g_itemDefinitions.TryGetValue(shortname, out itemToRemove);
            if (ret == false) return 0;
            var foundItems = player.inventory.FindItemIDs(itemToRemove.itemid);
            if (foundItems == null || !foundItems.Any()) return 0;
            var nbFound = foundItems == null ? 0 : foundItems.Sum(item => item.amount);
            if (nbFound < amount) amount = nbFound;
            var nbRemoved = player.inventory.Take(foundItems, itemToRemove.itemid, amount);
            return nbRemoved;
        }

        string GetPriceString()
        {
            var sb = new StringBuilder();
            sb.Append("The price to setup a <color=yellow>Salvaging Bench is</color>:\n");
            foreach (var price in g_priceDict)
            {
                sb.Append($"\t\t{price.Key} X {price.Value}\n");
            }

            return sb.ToString();
        }

        bool HasPrice(BasePlayer player )
        {
            foreach (var price in g_priceDict)
            {
                if (!CheckPlayerInventoryForItems(player, price.Key, price.Value))
                    return false;
            }
            return true;
        }

        void RunCommand(BasePlayer player, string command, BaseEntity container)
        {
            var owner = GetSalvagerOwner(container);

            //*********************************************
            // LINKBOX
            //*********************************************
            if (command.StartsWith("buy"))
            {
                // Make sure the bench is not already associated with a list
                if (owner != 0)
                {
                    player.ChatMessage(FormatError("This <color=yellow>Repair Bench</color> is already a <color=yellow>Salvaging Bench</color>, use <color=yellow>/salvager remove</color> to cancel (must be owner)"));
                    return;
                }

                // Check if we have the price and if so, remove
                if (!HasPrice(player)) 
                {
                    player.ChatMessage(FormatError(GetPriceString()));
                    return;
                }
                foreach (var price in g_priceDict)
                {
                    var removed = RemoveItemsFromInventory(player, price.Key, price.Value);
                    if (removed != price.Value)
                    {
                        Puts($"Oh snap! Tried to remove {price.Value} X {price.Key} but only {removed} were found --- this should not happen, contact the author");
                    }
                }
                    

                // Link the box
                c_salvagers.Add(UniqueId(container), player.userID.ToString());

                // Save the config
                SetConfigValue("Salvager", "Salvagers", c_salvagers);

                // Report success
                player.ChatMessage($"<color=yellow>Repair Bench</color> is now a <color=yellow>Salvaging Bench</color>!");
                return;
            }

            //*********************************************
            // UNLINKBOX
            //*********************************************
            if (command.StartsWith("remove"))
            {
                // Abort if no list is currently associated with the box
                if (owner == 0)
                {
                    player.ChatMessage(FormatError("This <color=yellow>Repair Bench</color> is not a <color=yellow>Salvaging Bench!</color>"));
                    return;
                }

                // Unlink the box
                c_salvagers.Remove(UniqueId(container));

                // Save the config
                SetConfigValue("Salvager", "Salvagers", c_salvagers);

                // Report success
                player.ChatMessage($"<color=yellow>Salvaging Bench</color> successfully reverted to a <color=yellow>Repair Bench</color>");
                return;
            }
        }

        private string GetActiveCommand(BasePlayer player)
        {
            string command = null;
            g_playerCommands.TryGetValue(player.userID, out command);
            return command;
        }

        private void SetActiveCommand(BasePlayer player, string command)
        {
            string oldCommand = GetActiveCommand(player);
            if (oldCommand != null) ClearActiveCommand(player);
            g_playerCommands.Add(player.userID, command);
        }

        private void ClearActiveCommand(BasePlayer player)
        {
            if (GetActiveCommand(player) != null)
                g_playerCommands.Remove(player.userID);
        }

        private ulong GetSalvagerOwner(BaseEntity container)
        {
            string steamId = "0";
            c_salvagers.TryGetValue(UniqueId(container), out steamId);
            return Convert.ToUInt64(steamId);
        }

        private bool CreateSalvager(BaseEntity container, ulong steamIdOwner)
        {
            var currentOwner = GetSalvagerOwner(container);
            if (currentOwner != 0)
            {
                // Error already salvager
                return false;
            }
            
            c_salvagers.Add(UniqueId(container), steamIdOwner.ToString());
            return true;
        }

        void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            StorageContainer entity = container.entityOwner as StorageContainer;
            if (entity == null) return;

            if (entity.LookupShortPrefabName() != "repairbench_deployed.prefab") return;

            if (GetSalvagerOwner(entity) == 0) return;
            
            // Try to identify the looter based on stored info (ugly hack)
            BasePlayer player;
            if (g_lootCache.TryGetValue(UniqueId(entity), out player) == false || player == null)
            {
                //Puts($"Looter cannot be identified");
                return;
            }

            if (item.hasCondition && item.condition == 0)
            {
                player.ChatMessage(FormatError("This item is totally broken, nothing would be salvageable, try repairing it first!"));
                return;
            }

            ItemBlueprint bp = null;
            if (g_blueprintDefinitions.TryGetValue(item.info.shortname, out bp) == false)
            {
                player.ChatMessage(FormatError($"This item is not recyclable: {item.info.displayName.english}"));
                player.GiveItem(item);
                return;
            }

            item.RemoveFromContainer();
            SalvageItem(player, item);

            player.ChatMessage($"Successfully recycled <color=yellow>{item.info.displayName.english}</color> to base materials!");
        }

        void SalvageItem(BasePlayer player, Item item)
        {
            ItemBlueprint bp = null;
            if (g_blueprintDefinitions.TryGetValue(item.info.shortname, out bp) == false)
                return;

            var ratio = item.hasCondition ? (item.condition / item.maxCondition) : 1;

            foreach (var ingredient in bp.ingredients)
            {
                var refundAmount = (double)ingredient.amount / bp.amountToCreate;
                refundAmount *= item.amount;
                refundAmount *= ratio;
                refundAmount *= c_refundRatio;
                refundAmount = Math.Ceiling(refundAmount);
                if (refundAmount < 1) refundAmount = 1;
                
                ItemBlueprint ingredientBp = null;
                if (g_blueprintDefinitions.TryGetValue(ingredient.itemDef.shortname, out ingredientBp) == true)
                {
                    // Cascade down other salvageable items
                    var subItem= ItemManager.CreateByName(ingredient.itemDef.shortname, (int)refundAmount);
                    if (subItem.hasCondition && item.hasCondition) subItem.condition = item.condition;
                    SalvageItem(player, subItem);
                }
                else
                {
                    var newItem = ItemManager.Create(g_itemDefinitions[ingredient.itemDef.shortname], (int)refundAmount);
                    player.GiveItem(newItem);
                }
            }
        }

        string UniqueId(BaseEntity entity)
        {
            return $"({entity.transform.localPosition.x};{entity.transform.localPosition.y};{entity.transform.localPosition.z})";
        }

        string FormatError(string message)
        {
            return $"<color=red>ERROR</color>: {message} - <color=orange>aborting</color>.";
        }
    }
}

// --- End of file: Salvager.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/DamageDisplay.cs ---
// --- Original Local Path: DamageDisplay.cs ---

using Rust;
using System;
using System.Collections.Generic;
using Oxide.Game.Rust.Cui;
using Oxide.Core;
using UnityEngine;
using System.Linq;

namespace Oxide.Plugins
{

    [Info("DamageDisplayGUI", "cogu", "1.6.1")]
    [Description("Displays the given damage to a player in a GUI")]
    class DamageDisplay : RustPlugin
    {
		/////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
		///////////////////////////////////////				Configs			\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
		/////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
				
        HashSet<ulong> users = new HashSet<ulong>();
		System.Collections.Generic.List<ulong> DisabledFor = new System.Collections.Generic.List<ulong>();
		public float DisplayAttackerNameRange => Config.Get<float>("DisplayAttackerNameRange");
		public float DisplayVictimNameRange => Config.Get<float>("DisplayVictimNameRange");
		public bool DisplayDistance => Config.Get<bool>("DisplayDistance");
		public bool DisplayBodyPart => Config.Get<bool>("DisplayBodyPart");
		public bool DamageForAttacker => Config.Get<bool>("DamageForAttacker");
		public bool DamageForVictim => Config.Get<bool>("DamageForVictim");
		public float X_MinVictim => Config.Get<float>("X_MinVictim");
		public float X_MaxVictim => Config.Get<float>("X_MaxVictim");
		public float Y_MinVictim => Config.Get<float>("Y_MinVictim");
		public float Y_MaxVictim => Config.Get<float>("Y_MaxVictim");
		public float X_MinAttacker => Config.Get<float>("X_MinAttacker");
		public float X_MaxAttacker => Config.Get<float>("X_MaxAttacker");
		public float Y_MinAttacker => Config.Get<float>("Y_MinAttacker");
		public float Y_MaxAttacker => Config.Get<float>("Y_MaxAttacker");
		public float DisplayTime => Config.Get<float>("DisplayTime");
		void Unload() => SaveData();
        void OnServerSave() => SaveData();
		
		protected override void LoadDefaultConfig()
        {	
			Config["DisplayAttackerNameRange"] = 50;
			Config["DisplayVictimNameRange"] = 50;
			Config["DisplayDistance"] = true;
			Config["DisplayBodyPart"] = false;
			Config["DamageForVictim"] = true;
			Config["DamageForAttacker"] = true;
			Config["X_MinVictim"] = 0.355;
			Config["X_MaxVictim"] = 0.475;
			Config["Y_MinVictim"] = 0.91;
			Config["Y_MaxVictim"] = 0.99;
			Config["X_MinAttacker"] = 0.555;
			Config["X_MaxAttacker"] = 0.675;
			Config["Y_MinAttacker"] = 0.91;
			Config["Y_MaxAttacker"] = 0.99;
			Config["DisplayTime"] = 0.3f;
			SaveConfig();
        }
		
		/////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

        private void OnEntityTakeDamage(BaseCombatEntity victim, HitInfo hitInfo)
        {
			
            if (victim == null || hitInfo == null) return;
            DamageType type = hitInfo.damageTypes.GetMajorityDamageType();
            if (type == null) return;

            if (hitInfo?.Initiator != null && hitInfo?.Initiator?.ToPlayer() != null && users.Contains(hitInfo.Initiator.ToPlayer().userID) && victim.ToPlayer() != null)
            {
				/////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
				///////////////////////////////////////				Configs			\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
				/////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
				
				string vName = "";
				string aName = "";
				string bodypart = "";
				string distance = "";
				float displaytime = DisplayTime;
				float xminvictim = X_MinVictim;
				float xmaxvictim = X_MaxVictim;
				float yminvictim = Y_MinVictim;
				float ymaxvictim = Y_MaxVictim;
				float xminattacker = X_MinAttacker;
				float xmaxattacker = X_MaxAttacker;
				float yminattacker = Y_MinAttacker;
				float ymaxattacker = Y_MaxAttacker;
				float distanceBetween = Vector3.Distance(victim.transform.position,hitInfo.Initiator.ToPlayer().transform.position);
				float displayattackerrange = DisplayAttackerNameRange;
				float displayvictimrange = DisplayVictimNameRange;
				/////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
				
				/////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
				///////////////////////////////////////				Handling		\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
				/////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
				
                NextTick(() =>
                {
				double damage = System.Convert.ToDouble(Math.Round(hitInfo.damageTypes.Total(), 0, MidpointRounding.AwayFromZero));
				if(DisplayAttackerNameRange == -1){
					displayattackerrange = 65535;
				}
				if(DisplayVictimNameRange == -1){
					displayvictimrange = 65535;
				}
				if(DisplayBodyPart && hitInfo?.Initiator?.ToPlayer() != victim.ToPlayer()){
					bodypart = FirstUpper(GetBoneName(victim, ((uint)hitInfo?.HitBone)));
				}
				if(hitInfo?.Initiator?.ToPlayer() != victim.ToPlayer() && distanceBetween <= displayattackerrange){
					aName = hitInfo?.Initiator?.ToPlayer().displayName;
				}
				if(hitInfo?.Initiator?.ToPlayer() != victim.ToPlayer() && distanceBetween <= displayvictimrange){
					vName = victim.ToPlayer().displayName;
				}
				if(DisplayDistance && hitInfo?.Initiator?.ToPlayer() != victim.ToPlayer()){
					distance = GetDistance(victim, hitInfo);
				}
				NextTick(() =>
                {
					if(DamageForAttacker && hitInfo?.Initiator?.ToPlayer() != victim.ToPlayer()){
						UseUI(hitInfo?.Initiator?.ToPlayer(), "-"+damage.ToString()+" HP", distance, vName, bodypart, xminattacker, xmaxattacker, yminattacker, ymaxattacker);
					}
					if(DamageForVictim && hitInfo?.Initiator?.ToPlayer() != victim.ToPlayer()){
						UseUI(victim.ToPlayer(), "<color=#cc0000>-"+damage.ToString()+" HP"+"</color>", "<color=#cc0000>"+distance+"</color>", "<color=#cc0000>"+aName+"</color>", "<color=#cc0000>"+bodypart+"</color>", xminvictim, xmaxvictim, yminvictim, ymaxvictim);
					}
				});
							timer.Once(displaytime, () =>
							{
								DestroyNotification(hitInfo?.Initiator?.ToPlayer());
								DestroyNotification(victim.ToPlayer());
							});
                });
				/////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
				
            }
        }
		
		/////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
		/////////////////////////////////					  Extra					 \\\\\\\\\\\\\\\\\\\\\\\\\\
		/////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
		
		void Loaded()
        {
            LoadSavedData();
			Puts("DamageDisplay by cogu is now LIVE!");
			foreach (BasePlayer player in BasePlayer.activePlayerList)
			{
				users.Add(player.userID);
			}
        }
		
		void OnPlayerInit()
		{
			foreach (BasePlayer player in BasePlayer.activePlayerList)
			{
				users.Add(player.userID);
			}
		}

        void SaveData() => Interface.Oxide.DataFileSystem.WriteObject("DamageDisplay", users);
        void LoadSavedData()
        {
            HashSet<ulong> users = Interface.Oxide.DataFileSystem.ReadObject<HashSet<ulong>>("DamageDisplay");
            this.users = users;
        }
		
		private void UseUI(BasePlayer player, string dmg, string dst, string name, string bpart, float xmin, float xmax, float ymin, float ymax)
        {
			float dtime = DisplayTime;
			
            var elements = new CuiElementContainer();
            CuiElement textElement = new CuiElement
                {
                    Name = "DamageDisplay",
                    Parent = "HUD/Overlay",
                    FadeOut = dtime,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = dmg+"\n"+dst+"\n"+bpart+"\n"+name,
                            FontSize = 18,
                            Align = TextAnchor.MiddleCenter,
                            FadeIn = dtime
                        },
                        new CuiOutlineComponent
                        {
                            Distance = "1.0 1.0",
                            Color = "0.0 0.0 0.0 1.0"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = xmin + " " + ymin,
                            AnchorMax = xmax + " " + ymax
                        }
                    }
                };
				elements.Add(textElement);
            CuiHelper.AddUi(player, elements);
        }
		
		private void DestroyNotification(BasePlayer player)
		{
			CuiHelper.DestroyUi(player, "DamageDisplay");
		}
		
		string GetBoneName(BaseCombatEntity entity, uint boneId) => entity?.skeletonProperties?.FindBone(boneId)?.name?.english ?? "Body";
		string FirstUpper(string original)
        {
            if (original == string.Empty)
                return string.Empty;
            List<string> output = new List<string>();
            foreach (string word in original.Split(' '))
                output.Add(word.Substring(0, 1).ToUpper() + word.Substring(1, word.Length - 1));
            return ListToString(output, 0, " ");
        }
		string ListToString(List<string> list, int first, string seperator) => string.Join(seperator, list.Skip(first).ToArray());
		string GetDistance(BaseCombatEntity entity, HitInfo info)
            {
                float distance = 0.0f;
                if (entity != null && info.Initiator != null)
                {
                    distance = Vector3.Distance(info.Initiator.transform.position, entity.transform.position);
                }
                return distance.ToString("0.0").Equals("0.0") ? "" : distance.ToString("0.0") + "m";
            }
			
		/////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
	}
}


// --- End of file: DamageDisplay.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ForestBerries.cs ---
// --- Original Local Path: ForestBerries.cs ---

using Random = UnityEngine.Random;
namespace Oxide.Plugins
{
    [Info("Forest Berries", "0xPani", "1.0.0")]
    class ForestBerries : RustPlugin
    {
		private float chance = 20f; //Шанс выпадения ягод при сборе грибов лол
		
		object OnCollectiblePickup(Item item, BasePlayer player)
		{
			if (item.info.shortname.Contains("mushroom"))
			{
				if (UnityEngine.Random.Range(0f, 100f) < chance)
				{
					var amount = Random.Range(1, 3); //Рандомное количество ягод за один сбор (от 1 до 3)
					Item berry = ItemManager.CreateByItemID(-586342290, amount);
					player.inventory.GiveItem(berry);
					string msg = amount == 1 ? "Вы нашли ягодки" : "Вы нашли ягодки";
					PrintToChat(player, msg);
				}
			}
			return null;
		}
    }
}


// --- End of file: ForestBerries.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Top.cs ---
// --- Original Local Path: Top.cs ---

using Oxide.Core;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Top", "RustPlugin.ru", "1.1.0")]

    class Top : RustPlugin
    {
        private int MessageNum = 0;
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Создание конфига");
            Config.Clear();
            Config["Цвет Панели"] = "0.0 0.0 0.0 0.8";
            Config["Время Между Сообщениями"] = 300f;
            Config["Цвет Оповещаний"] = "#ffa500";
            SaveConfig();
        }

        [ChatCommand("rank")]
        void TurboRankCommand(BasePlayer player, string command)
        {
            var TopPlayer = (from x in Tops where x.UID == player.UserIDString select x).OrderByDescending(x => x.РакетВыпущено + x.ВзрывчатокИспользовано);
            player.ChatMessage($"<size=15>Статистика игрока <color=#ffa500>{player.displayName}</color></size>");
            foreach (var top in TopPlayer)
            {
                SendReply(player, $"<size=14><color=#ffffff>Убийств игроков: <color=#ffa500>{top.УбийствPVP}</color> | Смертей: <color=#ffa500>{top.Смертей}</color></color></size>");
                SendReply(player, $"<size=14><color=#ffffff>Ракет выпущено: <color=#ffa500>{top.РакетВыпущено}</color> | Взрывчаток использовано: <color=#ffa500>{top.ВзрывчатокИспользовано}</color></color></size>");
                SendReply(player, $"<size=14><color=#ffffff>Ресурсов собрано: <color=#ffa500>{top.РесурсовСобрано}</color> | Животных убито: <color=#ffa500>{top.УбийствЖивотных}</color></color></size>");
                SendReply(player, $"<size=14><color=#ffffff>Пуль выпущено: <color=#ffa500>{top.ПульВыпущено}</color> | Стрел выпущено: <color=#ffa500>{top.СтрелВыпущено}</color></color></size>");
                SendReply(player, $"<size=14><color=#ffffff>Предметов скрафчено: <color=#ffa500>{top.ПредметовСкрафчено}</color> | Вертолетов сбито: <color=#ffa500>{top.ВертолётовУничтожено}</color></color></size>");
                SendReply(player, $"<size=14><color=#ffffff>NPC убито: <color=#ffa500>{top.NPCУбито}</color> | Танков уничтожено: <color=#ffa500>{top.ТанковУничтожено}</color></color></size>");
            }
            return;
        }

        [ChatCommand("top")]
        void TurboTopCommand(BasePlayer player, string command, string[] args)
        {
            if (args.Length == 1)
            {
                int n = 0;
                if (args[0] == "reset")
                {
                    if (!player.IsAdmin)
                    {
                        SendReply(player, $"<size=14><color=#FFA500>Ты кто такой? Давай досвиданье!</color></size>");
                        return;
                    }
                    var TopPlayer = (from x in Tops select x);
                    foreach (var top in TopPlayer)
                    {
                        top.Reset();
                        Saved();
                    }
                    SendReply(player, $"<size=14><color=#FFA500>Статистика игроков обнулена!</color></size>");
                    return;
                }
                if (args[0] == "farm")
                {
                    bool prov = false;
                    player.ChatMessage("<size=14><color=#FF6347>[СТАТИСТИКА]</color> ТОП Фармеров</size>");
                    var TopPlayer = (from x in Tops select x).OrderByDescending(x => x.РесурсовСобрано);
                    foreach (var top in TopPlayer)
                    {
                        n++;
                        if (n <= 5)
                        {
                            player.SendConsoleCommand("chat.add", top.UID, $"<size=14><color=#FFA500>{n}.</color> <color=#FF8C00>{top.Ник}</color> ({top.РесурсовСобрано})</size>");
                            if (top.UID == player.UserIDString)
                            {
                                prov = true;
                            }
                        }
                    }
                    if (!prov)
                    {
                        player.ChatMessage("...");
                        int i = 0;
                        foreach (var top in TopPlayer)
                        {
                            i++;
                            if (top.UID == player.UserIDString)
                            {
                                player.SendConsoleCommand("chat.add", player.UserIDString, $"<size=14><color=#FFA500>{i}.</color> <color=#FF8C00>{top.Ник}</color> ({top.РесурсовСобрано})</size>");
                            }
                        }
                    }
                    return;
                }
                if (args[0] == "pvp")
                {
                    bool prov = false;
                    player.ChatMessage("<size=14><color=#FF6347>[СТАТИСТИКА]</color> ТОП Убийств PVP</size>");
                    var TopPlayer = (from x in Tops select x).OrderByDescending(x => x.УбийствPVP);
                    foreach (var top in TopPlayer)
                    {
                        n++;
                        if (n <= 5)
                        {
                            player.SendConsoleCommand("chat.add", top.UID, $"<size=14><color=#FFA500>{n}.</color> <color=#FF8C00>{top.Ник}</color> ({top.УбийствPVP})</size>");
                            if (top.UID == player.UserIDString)
                            {
                                prov = true;
                            }
                        }
                    }
                    if (!prov)
                    {
                        player.ChatMessage("<size=14>...</size>");
                        int i = 0;
                        foreach (var top in TopPlayer)
                        {
                            i++;
                            if (top.UID == player.UserIDString)
                            {
                                player.SendConsoleCommand("chat.add", player.UserIDString, $"<size=14><color=#FFA500>{i}.</color> <color=#FF8C00>{top.Ник}</color> ({top.УбийствPVP})</size>");
                            }
                        }
                    }
                    return;
                }
                if (args[0] == "raid")
                {
                    bool prov = false;
                    player.ChatMessage("<size=14><color=#FF6347>[СТАТИСТИКА]</color> ТОП Рейдеров</size>");
                    var TopPlayer = (from x in Tops select x).OrderByDescending(x => x.РакетВыпущено + x.ВзрывчатокИспользовано);
                    foreach (var top in TopPlayer)
                    {
                        n++;
                        if (n <= 5)
                        {
                            player.SendConsoleCommand("chat.add", top.UID, $"<size=14><color=#FFA500>{n}.</color> <color=#FF8C00>{top.Ник}</color> ({top.РакетВыпущено + top.ВзрывчатокИспользовано})</size>");
                            if (top.UID == player.UserIDString)
                            {
                                prov = true;
                            }
                        }
                    }
                    if (!prov)
                    {
                        player.ChatMessage("<size=14>...</size>");
                        int i = 0;
                        foreach (var top in TopPlayer)
                        {
                            i++;
                            if (top.UID == player.UserIDString)
                            {
                                player.SendConsoleCommand("chat.add", player.UserIDString, $"<size=14><color=#FFA500>{i}.</color> <color=#FF8C00>{top.Ник}</color> ({top.РакетВыпущено + top.ВзрывчатокИспользовано})</size>");
                            }
                        }
                    }
                    return;
                }
            }
            else
            {
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "DestroyUI", "Панелька");
                CuiElementContainer elements = CreatePanel("0");
                CuiHelper.AddUi(player, elements);
            }
        }

        [ConsoleCommand("top.show")]
        private void TopShowOpenCmd2(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "DestroyUI", "Панелька");
            string number = arg.Args[0];
            CuiElementContainer elements = CreatePanel(number);
            CuiHelper.AddUi(player, elements);
            return;
        }

        CuiElementContainer CreatePanel(string number)
        {
            string cvet = Convert.ToString(Config["Цвет Панели"]);
            var elements = new CuiElementContainer();
            var panel = elements.Add(new CuiPanel
            {
                Image = { Color = "0 0 0 0.75" },
                RectTransform = { AnchorMin = "0.2 0.13", AnchorMax = "0.8 0.95" },
                CursorEnabled = true
            }, "Hud", "Панелька");
            elements.Add(new CuiPanel
            {
                Image = { Color = $"{cvet}" },
                RectTransform = { AnchorMin = "0 0.81", AnchorMax = "1 1" },
            }, panel);

            elements.Add(new CuiLabel
            {
                Text = { Text = "<color=#ffa500>TOP 10 ИГРОКОВ</color>", FontSize = 30, Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = "0 0.89", AnchorMax = "1 1" },
            }, panel);
            elements.Add(new CuiButton
            {
                Button = { Command = "top.exit", Color = $"{cvet}" },
                RectTransform = { AnchorMin = "0.9 0.90", AnchorMax = "1 1" },
                Text = { Text = "<color=#ffa500>X</color>", FontSize = 18, Align = TextAnchor.MiddleCenter }
            }, panel);

            elements.Add(new CuiPanel
            {
                Image = { Color = $"{cvet}" },
                RectTransform = { AnchorMin = "0 0.81", AnchorMax = "0.298 0.8899999" },
            }, panel);
            elements.Add(new CuiLabel
            {
                Text = { Text = "<color=#ffa500>Игрок</color>", FontSize = 20, Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = "0 0.81", AnchorMax = "0.29 0.8899999" },
            }, panel);
            elements.Add(new CuiButton
            {
                Text = { Text = "<color=#ffa500>Убийства</color>", FontSize = 15, Align = TextAnchor.MiddleCenter },
                Button = { Command = "top.show 1", Color = $"{cvet}" },
                RectTransform = { AnchorMin = "0.30 0.81", AnchorMax = "0.454 0.8899999" }
            }, panel);
            elements.Add(new CuiButton
            {
                Text = { Text = "<color=#ffa500>Смертей</color>", FontSize = 15, Align = TextAnchor.MiddleCenter },
                Button = { Command = "top.show 2", Color = $"{cvet}" },
                RectTransform = { AnchorMin = "0.455 0.81", AnchorMax = "0.578 0.8899999" }
            }, panel);
            elements.Add(new CuiButton
            {
                Text = { Text = "<color=#ffa500>Животные</color>", FontSize = 15, Align = TextAnchor.MiddleCenter },
                Button = { Command = "top.show 3", Color = $"{cvet}" },
                RectTransform = { AnchorMin = "0.58 0.81", AnchorMax = "0.678 0.8899999" }
            }, panel);
            elements.Add(new CuiButton
            {
                Text = { Text = "<color=#ffa500>Взрывов</color>", FontSize = 15, Align = TextAnchor.MiddleCenter },
                Button = { Command = "top.show 4", Color = $"{cvet}" },
                RectTransform = { AnchorMin = "0.68 0.81", AnchorMax = "0.859 0.8899999" }
            }, panel);
            elements.Add(new CuiButton
            {
                Text = { Text = "<color=#ffa500>Ресурсы</color>", FontSize = 15, Align = TextAnchor.MiddleCenter },
                Button = { Command = "top.show 5", Color = $"{cvet}" },
                RectTransform = { AnchorMin = "0.86 0.81", AnchorMax = "1 0.8899999" }
            }, panel);

            string polosa = "0 0 0 0.9";
            int n = 0;
            var TopPlayer = (from x in Tops select x).OrderByDescending(x => x.УбийствPVP).Take(10);
            if (number == "2")
            {
                TopPlayer = (from x in Tops select x).OrderByDescending(x => x.Смертей).Take(10);
            }
            else if (number == "3")
            {
                TopPlayer = (from x in Tops select x).OrderByDescending(x => x.УбийствЖивотных).Take(10);
            }
            else if (number == "4")
            {
                TopPlayer = (from x in Tops select x).OrderByDescending(x => x.РакетВыпущено + x.ВзрывчатокИспользовано).Take(10);
            }
            else if (number == "5")
            {
                TopPlayer = (from x in Tops select x).OrderByDescending(x => x.РесурсовСобрано).Take(10);
            }
            else
            {
                TopPlayer = (from x in Tops select x).OrderByDescending(x => x.УбийствPVP).Take(10);
            }
            foreach (var top in TopPlayer)
            {
                if (n % 2 == 0)
                {
                    polosa = "0 0 0 0.7";
                }
                else
                {
                    polosa = "1 1 1 0.05";
                }
                elements.Add(new CuiPanel
                {
                    Image = { Color = polosa },
                    RectTransform = { AnchorMin = $"0 {0.72 - (n * 0.08)}", AnchorMax = $"1 {0.8 - (n * 0.08)}" },
                }, panel);
                elements.Add(new CuiLabel
                {
                    Text = { Text = Convert.ToString(top.Ник), FontSize = 15, Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0 {0.72 - (n * 0.08)}", AnchorMax = $"0.29 {0.8 - (n * 0.08)}" },
                }, panel);
                elements.Add(new CuiLabel
                {
                    Text = { Text = Convert.ToString(top.УбийствPVP), FontSize = 15, Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.3 {0.72 - (n * 0.08)}", AnchorMax = $"0.454 {0.8 - (n * 0.08)}" },
                }, panel);
                elements.Add(new CuiLabel
                {
                    Text = { Text = Convert.ToString(top.Смертей), FontSize = 15, Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.455 {0.72 - (n * 0.08)}", AnchorMax = $"0.578 {0.8 - (n * 0.08)}" },
                }, panel);
                elements.Add(new CuiLabel
                {
                    Text = { Text = Convert.ToString(top.УбийствЖивотных), FontSize = 15, Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.58 {0.72 - (n * 0.08)}", AnchorMax = $"0.678 {0.8 - (n * 0.08)}" },
                }, panel);
                elements.Add(new CuiLabel
                {
                    Text = { Text = $"{ Convert.ToString(top.ВзрывчатокИспользовано + top.РакетВыпущено)}", FontSize = 15, Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.68 {0.72 - (n * 0.08)}", AnchorMax = $"0.85 {0.8 - (n * 0.08)}" },
                }, panel);
                elements.Add(new CuiLabel
                {
                    Text = { Text = Convert.ToString(top.РесурсовСобрано), FontSize = 15, Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.86 {0.72 - (n * 0.08)}", AnchorMax = $"0.99 {0.8 - (n * 0.08)}" },
                }, panel);
                n++;
            }
            return elements;
        }

        [ConsoleCommand("top.exit")]
        private void MagazineOpenCmd2(ConsoleSystem.Arg arg)
        {
            if (arg.Player() == null)
                return;
            BasePlayer player = arg.Player();
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "DestroyUI", "Панелька");
        }

        private Dictionary<uint, string> LastHeliHit = new Dictionary<uint, string>();

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity is BaseHelicopter && info.Initiator is BasePlayer)
                LastHeliHit[entity.net.ID] = info.InitiatorPlayer.UserIDString;
        }

        void OnEntityDeath(BaseCombatEntity victim, HitInfo info)
        {
            if (victim == null || info == null) return;
            BasePlayer victimBP = victim.ToPlayer();
            BasePlayer initiator = info.InitiatorPlayer;
            if (victimBP != null && !IsNPC(victimBP))
            {
                string death = victimBP.UserIDString;
                TopData con = (from x in Tops where x.UID == death select x).FirstOrDefault();
                con.Смертей += 1;
            }
            if (initiator == null)
            {
                if (victim is BaseHelicopter)
                {
                    if (LastHeliHit.ContainsKey(victim.net.ID))
                    {
                        TopData data = Tops.Where(p => p.UID == LastHeliHit[victim.net.ID]).FirstOrDefault();
                        data.ВертолётовУничтожено += 1;
                        LastHeliHit.Remove(victim.net.ID);
                    }
                }
                return;
            }
            if (initiator != null && !IsNPC(initiator))
            {
                string killer = initiator.UserIDString;
                TopData con2 = (from x in Tops where x.UID == killer select x).FirstOrDefault();
                if (IsNPC(victimBP))
                {
                    con2.NPCУбито++;
                    return;
                }
                if (victim is BaseAnimalNPC)
                {
                    con2.УбийствЖивотных += 1;
                    return;
                }
                if (victim is BradleyAPC)
                {
                    con2.ТанковУничтожено++;
                    return;
                }
                if (victimBP != null && victimBP != initiator)
                {
                    con2.УбийствPVP += 1;
                    return;
                }
            }
            return;
        }

        void OnExplosiveThrown(BasePlayer player, BaseEntity entity)
        {
            TopData con = (from x in Tops where x.UID == Convert.ToString(player.userID) select x).FirstOrDefault();
            con.ВзрывчатокИспользовано += 1;
        }

        void OnRocketLaunched(BasePlayer player, BaseEntity entity)
        {
            TopData con = (from x in Tops where x.UID == Convert.ToString(player.userID) select x).FirstOrDefault();
            con.РакетВыпущено += 1;
        }

        void OnWeaponFired(BaseProjectile projectile, BasePlayer player, ItemModProjectile mod, ProtoBuf.ProjectileShoot projectiles)
        {
            TopData con = (from x in Tops where x.UID == Convert.ToString(player.userID) select x).FirstOrDefault();
            if (projectile.primaryMagazine.definition.ammoTypes == Rust.AmmoTypes.BOW_ARROW)
            {
                con.СтрелВыпущено += 1;
            }
            else
            {
                con.ПульВыпущено += 1;
            }
        }

        void OnItemCraftFinished(ItemCraftTask task, Item item)
        {
            if (task.owner is BasePlayer)
            {
                TopData con = (from x in Tops where x.UID == Convert.ToString(task.owner.userID) select x).FirstOrDefault();
                con.ПредметовСкрафчено += 1;
            }
        }

        void OnServerSave()
        {
            Saved();
        }

        void Unload()
        {
            foreach(var player in BasePlayer.activePlayerList)
            {
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "DestroyUI", "Панелька");
            }
            Saved();
        }

        void OnCollectiblePickup(Item item, BasePlayer player)
        {
            DoGather(player, item);
        }

        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            if (entity == null || !(entity is BasePlayer) || item == null || dispenser == null) return;
            if (entity.ToPlayer() is BasePlayer)
                DoGather(entity.ToPlayer(), item);
        }

        void DoGather(BasePlayer player, Item item)
        {
            if (player == null) return;
            TopData con = (from x in Tops where x.UID == Convert.ToString(player.userID) select x).FirstOrDefault();
            con.РесурсовСобрано += item.amount;
            return;
        }

        void CreateInfo(BasePlayer player)
        {
            if (player == null) return;
            Tops.Add(new TopData(player.displayName, player.UserIDString));
        }

        void OnPlayerInit(BasePlayer player)
        {
            var check = (from x in Tops where x.UID == player.UserIDString select x).Count();
            if (check == 0) CreateInfo(player);
            TopData con = (from x in Tops where x.UID == Convert.ToString(player.userID) select x).FirstOrDefault();
            con.Ник = (string)player.displayName;
        }

        void Loaded()
        {
            Tops = Interface.Oxide.DataFileSystem.ReadObject<List<TopData>>("TopData");
            foreach (var player in BasePlayer.activePlayerList)
            {
                var check = (from x in Tops where x.UID == player.UserIDString select x).Count();
                if (check == 0) CreateInfo(player);
            }
            timer.Repeat(Convert.ToInt32(Config["Время Между Сообщениями"]), 0, () =>
            {
                MessageNum++;
                TopData data = null;
                switch (MessageNum)
                {
                    case 1:
                        data = Tops.OrderByDescending(p => p.УбийствPVP).FirstOrDefault();
                        if (data != null)
                            Server.Broadcast($"<size=16><color={Convert.ToString(Config["Цвет Оповещаний"])}>TOP Киллер</color> - {data.Ник} ({data.УбийствPVP})</size>");
                        break;
                    case 2:
                        data = Tops.OrderByDescending(p => p.ВзрывчатокИспользовано + p.РакетВыпущено).FirstOrDefault();
                        if (data != null)
                            Server.Broadcast($"<size=16><color={Convert.ToString(Config["Цвет Оповещаний"])}>TOP Рейдер</color> - {data.Ник} ({data.ВзрывчатокИспользовано + data.РакетВыпущено})</size>");
                        break;
                    case 3:
                        data = Tops.OrderByDescending(p => p.УбийствЖивотных).FirstOrDefault();
                        if (data != null)
                            Server.Broadcast($"<size=16><color={Convert.ToString(Config["Цвет Оповещаний"])}>TOP Убийца животных</color> - {data.Ник} ({data.УбийствЖивотных})</size>");
                        break;
                    case 4:
                        data = Tops.OrderByDescending(p => p.ПульВыпущено).FirstOrDefault();
                        if (data != null)
                            Server.Broadcast($"<size=16><color={Convert.ToString(Config["Цвет Оповещаний"])}>TOP Выпустил пуль</color> - {data.Ник} ({data.ПульВыпущено})</size>");
                        break;
                    case 5:
                        data = Tops.OrderByDescending(p => p.СтрелВыпущено).FirstOrDefault();
                        if (data != null)
                            Server.Broadcast($"<size=16><color={Convert.ToString(Config["Цвет Оповещаний"])}>TOP Выпустил стрел</color> - {data.Ник} ({data.СтрелВыпущено})</size>");
                        break;
                    case 6:
                        data = Tops.OrderByDescending(p => p.Смертей).FirstOrDefault();
                        if (data != null)
                            Server.Broadcast($"<size=16><color={Convert.ToString(Config["Цвет Оповещаний"])}>TOP Смертей</color> - {data.Ник} ({data.Смертей})</size>");
                        break;
                    case 7:
                        data = Tops.OrderByDescending(p => p.ПредметовСкрафчено).FirstOrDefault();
                        if (data != null)
                            Server.Broadcast($"<size=16><color={Convert.ToString(Config["Цвет Оповещаний"])}>TOP Крафтер</color> - {data.Ник} ({data.ПредметовСкрафчено})</size>");
                        break;
                    case 8:
                        data = Tops.OrderByDescending(p => p.РесурсовСобрано).FirstOrDefault();
                        if (data != null)
                            Server.Broadcast($"<size=16><color={Convert.ToString(Config["Цвет Оповещаний"])}>TOP Добытчик</color> - {data.Ник} ({data.РесурсовСобрано})</size>");
                        break;
                    case 9:
                        data = Tops.OrderByDescending(p => p.ВертолётовУничтожено).FirstOrDefault();
                        if (data != null)
                            Server.Broadcast($"<size=16><color={Convert.ToString(Config["Цвет Оповещаний"])}>TOP Убийца вертолётов</color> - {data.Ник} ({data.ВертолётовУничтожено})</size>");
                        break;
                    case 10:
                        data = Tops.OrderByDescending(p => p.NPCУбито).FirstOrDefault();
                        if (data != null)
                            Server.Broadcast($"<size=16><color={Convert.ToString(Config["Цвет Оповещаний"])}>TOP Убийца NPC</color> - {data.Ник} ({data.NPCУбито})</size>");
                        break;
                    case 11:
                        data = Tops.OrderByDescending(p => p.ТанковУничтожено).FirstOrDefault();
                        if (data != null)
                            Server.Broadcast($"<size=16><color={Convert.ToString(Config["Цвет Оповещаний"])}>TOP Убийца танков</color> - {data.Ник} ({data.ТанковУничтожено})</size>");
                        MessageNum = 0;
                        break;
                }
            });
        }

        void Saved()
        {
            Interface.Oxide.DataFileSystem.WriteObject("TopData", Tops);
        }

        private bool IsNPC(BasePlayer player)
        {
            if (player == null) return false;
            if (player is NPCPlayer)
                return true;
            if (!(player.userID >= 76560000000000000L || player.userID <= 0L))
                return true;
            return false;
        }

        public List<TopData> Tops = new List<TopData>();

        public class TopData
        {
            public TopData(string Ник, string UID)
            {
                this.Ник = Ник;
                this.UID = UID;
                this.РакетВыпущено = 0;
                this.УбийствPVP = 0;
                this.ВзрывчатокИспользовано = 0;
                this.УбийствЖивотных = 0;
                this.ПульВыпущено = 0;
                this.СтрелВыпущено = 0;
                this.Смертей = 0;
                this.ПредметовСкрафчено = 0;
                this.РесурсовСобрано = 0;
                this.ВертолётовУничтожено = 0;
                this.NPCУбито = 0;
                this.ТанковУничтожено = 0;
            }
            public void Reset()
            {
                this.РакетВыпущено = 0;
                this.УбийствPVP = 0;
                this.ВзрывчатокИспользовано = 0;
                this.УбийствЖивотных = 0;
                this.ПульВыпущено = 0;
                this.СтрелВыпущено = 0;
                this.Смертей = 0;
                this.ПредметовСкрафчено = 0;
                this.РесурсовСобрано = 0;
                this.ВертолётовУничтожено = 0;
                this.NPCУбито = 0;
                this.ТанковУничтожено = 0;
            }

            public string Ник { get; set; }
            public string UID { get; set; }
            public int РакетВыпущено { get; set; }
            public int УбийствPVP { get; set; }
            public int ВзрывчатокИспользовано { get; set; }
            public int УбийствЖивотных { get; set; }
            public int ПульВыпущено { get; set; }
            public int СтрелВыпущено { get; set; }
            public int Смертей { get; set; }
            public int ПредметовСкрафчено { get; set; }
            public int РесурсовСобрано { get; set; }
            public int ВертолётовУничтожено { get; set; }
            public int ТанковУничтожено { get; set; }
            public int NPCУбито { get; set; }
        }
    }
}


// --- End of file: Top.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NewFurnace.cs ---
// --- Original Local Path: NewFurnace.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using ConVar;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("NewFurnace", "CASHR", "1.0.0")]
    public class NewFurnace : RustPlugin
    {
        [JsonProperty("Список ящиков в которых его спавнить")]
        public List<string> ListContainers = new List<string>()
                {
                    { "crate_basic" },
                    { "crate_normal" },
                    { "crate_normal_2" }
                };
        #region Конфиг
        private class Configuration
        {
            [JsonProperty("Шанс нахождения печки в ящике")]
            public int Chance = 10;
            [JsonProperty("Скорость плавки")]
            public double Speed = 3f;
            [JsonProperty("Название печи")]
            public string DisplayName = "Улучшенная печь";
            [JsonProperty("Описание печи")]
            public string Desk = "Плавит ресурсы в 2 раза быстрее!";
            [JsonProperty("СкинИД предмета")]
            public ulong SkinID = 10;  
            public static Configuration GetNewConf()
            {
                return new Configuration();
            }

        }
        protected override void LoadDefaultConfig() => _config = Configuration.GetNewConf();
        protected override void SaveConfig() => Config.WriteObject(_config);
        private Configuration _config = new Configuration();
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }

        #endregion

        #region OxideHooks
        object OnOvenToggle(BaseOven oven, BasePlayer player)
        {

            if (oven.HasFlag(BaseEntity.Flags.On)) return null;
            if (oven.skinID == _config.SkinID)
            {              
                double ovenMultiplier = _config.Speed;
                if (ovenMultiplier > 10f) ovenMultiplier = 10f;
                if (ovenMultiplier < 0.1f) ovenMultiplier = 0.1f;
                StartCooking(oven, oven.GetComponent<BaseEntity>(), ovenMultiplier);
                return false;
            }
            else
            {
                double ovenMultiplier = 1f;
                if (ovenMultiplier > 10f) ovenMultiplier = 10f;
                if (ovenMultiplier < 0.1f) ovenMultiplier = 0.1f;
                StartCooking(oven, oven.GetComponent<BaseEntity>(), ovenMultiplier);
                return false;
            }
        }
        float CookingTemperature(BaseOven.TemperatureType temperature)
        {
            switch (temperature)
            {
                case BaseOven.TemperatureType.Warming:
                    return 50f;
                case BaseOven.TemperatureType.Cooking:
                    return 200f;
                case BaseOven.TemperatureType.Smelting:
                    return 1000f;
                case BaseOven.TemperatureType.Fractioning:
                    return 1500f;
                default:
                    return 15f;
            }
        }
       
        private void OnServerInitialized()
        {
            LoadConfig();
        }
        void OnLootSpawn(LootContainer container)
        {
            if (container.ShortPrefabName == "stocking_large_deployed" ||
                container.ShortPrefabName == "stocking_small_deployed") return;
            if (ListContainers.Contains(container.ShortPrefabName))
            {
                if (UnityEngine.Random.Range(1, 100) <= _config.Chance)
                {
                    if (container.inventory.itemList.Count == container.inventory.capacity)
                    {
                        container.inventory.capacity++;
                    }
                    Item i = ItemManager.CreateByName("furnace", 1, _config.SkinID);
                    i.name = $"<color=#️249c00>{_config.DisplayName}</color>" + $"<size=10>{_config.Desk}</size>";
                    i.MoveToContainer(container.inventory);
                }
            }
        }

        #endregion

        #region Function

        public void ReplyWithHelper(BasePlayer player, string message, string[] args = null)
        {
            if (args != null)
                message = string.Format(message, args);
            player.SendConsoleCommand("chat.add 0", new object[2]
            {
                76561198090669418,
                string.Format("<size=16><color={2}>{0}</color>:</size>\n{1}", "Виртуальный помощник:", message, "#00bfff")
            });
        }
        void StartCooking(BaseOven oven, BaseEntity entity, double ovenMultiplier)
        {
            if (FindBurnable(oven) == null)
                return;
            oven.inventory.temperature = CookingTemperature(oven.temperature);
            oven.UpdateAttachmentTemperature();
            InvokeHandler.CancelInvoke(entity.GetComponent<MonoBehaviour>(), new Action(oven.Cook));
            InvokeHandler.InvokeRepeating(entity.GetComponent<MonoBehaviour>(), new Action(oven.Cook), (float)(0.5f / ovenMultiplier), (float)(0.5f / ovenMultiplier));
            entity.SetFlag(BaseEntity.Flags.On, true, false);
        }
        Item FindBurnable(BaseOven oven)
        {
            if (oven.inventory == null)
                return null;
            foreach (Item current in oven.inventory.itemList)
            {
                ItemModBurnable component = current.info.GetComponent<ItemModBurnable>();
                if (component && (oven.fuelType == null || current.info == oven.fuelType))
                    return current;
            }
            return null;
        }
        private static string HexToRGB(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);
            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }
        public Item FindItem(BasePlayer player, int itemID, ulong skinID, int amount)
        {
            Item item = null;

            if (skinID == 0U)
            {
                if (player.inventory.FindItemID(itemID) != null && player.inventory.FindItemID(itemID).amount >= amount)
                    return player.inventory.FindItemID(itemID);
            }
            else
            {

                List<Item> items = new List<Item>();

                items.AddRange(player.inventory.FindItemIDs(itemID));

                foreach (var findItem in items)
                {
                    if (findItem.skin == skinID && findItem.amount >= amount)
                    {
                        return findItem;
                    }
                }
            }

            return item;
        }
        public bool HaveItem(BasePlayer player, int itemID, ulong skinID, int amount)
        {
            if (skinID == 0U)
            {
                if (player.inventory.FindItemID(itemID) != null &&
                    player.inventory.FindItemID(itemID).amount >= amount) return true;
                return false;
            }
            else
            {

                List<Item> items = new List<Item>();

                items.AddRange(player.inventory.FindItemIDs(itemID));

                foreach (var item in items)
                {
                    if (item.skin == skinID && item.amount >= amount)
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        #endregion

    }
}

// --- End of file: NewFurnace.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/MagicVariables.cs ---
// --- Original Local Path: MagicVariables.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Rust;
using Oxide.Core.Plugins;
namespace Oxide.Plugins
{
    [Info("MagicVariables", "Norn", 0.1, ResourceId = 1419)]
    [Description("Simple static variable system.")]
    public class MagicVariables : RustPlugin
    {
        public Int32 UnixTimeStampUTC()
        {
            Int32 unixTimeStamp;
            DateTime currentTime = DateTime.Now;
            DateTime zuluTime = currentTime.ToUniversalTime();
            DateTime unixEpoch = new DateTime(1970, 1, 1);
            unixTimeStamp = (Int32)(zuluTime.Subtract(unixEpoch)).TotalSeconds;
            return unixTimeStamp;
        }
        static readonly DateTime UnixEpoch = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);
        static readonly double MaxUnixSeconds = (DateTime.MaxValue - UnixEpoch).TotalSeconds;

        public static DateTime UnixTimeStampToDateTime(double unixTimeStamp)
        {
            return unixTimeStamp > MaxUnixSeconds
               ? UnixEpoch.AddMilliseconds(unixTimeStamp)
               : UnixEpoch.AddSeconds(unixTimeStamp);
        }
        public class StaticVariables
        {
            public int iResourceID;

            public Dictionary<string, object> Variables = new Dictionary<string, object>();
            public Hash<ulong, Dictionary<string, object>> UserVariables = new Hash<ulong, Dictionary<string, object>>();
            public Dictionary<ulong, PlayersInit> Users = new Dictionary<ulong, PlayersInit>();

            public StaticVariables()
            {
            }
        }
        public class PlayersInit
        {
            public ulong uUserID;
            public string tDisplayName;
            public PlayersInit()
            {
            }
        }
        public class PluginInfo
        {
            public Dictionary<Plugin, StaticVariables> Plugins = new Dictionary<Plugin, StaticVariables>();
            public PluginInfo()
            {
            }
        }
        PluginInfo Data = new PluginInfo();
        private bool PluginExists(Plugin plugin)
        {
            if (Data.Plugins.ContainsKey(plugin))
            {
                return true;
            }
            return false;
        }
        private bool SetStaticVariable(Plugin plugin, string variable, string value, bool debug = false)
        {
            if (PluginExists(plugin))
            {
                if (!Data.Plugins[plugin].Variables.ContainsKey(variable))
                {
                    Data.Plugins[plugin].Variables.Add(variable, value);
                    if (debug) Puts(plugin.Title + " : " + variable + " = " + value + " : Initiation.");
                    return true;
                }
                else
                {
                    Data.Plugins[plugin].Variables[variable] = value;
                    if (debug) Puts(plugin.Title + " : " + variable + " = " + value + " : Updating.");
                    return true;
                }
            }
            return false;
        }
        private string GetStaticVariable(Plugin plugin, string variable, bool debug = false)
        {
            if (PluginExists(plugin))
            {
                if (Data.Plugins[plugin].Variables.ContainsKey(variable))
                {
                    if (debug) Puts(plugin.Title + " : " + Data.Plugins[plugin].Variables[variable].ToString() + " : Data Returned.");
                    return Data.Plugins[plugin].Variables[variable].ToString();
                }
            }
            return "0";
        }
        private bool RemoveStaticVariable(Plugin plugin, string variable, bool debug = false)
        {
            if (PluginExists(plugin))
            {
                if (Data.Plugins[plugin].Variables.ContainsKey(variable))
                {
                    Data.Plugins[plugin].Variables.Remove(variable);
                    return true;
                }
            }
            return false;
        }
        private bool DestroyPlugin(Plugin plugin, bool debug = false)
        {
            try
            {
                if (PluginExists(plugin))
                {
                    Data.Plugins.Remove(plugin);
                    if (debug) Puts("Removing " + plugin.Title + " from the plugin list.");
                    return true;
                }
            }
            catch
            {
                if (debug) Puts("DEBUG: Failed To Call Hook DestroyPlugin(" + plugin.Title.ToString() + ");");
            }
            return false;
        }
        private bool InitPlugin(Plugin plugin, bool debug = false)
        {
            try
            {
                if (!PluginExists(plugin))
                {
                    StaticVariables d = new StaticVariables();
                    d.iResourceID = plugin.ResourceId;
                    Data.Plugins.Add(plugin, d);
                    SetStaticVariable(plugin, "INIT_TIMESTAMP", UnixTimeStampUTC().ToString());
                    if (debug) Puts("[" + plugin.Title + "] added " + plugin.Title + " [Resource ID: " + Data.Plugins[plugin].iResourceID.ToString() + "].");
                    return true;
                }
            }
            catch
            {
                if (debug) Puts("DEBUG: Failed To Call Hook InitPlugin(" + plugin.Title.ToString() + ");");
            }
            return false;
        }
        void OnServerInitialized()
        {
            int config_protocol = Convert.ToInt32(Config["Protocol"]);
            if (config_protocol != Protocol.network)
            {
                Config["Protocol"] = Protocol.network;
                SaveConfig();
            }
        }
        private bool RemoveStaticPlayerVariable(Plugin plugin, BasePlayer player, string variable, bool debug = false)
        {
            if (!PlayerExists(plugin, player)) { return false; }
            if (PlayerHasVariables(plugin, player) == 0) { return false; }
            if (Data.Plugins[plugin].UserVariables[player.userID].ContainsKey(variable))
            {
                if (debug) Puts("[" + plugin.Title + "] Removing static variable " + variable + ":" + Data.Plugins[plugin].UserVariables[player.userID][variable] + ".");
                Data.Plugins[plugin].UserVariables[player.userID].Remove(variable);
                return true;
            }
            return false;
        }
        private string GetStaticPlayerVariable(Plugin plugin, BasePlayer player, string variable, bool debug = false)
        {
            string default_return = "0";
            if (!PlayerExists(plugin, player)) { return default_return; }
            if (PlayerHasVariables(plugin, player) == 0) { return default_return; }
            if (Data.Plugins[plugin].UserVariables[player.userID].ContainsKey(variable))
            {
                default_return = Data.Plugins[plugin].UserVariables[player.userID][variable].ToString();
            }
            return default_return;
        }
        private void SetStaticPlayerVariable(Plugin plugin, BasePlayer player, string variable, string value, bool debug = false)
        {
            ulong steamid = player.userID;
            if (!PlayerExists(plugin, player)) { InitPlayer(plugin, player); return; }
            if (Data.Plugins[plugin].UserVariables.ContainsKey(player.userID))
            {
                if (Data.Plugins[plugin].UserVariables[player.userID].ContainsKey(variable))
                {
                    Data.Plugins[plugin].UserVariables[player.userID][variable] = value;
                }
                else
                {
                    Data.Plugins[plugin].UserVariables[player.userID].Add(variable, value);
                }
            }
            else
            {
                Dictionary<string, object> zdata = new Dictionary<string, object>();
                zdata.Add(variable, value);
                Data.Plugins[plugin].UserVariables.Add(player.userID, zdata);
            }
            if (debug) Puts(player.displayName + " : " + player.userID.ToString() + " : " + variable + " : " + Data.Plugins[plugin].UserVariables[player.userID][variable].ToString());
        }
        private int PlayerHasVariables(Plugin plugin, BasePlayer player)
        {
            if (PluginExists(plugin) && PlayerExists(plugin, player))
            {
                if (!Data.Plugins[plugin].UserVariables.ContainsKey(player.userID)) { return 0; }
                return Data.Plugins[plugin].UserVariables[player.userID].Count();
            }
            return 0;
        }
        private bool InitPlayer(Plugin plugin, BasePlayer player, bool debug = false)
        {
            if (!PlayerExists(plugin, player) && PluginExists(plugin))
            {
                PlayersInit data = new PlayersInit();
                data.tDisplayName = player.displayName;
                data.uUserID = player.userID;
                Data.Plugins[plugin].Users.Add(player.userID, data);
                if (debug) Puts("[" + plugin.Title + "] added " + Data.Plugins[plugin].Users[player.userID].tDisplayName + " (" + Data.Plugins[plugin].Users[player.userID].uUserID.ToString() + ") to the user list.");
                return true;
            }
            return false;
        }
        private bool RemovePlayer(Plugin plugin, BasePlayer player, bool debug = false)
        {
            if (PluginExists(plugin))
            {
                if (Data.Plugins[plugin].Users.ContainsKey(player.userID))
                {
                    if (debug) Puts("[" + plugin.Title + "] Removing " + Data.Plugins[plugin].Users[player.userID].tDisplayName + " [ " + player.userID + " ] ");
                    Data.Plugins[plugin].Users.Remove(player.userID);
                    return true;
                }
            }
            return false;
        }
        private bool PlayerExists(Plugin plugin, BasePlayer player)
        {
            if (PluginExists(plugin))
            {
                if (Data.Plugins[plugin].Users.ContainsKey(player.userID))
                {
                    return true;
                }
            }
            return false;
        }
        protected override void LoadDefaultConfig()
        {
            Puts("No configuration file found, generating...");
            Config.Clear();
            Config["Protocol"] = Protocol.network;
            SaveConfig();
        }
    }
}

// --- End of file: MagicVariables.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/OnlinePanel.cs ---
// --- Original Local Path: OnlinePanel.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;
namespace Oxide.Plugins
{
    [Info("OnlinePanel", "OxideBro", "0.1.1")]
    public class OnlinePanel : RustPlugin
    {
        public class PlayerTime
        {
            public TimeSpan time = new TimeSpan();
            public Coroutine coroutine;
        }

        public Dictionary<BasePlayer, PlayerTime> PlayersTime = new Dictionary<BasePlayer, PlayerTime>();

        private PluginConfig config;

        private Coroutine UpdateActionValues;

        public bool CargoPlane;
        public bool BradleyAPC;
        public bool BaseHelicopter;
        public bool CargoShip;
        public bool CH47Helicopter;
        public bool Init;

        private IEnumerator UpdateValues()
        {
            while (Init)
            {
                CargoPlane = false;
                BradleyAPC = false;
                BaseHelicopter = false;
                CargoShip = false;
                CH47Helicopter = false;
                foreach (var entity in BaseNetworkable.serverEntities.Where(p => p is CargoPlane || p is BradleyAPC
                || p is BaseHelicopter || p is BaseHelicopter || p is CargoShip || p is CH47Helicopter))
                {
                    if (entity is CargoPlane)
                        CargoPlane = true;
                    if (entity is BradleyAPC)
                        BradleyAPC = true;
                    if (entity is BaseHelicopter)
                        BaseHelicopter = true;
                    if (entity is CargoShip)
                        CargoShip = true;
                    if (entity is CH47Helicopter)
                        CH47Helicopter = true;
                }
                yield return new WaitForSeconds(10);
            }
            yield return 0;
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Благодарим за скачивание плагина на сайте RustPlugin.ru. <3 OxideBro!");
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < new VersionNumber(1, 1, 0))
            {
                PrintWarning("Config update detected! Updating config values...");
                PrintWarning("Config update completed!");
            }
            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                timer.In(1f, () => OnPlayerConnected(player));
                return;
            }
            if (!PlayersTime.ContainsKey(player)) PlayersTime.Add(player, new PlayerTime());
            if (!string.IsNullOrEmpty(config.IpGeoAPIKey))
            {
                var url = $"https://api.ipgeolocation.io/timezone?apiKey={config.IpGeoAPIKey}d&ip={player.Connection.ipaddress}";
                webrequest.Enqueue(url, string.Empty, (code, response) =>
                {
                    try
                    {
                        var result = JsonConvert.DeserializeObject<Parser>(response);
                        if (result != null)
                        {
                            var newtime = DateTime.Parse(result.date_time);
                            if (newtime != null)
                                PlayersTime[player].time = DateTime.UtcNow.ToLocalTime() - newtime;
                        }
                    }
                    catch
                    {
                    }

                }, this);
            }

            PlayersTime[player].coroutine = ServerMgr.Instance.StartCoroutine(StartUpdate(player));
        }

        void Unload()
        {
            Init = false;
            if (UpdateActionValues != null)
                ServerMgr.Instance.StopCoroutine(UpdateValues());
            foreach (var player in PlayersTime)
            {
                ServerMgr.Instance.StopCoroutine(player.Value.coroutine);
                CuiHelper.DestroyUi(player.Key, "OnlinePanel_Main");
            }
        }

        private IEnumerator StartUpdate(BasePlayer player)
        {
            while (player.IsConnected)
            {
                CreateMenu(player);
                yield return new WaitForSeconds(config.UpdateTime);
            }

            PlayersTime.Remove(player);
            yield return 0;
        }

        class PluginConfig
        {
            [JsonProperty("Версия конфигурации")]
            public VersionNumber PluginVersion = new VersionNumber();

            [JsonProperty("Размер текста")]
            public int TextSize = 12;

            [JsonProperty("Шаблон верх ({0} Игровое время | {1} ВРЕМЯ ИГРОКА | {2} ОНЛАЙН | {3} ПОДКЛЮЧЕНИЯ | {4} СЛИПЕРЫ)")]
            public string TextHeader = "ИГРОВОЕ ВРЕМЯ <color=#ffffff>{0}</color> | ВРЕМЯ <color=#ffffff>{1}</color> | ОНЛАЙН <color=#ffffff>{2}</color>| СЛИПЕРЫ <color=#ffffff>{4}</color>";

            [JsonProperty("Шаблон низ")]
            public string TextFooter = "- {tank} - {ship} - {plane} - {heli} - {chinook} -";

            [JsonProperty("Цвет подсветки, когда есть танк, корабль и тд")]
            public string ActiveColor = "#ffffff";

            [JsonProperty("Цвет неосновного текста с прозрачностью")]
            public string PassiveColor = "1 1 1 0.5";

            [JsonProperty("Название танка")]
            public string PAnzerName = "танк";

            [JsonProperty("Название корбля")]
            public string ShipName = "корабль";

            [JsonProperty("Название самолета")]
            public string AirName = "самолет";

            [JsonProperty("Название вертолета")]
            public string HeliName = "вертолет";

            [JsonProperty("Название чинука")]
            public string ChinookName = "чинук";

            [JsonProperty("Расоложение верхнего шаблона - MAX")]
            public string HeaderMax = "610 710";

            [JsonProperty("Расоложение верхнего шаблона - MIN")]
            public string HeaderMin = "300 695";

            [JsonProperty("Расоложение нижнего шаблона - MAX")]
            public string FooterMax = "610 698";

            [JsonProperty("Расоложение нижнего шаблона - MIN")]
            public string FooterMin = "300 650";

            [JsonProperty("Частота обновления игрового времени")]
            public float UpdateTime = 5.0f;

            [JsonProperty("Ключ от ipgeolocation.io (Для получения времени игрока, сервис бесплатный)")]
            public string IpGeoAPIKey = "";

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    PluginVersion = new VersionNumber(),
                    IpGeoAPIKey = "",
                };
            }
        }

        class Parser
        {
            public string date_time;
        }

        void OnServerInitialized()
        {
            Init = true;
            BasePlayer.activePlayerList.ToList().ForEach(OnPlayerConnected);
            UpdateActionValues = ServerMgr.Instance.StartCoroutine(UpdateValues());
        }

        void CreateMenu(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "OnlinePanel_Main");
            CuiElementContainer container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Parent = "Hud",
                Name = "OnlinePanel_Main",
                Components =
                    {
                        new CuiImageComponent { Color = "0 0 0 0"},
                        new CuiRectTransformComponent{ AnchorMin = "0.5 0", AnchorMax = $"0.5 0"},
                    }
            });

            var time = DateTime.UtcNow.ToLocalTime() - PlayersTime[player].time;

            container.Add(new CuiElement
            {
                Parent = "OnlinePanel_Main",
                Components =
                    {
                        new CuiTextComponent { Color = config.PassiveColor.StartsWith("#") ? HexToRustFormat(config.PassiveColor) : config.PassiveColor, FontSize = config.TextSize, Align = TextAnchor.UpperCenter,

                            Text = string.Format(config.TextHeader, TOD_Sky.Instance.Cycle.DateTime.ToString("HH:mm"), time.ToString("HH:mm"), BasePlayer.activePlayerList.Count,  ServerMgr.Instance.connectionQueue.Joining + ServerMgr.Instance.connectionQueue.Queued, BasePlayer.sleepingPlayerList.Count)
                        },
                        new CuiRectTransformComponent{ AnchorMin = "0.5 0", AnchorMax = $"0.5 0", OffsetMin = config.HeaderMin, OffsetMax = config.HeaderMax},
                    }
            });
            var color = config.ActiveColor;
            container.Add(new CuiElement
            {
                Parent = "OnlinePanel_Main",
                Components =
                    {
                        new CuiTextComponent { Color = config.PassiveColor.StartsWith("#") ? HexToRustFormat(config.PassiveColor) : config.PassiveColor, FontSize = config.TextSize, Align = TextAnchor.UpperCenter, Text = config.TextFooter.Replace("{tank}", BradleyAPC ? $"<color={color}>{config.PAnzerName}</color>" :  config.PAnzerName).Replace("{ship}", CargoShip ? $"<color={color}>{config.ShipName}</color>" :  config.ShipName).Replace("{plane}", CargoPlane ? $"<color={color}>{config.AirName}</color>" :  config.AirName).Replace("{heli}",  BaseHelicopter ? $"<color={color}>{config.HeliName}</color>" :  config.HeliName).Replace("{chinook}",  CH47Helicopter ? $"<color={color}>{config.ChinookName}</color>" :  config.ChinookName)},
                        new CuiRectTransformComponent{ AnchorMin = "0.5 0", AnchorMax = $"0.5 0", OffsetMin = config.FooterMin, OffsetMax = config.FooterMax},
                    }
            });

            CuiHelper.AddUi(player, container);
        }

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);
            Color color = new Color32(r, g, b, a);
            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }
    }
}


// --- End of file: OnlinePanel.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Hookie.cs ---
// --- Original Local Path: Hookie.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;
using Oxide.Core.Plugins;
using Rust;
using System.Reflection;
namespace Oxide.Plugins
{

    /* ------------------- [ HOOKS ] -------------------

    [1] IsPlayerInArea(player, MinX, MinY, MaxX, MaxY); (Bool)
    [2] SetPlayerHealth(player, amount); (Void)
    [3] Slap(BasePlayer player, amount = 12); (Bool)
    [4] GivePlayerHealth(player, amount); (Void)
    [5] RemovePlayerHealth(player, amount); (Void)
    [6] Explode(BasePlayer player, damage = 60, times = 1); (Void)
    [7] IsPlayerInWater(player); (Bool)
    [8] HealAll(); (Void)
    [9] MoveEveryPlayerToPlayer(player); (Void)
    [10] GetGroundPosition(sourcepos); (Vecto3)
    [11] FindPlayer(stringtofind); (BasePlayer); [Reneb]
    [12] FindPlayerByID(id); (BasePlayer); [Reneb]

        Commands:
        Slap, Explode, Heal, HealAll, TpAll
    ----------------------------------------------------*/

    [Info("Hookie", "Norn", 0.1, ResourceId = 1518)]
    [Description("Useful hooks.")]
    public class Hookie : RustPlugin
    {
        void OnServerInitialized()
        {
            if(Config["Messages", "Teleported"] == null) { Puts("Configuration file out of date, resetting..."); LoadDefaultConfig(); }
        }
        protected override void LoadDefaultConfig()
        {
            Puts("No configuration file found, generating..."); Config.Clear();

            Config["General", "Commands"] = true;

            Config["Messages", "NoAuth"] = "<color=yellow>ERROR:</color> You don't have access to this command.";
            Config["Messages", "NoPlayersFound"] = "<color=yellow>ERROR:</color> No players found.";
            Config["Messages", "MultiplePlayers"] = "<color=yellow>ERROR:</color> Multiple players found.";
            Config["Messages", "Slap"] = "<color=yellow>INFO:</color> You have slapped <color=red>{name}</color>!";
            Config["Messages", "Slapped"] = "<color=yellow>INFO:</color> You have been slapped by <color=red>{name}</color>!";
            Config["Messages", "Explode"] = "<color=yellow>INFO:</color> You have exploded <color=red>{name}</color>!";
            Config["Messages", "Exploded"] = "<color=yellow>INFO:</color> You have been exploded by <color=red>{name}</color>!";
            Config["Messages", "Heal"] = "<color=yellow>INFO:</color> You have healed <color=green>{name}</color>!";
            Config["Messages", "Healed"] = "<color=yellow>INFO:</color> You have been healed by <color=green>{name}</color>!";
            Config["Messages", "TP"] = "<color=yellow>INFO:</color> You have teleported <color=green>{name}</color>!";
            Config["Messages", "Teleported"] = "<color=yellow>INFO:</color> You have been teleported by <color=green>{name}</color>!";

            Config["Admin", "MinLevel"] = 1;
            Config["Admin", "MaxLevel"] = 2;
        }
        private bool IsPlayerInArea(BasePlayer player, float MinX, float MinY, float MaxX, float MaxY)
        {
            if (player != null && player.isConnected)
            { float X = player.transform.position.x; float Y = player.transform.position.y; float Z = player.transform.position.z; if (X >= MinX && X <= MaxX && Y >= MinY && Y <= MaxY) { return true; } }
            return false;
        }
        private void Explode(BasePlayer player, float damage = 60, int times = 1)
        {
            if (player != null & player.isConnected) {
                for (int i = 1; i <= times; i++)
                { Effect.server.Run("assets/bundled/prefabs/fx/firebomb.prefab", player.transform.position); Effect.server.Run("assets/bundled/prefabs/fx/gas_explosion_small.prefab", player.transform.position); Effect.server.Run("assets/prefabs/npc/patrol helicopter/effects/rocket_explosion.prefab", player.transform.position); Effect.server.Run("assets/prefabs/npc/patrol helicopter/effects/rocket_explosion.prefab", player.transform.position); Effect.server.Run("assets/prefabs/npc/patrol helicopter/effects/rocket_explosion.prefab", player.transform.position); Effect.server.Run("assets/prefabs/tools/c4/effects/c4_explosion.prefab", player.transform.position); }
                player.Hurt(damage, global::Rust.DamageType.Explosion, null, true);
            }
        }
        private static LayerMask GROUND_MASKS = LayerMask.GetMask("Terrain", "World", "Construction");
        static Vector3 GetGroundPosition(Vector3 sourcePos)
        {
            RaycastHit hitInfo;

            if (Physics.Raycast(sourcePos, Vector3.down, out hitInfo, GROUND_MASKS))
            {
                sourcePos.y = hitInfo.point.y;
            }
            sourcePos.y = Mathf.Max(sourcePos.y, TerrainMeta.HeightMap.GetHeight(sourcePos));
            return sourcePos;
        }
        private object FindPlayerByID(ulong steamid)
        {
            BasePlayer targetplayer = BasePlayer.FindByID(steamid);
            if (targetplayer != null)
            {
                return targetplayer;
            }
            targetplayer = BasePlayer.FindSleeping(steamid);
            if (targetplayer != null)
            {
                return targetplayer;
            }
            return null;
        }
        private object FindPlayer(string tofind)
        {
            if (tofind.Length == 17)
            {
                ulong steamid; if (ulong.TryParse(tofind.ToString(), out steamid))
                { return FindPlayerByID(steamid); }
            }
            List<BasePlayer> onlineplayers = BasePlayer.activePlayerList as List<BasePlayer>; object targetplayer = null; foreach (BasePlayer player in onlineplayers.ToArray())
            {
                if (player.displayName.ToString() == tofind)
                    return player;
                else if (player.displayName.ToString().Contains(tofind))
                {
                    if (targetplayer == null)
                        targetplayer = player;
                    else
                        return Config["Messages", "MultiplePlayers"].ToString();
                }
            }
            if (targetplayer != null)
                return targetplayer; List<BasePlayer> offlineplayers = BasePlayer.sleepingPlayerList as List<BasePlayer>; foreach (BasePlayer player in offlineplayers.ToArray())
            {
                if (player.displayName.ToString() == tofind)
                    return player;
                else if (player.displayName.ToString().Contains(tofind))
                {
                    if (targetplayer == null)
                        targetplayer = player;
                    else
                        return Config["Messages", "MultiplePlayers"].ToString();
                }
            }
            if (targetplayer == null)
                return Config["Messages", "NoPlayersFound"].ToString(); return targetplayer;
        }
        private int MoveEveryPlayerToPlayer(BasePlayer user)
        {
            int count = 0; if (user == null) { return count; }
            float addon = 1; foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (player != user)
                { Vector3 pos = player.transform.position; pos.z = pos.z + addon; var newSpawn = GetGroundPosition(pos); player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, true); player.ClientRPCPlayer(null, player, "StartLoading"); if (BasePlayer.sleepingPlayerList.Contains(player) == false) BasePlayer.sleepingPlayerList.Add(player); player.transform.position = newSpawn; var LastPositionValue = typeof(BasePlayer).GetField("lastPositionValue", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic)); LastPositionValue.SetValue(player, player.transform.position); player.ClientRPCPlayer(null, player, "ForcePositionTo", newSpawn); player.TransformChanged(); player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true); player.UpdateNetworkGroup(); player.SendNetworkUpdateImmediate(false); player.SendFullSnapshot(); player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, false); player.ClientRPCPlayer(null, player, "FinishLoading"); count++; addon++; }
            }
            if (count != 0) { Puts("Moved " + count.ToString() + " players to " + user.displayName + " [" + user.userID + "]."); }
            return count;
        }
        [ChatCommand("explode")]
        private void cmdExplode(BasePlayer player, string command, string[] args)
        {
            if (!Convert.ToBoolean(Config["General", "Commands"])) { return; }
            if (player.net.connection.authLevel >= Convert.ToInt32(Config["Admin", "MinLevel"]) && player.net.connection.authLevel <= Convert.ToInt32(Config["Admin", "MaxLevel"]))
            {
                if (args.Length == 1)
                {
                    object foundp = FindPlayer(args[0]);
                    BasePlayer target = foundp as BasePlayer;
                    if (target == null || !target.IsConnected())
                    {
                        PrintToChat(player, Config["Messages", "NoPlayersFound"].ToString()); return;
                    }
                    else
                    {
                        string parsed_config = Config["Messages", "Explode"].ToString();
                        parsed_config = parsed_config.Replace("{name}", target.displayName);
                        PrintToChat(player, parsed_config);
                        parsed_config = Config["Messages", "Exploded"].ToString();
                        parsed_config = parsed_config.Replace("{name}", player.displayName);
                        PrintToChat(target, parsed_config);
                        Puts(player.displayName + " has exploded " + target.displayName + " [ " + target.userID.ToString() + " ].");
                        Explode(target);
                    }
                }
            }
            else { PrintToChat(player, Config["Messages", "NoAuth"].ToString()); }
        }
        [ChatCommand("slap")]
        private void cmdSlap(BasePlayer player, string command, string[] args)
        {
            if (!Convert.ToBoolean(Config["General", "Commands"])) { return; }
            if (player.net.connection.authLevel >= Convert.ToInt32(Config["Admin", "MinLevel"]) && player.net.connection.authLevel <= Convert.ToInt32(Config["Admin", "MaxLevel"]))
            {
                if (args.Length == 1)
                {
                    object foundp = FindPlayer(args[0]);
                    BasePlayer target = foundp as BasePlayer;
                    if (target == null || !target.IsConnected())
                    {
                        PrintToChat(player, Config["Messages", "NoPlayersFound"].ToString()); return;
                    }
                    else
                    {
                        string parsed_config = Config["Messages", "Slap"].ToString();
                        parsed_config = parsed_config.Replace("{name}", target.displayName);
                        PrintToChat(player, parsed_config);
                        parsed_config = Config["Messages", "Slapped"].ToString();
                        parsed_config = parsed_config.Replace("{name}", player.displayName);
                        PrintToChat(target, parsed_config);
                        Puts(player.displayName + " has slapped " + target.displayName + " [ " + target.userID.ToString() + " ].");
                        Slap(target);
                    }
                }
            }
            else { PrintToChat(player, Config["Messages", "NoAuth"].ToString()); }
        }
        [ChatCommand("tpall")]
        private void cmdTPAll(BasePlayer player, string command, string[] args)
        {
            if (!Convert.ToBoolean(Config["General", "Commands"])) { return; }
            if (player.net.connection.authLevel >= Convert.ToInt32(Config["Admin", "MinLevel"]) && player.net.connection.authLevel <= Convert.ToInt32(Config["Admin", "MaxLevel"]))
            {
                string parsed_config = Config["Messages", "TP"].ToString();
                parsed_config = parsed_config.Replace("{name}", player.displayName);
                PrintToChat(parsed_config);
                MoveEveryPlayerToPlayer(player);
                PrintToChat("<color=yellow>"+player.displayName + "</color> has moved teleported every user.");
            }
            else { PrintToChat(player, Config["Messages", "NoAuth"].ToString()); }
        }
        [ChatCommand("healall")]
        private void cmdHealAll(BasePlayer player, string command, string[] args)
        {
            if (!Convert.ToBoolean(Config["General", "Commands"])) { return; }
            if (player.net.connection.authLevel >= Convert.ToInt32(Config["Admin", "MinLevel"]) && player.net.connection.authLevel <= Convert.ToInt32(Config["Admin", "MaxLevel"]))
            {
                string parsed_config = Config["Messages", "Healed"].ToString();
                parsed_config = parsed_config.Replace("{name}", player.displayName);
                PrintToChat(parsed_config);
                HealAll();
            }
            else { PrintToChat(player, Config["Messages", "NoAuth"].ToString()); }
        }
        [ChatCommand("heal")]
        private void cmdHeal(BasePlayer player, string command, string[] args)
        {
            if (!Convert.ToBoolean(Config["General", "Commands"])) { return; }
            if (player.net.connection.authLevel >= Convert.ToInt32(Config["Admin", "MinLevel"]) && player.net.connection.authLevel <= Convert.ToInt32(Config["Admin", "MaxLevel"]))
            {
                if (args.Length == 1)
                {
                    object foundp = FindPlayer(args[0]);
                    BasePlayer target = foundp as BasePlayer;
                    if (target == null || !target.IsConnected())
                    {
                        PrintToChat(player, Config["Messages", "NoPlayersFound"].ToString()); return;
                    }
                    else
                    {
                        string parsed_config = Config["Messages", "Heal"].ToString();
                        parsed_config = parsed_config.Replace("{name}", target.displayName);
                        PrintToChat(player, parsed_config);
                        parsed_config = Config["Messages", "Healed"].ToString();
                        parsed_config = parsed_config.Replace("{name}", player.displayName);
                        PrintToChat(target, parsed_config);
                        Puts(player.displayName + " has healed " + target.displayName + " [ " + target.userID.ToString() + " ].");
                        SetPlayerHealth(target, 100);
                    }
                }
            }
            else { PrintToChat(player, Config["Messages", "NoAuth"].ToString()); }
        }
        private void HealAll() { foreach (BasePlayer player in BasePlayer.activePlayerList) { if (player != null && player.isConnected) { player.health = 100; } } }
        private bool IsPlayerInWater(BasePlayer player) { if (player != null && player.isConnected) { return player.IsSwimming(); } return false; }
        private void RemovePlayerHealth(BasePlayer player, float hp) { if (player != null && player.isConnected) { player.health = player.health - hp; } }
        private void GivePlayerHealth(BasePlayer player, float hp) { if (player != null && player.isConnected) { player.health = player.health + hp; } }
        private void SetPlayerHealth(BasePlayer player, float hp) { if (player != null && player.isConnected) { player.health = hp; } }
        private bool Slap(BasePlayer player, float amount = 12)
        {
            if (player != null && player.isConnected)
            { float X = player.transform.position.x; float Y = player.transform.position.y; float Z = player.transform.position.z; Vector3 destination = new Vector3(X, Y + amount, Z); player.transform.position = destination; var LastPositionValue = typeof(BasePlayer).GetField("lastPositionValue", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic)); LastPositionValue.SetValue(player, player.transform.position); player.ClientRPCPlayer(null, player, "ForcePositionTo", destination); player.TransformChanged(); return true; }
            return false;
        }
    }
}

// --- End of file: Hookie.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ZoneInfoGUI.cs ---
// --- Original Local Path: ZoneInfoGUI.cs ---

﻿using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("ZoneInfoGUI", "SNAK84", "1.0.1")]
    public class ZoneInfoGUI : RustPlugin
    {
        [PluginReference] Plugin ZoneManager;

        #region Config
        private ConfigData Conf;
        private class ConfigData
        {
            public string AnchorMax = "0.307 0.95";
            public string AnchorMin = "0 0.92";
            public int FontSize = 15;
            public List<ZoneConfig> ZonesConfig = new List<ZoneConfig>();
        }
        private class ZoneConfig
        {
            public bool Enable = true;
            public string ZoneID;
            public string Text = "Вы находитесь в зоне {zonename}";
            public string Color = "0 1 0 0.4";
            public string TextColor = "1 1 1 1";
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Creating new config file.");
            var config = new ConfigData();
            SaveConfig();
        }

        private void LoadConfigVariables()
        {
            Conf = Config.ReadObject<ConfigData>();
            SaveConfig(Conf);
        }

        void SaveConfig(ConfigData config)
        {
            Config.WriteObject(config, true);
        }

        #endregion


        #region Oxide hooks
        void Init()
        {
            LoadConfigVariables();
        }

        void OnPluginLoaded(Plugin name)
        {
            if (name == ZoneManager)
            {
                PrintError("Plugin ZoneManager has been loaded");
                OnServerInitialized();
            }
        }

        void OnServerInitialized()
        {
            if (!ZoneManager)
            {
                PrintError("Unable to find a valid ZoneManager plugin! Unable to continue");
                return;
            }

            int DelZone = 0, AddZone = 0;

            List<string> Zones = ZoneManager.Call<string[]>("GetZoneIDs").ToList<string>();

            foreach (string ZoneId in Zones)
            {
                ZoneConfig Zone = Conf.ZonesConfig.Find(p => p.ZoneID == ZoneId);

                if (Zone == null)
                {
                    Conf.ZonesConfig.Add(new ZoneConfig { ZoneID = ZoneId });
                    AddZone++;
                }
            }
            
            foreach (ZoneConfig Zone in Conf.ZonesConfig)
            {
                if (ZoneManager.Call<string>("CheckZoneID", Zone.ZoneID) == null)
                {
                    Conf.ZonesConfig.Remove(Zone);
                    DelZone++;
                }
            }

            SaveConfig(Conf);
            if (AddZone > 0) Puts("Added new zones to config: " + AddZone.ToString());
            if (DelZone > 0) Puts("Removed zones from config: " + DelZone.ToString());

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                string[] PZones = ZoneManager.Call<string[]>("GetPlayerZoneIDs", player);
                if (PZones != null) CreateUI(player, GetZone(PZones[0]));
            }

        }

        void OnPlayerSleepEnded(BasePlayer player)
        {
            string[] PZones = ZoneManager?.Call<string[]>("GetPlayerZoneIDs", player);
            if (PZones != null) CreateUI(player, GetZone(PZones[0]));
        }

        void OnEnterZone(string ZoneID, BasePlayer player)
        {
            CreateUI(player, GetZone(ZoneID));
        }

        void OnExitZone(string ZoneID, BasePlayer player)
        {
            DestroyUI(player);
        }

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyUI(player);
            }
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            DestroyUI(player);
        }

        #endregion

        ZoneConfig GetZone(string ZoneId)
        {
            ZoneConfig Zone = Conf.ZonesConfig.Find(p => p.ZoneID == ZoneId);
            if (Zone == null)
            {
                Zone = new ZoneConfig { ZoneID = ZoneId };
                Conf.ZonesConfig.Add(Zone);
            }

            return Zone;
        }


        #region UI


        void DestroyUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "ZoneInfoGUI");
        }

        void CreateUI(BasePlayer player, ZoneConfig Zone)
        {

            DestroyUI(player);

            if (!Zone.Enable) return;

            string ZoneText = Zone.Text.Replace("{zonename}", ZoneManager.Call<string>("GetZoneName", Zone.ZoneID));

            CuiElementContainer container = new CuiElementContainer();

            var panel = container.Add(new CuiPanel()
            {
                Image = { Color = Zone.Color },
                RectTransform = { AnchorMin = Conf.AnchorMin, AnchorMax = Conf.AnchorMax }
            }, "Hud", "ZoneInfoGUI");

            CuiElement element = new CuiElement
            {
                Parent = panel,
                Components = {
                    new CuiTextComponent { Text = ZoneText, FontSize = Conf.FontSize, Color = Zone.TextColor, Align = TextAnchor.MiddleCenter },
                    new CuiRectTransformComponent { AnchorMin = "0.0 0.0", AnchorMax = "1.0 1.0" }
                }
            };
            container.Add(element);

            CuiHelper.AddUi(player, container);
        }
        #endregion
    }
}


// --- End of file: ZoneInfoGUI.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SkipNightVote.cs ---
// --- Original Local Path: SkipNightVote.cs ---

using System.Collections.Generic;
using System;
using System.Reflection;
using System.Data;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;


namespace Oxide.Plugins {
    [Info("SkipNightVote", "Mordenak", "1.1.0", ResourceId = 1014)]
    class SkipNightVote : RustPlugin {

        public class TimePoll : RustPlugin {
            Dictionary<string, bool> votesReceived = new Dictionary<string, bool>();
            float votesRequired;

            public TimePoll(float votes) {
                votesRequired = votes;
            }

            bool checkVote(string playerId) {
                if ( votesReceived.ContainsKey(playerId) ) 
                    return false;
                return true;
            }

            public bool voteDay(BasePlayer player) {
                var playerId = player.userID.ToString();

                if (!checkVote(playerId))
                    return false;
                votesReceived.Add(playerId, true);
                return true;
            }

            public int tallyVotes() {
                int yesVotes = 0;
                foreach (var votes in votesReceived) {
                    if (votes.Value) 
                        yesVotes = yesVotes + 1;
                }
                return yesVotes;
            }

            public bool wasVoteSuccessful() {
                float result = (float)tallyVotes() / BasePlayer.activePlayerList.Count;
                if (result >= votesRequired)
                    return true;
                else
                    return false;
            }

        }

        public float requiredVotesPercentage = 0.5f; // % of votes needed to change time
        public float pollRetryTime = 5; // in minutes
        public float pollTimer = 1.0f; // in minutes
        public int sunsetHour = 18; // hour to start a vote
        public int sunriseHour = 8; // hour to set if vote is successful
        public bool displayVoteProgress = false; // determine whether to display a message for vote progress

        bool readyToCheck = false;
        
        public TimePoll votePoll = null;
        float lastPoll = 0f;

        // Messages!
        string noPollOpen = "No poll is open at this time.";
        string alreadyVoted = "You have already voted once.";
        string voteProgress = "Vote progress: {0} / {1} ({2}%/{3}%)";
        string voteOpenTime = "Night time skip vote is now open for {0} minute(s).";
        string voteSuccessful = "Vote was successful, it will be daytime soon.";
        string voteFailed = "Vote failed, not enough players voted to skip night time.";
        string voteReOpenTime = "Vote will re-open in {0} minute(s).";
        string voteNow = "Type <color=#FF2211>/voteday</color> now to skip night time.";
        

        [ChatCommand("voteday")]
        void cmdVoteTime(BasePlayer player, string command, string[] args) {
            if (votePoll == null) {
                SendReply(player, noPollOpen);
                return;
            }

            var checkVote = votePoll.voteDay(player);
            if (!checkVote) {
                SendReply(player, alreadyVoted);
                return; // don't go further if the player has voted
            }
            checkVotes();
            if (displayVoteProgress) {
                if (votePoll != null) {
                    int totalPlayers = BasePlayer.activePlayerList.Count;
                    int votes = votePoll.tallyVotes();
                    float percent = (float)votes / totalPlayers;
                    MessageAllPlayers( string.Format(voteProgress, votes, totalPlayers, (int)(percent*100), (int)(requiredVotesPercentage*100)) );
                }
            }
        }

        
        void openVote()
        {
            if (votePoll != null) 
                return;
            votePoll = new TimePoll(requiredVotesPercentage);
            MessageAllPlayers(string.Format(voteOpenTime, pollTimer) );
            MessageAllPlayers(voteNow);
            lastPoll = Time.realtimeSinceStartup;
        }

        void closeVote() {
            votePoll = null;
        }

        void checkVotes() {
            if (votePoll.wasVoteSuccessful()) {
                MessageAllPlayers(voteSuccessful);
                // change time
                TOD_Sky.Instance.Cycle.Hour = sunriseHour;
                Puts("{0}: {1}", Title, "has changed the server time.");
                // clean up votePoll
                closeVote();
            }
        }

        [HookMethod("OnTick")]
        private void OnTick() {
            try {
                if (readyToCheck) {
                    //Debug.Log("Plugin passed ready check...");
                    if (votePoll != null) { // timeout
                        if (Time.realtimeSinceStartup >= (lastPoll + (pollTimer * 60))) {
                            MessageAllPlayers( voteFailed );
                            MessageAllPlayers(string.Format(voteReOpenTime, pollRetryTime) );
                            closeVote();
                        }
                    }
                    if (TOD_Sky.Instance.Cycle.Hour <= sunsetHour && TOD_Sky.Instance.Cycle.Hour >= sunriseHour) {
                        // it's already day do nothing
                    }
                    else {
                        // check when last vote was...
                        if (Time.realtimeSinceStartup >= (lastPoll + (pollRetryTime * 60)) ) {
                            if (votePoll == null)
                                openVote();
                            else
                                checkVotes();
                        }
                    }
                }
            }
            catch (Exception ex) {
                PrintError("{0}: {1}", Title,"OnTick failed: " + ex.Message);
            }
        }

        private void MessageAllPlayers(string message) {
            foreach (BasePlayer player in BasePlayer.activePlayerList) {
                SendReply(player, message);
            }
        }

        void PopulateConfig() {

            Config["Version"] = Version.ToString();

            var settings = new Dictionary<string, object>();
            settings.Add("requiredVotesPercentage", requiredVotesPercentage);
            settings.Add("pollRetryTime", pollRetryTime);
            settings.Add("pollTimer", pollTimer);
            settings.Add("sunsetHour", sunsetHour);
            settings.Add("sunriseHour", sunriseHour);
            settings.Add("displayVoteProgress", displayVoteProgress);

            Config["Settings"] = settings;

            // messages
            var messages = new Dictionary<string, string>();
            messages.Add("noPollOpen", "No poll is open at this time.");
            messages.Add("alreadyVoted", "You have already voted once.");
            messages.Add("voteProgress", "Vote progress: {0} / {1} ({2}%/{3}%)");
            messages.Add("voteOpenTime", "Night time skip vote is now open for {0} minute(s).");
            messages.Add("voteSuccessful", "Vote was successful, it will be daytime soon.");
            messages.Add("voteFailed", "Vote failed, not enough players voted to skip night time.");
            messages.Add("voteReOpenTime", "Vote will re-open in {0} minute(s).");
            messages.Add("voteNow", "Type <color=#FF2211>/voteday</color> now to skip night time.");

            Config["Messages"] = messages;

            SaveConfig();
        }

        void Loaded() {
            LoadConfig();

            Debug.Log( string.Format("version is {0}", Version) );

            if (Config["Version"] != null) {
                var cfgVersion = Config["Version"] as string;
                if (cfgVersion != Version.ToString()) {
                    PrintError("{0}: {1}", Title, "Config out of date!  Forcing update.");
                    Config.Clear();
                    PopulateConfig();
                    readyToCheck = true;
                }
                else {
                    if (Config["Settings"] != null) {
                        var settings = Config["Settings"] as Dictionary<string, object>;

                        requiredVotesPercentage = (float)Convert.ChangeType(settings["requiredVotesPercentage"], typeof(float));
                        pollRetryTime = (float)Convert.ChangeType(settings["pollRetryTime"], typeof(float));
                        pollTimer = (float)Convert.ChangeType(settings["pollTimer"], typeof(float));
                        sunsetHour = (int)settings["sunsetHour"];
                        sunriseHour = (int)settings["sunriseHour"];
                        displayVoteProgress = (bool)settings["displayVoteProgress"];
                    }
                    else {
                        PrintError("{0}: {1}", Title, "Loading Config[\"Settings\"] failed.");
                    }

                    if (Config["Messages"] != null) {
                        var messages = Config["Messages"] as Dictionary<string, object>;

                        
                        noPollOpen = (string)messages["noPollOpen"];
                        alreadyVoted = (string)messages["alreadyVoted"];
                        voteProgress = (string)messages["voteProgress"];
                        voteOpenTime = (string)messages["voteOpenTime"];
                        voteSuccessful = (string)messages["voteSuccessful"];
                        voteFailed = (string)messages["voteFailed"];
                        voteReOpenTime = (string)messages["voteReOpenTime"];
                        voteNow = (string)messages["voteNow"];
                    }
                    else {
                        PrintError("{0}: {1}", Title, "Loading Config[\"Messages\"] failed.");
                    }
                    
                    readyToCheck = true;
                    // it appears we don't want to get this too early...
                    PopulateConfig();
                }
            }
            else {
                PrintError("{0}: {1}", Title, "Config out of date!  Forcing update.");
                Config.Clear();
                PopulateConfig();
                readyToCheck = true;
            }
        }



    }

}


// --- End of file: SkipNightVote.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CovertAdmin (1).cs ---
// --- Original Local Path: CovertAdmin (1).cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using UnityEngine;
using Random = UnityEngine.Random;
using System.Text;

namespace Oxide.Plugins
{
    [Info("CovertAdmin", "redBDGR", "1.0.6")]
    [Description("Go fully undercover and disguise yourself as another player")]
    internal class CovertAdmin : RustPlugin
    {
        [PluginReference] private Plugin BetterChat;

        private bool Changed;

        private Dictionary<string, CovertInfo> covertDic = new Dictionary<string, CovertInfo>();
        private string nameColour = "#54A7FB";
        private const string permissionName = "covertadmin.use";

        private Dictionary<string, object> playerNames = new Dictionary<string, object>();

        private string tags = "";
        private string textSize = "15";
        private bool disableOnLogout = true;

        private static Dictionary<string, object> RandomPlayerNames()
        {
            var x = new Dictionary<string, object> { { "RandomName1", "randomSteamID" }, { "RandomName2", "76561198381967577" } };
            return x;
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        private void LoadVariables()
        {
            playerNames = (Dictionary<string, object>)GetConfig("Settings", "Covert Names", RandomPlayerNames());
            tags = Convert.ToString(GetConfig("Settings", "Tags", ""));
            nameColour = Convert.ToString(GetConfig("Settings", "Covert Name Colour", "#54A7FB"));
            textSize = Convert.ToString(GetConfig("Settings", "Message Size", "15"));
            disableOnLogout = Convert.ToBoolean(GetConfig("Settings", "Disable On Logout", true));

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }

        private void Init()
        {
            LoadVariables();
            permission.RegisterPermission(permissionName, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                //chat
                ["format"] = "<size={0}>{1} <color={2}>{3}</color>: {4}</size>",
                ["No Permission"] = "You cannot use this command",
                ["Covert Disabled"] = "Covert mode disabled",
                ["Covert Enabled"] = "Covert mode enabled! You will now appear under the name of \"{0}\"",
                ["Already In Covert"] = "You are already in covert mode",
                ["Login Warning"] = "Your covert mode is still activated! type /covert to disable it"
                // [0] = size
                // [1] = tags
                // [2] = colour
                // [3] = name
                // [4] = text
            }, this);
        }

        private void Unload()
        {
            foreach (var entry in covertDic)
                if (entry.Value.player.IsConnected)
                    RenamePlayer(entry.Value.player, entry.Value.restoreName);
        }

        [ChatCommand("covertstatus")]
        private void CovertStatusCMD(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionName))
            {
                player.ChatMessage(msg("No Permission", player.UserIDString));
                return;
            }
            if (covertDic.ContainsKey(player.UserIDString))
            {
                StringBuilder sb = new StringBuilder();
                sb.AppendLine("Current covert status:");
                sb.AppendLine($"Display Name: {covertDic[player.UserIDString].covertName}");
                sb.AppendLine($"Covert ID: {covertDic[player.UserIDString].covertID}");
                player.ChatMessage(sb.ToString().TrimEnd());
            }
            else
                player.ChatMessage("Covert mode is currently disabled");
        }

        [ChatCommand("covert")]
        private void CovertCMD(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionName))
            {
                player.ChatMessage(msg("No Permission", player.UserIDString));
                return;
            }
            switch (args.Length)
            {
                case 0:
                    if (covertDic.ContainsKey(player.UserIDString))
                    {
                        RenamePlayer(player, covertDic[player.UserIDString].restoreName);
                        covertDic.Remove(player.UserIDString);
                        player.ChatMessage(msg("Covert Disabled", player.UserIDString));
                    }
                    else
                    {
                        var names = playerNames.Keys.ToList();
                        var coverName = names[Convert.ToInt16(Mathf.Round(Random.Range(0f, Convert.ToSingle(playerNames.Count) - 1f)))];
                        covertDic.Add(player.UserIDString, new CovertInfo { covertName = coverName, restoreName = player.displayName, covertID = Convert.ToUInt64(playerNames[coverName]), player = player, restoreID = player.userID });
                        RenamePlayer(player, coverName);
                        player.ChatMessage(string.Format(msg("Covert Enabled", player.UserIDString), coverName));
                    }
                    break;
                case 1:
                    if (covertDic.ContainsKey(player.UserIDString))
                    {
                        player.ChatMessage(msg("Already In Covert", player.UserIDString));
                        return;
                    }
                    covertDic.Add(player.UserIDString, new CovertInfo { covertName = args[0], restoreName = player.displayName, covertID = 76561198136204161, player = player, restoreID = player.userID });
                    RenamePlayer(player, args[0]);
                    player.ChatMessage(string.Format(msg("Covert Enabled", player.UserIDString), args[0]));
                    break;
                case 2:
                    if (covertDic.ContainsKey(player.UserIDString))
                    {
                        player.ChatMessage(msg("Already In Covert", player.UserIDString));
                        return;
                    }
                    covertDic.Add(player.UserIDString, new CovertInfo { covertName = args[0], restoreName = player.displayName, covertID = Convert.ToUInt64(args[1]), player = player, restoreID = player.userID });
                    RenamePlayer(player, args[0]);
                    player.ChatMessage(string.Format(msg("Covert Enabled", player.UserIDString), args[0]));
                    break;
            }
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (!covertDic.ContainsKey(player.UserIDString))
                return;
            if (disableOnLogout)
            {
                RenamePlayer(player, covertDic[player.UserIDString].restoreName);
                covertDic.Remove(player.UserIDString);
            }
        }

        private void OnPlayerInit(BasePlayer player)
        {
            if (disableOnLogout)
                return;
            if (!covertDic.ContainsKey(player.UserIDString))
                return;
            RenamePlayer(player, covertDic[player.UserIDString].covertName);
            player.ChatMessage(msg("Login Warning", player.UserIDString));
        }

        private object OnPlayerDie(BasePlayer player, HitInfo info)
        {
            if (info == null)
                return null;
            if (info.Initiator == null)
                return null;
            BasePlayer attacker = info.Initiator.GetComponent<BasePlayer>();
            if (!attacker)
                return null;
            if (covertDic.ContainsKey(attacker.UserIDString))
            {
                attacker.userID = covertDic[attacker.UserIDString].covertID;
                timer.Once(0.2f, () =>
                {
                    if (attacker != null)
                        attacker.userID = covertDic[attacker.UserIDString].restoreID;
                });
            }
            return null;
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            if (covertDic.ContainsKey(player.UserIDString))
                RenamePlayer(player, covertDic[player.UserIDString].covertName);
        }

        private void RenamePlayer(BasePlayer player, string name)
        {
            player.displayName = name;
            IPlayer _player = covalence.Players.FindPlayerById(player.UserIDString);
            _player.Rename(name);
            player.SendNetworkUpdateImmediate();
        }

        private object OnBetterChat(Dictionary<string, object> data)
        {
            var player = data["Player"] as IPlayer;
            if (player == null)
                return null;
            if (!covertDic.ContainsKey(player.Id))
                return null;
            rust.BroadcastChat(null, string.Format(msg("format"), textSize, tags, nameColour, player.Name, data["Text"]), covertDic[player.Id].covertID.ToString()); //  76561198136204161
            return false;
        }

        private object OnPlayerChat(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null)
                return null;
            if (!covertDic.ContainsKey(player.UserIDString)) return null;
            player.userID = covertDic[player.UserIDString].covertID;
            timer.Once(0.2f, () =>
            {
                if (!player) return;
                if (covertDic.ContainsKey(player.UserIDString))
                    player.userID = covertDic[player.UserIDString].restoreID;
            });
            return true;
        }

        private object OnUserChat(IPlayer player, string message)
        {
            if (covertDic.ContainsKey(player.Id))
            {
                if (!BetterChat)
                    rust.BroadcastChat(null, string.Format(msg("format"), textSize, tags, nameColour, player.Name, message, covertDic[player.Id].covertID.ToString()));
                return true;
            }
            return null;
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (data.TryGetValue(datavalue, out value)) return value;
            value = defaultValue;
            data[datavalue] = value;
            Changed = true;
            return value;
        }

        private string msg(string key, string id = null) => lang.GetMessage(key, this, id);

        private class CovertInfo
        {
            public ulong covertID;
            public string covertName;
            public BasePlayer player;
            public string restoreName;
            public ulong restoreID;
        }
    }
}

// --- End of file: CovertAdmin (1).cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/IQChat.cs ---
// --- Original Local Path: IQChat.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using ConVar;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("IQChat", "Mercury", "0.1.0")]
    [Description("aaaaaaaaaaaaaaaaaaa")]
    class IQChat : RustPlugin
    {
        #region Vars
        public string PermMuteMenu = "iqchat.muteuse";
        #endregion

        #region Configuration

        private static Configuration config = new Configuration();
        private class Configuration
        {
            [JsonProperty("Права для смены ника")]
            public string RenamePermission;
            [JsonProperty("Настройка префиксов")]
            public Dictionary<string, string> PrefixList = new Dictionary<string, string>();
            [JsonProperty("Настройка цветов для ников")]
            public Dictionary<string, string> NickColorList = new Dictionary<string, string>();
            [JsonProperty("Настройка цветов для сообщений")]
            public Dictionary<string, string> MessageColorList = new Dictionary<string, string>();
            [JsonProperty("Настройка сообщений в чате")]
            public MessageSettings MessageSetting;                                  
            [JsonProperty("Настройка причин блокировок чата")]
            public Dictionary<string, int> ReasonListChat = new Dictionary<string, int>();
            [JsonProperty("Настройка интерфейса")]
            public InterfaceSettings InterfaceSetting;
            [JsonProperty("Настройка оповещения")]
            public AlertSetting AlertSettings;

            internal class MessageSettings
            {
                [JsonProperty("Наименование оповещения в чат")]
                public string BroadcastTitle;
                [JsonProperty("Цвет сообщения оповещения в чат")]
                public string BroadcastColor;
                [JsonProperty("На какое сообщение заменять плохие слова")]
                public string ReplaceBadWord;
                [JsonProperty("Steam64ID для аватарки в чате")]
                public ulong Steam64IDAvatar;
                [JsonProperty("Список плохих слов")]
                public List<string> BadWords = new List<string>();
                [JsonProperty("Время,через которое удалится сообщение с UI от администратора")]
                public int TimeDeleteAlertUI;
                [JsonProperty("Включить форматирование сообщений")]
                public bool FormatingMessage;
                [JsonProperty("Включить личные сообщения")]
                public bool PMActivate;
                [JsonProperty("Включить Анти-Спам")]
                public bool AntiSpamActivate;
                [JsonProperty("Звук при при получении личного сообщения")]
                public string SoundPM;
                [JsonProperty("Время через которое игрок может отправлять сообщение (АнтиСпам)")]
                public int FloodTime;
            }

            internal class InterfaceSettings
            {
                [JsonProperty("Основной цвет UI")]
                public string MainColor;
                [JsonProperty("Дополнительный #1 цвет UI")]
                public string TwoMainColor;
                [JsonProperty("Дополнительный #2 цвет UI")]
                public string ThreeMainColor;
                [JsonProperty("Основной цвет UI панели МУТОВ")]
                public string MainColorMute;
            }

            internal class AlertSetting
            {
                [JsonProperty("Включить случайное сообщение зашедшему игроку")]
                public bool WelcomeMessageUse;
                [JsonProperty("Список сообщений игроку при входе")]
                public List<string> WelcomeMessage = new List<string>();
                [JsonProperty("Уведомлять о входе игрока в чат")]
                public bool ConnectedAlert;
                [JsonProperty("Уведомлять о выходе игрока в чат")]
                public bool DisconnectedAlert;
                [JsonProperty("При уведомлении о входе/выходе игрока отображать его аватар напротив ника")]
                public bool ConnectedAvatarUse;
                [JsonProperty("Включить автоматические сообщения в чат")]
                public bool AlertMessage;
                [JsonProperty("Настройка отправки автоматических сообщений в чат")]
                public List<string> MessageList;
                [JsonProperty("Интервал отправки сообщений в чат(Броадкастер)")]
                public int MessageListTimer;
            }

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    PrefixList = new Dictionary<string, string>
                    {
                        ["iqchat.default"] = "<color=yellow><b>[+]</b></color>",
                        ["iqchat.vip"] = "<color=yellow><b>[VIP]</b></color>",
                        ["iqchat.premium"] = "<color=red><b>[PREMIUM]</b></color>",
                    },
                    NickColorList = new Dictionary<string, string>
                    {
                        ["iqchat.default"] = "#DBEAEC",
                        ["iqchat.vip"] = "#FFC428",
                        ["iqchat.premium"] = "#45AAB4",
                    },
                    MessageColorList = new Dictionary<string, string>
                    {
                        ["iqchat.default"] = "#DBEAEC",
                        ["iqchat.vip"] = "#FFC428",
                        ["iqchat.premium"] = "#45AAB4",
                    },
                    MessageSetting = new MessageSettings
                    {
                        BroadcastTitle = "<color=#007FFF><b>[ОПОВЕЩЕНИЕ]</b></color>",
                        BroadcastColor = "#74ade1",
                        ReplaceBadWord = "Ругаюсь матом",
                        Steam64IDAvatar = 0,
                        TimeDeleteAlertUI = 5,
                        PMActivate = true,
                        SoundPM = "assets/bundled/prefabs/fx/notice/stack.world.fx.prefab",
                        AntiSpamActivate = true,
                        FloodTime = 5,
                        FormatingMessage = true,                      
                        BadWords = new List<string> { "хуй", "гей", "говно", "бля", "тварь" }
                    },
                    ReasonListChat = new Dictionary<string, int>
                    {
                        ["Оскорбление игроков"] = 120,
                        ["Оскорбление родителей"] = 1200,
                    },
                    RenamePermission = "iqchat.renameuse",                  
                    AlertSettings = new AlertSetting
                    {
                        MessageListTimer = 60,
                        WelcomeMessageUse = true,
                        ConnectedAlert = true,
                        DisconnectedAlert = true,
                        AlertMessage = true,
                        ConnectedAvatarUse = true,
                        MessageList = new List<string>
                        {
                        "Автоматическое сообщение #1",
                        "Автоматическое сообщение #2",
                        "Автоматическое сообщение #3",
                        "Автоматическое сообщение #4",
                        "Автоматическое сообщение #5",
                        "Автоматическое сообщение #6",
                        },
                        WelcomeMessage = new List<string>
                        {
                            "Добро пожаловать на сервер SUPERSERVER\nРады,что выбрал именно нас!",
                            "С возвращением на сервер!\nЖелаем тебе удачи",
                            "Добро пожаловать на сервер\nУ нас самые лучшие плагины",
                        },

                    },
                    InterfaceSetting = new InterfaceSettings
                    {
                        MainColor = "#6B803EFF",
                        TwoMainColor = "#6D942BFF",
                        ThreeMainColor = "#8EBA43FF",
                        MainColorMute = "#6A803EFF",
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning("Ошибка #1" + $"чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }

        void RegisteredPermissions()
        {
            for(int i = 0; i < config.MessageColorList.Count; i++)
                permission.RegisterPermission(config.MessageColorList.ElementAt(i).Key, this);
            for (int j = 0; j < config.NickColorList.Count; j++)
                permission.RegisterPermission(config.NickColorList.ElementAt(j).Key, this);
            for (int g = 0; g < config.PrefixList.Count; g++)
                permission.RegisterPermission(config.PrefixList.ElementAt(g).Key, this);

            permission.RegisterPermission(config.RenamePermission, this);
            permission.RegisterPermission(PermMuteMenu, this);
            PrintWarning("Permissions - completed");
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Data
        [JsonProperty("Дата с настройкой чата игрока")] public Dictionary<ulong, SettingUser> ChatSettingUser = new Dictionary<ulong, SettingUser>();
        [JsonProperty("Дата с Административной настройкой")] public AdminSettings AdminSetting = new AdminSettings();
        public class SettingUser
        {
            public string ChatPrefix;
            public string NickColor;
            public string MessageColor;
            public double MuteChatTime;
            public double MuteVoiceTime;
        }

        public class AdminSettings
        {
            public bool MuteChatAll;
            public bool MuteVoiceAll;
            public Dictionary<ulong, string> RenameList = new Dictionary<ulong, string>()
;        }
        void ReadData()
        {
            ChatSettingUser = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, SettingUser>>("IQChat/IQUser");
            AdminSetting = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<AdminSettings>("IQChat/AdminSetting");
        }
        void WriteData() => timer.Every(60f, () =>
        {
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQChat/IQUser", ChatSettingUser);
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQChat/AdminSetting", AdminSetting);
        });

        void RegisteredDataUser(BasePlayer player)
        {
            if (!ChatSettingUser.ContainsKey(player.userID))
                ChatSettingUser.Add(player.userID, new SettingUser
                {
                    ChatPrefix = config.PrefixList.ElementAt(0).Value,
                    NickColor = config.NickColorList.ElementAt(0).Value,
                    MessageColor = config.MessageColorList.ElementAt(0).Value,
                    MuteChatTime = 0,
                    MuteVoiceTime = 0,
                });
        }

        #endregion

        #region Hooks
       
        private bool OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
        {
            if (Interface.Oxide.CallHook("CanChatMessage", player, message) != null) return false;
            Message(channel, player, message);
            return false;
        }

        object OnPlayerVoice(BasePlayer player, Byte[] data)
        {
            var DataPlayer = ChatSettingUser[player.userID];
            bool IsMuted = DataPlayer.MuteVoiceTime > CurrentTime() ? true : false;
            if (IsMuted)
                return false;
            return null;
        }

        private void OnServerInitialized()
        {
            ReadData();
            BasePlayer.activePlayerList.ForEach(p => RegisteredDataUser(p));
            RegisteredPermissions();
            WriteData();
            BroadcastAuto();
        }
        private void OnPlayerInit(BasePlayer player)
        {
            RegisteredDataUser(player);
            ReturnDefaultData(player);
            var Alert = config.AlertSettings;
            if (Alert.ConnectedAlert)
            {
                string Avatar = Alert.ConnectedAvatarUse ? player.UserIDString : "";
                ReplyBroadcast(String.Format(lang.GetMessage("WELCOME_PLAYER", this, player.UserIDString), player.displayName), "", Avatar);
            }
            if (Alert.WelcomeMessageUse)
            {
                int RandomMessage = UnityEngine.Random.Range(0, Alert.WelcomeMessage.Count);
                string WelcomeMessage = Alert.WelcomeMessage[RandomMessage];
                ReplySystem(Chat.ChatChannel.Global, player, WelcomeMessage);
            }
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            var Alert = config.AlertSettings;
            if (Alert.DisconnectedAlert)
            {
                string Avatar = Alert.ConnectedAvatarUse ? player.UserIDString : "";
                ReplyBroadcast(String.Format(lang.GetMessage("LEAVE_PLAYER", this, player.UserIDString), player.displayName), "", Avatar);
            }
        }
        #endregion

        #region Func
        private void Message(Chat.ChatChannel channel, BasePlayer player, string message)
        {
            if (config.MessageSetting.FormatingMessage)
            {
                message = message.ToLower();
                var firstLetter = message.Substring(0, 1);
                message = message.Remove(0, 1);
                message = firstLetter.ToUpper() + message;
            }
            var cfg = config.MessageSetting;

            for (int i = 0; i < cfg.BadWords.Count; i++)
            {
                var BadWord = cfg.BadWords[i];
                foreach (var msg in message.Split(' '))
                {
                    if (msg.ToLower() == BadWord.ToLower())
                        message = message.Replace(msg, cfg.ReplaceBadWord, StringComparison.OrdinalIgnoreCase);
                }
            }
            string FormatMessage = "";
            var DataPlayer = ChatSettingUser[player.userID];

            bool IsMuted = DataPlayer.MuteChatTime > CurrentTime() ? true : false;
            if(IsMuted)
            {
                ReplySystem(Chat.ChatChannel.Global, player,string.Format(lang.GetMessage("FUNC_MESSAGE_ISMUTED_TRUE",this,player.UserIDString),FormatTime(TimeSpan.FromSeconds(DataPlayer.MuteChatTime - CurrentTime()))));
                return;
            }
        
            Dictionary<string, object> ChatTags = new Dictionary<string, object>
            {
                ["Player"] = player,
                ["Message"] = message,
                ["Prefixes"] = DataPlayer.ChatPrefix
            };

            var HookResult = Interface.Oxide.CallHook("OnChatSystemMessage", ChatTags);
            var DisplayNick = AdminSetting.RenameList.ContainsKey(player.userID) ? AdminSetting.RenameList[player.userID] : player.displayName;
            if (HookResult != null)
            {
                if (HookResult is bool) return;
                if (channel == Chat.ChatChannel.Team)
                    FormatMessage = $"<color=#a5e664>[Team]</color> {ChatTags["Prefixes"].ToString().Replace("— ", "")} <color={DataPlayer.NickColor}>{DisplayNick}</color>: <color={DataPlayer.MessageColor}>{ChatTags["Message"]}</color>";
                else FormatMessage = $"{ChatTags["Prefixes"].ToString().Replace("— ", "")} <color={DataPlayer.NickColor}>{DisplayNick}</color>:  <color={DataPlayer.MessageColor}>{ChatTags["Message"]}</color>";
            }
            else
                if (channel == Chat.ChatChannel.Team)
                    FormatMessage = $"<color=#a5e664>[Team]</color> {DataPlayer.ChatPrefix.Replace("—", "")} <color={DataPlayer.NickColor}>{DisplayNick}</color>: <color={DataPlayer.MessageColor}>{message}</color>";
                else FormatMessage = $"{DataPlayer.ChatPrefix.Replace("—", "")} <color={DataPlayer.NickColor}>{DisplayNick}</color>: <color={DataPlayer.MessageColor}>{message}</color>";

            ReplyChat(channel, player, FormatMessage);
            Puts($"{player}: {message}");
            Log($"СООБЩЕНИЕ В ЧАТ : {FormatMessage}");
        }

        public void ReturnDefaultData(BasePlayer player)
        {
            var DataPlayer = ChatSettingUser[player.userID];
            var PrefixPerm = config.PrefixList.FirstOrDefault(x => x.Value == DataPlayer.ChatPrefix).Key;
            var PrefixColorMsg= config.MessageColorList.FirstOrDefault(x => x.Value == DataPlayer.MessageColor).Key;
            var PrefixColorNick = config.NickColorList.FirstOrDefault(x => x.Value == DataPlayer.NickColor).Key;

            if (!permission.UserHasPermission(player.UserIDString, PrefixPerm))
                DataPlayer.ChatPrefix = config.PrefixList.ElementAt(0).Value;

            if (!permission.UserHasPermission(player.UserIDString, PrefixColorMsg))
                DataPlayer.MessageColor = config.MessageColorList.ElementAt(0).Value;

            if (!permission.UserHasPermission(player.UserIDString, PrefixColorNick))
                DataPlayer.NickColor = config.NickColorList.ElementAt(0).Value;
        }

        public void BroadcastAuto()
        {
            var Alert = config.AlertSettings;
            if (Alert.AlertMessage)
            {
                timer.Every(Alert.MessageListTimer, () =>
                 {
                     var RandomMsg = Alert.MessageList[UnityEngine.Random.Range(0, Alert.MessageList.Count)];
                     ReplyBroadcast(RandomMsg);
                 });
            }
        }

        public void MutePlayer(BasePlayer player,BasePlayer Initiator,string Format,int ReasonIndex)
        {
            var cfg = config.ReasonListChat.ElementAt(ReasonIndex);
            string Reason = cfg.Key;
            float TimeMute = cfg.Value;
            switch (Format)
            {
                case "mutechat":
                    {
                        ChatSettingUser[player.userID].MuteChatTime = TimeMute + CurrentTime();
                        ReplyBroadcast(string.Format(lang.GetMessage("FUNC_MESSAGE_MUTE_CHAT", this, player.UserIDString), Initiator.displayName,player.displayName,FormatTime(TimeSpan.FromSeconds(TimeMute)), Reason));
                        break;
                    }
                case "unmutechat":
                    {
                        ChatSettingUser[player.userID].MuteChatTime = 0;
                        ReplyBroadcast(string.Format(lang.GetMessage("FUNC_MESSAGE_UNMUTE_CHAT", this, player.UserIDString), Initiator.displayName));
                        break;
                    }
                case "mutevoice":
                    {
                        ChatSettingUser[player.userID].MuteVoiceTime = TimeMute + CurrentTime();
                        ReplyBroadcast(string.Format(lang.GetMessage("FUNC_MESSAGE_MUTE_VOICE", this), Initiator.displayName, player.displayName, FormatTime(TimeSpan.FromSeconds(TimeMute)), Reason)); 
                        break;
                    }
            }
        }
        
        public void MuteAllChatPlayer(BasePlayer player,float TimeMute = 86400) => ChatSettingUser[player.userID].MuteChatTime = TimeMute + CurrentTime();

        public void RenameFunc(BasePlayer player,string NewName)
        {
            if (permission.UserHasPermission(player.UserIDString, config.RenamePermission))
            {
                if (!AdminSetting.RenameList.ContainsKey(player.userID))
                    AdminSetting.RenameList.Add(player.userID, NewName);
                else AdminSetting.RenameList[player.userID] = NewName;
                ReplySystem(Chat.ChatChannel.Global, player, String.Format(lang.GetMessage("COMMAND_RENAME_SUCCES", this, player.UserIDString),NewName));
            }
            else ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_NOT_PERMISSION", this, player.UserIDString)); 
        }

        #endregion

        #region Interface
        static string MAIN_PARENT = "MAIN_PARENT_UI";
        static string MUTE_MENU_PARENT = "MUTE_MENU_UI";
        static string ELEMENT_SETTINGS = "NEW_ELEMENT_SETTINGS";
        static string MAIN_ALERT_UI = "ALERT_UI_PLAYER";

        public void UI_MainMenu(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, MAIN_PARENT);

            #region Panels

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5",OffsetMin = "-300 -150", OffsetMax = "0 200" },
                Image = { FadeIn = 0.15f, Color = HexToRustFormat(config.InterfaceSetting.MainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, "Overlay", MAIN_PARENT);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.8628572", AnchorMax = "1 1" },
                Image = { Color = HexToRustFormat(config.InterfaceSetting.TwoMainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            },  MAIN_PARENT, "TITLE_PANEL");

            #endregion

            #region Labels

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.3888887", AnchorMax = "1 1" },
                Text = { Text = lang.GetMessage("TITLE_ONE",this,player.UserIDString), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, "TITLE_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.4694438" },
                Text = { Text = lang.GetMessage("TITLE_TWO", this, player.UserIDString), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, "TITLE_PANEL");

            #region BtnLabels

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.01 0.7828571", AnchorMax = "1 0.8419046" },
                Text = { Text = lang.GetMessage("UI_TEXT_PREFIX", this, player.UserIDString), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft, FadeIn = 0.3f }
            },  MAIN_PARENT);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.01 0.6285695", AnchorMax = "1 0.6876169" },
                Text = { Text = lang.GetMessage("UI_TEXT_COLOR_NICK", this, player.UserIDString), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft, FadeIn = 0.3f }
            }, MAIN_PARENT);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.01 0.3806", AnchorMax = "1 0.5428537" },
                Text = { Text = lang.GetMessage("UI_TEXT_COLOR_MSG", this, player.UserIDString), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft, FadeIn = 0.3f }
            }, MAIN_PARENT);

            #endregion

            #endregion

            #region Buttons

            container.Add(new CuiButton
            {
                FadeOut = 0.2f,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0",OffsetMin = "0 -30", OffsetMax = "300 -1" },
                Button = { Close = MAIN_PARENT, Color = HexToRustFormat("#C43E28FF"), Material = "assets/content/ui/uibackgroundblur.mat", FadeIn = 0.1f },
                Text = { Text = lang.GetMessage("UI_CLOSE_BTN",this,player.UserIDString), Color = HexToRustFormat("#FFBBB0FF"), Align = TextAnchor.MiddleCenter }
            }, MAIN_PARENT,"BTN_CLOSE_PARENT");

            container.Add(new CuiElement
            {
                Parent = "BTN_CLOSE_PARENT",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat("#772500FF"), Sprite = "assets/icons/close.png"  },
                        new CuiRectTransformComponent { AnchorMin = "0.01896266 0.1418719", AnchorMax = "0.09458128 0.8512315" }
                    }
            });

            #region PrefixSettings

            container.Add(new CuiButton
            {
                FadeOut = 0.2f,
                RectTransform = { AnchorMin = "0 0.7085695", AnchorMax = "1 0.7790456" },
                Button = { Command = "iq_chat newelementsettingsprefix", Color = HexToRustFormat(config.InterfaceSetting.ThreeMainColor), Material = "assets/content/ui/uibackgroundblur.mat", FadeIn = 0.1f },
                Text = { Text = lang.GetMessage("UI_TEXT_GO_SETTINGS", this, player.UserIDString), Align = TextAnchor.MiddleCenter }
            }, MAIN_PARENT, "BTN_PREFIX_SETTINGS");

            container.Add(new CuiElement
            {
                Parent = "BTN_PREFIX_SETTINGS",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat("#FFFFFFFF"), Sprite = "assets/icons/gear.png",  },
                        new CuiRectTransformComponent { AnchorMin = "0.01333339 0.1621625", AnchorMax = "0.06666672 0.8108124" }
                    }
            });

            container.Add(new CuiElement
            {
                Parent = "BTN_PREFIX_SETTINGS",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat("#FFFFFFFF"), Sprite = "assets/icons/gear.png"  },
                        new CuiRectTransformComponent { AnchorMin = "0.9333356 0.1621625", AnchorMax = "0.9866689 0.8108124" }
                    }
            });

            #endregion

            #region NickColorSettings

            container.Add(new CuiButton
            {
                FadeOut = 0.2f,
                RectTransform = { AnchorMin = "0 0.5542819", AnchorMax = "1 0.62475266" },
                Button = { Command = "iq_chat newelementsettingscolornick", Color = HexToRustFormat(config.InterfaceSetting.ThreeMainColor), Material = "assets/content/ui/uibackgroundblur.mat", FadeIn = 0.1f },
                Text = { Text = lang.GetMessage("UI_TEXT_GO_SETTINGS", this, player.UserIDString), Align = TextAnchor.MiddleCenter }
            }, MAIN_PARENT, "BTN_NICK_COLOR_SETTINGS");

            container.Add(new CuiElement
            {
                Parent = "BTN_NICK_COLOR_SETTINGS",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat("#FFFFFFFF"), Sprite = "assets/icons/gear.png"  },
                        new CuiRectTransformComponent { AnchorMin = "0.01333339 0.1621625", AnchorMax = "0.06666672 0.8108124" }
                    }
            });

            container.Add(new CuiElement
            {
                Parent = "BTN_NICK_COLOR_SETTINGS",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat("#FFFFFFFF"), Sprite = "assets/icons/gear.png"  },
                        new CuiRectTransformComponent { AnchorMin = "0.9333356 0.1621625", AnchorMax = "0.9866689 0.8108124" }
                    }
            });

            #endregion

            #region MsgColorSettings

            container.Add(new CuiButton
            {
                FadeOut = 0.2f,
                RectTransform = { AnchorMin = "0 0.4114244", AnchorMax = "1 0.19015" },
                Button = { Command = "iq_chat newelementsettingcolormessage", Color = HexToRustFormat(config.InterfaceSetting.ThreeMainColor), Material = "assets/content/ui/uibackgroundblur.mat", FadeIn = 0.1f },
                Text = { Text = lang.GetMessage("UI_TEXT_GO_SETTINGS", this, player.UserIDString), Align = TextAnchor.MiddleCenter }
            }, MAIN_PARENT, "BTN_MSG_COLOR_SETTINGS");

            container.Add(new CuiElement
            {
                Parent = "BTN_MSG_COLOR_SETTINGS",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat("#FFFFFFFF"), Sprite = "assets/icons/gear.png"  },
                        new CuiRectTransformComponent { AnchorMin = "0.01333339 0.1621625", AnchorMax = "0.06666672 0.8108124" }
                    }
            });

            container.Add(new CuiElement
            {
                Parent = "BTN_MSG_COLOR_SETTINGS",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat("#FFFFFFFF"), Sprite = "assets/icons/gear.png"  },
                        new CuiRectTransformComponent { AnchorMin = "0.9333356 0.1621625", AnchorMax = "0.9866689 0.8108124" }
                    }
            });

            #endregion

            #endregion

            #region AdminPanel
            if (player.IsAdmin)
            {
                string CommandChat = "iq_chat admin_chat";
                string ColorMuteChatButton = AdminSetting.MuteChatAll ? "#C43E28FF" : config.InterfaceSetting.ThreeMainColor;
                string TextMuteChatButton = AdminSetting.MuteChatAll ? "UI_TEXT_ADMIN_PANEL_UNMUTE_CHAT_ALL" : "UI_TEXT_ADMIN_PANEL_MUTE_CHAT_ALL";
                string CommandMuteChatButton = AdminSetting.MuteChatAll ? "unmutechat" : "mutechat";
                string CommandVoice = "iq_chat admin_voice";
                string ColorMuteVoiceButton = AdminSetting.MuteVoiceAll ? "#C43E28FF" : config.InterfaceSetting.ThreeMainColor;
                string TextMuteVoiceButton = AdminSetting.MuteVoiceAll ? "UI_TEXT_ADMIN_PANEL_UNMUTE_VOICE_ALL" : "UI_TEXT_ADMIN_PANEL_MUTE_VOICE_ALL";
                string CommandMuteVoiceButton = AdminSetting.MuteVoiceAll ? "unmutevoice" : "mutevoice";

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0 0.3104762", AnchorMax = "1 0.3923809" },
                    Image = { Color = HexToRustFormat(config.InterfaceSetting.TwoMainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
                }, MAIN_PARENT, "AdminPanel_TITLE");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = lang.GetMessage("UI_TEXT_ADMIN_PANEL", this, player.UserIDString), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
                }, "AdminPanel_TITLE");

                container.Add(new CuiButton
                {
                    FadeOut = 0.2f,
                    RectTransform = { AnchorMin = "0 0.2342857", AnchorMax = "1 0.3047618" },
                    Button = { Close = MAIN_PARENT, Command = $"{CommandChat} {CommandMuteChatButton}", Color = HexToRustFormat(ColorMuteChatButton), Material = "assets/content/ui/uibackgroundblur.mat", FadeIn = 0.1f },
                    Text = { Text = lang.GetMessage(TextMuteChatButton, this, player.UserIDString), Align = TextAnchor.MiddleCenter }
                }, MAIN_PARENT);

                container.Add(new CuiButton
                {
                    FadeOut = 0.2f,
                    RectTransform = { AnchorMin = "0 0.1580954", AnchorMax = "1 0.2285715" },
                    Button = { Close = MAIN_PARENT, Command = $"{CommandVoice} {CommandMuteVoiceButton}", Color = HexToRustFormat(ColorMuteVoiceButton), Material = "assets/content/ui/uibackgroundblur.mat", FadeIn = 0.1f },
                    Text = { Text = lang.GetMessage(TextMuteVoiceButton, this, player.UserIDString), Align = TextAnchor.MiddleCenter }
                }, MAIN_PARENT);               
            }
            #endregion

            CuiHelper.AddUi(player, container);
        }

        public void UI_MuteMenu(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, MUTE_MENU_PARENT);

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-500 -250", OffsetMax = "500 300" },
                Image = { FadeIn = 0.15f, Color = HexToRustFormat(config.InterfaceSetting.MainColorMute), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, "Overlay", MUTE_MENU_PARENT);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.8957576", AnchorMax = "1 1" },
                Image = { Color = HexToRustFormat(config.InterfaceSetting.TwoMainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, MUTE_MENU_PARENT, "TITLE_PANEL_MUTE");

            #region PlayerList
            int x = 0; int y = 0;
            foreach (var pList in BasePlayer.activePlayerList)
            {
                string ColorButton = ChatSettingUser[pList.userID].MuteChatTime > CurrentTime() ? "#C43E28FF" : ChatSettingUser[pList.userID].MuteVoiceTime > CurrentTime() ? "#C43E28FF" : config.InterfaceSetting.ThreeMainColor;
                container.Add(new CuiButton
                {
                    FadeOut = 0.2f,
                    RectTransform = { AnchorMin = $"{0.004058793 + (x * 0.144)} {0.7551514 - (y * 0.05)}", AnchorMax = $"{0.1306667 + (x * 0.144)} {0.7974398 - (y * 0.05)}" },
                    Button = { Command = $"iq_chat mute_take_action {pList.userID}", Color = HexToRustFormat(ColorButton), Material = "assets/content/ui/uibackgroundblur.mat", FadeIn = 0.1f },
                    Text = { Text = pList.displayName, Align = TextAnchor.MiddleCenter }
                }, MUTE_MENU_PARENT, "BUTTON" + player.userID);

                x++;
                if (x == 7)
                {
                    y++;
                    x = 0;
                }
                if (y == 13 && x == 6) break;

            };

            #endregion

            #region Helps

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.002666675 0.05212118", AnchorMax = "0.02333329 0.0881" },
                Image = { Color = HexToRustFormat(config.InterfaceSetting.ThreeMainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, MUTE_MENU_PARENT);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.002666662 0.006060584", AnchorMax = "0.02333332 0.04242422" },
                Image = { Color = HexToRustFormat("#C43E28FF"), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, MUTE_MENU_PARENT);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.02133331 0.05212118", AnchorMax = "0.282 0.0882" },
                Text = { Text = lang.GetMessage("UI_MUTE_PANEL_TITLE_HELPS_GREEN", this, player.UserIDString), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, MUTE_MENU_PARENT);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.02133331 0.00823", AnchorMax = "0.2746667 0.04" },
                Text = { Text = lang.GetMessage("UI_MUTE_PANEL_TITLE_HELPS_RED", this, player.UserIDString), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, MUTE_MENU_PARENT);

            #endregion

            #region Labels

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.2906973", AnchorMax = "1 1" },
                Text = { Text = lang.GetMessage("UI_MUTE_PANEL_TITLE", this, player.UserIDString), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, "TITLE_PANEL_MUTE");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.4418605" },
                Text = { Text = lang.GetMessage("UI_MUTE_PANEL_TITLE_ACTION", this, player.UserIDString), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, "TITLE_PANEL_MUTE");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.8036363", AnchorMax = "1 0.8436363" },
                Text = { Text = lang.GetMessage("UI_MUTE_PANEL_TITLE_PLIST", this, player.UserIDString), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, MUTE_MENU_PARENT);

            #endregion

            #region Buttons

            container.Add(new CuiButton
            {
                FadeOut = 0.2f,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 -35", OffsetMax = "0 -3" },
                Button = { Close = MUTE_MENU_PARENT, Color = HexToRustFormat("#C43E28FF"), Material = "assets/content/ui/uibackgroundblur.mat", FadeIn = 0.1f },
                Text = { Text = lang.GetMessage("UI_CLOSE_BTN", this, player.UserIDString), Color = HexToRustFormat("#FFBBB0FF"), Align = TextAnchor.MiddleCenter }
            }, MUTE_MENU_PARENT, "BTN_CLOSE_MUTE_MENU_PARENT");

            #endregion

            CuiHelper.AddUi(player, container);
        }

        public void UI_MuteTakeAction(BasePlayer player,ulong userID)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, "TAKE_ACTION_MUTE");

            #region Panels

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.3526041 0.6037037", AnchorMax = "0.65125 0.778889" },
                Image = { Color = HexToRustFormat(config.InterfaceSetting.MainColorMute), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, MUTE_MENU_PARENT, "TAKE_ACTION_MUTE");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.6712323", AnchorMax = "1 1" },
                Image = { Color = HexToRustFormat(config.InterfaceSetting.TwoMainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, "TAKE_ACTION_MUTE","TITLE_MENU_MUTE_ACTION");

            #endregion

            #region Labels

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Text = { Text = lang.GetMessage("UI_MUTE_TAKE_ACTION_PANEL", this, player.UserIDString), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, "TITLE_MENU_MUTE_ACTION");

            #endregion

            #region Buttons
            string ButtonColorChat = ChatSettingUser[userID].MuteChatTime > CurrentTime() ? "#C43E28FF" : config.InterfaceSetting.ThreeMainColor;
            string ButtonColorVoice = ChatSettingUser[userID].MuteVoiceTime > CurrentTime() ? "#C43E28FF" : config.InterfaceSetting.ThreeMainColor;
            string ButtonChat = ChatSettingUser[userID].MuteChatTime > CurrentTime() ?  "UI_MUTE_TAKE_ACTION_CHAT_UNMUTE" : "UI_MUTE_TAKE_ACTION_CHAT";
            string ButtonVoice = ChatSettingUser[userID].MuteVoiceTime > CurrentTime() ? "UI_MUTE_TAKE_ACTION_VOICE_UNMUTE" : "UI_MUTE_TAKE_ACTION_VOICE";
            string ButtonCommandChat = ChatSettingUser[userID].MuteChatTime > CurrentTime() ? $"iq_chat mute_action {userID} unmutechat" : $"iq_chat mute_action {userID} mute mutechat";
            string ButtonCommandVoice = ChatSettingUser[userID].MuteVoiceTime > CurrentTime() ? $"iq_chat mute_action {userID} unmutevoice" : $"iq_chat mute_action {userID} mute mutevoice";
            container.Add(new CuiButton
            {
                FadeOut = 0.2f,
                RectTransform = { AnchorMin = "0 0.3787669", AnchorMax = "1 0.6127237" },
                Button = { Command = ButtonCommandChat, Color = HexToRustFormat(ButtonColorChat), Material = "assets/content/ui/uibackgroundblur.mat", FadeIn = 0.1f },
                Text = { Text = lang.GetMessage(ButtonChat,this,player.UserIDString),  Align = TextAnchor.MiddleCenter }
            },  "TAKE_ACTION_MUTE");

            container.Add(new CuiButton
            {
                FadeOut = 0.2f,
                RectTransform = { AnchorMin = "0 0.07369863", AnchorMax = "1 0.3150686"},
                Button = { Command = ButtonCommandVoice, Color = HexToRustFormat(ButtonColorVoice), Material = "assets/content/ui/uibackgroundblur.mat", FadeIn = 0.1f },
                Text = { Text = lang.GetMessage(ButtonVoice, this, player.UserIDString), Align = TextAnchor.MiddleCenter }
            },  "TAKE_ACTION_MUTE");

            #endregion

            CuiHelper.AddUi(player, container);
        }

        void UI_MuteTakeActionShowListReason(BasePlayer player,ulong userID,string MuteFormat)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, "TAKE_PANEL_REASON");

            #region Panels
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "0 -300", OffsetMax = "300 0" },
                Image = { Color = HexToRustFormat(config.InterfaceSetting.MainColorMute), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, "TAKE_ACTION_MUTE","TAKE_PANEL_REASON");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.8859987", AnchorMax = "1 1" },
                Image = { Color = HexToRustFormat(config.InterfaceSetting.TwoMainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, "TAKE_PANEL_REASON", "TAKE_ACTION_MUTE_TITLE");

            #endregion

            #region Labels

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Text = { Text = lang.GetMessage("UI_MUTE_TAKE_REASON_TITLE", this, player.UserIDString), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, "TAKE_ACTION_MUTE_TITLE");

            #endregion

            #region Buttons
            for (int i = 0; i < config.ReasonListChat.Count; i++)
            {
                var Reason = config.ReasonListChat.ElementAt(i);
                container.Add(new CuiButton
                {
                    FadeOut = 0.2f,
                    RectTransform = { AnchorMin = $"0 {0.76898 - (i * 0.118)}", AnchorMax = $"1 {0.8694967 - (i * 0.118)}" },
                    Button = { Command = $"iq_chat mute_action {userID} mute_reason {MuteFormat} {i}", Color = HexToRustFormat("#90BC37FF"), Material = "assets/content/ui/uibackgroundblur.mat", FadeIn = 0.1f },
                    Text = { Text = Reason.Key, Align = TextAnchor.MiddleCenter }
                }, "TAKE_PANEL_REASON", "BUTTON" + i);
            }

            #endregion

            CuiHelper.AddUi(player, container);
        }

        #region NewElementSettings
        public void NewElementSettings(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, ELEMENT_SETTINGS);

            #region Panels

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "-300 -30", OffsetMax = "-1 350" },
                Image = { FadeIn = 0.15f, Color = HexToRustFormat(config.InterfaceSetting.MainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            },  MAIN_PARENT, ELEMENT_SETTINGS);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0.9959 0.07606" },
                Image = { Color = HexToRustFormat(config.InterfaceSetting.TwoMainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            },  ELEMENT_SETTINGS, "MySettingPanel");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.9126315", AnchorMax = "0.9959 1" },
                Image = { Color = HexToRustFormat(config.InterfaceSetting.TwoMainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, ELEMENT_SETTINGS, "TitlePanel");

            #endregion

            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region NewElementPrefixSettings
        public void NewElementPrefixSetting(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            var Prefix = ChatSettingUser[player.userID].ChatPrefix;
            var MyColorNick = ChatSettingUser[player.userID].NickColor;
            var PrefixList = config.PrefixList;
            #region Buttons

            int x = 0, y = 0;
            for(int i = 0; i < PrefixList.Count; i++)
            {
                var ElementPrefix = PrefixList.ElementAt(i);
                if (!permission.UserHasPermission(player.UserIDString, ElementPrefix.Key)) continue;
                container.Add(new CuiButton
                {
                    FadeOut = 0.2f,
                    RectTransform = { AnchorMin = $"{0.009514093 + (x * 0.594)} {0.77595 - (y * 0.07)}", AnchorMax = $"{0.3950973 + (x * 0.594)} {0.8368425 - (y * 0.07)}" },
                    Button = { Command = $"iq_chat prefix_selected {ElementPrefix.Value} MySettingPanel Prefix_Label {ElementPrefix.Value}<color={MyColorNick}>{player.displayName}</color>", Color = HexToRustFormat(config.InterfaceSetting.ThreeMainColor), Material = "assets/content/ui/uibackgroundblur.mat", FadeIn = 0.1f },
                    Text = { Text = ElementPrefix.Value, Color = HexToRustFormat("#FFBBB0FF"), Align = TextAnchor.MiddleCenter }
                },  ELEMENT_SETTINGS, $"BUTTON_{i}");
                x++;
                if (x == 2)
                {
                    y++;
                    x = 0;
                }
            }
            #endregion

            #region Labels

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Text = { Text = lang.GetMessage("UI_TEXT_PREFIX",this,player.UserIDString), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, "TitlePanel");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Text = { Text = $"{Prefix}<color={MyColorNick}>{player.displayName}</color>", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, "MySettingPanel", "Prefix_Label");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.8476694", AnchorMax = "1 0.9090226" },
                Text = { Text = lang.GetMessage("UI_TITLE_NEW_PREFIX_ELEMENT",this,player.UserIDString), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            },  ELEMENT_SETTINGS);

            #endregion

            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region NewElementNickColorSetting
        public void NewElementNickColorSetting(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            var MyColor = ChatSettingUser[player.userID].NickColor;
            var MyPrefix = ChatSettingUser[player.userID].ChatPrefix;
            var ColorList = config.NickColorList;
            #region Buttons

            int x = 0, y = 0;
            for (int i = 0; i < ColorList.Count; i++)
            {
                var ElementColor = ColorList.ElementAt(i);
                if (!permission.UserHasPermission(player.UserIDString, ElementColor.Key)) continue;
                container.Add(new CuiButton
                {
                    FadeOut = 0.2f,
                    RectTransform = { AnchorMin = $"{0.009514093 + (x * 0.594)} {0.77595 - (y * 0.07)}", AnchorMax = $"{0.3950973 + (x * 0.594)} {0.8368425 - (y * 0.07)}" },
                    Button = { Command = $"iq_chat nick_color_selected {ElementColor.Value} MySettingPanel Nick_Color_Label {MyPrefix}<color={ElementColor.Value}>{player.displayName}</color>", Color = HexToRustFormat(config.InterfaceSetting.ThreeMainColor), Material = "assets/content/ui/uibackgroundblur.mat", FadeIn = 0.1f },
                    Text = { Text = $"<color={ElementColor.Value}>{player.displayName}</color>", Align = TextAnchor.MiddleCenter }
                }, ELEMENT_SETTINGS, $"BUTTON_{i}");
                x++;
                if (x == 2)
                {
                    y++;
                    x = 0;
                }
            }
            #endregion

            #region Labels

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Text = { Text = lang.GetMessage("UI_TEXT_COLOR_NICK", this, player.UserIDString), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, "TitlePanel");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Text = { Text = $"{MyPrefix}<color={MyColor}>{player.displayName}</color>", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, "MySettingPanel", "Nick_Color_Label");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.8476694", AnchorMax = "1 0.9090226" },
                Text = { Text = lang.GetMessage("UI_TITLE_NEW_NICK_COLOR_ELEMENT", this, player.UserIDString), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, ELEMENT_SETTINGS);

            #endregion

            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region NewElementMessageColorSetting
        public void NewElementMessageColorSetting(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            var MyColor = ChatSettingUser[player.userID].MessageColor;
            var MyColorNick = ChatSettingUser[player.userID].NickColor;
            var MyPrefix = ChatSettingUser[player.userID].ChatPrefix;
            var ColorList = config.MessageColorList;
            #region Buttons

            int x = 0, y = 0;
            for (int i = 0; i < ColorList.Count; i++)
            {
                var ElementColor = ColorList.ElementAt(i);
                if (!permission.UserHasPermission(player.UserIDString, ElementColor.Key)) continue;
                container.Add(new CuiButton
                {
                    FadeOut = 0.2f,
                    RectTransform = { AnchorMin = $"{0.009514093 + (x * 0.594)} {0.77595 - (y * 0.07)}", AnchorMax = $"{0.3950973 + (x * 0.594)} {0.8368425 - (y * 0.07)}" },
                    Button = { Command = $"iq_chat message_color_selected {ElementColor.Value} MySettingPanel Message_Color_Label {MyPrefix}<color={MyColorNick}>{player.displayName}</color>:<color={ElementColor.Value}>Сообщение</color>", Color = HexToRustFormat(config.InterfaceSetting.ThreeMainColor), Material = "assets/content/ui/uibackgroundblur.mat", FadeIn = 0.1f },
                    Text = { Text = $"<color={ElementColor.Value}>Сообщение</color>", Align = TextAnchor.MiddleCenter }
                }, ELEMENT_SETTINGS, $"BUTTON_{i}");
                x++;
                if (x == 2)
                {
                    y++;
                    x = 0;
                }
            }

            #endregion

            #region Labels

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Text = { Text = lang.GetMessage("UI_TEXT_COLOR_MSG", this, player.UserIDString), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, "TitlePanel");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Text = { Text = $"{MyPrefix}<color={MyColorNick}>{player.displayName}</color>:<color={MyColor}>Сообщение</color>", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, "MySettingPanel", "Message_Color_Label");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.8476694", AnchorMax = "1 0.9090226" },
                Text = { Text = lang.GetMessage("UI_TITLE_NEW_MESSAGE_COLOR_ELEMENT", this, player.UserIDString), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, ELEMENT_SETTINGS);

            #endregion


            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region UpdateLabel

        public void UpdateLabel(BasePlayer player,string Parent,string Name ,string TextLabel)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, Name);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Text = { Text = $"{TextLabel}", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            },  Parent, Name);

            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region UIAlert
        void UIAlert(BasePlayer player,string Message)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, MAIN_ALERT_UI);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-250 -280", OffsetMax = "231 -250" },
                Image = { Color = HexToRustFormat(config.InterfaceSetting.TwoMainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            },  "Overlay", MAIN_ALERT_UI);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Text = { Text = $"{Message}", FontSize = 14, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            },  MAIN_ALERT_UI);

            CuiHelper.AddUi(player, container);

            timer.Once(config.MessageSetting.TimeDeleteAlertUI, () =>
            {
                CuiHelper.DestroyUi(player, MAIN_ALERT_UI);
            });
        }
        #endregion

        #endregion

        #region Command

        [ChatCommand("chat")]
        void ChatCommandMenu(BasePlayer player)
        {
            UI_MainMenu(player);
        }

        [ChatCommand("mute")]
        void ChatMuteCommandMenu(BasePlayer player, string cmd, string[] arg)
        {
            if (arg.Length == 0 || arg == null)
            {
                if (permission.UserHasPermission(player.UserIDString, PermMuteMenu))
                    UI_MuteMenu(player);
            }
        }

        [ChatCommand("alert")]
        void ChatAlertPlayers(BasePlayer player,string cmd,string[] arg)
        {
            if (!player.IsAdmin) return;
            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("FUNC_MESSAGE_NO_ARG_BROADCAST", this, player.UserIDString));
                return;
            }
            string Message = "";
            foreach (var msg in arg)
                Message += " " + msg;
            
            ReplyBroadcast(Message);
        }

        [ConsoleCommand("alert")]
        void ChatAlertPlayersCMD(ConsoleSystem.Arg arg)
        {
            if (arg.Args.Length == 0 || arg.Args == null)
            {
                PrintWarning(lang.GetMessage("FUNC_MESSAGE_NO_ARG_BROADCAST", this));
                return;
            }
            string Message = "";
            foreach (var msg in arg.Args)
                Message += " " + msg;

            ReplyBroadcast(Message);
        }

        [ConsoleCommand("alertui")]
        void ChatAlertPlayersUICMD(ConsoleSystem.Arg arg)
        {
            if (arg.Args.Length == 0 || arg.Args == null)
            {
                PrintWarning(lang.GetMessage("FUNC_MESSAGE_NO_ARG_BROADCAST", this));
                return;
            }
            string Message = "";
            foreach (var msg in arg.Args)
                Message += " " + msg;

            BasePlayer.activePlayerList.ForEach(p => UIAlert(p, Message));
        }

        [ChatCommand("alertui")]
        void ChatAlertPlayersUI(BasePlayer player, string cmd, string[] arg)
        {
            if (!player.IsAdmin) return;
            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("FUNC_MESSAGE_NO_ARG_BROADCAST", this, player.UserIDString));
                return;
            }
            string Message = "";
            foreach (var msg in arg)
                Message += " " + msg;

            BasePlayer.activePlayerList.ForEach(p => UIAlert(p, Message));
        }

        [ChatCommand("rename")]
        void RenameMetods(BasePlayer player,string cmd, string[] arg)
        {
            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_RENAME_NOTARG", this, player.UserIDString));
                return;
            }
            string NewName = "";
            foreach (var name in arg)
                NewName += " " + name;
            RenameFunc(player, NewName);          
        }
                    
        public Dictionary<BasePlayer, BasePlayer> PMHistory = new Dictionary<BasePlayer, BasePlayer>();

        [ChatCommand("pm")]
        void PmChat(BasePlayer player, string cmd, string[] arg)
        {
            if (!config.MessageSetting.PMActivate) return;
            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_PM_NOTARG", this, player.UserIDString));
                return;
            }
            string NameUser = arg[0];
            BasePlayer TargetUser = FindPlayer(NameUser);
            if (TargetUser == null || NameUser == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_PM_NOT_USER", this, player.UserIDString));
                return;
            }
            var argList = arg.ToList();
            argList.RemoveAt(0);
            string Message = string.Join(" ", argList.ToArray());
            if (Message.Length > 125) return;
            if(Message.Length <= 0 || Message == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_PM_NOT_NULL_MSG", this, player.UserIDString));
                return;
            }

            PMHistory[TargetUser] = player;
            PMHistory[player] = TargetUser;
            var DisplayNick = AdminSetting.RenameList.ContainsKey(player.userID) ? AdminSetting.RenameList[player.userID] : player.displayName;

            ReplySystem(Chat.ChatChannel.Global, TargetUser, String.Format(lang.GetMessage("COMMAND_PM_SEND_MSG",this,player.UserIDString), DisplayNick, Message));
            ReplySystem(Chat.ChatChannel.Global, player, String.Format(lang.GetMessage("COMMAND_PM_SUCCESS", this,player.UserIDString), Message));
            Effect.server.Run(config.MessageSetting.SoundPM, TargetUser.GetNetworkPosition());
            Log($"ЛИЧНЫЕ СООБЩЕНИЯ : {player.displayName}({DisplayNick}) отправил сообщение игроку - {TargetUser.displayName}\nСООБЩЕНИЕ : {Message}");
        }

        [ChatCommand("r")]
        void RChat(BasePlayer player, string cmd, string[] arg)
        {
            if (!config.MessageSetting.PMActivate) return;
            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_R_NOTARG", this, player.UserIDString));
                return;
            }
            if (!PMHistory.ContainsKey(player))
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_R_NOTMSG", this, player.UserIDString));
                return;
            }
            BasePlayer RetargetUser = PMHistory[player];
            if (RetargetUser == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_PM_NOT_USER", this, player.UserIDString));
                return;
            }
            var argList = arg.ToList();
            string Message = string.Join(" ", argList.ToArray());
            if (Message.Length > 125) return;
            if (Message.Length <= 0 || Message == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_PM_NOT_NULL_MSG", this, player.UserIDString));
                return;
            }
            PMHistory[RetargetUser] = player;
            var DisplayNick = AdminSetting.RenameList.ContainsKey(player.userID) ? AdminSetting.RenameList[player.userID] : player.displayName;

            ReplySystem(Chat.ChatChannel.Global, RetargetUser, String.Format(lang.GetMessage("COMMAND_PM_SEND_MSG", this, player.UserIDString), DisplayNick, Message));
            ReplySystem(Chat.ChatChannel.Global, player, String.Format(lang.GetMessage("COMMAND_PM_SUCCESS", this, player.UserIDString), Message));
            Effect.server.Run(config.MessageSetting.SoundPM, RetargetUser.GetNetworkPosition());
            Log($"ЛИЧНЫЕ СООБЩЕНИЯ : {player.displayName} отправил сообщение игроку - {RetargetUser.displayName}\nСООБЩЕНИЕ : {Message}");
        }
        
        [ConsoleCommand("set")]
        private void ConsolesCommandPrefixSet(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length < 1 || arg.Args[0].Length < 0)
            {
                Puts("Используйте правильно ситаксис : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                return;
            }
            ulong Steam64ID = 0;
            BasePlayer player = null;
            if (ulong.TryParse(arg.Args[0], out Steam64ID))
                player = BasePlayer.FindByID(Steam64ID);
            if (player == null)
            {
                Puts("Неверно указан SteamID игрока или ошибка в синтаксисе\nИспользуйте правильно ситаксис : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                return;
            }
            var DataPlayer = ChatSettingUser[player.userID];

            switch (arg.Args[1].ToLower())
            {
                case "prefix":
                    {
                        string KeyPrefix = arg.Args[2];
                        if (config.PrefixList.ContainsKey(KeyPrefix))
                        {
                            var Prefix = config.PrefixList[KeyPrefix];
                            DataPlayer.ChatPrefix = Prefix;
                            Puts($"Префикс успешно установлен на - {Prefix}");
                        }
                        else Puts("Неверно указан Permissions от префикса");
                        break;
                    }
                case "chat":
                    {
                        string KeyChatColor = arg.Args[2];
                        if (config.PrefixList.ContainsKey(KeyChatColor))
                        {
                            var Message = config.MessageColorList[KeyChatColor];
                            DataPlayer.MessageColor = Message;
                            Puts($"Цвет сообщения успешно установлен на - {Message}");
                        }
                        else Puts("Неверно указан Permissions от префикса");

                        break;
                    }
                case "nick":
                    {
                        string KeyNickColor = arg.Args[2];
                        if (config.PrefixList.ContainsKey(KeyNickColor))
                        {
                            var Nick = config.NickColorList[KeyNickColor];
                            DataPlayer.NickColor = Nick;
                            Puts($"Цвет ника успешно установлен на - {Nick}");
                        }
                        else Puts("Неверно указан Permissions от префикса");

                        break;
                    }
                case "custom":
                    {
                        string CustomPrefix = arg.Args[2];
                        DataPlayer.ChatPrefix = CustomPrefix;
                        Puts($"Кастомный префикс успешно установлен на - {CustomPrefix}");
                        break;
                    }
                default:
                    {
                        Puts("Используйте правильно ситаксис : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                        break;
                    }
            }

        }

        [ConsoleCommand("iq_chat")] 
        private void ConsoleCommandIQChat(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            var DataPlayer = ChatSettingUser[player.userID];
            switch (arg.Args[0])
            {
                case "newelementsettingsprefix":
                    {
                        NewElementSettings(player);
                        NewElementPrefixSetting(player);
                        break;
                    }
                case "newelementsettingscolornick":
                    {
                        NewElementSettings(player);
                        NewElementNickColorSetting(player);
                        break;
                    }
                case "newelementsettingcolormessage":
                    {
                        NewElementSettings(player);
                        NewElementMessageColorSetting(player);
                        break;
                    }
                case "prefix_selected":
                    {
                        var SelectedPrefix = arg.Args[1];
                        var ParentLabel = arg.Args[2];
                        var NameLabel = arg.Args[3];
                        var TextLabel = arg.Args[4];
                        DataPlayer.ChatPrefix = SelectedPrefix;
                        UpdateLabel(player, ParentLabel, NameLabel, TextLabel);
                        break;
                    }
                case "nick_color_selected":
                    {
                        var SelectedNickColor = arg.Args[1];
                        var ParentLabel = arg.Args[2];
                        var NameLabel = arg.Args[3];
                        var TextLabel = arg.Args[4];
                        DataPlayer.NickColor = SelectedNickColor;
                        UpdateLabel(player, ParentLabel, NameLabel, TextLabel);
                        break;
                    }
                case "message_color_selected":
                    {
                        var SelectedMessageColor = arg.Args[1];
                        var ParentLabel = arg.Args[2];
                        var NameLabel = arg.Args[3];
                        var TextLabel = arg.Args[4];
                        DataPlayer.MessageColor = SelectedMessageColor;
                        UpdateLabel(player, ParentLabel, NameLabel, TextLabel);
                        break;
                    }
                case "mute_take_action": 
                    {
                        BasePlayer target = BasePlayer.FindByID(ulong.Parse(arg.Args[1]));
                        UI_MuteTakeAction(player, target.userID);
                        break;
                    }
                case "mute_action": 
                    {
                        BasePlayer target = BasePlayer.FindByID(ulong.Parse(arg.Args[1]));
                        string Action = arg.Args[2];
                        switch (Action)
                        {
                            case "mute":
                                {
                                    string MuteFormat = arg.Args[3];
                                    UI_MuteTakeActionShowListReason(player, target.userID, MuteFormat);
                                    break;
                                }
                            case "mute_reason": 
                                {
                                    CuiHelper.DestroyUi(player, MUTE_MENU_PARENT);
                                    string MuteFormat = arg.Args[3];
                                    int Index = Convert.ToInt32(arg.Args[4]);
                                    MutePlayer(target, player, MuteFormat, Index);
                                    break;
                                }
                            case "unmutechat":
                                {
                                    CuiHelper.DestroyUi(player, MUTE_MENU_PARENT);
                                    ChatSettingUser[target.userID].MuteChatTime = 0;
                                    ReplyBroadcast(string.Format(lang.GetMessage("FUNC_MESSAGE_UNMUTE_CHAT",this),player.displayName,target.displayName));
                                    break;
                                }
                            case "unmutevoice":
                                {
                                    CuiHelper.DestroyUi(player, MUTE_MENU_PARENT);
                                    ChatSettingUser[target.userID].MuteVoiceTime = 0;
                                    ReplyBroadcast(string.Format(lang.GetMessage("FUNC_MESSAGE_UNMUTE_VOICE", this), player.displayName,target.displayName));
                                    break;
                                }
                        }
                        break;
                    }
                case "admin_voice":
                    {
                        var Command = arg.Args[1];
                        switch(Command)
                        {
                            case "mutevoice":
                                {
                                    AdminSetting.MuteVoiceAll = true;
                                    BasePlayer.activePlayerList.ForEach(p => ChatSettingUser[p.userID].MuteVoiceTime = CurrentTime() + 86400);
                                    ReplyBroadcast(lang.GetMessage("FUNC_MESSAGE_MUTE_ALL_VOICE", this, player.UserIDString));
                                    break;
                                }
                            case "unmutevoice":
                                {
                                    AdminSetting.MuteVoiceAll = false;
                                    BasePlayer.activePlayerList.ForEach(p => ChatSettingUser[p.userID].MuteVoiceTime = 0);
                                    ReplyBroadcast(lang.GetMessage("FUNC_MESSAGE_UNMUTE_ALL_VOICE", this, player.UserIDString));
                                    break;
                                }
                        }
                        BasePlayer.activePlayerList.ForEach(p => { rust.RunServerCommand(Command, p.userID); });
                        break;
                    }
                case "admin_chat":
                    {
                        var Command = arg.Args[1];
                        switch(Command)
                        {
                            case "mutechat":
                                {
                                    AdminSetting.MuteChatAll = true;
                                    BasePlayer.activePlayerList.ForEach(p => MuteAllChatPlayer(p));
                                    ReplyBroadcast(lang.GetMessage("FUNC_MESSAGE_MUTE_ALL_CHAT", this, player.UserIDString));
                                    break;
                                }
                            case "unmutechat":
                                {
                                    AdminSetting.MuteChatAll = false;
                                    BasePlayer.activePlayerList.ForEach(p => ChatSettingUser[p.userID].MuteChatTime = 0);
                                    ReplyBroadcast(lang.GetMessage("FUNC_MESSAGE_UNMUTE_ALL_CHAT", this, player.UserIDString));
                                    break;
                                }
                        }
                        break;
                    }
            }
        }

        #endregion

        #region Lang
        private new void LoadDefaultMessages()
        {
            PrintWarning("Языковой файл загружается...");
            Dictionary<string, string> Lang = new Dictionary<string, string>
            {
                ["TITLE_ONE"] = "<size=20><b>Hастройка чата</b></size>",
                ["TITLE_TWO"] = "<size=12><b>Bыберите действие</b></size>",
                ["UI_CLOSE_BTN"] = "<size=20><b>Закрыть</b></size>",

                ["UI_TEXT_PREFIX"] = "<size=13><b>Hастройка префикса</b></size>",
                ["UI_TEXT_COLOR_NICK"] = "<size=13><b>Hастройка цвета ника</b></size>",
                ["UI_TEXT_COLOR_MSG"] = "<size=13><b>Hастройка цвета чата</b></size>",
                ["UI_TEXT_GO_SETTINGS"] = "<size=14><b>Перейти к настройкам</b></size>",

                ["UI_TEXT_ADMIN_PANEL"] = "<size=18><b>Панель Aдминистратора</b></size>",
                ["UI_TEXT_ADMIN_PANEL_MUTE_CHAT_ALL"] = "<size=14><b>3аблокировать всем чат</b></size>",
                ["UI_TEXT_ADMIN_PANEL_UNMUTE_CHAT_ALL"] = "<size=14><b>Разблокировать всем чат</b></size>",
                ["UI_TEXT_ADMIN_PANEL_MUTE_VOICE_ALL"] = "<size=14><b>3аблокировать всем голос</b></size>",
                ["UI_TEXT_ADMIN_PANEL_UNMUTE_VOICE_ALL"] = "<size=14><b>Разблокировать всем голос</b></size>",

                ["UI_TITLE_NEW_PREFIX_ELEMENT"] = "<size=16><b>Ваши доступные префексы</b></size>",
                ["UI_TITLE_NEW_NICK_COLOR_ELEMENT"] = "<size=16><b>Ваш доступные цвета для ника</b></size>",
                ["UI_TITLE_NEW_MESSAGE_COLOR_ELEMENT"] = "<size=16><b>Ваш доступные цвета для сообщений</b></size>",

                ["FUNC_MESSAGE_MUTE_CHAT"] = "{0} заблокировал чат игроку {1} на {2}\nПричина : {3}",
                ["FUNC_MESSAGE_UNMUTE_CHAT"] = "{0} разблокировал чат игроку {1}",
                ["FUNC_MESSAGE_MUTE_VOICE"] = "{0} заблокировал голос игроку {1} на {2}\nПричина : {3}",
                ["FUNC_MESSAGE_UNMUTE_VOICE"] = "{0} разблокировал голос игроку {1}",
                ["FUNC_MESSAGE_MUTE_ALL_CHAT"] = "Всем игрокам был заблокирован чат",
                ["FUNC_MESSAGE_UNMUTE_ALL_CHAT"] = "Всем игрокам был разблокирован чат",
                ["FUNC_MESSAGE_MUTE_ALL_VOICE"] = "Всем игрокам был заблокирован голос",
                ["FUNC_MESSAGE_UNMUTE_ALL_VOICE"] = "Всем игрокам был разблокирован голос",

                ["FUNC_MESSAGE_ISMUTED_TRUE"] = "Вы не можете отправлять сообщения еще {0}\nВаш чат заблокирован",
                ["FUNC_MESSAGE_NO_ARG_BROADCAST"] = "Вы не можете отправлять пустое сообщение в оповещение!",

                ["UI_MUTE_PANEL_TITLE"] = "<size=24><b>Панель управления блокировками чата</b></size>",
                ["UI_MUTE_PANEL_TITLE_ACTION"] = "<size=16><b>Выберите игрока или введите ник в поиске</b></size>",
                ["UI_MUTE_PANEL_TITLE_PLIST"] = "<size=18><b>Список игроков</b></size>",
                ["UI_MUTE_PANEL_TITLE_HELPS_GREEN"] = "<size=13><b>- У игрока разблокирован чат или голос</b></size>",
                ["UI_MUTE_PANEL_TITLE_HELPS_RED"] = "<size=13><b>- У игрока заблокирован чат или голос</b></size>",

                ["UI_MUTE_TAKE_ACTION_PANEL"] = "<size=20><b>Bыберите действие</b></size>",
                ["UI_MUTE_TAKE_ACTION_CHAT"] = "<size=15><b>3аблокировать чат</b></size>",
                ["UI_MUTE_TAKE_ACTION_CHAT_UNMUTE"] = "<size=15><b>Разблокировать чат</b></size>",
                ["UI_MUTE_TAKE_ACTION_VOICE"] = "<size=15><b>3аблокировать голос</b></size>",
                ["UI_MUTE_TAKE_ACTION_VOICE_UNMUTE"] = "<size=15><b>Разблокировать голос</b></size>",

                ["UI_MUTE_TAKE_REASON_TITLE"] = "<size=17><b>Bыберите причину</b></size>",

                ["COMMAND_NOT_PERMISSION"] = "У вас недостаточно прав для данной команды",
                ["COMMAND_RENAME_NOTARG"] = "Используйте команду так : /rename Новый Ник",
                ["COMMAND_RENAME_SUCCES"] = "Вы успешно изменили ник на {0}",

                ["COMMAND_PM_NOTARG"] = "Используйте команду так : /pm Ник Игрока Сообщение",
                ["COMMAND_PM_NOT_NULL_MSG"] = "Вы не можете отправлять пустое сообщение",
                ["COMMAND_PM_NOT_USER"] = "Игрок не найден или не в сети",
                ["COMMAND_PM_SUCCESS"] = "Ваше сообщение успешно доставлено\nСообщение : {0}",
                ["COMMAND_PM_SEND_MSG"] = "Сообщение от {0}\n{1}",

                ["COMMAND_R_NOTARG"] = "Используйте команду так : /r Сообщение",
                ["COMMAND_R_NOTMSG"] = "Вам или вы ещё не писали игроку в личные сообщения!",

                ["FLOODERS_MESSAGE"] = "Вы пишите слишком быстро! Подождите {0} секунд",

                ["WELCOME_PLAYER"] = "{0} зашел на сервер",
                ["LEAVE_PLAYER"] = "{0} вышел с сервера",
            };

            lang.RegisterMessages(Lang, this);
            PrintWarning("Языковой файл загружен успешно");
        }
        #endregion

        #region Helpers

        public void Log(string LoggedMessage) => LogToFile("IQChatLogs", LoggedMessage, this);

        public static string FormatTime(TimeSpan time, int maxSubstr = 5, string language = "ru")
        {
            string result = string.Empty;
            switch (language)
            {
                case "ru":
                    int i = 0;
                    if (time.Days != 0 && i < maxSubstr)
                    {
                        if (!string.IsNullOrEmpty(result))
                            result += " ";

                        result += $"{Format(time.Days, "дней", "дня", "день")}";
                        i++;
                    }

                    if (time.Hours != 0 && i < maxSubstr)
                    {
                        if (!string.IsNullOrEmpty(result))
                            result += " ";

                        result += $"{Format(time.Hours, "часов", "часа", "час")}";
                        i++;
                    }

                    if (time.Minutes != 0 && i < maxSubstr)
                    {
                        if (!string.IsNullOrEmpty(result))
                            result += " ";

                        result += $"{Format(time.Minutes, "минут", "минуты", "минута")}";
                        i++;
                    }

                    if (time.Seconds != 0 && i < maxSubstr)
                    {
                        if (!string.IsNullOrEmpty(result))
                            result += " ";

                        result += $"{Format(time.Seconds, "секунд", "секунды", "секунда")}";
                        i++;
                    }

                    break;
                case "en":
                    result = string.Format("{0}{1}{2}{3}",
                        time.Duration().Days > 0 ? $"{time.Days:0} day{(time.Days == 1 ? String.Empty : "s")}, " : string.Empty,
                        time.Duration().Hours > 0 ? $"{time.Hours:0} hour{(time.Hours == 1 ? String.Empty : "s")}, " : string.Empty,
                        time.Duration().Minutes > 0 ? $"{time.Minutes:0} minute{(time.Minutes == 1 ? String.Empty : "s")}, " : string.Empty,
                        time.Duration().Seconds > 0 ? $"{time.Seconds:0} second{(time.Seconds == 1 ? String.Empty : "s")}" : string.Empty);

                    if (result.EndsWith(", ")) result = result.Substring(0, result.Length - 2);

                    if (string.IsNullOrEmpty(result)) result = "0 seconds";
                    break;
            }
            return result;
        }

        private BasePlayer FindPlayer(string nameOrId)
        {
            foreach (var check in BasePlayer.activePlayerList)
            {
                if (check.displayName.ToLower().Contains(nameOrId.ToLower()) || check.userID.ToString() == nameOrId)
                    return check;
            }

            return null;
        }
        public static long TimeToSeconds(string time)
        {
            time = time.Replace(" ", "").Replace("d", "d ").Replace("h", "h ").Replace("m", "m ").Replace("s", "s ").TrimEnd(' ');
            var arr = time.Split(' ');
            long seconds = 0;
            foreach (var s in arr)
            {
                var n = s.Substring(s.Length - 1, 1);
                var t = s.Remove(s.Length - 1, 1);
                int d = int.Parse(t);
                switch (n)
                {
                    case "s":
                        seconds += d;
                        break;
                    case "m":
                        seconds += d * 60;
                        break;
                    case "h":
                        seconds += d * 3600;
                        break;
                    case "d":
                        seconds += d * 86400;
                        break;
                }
            }
            return seconds;
        }

        private static string Format(int units, string form1, string form2, string form3)
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                return $"{units} {form1}";

            if (tmp >= 2 && tmp <= 4)
                return $"{units} {form2}";

            return $"{units} {form3}";
        }

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        public Dictionary<ulong, double> Flooders = new Dictionary<ulong, double>();
        void ReplyChat(Chat.ChatChannel channel, BasePlayer player, string format)
        {
            var MessageSetting = config.MessageSetting;
            if (MessageSetting.AntiSpamActivate)
            {
                if (Flooders.ContainsKey(player.userID))
                {
                    if (Flooders[player.userID] > CurrentTime())
                    {
                        ReplySystem(Chat.ChatChannel.Global, player, string.Format(lang.GetMessage("FLOODERS_MESSAGE", this, player.UserIDString), Convert.ToInt32(Flooders[player.userID] - CurrentTime())));
                        Flooders[player.userID] = MessageSetting.FloodTime + CurrentTime();
                        return;
                    }
                }
                else Flooders.Add(player.userID, CurrentTime() + MessageSetting.FloodTime);

                Flooders[player.userID] = MessageSetting.FloodTime + CurrentTime();
            }

            if (channel == Chat.ChatChannel.Global)
            {
                BasePlayer.activePlayerList.ForEach(p => p.SendConsoleCommand("chat.add", channel, player.userID, format));
                PrintToConsole(format);
            }
            if (channel == Chat.ChatChannel.Team)
            {
                RelationshipManager.PlayerTeam Team = RelationshipManager.Instance.FindTeam(player.currentTeam);
                if (Team == null) return;
                foreach (var FindPlayers in Team.members)
                {
                    BasePlayer TeamPlayer = BasePlayer.FindByID(FindPlayers);
                    if (TeamPlayer == null) return;
                        TeamPlayer.SendConsoleCommand("chat.add", channel, player.userID, format);
                }
            }
        }

        void ReplySystem(Chat.ChatChannel channel, BasePlayer player, string Message,string CustomPrefix = "", string CustomAvatar = "")
        {
            string Prefix = string.IsNullOrEmpty(CustomPrefix) ? config.MessageSetting.BroadcastTitle : CustomPrefix;
            ulong Avatar = string.IsNullOrEmpty(CustomAvatar) ? config.MessageSetting.Steam64IDAvatar : ulong.Parse(CustomAvatar);

            string FormatMessage = $"{Prefix} <color={config.MessageSetting.BroadcastColor}>{Message}</color>";
            if (channel == Chat.ChatChannel.Global)
                player.SendConsoleCommand("chat.add", channel, Avatar, FormatMessage);         
        }

        void ReplyBroadcast(string Message, string CustomPrefix = "", string CustomAvatar = "")
        {
            BasePlayer.activePlayerList.ForEach(p => { ReplySystem(Chat.ChatChannel.Global, p, Message, CustomPrefix, CustomAvatar);  });
        }

        static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        static double CurrentTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;
        #endregion

        #region API

        void API_ALERT(string Message, Chat.ChatChannel channel = Chat.ChatChannel.Global, string CustomPrefix = "", string CustomAvatar = "") => BasePlayer.activePlayerList.ForEach(p => { ReplySystem(channel, p, Message, CustomPrefix, CustomAvatar); });
        void API_ALERT_PLAYER(BasePlayer player,string Message, string CustomPrefix = "", string CustomAvatar = "") => ReplySystem(Chat.ChatChannel.Global, player, Message, CustomPrefix, CustomAvatar);
        bool API_CHECK_MUTE_CHAT(ulong ID)
        {
            var DataPlayer = ChatSettingUser[ID];
            if (DataPlayer.MuteChatTime > CurrentTime())
                return true;
            else return false;
        }
        bool API_CHECK_VOICE_CHAT(ulong ID)
        {
            var DataPlayer = ChatSettingUser[ID];
            if (DataPlayer.MuteVoiceTime > CurrentTime())
                return true;
            else return false;
        }
        string API_GET_PREFIX(ulong ID)
        {
            var DataPlayer = ChatSettingUser[ID];
            return DataPlayer.ChatPrefix;
        }
        string API_GET_CHAT_COLOR(ulong ID)
        {
            var DataPlayer = ChatSettingUser[ID];
            return DataPlayer.MessageColor;
        }
        string API_GET_NICK_COLOR(ulong ID)
        {
            var DataPlayer = ChatSettingUser[ID];
            return DataPlayer.NickColor;
        }
        #endregion
    }
}


// --- End of file: IQChat.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/InstantCraft.cs ---
// --- Original Local Path: InstantCraft.cs ---

using Newtonsoft.Json;
using System.Collections.Generic;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Instant Craft", "Orange", "2.1.5")]
    [Description("Allows players to instantly craft items with features")]
    public class InstantCraft : RustPlugin
    {
        #region Vars

        private const string permUse = "instantcraft.use";

        #endregion
        
        #region Oxide Hooks

        private void Init()
        {
            permission.RegisterPermission(permUse, this);
        }
        
        private object OnItemCraft(ItemCraftTask item)
        {
            return OnCraft(item);
        }

        #endregion

        #region Core

        private object OnCraft(ItemCraftTask task)
        {
            if (task.cancelled == true)
            {
                return null;
            }
            
            var player = task.owner;
            var target = task.blueprint.targetItem;
            var targetName = target.shortname;

            if (targetName.Contains("key"))
            {
                return null;
            }
            
            if (permission.UserHasPermission(player.UserIDString, permUse) == false)
            {
                return null;
            }

            if (IsBlocked(targetName))
            {
                task.cancelled = true;
                Message(player, "Blocked");
                GiveRefund(player, task.takenItems);
                return null;
            }

            var stacks = GetStacks(target, task.amount * task.blueprint.amountToCreate);
            var slots = FreeSlots(player);

            if (HasPlace(slots, stacks) == false)
            {
                task.cancelled = true;
                Message(player, "Slots", stacks.Count, slots);
                GiveRefund(player, task.takenItems);
                return null;
            }
            
            if (IsNormalItem(targetName))
            {
                Message(player, "Normal");
                return null;
            }
            
            GiveItem(player, task, target, stacks, task.skinID);
            task.cancelled = true;
            return null;
        }

        private void GiveItem(BasePlayer player, ItemCraftTask task, ItemDefinition def, List<int> stacks, int taskSkinID)
        {
            var skin = ItemDefinition.FindSkin(def.itemid, taskSkinID);
            
            if (config.split == false)
            {
                var final = 0;

                foreach (var stack in stacks)
                {
                    final += stack;
                }
                
                var item = ItemManager.Create(def, final, skin);
                player.GiveItem(item);
                Interface.CallHook("OnItemCraftFinished", task, item);
            }
            else
            {
                foreach (var stack in stacks)
                {
                    var item = ItemManager.Create(def, stack, skin);
                    player.GiveItem(item);
                    Interface.CallHook("OnItemCraftFinished", task, item);
                }
            }
        }

        private int FreeSlots(BasePlayer player)
        {
            var slots = player.inventory.containerMain.capacity + player.inventory.containerBelt.capacity;
            var taken = player.inventory.containerMain.itemList.Count + player.inventory.containerBelt.itemList.Count;
            return slots - taken;
        }

        private void GiveRefund(BasePlayer player, List<Item> items)
        {
            foreach (var item in items)
            {
                player.GiveItem(item);
            }
        }

        private List<int> GetStacks(ItemDefinition item, int amount) 
        {
            var list = new List<int>();
            var maxStack = item.stackable;

            if (maxStack == 0)
            {
                maxStack = 1;
            }

            while (amount > maxStack)
            {
                amount -= maxStack;
                list.Add(maxStack);
            }
            
            list.Add(amount);
            
            return list; 
        }

        private bool IsNormalItem(string name)
        {
            return config.normal?.Contains(name) ?? false;
        }

        private bool IsBlocked(string name)
        {
            return config.blocked?.Contains(name) ?? false;
        }

        private bool HasPlace(int slots, List<int> stacks)
        {
            if (config.checkPlace == false)
            {
                return true;
            }

            if (config.split && slots - stacks.Count < 0)
            {
                return false;
            }

            return slots > 0;
        }

        #endregion

        #region Localization 1.1.1
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Blocked", "Crafting of that item is blocked!"},
                {"Slots", "You don't have enough place to craft! Need {0}, have {1}!"},
                {"Normal", "Item will be crafted with normal speed."}
            }, this);
        }

        private void Message(BasePlayer player, string messageKey, params object[] args)
        {
            if (player == null)
            {
                return;
            }

            var message = GetMessage(messageKey, player.UserIDString, args);
            player.ChatMessage(message);
        }

        private string GetMessage(string messageKey, string playerID, params object[] args)
        {
            return string.Format(lang.GetMessage(messageKey, this, playerID), args);
        }

        #endregion
        
        #region Configuration 1.1.0

        private static ConfigData config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Check for free place")]
            public bool checkPlace = false;
            
            [JsonProperty(PropertyName = "Split crafted stacks")]
            public bool split = false;
            
            [JsonProperty(PropertyName = "Normal Speed")]
            public string[] normal =
            {
                "hammer",
                "put item shortname here"
            };

            [JsonProperty(PropertyName = "Blacklist")]
            public string[] blocked =
            {
                "rock",
                "put item shortname here"
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintError("Configuration file is corrupt! Unloading plugin...");
                Interface.Oxide.RootPluginManager.RemovePlugin(this);
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
    }
}

// --- End of file: InstantCraft.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XPSync.cs ---
// --- Original Local Path: XPSync.cs ---

using Oxide.Core.Database;
using Oxide.Core;
using Oxide.Ext.MySql;

namespace Oxide.Plugins
{
    [Info("XP Sync", "PaiN", 0.2, ResourceId = 2072)]
    class XPSync : RustPlugin
    {
        public static readonly Oxide.Ext.MySql.Libraries.MySql _mySql = Interface.Oxide.GetLibrary<Oxide.Ext.MySql.Libraries.MySql>();
        public static Connection _mySqlConnection;

        ConfigFile Cfg = new ConfigFile();

        class ConfigFile
        {
            public string Host = "localhost";
            public int Port = 3306;
            public string Database = "databasename";
            public string User = "root";
            public string Password = "";
        }

        void Loaded()
        {
            Cfg = Config.ReadObject<ConfigFile>();

            _mySqlConnection = _mySql.OpenDb(Cfg.Host, Cfg.Port, Cfg.Database, Cfg.User, Cfg.Password, this);
            if (_mySqlConnection == null)
            {
                Puts("Can't connect to the database!");
                return;
            }

            var sql = Sql.Builder.Append(@"CREATE TABLE IF NOT EXISTS xpsync (
                                 id BIGINT(32),
                                 xp FLOAT
                               );");

            _mySql.ExecuteNonQuery(sql, _mySqlConnection);
        }

        void Unloaded() => _mySql.CloseDb(_mySqlConnection);
        protected override void LoadDefaultConfig() { PrintWarning("Creating a new configuration file . . ."); Config.WriteObject(Cfg, true); }

        void OnPlayerDisconnected(BasePlayer player)
        {
            if (_mySqlConnection == null)
            {
                Puts("Can't connect to the database to save player's xp!");
                return;
            }

            var agent = BasePlayer.FindXpAgent(player.userID);

            if (agent.EarnedXp == 0)
                return;

            var sql = Sql.Builder.Append($"SELECT * FROM xpsync WHERE id={player.userID};");

            _mySql.Query(sql, _mySqlConnection, list =>
            {
                if (list.Count == 0)
                {
                    _mySql.Query(Sql.Builder.Append($"INSERT INTO xpsync (`id`, `xp`) VALUES ('{player.userID}', '{agent.EarnedXp}');"), _mySqlConnection, callback => { });
                }
                else
                {
                    if (agent.EarnedXp < System.Convert.ToSingle(list[0]["xp"]))
                        return;

                    _mySql.Query(Sql.Builder.Append($"UPDATE xpsync SET xp={agent.EarnedXp} WHERE  id={player.userID};"), _mySqlConnection, callback => { });
                }
            });
        }

        void OnPlayerInit(BasePlayer player)
        {
            if (_mySqlConnection == null)
            {
                Puts("Can't connect to the database to load player's xp!");
                return;
            }

            _mySql.Query(Sql.Builder.Append($"SELECT * FROM xpsync WHERE id={player.userID};"), _mySqlConnection, list =>
            {
                if (list.Count == 0)
                    return;

                if (BasePlayer.FindXpAgent(player.userID).EarnedXp >= System.Convert.ToSingle(list[0]["xp"]))
                    return;

                player.xp.Reset();
                player.xp.Add(Rust.Xp.Definitions.Cheat, System.Convert.ToSingle(list[0]["xp"]));
            });
        }
    }
}

// --- End of file: XPSync.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NoEscape.cs ---
// --- Original Local Path: NoEscape.cs ---

using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("NoEscape", "Hougan", "0.1.4")]
    public class NoEscape : RustPlugin
    {
        private static string Layer = "UI_NoEscapeLayer";
        private static List<Blocker> BlockerList = new List<Blocker>();
        
        #region Class

        private class PlayerBlocked : MonoBehaviour
        {
            private BasePlayer Player;
            public Blocker CurrentBlocker;
            private float LastUpdate = 0f;

            private void Awake()
            {
                Player = GetComponent<BasePlayer>(); 
            }
 
            private void Update()
            {
                LastUpdate += Time.deltaTime;
                if (LastUpdate > 1)
                {
                    LastUpdate = 0f;
                    ControllerUpdate();
                }
            }

            private void ControllerUpdate()
            {
                if (CurrentBlocker == null)
                {
                    UnblockPlayer(); 
                    if (Settings.BlockSettings.ShouldBlockEnter)
                    {
                        var blocker = BlockerList.FirstOrDefault(p => p.IsInBlocker(Player));
                        if (!blocker) return;
                    
                        BlockPlayer(blocker); 
                    }
                }
                else
                {
                    UpdateUI();
                }
            }

            private void BlockPlayer(Blocker blocker, bool justCreated = false)
            {
                CurrentBlocker = blocker;
            
                CuiElementContainer container = new CuiElementContainer();
                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    RectTransform = { AnchorMin = "0.3447913 0.112037", AnchorMax = "0.640625 0.1398148", OffsetMax = "0 0" },
                    Image = { Color = "0.968627453 0.921568632 0.882352948 0.03529412" }
                }, "Hud", Layer);
            
                CuiHelper.AddUi(Player, container);
                UpdateUI();
            }
              
            private const string UpdateLayer = "UI_MagicLayerUpdate";

            public void UpdateUI() 
            {
                CuiHelper.DestroyUi(Player, UpdateLayer);
                CuiHelper.DestroyUi(Player, Layer + ".Info");

                CuiElementContainer container = new CuiElementContainer();
            
                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Name = UpdateLayer, 
                    Components =
                    {//0.441568628 0.609607848 0.327451 1
                        new CuiImageComponent { Color = Settings.NotificationSettings.InterfaceColor },
                        new CuiRectTransformComponent {AnchorMin = $"0 0", AnchorMax = $"{(float) (CurrentBlocker.CurrentTime / CurrentBlocker.TotalTime)} 1", OffsetMin = "1 1", OffsetMax = "-2 -1"},
                    }
                });
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Text = { Text = $"БЛОКИРОВКА: {(CurrentBlocker.TotalTime - CurrentBlocker.CurrentTime + 1):F0} СЕК", Font = "robotocondensed-regular.ttf", Color = "0.8 0.8 0.8 0.9", FontSize = 16, Align = TextAnchor.MiddleCenter }
                }, Layer, Layer + ".Info"); 
                
                CuiHelper.AddUi(Player, container);
            }

            private void UnblockPlayer()
            {
                CuiHelper.DestroyUi(Player, Layer);
            }

            private void OnDestroy() => UnblockPlayer();
        }

        private class Blocker : MonoBehaviour
        {
            public double CurrentTime = 0;
            public double TotalTime = Settings.BlockSettings.BlockLength;
            
            public BuildingPrivlidge Cupboard;
            public BaseEntity Alarm;
            public BaseEntity Light;

            public void Awake()
            {
                Cupboard = GetComponent<BuildingPrivlidge>();

                if (Settings.BlockSettings.CreateAlarm)
                {
                    Alarm = GameManager.server.CreateEntity("assets/prefabs/deployable/playerioents/alarms/audioalarm.prefab", Cupboard.transform.position, default(Quaternion), true);
                     
                    Alarm.Spawn();
                    
                    Alarm.SetFlag(BaseEntity.Flags.Reserved8, true);
                }
                if (Settings.BlockSettings.CreateLighter)
                {
                    Light = GameManager.server.CreateEntity("assets/prefabs/deployable/playerioents/lights/sirenlight/electric.sirenlight.deployed.prefab", Cupboard.transform.position, Quaternion.identity, false);
                
                    
                    Light.enableSaving = true;
                    Light.Spawn();
                    Light.SetParent(Cupboard);
                    Light.transform.localPosition = new Vector3(0, 1.7f, 0);
                    Light.transform.hasChanged = true;
                    Light.SendNetworkUpdate(); 
                    
                    Light.SetFlag(BaseEntity.Flags.Reserved8, true);
                }

                NotifyOwners(Cupboard);
            }

            public void Update()
            {
                CurrentTime += Time.deltaTime;
                if (CurrentTime > TotalTime)
                {
                    if (BlockerList.Contains(this)) 
                        BlockerList.Remove(this);
                    
                    UnityEngine.Object.Destroy(this);
                }
            }

            public void OnDestroy()
            {
                if (Settings.BlockSettings.CreateAlarm)
                {
                    Alarm?.Kill();
                }
                if (Settings.BlockSettings.CreateLighter)
                {
                    Light?.Kill();
                }

                if (BlockerList.Contains(this)) 
                    BlockerList.Remove(this);
            }
            
            public bool IsOwner(ulong userId) => Cupboard.authorizedPlayers.FirstOrDefault(p => p.userid == userId) != null;
            public bool IsInBlocker(BasePlayer player) => Vector3.Distance(player.transform.position, Cupboard.transform.position) < Settings.BlockSettings.BlockerDistance;
        }
        
        #endregion


        private void OnPlayerInit(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerInit(player));
                return;
            }
            
            if (player.GetComponent<PlayerBlocked>() == null)
                player.gameObject.AddComponent<PlayerBlocked>();

            if (player.GetComponent<PlayerBlocked>().CurrentBlocker != null)
            {
                CuiElementContainer container = new CuiElementContainer();
                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    RectTransform = { AnchorMin = "0.3447913 0.112037", AnchorMax = "0.640625 0.1398148", OffsetMax = "0 0" },
                    Image = { Color = "0.968627453 0.921568632 0.882352948 0.03529412" }
                }, "Hud", Layer);
            
                CuiHelper.AddUi(player, container);
            }
        }
 
        private void Unload()
        {
            UnityEngine.Object.FindObjectsOfType<PlayerBlocked>().ToList().ForEach(UnityEngine.Object.Destroy);
            UnityEngine.Object.FindObjectsOfType<Blocker>().ToList().ForEach(UnityEngine.Object.Destroy);
        }

        private class Configuration
        {
            internal class BlockSetting
            {
                internal class BlockLimit
                {
                    [JsonProperty("Можно ли строить? (фундаменты, стены (из соломы))")] 
                    public bool CanBuild = true;
                    [JsonProperty("Можно ли размещать объекты? (спальники, двери и т.д.)")]
                    public bool CanPlaceObjects = true; 
                    [JsonProperty("Можно ли чинить объекты (фундаменты, двери и т.д.)")]
                    public bool CanRepair = false;
                    [JsonProperty("Можно ли улучшать объекты (фундаменты, стены и т.д.)")]
                    public bool CanUpgrade = false;
                    [JsonProperty("Список запрещенных для использования команд")]
                    public List<string> BlockedCommands = new List<string>();
                }
                
                [JsonProperty("Дистанция действия блокировки (в метрах)")]
                public float BlockerDistance = 150;
                [JsonProperty("Время блокировки в секундах")]
                public float BlockLength = 150;
                [JsonProperty("Создавать сигнальный фонарь при рейде")]
                public bool CreateLighter = true;
                [JsonProperty("Создавать звуковое оповещение при рейде (колонка)")]
                public bool CreateAlarm = true;
                [JsonProperty("Блокировать хозяев построек, даже если они вне зоны рейда")]
                public bool BlockOwnersIfNotInZone = false;
                [JsonProperty("Блокировать игрока, который вошёл в активную зону блокировки")]
                public bool ShouldBlockEnter = true;
                [JsonProperty("Пускать игроков без очереди, если игрока рейдят")]
                public bool ShouldByPassQueue = true;
                [JsonProperty("Разрешить игрокам ломать шкаф (сразу после разрушения шкафа рейд-блок спадёт)")]
                public bool CanDestroyCupBoard = false;
                
                [JsonProperty("Настройки ограничений игроков в рейд-блоке")]
                public BlockLimit BlockLimits = new BlockLimit();
            }

            internal class NotificationSetting
            {
                [JsonProperty("Цвет полосы в интерфейсе у РБ игроков")]
                public string InterfaceColor = "0.121568628 0.419607848 0.627451 0.784313738";
                [JsonProperty("Привилегия, игроки с которой могут установить оповещение о рейде")]
                public string PermissionToInstall = "NoEscape.Install";
                [JsonProperty("Текст уведомления о рейде для отправки")]
                public string NotificationText = "Ваша постройка подверглась нападению!\n" +
                                                 "Скорее заходите и защитесь!";
            }
            
            [JsonProperty("Настройка работы блокировки")]
            public BlockSetting BlockSettings = new BlockSetting();
            [JsonProperty("Настройка оповещения о рейде")]
            public NotificationSetting NotificationSettings = new NotificationSetting();

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    BlockSettings = new BlockSetting
                    {
                        BlockLimits = new BlockSetting.BlockLimit
                        {
                            BlockedCommands = new List<string>
                            {
                                "/shop",
                                "/s",
                                "/chat",
                                "god",
                                "backpack.open" 
                            }
                        }
                    }
                };
            }
        }

        #region Variables
        
        private static Configuration Settings = new Configuration();
        
        #endregion
        
        #region Hooks
        
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                Settings = Config.ReadObject<Configuration>();
                if (Settings?.BlockSettings == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }
            
            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => Settings = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(Settings);

        private bool? OnServerCommand(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null) return null;
            if (!args.HasArgs(1)) return null;

            if (!IsBlocked(player)) return null;
            
            foreach (var check in Settings.BlockSettings.BlockLimits.BlockedCommands)
            {
                if (args.Args[0].ToLower().Contains(check.ToLower())) 
                {
                    player.ChatMessage("Вам запрещено использовать эту команду во время РБ!");
                    return false;
                }
            }

            return null;
        }
        
        private bool? OnPlayerCommand(ConsoleSystem.Arg args, BasePlayer player)
        {
            if (!args.HasArgs(1)) return null;

            BasePlayer initiator = args.Player();
            if (initiator == null) return null; 
            
            if (!IsBlocked(initiator)) return null;
            string cmd = args.Args[0];

            if (Settings.BlockSettings.BlockLimits.BlockedCommands.Contains(cmd.ToLower()))  
            {
                initiator.ChatMessage("Вам запрещено использовать эту команду во время РБ!");
                return false;
            }

            return null;
        }
        
        private string CupLayer = "UI_CupLayer";
        private void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            if (!(entity is BuildingPrivlidge)) return;
            if (!VKBot) return;
            
            CuiHelper.DestroyUi(player, CupLayer);
            CuiElementContainer container = new CuiElementContainer();
            
            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "192 491", OffsetMax = "573 556" },
                Image = { Color = "0 0 0 0" }
            }, "Overlay", CupLayer);

            bool isOn = entity.HasFlag(BaseEntity.Flags.Reserved4);
            string text = isOn ? "ОПОВЕЩЕНИЯ АКТИВИРОВНЫ" : "ОПОВЕЩЕНИЯ ОТКЛЮЧЕНЫ";
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = isOn ? "0.5 0.6 0.5 1" : "0.7 0.5 0.5 1", Command = "UI_NoEscape switch" },
                Text = { Text = "", Align  = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 24 }
            }, CupLayer);

            if (!permission.UserHasPermission(player.UserIDString, Settings.NotificationSettings.PermissionToInstall) && !isOn)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0.15", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Button = { Color = isOn ? "0.501486 0.606000789 0.504524 0" : "0.70465 0.50488 0.50655 0", Command = "UI_NoEscape switch" },
                    Text = { Text = isOn ? "ОПОВЕЩЕНИЯ АКТИВИРОВНЫ" : "ОПОВЕЩЕНИЯ ОТКЛЮЧЕНЫ", Align  = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 24 }
                }, CupLayer);
                
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.55", OffsetMax = "0 0" },
                    Button = { Color = isOn ? "0.501486 0.606000789 0.504524 0" : "0.70465 0.50488 0.50655 0", Command = "UI_NoEscape switch" },
                    Text = { Text = "У вас нет доступа к активации оповещений о рейде", Align  = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 12 }
                }, CupLayer);
            } 
            else
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Button = { Color = isOn ? "0.501486 0.606000789 0.504524 0" : "0.70465 0.50488 0.50655 0", Command = "UI_NoEscape switch" },
                    Text = { Text = isOn ? "ОПОВЕЩЕНИЯ АКТИВИРОВНЫ" : "ОПОВЕЩЕНИЯ ОТКЛЮЧЕНЫ", Align  = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 24 }
                }, CupLayer);
            }
            
            CuiHelper.AddUi(player, container); 
        }

        [ConsoleCommand("UI_NoEscape")]
        private void CmdConsoleHandler(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (!args.HasArgs(1) || player == null) return;
            switch (args.Args[0].ToLower())
            {
                case "switch":
                {
                    if (!permission.UserHasPermission(player.UserIDString, Settings.NotificationSettings.PermissionToInstall)) return;
                    string receiver = (string) instance.VKBot.Call("GetUserVKId", player.userID);
                    if (string.IsNullOrEmpty(receiver))
                    {
                        player.ChatMessage($"У вас не подтвержден профиль ВК! Используйте VKBot чтобы сделать это!");
                        return;
                    }
                    
                    var loot = player.inventory.loot.entitySource;
                    if (loot != null && loot is BuildingPrivlidge)
                        loot.SetFlag(BaseEntity.Flags.Reserved4, !loot.HasFlag(BaseEntity.Flags.Reserved4));
                    
                    OnLootEntity(player, loot);
                    break;
                }
            }
        }
        
        private void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity) => CuiHelper.DestroyUi(player, CupLayer);
        
        private bool? OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity is BuildingPrivlidge && entity.GetComponent<Blocker>())
            {
                if (info?.InitiatorPlayer != null) info?.InitiatorPlayer.ChatMessage($"Вы не можете разрушить шкаф во время блокировки!");
                info?.damageTypes.ScaleAll(0);
                return false;
            }
            return null;
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (!(entity is StabilityEntity)) return;
            if (entity.GetBuildingPrivilege() == null) return;
            if (entity is BuildingBlock && (entity as BuildingBlock).currentGrade.gradeBase.type == BuildingGrade.Enum.Twigs) return;
            var owner = info?.InitiatorPlayer;
            if (owner != null && owner.IsBuildingAuthed()) return;
            if (info?.damageTypes.GetMajorityDamageType() == DamageType.Decay) return;
            
            var buildingPrivlidge = entity.GetBuildingPrivilege();

            var alreadyBlock = BlockerList.FirstOrDefault(p => p.Cupboard == buildingPrivlidge);
            if (alreadyBlock) alreadyBlock.CurrentTime = 0;
            else
            {
                var block = buildingPrivlidge.gameObject.AddComponent<Blocker>();
                BlockerList.Add(block);
            }
        }
        private bool? CanBypassQueue(Network.Connection connection) => BlockerList.FirstOrDefault(p => p.IsOwner(connection.userid));
        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            BasePlayer player = plan.GetOwnerPlayer(); 
            BaseEntity entity = go.ToBaseEntity();
            
            if (entity is BuildingPrivlidge && !permission.UserHasPermission(player.UserIDString, Settings.NotificationSettings.PermissionToInstall))
                entity.SetFlag(BaseEntity.Flags.Reserved4, false);
            
            if (player == null || !IsRaidBlocked(player)) return;

            bool shouldDestroy = false;
            if (!Settings.BlockSettings.BlockLimits.CanBuild && entity is StabilityEntity) shouldDestroy = true;
            else if (!Settings.BlockSettings.BlockLimits.CanPlaceObjects && entity is DecayEntity) shouldDestroy = true;
            else return;

            if (shouldDestroy)
            {
                if (entity is BuildingBlock)
                {
                    (entity as StabilityEntity).BuildCost().ForEach(p =>
                    {
                        var item = ItemManager.Create(p.itemDef, (int) p.amount);
                        if (!player.inventory.GiveItem(item)) item.Drop(player.transform.position, Vector3.down);
                    });
                }
                else if (entity is DecayEntity)
                {
                    var item = ItemManager.GetItemDefinitions().FirstOrDefault(p => p.GetComponent<ItemModDeployable>()?.entityPrefab.resourcePath == entity.PrefabName);
                    if (item == null) return;

                    if (!player.inventory.GiveItem(ItemManager.Create(item)))
                        ItemManager.Create(item).Drop(player.transform.position, Vector3.down);
                }
            
                player.ChatMessage($"Вам запрещено совершать это действие во время РБ!");
                entity.Kill();
            }
        }
        
        private bool? CanAffordUpgrade(BasePlayer player, BuildingBlock block, BuildingGrade.Enum grade)
        {
            if (!IsRaidBlocked(player)) return null;
            
            player.ChatMessage($"Вам запрещено улучшать объекты во время РБ!"); 
            return false;
        }
        
        private bool? OnStructureRepair(BaseCombatEntity entity, BasePlayer player)
        {
            if (!IsRaidBlocked(player)) return null;

            player.ChatMessage($"Вам запрещено чинить объекты во время РБ!"); 
            return false;
        }
        
        #endregion

        #region Functions

        [PluginReference] private Plugin VKBot;
        private static void NotifyOwners(BuildingPrivlidge building)
        {
            foreach (var check in building.authorizedPlayers)
            {
                string receiver = (string) instance.VKBot?.Call("GetUserVKId", check.userid) ?? "";
                if (string.IsNullOrEmpty(receiver)) continue;

                instance.VKBot?.Call("SendVkMessage", receiver, Settings.NotificationSettings.NotificationText);
            }   
        }

        #endregion

        private static NoEscape instance; 
        private void OnServerInitialized()
        {
            instance = this;
            timer.Once(1, () =>
            {
                BasePlayer.activePlayerList.ForEach(OnPlayerInit);
                PrintError("NoEscape initialized (HOUGAN)");
            });
            
            permission.RegisterPermission(Settings.NotificationSettings.PermissionToInstall, this);
            
            if (Settings.BlockSettings.CanDestroyCupBoard) Unsubscribe(nameof(OnEntityTakeDamage));
            if (Settings.BlockSettings.BlockLimits.CanRepair) Unsubscribe(nameof(OnStructureRepair));
            if (Settings.BlockSettings.BlockLimits.CanUpgrade) Unsubscribe(nameof(CanAffordUpgrade));
            if (!Settings.BlockSettings.ShouldByPassQueue) Unsubscribe(nameof(CanBypassQueue));
        }


        #region API

        private bool IsBlocked(BasePlayer player) => IsRaidBlocked(player);
        private bool IsRaidBlock(ulong userId) => IsRaidBlocked(userId.ToString());
        private bool IsRaidBlocked(BasePlayer player) => player.GetComponent<PlayerBlocked>()?.CurrentBlocker != null;
        private bool IsRaidBlocked(string player)
        {
            BasePlayer target = BasePlayer.Find(player);
            if (!target || !target.IsConnected) return false;

            return IsRaidBlocked(target);
        }
        private int ApiGetTime(ulong userId)
        {
            if (!IsRaidBlocked(userId.ToString())) return 0;
            var targetBlock = BasePlayer.Find(userId.ToString()).GetComponent<PlayerBlocked>(); 
            return (int) (targetBlock.CurrentBlocker.TotalTime - targetBlock.CurrentBlocker.CurrentTime);
        }

        private string CanTeleport(BasePlayer player)
        {
            if (IsBlocked(player)) return "Вы не можете телепортироваться в зоне рейда!";
            return null;
        }

        private string CanTrade(BasePlayer player)
        {
            if (IsBlocked(player)) return "Вы не можете обмениваться ресурсами во время рейда!";
            return null; 
        }

        #endregion
    }
}

// --- End of file: NoEscape.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PsyArrows.cs ---
// --- Original Local Path: PsyArrows.cs ---

using Oxide.Core;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Linq;
using UnityEngine;
using System.Text;
using Rust;
using Oxide.Core.Libraries;

namespace Oxide.Plugins
{
    [Info("PsyArrows", "Psyk", "0.1", ResourceId = 714)]
    [Description("More Arrow Types For Rust! - By Psyk.")]
    class PsyArrows : RustPlugin
    {
        string arrow_type;
        bool enabled;
        float detonationTime = 5f;
        float projectileSpeed = 90f;
        float gravityModifier = 0f;
        float expRad = 100f;
        int arrow_curr = 374890416;
        int arrow_price = 30;
        bool sticky = true;
        bool highjump = false;
        static System.Random rnd = new System.Random();

        Dictionary<ulong, string> bowmen = new Dictionary<ulong, string>(); // steamid, arrow_type

        int GetAmountItems(BasePlayer player)
        {
            Item item = player.inventory.FindItemID("metal.refined");
            int item_id = item.info.itemid;

            return player.inventory.containerMain.GetAmount(item_id, true);
        }

        void ArrowBleed(BasePlayer player)
        {
            player.health = player.health - rnd.Next(3, 8);
        }


        void OnPlayerAttack(BasePlayer attacker, HitInfo hitInfo)
        {
            if (hitInfo != null && hitInfo.WeaponPrefab.ToString().Contains("hunting") || hitInfo.WeaponPrefab.ToString().Contains("bow") && attacker.IsAdmin())
            {
                /*if (hitInfo.HitEntity.gameObject.name.Contains("player"))
                {*/



                var hitPlayer = hitInfo.HitEntity.ToPlayer();

                // hitPlayer.health = hitPlayer.health - rnd.Next(15, 25);
                // hitPlayer.Hurt(hitPlayer.metabolism.bleeding.@value * 2f, DamageType.Bleeding, null, true);
                //timer.Repeat(3, rnd.Next(1, 5), () => ArrowBleed(hitPlayer));
                //hitPlayer.ChatMessage("<color='red'> You've begun to bleed. :( </color>");
                if (/*attacker.IsAdmin() || attacker.userID == 76561198031895400*/ true)
                    {
                        if (bowmen.TryGetValue(attacker.userID, out arrow_type))
                        {
                            switch (arrow_type)
                            {
                                case "wind":
                                    // Hit a player
                                    var plyX = hitPlayer.transform.position.x;
                                    var plyY = hitPlayer.transform.position.y;
                                    var plyZ = hitPlayer.transform.position.z;
                                    int constant = rnd.Next(4, 5);
                                    var new_vector = new Vector3(plyX + constant, plyY + rnd.Next(5, 8), plyZ + constant);
                                    hitPlayer.MovePosition(new_vector);
                                    attacker.ChatMessage("[<color='lime'>PsyArrow</color>] You hit " + hitPlayer.displayName);
                                    bowmen.Remove(attacker.userID);
                                break;

                                case "fire":
                                    CreateRocket(hitPlayer.transform.position, hitPlayer.transform.position, true);
                                    attacker.ChatMessage("[<color='lime'>PsyArrow</color>] You hit " + hitPlayer.displayName + " Health : " + hitPlayer.health);
                                    bowmen.Remove(attacker.userID);
                                    break;

                                case "explosive":
                                     CreateRocket(hitPlayer.transform.position, hitPlayer.transform.position, false);
                                     bowmen.Remove(attacker.userID);
                                    break;
                                case "knockdown":
                                    attacker.ChatMessage("[<color='lime'>PsyArrow</color>] You knocked " + hitPlayer.displayName + " down! Save him or kill him.");
                                    hitPlayer.StartWounded();
                                    bowmen.Remove(attacker.userID);
                                    break;
                                case "narco":
                                    hitPlayer.StartSleeping();
                                    attacker.ChatMessage("[<color='lime'>PsyArrow</color>] You hit " + hitPlayer.displayName);
                                    attacker.inventory.Take(attacker.inventory.FindItemIDs(arrow_curr), arrow_curr, arrow_price);
                                    bowmen.Remove(attacker.userID);
                                    break;
                                case "poision":
                                    var poisionTimer = timer.Repeat(rnd.Next(1, 3), rnd.Next(5, 10), () => poisionPlayer(hitPlayer));
                                    bowmen.Remove(attacker.userID);
                                    break;
                            }
                        }
                        else
                        {
                            attacker.ChatMessage("<color='red'>PsyArrows</color> Your bow is not drawn! You must select an arrow.");
                        }

                        if (hitInfo.isHeadshot)
                        {
                            // Hit a player
                            var plyX = hitPlayer.transform.position.x;
                            var plyY = hitPlayer.transform.position.y;
                            var plyZ = hitPlayer.transform.position.z;
                            var new_vector = new Vector3(plyX + 1, plyY + rnd.Next(100, 200), plyZ);
                            hitPlayer.MovePosition(new_vector);
                            attacker.ChatMessage("[<color='lime'>PsyArrow</color>] You hit " + hitPlayer.displayName);
                            hitPlayer.health = 1;
                        }
                    }
                    else
                    {
                        if (GetAmountItems(attacker) >= arrow_price)
                        {
                            if (bowmen.TryGetValue(attacker.userID, out arrow_type))
                            {
                                switch (arrow_type)
                                {
                                    case "narco":
                                        hitPlayer.StartSleeping();
                                        attacker.ChatMessage("[<color='lime'>PsyArrow</color>] You hit " + hitPlayer.displayName);
                                        attacker.inventory.Take(attacker.inventory.FindItemIDs(arrow_curr), arrow_curr, arrow_price);
                                        //arrow_type = "normal";
                                        bowmen.Remove(attacker.userID);
                                        break;
                                    case "poision":
                                        var poisionTimer = timer.Repeat(rnd.Next(1, 3), rnd.Next(5, 10), () => poisionPlayer(hitPlayer));
                                        attacker.inventory.Take(attacker.inventory.FindItemIDs(arrow_curr), arrow_curr, arrow_price);
                                        //arrow_type = "normal";
                                        bowmen.Remove(attacker.userID);
                                        break;
                                }
                            }
                            else
                            {
                                attacker.ChatMessage("[<color='red'>PsyArrows]</color> Your bow is not drawn! You must select an arrow.");

                            }
                        }
                        else
                        {
                            attacker.ChatMessage("<color='red'>PsyArrows</color> Sorry, " + attacker.displayName + ", but you require [" + arrow_price + "]" + "["+arrow_curr+"] to fire these arrows.");
                        }

                    }
                /*}
                else
                {
                    if(arrow_type == "normal")
                    {

                    }
                    else
                    {
                        attacker.ChatMessage("[<color='red'>PsyArrow</color>] You have to hit a valid player with this type of arrow!");
                    }
                }*/
            }
        }

        private static readonly FieldInfo ServerInput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));




        private BaseEntity CreateRocket(Vector3 startPoint, Vector3 direction, bool isFireRocket)
        {
            ItemDefinition projectileItem;

            if (isFireRocket)
                projectileItem = GetFireRocket();
            else
                projectileItem = GetRocket();

            ItemModProjectile component = projectileItem.GetComponent<ItemModProjectile>();
            BaseEntity entity = GameManager.server.CreateEntity(component.projectileObject.resourcePath, startPoint, new Quaternion(), true);

            TimedExplosive timedExplosive = entity.GetComponent<TimedExplosive>();
            ServerProjectile serverProjectile = entity.GetComponent<ServerProjectile>();

            serverProjectile.gravityModifier = gravityModifier;
            serverProjectile.speed = projectileSpeed;
            timedExplosive.timerAmountMin = detonationTime;
            timedExplosive.timerAmountMax = detonationTime;
            timedExplosive.explosionRadius = 1000f;
            timedExplosive.canStick = true;

            entity.SendMessage("InitializeVelocity", (object)(direction * 2f));
            entity.Spawn(true);

            return entity;
        }

        private ItemDefinition GetRocket()
        {
            return ItemManager.FindItemDefinition("ammo.rocket.basic");
        }

        private ItemDefinition GetFireRocket()
        {
            return ItemManager.FindItemDefinition("ammo.rocket.fire");
        }

        void poisionPlayer(BasePlayer player)
        {
            player.health = player.health - rnd.Next(2, 4);
            player.ChatMessage("[<color='lime'>PsyArrow : POISION</color>] You've been poisioned! It should wear off soon..");
        }



        string GetVictim(BaseCombatEntity vic)
        {
            string victim = "Unknown Victim";

            if (vic != null)
            {
                if (vic.ToPlayer() != null)
                {
                    victim = vic.ToPlayer().displayName; // Get Name of the Victim.
                }
            }
            return victim;
        }

        [ChatCommand("arrow")]
        void arrow(BasePlayer player, string command, string[] args)
        {
            Puts(player.playerFlags.ToString());
            if (args.Length >= 1)
            {
                switch (args[0])
                {
                    case "narco":
                        arrow_type = "narco";
                        break;
                    case "wind":
                        arrow_type = "wind";
                        break;
                    case "poision":
                        arrow_type = "poision";
                        break;
                    case "fire":
                        arrow_type = "fire";
                        break;
                    case "explosive":
                        arrow_type = "explosive";
                        break;
                    case "knockdown":
                        arrow_type = "knockdown";
                        break;
                    case "slow":
                        arrow_type = "slow";
                        break;
                    default:
                        player.ChatMessage("[<color='orange'>PsyArrow</color>] Arrow Types \n 1) narco \n 2) wind \n 3) poision \n 4) fire \n 5) explosive \n 6) knockdown \n 7) slow ");
                        break;
                }


                player.ChatMessage("[<color='cyan'>PsyArrow</color>] Arrow type switched to [<color='lime'> " + arrow_type + " </color>]");
                bowmen.Add(player.userID, arrow_type);
            }
            else
            {
                player.ChatMessage("[<color='orange'>PsyArrow</color>] Arrow Types \n [USAGE: /arrow arrow_type : Ex. /arrow narco ]\n 1) narco \n 2) wind \n 3) poision \n 4) fire \n 5) explosive \n 6) knockdown \n 7) slow ");

            }
