on from <color=#aaff55>[{0}]</color>\nTo accept, type: <color=#ffd479>/{2} accept {0}</color>\nThe invitation will expire in: {1}",
            ["Notification.Alliance.NoActiveInvite"] = "You do not have an active alliance invitation for <color=#aaff55>[{0}]</color>",
            ["Notification.Alliance.NoActiveInviteFrom"] = "You do not have an active alliance invitation from <color=#aaff55>[{0}]</color>",
            ["Notification.Alliance.WithdrawnClan"] = "{0} has withdrawn an alliance invitation to <color=#aaff55>[{1}]</color>",
            ["Notification.Alliance.WithdrawnTarget"] = "<color=#aaff55>[{0}]</color> has withdrawn their alliance invitation",
            ["Notification.Alliance.AtLimitTarget"] = "<color=#aaff55>[{0}]</color> currently has the maximum amount of alliances allowed",
            ["Notification.Alliance.AtLimitSelf"] = "Your clan currently has the maximum amount of alliances allowed",
            ["Notification.Alliance.AtLimitAlliedMembersTarget"] = "<color=#aaff55>[{0}]</color> clan member count plus alliance member count plus your clans member count is greater than allowed",
            ["Notification.Alliance.AtLimitAlliedMembersSelf"] = "Your clan member count plus alliance member count plus this clans member count is greater than allowed",
            ["Notification.Alliance.Formed"] = "<color=#aaff55>[{0}]</color> has formed an alliance with <color=#aaff55>[{1}]</color>",
            ["Notification.Alliance.Rejected"] = "<color=#aaff55>[{0}]</color> has rejected calls to form an alliance with <color=#aaff55>[{1}]</color>",
            ["Notification.Alliance.Revoked"] = "<color=#aaff55>[{0}]</color> has revoked their alliance with <color=#aaff55>[{1}]</color>",
            ["Notification.Alliance.NoActiveAlliance"] = "You do not currently have an alliance with <color=#aaff55>[{0}]</color>",

            ["Notification.FF.MemberEnabled"] = "Clanmates <color=#ffd479>will</color> take damage from friendly fire",
            ["Notification.FF.MemberDisabled"] = "Clanmates <color=#ffd479>won't</color> take damage from friendly fire",
            ["Notification.FF.AllyEnabled"] = "Allies <color=#ffd479>will</color> take damage from friendly fire",
            ["Notification.FF.AllyDisabled"] = "Allies <color=#ffd479>won't</color> take damage from friendly fire",
            ["Notification.FF.IsEnabled"] = "<color=#aaff55>Enabled</color>",
            ["Notification.FF.IsDisabled"] = "<color=#ce422b>Disabled</color>",
            ["Notification.FF.OnHitClanMember"] = "{0} is a clan member and can not be hurt.\nTo toggle clan friendly fire type: <color=#ffd479>/{1}</color>",
            ["Notification.FF.OnHitAllyMember"] = "{0} is a member of an allied clan and can not be hurt.\nTo toggle ally friendly fire type: <color=#ffd479>/{1}</color>",
            ["Notification.FF.ToggleNotOwner"] = "Only the clan Owner or Council can toggle friendly fire",
            ["Notification.FF.OwnerToggle"] = "{0} has toggled friendly fire.\n{1}",
            ["Notification.FF.OwnerAllyToggle"] = "{0} has toggled allied friendly fire.\n{1}",

            ["Notification.ClanHelp.NoClan"] = "\nAvailable Commands:\n<color=#ffd479>/{0} create <tag> \"description\"</color> - Create a new clan\n<color=#ffd479>/{0} accept <tag></color> - Join a clan by invitation\n<color=#ffd479>/{0} reject <tag></color> - Reject a clan invitation",
            ["Notification.ClanHelp.Basic2"] = "\nAvailable Commands:\n<color=#ffd479>/{0}</color> - Display your clan information\n<color=#ffd479>/{1} <message></color> - Send a message via clan chat\n<color=#ffd479>/{0} leave</color> - Leave your current clan",
            ["Notification.ClanHelp.MFF"] = "\n<color=#ffd479>/{0}</color> - Toggle friendly fire against other clan mates",
            ["Notification.ClanHelp.AFF"] = "\n<color=#ffd479>/{0}</color> - Toggle friendly fire against allied clan members",
            ["Notification.ClanHelp.Alliance"] = "\n\n<color=#45b6fe><size=14>Alliance Commands:</size></color>\n<color=#ffd479>/{0} invite <tag></color> - Invite a clan to become allies\n<color=#ffd479>/{0} withdraw <tag></color> - Withdraw an alliance invitation\n<color=#ffd479>/{0} accept <tag></color> - Accept an alliance invitation\n<color=#ffd479>/{0} reject <tag></color> - Reject an alliance invitation\n<color=#ffd479>/{0} revoke <tag></color> - Revoke an alliance",
            ["Notification.ClanHelp.Moderator"] = "\n\n<color=#b573ff><size=14>Moderator Commands:</size></color>\n<color=#ffd479>/{0} invite <name or ID></color> - Invite a player to your clan\n<color=#ffd479>/{0} withdraw <name or ID></color> - Revoke a invitation\n<color=#ffd479>/{0} kick <name or ID></color> - Kick a member from your clan",
            ["Notification.ClanHelp.Owner"] = "\n\n<color=#a1ff46><size=14>Owner Commands:</size></color>\n<color=#ffd479>/{0} promote <name or ID></color> - Promote a clan member\n<color=#ffd479>/{0} demote <name or ID></color> - Demote a clan member\n<color=#ffd479>/{0} disband forever</color> - Disband your clan",

            ["Notification.ClanHelp.TagColor"] = "\n<color=#ffd479>/{0} tagcolor <hex></color> - Sets a custom clan tag color\n<color=#ffd479>/{0} tagcolor reset</color> - Restores the default clan tag color",

            ["Notification.Clan.NotInAClan"] = "\nYou are currently not a member of a clan",
            ["Notification.Clan.Help"] = "\nTo see available commands type: <color=#ffd479>/{0}</color>",
            ["Notification.Clan.OwnerOf"] = "\nYou are the owner of: <color=#aaff55>{0}</color> ({1}/{2})",
            ["Notification.Clan.CouncilOf"] = "\nYou are the council of: <color=#aaff55>{0}</color> ({1}/{2})",
            ["Notification.Clan.ModeratorOf"] = "\nYou are a moderator of: <color=#aaff55>{0}</color> ({1}/{2})",
            ["Notification.Clan.MemberOf"] = "\nYou are a member of: <color=#aaff55>{0}</color> ({1}/{2})",
            ["Notification.Clan.MembersOnline"] = "\nMembers Online: {0}",
            ["Notification.Clan.MFF"] = "\nClan FF Status: {0} (<color=#ffd479>/{1}</color>)",
            ["Notification.Clan.AFF"] = "\nAlly FF Status: {0} (<color=#ffd479>/{1}</color>)",

            ["Notification.Clan.CreateSyntax"] = "<color=#ffd479>/{0} create <tag> \"description\"</color> - Create a new clan",
            ["Notification.Clan.InviteSyntax"] = "<color=#ffd479>/{0} invite <partialNameOrID></color> - Invite a player to your clan",
            ["Notification.Clan.WithdrawSyntax"] = "<color=#ffd479>/{0} withdraw <partialNameOrID></color> - Revoke a member invitation",
            ["Notification.Clan.AcceptSyntax"] = "<color=#ffd479>/{0} accept <tag></color> - Join a clan by invitation",
            ["Notification.Clan.RejectSyntax"] = "<color=#ffd479>/{0} reject <tag></color> - Reject a clan invitation",
            ["Notification.Clan.PromoteSyntax"] = "<color=#ffd479>/{0} promote <partialNameOrID></color> - Promote a clanFreb member to the next rank",
            ["Notification.Clan.DemoteSyntax"] = "<color=#ffd479>/{0} demote <partialNameOrID></color> - Demote a clan member to the next lowest rank",
            ["Notification.Clan.DisbandSyntax"] = "<color=#ffd479>/{0} disband forever</color> - Disband your clan (this can not be undone)",
            ["Notification.Clan.KickSyntax"] = "<color=#ffd479>/{0} kick <partialNameOrID></color> - Kick a member from your clan",

            ["Notification.Clan.TagColorSyntax"] = "<color=#ffd479>/{0} tagcolor <hex (XXXXXX)></color> - Set a custom clan tag color",
            ["Notification.Clan.TagColorFormat"] = "<color=#ffd479>The hex string must be 6 characters long, and be a valid hex color</color>",
            ["Notification.Clan.TagColorReset"] = "<color=#ffd479>You have reset your clan's tag color</color>",
            ["Notification.Clan.TagColorSet"] = "<color=#ffd479>You have set your clan's tag color to</color> <color=#{0}>{0}</color>",
            ["Notification.Clan.TagColorDisabled"] = "<color=#ffd479>Custom tag colors are disabled on this server</color>",
            ["Notification.Clan.TagColorBlocked"] = "<color=#ffd479>The color <color=#{0}>{0}</color> is blacklisted for use by clans.",
            ["Notification.Clan.TagColorOutOfRange"] = "<color=#ffd479>The color <color=#{0}>{0}</color> is out of the allowed color range. You must pick a color between <color=#{1}>{1}</color> and <color=#{2}>{2}</color></color>",

            ["Notification.Disband.NotOwner"] = "You must be the clan owner to use this command",
            ["Notification.Disband.Success"] = "You have disbanded the clan <color=#aaff55>[{0}]</color>",
            ["Notification.Disband.Message"] = "The clan has been disbanded",
            ["Notification.Disband.NoPermission"] = "You do not have permission to disband this clan",

            ["Notification.Generic.ClanFull"] = "The clan is already at maximum capacity",
            ["Notification.Generic.NoClan"] = "You are not a member of a clan",
            ["Notification.Generic.InvalidClan"] = "The clan <color=#aaff55>[{0}]</color> does not exist!",
            ["Notification.Generic.NoPermissions"] = "You have insufficient permission to use that command",
            ["Notification.Generic.SpecifyClanTag"] = "Please specify a clan tag",
            ["Notification.Generic.UnableToFindPlayer"] = "Unable to find a player with the name or ID {0}",
            ["Notification.Generic.CommandSelf"] = "You can not use this command on yourself",

            ["Chat.IsMuted"] = "You are currently muted",
            ["Chat.Alliance.Prefix"] = "<color=#a1ff46>[ALLY CHAT]</color>: {0}",
            ["Chat.Clan.Prefix"] = "<color=#a1ff46>[CLAN CHAT]</color>: {0}",
            ["Chat.Alliance.Format"] = "[{0}] <color={1}>{2}</color>: {3}",

            ["Admin.BroadcastToClan"] = "<color=#ff3333>[ADMIN]</color>: {0}",
            ["Admin.Rename"] = "An administrator changed your clan tag to <color=#aaff55>[{0}]</color>",
            ["Admin.Disband"] = "An administrator has disbanded your clan",
            ["Admin.Invite"] = "An administrator has invited {0} to join your clan",
            ["Admin.Join"] = "An administrator has forced you to join <color=#aaff55>[{0}]</color>",
            ["Admin.Kick"] = "An administrator has kicked you from <color=#aaff55>[{0}]</color>",
            ["Admin.SetOwner"] = "An administrator has set {0} as the clan leader",
            ["Admin.Promote"] = "An administrator has promoted {0} to the rank of {1}",
            ["Admin.Demote"] = "An administrator has demoted {0} to the rank of {1}",
        };

        private Dictionary<string, string> leetTable = new Dictionary<string, string>
        {
            { "}{", "h" },
            { "|-|", "h" },
            { "]-[", "h" },
            { "/-/", "h" },
            { "|{", "k" },
            { "/\\/\\", "m" },
            { "|\\|", "n" },
            { "/\\/", "n" },
            { "()", "o" },
            { "[]", "o" },
            { "vv", "w" },
            { "\\/\\/", "w" },
            { "><", "x" },
            { "2", "z" },
            { "4", "a" },
            { "@", "a" },
            { "8", "b" },
            { "ß", "b" },
            { "(", "c" },
            { "<", "c" },
            { "{", "c" },
            { "3", "e" },
            { "€", "e" },
            { "6", "g" },
            { "9", "g" },
            { "&", "g" },
            { "#", "h" },
            { "$", "s" },
            { "7", "t" },
            { "|", "l" },
            { "1", "i" },
            { "!", "i" },
            { "0", "o" },
        };
        #endregion

        /*[ChatCommand(("fakeclan"))]
        private void cmdFakeClan(BasePlayer player, string command, string[] args)
        {
            Clan myClan = storedData.FindClanByID(player.userID);
            for (int i = 0; i < 20; i++)
            {
                ulong ownerid = (ulong)UnityEngine.Random.Range(76560000000000000, 7656999999999999);
                string tag = $"{UnityEngine.Random.Range(100, 999)}";
                Clan clan = new Clan
                {
                    Tag = tag,
                    Description = string.Empty,
                    CreationTime = UnixTimeStampUTC(),
                    LastOnlineTime = UnixTimeStampUTC(),
                    OwnerID = ownerid
                };
                
                clan.ClanMembers.Add(ownerid, new Clan.Member(Clan.Member.MemberRole.Owner, clan));
                clan.AllianceInvites.Add("420", UnixTimeStampUTC());

                myClan.IncomingAlliances.Add(tag);

                storedData.clans[tag] = clan;
            }

            for (int i = 0; i < 20; i++)
            {
                ulong ownerid = (ulong)UnityEngine.Random.Range(76560000000000000, 7656999999999999);
                myClan.MemberInvites[ownerid] = new Clan.MemberInvite()
                {
                    DisplayName = $"Dummy Player {i}",
                    ExpiryTime = UnixTimeStampUTC()
                };
            }
            
            for (int i = 0; i < 20; i++)
            {
                ulong ownerid = (ulong)UnityEngine.Random.Range(76560000000000000, 7656999999999999);
                myClan.Alliances.Add(ownerid.ToString());
            }
            
            for (int i = 0; i < 20; i++)
            {
                ulong ownerid = (ulong)UnityEngine.Random.Range(76560000000000000, 7656999999999999);
                myClan.AllianceInvites.Add(ownerid.ToString(), UnixTimeStampUTC());
            }
            
            for (int i = 0; i < 20; i++)
            {
                ulong ownerid = (ulong)UnityEngine.Random.Range(76560000000000000, 7656999999999999);
                myClan.IncomingAlliances.Add(ownerid.ToString());
            }
            SaveData();
        }*/
    }
}


// --- End of file: Clans-3.0.40.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/LootProtection.cs ---
// --- Original Local Path: LootProtection.cs ---

using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("LootProtection", "Wulf/lukespragg", "0.5.0", ResourceId = 1150)]
    [Description("Protects corpses and/or sleepers with permission from being looted by other players")]

    class LootProtection : CovalencePlugin
    {
        #region Initialization

        const string permBypass = "lootprotection.bypass";
        const string permCorpse = "lootprotection.corpse";
        const string permSleeper = "lootprotection.sleeper";

        void Init()
        {
            LoadDefaultMessages();

            permission.RegisterPermission(permBypass, this);
            permission.RegisterPermission(permCorpse, this);
            permission.RegisterPermission(permSleeper, this);
        }

        void OnServerInitialized()
        {
            foreach (var player in players.All)
            {
                if (!player.HasPermission("lootprotection.enable")) continue;
                permission.RevokeUserPermission(player.Id, "lootprotection.enable");
            }

            foreach (var group in permission.GetGroups())
            {
                if (!permission.GroupHasPermission(group, "lootprotection.enable")) continue;
                permission.RevokeGroupPermission(group, "lootprotection.enable");
            }
        }

        #endregion

        #region Localization

        void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string> { ["LootProtection"] = "{0} has loot protection enabled" }, this);

            // French
            lang.RegisterMessages(new Dictionary<string, string> { ["LootProtection"] = "{0} a protection de butin activÃ©e" }, this, "fr");

            // German
            lang.RegisterMessages(new Dictionary<string, string> { ["LootProtection"] = "{0} hat Beute Schutz aktiviert" }, this, "de");

            // Russian
            lang.RegisterMessages(new Dictionary<string, string> { ["LootProtection"] = "{0} Ð¸Ð¼ÐµÐµÑ Ð²ÐºÐ»ÑÑÐµÐ½Ð° Ð·Ð°ÑÐ¸ÑÐ° ÐÑÑ" }, this, "ru");

            // Spanish
            lang.RegisterMessages(new Dictionary<string, string> { ["LootProtection"] = "{0} tiene botÃ­n protecciÃ³n activada" }, this, "es");
        }

        #endregion

        #region Loot Protection

        object OnLootEntity(BasePlayer looter, BaseEntity entity)
        {
            var corpse = entity as LootableCorpse;
            var sleeper = entity as BasePlayer;

            if (permission.UserHasPermission(looter.UserIDString, permBypass)) return null;

            if (corpse != null && permission.UserHasPermission(corpse.playerSteamID.ToString(), permCorpse))
            {
                NextFrame(looter.EndLooting);
                looter.ChatMessage(Lang("LootProtection", looter.UserIDString, corpse.playerName));
                return true;
            }

            if (sleeper != null && permission.UserHasPermission(sleeper.UserIDString, permSleeper))
            {
                NextFrame(looter.EndLooting);
                looter.ChatMessage(Lang("LootProtection", looter.UserIDString, sleeper.displayName));
                return true;
            }

            return null;
        }

        #endregion

        #region Helpers

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion
    }
}


// --- End of file: LootProtection.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SkyReportSystem.cs ---
// --- Original Local Path: SkyReportSystem.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Globalization;
using UnityEngine;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Libraries;
using ConVar;
using Newtonsoft.Json.Linq;

namespace Oxide.Plugins
{
    [Info("SkyReportSystem", "DezLife", "3.2.0")]
    [Description("Report system for rust")]
    public class SkyReportSystem : RustPlugin
    {
        #region Reference
        [PluginReference] Plugin IQChat, ImageLibrary;
        public string GetImage(string shortname, ulong skin = 0) => (string)ImageLibrary?.Call("GetImage", shortname, skin);

        Dictionary<ulong, ulong> CheckPlayerModeration = new Dictionary<ulong, ulong>();
        #endregion

        #region Config
        private Configuration config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "VK:", Order = 0)]
            public VKontakte vKontakte;

            [JsonProperty(PropertyName = "Discord:", Order = 1)]
            public Discord discord;

            [JsonProperty(PropertyName = "Setting:", Order = 2)]
            public Setting setting;

            [JsonProperty(PropertyName = "Проверка на AFK:", Order = 3)]
            public IsAfk isafk;

            [JsonProperty(PropertyName = "Причины бана:", Order = 4)]
            public List<BanReasons> banReasons;

            [JsonProperty("Настройки плагина", Order = 5)]
            public List<string> Reasonsforcomplaint;
        }

        public class BanReasons
        {
            [JsonProperty(PropertyName = "Причина бана:", Order = 0)]
            public string BanReason;

            [JsonProperty(PropertyName = "Команда для бана:", Order = 1)]
            public string BanReasonCommand;
        }

        public class IsAfk
        {
            [JsonProperty(PropertyName = "Включить проверку на AFK ?", Order = 0)]
            public bool usecheckafk;

            [JsonProperty(PropertyName = "Время между проверками на AFK", Order = 2)]
            public float timecheckisafk;
        }


        public class Setting
        {
            [JsonProperty(PropertyName = "Аватар для сообщений(Для работы с IQChat )", Order = 0)]
            public ulong avatarid;

            [JsonProperty(PropertyName = "Префикс(Для работы с IQChat )", Order = 1)]
            public string prefix;

            [JsonProperty(PropertyName = "Колличевство репортов для вызова на проверку", Order = 3)]
            public int maxreportcall;

            [JsonProperty(PropertyName = "Отправлять сообщения модераторам в чат о том что игрок превысил количевство репортов (Требуется разрешения SkyReportSystem.moderator)", Order = 4)]
            public bool usemodercall;

            [JsonProperty(PropertyName = "Включить логирование ?", Order = 5)]
            public bool uselog;

            [JsonProperty(PropertyName = "Кд на отправку репортов", Order = 6)]
            public int Cooldown;

            [JsonProperty(PropertyName = "Названия сервера", Order = 7)]
            public string servername;

            [JsonProperty(PropertyName = "Команда для открытия репорт меню", Order = 8)]
            public string comandplayer;

            [JsonProperty(PropertyName = "Команда для открытия модер меню", Order = 9)]
            public string comandmoder;

            [JsonProperty(PropertyName = "Сообщения в титле", Order = 10)]
            public string teatletxt;
        }

        public class VKontakte
        {
            [JsonProperty(PropertyName = "Используем Вконтакте:", Order = 0)]
            public bool UseVK;

            [JsonProperty(PropertyName = "ID Беседы ВК для бота:", Order = 1)]
            public string VK_ChatID;

            [JsonProperty(PropertyName = "Token Группы ВК:", Order = 2)]
            public string VK_Token;
        }
        public class Discord
        {
            [JsonProperty(PropertyName = "Используем Discord:", Order = 0)]
            public bool UseDiscord;

            [JsonProperty(PropertyName = "Webhook Discrod:", Order = 1)]
            public string Discord_webHook;
        }

        protected override void LoadDefaultConfig()
        {
            config = new Configuration()
            {
                vKontakte = new VKontakte()
                {
                    UseVK = false,
                    VK_ChatID = "ChatID",
                    VK_Token = "VKToken",
                },
                discord = new Discord()
                {
                    Discord_webHook = "webHook",
                    UseDiscord = false,
                },
                setting = new Setting()
                {
                    avatarid = 76561198854646370,
                    prefix = "SkyReportSystem",
                    maxreportcall = 4,
                    usemodercall = true,
                    uselog = false,
                    Cooldown = 360,
                    servername = "Server Name",
                    comandplayer = "report",
                    comandmoder = "reportm",
                    teatletxt = "ReportSystem by DezLife"

                },
                isafk = new IsAfk()
                {
                    usecheckafk = false,
                    timecheckisafk = 15f,
                },
                banReasons = new List<BanReasons>()
                {
                    new BanReasons
                    {
                         BanReason = "Читы",
                         BanReasonCommand = "ban {0} 999d Soft",
                    },
                    new BanReasons
                    {
                         BanReason = "Макросы",
                         BanReasonCommand = "ban {0} 30d Macros",
                    },
                    new BanReasons
                    {
                         BanReason = "Превышение максимальной численности игроков в команде",
                         BanReasonCommand = "ban {0} 14d 3+",
                    },
                    new BanReasons
                    {
                         BanReason = "Отказ от проверки",
                         BanReasonCommand = "ban {0} 7d Otkaz",
                    },
                    new BanReasons
                    {
                         BanReason = "Другое",
                         BanReasonCommand = "ban {0} 999d 5",
                    },
                },
                Reasonsforcomplaint = new List<string>
                {
                    "3+",
                    "Подозрения в читах",
                    "Макросы",
                    "Реклама в нике",
                    "Спам в чат",
                    "Обман игроков",
                    "Багоюз",
                    "Токсик",
                }

            };
            SaveConfig(config);
        }

        void SaveConfig(Configuration config)
        {
            Config.WriteObject(config, true);
            SaveConfig();
        }

        public void LoadConfigVars()
        {
            config = Config.ReadObject<Configuration>();
            Config.WriteObject(config, true);
        }
        #endregion

        #region data

        public Dictionary<ulong, ReportUser> ReportData = new Dictionary<ulong, ReportUser>();

        public class ReportUser
        {
            public int ReportCount;
            public int CheckCount;
            public List<string> complaint = new List<string>();
        }
        #endregion

        #region Lang

        protected override void LoadDefaultMessages()
        {
            Dictionary<string, string> Lang = new Dictionary<string, string>
            {
                ["SKY_REPORT_REPORTING"] = "Вы успешно отправили репорт на игрока {0}",
                ["SKY_REPORT_REPORTING_VK_DISCORD"] = "=====================================================\nСервер : {0}\nИгрок : {1} пожаловался на {2} [{3}]\nПричина : {4}",
                ["SKY_REPORT_MAXIMUM_REPORT"] = "Игрок: {0} " +
                " Превысил максимальное количевство репортов!" +
                "Его колличевство {1}",
                ["SKY_COLDOWN"] = "Вы недавно отправляли жалобу,подождите еще немного",
                ["SKY_ERROR_PLAYER"] = "Вы жалуетесь сами на себя!",
                ["SKY_PLAYER_PERMISSION_IS_FOUND"] = "У вас недостаточно прав для использования данной команды!",
                ["SKY_NO_CHECK_MODERATION_OR_CHECKING"] = "Вы не можете вызвать игрока {0} на проверку,т.к его проверяет другой модератор",
                ["SKY_ACESS_CHECKING"] = "Вы вызвали игрока {0} на проверку",
                ["SKY_MODER_CHECK_PLAYER_GOING"] = "=====================================================\nМодератор {0} вызвал на проверку игрока {1}[{2}]",
                ["SKY_MODER_CHECK_PLAYER_GOING_CONSOLE"] = "=====================================================\nИгрок {1}[{2}] был вызван с помощью консоли",
                ["SKY_PLAYER_IS_AFK_VK_DISCORD_OK"] = "=====================================================\nИгрок: {0}  двигался с момента последней проверки на AFK",
                ["SKY_PLAYER_IS_AFK_VK_DISCORD_NO"] = "=====================================================\nИгрок: {0} не двигался с момента последней проверки на AFK",
                ["SKY_PLAYER_IS_AFK_OK"] = "Игрок: <color=orange>{0}</color> двигался с момента последней проверки на AFK",
                ["SKY_PLAYER_IS_AFK_NO"] = "Игрок: <color=orange>{0}</color> не двигался с момента последней проверки на AFK",
                ["SKY_MODERATOR_STOPID_CHEKING"] = "Вы успешно закончили проверку над игроком : {0} !",
                ["SKY_PLAYER_STOPID_CHEKING"] = "Проверка успешно окончена. \nПроверял модератор {0} !",
                ["SKY_PLAYER_CHECKING_MODER_MENU_MODERATION"] = "Игрок проверяется модератором",
                ["SKY_PLAYER_NOTHING_MESSAGE_SKYPE_DISCORD"] = "Вы ничего не ввели!",
                ["SKY_MODER_CHECK_P_SKYPE"] = "Вы предоставили свой Skype : {0}",
                ["SKY_MODER_CHECK_P_DISCORD"] = "Вы предоставили свой Discord : {0}",
                ["SKY_Menu_Info"] = "В данном окне вам нужно выбрать игрока из списка или ввести его ник в поле ниже что бы оставить на него жалобу",
                ["SKY_SKYPE_MESSAGE"] =
                                           "=====================================================\n" +
                                           "Сервер : {0}\n" +
                                           "Игровой ник: {1}\n" +
                                           "Steam ID: {2}\n" +
                                           "Предоставил Skype на проверку : {3}",
                ["SKY_DISCORD_MESSAGE"] =
                                           "=====================================================\n" +
                                           "Сервер : {0}\n" +
                                           "Игровой ник: {1}\n" +
                                           "Steam ID: {2}\n" +
                                           "Предоставил Discord на проверку : {3}",
                ["SKY_SKYPE_DISCORD_ERROR"] = "Вас должны вызвать на проверку,перед тем,как отправлять данные",
                ["SKY_REPORT_VK_DISCORD_MAXIMUM_BLACK"] =
                                           "=====================================================\n" +
                                           "Сервер : {0}\n" +
                                           "Достигнут предел жалоб на игрока!\n" +
                                           "Игровой ник: {1}\n" +
                                           "Steam ID: {2}\n" +
                                           "Информация о подозрительном игроке:\n" +
                                           "Игрок проверялся: {3} раз(-а)\n" +
                                           "Стим: https://steamcommunity.com/profiles/{4}",
                ["SKY_CHECK_STOP"] =
                                           "=====================================================\n" +
                                           "Сервер : {0}\n" +
                                           "Модератор {1} окончил проверку над игроком {2} [{3}]\n",
                ["SKY_CHECK_STOP_CONSOLE"] =
                                           "=====================================================\n" +
                                           "Сервер : {0}\n" +
                                           "Проверка окончена над игроком {2} [{3}]\n",
                ["BAN_USER_VK_DISCORD"] =
                                           "=====================================================\n" +
                                           "Игрок :{0}({1})\n" +
                                           "Был забанен на сервере({2}) по причине {3} Модератором {4}\n",
            };
            lang.RegisterMessages(Lang, this);
            PrintWarning("Языковой файл загружен успешно");

        }
        #endregion

        #region Hooks

        private void OnServerInitialized()
        {
            LoadConfigVars();
            if (!ImageLibrary)
            {
                PrintError("Не найден ImageLibrary, плагин не будет работать!");
                return;
            }
            #region Permission
            permission.RegisterPermission("SkyReportSystem.moderator", this);
            permission.RegisterPermission("SkyReportSystem.ban", this);
            #endregion

            #region DataLoad
            LoadData("ReportData", ref ReportData, true);

            for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
                OnPlayerConnected(BasePlayer.activePlayerList[i]);
            #endregion


            cmd.AddChatCommand(config.setting.comandplayer, this, nameof(ReportMenu));
            cmd.AddChatCommand(config.setting.comandmoder, this, nameof(modermenu));

            if (config.setting.servername == "Server Name")
            {
                PrintWarning("Вы не указали названия сервера, плагин будет работать некорректно!");
            }

            PrintError($"-----------------------------------");
            PrintError($"           SkyReportSystem         ");
            PrintError($"          Author = DezLife         ");
            PrintError($"          Version = {Version}      ");
            PrintError($"-----------------------------------");
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (!ReportData.ContainsKey(player.userID))
            {
                ReportUser NewUser = new ReportUser()
                {
                    ReportCount = 0,
                    CheckCount = 0,
                    complaint = new List<string> { }
                };
                ReportData.Add(player.userID, NewUser);
            }
            if (CheckPlayerModeration.ContainsKey(player.userID))
            {
                BasePlayer players = BasePlayer.FindByID(CheckPlayerModeration[player.userID]);
                if (players != null)
                {
                    SendChat(players, "Вызываемый игрок покинул сервер!");
                }
                else
                {
                    PrintWarning("Вызываемый игрок покинул сервер!");
                }
                BanPlayer.Remove(player.userID);
            }
        }

        void Unload()
        {
            SaveData("ReportData", ReportData);
            for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                var p = BasePlayer.activePlayerList[i];
                CuiHelper.DestroyUi(p, mainskymenu);
                CuiHelper.DestroyUi(p, ModerMenuSky);
                CuiHelper.DestroyUi(p, ModerAlert);
            }
        }

        #endregion

        #region Metods

        private void ReportActivity(BasePlayer reportplayer, BasePlayer target, string reason)
        {
            if (ReportData[target.userID].ReportCount >= config.setting.maxreportcall && target.userID != reportplayer.userID)
            {
                SendChatMessage("SKY_REPORT_VK_DISCORD_MAXIMUM_BLACK", config.setting.servername, target.displayName, target.userID, ReportData[target.userID].CheckCount, target.userID);
            }
            if (config.discord.UseDiscord == true && ReportData[target.userID].ReportCount >= config.setting.maxreportcall && target.userID != reportplayer.userID)
            {
                SendDiscordMsg("SKY_REPORT_VK_DISCORD_MAXIMUM_BLACK", config.setting.servername, target.displayName, target.userID, ReportData[target.userID].CheckCount, target.userID);
            }
            if (config.setting.uselog == true && ReportData[target.userID].ReportCount >= config.setting.maxreportcall && target.userID != reportplayer.userID)
            {
                LogToFile("SkyReportSystemLOG", $"На игрока <color=#816AD0>{target.displayName}</color> пожаловался <color=#816AD0>{reportplayer.displayName}</color>\n" +
                            $"<size=12>Причина: {reason} </size>", this);
            }
        }

        #endregion

        #region Parent
        public static string mainskymenu = "MAIN_MENU_PLAYER";
        public static string ModerMenuSky = "MAIN_MENU_MODER";
        public static string PlayerAlert = "MAIN_MENU_alert";
        public static string ModerAlert = "MAIN_moder_alert";
        #endregion

        #region commands

        private void ReportMenu(BasePlayer player)
        {
            SkyReportPlayers(player);
        }

        [ConsoleCommand("reportplayer")]
        private void cmdreportplayer(ConsoleSystem.Arg args)
        {
            SkyReportPlayers(args.Player());
        }

        [ConsoleCommand("players")]
        private void cmdreportplayerConsole(ConsoleSystem.Arg args)
        {
            if (args.Args == null || args.Args.Length == 0 || args.Args.Length < 2)
            {
                PrintWarning($"Неверный синтаксис, используйте players check/uncheck StemId64");
                return;
            }

            BasePlayer player = BasePlayer.FindByID(ulong.Parse(args.Args[1]));
            if (player == null) { PrintWarning("Игрока нет на сервере!"); return; };

            switch (args.Args[0].ToLower())
            {
                case "check":
                    {
                        CheckPlayerModeration.Add(player.userID, player.userID);
                        PrintWarning($"Вы вызвали игрока {player.displayName} на проверку");
                        SendDiscordMsg("SKY_MODER_CHECK_PLAYER_GOING_CONSOLE", player.displayName, player.userID);
                        SendChatMessage("SKY_MODER_CHECK_PLAYER_GOING_CONSOLE", player.displayName, player.userID);


                        if (config.isafk.usecheckafk == true)
                        {
                            timer.Repeat(config.isafk.timecheckisafk, 3, () =>
                            {
                                if (!IsPlayerAfk(player))
                                {
                                    SendDiscordMsg("SKY_PLAYER_IS_AFK_VK_DISCORD_OK", player.displayName);

                                    SendChatMessage("SKY_PLAYER_IS_AFK_VK_DISCORD_OK", player.displayName);
                                    PrintWarning(String.Format(lang.GetMessage("SKY_PLAYER_IS_AFK_OK", this), player.displayName));
                                }
                                else
                                {
                                    SendDiscordMsg("SKY_PLAYER_IS_AFK_VK_DISCORD_NO", player.displayName);

                                    SendChatMessage("SKY_PLAYER_IS_AFK_VK_DISCORD_NO", player.displayName);
                                    PrintWarning(String.Format(lang.GetMessage("SKY_PLAYER_IS_AFK_NO", this), player.displayName));
                                }
                            });
                        }
                        AlertPlayerCheck(player, player);
                        break;
                    }
                case "uncheck":
                    {
                        if (CheckPlayerModeration.ContainsKey(player.userID))
                        {
                            CheckPlayerModeration.Remove(player.userID);

                            CuiHelper.DestroyUi(player, PlayerAlert);

                            PrintWarning(String.Format(lang.GetMessage("SKY_MODERATOR_STOPID_CHEKING", this), player.displayName));
                            SendDiscordMsg("SKY_CHECK_STOP_CONSOLE", config.setting.servername, player.displayName, player.userID);
                            SendChatMessage("SKY_CHECK_STOP_CONSOLE", config.setting.servername, player.displayName, player.userID);

                            ReportData[player.userID].ReportCount = 0;
                            ReportData[player.userID].CheckCount++;
                        }
                        else
                        {
                            PrintWarning("Этого игрока не вызывали на проверку!");
                        }
                        break;
                    }
            }

        }

        private void modermenu(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, "SkyReportSystem.moderator") || player.IsAdmin)
            {
                SkyModerMenu(player);
            }
            else
            {
                SendChat(player, String.Format(lang.GetMessage("SKY_PLAYER_PERMISSION_IS_FOUND", this)));
            }
        }

        [ConsoleCommand("moderreport")]
        private void cmdreportmenu(ConsoleSystem.Arg args)
        {
            if (permission.UserHasPermission(args.Player().UserIDString, "SkyReportSystem.moderator") || args.Player().IsAdmin)
            {
                SkyModerMenu(args.Player());
            }
            else
            {
                SendChat(args.Player(), String.Format(lang.GetMessage("SKY_PLAYER_PERMISSION_IS_FOUND", this)));
            }
        }

        [ConsoleCommand("closeui")]
        void closeuimain(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            CuiHelper.DestroyUi(player, mainskymenu);
            CuiHelper.DestroyUi(player, "buttoncap");
            CuiHelper.DestroyUi(player, ModerMenuSky);
            CuiHelper.DestroyUi(player, PlayerAlert);
            CuiHelper.DestroyUi(player, ModerAlert);
        }

        [ChatCommand("discord")]
        void discordaccess(BasePlayer player, string cmd, string[] Args)
        {
            if (Args == null || Args.Length == 0)
            {
                SendChat(player, lang.GetMessage("SKY_PLAYER_NOTHING_MESSAGE_SKYPE_DISCORD", this));
                return;
            }

            if (CheckPlayerModeration.ContainsKey(player.userID))
            {
                string Discord = "";
                foreach (var arg in Args)
                {
                    Discord += " " + arg;
                }
                SendChatMessage("SKY_DISCORD_MESSAGE", config.setting.servername, player.displayName, player.UserIDString, Discord);
                SendDiscordMsg("SKY_DISCORD_MESSAGE", config.setting.servername, player.displayName, player.UserIDString, Discord);
                BasePlayer moderator = FindPlayer(CheckPlayerModeration[player.userID].ToString());
                if (player == moderator) { }
                else
                {
                    SendChat(moderator, String.Format(lang.GetMessage("SKY_DISCORD_MESSAGE", this), config.setting.servername, player.displayName, player.UserIDString, Discord));
                    SendChat(player, String.Format(lang.GetMessage("SKY_MODER_CHECK_P_DISCORD", this), Discord));
                }

            }
            else { SendChat(player, lang.GetMessage("SKY_SKYPE_DISCORD_ERROR", this)); }
        }

        [ConsoleCommand("openinfoplayer")]
        void consolego(ConsoleSystem.Arg args)
        {
            if (!args.HasArgs(2)) return;

            BasePlayer targetPlayer = BasePlayer.FindByID(ulong.Parse(args.Args[1]));

            BasePlayer player = args.Player();
            bool CanUse = permission.UserHasPermission(player.UserIDString, "SkyReportSystem.moderator") || player.IsAdmin;
            if (!CanUse) return;
            if (args.Args[0].ToLower() == "chooseplayers")
            {
                if (CanUse)
                {
                    playerinfomenu(player, args.Args[1], targetPlayer);
                }
                else
                {
                    SendChat(player, String.Format(lang.GetMessage("SKY_PLAYER_PERMISSION_IS_FOUND", this)));
                }
            }
            if (args.Args[0].ToLower() == "checkinplayer")
            {
                if (CheckPlayerModeration.ContainsKey(targetPlayer.userID))
                {
                    SendChat(player, String.Format(lang.GetMessage("SKY_NO_CHECK_MODERATION_OR_CHECKING", this), targetPlayer.displayName));
                }
                else
                {
                    if (CanUse)
                    {
                        CheckPlayerModeration.Add(targetPlayer.userID, args.Player().userID);
                        SendChat(player, String.Format(lang.GetMessage("SKY_ACESS_CHECKING", this), targetPlayer.displayName));
                        SendDiscordMsg("SKY_MODER_CHECK_PLAYER_GOING", player.displayName, targetPlayer.displayName, targetPlayer.userID);
                        SendChatMessage("SKY_MODER_CHECK_PLAYER_GOING", player.displayName, targetPlayer.displayName, targetPlayer.userID);


                        if (config.isafk.usecheckafk == true)
                        {
                            timer.Repeat(config.isafk.timecheckisafk, 3, () =>
                            {
                                if (!IsPlayerAfk(targetPlayer))
                                {
                                    SendDiscordMsg("SKY_PLAYER_IS_AFK_VK_DISCORD_OK", targetPlayer.displayName);

                                    SendChatMessage("SKY_PLAYER_IS_AFK_VK_DISCORD_OK", targetPlayer.displayName);
                                    SendChat(args.Player(), String.Format(lang.GetMessage("SKY_PLAYER_IS_AFK_OK", this), targetPlayer.displayName));
                                }
                                else
                                {
                                    SendDiscordMsg("SKY_PLAYER_IS_AFK_VK_DISCORD_NO", targetPlayer.displayName);

                                    SendChatMessage("SKY_PLAYER_IS_AFK_VK_DISCORD_NO", targetPlayer.displayName);
                                    SendChat(args.Player(), String.Format(lang.GetMessage("SKY_PLAYER_IS_AFK_NO", this), targetPlayer.displayName));
                                }
                            });
                        }
                        AlertPlayerCheck(BasePlayer.FindByID(targetPlayer.userID), player);
                        CuiHelper.DestroyUi(player, ModerMenuSky);
                    }
                    else
                    {
                        SendChat(player, String.Format(lang.GetMessage("SKY_PLAYER_PERMISSION_IS_FOUND", this)));
                    }
                }
            }

            if (args.Args[0] == "stopcheckingplayers")
            {
                if (CanUse)
                {
                    CheckPlayerModeration.Remove(targetPlayer.userID);

                    CuiHelper.DestroyUi(targetPlayer, PlayerAlert);
                    CuiHelper.DestroyUi(player, ModerMenuSky);
                    SendChat(player, String.Format(lang.GetMessage("SKY_MODERATOR_STOPID_CHEKING", this), targetPlayer.displayName));
                    SendChat(targetPlayer, String.Format(lang.GetMessage("SKY_PLAYER_STOPID_CHEKING", this), args.Player().displayName));
                    SendDiscordMsg("SKY_CHECK_STOP", config.setting.servername, args.Player().displayName, targetPlayer.displayName, targetPlayer.userID);
                    SendChatMessage("SKY_CHECK_STOP", config.setting.servername, args.Player().displayName, targetPlayer.displayName, targetPlayer.userID);

                    ReportData[targetPlayer.userID].ReportCount = 0;
                    ReportData[targetPlayer.userID].CheckCount++;
                }
                else
                {
                    SendChat(player, String.Format(lang.GetMessage("SKY_PLAYER_PERMISSION_IS_FOUND", this)));
                }
            }

            if (args.Args[0] == "moderatorcheckbanreason")
            {
                PlayerBanIPlayerModeration(player, BasePlayer.FindByID(targetPlayer.userID));
            }
        }

        [ConsoleCommand("Banplayers")]
        void ReportSystemBanReason(ConsoleSystem.Arg arg)
        {
            rust.RunClientCommand(arg.Player(), String.Format(config.banReasons[Convert.ToInt32(arg.Args[1])].BanReasonCommand, arg.Args[0]));
            CuiHelper.DestroyUi(arg.Player(), ModerMenuSky);
            BasePlayer player = BasePlayer.Find(arg.Args[0]);
            BasePlayer moderator = arg.Player();
            ReportData[player.userID].ReportCount = 0;
            string BanReason = $"{String.Format(config.banReasons[Convert.ToInt32(arg.Args[1])].BanReason, arg.Args[0])}";

            SendChatMessage("BAN_USER_VK_DISCORD", player.displayName, player.UserIDString, config.setting.servername, BanReason, moderator.displayName);
            SendDiscordMsg("BAN_USER_VK_DISCORD", player.displayName, player.UserIDString, config.setting.servername, BanReason, moderator.displayName);

            BanPlayer.Add(player.userID);

        }
        public List<ulong> BanPlayer = new List<ulong>();

        #region MetodsCooldown
        public Dictionary<ulong, int> CooldownPC = new Dictionary<ulong, int>();

        static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        static double CurrentTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;
        void Metods_GiveCooldown(ulong ID, int cooldown)
        {
            CooldownPC[ID] = cooldown + (int)CurrentTime();
        }

        bool Metods_GetCooldown(ulong ID)
        {
            if (!CooldownPC.ContainsKey(ID) || Math.Max(0, CooldownPC[ID]) < 1 || CooldownPC[ID] <= (int)CurrentTime())
                return false;
            else return true;
        }

        #endregion

        [ConsoleCommand("SkyReportGo")]
        private void PlayerReportSystem(ConsoleSystem.Arg args)
        {
            string ReasonReport = "";
            if (args.Args.Length == 0)
            {
                SkyReportPlayers(args.Player());
                return;
            }
            if (args.Args[0] == "chooseplayers")
            {
                SkyReportPlayers(args.Player(), args.Args[1]);
                return;
            }
            if (args.Args[0].Length != 17)
            {
                for (int t = 0; t < 44; t++)
                {
                    CuiHelper.DestroyUi(args.Player(), "Button" + $".ChoosePlayer.{t}");
                    CuiHelper.DestroyUi(args.Player(), "Button" + $".ChoosePlayer.{t}.Text");
                }
                SkyReportPlayers(args.Player(), args.Args[0]);
                return;
            }
            if (args.Args.Length >= 2)
            {
                int ReasonIndex = int.Parse(args.Args[1]);
                ReasonReport = config.Reasonsforcomplaint[ReasonIndex];
                BasePlayer target = BasePlayer.Find(args.Args[0]);
                ReportActivity(args.Player(), target, ReasonReport);


                if (args.Player() != target)
                {
                    if (Metods_GetCooldown(args.Player().userID) == true)
                    {
                        SendChat(args.Player(), lang.GetMessage("SKY_COLDOWN", this));
                        return;
                    }
                    ReportData[target.userID].ReportCount++;


                    ReportData[target.userID].complaint.Insert(0, ReasonReport);
                    SendChat(args.Player(), String.Format(lang.GetMessage("SKY_REPORT_REPORTING", this), target.displayName));
                    SendDiscordMsg("SKY_REPORT_REPORTING_VK_DISCORD", config.setting.servername, args.Player().displayName, target.displayName, target.userID, ReasonReport);
                    SendChatMessage("SKY_REPORT_REPORTING_VK_DISCORD", config.setting.servername, args.Player().displayName, target.displayName, target.userID, ReasonReport);
                    Metods_GiveCooldown(args.Player().userID, config.setting.Cooldown);
                    if (ReportData[target.userID].ReportCount > config.setting.maxreportcall)
                    {
                        if (config.setting.usemodercall == true)
                        {
                            for (int u = 0; u < BasePlayer.activePlayerList.Count; u++)
                            {
                                BasePlayer player = BasePlayer.activePlayerList[u];
                                if (permission.UserHasPermission(player.UserIDString, "SkyReportSystem.moderator"))
                                {
                                    SendChat(player, String.Format(lang.GetMessage("SKY_REPORT_MAXIMUM_REPORT", this), target, ReportData[target.userID].ReportCount));
                                    ModerAlertCheck(player, target);
                                    timer.Once(5f, () => { CuiHelper.DestroyUi(player, ModerAlert); });
                                }
                            }
                        }
                        if (config.setting.uselog == true)
                        {
                            LogToFile("SkyReportSystemLOG", $"Игрок {target} превысил максимальное количество репортов! [{ReportData[target.userID].ReportCount}]", this);
                        }
                        return;
                    }

                }
                else
                {
                    SendChat(args.Player(), lang.GetMessage("SKY_ERROR_PLAYER", this));
                }
                return;
            }
        }
        #endregion

        #region cui

        private void PlayerBanIPlayerModeration(BasePlayer player, BasePlayer targetinfoban)
        {
            CuiHelper.DestroyUi(player, "BanMunuReason");
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.168753 0.1509259", AnchorMax = "0.6302084 0.3185185" },
                Image = { FadeIn = 1f, Color = HexToCuiColor("#00000064") }
            }, "InfoPlayerSky", "BanMunuReason");

            #region BanReasonPanel


            for (int U = 0, x = 0, y = 0, i = 0; U < config.banReasons.Count; U++)
            {
                var reason = config.banReasons[U];
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{0.005902235 + (x * 0.33)} {0.6906075 - (y * 0.31)}", AnchorMax = $"{0.3318241 + (x * 0.33)} {0.9613256 - (y * 0.31)}" },
                    Button = { Command = $"Banplayers {targetinfoban.userID} {i}", Color = HexToCuiColor("#000000B2") },
                    Text = { Text = reason.BanReason, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 16 }
                }, "BanMunuReason");
                x++; i++;
                if (x == 3)
                {
                    x = 0;
                    y++;
                }

            }
            #endregion

            CuiHelper.AddUi(player, container);
        }

        private void ModerAlertCheck(BasePlayer player, BasePlayer target)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, ModerAlert);

            container.Add(new CuiPanel
            {
                FadeOut = 0.1f,
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "1 -150", OffsetMax = "230 -60" },
                Image = { Color = "0 0 0 0", FadeIn = 0.3f }
            }, "Overlay", ModerAlert);

            container.Add(new CuiElement
            {
                Parent = ModerAlert,
                Name = "AlerModer",
                FadeOut = 0.1f,
                Components =
                    {
                        new CuiImageComponent {  Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.3", Sprite = "assets/content/ui/ui.background.transparent.radial.psd", FadeIn = 0.3f  },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
            });

            container.Add(new CuiLabel
            {
                FadeOut = 0.1f,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Text = { Text = $"Игрок: {target.displayName}\nПревысил максимальное количевство жалоб! ", FontSize = 18, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, "AlerModer");

            CuiHelper.AddUi(player, container);

        }

        private void AlertPlayerCheck(BasePlayer player, BasePlayer moderinformation)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, PlayerAlert);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-200 150", OffsetMax = "180 300" },
                Image = { Color = "0 0 0 0" }
            }, "Overlay", PlayerAlert);

            container.Add(new CuiElement
            {
                Parent = PlayerAlert,
                Name = "MainAlert",
                Components =
                    {
                        new CuiImageComponent {  Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.5", Sprite = "assets/content/ui/ui.background.transparent.radial.psd"  },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.7644448", AnchorMax = "1 1", OffsetMax = "0 0" },
                Text = { Text = "Вас вызвали на проверку", FontSize = 19, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, "MainAlert");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.6311106", AnchorMax = "1 0.7422219", OffsetMax = "0 0.764444" },
                Text = { Text = "Вы обязаны предоставить Skype или Discord!", FontSize = 15, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, "MainAlert");

            if (player.userID == moderinformation.userID)
            {
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.0684208 0.05777803", AnchorMax = "0.9087719 0.6266667", OffsetMax = "0 0" },
                    Text = { Text = $"Kоманды :\n<color=orange>/skype</color> \n<color=orange>/discord</color>\nВызвавший модератор : НЕИЗВЕСТНО", FontSize = 17, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, "MainAlert");
            }
            else
            {
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.0684208 0.057778234", AnchorMax = "0.9087719 0.6266667", OffsetMax = "0 0" },
                    Text = { Text = $"Kоманды :\n<color=orange>/skype</color> \n<color=orange>/discord</color>\nВызвавший модератор : {moderinformation.displayName}", FontSize = 17, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, "MainAlert");
            }


            CuiHelper.AddUi(player, container);
        }

        private void SkyModerMenu(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, ModerMenuSky);
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = "0 0 0 0" }
            }, "Hud", ModerMenuSky);

            container.Add(new CuiElement
            {
                Parent = ModerMenuSky,
                Components =
                    {
                        new CuiImageComponent {   Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat",  Color = HexToCuiColor("#00000069")   },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "-100 -100", AnchorMax = "100 100" },
                Button = { Close = ModerMenuSky, Color = "0 0 0 0" },
                Text = { Text = "" }
            }, ModerMenuSky);

            #region title
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.2796874 0.9157416", AnchorMax = "0.7052073 0.968505" },
                Image = { Color = HexToCuiColor("#00000064") }
            }, ModerMenuSky, "TitlePanel");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Text = { Text = "Меню Модератора!", FontSize = 18, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, "TitlePanel");

            #endregion

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.2302083 0.2972222", AnchorMax = "0.7557291 0.8268524" },
                Image = { Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat", Color = HexToCuiColor("#423A3898") }
            }, ModerMenuSky, "MainPanelModer");

            container.Add(new CuiElement
            {
                Name = "playerlisd",
                Parent = "MainPanelModer",
                Components =
                    {
                        new CuiImageComponent { Color = "0 0 0 0" },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
            });

            #region PlayerList

            for (int x = 0, y = 0, i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                var mplayer = BasePlayer.activePlayerList[i];
                if (mplayer == null || !ReportData.ContainsKey(mplayer.userID) || mplayer.userID == player.userID) continue;
                if (ReportData[mplayer.userID].ReportCount >= config.setting.maxreportcall)
                {
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = $"{0.01333263 + (x * 0.245)} {0.9033457 - (y * 0.090)}", AnchorMax = $"{0.252307 + (x * 0.245)} {0.9758366 - (y * 0.090)}" },
                        Button = { Command = $"openinfoplayer chooseplayers {mplayer.userID}", Color = HexToCuiColor("#000000B2") },
                        Text = { Text = $"({mplayer.displayName})" + " [" + ReportData[mplayer.userID].ReportCount + "]", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 16 }
                    }, "playerlisd", "playerlisd" + $".Player.{i}.Text");

                    x++;
                    if (x == 4)
                    {
                        x = 0;
                        y++;

                        if (y == 11)
                        {
                            break;
                        }
                    }
                }
            }
            #endregion

            CuiHelper.AddUi(player, container);
        }

        private void playerinfomenu(BasePlayer player, string target, BasePlayer targetinfocheck)
        {
            #region SupportMetods
            string ImageAvatar = GetImage(target, 0);
            #endregion
            BasePlayer targets = BasePlayer.FindByID(ulong.Parse(target));
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, "MainPanelModer");


            container.Add(new CuiPanel
            {
                FadeOut = 0.5f,
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { FadeIn = 0.5f, Color = "0 0 0 0" },
            }, ModerMenuSky, "InfoPlayerSky");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "-100 -100", AnchorMax = "100 100" },
                Button = { Close = ModerMenuSky, Color = "0 0 0 0" },
                Text = { Text = "" }
            }, "InfoPlayerSky");



            container.Add(new CuiElement
            {
                Parent = "InfoPlayerSky",
                Components = {
                    new CuiRawImageComponent {
                        Png = ImageAvatar,
                        Url = null ,
                        Sprite = "assets/content/textures/generic/fulltransparent.tga"
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0.16875 0.5842593",
                        AnchorMax = "0.3151042 0.8796296"
                    },
                }
            });


            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.3229166 0.8203703", AnchorMax = "0.5739583 0.8740742" },
                Text = { Text = $"{targets.displayName} ({targets.UserIDString})", FontSize = 22, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "InfoPlayerSky");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.3203125 0.7574074", AnchorMax = "0.5020834 0.8037037" },
                Text = { Text = $"Количевство репортов: {ReportData[targetinfocheck.userID].ReportCount}", FontSize = 15, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "InfoPlayerSky");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.3203126 0.7101846", AnchorMax = "0.4828126 0.7564811" },
                Text = { Text = $"Количевство проверок: {ReportData[targetinfocheck.userID].CheckCount}", FontSize = 15, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "InfoPlayerSky");

            container.Add(new CuiPanel
            {
                FadeOut = 0.5f,
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0.6703124 0.462963", AnchorMax = "0.8505208 0.8925924" },
                Image = { FadeIn = 0.5f, Color = HexToCuiColor("#0000006E"), },
            }, "InfoPlayerSky", "captain");

            container.Add(new CuiElement
            {
                Parent = "captain",
                Components =
                    {
                        new CuiImageComponent { Color = HexToCuiColor("#FFFFFFFF") },
                        new CuiRectTransformComponent { AnchorMin = "0 0.886463", AnchorMax = "1 0.8886465" }
                    }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.03468214 0.8995634", AnchorMax = "0.9624277 0.9825329" },
                Text = { Text = "Последнии жалобы", FontSize = 16, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, "captain");

            int i = 0;
            for (int j = 0; j < ReportData[targets.userID].complaint.Count; j++)
            {
                var captainlist = ReportData[targets.userID].complaint[j];

                if (i <= 7)
                {
                    container.Add(new CuiElement
                    {
                        Parent = "captain",
                        Name = "listcap",
                        Components =
                        {
                            new CuiImageComponent { Color = HexToCuiColor("#FF7575BB"), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                            new CuiRectTransformComponent { AnchorMin =  $"0.0231214 {0.7758622 - (i * 0.107)}", AnchorMax = $"0.9739881 {0.8668124 - (i * 0.107)}" }
                        }
                    });

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                        Text = { Text = captainlist, FontSize = 17, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                    }, "listcap");
                    i++;
                }
                else
                {
                    break;
                }
            }

            if (!CheckPlayerModeration.ContainsKey(targetinfocheck.userID))
            {
                CuiHelper.DestroyUi(player, "StopPlayerBtn");
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.16875 0.5018519", AnchorMax = "0.315625 0.5722228" },
                    Button = { Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat", Color = HexToCuiColor("#33302F98"), Command = $"openinfoplayer checkinplayer {targetinfocheck.userID}" },
                    Text = { Text = "Bызвать на проверку", FontSize = 14, Align = TextAnchor.MiddleCenter }
                }, "InfoPlayerSky", "CheckPlayerBtn");
            }
            else if (CheckPlayerModeration.ContainsKey(targetinfocheck.userID) && CheckPlayerModeration.ContainsValue(player.userID) || player.IsAdmin)
            {
                CuiHelper.DestroyUi(player, "CheckPlayerBtn");
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.1686849 0.427109", AnchorMax = "0.315625 0.4972244" },
                    Button = { Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat", Color = HexToCuiColor("#33302F98"), Command = $"openinfoplayer stopcheckingplayers {targetinfocheck.userID}" },
                    Text = { Text = "Закончить проверку", FontSize = 14, Align = TextAnchor.MiddleCenter }
                }, "InfoPlayerSky", "StopPlayerBtn");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.1686849 0.351852", AnchorMax = "0.3156251 0.4224281" },
                    Button = { Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat", Color = HexToCuiColor("#33302F98"), Command = $"openinfoplayer moderatorcheckbanreason {targetinfocheck.userID}" },
                    Text = { Text = "Выдать блокировку", FontSize = 14, Align = TextAnchor.MiddleCenter }
                }, "InfoPlayerSky", "GoBanned");
            }
            else
            {
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.325 0.6064815", AnchorMax = "0.6682292 0.6990741", OffsetMax = "0 0" },
                    Text = { Text = String.Format(lang.GetMessage("SKY_PLAYER_CHECKING_MODER_MENU_MODERATION", this)), FontSize = 20, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, "InfoPlayerSky");
            }

            CuiHelper.AddUi(player, container);
        }

        private void SkyReportPlayers(BasePlayer player, string target = "", string reason = "")
        {
            CuiElementContainer container = new CuiElementContainer();

            if (target == "" && reason == "")
            {

                CuiHelper.DestroyUi(player, mainskymenu);

                container.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Image = { Color = "0 0 0 0" }
                }, "Hud", mainskymenu);

                container.Add(new CuiElement
                {
                    Parent = mainskymenu,
                    Components =
                    {
                        new CuiImageComponent { Color = HexToCuiColor("#000000B1") },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "-100 -100", AnchorMax = "100 100" },
                    Button = { Close = mainskymenu, Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, mainskymenu);


                #region title
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0.2796874 0.9157416", AnchorMax = "0.7052073 0.968505" },
                    Image = { Color = HexToCuiColor("#00000064") }
                }, mainskymenu, "TitlePanel");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Text = { Text = config.setting.teatletxt, FontSize = 18, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, "TitlePanel");

                #endregion

                #region infotxt

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.2322917 0.8472127", AnchorMax = "0.7520834 0.9027551" },
                    Text = { Text = lang.GetMessage("SKY_Menu_Info", this), FontSize = 17, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, mainskymenu);

                #endregion

                #region input

                container.Add(new CuiElement
                {
                    Parent = mainskymenu,
                    Name = mainskymenu + ".Input",
                    Components =
                    {
                        new CuiImageComponent { Color = HexToCuiColor("#423a38")},
                        new CuiRectTransformComponent { AnchorMin = "0.2385417 0.7777631", AnchorMax = "0.7458333 0.821279" },
                        new CuiOutlineComponent{Distance = "1.2 1.2", Color = HexToCuiColor("#FFFFFFFF"), UseGraphicAlpha = false}

                    }
                });

                container.Add(new CuiElement
                {
                    Parent = mainskymenu + ".Input",
                    Name = mainskymenu + ".Input.Current",
                    Components =
                    {
                        new CuiInputFieldComponent { FontSize = 16, Align = TextAnchor.MiddleCenter, Command = "SkyReportGo ", Text = "dsfsadf", Color = HexToCuiColor("#AFF9FFFF")},
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" },
                    }
                });
                #endregion

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0.238542 0.2740741", AnchorMax = "0.7463545 0.7722222" },
                    Image = { Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat", Color = HexToCuiColor("#423A3898") }
                }, mainskymenu, "playerslist");
            }

            if (target.Length != 17 && reason == "")
            {

                for (int i = 0; i < 44; i++)
                {
                    CuiHelper.DestroyUi(player, mainskymenu + $".ChoosePlayer.{i}");
                    CuiHelper.DestroyUi(player, mainskymenu + $".ChoosePlayer.{i}.Text");
                }

                for (int x = 0, y = 0, i = 0; i < BasePlayer.activePlayerList.Count; i++)
                {

                    var check = BasePlayer.activePlayerList[i];
                    if (check.displayName.ToLower().Contains(target.ToLower()))
                    {
                        string command = $"SkyReportGo chooseplayers {check.userID}";

                        container.Add(new CuiButton
                        {
                            FadeOut = 0.1f,
                            RectTransform = { AnchorMin = $"{0.01333263 + (x * 0.244)} {0.9033457 - (y * 0.089)}", AnchorMax = $"{0.252307 + (x * 0.244)} {0.9758366 - (y * 0.089)}" },
                            Button = { Command = command, Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat", Color = HexToCuiColor("#939391C8"), FadeIn = 0.4f },
                            Text = { Text = $"[{check.displayName}]", FontSize = 14, Align = TextAnchor.MiddleCenter },
                        }, "playerslist", "Button" + $".ChoosePlayer.{i}");

                        x++;
                        if (x == 4)
                        {
                            x = 0;
                            y++;

                            if (y == 11)
                            {
                                break;
                            }
                        }

                    }

                }
            }
            else
            {

                CuiHelper.DestroyUi(player, "buttoncap");
                CuiHelper.DestroyUi(player, "infotxt2");

                if (reason == "")
                {
                    container.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = "0.2385417 0.1064812", AnchorMax = "0.74583544 0.2185182" },
                        Image = { Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat", Color = HexToCuiColor("#423A3898") }
                    }, mainskymenu, "buttoncap");

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0.2333325 0.2203703", AnchorMax = "0.75 0.2648149" },
                        Text = { Text = "Далее вам нужно выбрать причину жалобы на данного игрока, или ввести свою", FontSize = 17, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                    }, mainskymenu, "infotxt2");

                    for (int x = 0, y = 0, i = 0, t = 0; i < config.Reasonsforcomplaint.Count; i++)
                    {
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = $"{0.009240265 + (x * 0.245)} {0.5289283 - (y * 0.45)}", AnchorMax = $"{0.2505133 + (x * 0.245)} {0.9173553 - (y * 0.45)}" },
                            Button = { Command = $"SkyReportGo {target.Replace(" ", "").Replace(" ", "").Replace(" ", "")} {i}", Color = HexToCuiColor("#939391C8"), Close = "buttoncap" + "infotxt2", Material = "assets/content/ui/uibackgroundblur.mat", FadeIn = 0.4f },
                            Text = { Text = config.Reasonsforcomplaint[i], Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 16 }
                        }, "buttoncap");

                        x++;
                        if (x == 4)
                        {
                            x = 0;
                            y++;
                        }
                        if (y == 2)
                        {
                            break;
                        }
                        t++;
                    }
                }
            }
            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region Help


        #region FindPlayer
        private BasePlayer FindPlayer(string nameOrId)
        {
            for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                var check = BasePlayer.activePlayerList[i];
                if (check.displayName.ToLower().Contains(nameOrId.ToLower()) || check.userID.ToString() == nameOrId)
                    return check;
            }
            return null;
        }

        #endregion

        #region IsAfk

        readonly Hash<ulong, Vector3> lastPosition = new Hash<ulong, Vector3>();
        public bool IsPlayerAfk(BasePlayer player)
        {
            if (player == null) return true;
            var last = lastPosition[player.userID];
            var current = player.transform.position;

            if (last.x.Equals(current.x)) return true;
            lastPosition[player.userID] = current;

            return false;
        }
        #endregion

        #region Hex
        private static string HexToCuiColor(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException(" Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }

        #endregion

        #region reply
        public void SendChat(BasePlayer player, string Message, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            if (IQChat)
                IQChat?.Call("API_ALERT_PLAYER", player, Message, config.setting.prefix, config.setting.avatarid.ToString());
            else player.SendConsoleCommand("chat.add", channel, 0, Message);
        }
        #endregion

        #region VK
        private void SendChatMessage(string msg, params object[] args)
        {
            if (!config.vKontakte.UseVK) return;

            string vkchat = string.Format(lang.GetMessage(msg, this), args);
            int RandomID = UnityEngine.Random.Range(0, 99999);
            while (vkchat.Contains("#"))
                vkchat = vkchat.Replace("#", "%23");
            webrequest.Enqueue($"https://api.vk.com/method/messages.send?chat_id={config.vKontakte.VK_ChatID}&random_id={RandomID}&message={vkchat}&access_token={config.vKontakte.VK_Token}&v=5.90", null, (code, response) => { }, this);
        }

        #endregion

        #region discord

        #region FancyDiscord
        public class FancyMessage
        {
            public string content { get; set; }
            public bool tts { get; set; }
            public Embeds[] embeds { get; set; }

            public class Embeds
            {
                public string title { get; set; }
                public int color { get; set; }
                public List<Fields> fields { get; set; }
                public Footer footer { get; set; }
                public Authors author { get; set; }

                public Embeds(string title, int color, List<Fields> fields, Authors author, Footer footer)
                {
                    this.title = title;
                    this.color = color;
                    this.fields = fields;
                    this.author = author;
                    this.footer = footer;

                }
            }

            public FancyMessage(string content, bool tts, Embeds[] embeds)
            {
                this.content = content;
                this.tts = tts;
                this.embeds = embeds;
            }

            public string toJSON() => JsonConvert.SerializeObject(this);
        }

        public class Footer
        {
            public string text { get; set; }
            public string icon_url { get; set; }
            public string proxy_icon_url { get; set; }
            public Footer(string text, string icon_url, string proxy_icon_url)
            {
                this.text = text;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        public class Authors
        {
            public string name { get; set; }
            public string url { get; set; }
            public string icon_url { get; set; }
            public string proxy_icon_url { get; set; }
            public Authors(string name, string url, string icon_url, string proxy_icon_url)
            {
                this.name = name;
                this.url = url;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        public class Fields
        {
            public string name { get; set; }
            public string value { get; set; }
            public bool inline { get; set; }
            public Fields(string name, string value, bool inline)
            {
                this.name = name;
                this.value = value;
                this.inline = inline;
            }
        }

        private void Request(string url, string payload, Action<int> callback = null)
        {
            Dictionary<string, string> header = new Dictionary<string, string>();
            header.Add("Content-Type", "application/json");
            webrequest.Enqueue(url, payload, (code, response) =>
            {
                if (code != 200 && code != 204)
                {
                    if (response != null)
                    {
                        try
                        {
                            JObject json = JObject.Parse(response);
                            if (code == 429)
                            {
                                float seconds = float.Parse(Math.Ceiling((double)(int)json["retry_after"] / 1000).ToString());
                            }
                            else
                            {
                                PrintWarning($" Discord rejected that payload! Responded with \"{json["message"].ToString()}\" Code: {code}");
                            }
                        }
                        catch
                        {
                            PrintWarning($"Failed to get a valid response from discord! Error: \"{response}\" Code: {code}");
                        }
                    }
                    else
                    {
                        PrintWarning($"Discord didn't respond (down?) Code: {code}");
                    }
                }
                try
                {
                    callback?.Invoke(code);
                }
                catch (Exception ex) { }

            }, this, RequestMethod.POST, header);
        }
        #endregion

        void SendDiscordMsg(string key, params object[] args)
        {
            if (!config.discord.UseDiscord) return;
            if (String.IsNullOrEmpty(config.discord.Discord_webHook)) return;

            string msg = string.Format(lang.GetMessage(key, this), args);

            List<Fields> fields = new List<Fields>
            {
                    new Fields("SkyReportSystem", msg, true),
            };

            FancyMessage newMessage = new FancyMessage(null, true, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, 16775936, fields, new Authors("SkyReportSystem", "https://skyplugins.ru/", "https://i.imgur.com/ILk3uJc.png", null), new Footer("Author: DezLife", "https://i.imgur.com/ILk3uJc.png", null)) });
            Request($"{config.discord.Discord_webHook}", newMessage.toJSON());
        }

        #endregion

        #endregion

        #region DataWorkerModule

        private void LoadData<T>(string name, ref T data, bool enableSaving)
        {
            string resultName = this.Name + $"/{name}";

            if (Interface.Oxide.DataFileSystem.ExistsDatafile(resultName))
            {
                data = Interface.Oxide.DataFileSystem.ReadObject<T>(resultName);
            }
            else
            {
                Interface.Oxide.DataFileSystem.WriteObject(resultName, data);
            }

            if (enableSaving)
            {
                SaveData(name, data);
            }
        }

        private void SaveData<T>(string name, T data)
        {
            string resultName = this.Name + $"/{name}";

            Interface.Oxide.DataFileSystem.WriteObject(resultName, data);
        }

        #endregion
    }
}


// --- End of file: SkyReportSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TsunHorse.cs ---
// --- Original Local Path: TsunHorse.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using UnityEngine;
using System.Linq;
using System.Globalization;
using System.Text;
using Facepunch;

namespace Oxide.Plugins
{
    [Info("TsunHorse", "k1lly0u", "3.0.1", ResourceId = 0)]
    class TsunHorse : RustPlugin
    {
        #region Fields  
        private StoredData storedData;
        private DynamicConfigFile data;

        private List<Controller> controllers = new List<Controller>();
        private static TsunHorse ins = null;

        const string chairPrefab = "assets/prefabs/vehicle/seats/passengerchair.prefab";
        const string animalPrefab = "assets/rust.ai/agents/{0}/{0}.prefab";
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            permission.RegisterPermission("tsunhorse.stophorse", this);
            permission.RegisterPermission("tsunhorse.ridehorse", this);
            permission.RegisterPermission("tsunhorse.spawnhorse", this);
            lang.RegisterMessages(Messages, this);

            data = Interface.Oxide.DataFileSystem.GetFile("tsunhorse_cooldowns");

            ins = this;

            LoadData();
        }

        private void OnServerSave() => SaveData();
     
        private void Unload()
        {
            for (int i = controllers.Count - 1; i >= 0; i--)
            {
                Controller controller = controllers[i];
                controller.Player.DismountObject();
                UnityEngine.Object.Destroy(controller);
            }
            ins = null;
        }

        private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null)
                return null;

            BaseNpc baseNpc = entity.GetComponent<BaseNpc>();
            if (baseNpc == null)
                return null;

            AnimalController animalController = entity.GetComponent<AnimalController>();
            if (animalController == null)
            {
                if (configData.Command.Invulnerable)
                {
                    if (!baseNpc.GetNavAgent.enabled && (!baseNpc.Entity?.GetComponent<Apex.AI.Components.UtilityAIComponent>()?.enabled ?? false))
                        return true;
                }
                return null;
            }

            if (configData.Settings.Invulnerable)
                return true;

            return false;
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null)
                return;

            AnimalController animalController = entity.GetComponent<AnimalController>();
            if (animalController != null)
            {
                if (animalController.Human != null)
                {
                    animalController.Human.Player.DismountObject();
                    UnityEngine.Object.Destroy(animalController.Human);
                }
                UnityEngine.Object.Destroy(animalController);
                return;
            }

            Controller controller = entity.GetComponent<Controller>();
            if (controller != null)
            {
                controller.Player.DismountObject();
                UnityEngine.Object.Destroy(controller);
            }
        }

        private void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (player == null || !permission.UserHasPermission(player.UserIDString, "tsunhorse.ridehorse") || player.isMounted) return;

            if (input.WasJustPressed(BUTTON.USE))
            {
                RaycastHit hit;
                if (Physics.SphereCast(player.eyes.position, 0.5f, Quaternion.Euler(player.serverInput.current.aimAngles) * Vector3.forward, out hit, 1.5f))
                {
                    BaseNpc baseNpc = hit.GetEntity()?.GetComponent<BaseNpc>();
                    if (baseNpc == null)
                        return;

                    if (!configData.Settings.AllowedTypes.Any(x => x.Contains(baseNpc.ShortPrefabName, CompareOptions.IgnoreCase)))
                    {
                        SendReply(player, msg("Warning.InvalidType", player.UserIDString));
                        return;
                    }

                    if (baseNpc.health <= 1)
                    {
                        SendReply(player, msg("Warning.NearDeath", player.UserIDString));
                        return;
                    }

                    if (baseNpc.GetComponent<AnimalController>())
                    {
                        SendReply(player, msg("Warning.InUse", player.UserIDString));
                        return;
                    }

                    Controller controller = player.gameObject.AddComponent<Controller>();
                    controller.MountToNpc(baseNpc);
                    controllers.Add(controller);
                }
            }            
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            Controller controller = player.GetComponent<Controller>();
            if (controller == null)
                return;

            controllers.Remove(controller);
            UnityEngine.Object.Destroy(controller);
        }

        private void OnEntityDismounted(BaseMountable mountable, BasePlayer player)
        {
            Controller controller = player.GetComponent<Controller>();
            if (controller == null)
                return;
           
            controllers.Remove(controller);
            UnityEngine.Object.Destroy(controller);
        }

        private object CanAnimalAttack(BaseNpc entity, BasePlayer player)
        {
            AnimalController animalController = entity.GetComponent<AnimalController>();
            if (animalController != null)
                return false;
            return null;
        }

        private object CanNPCEat(BaseNpc entity, BaseEntity target)
        {
            AnimalController animalController = entity.GetComponent<AnimalController>();
            if (animalController != null)
                return false;
            return null;
        }

        private object OnNpcTarget(BaseNpc entity, BaseEntity target)
        {
            AnimalController animalController = entity.GetComponent<AnimalController>();
            if (animalController != null)
                return false;
            return null;
        }
        #endregion

        #region Functions
        private static double CurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;

        private string FormatTime(double time)
        {
            TimeSpan dateDifference = TimeSpan.FromSeconds((float)time);
            int days = dateDifference.Days;
            int hours = dateDifference.Hours;
            int mins = dateDifference.Minutes;
            int secs = dateDifference.Seconds;

            if (days > 0)
                return string.Format("{0:00}d:{1:00}h:{2:00}m:{3:00}s", days, hours, mins, secs);
            else if (hours > 0)
                return string.Format("{0:00}h:{1:00}m:{2:00}s", hours, mins, secs);
            else if (mins > 0)
                return string.Format("{0:00}m:{1:00}s", mins, secs);
            else return string.Format("{0}s", secs);
        }

        private bool SpawnAnimal(string type, Vector3 position, out BaseNpc baseNpc)
        {
            Vector3 point;
            if (FindPointOnNavmesh(position, 1, out point))
            {
                baseNpc = InstantiateEntity(string.Format(animalPrefab, type), point) as BaseNpc;
                if (baseNpc == null)
                    return false;

                baseNpc.Spawn();                
                return true;
            }
            baseNpc = null;
            return false;
        }

        private BaseEntity InstantiateEntity(string type, Vector3 position)
        {
            var gameObject = Instantiate.GameObject(GameManager.server.FindPrefab(type), position, new Quaternion());
            gameObject.name = type;

            UnityEngine.SceneManagement.SceneManager.MoveGameObjectToScene(gameObject, Rust.Server.EntityScene);

            UnityEngine.Object.Destroy(gameObject.GetComponent<Spawnable>());

            if (!gameObject.activeSelf)
                gameObject.SetActive(true);

            BaseEntity component = gameObject.GetComponent<BaseEntity>();
            return component;
        }

        private bool FindPointOnNavmesh(Vector3 center, float range, out Vector3 result)
        {
            for (int i = 0; i < 30; i++)
            {
                Vector3 randomPoint = center + UnityEngine.Random.insideUnitSphere * range;
                UnityEngine.AI.NavMeshHit hit;
                if (UnityEngine.AI.NavMesh.SamplePosition(randomPoint, out hit, 5f, UnityEngine.AI.NavMesh.AllAreas))
                {
                    result = hit.position;
                    return true;
                }
            }
            result = Vector3.zero;
            return false;
        }
        #endregion

        #region Controller
        private class Controller : MonoBehaviour
        {
            public BasePlayer Player { get; private set; }
            public AnimalController Animal { get; private set; }

            public ConfigData.RidingSettings config;

            private float acceleration = 0f;
            private float steering = 0f;
            private bool sprint = false;

            private Vector3 targetPosition;

            private void Awake()
            {
                Player = GetComponent<BasePlayer>();
                enabled = false;

                config = ins.configData.Settings;
                InvokeHandler.InvokeRepeating(this, BlockTargeting, 5f, 5f);                
            }

            private void BlockTargeting()
            {
                Animal.Npc.BlockEnemyTargeting(5f);
                Animal.Npc.BlockFoodTargeting(5f);
                
                InvokeHandler.Invoke(this, BlockTargeting, 5f);
            }

            public void FixedUpdate()
            {
                if (Player == null || Animal == null || Animal.Npc == null)
                    return;
               
                Animal.Npc.AutoBraking = false;               

                Animal.Npc.IsDormant = false;
                Animal.Npc.IsStopped = false;

                if (acceleration == 0 && steering == 0)
                {
                    Animal.Npc.IsStopped = true;
                    Animal.Npc.SetFact(BaseNpc.Facts.CanTargetFood, 0, true, true);
                    Animal.Npc.ToSpeedEnum(0);

                    Animal.TargetSpeed = 0;
                }

                Animal.TargetSpeed = sprint ? Animal.stats.Sprint : Animal.stats.Walk;

                Animal.Npc.SetFact(BaseNpc.Facts.Speed, (byte)(sprint ? BaseNpc.SpeedEnum.Run : BaseNpc.SpeedEnum.Walk), true, true);

                Transform trans = Animal.Npc.transform;
                
                Vector3 steerPos = ((trans.rotation * Vector3.right) * steering) * 0.75f;
                Vector3 accelPos = ((trans.rotation * Vector3.forward) * acceleration) * 5f;

                targetPosition = trans.position + steerPos + (acceleration > 0 ? accelPos : trans.forward);

                Animal.Npc.UpdateDestination(targetPosition);
            }           

            public void LateUpdate()
            {
                InputState input = Player.serverInput;

                if (input.WasJustPressed(BUTTON.JUMP))
                {
                    enabled = false;
                    Destroy(this);
                    return;
                }

                sprint = input.IsDown(BUTTON.SPRINT);
                acceleration = input.IsDown(BUTTON.FORWARD) ? 1f : 0f;
                steering = input.IsDown(BUTTON.LEFT) ? -1f : input.IsDown(BUTTON.RIGHT) ? 1f : 0f;

                if (input.WasJustPressed(BUTTON.FIRE_THIRD))
                    Player.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, !Player.HasPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode));
            }

            public void OnDestroy()
            {
                if (Player != null)
                {
                    if (Player.isMounted)
                        Player.DismountObject();                    
                    Player.EnsureDismounted();
                    Player.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, false);
                    Player.MovePosition(Animal.transform.position + (Animal.transform.right * 1.5f));
                }

                if (ins.controllers.Contains(this))
                    ins.controllers.Remove(this);

                Destroy(Animal);
            }

            public void MountToNpc(BaseNpc baseNpc)
            {
                Animal = baseNpc.gameObject.AddComponent<AnimalController>();
                Animal.CreateMountable(this);
                Player.MountObject(Animal.Mountable);
                Animal.Npc.Resume();
                enabled = true;

                Player.ChatMessage(msg("Help.Controls1", Player.UserIDString));

                BlockTargeting();

                InvokeHandler.InvokeRepeating(this, UpdatePosition, 0, 2);
            }

            private void UpdatePosition()
            {
                Player.transform.position = Animal.Mountable.transform.position;                
            }
        }

        private class AnimalController : MonoBehaviour
        {
            public BaseNpc Npc { get; private set; }
            public BaseMountable Mountable { get; private set; }
            public Controller Human { get; private set; }

            public float TargetSpeed { get; set; }

            public ConfigData.SpeedSettings stats;            

            private void Awake()
            {
                Npc = GetComponent<BaseNpc>();
                enabled = false;
                Npc.Pause();
                Npc.NewAI = false;

                Npc.CancelInvoke(Npc.TickAi);
                AnimalSensesLoadBalancer.animalSensesLoadBalancer.Remove(Npc);

                stats = ins.configData.Speeds[Npc.ShortPrefabName];

                Npc.InvokeRandomized(new Action(this.TickAi), 0.1f, 0.1f, 0.00500000035f);
            }

            public void CreateMountable(Controller controller)
            {
                this.Human = controller;

                Mountable = GameManager.server.CreateEntity(chairPrefab, Npc.transform.position, new Quaternion()) as BaseMountable;
                Mountable.enableSaving = false;
                Mountable.isMobile = true;
                Mountable.skinID = 1169930802;
                Mountable.maxMountDistance = 1.5f;

                Mountable.Spawn();
                Mountable.isMobile = true;
                Destroy(Mountable.GetComponent<DestroyOnGroundMissing>());
                Destroy(Mountable.GetComponent<GroundWatch>());
                Mountable.GetComponent<MeshCollider>().convex = true;

                Mountable.SetParent(Npc);

                KeyValuePair<Vector3, Vector3> offset;
                if (ins.mountingPositions.TryGetValue(Npc.ShortPrefabName, out offset))
                {
                    Mountable.transform.localPosition = offset.Key;
                    Mountable.transform.localEulerAngles = offset.Value;
                }
                Npc.Resume();
            }

            private void TickAi()
            {
                if (TerrainMeta.WaterMap == null)
                {
                    Npc.wasSwimming = false;
                    Npc.swimming = false;
                    Npc.waterDepth = 0f;
                }
                else
                {
                    Npc.waterDepth = TerrainMeta.WaterMap.GetDepth(Npc.ServerPosition);
                    Npc.wasSwimming = Npc.swimming;
                    Npc.swimming = Npc.waterDepth > Npc.Stats.WaterLevelNeck * 0.25f;
                }

                Npc.TickNavigation();
                
                if (Npc.GetNavAgent.enabled)
                {
                    TickSpeed();                    
                }
            }

            private void TickSpeed()
            {
                float speed = TargetSpeed;               
                
                float single = Mathf.Min(Npc.NavAgent.speed / stats.Sprint, 1f);
                Vector3 vector3 = Npc.transform.forward;
                Vector3 navAgent = Npc.NavAgent.nextPosition - Npc.ServerPosition;
                float single1 = 1f - 0.9f * Vector3.Angle(vector3, navAgent.normalized) / 180f * single * single;
                speed *= single1;
                Npc.NavAgent.speed = Mathf.Lerp(Npc.NavAgent.speed, speed, 0.5f);
                Npc.NavAgent.angularSpeed = 1f * (1.1f - single);
                Npc.NavAgent.acceleration = Npc.Stats.Acceleration;
            }

            private void OnDestroy()
            {               
                if (Mountable != null && !Mountable.IsDestroyed)
                {
                    if (Mountable.IsMounted())
                        Mountable.DismountAllPlayers();

                    Mountable.Kill(BaseNetworkable.DestroyMode.None);
                }

                if (Npc != null && !Npc.IsDestroyed)
                {
                    AnimalSensesLoadBalancer.animalSensesLoadBalancer.Add(Npc);
                    Npc.CancelInvoke(TickAi);

                    Npc.InvokeRandomized(Npc.TickAi, 0.1f, 0.1f, 0.00500000035f);

                    Npc.StopMoving();
                    Npc.Pause();

                    Npc.Invoke(Npc.Resume, 30f);
                }
            }
        }

        private Dictionary<string, KeyValuePair<Vector3, Vector3>> mountingPositions = new Dictionary<string, KeyValuePair<Vector3, Vector3>>
        {
            ["horse"] = new KeyValuePair<Vector3, Vector3>(new Vector3(0, 0.6f, 0.2f), new Vector3(0, 0, 0)),
            ["stag"] = new KeyValuePair<Vector3, Vector3>(new Vector3(0, 0.35f, 0.1f), new Vector3(0, 0, 0)),
            ["chicken"] = new KeyValuePair<Vector3, Vector3>(new Vector3(0, 0, 0), new Vector3(0, 0, 0)),
            ["wolf"] = new KeyValuePair<Vector3, Vector3>(new Vector3(0, 0.1f, 0.2f), new Vector3(0, 0, 0)),
            ["bear"] = new KeyValuePair<Vector3, Vector3>(new Vector3(0, 0.6f, 0), new Vector3(0, 0, 0)),
            ["boar"] = new KeyValuePair<Vector3, Vector3>(new Vector3(0, 0.1f, 0.1f), new Vector3(0, 0, 0)),
        };
        #endregion

        #region Commands
        [ChatCommand("spawnhorse")]
        private void cmdSpawn(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "tsunhorse.spawnhorse"))
            {
                SendReply(player, msg("Error.NoPermission", player.UserIDString));
                return;
            }

            if (args.Length == 0)
            {
                SendReply(player, msg("Help.Spawn", player.UserIDString));
                SendReply(player, string.Format(msg("Help.AvailableTypes", player.UserIDString), configData.Settings.AllowedTypes.ToSentence()));
                return;
            }

            string type = args[0].ToLower();
            if (!configData.Settings.AllowedTypes.Contains(type))
            {
                SendReply(player, msg("Error.InvalidAnimal", player.UserIDString) + " " + string.Format(msg("Help.AvailableTypes", player.UserIDString), configData.Settings.AllowedTypes.ToSentence()));
                return;
            }

            double remaining = 0;
            double current = CurrentTime();

            StoredData.Cooldown cooldown;

            if (storedData.cooldowns.TryGetValue(player.userID, out cooldown))
            {
                remaining = cooldown.GetValue(true);

                if (remaining > current)
                {
                    double time = remaining - current;
                    SendReply(player, string.Format(msg("Error.Cooldown", player.UserIDString), FormatTime(time)));
                    return;
                }
            }

            BaseNpc baseNpc;
            if (!SpawnAnimal(type, player.transform.position, out baseNpc))
            {
                SendReply(player, msg("Error.InvalidPosition", player.UserIDString));
                return;
            }

            baseNpc.Resume();
            timer.In(2f, () =>
            {
                if (baseNpc != null)
                {
                    baseNpc.StopMoving();
                    baseNpc.Pause();
                }
            });

            if (storedData.cooldowns.ContainsKey(player.userID))
                storedData.cooldowns[player.userID].Spawn = current + configData.Command.SpawnCooldown;
            else storedData.cooldowns.Add(player.userID, new StoredData.Cooldown(0, configData.Command.SpawnCooldown));

            SendReply(player, string.Format(msg("Msg.SpawnSuccess", player.UserIDString), type));
        }

        [ChatCommand("stop")]
        private void cmdStop(BasePlayer player, string command, string[] args)
        {
            if (!configData.Command.Command)
                return;

            if (!permission.UserHasPermission(player.UserIDString, "tsunhorse.stophorse"))
            {
                SendReply(player, msg("Error.NoPermission", player.UserIDString));
                return;
            }

            double remaining = 0;
            double current = CurrentTime();

            StoredData.Cooldown cooldown;

            if (storedData.cooldowns.TryGetValue(player.userID, out cooldown))
            {
                remaining = cooldown.GetValue(false);

                if (remaining > current)
                {
                    double time = remaining - current;
                    SendReply(player, string.Format(msg("Error.Cooldown", player.UserIDString), FormatTime(time)));
                    return;
                }
            }
          
            List<BaseNpc> entities = Pool.GetList<BaseNpc>();
            Vis.Entities<BaseNpc>(player.transform.position, configData.Command.StopRadius, entities);
            int count = 0;
            foreach(BaseNpc baseNpc in entities.Distinct())
            {
                if (baseNpc.GetComponent<AnimalController>())
                    continue;

                if (configData.Settings.AllowedTypes.Any(x => x.Contains(baseNpc.ShortPrefabName, CompareOptions.IgnoreCase)))
                {
                    count++;
                    baseNpc.StopMoving();
                    baseNpc.Pause();

                    timer.In(configData.Command.StopTime, () => baseNpc?.Resume());
                }
            }
            Pool.FreeList(ref entities);
            if (count > 0)
            {
                if (storedData.cooldowns.ContainsKey(player.userID))
                    storedData.cooldowns[player.userID].Stop = current + configData.Command.StopCooldown;
                else storedData.cooldowns.Add(player.userID, new StoredData.Cooldown(configData.Command.StopCooldown, 0));

                SendReply(player, string.Format(msg("Help.StoppedAnimals", player.UserIDString), count));
            }
            else SendReply(player, msg("Help.NoStoppedAnimals", player.UserIDString));
        }
        #endregion

        #region Config        
        private ConfigData configData;
        private class ConfigData
        {
            public RidingSettings Settings { get; set;}
            public CommandSettings Command { get; set; }
            public Dictionary<string, SpeedSettings> Speeds { get; set; }

            public class RidingSettings
            {
                [JsonProperty(PropertyName = "Allowed animal types (Horse, Bear, Boar, Chicken, Stag, Wolf)")]
                public string[] AllowedTypes { get; set; }
                [JsonProperty(PropertyName = "Are animals invincible when being ridden")]
                public bool Invulnerable { get; set; }
                [JsonProperty(PropertyName = "Allow third person toggle (middle mouse button)")]
                public bool ThirdPersonHotkey { get; set; } 
            }

            public class CommandSettings
            {
                [JsonProperty(PropertyName = "Stop command cooldown time (seconds)")]
                public int StopCooldown { get; set; }
                [JsonProperty(PropertyName = "Spawn command cooldown time (seconds)")]
                public int SpawnCooldown { get; set; }
                [JsonProperty(PropertyName = "Enable command to stop animals within radius")]
                public bool Command { get; set; }
                [JsonProperty(PropertyName = "Radius in which to stop nearby animals")]
                public int StopRadius { get; set; }
                [JsonProperty(PropertyName = "Are animals invincible whilst stopped")]
                public bool Invulnerable { get; set; }
                [JsonProperty(PropertyName = "Amount of time animals stay stopped")]
                public int StopTime { get; set; }
            }

            public class SpeedSettings
            {
                [JsonProperty(PropertyName = "Walking speed")]
                public float Walk;
                [JsonProperty(PropertyName = "Sprinting speed")]
                public float Sprint;                
            }
            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Command = new ConfigData.CommandSettings
                {
                    Command = true,
                    StopCooldown = 30,
                    SpawnCooldown = 3600,
                    StopRadius = 10,
                    Invulnerable = true,
                    StopTime = 10
                },
                Settings = new ConfigData.RidingSettings
                {
                    AllowedTypes = new string[] { "horse", "chicken" },
                    Invulnerable = true,                    
                    ThirdPersonHotkey = true,
                },
                Speeds = new Dictionary<string, ConfigData.SpeedSettings>
                {
                    ["bear"] = new ConfigData.SpeedSettings
                    {
                        Walk = 1.8f,
                        Sprint = 8f,
                    },
                    ["boar"] = new ConfigData.SpeedSettings
                    {
                        Walk = 1.4f,
                        Sprint = 7f,
                    },
                    ["chicken"] = new ConfigData.SpeedSettings
                    {
                        Walk = 0.4f,
                        Sprint = 2f,
                    },
                    ["horse"] = new ConfigData.SpeedSettings
                    {
                        Walk = 2.4f,
                        Sprint = 12f,
                    },
                    ["stag"] = new ConfigData.SpeedSettings
                    {
                        Walk = 2.2f,
                        Sprint = 11f,
                    },
                    ["wolf"] = new ConfigData.SpeedSettings
                    {
                        Walk = 1.8f,
                        Sprint = 9f,
                    }
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new VersionNumber(3, 0, 1))
            {
                configData.Command.Invulnerable = true;
                configData.Command.StopTime = 10;
                configData.Command.SpawnCooldown = 3600;
                configData.Command.StopCooldown = 30;

                configData.Speeds = baseConfig.Speeds;
            }

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion

        #region Data Management
        private void SaveData() => data.WriteObject(storedData);

        private void LoadData()
        {
            try
            {
                storedData = data.ReadObject<StoredData>();
            }
            catch
            {
                storedData = new StoredData();
            }
        }

        private class StoredData
        {
            public Dictionary<ulong, Cooldown> cooldowns = new Dictionary<ulong, Cooldown>();
            
            public class Cooldown
            {
                public double Stop { get; set; }
                public double Spawn { get; set; }

                public Cooldown() { }

                public Cooldown(double stop, double spawn)
                {
                    this.Stop = stop;
                    this.Spawn = spawn;
                }

                public double GetValue(bool isSpawn) => isSpawn ? Spawn : Stop;
            }
        }
        #endregion

        #region Localization
        private static string msg(string key, string playerId = null) => ins.lang.GetMessage(key, ins, playerId);

        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["Help.Controls1"] = "<color=#ce422b>Animal Controls:\nForward</color> - Move Forward\n<color=#ce422b>Left/Right</color> - Turn\n<color=#ce422b>Sprint</color> - Sprint\n<color=#ce422b>Jump</color> - Dismount animal",
            ["Help.StoppedAnimals"] = "You have temporarily stopped <color=#ce422b>{0}</color> animal(s)!",
            ["Help.NoStoppedAnimals"] = "<color=#ce422b>There are no animals nearby...</color>",
            ["Help.Spawn"] = "<color=#ce422b>/spawnhorse <type></color> - Spawn a animal you can ride",
            ["Help.AvailableTypes"] = "Available types are; <color=#ce422b>{0}</color>",
            ["Msg.SpawnSuccess"] = "You have spawned a <color=#ce422b>{0}</color>! You can mount it by looking at it and pressing the <color=#ce422b>USE</color> key",
            ["Error.InvalidPosition"] = "<color=#ce422b>Unable to spawn a animal at this position</color>",
            ["Error.InvalidAnimal"] = "<color=#ce422b>Invalid animal type selected!</color>",
            ["Error.NoPermission"] = "<color=#ce422b>You do not have permission to use this command</color>",
            ["Error.Cooldown"] = "You have a cooldown of <color=#ce422b>{0}</color> remaining",
            ["Warning.InvalidType"] = "<color=#ce422b>That animal is not rideable</color>",
            ["Warning.NearDeath"] = "<color=#ce422b>That animal is nearing death...</color>",
            ["Warning.InUse"] = "<color=#ce422b>That animal already has someone riding it</color>"
        };
        #endregion
    }   
}


// --- End of file: TsunHorse.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Statistics.cs ---
// --- Original Local Path: Statistics.cs ---

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Facepunch.Math;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Statistics", "oxide-russia.ru", "0.1.5")]
    [Description("Statistics")]
    public class Statistics : RustPlugin
    {
        [PluginReference]
        Plugin ImageLibrary;
        private StoredData DataBase = new StoredData();
        public ulong lastDamageName;
        public string GetImage(string shortname, ulong skin = 0) => (string)ImageLibrary?.Call("GetImage", shortname, skin);

        #region Config

        private static ConfigFile config;

        public class ConfigFile
        {
            [JsonProperty(PropertyName = "StatsCmd")]
            public string StatsCmd { get; set; } = "stats";
            
            [JsonProperty(PropertyName = "ServerNAME")]
            public string ServerName { get; set; } = "YourServerName";
            
            [JsonProperty(PropertyName = "MainHeaderColor")]
            public string MainHeaderColor { get; set; } = "#C6C6C6FF";
            
            [JsonProperty(PropertyName = "MainHeaderButtonColor")]
            public string MainHeaderButtonColor { get; set; } = "#969696FF";
            
            [JsonProperty(PropertyName = "MainHeaderButtonEdgeColor")]
            public string MainHeaderButtonEdgeColor { get; set; } = "#C6C6C6FF";
            
            [JsonProperty(PropertyName = "MainHeaderButtonCloseColor")]
            public string MainHeaderButtonCloseColor { get; set; } = "#969696FF";
            
            [JsonProperty(PropertyName = "PlayerStatsHeaderColor1")]
            public string PlayerStatsHeaderColor1 { get; set; } = "#969696FF";
            
            [JsonProperty(PropertyName = "PlayerStatsHeaderColor2")]
            public string PlayerStatsHeaderColor2 { get; set; } = "#C6C6C6FF";
            
            [JsonProperty(PropertyName = "PlayerStatsBlocColor1")]
            public string PlayerStatsBlocColor1 { get; set; } = "#C6C6C6FF";
            
            [JsonProperty(PropertyName = "PlayerStatsBlocColor2")]
            public string PlayerStatsBlocColor2 { get; set; } = "#969696FF";
            
            [JsonProperty(PropertyName = "PlayerStatsProfileLineColor")]
            public string PlayerStatsProfileLineColor { get; set; } = "#C6C6C6FF";
            
            [JsonProperty(PropertyName = "PlayerStatsTextColor")]
            public string PlayerStatsTextColor { get; set; } = "#FFFFFFFF"; 
            
            [JsonProperty(PropertyName = "ServerStatsButtonsUpLine")]
            public string ServerStatsButtonsUpLine { get; set; } = "#C6C6C6FF";  
            
            [JsonProperty(PropertyName = "ServerStatsButtonsDownLine")]
            public string ServerStatsButtonsDownLine { get; set; } = "#C6C6C6FF";   
            
            [JsonProperty(PropertyName = "ServerStatsButtonsColor")]
            public string ServerStatsButtonsColor { get; set; } = "#969696FF"; 
            
            [JsonProperty(PropertyName = "ServerStatsButtonsEdgeColor")]
            public string ServerStatsButtonsEdge { get; set; } = "#C6C6C6FF"; 
            
            [JsonProperty(PropertyName = "ServerStatsTopColor1")]
            public string ServerStatsTopColor1 { get; set; } = "#C6C6C6FF"; 
            
            [JsonProperty(PropertyName = "ServerStatsTopColor2")]
            public string ServerStatsTopColor2 { get; set; } = "#969696FF";  
            
            [JsonProperty(PropertyName = "ServerStatsTopEdgeColor")]
            public string ServerStatsTopEdgeColor { get; set; } = "#FFFFFFFF"; 
            
            [JsonProperty(PropertyName = "ServerStatsTextColor")]
            public string ServerStatsTextColor { get; set; } = "#FFFFFFFF"; 
            
            [JsonProperty(PropertyName = "ServerStatsTopTextColor1")]
            public string ServerStatsTopTextColor1 { get; set; } = "#FFFFFFFF"; 
            
            [JsonProperty(PropertyName = "ServerStatsTopTextColor2")]
            public string ServerStatsTopTextColor2 { get; set; } = "#FFFFFFFF"; 
            
        }
        protected override void SaveConfig() => Config.WriteObject(config); 
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<ConfigFile>();
                if (config == null)
                    Regenerate();
            }
            catch { Regenerate(); }
        }
        private void Regenerate()
        {
            LoadDefaultConfig();
        }
        
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigFile();
            Config.WriteObject(config);
        }
        #endregion

        #region Lang

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                ["MyStatsButton"] = "Моя статистика",
                ["ServerStatsButton"] = "Обшая статистика",
                ["AnimalKillHeader"] = "Убийства животных",
                ["Bears"] = "Медведей",
                ["Horses"] = "Лошадей",
                ["Stug"] = "Оленей",
                ["Boar"] = "Кабанов",
                ["Chicken"] = "Куриц",
                ["Wolf"] = "Волков",
                ["KillsHeader"] = "Убийства",
                ["Kills"] = "Убийств",
                ["Deatchs"] = "Смертей",
                ["Animals"] = "Животных",
                ["Bradleys"] = "Танков",
                ["Helis"] = "Вертолётов",
                ["GatherHeader"] = "Добыто",
                ["Sulfur"] = "Сера",
                ["Stones"] = "Камни",
                ["Metal"] = "Железа",
                ["Wood"] = "Дерева",
                ["Profile"] = "Профиль",
                ["Time"] = "Время",
                ["TimeButton"] = "Время",
                ["KillsButton"] = "Убийств",
                ["DeatchsButton"] = "Смертей",
                ["AnimalsButton"] = "Животных",
                ["BradleysButton"] = "Танк",
                ["HelisButton"] = "Верт",
                ["SulfurButton"] = "Сера",
                ["StonesButton"] = "Камни",
                ["MetalButton"] = "Железа",
                ["WoodButton"] = "Дерева"
                
            }, this);
        }

        #endregion
        #region Data

        public class StoredData {
            public Dictionary<ulong, PlayerInfo> PlayerInfo = new Dictionary<ulong, PlayerInfo>();
        }
        public enum Animal
        {
            Bear,
            Boar,
            Chicken,
            Wolf,
            Horse,
            Stag
        }
        public class PlayerInfo {
            public string Name;
            public int kills;
            public int deaths;
            public int animalkills;
            public int bradleykills;
            public int helikills;
            public int wood;
            public int stones;
            public int irons;
            public int sulfur;
            public int time;
            public int Bear;
            public int Boar;
            public int Chicken;
            public int Wolf;
            public int Horse;
            public int Stag;
            public PlayerInfo() { }
        }
        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, DataBase);

        private void LoadData() {
            try {
                DataBase = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(Name);
            } catch (Exception e) {
                DataBase = new StoredData();
            }
        }
        void AddPlayer(BasePlayer player)
        {
            var data = new PlayerInfo {            
                Name = player.displayName,
                kills = 0,
                deaths = 0,
                animalkills = 0,
                bradleykills = 0,
                helikills = 0,
                wood = 0,
                stones = 0,
                irons = 0,
                sulfur = 0,
                time = 0,
                Bear = 0,
                Boar = 0,
                Chicken = 0,
                Wolf = 0,
                Horse = 0,
                Stag = 0
            };
            DataBase.PlayerInfo.Add(Convert.ToUInt64(player.userID), data);
            SaveData();
            
        }
        
        #endregion
        
        //Desigh by Kira
        #region PlayerStatsGui
        
        public void PlayerStatGuiCreate(BasePlayer player)
        {
            if(player == null)
                return;
            string AvatarImage = GetImage(player.UserIDString, 0);
            var Data = DataBase.PlayerInfo[player.userID];
            CuiHelper.DestroyUi(player, "PlayerStats");
            var PlayerStatsGui = new CuiElementContainer();
            var PlStatsGui = PlayerStatsGui.Add(new CuiPanel
            {
              Image = {Color = "0 0 0 0"},

             RectTransform = { AnchorMax = "1 1", AnchorMin = "0 0"}
            }, "Hud", "PlayerStats");
            
            PlayerStatsGui.Add(new CuiButton
            {
              Button = { Close = "PlayerStats",Color = "0 0 0 0",},
              RectTransform = { AnchorMax = "1 1",AnchorMin = "0 0"},
              Text = { Text = "",Color = "0 0 0 0"}
            },PlStatsGui);
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats",
                Name = "PlayerStats"+ "BackGround",
                Components =
                {
                    new CuiRawImageComponent()
                    {
                        Color = "0 0 0 0.50", 
                        Sprite = "assets/content/ui/ui.spashscreen.psd",
                        Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat"
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.2202381 0.361979",
                        AnchorMax = "0.770864 0.8125"
                    }
                }
                
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "BackGround",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.MainHeaderColor)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0 0.896152",
                        AnchorMax = "1 1"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "BackGround",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = config.ServerName,
                        FontSize = 28,
                        Align = TextAnchor.MiddleCenter
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.2690016 0.8855821",
                        AnchorMax = "0.9349946 1.016647"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "BackGround",
                Components =
                {
                    new CuiImageComponent() {Color = "0 0 0 0.5"},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.8401511 0.7185797",
                        AnchorMax = "0.9945088 0.8945763"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "BackGround",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsProfileLineColor)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.8412383 0.8017578",
                        AnchorMax = "0.9966829 0.8123275"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "BackGround",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsProfileLineColor)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.994765 0.3296121",
                        AnchorMax = "1.0002 0.9088357"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "BackGround",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = lang.GetMessage("Profile",this),
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.8368888 0.8158216",
                        AnchorMax = "0.9955958 0.896152"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Name = "PlayerStats" + "PlayerImg",
                Parent = "PlayerStats" + "BackGround",
                Components =
                {
                    new CuiRawImageComponent()
                    {
                        Color = "1 1 1 1",
                        Png = AvatarImage
                        
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.8401511 0.4078285",
                        AnchorMax = "0.9934217 0.7249228"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
            Parent = "PlayerStats" + "PlayerImg",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = player.displayName,
                        Color = HexToRustFormat(config.PlayerStatsTextColor),
                        FontSize = 14,
                        Align = TextAnchor.MiddleCenter
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0 1",
                        AnchorMax = "1 1.246667"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "BackGround",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsProfileLineColor)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.8401511 0.3296115",
                        AnchorMax = "0.9944085 0.4079273"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "BackGround",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = lang.GetMessage("Time",this)+" "+GetPlaytimeClock(Data.time),
                        Color = HexToRustFormat(config.PlayerStatsTextColor),
                        FontSize = 15,
                        Align = TextAnchor.MiddleCenter
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.8401511 0.3296115",
                        AnchorMax = "0.9944085 0.4079273"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Name = "PlayerStats" + "GatherHeader",
                Parent = "PlayerStats" + "BackGround",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsHeaderColor1)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.5626061 0.8033028",
                        AnchorMax = "0.8289275 0.8794051"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "GatherHeader",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsHeaderColor2)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0 -0.155246",
                        AnchorMax = "1 0"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "GatherHeader",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsHeaderColor2)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.979881 -0.155246",
                        AnchorMax = "1 0.95"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "GatherHeader",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = lang.GetMessage("GatherHeader",this),
                        Color = HexToRustFormat(config.PlayerStatsTextColor),
                        FontSize = 20,
                        Align = TextAnchor.MiddleCenter
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                }
            });

            PlayerStatsGui.Add(new CuiElement
            {
                Name = "PlayerStats" + "Sulfur",
                Parent = "PlayerStats" + "BackGround",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor1)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.5626054 0.7081748",
                        AnchorMax = "0.8017511 0.7779353"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {

                Parent = "PlayerStats" + "Sulfur",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor2)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "1 0",
                        AnchorMax = "1.027175 0.97"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "Sulfur",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = lang.GetMessage("Sulfur",this)+": "+Data.sulfur+"",
                        Color = HexToRustFormat(config.PlayerStatsTextColor),
                        FontSize = 18,
                        Align = TextAnchor.UpperLeft
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.033148 0",
                        AnchorMax = "1 1"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Name = "PlayerStats" + "Stones",
                Parent = "PlayerStats" + "BackGround",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor1)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.56260444 0.6278445",
                        AnchorMax = "0.80175 0.697605"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {

                Parent = "PlayerStats" + "Stones",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor2)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "1 0",
                        AnchorMax = "1.027175 0.95"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "Stones",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = lang.GetMessage("Stones",this)+": "+Data.stones+"",
                        Color = HexToRustFormat(config.PlayerStatsTextColor),
                        FontSize = 18,
                        Align = TextAnchor.UpperLeft
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.033148 0",
                        AnchorMax = "1 1"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Name = "PlayerStats" + "Metal",
                Parent = "PlayerStats" + "BackGround",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor1)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.5626044 0.5475143",
                        AnchorMax = "0.80175 0.6172748"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {

                Parent = "PlayerStats" + "Metal",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor2)},
                    new CuiRectTransformComponent() 
                    {
                        AnchorMin = "1 0",
                        AnchorMax = "1.027175 0.95"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "Metal",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = lang.GetMessage("Metal",this)+": "+Data.irons+"",
                        Color = HexToRustFormat(config.PlayerStatsTextColor),
                        FontSize = 18,
                        Align = TextAnchor.UpperLeft
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.033148 0",
                        AnchorMax = "1 1"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Name = "PlayerStats" + "Wood",
                Parent = "PlayerStats" + "BackGround",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor1)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.5626044 0.467184",
                        AnchorMax = "0.80175 0.5369444"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {

                Parent = "PlayerStats" + "Wood",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor2)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "1 0",
                        AnchorMax = "1.027175 0.95"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "Wood",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = lang.GetMessage("Wood",this)+": "+Data.wood+"",
                        Color = HexToRustFormat(config.PlayerStatsTextColor),
                        FontSize = 18,
                        Align = TextAnchor.UpperLeft
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.033148 0",
                        AnchorMax = "1 1"
                    }
                }
            });
            
            PlayerStatsGui.Add(new CuiElement
            {
                Name = "PlayerStats" + "KillsHeader",
                Parent = "PlayerStats" + "BackGround",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsHeaderColor1)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.2807915 0.8033028",
                        AnchorMax = "0.5471129 0.8794051"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "KillsHeader",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsHeaderColor2)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0 -0.155246",
                        AnchorMax = "1 0"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "KillsHeader",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsHeaderColor2)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.979881 -0.155246",
                        AnchorMax = "1 0.95"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "KillsHeader",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = lang.GetMessage("KillsHeader",this),
                        Color = HexToRustFormat(config.PlayerStatsTextColor),
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.016042 0.038466",
                        AnchorMax = "0.962574 1"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Name = "PlayerStats" + "Players",
                Parent = "PlayerStats" + "BackGround",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor1)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.2807903 0.7081748",
                        AnchorMax = "0.519936 0.7779353"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {

                Parent = "PlayerStats" + "Players",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor2)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "1 0",
                        AnchorMax = "1.027175 0.97"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "Players",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = lang.GetMessage("Kills",this)+": "+Data.kills+"",
                        Color = HexToRustFormat(config.PlayerStatsTextColor),
                        FontSize = 18,
                        Align = TextAnchor.UpperLeft
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.033148 0",
                        AnchorMax = "1 1"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Name = "PlayerStats" + "Death",
                Parent = "PlayerStats" + "BackGround",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor1)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.2807903 0.6278445",
                        AnchorMax = "0.519936 0.697605"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {

                Parent = "PlayerStats" + "Death",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor2)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "1 0",
                        AnchorMax = "1.027175 0.95"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "Death",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = lang.GetMessage("Deatchs",this)+": "+Data.deaths+"",
                        Color = HexToRustFormat(config.PlayerStatsTextColor),
                        FontSize = 18,
                        Align = TextAnchor.UpperLeft
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.033148 0",
                        AnchorMax = "1 1"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Name = "PlayerStats" + "Animals",
                Parent = "PlayerStats" + "BackGround",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor1)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.2807903 0.5475143",
                        AnchorMax = "0.519936 0.6172737"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {

                Parent = "PlayerStats" + "Animals",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor2)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "1 0",
                        AnchorMax = "1.027175 0.95"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "Animals",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = lang.GetMessage("Animals",this)+": "+Data.animalkills+"",
                        Color = HexToRustFormat(config.PlayerStatsTextColor),
                        FontSize = 18,
                        Align = TextAnchor.UpperLeft
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.033148 0",
                        AnchorMax = "1 1"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Name = "PlayerStats" + "Bradley",
                Parent = "PlayerStats" + "BackGround",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor1)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.2807903 0.467184",
                        AnchorMax = "0.519936 0.5369449"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {

                Parent = "PlayerStats" + "Bradley",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor2)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "1 0",
                        AnchorMax = "1.027175 0.95"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "Bradley",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = lang.GetMessage("Bradleys",this)+": "+Data.bradleykills+"",
                        Color = HexToRustFormat(config.PlayerStatsTextColor),
                        FontSize = 18,
                        Align = TextAnchor.UpperLeft
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.033148 0",
                        AnchorMax = "1 1"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Name = "PlayerStats" + "Heli",
                Parent = "PlayerStats" + "BackGround",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor1)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.2807903 0.3868537",
                        AnchorMax = "0.519936 0.4566151"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {

                Parent = "PlayerStats" + "Heli",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor2)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "1 0",
                        AnchorMax = "1.027175 0.95"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "Heli",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = lang.GetMessage("Helis",this)+": "+Data.helikills+"",
                        Color = HexToRustFormat(config.PlayerStatsTextColor),
                        FontSize = 18,
                        Align = TextAnchor.UpperLeft
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.033148 0",
                        AnchorMax = "1 1"
                    }
                }
            });
            
           PlayerStatsGui.Add(new CuiElement
            {
                Name = "PlayerStats" + "AnimalsKillHeader",
                Parent = "PlayerStats" + "BackGround",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsHeaderColor1)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.002174052 0.8033028",
                        AnchorMax = "0.2684954 0.8794054"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "AnimalsKillHeader",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsHeaderColor2)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0 -0.155247",
                        AnchorMax = "1 0"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "AnimalsKillHeader",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsHeaderColor2)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.979881 -0.155246",
                        AnchorMax = "1 0.95"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "AnimalsKillHeader",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = lang.GetMessage("AnimalKillHeader",this),
                        FontSize = 17,
                        Align = TextAnchor.MiddleCenter
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.016042 0.038466",
                        AnchorMax = "0.962574 1.03847"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Name = "PlayerStats" + "Bears",
                Parent = "PlayerStats" + "BackGround",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor1)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.002174052 0.7081748",
                        AnchorMax = "0.2413198 0.7779353"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {

                Parent = "PlayerStats" + "Bears",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor2)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "1 0",
                        AnchorMax = "1.027175 0.97"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "Bears",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = lang.GetMessage("Bears",this)+": "+Data.Bear+"",
                        Color = HexToRustFormat(config.PlayerStatsTextColor),
                        FontSize = 18,
                        Align = TextAnchor.UpperLeft
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.033148 0",
                        AnchorMax = "1 0.97"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Name = "PlayerStats" + "Horse",
                Parent = "PlayerStats" + "BackGround",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor1)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.002174052 0.6278445",
                        AnchorMax = "0.2413224 0.697605"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {

                Parent = "PlayerStats" + "Horse",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor2)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "1 0",
                        AnchorMax = "1.027175 0.95"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "Horse",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = lang.GetMessage("Horses",this)+": "+Data.Horse+"",
                        Color = HexToRustFormat(config.PlayerStatsTextColor),
                        FontSize = 18,
                        Align = TextAnchor.UpperLeft
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.033148 0",
                        AnchorMax = "1 1"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Name = "PlayerStats" + "Deer",
                Parent = "PlayerStats" + "BackGround",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor1)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.002174052 0.5475143",
                        AnchorMax = "0.2413224 0.6172748"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {

                Parent = "PlayerStats" + "Deer",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor2)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "1 0",
                        AnchorMax = "1.027175 0.95"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "Deer",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = lang.GetMessage("Stug",this)+": "+Data.Stag+"",
                        Color = HexToRustFormat(config.PlayerStatsTextColor),
                        FontSize = 18,
                        Align = TextAnchor.UpperLeft
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.033148 0",
                        AnchorMax = "1 1"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Name = "PlayerStats" + "Boar",
                Parent = "PlayerStats" + "BackGround",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor1)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.002174052 0.467184",
                        AnchorMax = "0.2413224 0.536945"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {

                Parent = "PlayerStats" + "Boar",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor2)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "1 0",
                        AnchorMax = "1.027175 0.95"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "Boar",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = lang.GetMessage("Boar",this)+": "+Data.Boar+"",
                        Color = HexToRustFormat(config.PlayerStatsTextColor),
                        FontSize = 18,
                        Align = TextAnchor.UpperLeft
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.033148 0",
                        AnchorMax = "1 1"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Name = "PlayerStats" + "Chicken",
                Parent = "PlayerStats" + "BackGround",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor1)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.002174052 0.3868537",
                        AnchorMax = "0.2413224 0.4566142"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {

                Parent = "PlayerStats" + "Chicken",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor2)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "1 0",
                        AnchorMax = "1.027175 0.95"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "Chicken",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = lang.GetMessage("Chicken",this)+": "+Data.Chicken+"",
                        Color = HexToRustFormat(config.PlayerStatsTextColor),
                        FontSize = 18,
                        Align = TextAnchor.UpperLeft
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.033148 0",
                        AnchorMax = "1 1"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Name = "PlayerStats" + "Wolf",
                Parent = "PlayerStats" + "BackGround",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor1)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.002174052 0.3065234",
                        AnchorMax = "0.2413224 0.3762839"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {

                Parent = "PlayerStats" + "Wolf",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.PlayerStatsBlocColor2)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "1 0",
                        AnchorMax = "1.027175 0.97"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "Wolf",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = lang.GetMessage("Wolf",this)+": "+Data.Wolf+"",
                        Color = HexToRustFormat(config.PlayerStatsTextColor),
                        FontSize = 18,
                        Align = TextAnchor.UpperLeft
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.033148 0",
                        AnchorMax = "1 1"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiElement
            {
                Parent = "PlayerStats" + "BackGround",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.MainHeaderButtonEdgeColor)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.2492921 0.896152",
                        AnchorMax = "0.2542441 0.9997358"
                    }
                }
            });
            PlayerStatsGui.Add(new CuiButton
                {
                    Button = { Color = HexToRustFormat(config.MainHeaderButtonColor),Command = "serverstats_gui"},
                    RectTransform = { AnchorMax = "0.248104 1", AnchorMin = "0 0.896152"},
                    Text = { Text = lang.GetMessage("ServerStatsButton",this), Color = HexToRustFormat(config.PlayerStatsTextColor), FontSize = 16,Align = TextAnchor.MiddleCenter}
            },"PlayerStats"+ "BackGround");
            PlayerStatsGui.Add(new CuiButton
            {
                Button = { Color = HexToRustFormat(config.MainHeaderButtonCloseColor),Close = "PlayerStats"},
                RectTransform = { AnchorMax = "1 1", AnchorMin = "0.9499407 0.9257474"},
                Text = { Text = "X",FontSize = 20,Align = TextAnchor.MiddleCenter}
            },"PlayerStats"+ "BackGround");
            CuiHelper.AddUi(player, PlayerStatsGui);
        }
        
        #endregion
        //Desigh by Kira
        #region ServerTopGui
     
        public void ServerStatGuiCreate(BasePlayer player)
        {
            if (player == null)
                return;
            CuiHelper.DestroyUi(player, "ServerStats");
            var ServerStatsGui = new CuiElementContainer();
            var SrvStatsGui = ServerStatsGui.Add(new CuiPanel
            {
                Image = {Color = "0 0 0 0"},

                RectTransform = { AnchorMax = "1 1", AnchorMin = "0 0"}
            }, "Hud", "ServerStats");
            ServerStatsGui.Add(new CuiButton
            {
                Button = { Close = "ServerStats",Color = "0 0 0 0"},
                RectTransform = { AnchorMax = "1 1",AnchorMin = "0 0"}

            },SrvStatsGui);
            ServerStatsGui.Add(new CuiElement
            {
                Parent = "ServerStats",
                Name = "ServerStatsBackGround",
                Components =
                {
                    new CuiRawImageComponent()
                    {
                        Color = "0 0 0 0.50", 
                        Sprite = "assets/content/ui/ui.spashscreen.psd",
                        Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat"
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.2202381 0.361979",
                        AnchorMax = "0.770864 0.8125"
                    }
                }
                
            });
            ServerStatsGui.Add(new CuiElement
            {
                Parent = "ServerStatsBackGround",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.MainHeaderColor)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0 0.896152",
                        AnchorMax = "1 1"
                    }
                }
            });
            ServerStatsGui.Add(new CuiElement
            {
                Parent = "ServerStatsBackGround",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = config.ServerName,
                        FontSize = 28,
                        Align = TextAnchor.MiddleCenter
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.2690016 0.8855821",
                        AnchorMax = "0.9349946 1.016647"
                    }
                }
            });
            ServerStatsGui.Add(new CuiButton
                {
                    Button = { Color = HexToRustFormat(config.MainHeaderButtonColor),Command = "PlayerStats_gui"},
                    RectTransform = {AnchorMax = "0.248104 1", AnchorMin = "0 0.896152"},
                    Text = { Text = lang.GetMessage("MyStatsButton",this), Color = HexToRustFormat(config.ServerStatsTextColor),FontSize = 16,Align = TextAnchor.MiddleCenter}
                },"ServerStatsBackGround");
            ServerStatsGui.Add(new CuiButton
                {
                    Button = { Color = HexToRustFormat(config.MainHeaderButtonCloseColor),Close = "ServerStats"},
                    RectTransform = { AnchorMax = "1 1", AnchorMin = "0.9499407 0.9257474"},
                    Text = { Text = "X",FontSize = 20,Align = TextAnchor.MiddleCenter}
                },"ServerStatsBackGround");
            ServerStatsGui.Add(new CuiElement
            {
                Parent = "ServerStatsBackGround",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.MainHeaderButtonEdgeColor)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.2492921 0.896152",
                        AnchorMax = "0.2542441 0.9997358"
                    }
                }
            });
            ServerStatsGui.Add(new CuiElement
            {
                Parent = "ServerStatsBackGround",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.ServerStatsButtonsUpLine)},
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0 0.8803822",
                        AnchorMax = "1 0.8889621"
                    }
                }
            });
            ServerStatsGui.Add(new CuiElement
            {
                Parent = "ServerStatsBackGround",
                Components =
                {
                    new CuiImageComponent() {Color = HexToRustFormat(config.ServerStatsButtonsUpLine)},
                    new CuiRectTransformComponent()
                    {
                         AnchorMin = "0 0.7984205",
                        AnchorMax = "1 0.8070003"
                    }
                }
            });
            ServerStatsGui.Add(new CuiElement
            {
                Parent = "ServerStatsBackGround",
                Components =
                {
                    new CuiImageComponent() {Color = "0 0 0 0"},
                    new CuiOutlineComponent()
                    {
                        Color = HexToRustFormat(config.ServerStatsButtonsEdge),
                        Distance = "3 0"
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.004126973 0.8053755",
                        AnchorMax = "0.1096696 0.8816238"
                    }
                }
            });
            ServerStatsGui.Add(new CuiButton
                {
                   Button =
                   {
                       Color = HexToRustFormat(config.ServerStatsButtonsColor),
                       Command = "topkills"
                   },
                   RectTransform = { 
                       AnchorMin = "0.004126973 0.8053755",
                       AnchorMax = "0.1096696 0.8816238"
                       },
                   Text = { Text = lang.GetMessage("KillsButton",this),Color = HexToRustFormat(config.ServerStatsTextColor),FontSize = 16,Align = TextAnchor.MiddleCenter}
                },"ServerStatsBackGround");
            ServerStatsGui.Add(new CuiElement
            {
                Parent = "ServerStatsBackGround",
                Components =
                {
                    new CuiImageComponent() {Color = "0 0 0 0"},
                    new CuiOutlineComponent()
                    {
                        Color = HexToRustFormat(config.ServerStatsButtonsEdge),
                        Distance = "3 0"
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.1141795 0.8053755",
                        AnchorMax = "0.2281555 0.8816238"
                    }
                }
            });
            ServerStatsGui.Add(new CuiButton
                {
                    Button =
                    {
                        Color = HexToRustFormat(config.ServerStatsButtonsColor),
                        Command = "topDeaths"
                    },
                    RectTransform = { 
                        AnchorMin = "0.1141795 0.8053756",
                        AnchorMax = "0.2281555 0.8816238"
                    },
                    Text = { Text = lang.GetMessage("DeatchsButton",this),Color = HexToRustFormat(config.ServerStatsTextColor),FontSize = 16,Align = TextAnchor.MiddleCenter},
                    
                },"ServerStatsBackGround");
            ServerStatsGui.Add(new CuiElement
            {
                Parent = "ServerStatsBackGround",
                Components =
                {
                    new CuiImageComponent() {Color = "0 0 0 0"},
                    new CuiOutlineComponent()
                    {
                        Color = HexToRustFormat(config.ServerStatsButtonsEdge),
                        Distance = "3 0"
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.4955396 0.8053756",
                        AnchorMax = "0.6097016 0.8816238"
                    }
                }
            });
            ServerStatsGui.Add(new CuiButton
            {
                Button =
                {
                    Color = HexToRustFormat(config.ServerStatsButtonsColor),
                    Command = "topAnimalkills"
                },
                RectTransform = { 
                    AnchorMin = "0.4955396 0.8053756",
                    AnchorMax = "0.6097016 0.8816238"
                },
                Text = { Text = lang.GetMessage("AnimalsButton",this),Color = HexToRustFormat(config.ServerStatsTextColor),FontSize = 16,Align = TextAnchor.MiddleCenter}
            },"ServerStatsBackGround");
            ServerStatsGui.Add(new CuiElement
            {
                Parent = "ServerStatsBackGround",
                Components =
                {
                    new CuiImageComponent() {Color = "0 0 0 0"},
                    new CuiOutlineComponent()
                    {
                        Color = HexToRustFormat(config.ServerStatsButtonsEdge),
                        Distance = "3 0"
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.3417817 0.8053756",
                        AnchorMax = "0.4096888 0.8816238"
                    }
                }
            });
            ServerStatsGui.Add(new CuiButton
                {
                    Button =
                    {
                        Color = HexToRustFormat(config.ServerStatsButtonsColor),
                        Command = "topTanks"
                    },
                    RectTransform = { 
                        AnchorMin = "0.3417817 0.8053756",
                        AnchorMax = "0.4096888 0.8816238"
                    },
                    Text = { Text = lang.GetMessage("BradleysButton",this),Color = HexToRustFormat(config.ServerStatsTextColor),FontSize = 16,Align = TextAnchor.MiddleCenter}
                },"ServerStatsBackGround");
            ServerStatsGui.Add(new CuiElement
            {
                Parent = "ServerStatsBackGround",
                Components =
                {
                    new CuiImageComponent() {Color = "0 0 0 0"},
                    new CuiOutlineComponent()
                    {
                        Color = HexToRustFormat(config.ServerStatsButtonsEdge),
                        Distance = "3 0"
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.4137693 0.8053756",
                        AnchorMax = "0.4912157 0.8816238"
                    }
                }
            });
            ServerStatsGui.Add(new CuiButton
                {
                    Button =
                    {
                        Color = HexToRustFormat(config.ServerStatsButtonsColor),
                        Command = "topHeli"
                    },
                    RectTransform = { 
                        AnchorMin = "0.4137693 0.8053756",
                        AnchorMax = "0.4912157 0.8816238"
                    },
                    Text = { Text = lang.GetMessage("HelisButton",this),Color = HexToRustFormat(config.ServerStatsTextColor),FontSize = 16,Align = TextAnchor.MiddleCenter}
                },"ServerStatsBackGround");
            ServerStatsGui.Add(new CuiElement
            {
                Parent = "ServerStatsBackGround",
                Components =
                {
                    new CuiImageComponent() {Color = "0 0 0 0"},
                    new CuiOutlineComponent()
                    {
                        Color = HexToRustFormat(config.ServerStatsButtonsEdge),
                        Distance = "3 0"
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.2328372 0.8053756",
                        AnchorMax = "0.3379452 0.8816238"
                    }
                }
            });
            ServerStatsGui.Add(new CuiButton
                {
                    Button =
                    {
                        Color = HexToRustFormat(config.ServerStatsButtonsColor),
                        Command = "topServerTime"
                    },
                    RectTransform = { 
                        AnchorMin = "0.2328372 0.8053756",
                        AnchorMax = "0.3379452 0.8816238"
                    },
                    Text = { Text = lang.GetMessage("TimeButton",this),Color = HexToRustFormat(config.ServerStatsTextColor),FontSize = 16,Align = TextAnchor.MiddleCenter}
                },"ServerStatsBackGround");
            ServerStatsGui.Add(new CuiElement
            {
                Parent = "ServerStatsBackGround",
                Components =
                {
                    new CuiImageComponent() {Color = "0 0 0 0"},
                    new CuiOutlineComponent()
                    {
                        Color = HexToRustFormat(config.ServerStatsButtonsEdge),
                        Distance = "3 0"
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.6033972 0.8053756",
                        AnchorMax = "0.7042729 0.8816238"
                    }
                }
            });
            ServerStatsGui.Add(new CuiButton
                {
                    Button =
                    {
                        Color = HexToRustFormat(config.ServerStatsButtonsColor),
                        Command = "topWood"
                    },
                    RectTransform = { 
                        AnchorMin = "0.6033972 0.8053756",
                        AnchorMax = "0.7042729 0.8816238"
                    },
                    Text = { Text = lang.GetMessage("WoodButton",this),Color = HexToRustFormat(config.ServerStatsTextColor),FontSize = 16,Align = TextAnchor.MiddleCenter}
                },"ServerStatsBackGround");
            ServerStatsGui.Add(new CuiElement
            {
                Parent = "ServerStatsBackGround",
                Components =
                {
                    new CuiImageComponent() {Color = "0 0 0 0"},
                    new CuiOutlineComponent()
                    {
                        Color = HexToRustFormat(config.ServerStatsButtonsEdge),
                        Distance = "3 0"
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.816939 0.8053756",
                        AnchorMax = "0.9216781 0.8816238"
                    }
                }
            });
            ServerStatsGui.Add(new CuiButton
                {
                    Button =
                    {
                        Color = HexToRustFormat(config.ServerStatsButtonsColor),
                        Command = "topStones"
                    },
                    RectTransform = { 
                        AnchorMin = "0.816939 0.8053756",
                        AnchorMax = "0.9216781 0.8816238"
                    },
                    Text = { Text = lang.GetMessage("StonesButton",this),Color = HexToRustFormat(config.ServerStatsTextColor),FontSize = 16,Align = TextAnchor.MiddleCenter}
                },"ServerStatsBackGround");
            ServerStatsGui.Add(new CuiElement
            {
                Parent = "ServerStatsBackGround",
                Components =
                {
                    new CuiImageComponent() {Color = "0 0 0 0"},
                    new CuiOutlineComponent()
                    {
                        Color = HexToRustFormat(config.ServerStatsButtonsEdge),
                        Distance = "3 0"
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.7090817 0.8053756",
                        AnchorMax = "0.8129755 0.8816238"
                    }
                }
            });
            ServerStatsGui.Add(new CuiButton
                {
                    Button =
                    {
                        Color = HexToRustFormat(config.ServerStatsButtonsColor),
                        Command = "topMetal"
                    },
                    RectTransform = { 
                        AnchorMin = "0.7090817 0.8053756",
                        AnchorMax = "0.8129755 0.8816238"
                    },
                    Text = { Text = lang.GetMessage("MetalButton",this),Color = HexToRustFormat(config.ServerStatsTextColor),FontSize = 16,Align = TextAnchor.MiddleCenter}
                },"ServerStatsBackGround");
            ServerStatsGui.Add(new CuiElement
            {
                Parent = "ServerStatsBackGround",
                Components =
                {
                    new CuiImageComponent() {Color = "0 0 0 0"},
                    new CuiOutlineComponent()
                    {
                        Color = HexToRustFormat(config.ServerStatsButtonsEdge),
                        Distance = "3 0"
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.9260262 0.8053756",
                        AnchorMax = "0.9951354 0.8816238"
                    }
                }
            });
            ServerStatsGui.Add(new CuiButton
                {
                    Button =
                    {
                        Color = HexToRustFormat(config.ServerStatsButtonsColor),
                        Command = "topSulfur"
                    },
                    RectTransform = { 
                        AnchorMin = "0.9260262 0.8053756",
                        AnchorMax = "0.9951354 0.8816238"
                    },
                    Text = { Text = lang.GetMessage("SulfurButton",this),Color = HexToRustFormat(config.ServerStatsTextColor),FontSize = 16,Align = TextAnchor.MiddleCenter}
                },"ServerStatsBackGround");
           

            CuiHelper.AddUi(player, ServerStatsGui);
            
        }
private string TopGui = "[{\"name\":\"BoxRating1\",\"parent\":\"ServerStatsBackGround\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"1 1 1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"-0.004468113 0.1092254\",\"anchormax\":\"0.46855 0.7226822\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Number1\",\"parent\":\"BoxRating1\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopColor1}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.01149032 0.8034965\",\"anchormax\":\"0.9885097 0.9825175\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Ramka\",\"parent\":\"Number1\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopEdgeColor}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.984665 0\",\"anchormax\":\"1.000002 1.000001\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"BGTXT\",\"parent\":\"Number1\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopColor2}\"},{\"type\":\"UnityEngine.UI.Outline\",\"distance\":\"1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.000777 0\",\"anchormax\":\"0.071113 1.000025\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"TXT\",\"parent\":\"Number1\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"1\",\"fontSize\":28,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0.1176471 0.1176471 0.1176471 0.4253244\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.012293 0.050013\",\"anchormax\":\"0.061523 0.975017\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Nick\",\"parent\":\"Number1\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{Nick0} :\",\"fontSize\":20,\"align\":\"MiddleLeft\",\"color\":\"{TopNickText}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.07811538 -3.1E-05\",\"anchormax\":\"0.5 0.9999701\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Value\",\"parent\":\"Number1\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{Value0}\",\"fontSize\":20,\"align\":\"MiddleRight\",\"color\":\"{TopValueText}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.4999999 0.07502806\",\"anchormax\":\"0.9800001 0.976303\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Number2\",\"parent\":\"BoxRating1\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopColor1}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.01149032 0.606993\",\"anchormax\":\"0.9885097 0.786014\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Ramka\",\"parent\":\"Number2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopEdgeColor}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.984665 1E-06\",\"anchormax\":\"1.000002 1.000001\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"BGTXT\",\"parent\":\"Number2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopColor2}\"},{\"type\":\"UnityEngine.UI.Outline\",\"distance\":\"1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.000777 2.5E-05\",\"anchormax\":\"0.071113 1.000025\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"TXT\",\"parent\":\"Number2\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"2\",\"fontSize\":27,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0.1176471 0.1176471 0.1176471 0.4253244\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.012293 0.025012\",\"anchormax\":\"0.061523 0.950012\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Nick\",\"parent\":\"Number2\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{Nick1} :\",\"fontSize\":20,\"align\":\"MiddleLeft\",\"color\":\"{TopNickText}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.07811538 -2.4E-05\",\"anchormax\":\"0.5 0.999976\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Value\",\"parent\":\"Number2\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{Value1}\",\"fontSize\":20,\"align\":\"MiddleRight\",\"color\":\"{TopValueText}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0.075028\",\"anchormax\":\"0.98 0.976303\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Number3\",\"parent\":\"BoxRating1\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopColor1}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.01149032 0.4104896\",\"anchormax\":\"0.9885097 0.5895105\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Ramka\",\"parent\":\"Number3\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopEdgeColor}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.984665 1E-06\",\"anchormax\":\"1.000002 1.000001\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"BGTXT\",\"parent\":\"Number3\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopColor2}\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0.8062065 0.8062065 0.8062065 1\",\"distance\":\"1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.000777 2.6E-05\",\"anchormax\":\"0.071113 1.000026\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"TXT\",\"parent\":\"Number3\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"3\",\"fontSize\":26,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0.1176471 0.1176471 0.1176471 0.4253244\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.012293 0.025007\",\"anchormax\":\"0.061523 0.950008\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Nick\",\"parent\":\"Number3\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{Nick2} :\",\"fontSize\":20,\"align\":\"MiddleLeft\",\"color\":\"{TopNickText}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.07811538 -0.025031\",\"anchormax\":\"0.5 0.97497\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Value\",\"parent\":\"Number3\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{Value2}\",\"fontSize\":20,\"align\":\"MiddleRight\",\"color\":\"{TopValueText}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0.075028\",\"anchormax\":\"0.98 0.976303\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Number4\",\"parent\":\"BoxRating1\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopColor1}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.01149032 0.213986\",\"anchormax\":\"0.9885097 0.393007\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Ramka\",\"parent\":\"Number4\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopEdgeColor}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.984665 1E-06\",\"anchormax\":\"1.000002 1.000001\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"BGTXT\",\"parent\":\"Number4\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopColor2}\"},{\"type\":\"UnityEngine.UI.Outline\",\"distance\":\"1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"1E-06 2.5E-05\",\"anchormax\":\"0.070553 1.000025\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"TXT\",\"parent\":\"Number4\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"4\",\"fontSize\":24,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0.1176471 0.1176471 0.1176471 0.4253244\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.009225 0.050008\",\"anchormax\":\"0.058455 0.975009\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Nick\",\"parent\":\"Number4\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{Nick3} :\",\"fontSize\":20,\"align\":\"MiddleLeft\",\"color\":\"{TopNickText}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.07811538 -3E-05\",\"anchormax\":\"0.5 0.999971\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Value\",\"parent\":\"Number4\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{Value3}\",\"fontSize\":20,\"align\":\"MiddleRight\",\"color\":\"{TopValueText}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0.075028\",\"anchormax\":\"0.98 0.976303\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Number5\",\"parent\":\"BoxRating1\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopColor1}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.01149032 0.01748264\",\"anchormax\":\"0.9885097 0.1965036\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Ramka\",\"parent\":\"Number5\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopEdgeColor}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.984665 1E-06\",\"anchormax\":\"1.000002 1.000001\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"BGTXT\",\"parent\":\"Number5\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopColor2}\"},{\"type\":\"UnityEngine.UI.Outline\",\"distance\":\"1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"1E-06 2.5E-05\",\"anchormax\":\"0.070553 1.000025\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"TXT\",\"parent\":\"Number5\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"5\",\"fontSize\":22,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0.1176471 0.1176471 0.1176471 0.4253244\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.009199 0.025007\",\"anchormax\":\"0.058279 0.950007\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Nick\",\"parent\":\"Number5\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{Nick4} :\",\"fontSize\":20,\"align\":\"MiddleLeft\",\"color\":\"{TopNickText}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.07811538 -3.1E-05\",\"anchormax\":\"0.5 0.99997\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Value\",\"parent\":\"Number5\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{Value4}\",\"fontSize\":20,\"align\":\"MiddleRight\",\"color\":\"{TopValueText}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0.075028\",\"anchormax\":\"0.98 0.976303\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"BoxRating2\",\"parent\":\"ServerStatsBackGround\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"1 1 1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5847 0.1092254\",\"anchormax\":\"1.004292 0.7226822\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Number6\",\"parent\":\"BoxRating2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopColor1}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.01295337 0.8034965\",\"anchormax\":\"0.9870467 0.9825175\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Ramka\",\"parent\":\"Number6\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopEdgeColor}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.984665 1E-06\",\"anchormax\":\"1.000002 1.000001\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"BGTXT\",\"parent\":\"Number6\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopColor2}\"},{\"type\":\"UnityEngine.UI.Outline\",\"distance\":\"1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"1E-06 2.5E-05\",\"anchormax\":\"0.070553 1.000025\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"TXT\",\"parent\":\"Number6\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"6\",\"fontSize\":22,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0.1176471 0.1176471 0.1176471 0.4253244\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.012231 0.050007\",\"anchormax\":\"0.061161 0.975007\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Nick\",\"parent\":\"Number6\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{Nick5} :\",\"fontSize\":20,\"align\":\"MiddleLeft\",\"color\":\"{TopNickText}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.07811538 -3.1E-05\",\"anchormax\":\"0.5 0.99997\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Value\",\"parent\":\"Number6\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{Value5}\",\"fontSize\":20,\"align\":\"MiddleRight\",\"color\":\"{TopValueText}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0.075028\",\"anchormax\":\"0.9803833 0.976303\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Number7\",\"parent\":\"BoxRating2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopColor1}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.01295337 0.606993\",\"anchormax\":\"0.9870467 0.786014\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Ramka\",\"parent\":\"Number7\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopEdgeColor}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.984665 1E-06\",\"anchormax\":\"1.000002 1.000001\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"BGTXT\",\"parent\":\"Number7\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopColor2}\"},{\"type\":\"UnityEngine.UI.Outline\",\"distance\":\"1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 2.5E-05\",\"anchormax\":\"0.070551 1.000025\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"TXT\",\"parent\":\"Number7\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"7\",\"fontSize\":20,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0.1176471 0.1176471 0.1176471 0.4253244\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.013058 0.050007\",\"anchormax\":\"0.062138 0.975007\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Nick\",\"parent\":\"Number7\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{Nick6} :\",\"fontSize\":20,\"align\":\"MiddleLeft\",\"color\":\"{TopNickText}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.07811538 -3.1E-05\",\"anchormax\":\"0.5 0.99997\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Value\",\"parent\":\"Number7\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{Value6}\",\"fontSize\":20,\"align\":\"MiddleRight\",\"color\":\"{TopValueText}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0.075028\",\"anchormax\":\"0.9803833 0.976303\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Number8\",\"parent\":\"BoxRating2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopColor1}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.01295337 0.4104896\",\"anchormax\":\"0.9870467 0.5895105\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Ramka\",\"parent\":\"Number8\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopEdgeColor}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.984665 1E-06\",\"anchormax\":\"1.000002 1.000001\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"BGTXT\",\"parent\":\"Number8\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopColor2}\"},{\"type\":\"UnityEngine.UI.Outline\",\"distance\":\"1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"1E-06 2.5E-05\",\"anchormax\":\"0.070553 1.000025\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"TXT\",\"parent\":\"Number8\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"8\",\"fontSize\":18,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0.1176471 0.1176471 0.1176471 0.4253244\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.012231 0.050007\",\"anchormax\":\"0.061161 0.975007\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Nick\",\"parent\":\"Number8\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{Nick7} :\",\"fontSize\":20,\"align\":\"MiddleLeft\",\"color\":\"{TopNickText}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.07811538 -3.1E-05\",\"anchormax\":\"0.5 0.99997\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Value\",\"parent\":\"Number8\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{Value7}\",\"fontSize\":20,\"align\":\"MiddleRight\",\"color\":\"{TopValueText}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0.075028\",\"anchormax\":\"0.9803833 0.976303\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Number9\",\"parent\":\"BoxRating2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopColor1}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.01295337 0.213986\",\"anchormax\":\"0.9870467 0.393007\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Ramka\",\"parent\":\"Number9\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopEdgeColor}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.984665 1E-06\",\"anchormax\":\"1.000002 1.000001\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"BGTXT\",\"parent\":\"Number9\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopColor2}\"},{\"type\":\"UnityEngine.UI.Outline\",\"distance\":\"1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"1E-06 2.5E-05\",\"anchormax\":\"0.070553 1.000025\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"TXT\",\"parent\":\"Number9\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"9\",\"fontSize\":16,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0.1176471 0.1176471 0.1176471 0.4253244\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.012231 0.050007\",\"anchormax\":\"0.061161 0.975007\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Nick\",\"parent\":\"Number9\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{Nick8} :\",\"fontSize\":20,\"align\":\"MiddleLeft\",\"color\":\"{TopNickText}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.07811538 -3.1E-05\",\"anchormax\":\"0.5 0.99997\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Value\",\"parent\":\"Number9\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{Value8}\",\"fontSize\":20,\"align\":\"MiddleRight\",\"color\":\"{TopValueText}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0.075028\",\"anchormax\":\"0.9803833 0.976303\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Number10\",\"parent\":\"BoxRating2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopColor1}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.01295337 0.01748264\",\"anchormax\":\"0.9870467 0.1965036\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Ramka\",\"parent\":\"Number10\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopEdgeColor}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.984665 1E-06\",\"anchormax\":\"1.000002 1.000001\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"BGTXT\",\"parent\":\"Number10\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{TopColor2}\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0.8900158 0.8900158 0.8900158 1\",\"distance\":\"1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"1E-06 2.5E-05\",\"anchormax\":\"0.070553 1.000025\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"TXT\",\"parent\":\"Number10\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"10\",\"fontSize\":13,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0.1176471 0.1176471 0.1176471 0.4253244\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.009173 0.025007\",\"anchormax\":\"0.058103 0.950007\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Nick\",\"parent\":\"Number10\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{Nick9} :\",\"fontSize\":20,\"align\":\"MiddleLeft\",\"color\":\"{TopNickText}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.07811538 -3.1E-05\",\"anchormax\":\"0.5 0.99997\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Value\",\"parent\":\"Number10\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{Value9}\",\"fontSize\":20,\"align\":\"MiddleRight\",\"color\":\"{TopValueText}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0.075028\",\"anchormax\":\"0.9803833 0.976303\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]}]";
        #endregion

        #region Commands
        void CmdStats(IPlayer player, string command, string[] args)
        {

            BasePlayer pl = player.Object as BasePlayer;
            int timeplayed = Epoch.Current -  timelist[pl.userID];
            timelist[pl.userID] = Epoch.Current;
            DataBase.PlayerInfo[pl.userID].time += timeplayed;
            PlayerStatGuiCreate(pl);
        }
        [ConsoleCommand("serverstats_gui")]
        void CmdServerStatsGui(ConsoleSystem.Arg args)
        {
            CuiHelper.DestroyUi(args.Player(), "PlayerStats");
            
           ServerStatGuiCreate(args.Player());  
     
        }  
        [ConsoleCommand("PlayerStats_gui")]  
        void CmdPlayerStatsGui(ConsoleSystem.Arg args)
        {
            CuiHelper.DestroyUi(args.Player(), "ServerStats");
            
            PlayerStatGuiCreate(args.Player());
  
        }
        [ConsoleCommand("topkills")]
        void CmdTopKills(ConsoleSystem.Arg args)
        {
            CuiHelper.DestroyUi(args.Player(), "BoxRating1");
            CuiHelper.DestroyUi(args.Player(), "BoxRating2");
            var Dicter = DataBase.PlayerInfo;
            
            var top = Dicter.OrderByDescending(pair => pair.Value.kills);
            string Topg = TopGui;
            int i = 0;
            foreach (var Finder in top)
            {
                if (i < 10)
                {
                    Topg = Topg.Replace("{Value" + i + "}", Finder.Value.kills.ToString()).Replace("{Nick" + i + "}", Finder.Value.Name)
                        .Replace("{TopColor1}", HexToRustFormat(config.ServerStatsTopColor1))
                        .Replace("{TopColor2}", HexToRustFormat(config.ServerStatsTopColor2))
                        .Replace("{TopNickText}", HexToRustFormat(config.ServerStatsTopTextColor1))
                        .Replace("{TopValueText}", HexToRustFormat(config.ServerStatsTopTextColor1))
                        .Replace("{TopEdgeColor}", HexToRustFormat(config.ServerStatsTopEdgeColor));
                    
                }
                i++;
            }
            CuiHelper.AddUi(args.Player(), Topg);
 
        }
        [ConsoleCommand("topDeaths")]
        void CmdTopDeaths(ConsoleSystem.Arg args)
        {
            CuiHelper.DestroyUi(args.Player(), "BoxRating1");
            CuiHelper.DestroyUi(args.Player(), "BoxRating2");
            var Dicter = DataBase.PlayerInfo;
            var top = Dicter.OrderByDescending(pair => pair.Value.deaths);
            string Topg = TopGui;
            int i = 0;
            foreach (var Finder in top)
            {
                if (i < 10)
                {
                    Topg = Topg.Replace("{Value" + i+ "}", Finder.Value.deaths.ToString()).Replace("{Nick" + i+ "}", Finder.Value.Name)
                        .Replace("{TopColor1}", HexToRustFormat(config.ServerStatsTopColor1))
                        .Replace("{TopColor2}", HexToRustFormat(config.ServerStatsTopColor2))
                        .Replace("{TopNickText}", HexToRustFormat(config.ServerStatsTopTextColor1))
                        .Replace("{TopValueText}", HexToRustFormat(config.ServerStatsTopTextColor1))
                        .Replace("{TopEdgeColor}", HexToRustFormat(config.ServerStatsTopEdgeColor));
                    
                }
                i++;
            }
            CuiHelper.AddUi(args.Player(), Topg);
 
        }
        [ConsoleCommand("topTanks")]
        void CmdTopTanks(ConsoleSystem.Arg args)
        {
            CuiHelper.DestroyUi(args.Player(), "BoxRating1");
            CuiHelper.DestroyUi(args.Player(), "BoxRating2");
            var Dicter = DataBase.PlayerInfo;
            var top = Dicter.OrderByDescending(pair => pair.Value.bradleykills);
            string Topg = TopGui;
            int i = 0;
            foreach (var Finder in top)
            {
                if (i < 10)
                {
                    Topg = Topg.Replace("{Value" + i+ "}", Finder.Value.bradleykills.ToString()).Replace("{Nick" + i+ "}", Finder.Value.Name)
                        .Replace("{TopColor1}", HexToRustFormat(config.ServerStatsTopColor1))
                        .Replace("{TopColor2}", HexToRustFormat(config.ServerStatsTopColor2))
                        .Replace("{TopNickText}", HexToRustFormat(config.ServerStatsTopTextColor1))
                        .Replace("{TopValueText}", HexToRustFormat(config.ServerStatsTopTextColor1))
                        .Replace("{TopEdgeColor}", HexToRustFormat(config.ServerStatsTopEdgeColor));
                    
                }
                i++;
            }
            CuiHelper.AddUi(args.Player(), Topg);
 
        }
        [ConsoleCommand("topHeli")]
        void CmdTopHeli(ConsoleSystem.Arg args)
        {
            CuiHelper.DestroyUi(args.Player(), "BoxRating1");
            CuiHelper.DestroyUi(args.Player(), "BoxRating2");
            var Dicter = DataBase.PlayerInfo;
            var top = Dicter.OrderByDescending(pair => pair.Value.helikills);
            string Topg = TopGui;
            int i = 0;
            foreach (var Finder in top)
            {
                if (i < 10)
                {
                    Topg = Topg.Replace("{Value" + i+ "}", Finder.Value.helikills.ToString()).Replace("{Nick" + i+ "}", Finder.Value.Name)
                        .Replace("{TopColor1}", HexToRustFormat(config.ServerStatsTopColor1))
                        .Replace("{TopColor2}", HexToRustFormat(config.ServerStatsTopColor2))
                        .Replace("{TopNickText}", HexToRustFormat(config.ServerStatsTopTextColor1))
                        .Replace("{TopValueText}", HexToRustFormat(config.ServerStatsTopTextColor1))
                        .Replace("{TopEdgeColor}", HexToRustFormat(config.ServerStatsTopEdgeColor));
                    
                }

                i++;
            }

            CuiHelper.AddUi(args.Player(), Topg);
 
        }
        [ConsoleCommand("topAnimalkills")]
        void CmdTopAnimalKills(ConsoleSystem.Arg args)
        {
            CuiHelper.DestroyUi(args.Player(), "BoxRating1");
            CuiHelper.DestroyUi(args.Player(), "BoxRating2");
            var Dicter = DataBase.PlayerInfo;
            var top = Dicter.OrderByDescending(pair => pair.Value.animalkills);
            string Topg = TopGui;
            int i = 0;
            foreach (var Finder in top)
            {
                if (i < 10)
                {
                    Topg = Topg.Replace("{Value" + i+ "}", Finder.Value.animalkills.ToString()).Replace("{Nick" + i+ "}", Finder.Value.Name)
                        .Replace("{TopColor1}", HexToRustFormat(config.ServerStatsTopColor1))
                        .Replace("{TopColor2}", HexToRustFormat(config.ServerStatsTopColor2))
                        .Replace("{TopNickText}", HexToRustFormat(config.ServerStatsTopTextColor1))
                        .Replace("{TopValueText}", HexToRustFormat(config.ServerStatsTopTextColor1))
                        .Replace("{TopEdgeColor}", HexToRustFormat(config.ServerStatsTopEdgeColor));
                    
                }
                i++;
            }
            CuiHelper.AddUi(args.Player(), Topg);
 
        }
        [ConsoleCommand("topServerTime")]
        void CmdTopServerTime(ConsoleSystem.Arg args)
        {
            CuiHelper.DestroyUi(args.Player(), "BoxRating1");
            CuiHelper.DestroyUi(args.Player(), "BoxRating2");
            var Dicter = DataBase.PlayerInfo;
            var top = Dicter.OrderByDescending(pair => pair.Value.time);
            string Topg = TopGui;

            int i = 0;
            foreach (var Finder in top)
            {
                if (i < 10)
                {
                    Topg = Topg.Replace("{Value" + i+ "}", GetPlaytimeClock(Finder.Value.time)).Replace("{Nick" + i+ "}", Finder.Value.Name)
                        .Replace("{TopColor1}", HexToRustFormat(config.ServerStatsTopColor1))
                        .Replace("{TopColor2}", HexToRustFormat(config.ServerStatsTopColor2))
                        .Replace("{TopNickText}", HexToRustFormat(config.ServerStatsTopTextColor1))
                        .Replace("{TopValueText}", HexToRustFormat(config.ServerStatsTopTextColor1))
                        .Replace("{TopEdgeColor}", HexToRustFormat(config.ServerStatsTopEdgeColor));
                    
                }
                i++;
            }
            CuiHelper.AddUi(args.Player(), Topg);
 
        }
        [ConsoleCommand("topWood")]
        void CmdTopWood(ConsoleSystem.Arg args)
        {
            CuiHelper.DestroyUi(args.Player(), "BoxRating1");
            CuiHelper.DestroyUi(args.Player(), "BoxRating2");
            var Dicter = DataBase.PlayerInfo;
            var top = Dicter.OrderByDescending(pair => pair.Value.wood);
            string Topg = TopGui;
            int i = 0;
            foreach (var Finder in top)
            {
                if (i < 10)
                {
                    Topg = Topg.Replace("{Value" + i+ "}", Finder.Value.wood.ToString()).Replace("{Nick" + i+ "}", Finder.Value.Name)
                        .Replace("{TopColor1}", HexToRustFormat(config.ServerStatsTopColor1))
                        .Replace("{TopColor2}", HexToRustFormat(config.ServerStatsTopColor2))
                        .Replace("{TopNickText}", HexToRustFormat(config.ServerStatsTopTextColor1))
                        .Replace("{TopValueText}", HexToRustFormat(config.ServerStatsTopTextColor1))
                        .Replace("{TopEdgeColor}", HexToRustFormat(config.ServerStatsTopEdgeColor));
                    
                }
                i++;
            }
            CuiHelper.AddUi(args.Player(), Topg);
 
        }
        [ConsoleCommand("topStones")]
        void CmdTopStones(ConsoleSystem.Arg args)
        {
            CuiHelper.DestroyUi(args.Player(), "BoxRating1");
            CuiHelper.DestroyUi(args.Player(), "BoxRating2");
            var Dicter = DataBase.PlayerInfo;
            var top = Dicter.OrderByDescending(pair => pair.Value.stones);
            string Topg = TopGui;
            int i = 0;
            foreach (var Finder in top)
            {
                if (i < 10)
                {
                    Topg = Topg.Replace("{Value" + i+ "}", Finder.Value.stones.ToString()).Replace("{Nick" + i+ "}", Finder.Value.Name)
                        .Replace("{TopColor1}", HexToRustFormat(config.ServerStatsTopColor1))
                        .Replace("{TopColor2}", HexToRustFormat(config.ServerStatsTopColor2))
                        .Replace("{TopNickText}", HexToRustFormat(config.ServerStatsTopTextColor1))
                        .Replace("{TopValueText}", HexToRustFormat(config.ServerStatsTopTextColor1))
                        .Replace("{TopEdgeColor}", HexToRustFormat(config.ServerStatsTopEdgeColor));
                    
                }

                i++;
            }
            CuiHelper.AddUi(args.Player(), Topg);
 
        }
        [ConsoleCommand("topMetal")]
        void CmdTopMetal(ConsoleSystem.Arg args)
        {
            CuiHelper.DestroyUi(args.Player(), "BoxRating1");
            CuiHelper.DestroyUi(args.Player(), "BoxRating2");
            var Dicter = DataBase.PlayerInfo;
            var top = Dicter.OrderByDescending(pair => pair.Value.irons);
            string Topg = TopGui;
            int i = 0;
            foreach (var Finder in top)
            {
                
                if (i < 10)
                {
                    Topg = Topg.Replace("{Value" + i+ "}", Finder.Value.irons.ToString()).Replace("{Nick" + i+ "}", Finder.Value.Name)
                        .Replace("{TopColor1}", HexToRustFormat(config.ServerStatsTopColor1))
                        .Replace("{TopColor2}", HexToRustFormat(config.ServerStatsTopColor2))
                        .Replace("{TopNickText}", HexToRustFormat(config.ServerStatsTopTextColor1))
                        .Replace("{TopValueText}", HexToRustFormat(config.ServerStatsTopTextColor1))
                        .Replace("{TopEdgeColor}", HexToRustFormat(config.ServerStatsTopEdgeColor));
                    
                }
                i++;
            }
            CuiHelper.AddUi(args.Player(), Topg);
 
        }
        [ConsoleCommand("topSulfur")]
        void CmdTopSulfur(ConsoleSystem.Arg args)
        {
            CuiHelper.DestroyUi(args.Player(), "BoxRating1");
            CuiHelper.DestroyUi(args.Player(), "BoxRating2");
            var Dicter = DataBase.PlayerInfo;
            var top = Dicter.OrderByDescending(pair => pair.Value.sulfur);
            string Topg = TopGui;
            int i = 0;
            foreach (var Finder in top)
            {
                if (i < 10)
                {
                    Topg = Topg.Replace("{Value" + i+ "}", Finder.Value.sulfur.ToString()).Replace("{Nick" + i+ "}", Finder.Value.Name)
                        .Replace("{TopColor1}", HexToRustFormat(config.ServerStatsTopColor1))
                        .Replace("{TopColor2}", HexToRustFormat(config.ServerStatsTopColor2))
                        .Replace("{TopNickText}", HexToRustFormat(config.ServerStatsTopTextColor1))
                        .Replace("{TopValueText}", HexToRustFormat(config.ServerStatsTopTextColor1))
                        .Replace("{TopEdgeColor}", HexToRustFormat(config.ServerStatsTopEdgeColor));
                    
                }
                i++;
            }
            CuiHelper.AddUi(args.Player(), Topg);
 
        }
        
        #endregion
       
        #region  Hooks
        Dictionary<ulong, int> timelist = new Dictionary<ulong, int>();
        private void OnPlayerInit(BasePlayer player)
        {
            if (!DataBase.PlayerInfo.ContainsKey(player.userID)) AddPlayer(player);
            if (DataBase.PlayerInfo[player.userID].Name != player.displayName) DataBase.PlayerInfo[player.userID].Name = player.displayName;
               timelist.Add(player.userID,Epoch.Current);
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            int timeplayed = Epoch.Current -  timelist[player.userID];
            DataBase.PlayerInfo[player.userID].time += timeplayed;
            timelist.Remove(player.userID);
        }
        void Init() 
        { 
            LoadConfig();
            AddCovalenceCommand(config.StatsCmd,"CmdStats","Statistics.use");
        } 
        private void OnServerInitialized() {
            LoadData();
            foreach (var player in BasePlayer.activePlayerList)
            {
                timelist.Add(player.userID,Epoch.Current);
            }
        }
        private void Unload()
        {
            SaveData();
            foreach (var player in BasePlayer.activePlayerList)
            {
                int timeplayed = Epoch.Current -  timelist[player.userID];
                DataBase.PlayerInfo[player.userID].time += timeplayed;
                timelist.Remove(player.userID);
            }
        }
        private void OnPlayerDie(BasePlayer player, HitInfo info)
        {
            if (info == null || player == null || player.IsNpc)
                return;
            CheckDb(player);
            var Dictinory = DataBase.PlayerInfo[player.userID];
            if (info.damageTypes.GetMajorityDamageType() == DamageType.Suicide)
                Dictinory.deaths++;
            else
            {
                Dictinory.deaths++;
                var attacker = info.InitiatorPlayer;
                if (attacker == null || attacker.IsNpc)
                    return;
                CheckDb(attacker);
                var AttackerDictinory = DataBase.PlayerInfo[attacker.userID];
                AttackerDictinory.kills++;
            }
         
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity is BaseHelicopter && info.Initiator is BasePlayer)
                lastDamageName = info.Initiator.ToPlayer().userID;
            if (entity is BradleyAPC && info.Initiator is BasePlayer)
                lastDamageName = info.Initiator.ToPlayer().userID;
           
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo hitinfo)
        {
            
            if (hitinfo?.Initiator is BasePlayer)
            {
                var player = hitinfo.Initiator as BasePlayer;
               
                if (player.userID.IsSteamId() && !(player is NPCPlayer) && !(player is HTNPlayer))
                {
                    CheckDb(player);
                    var Dictinory = DataBase.PlayerInfo[player.userID];
                    if (entity.name.Contains("agents/"))
                        switch (entity.ShortPrefabName)
                        {
                            case "bear":
                                Dictinory.Bear++;
                                Dictinory.animalkills++;
                                break;
                            case "boar":
                                Dictinory.Boar++;
                                Dictinory.animalkills++;
                                break;
                            case "chicken":
                                Dictinory.Chicken++;
                                Dictinory.animalkills++;
                                break;
                            case "horse":
                                Dictinory.Horse++;
                                Dictinory.animalkills++;
                                break;
                            case "stag":
                                Dictinory.Stag++;
                                Dictinory.animalkills++;
                                break;
                            case "wolf":
                                Dictinory.Wolf++;
                                Dictinory.animalkills++;
                                break;
                        }
                }
            }

            if (entity is BradleyAPC)
            {
                BasePlayer player;
                player = BasePlayer.FindByID(lastDamageName);
                CheckDb(player);
                var Dictinory = DataBase.PlayerInfo[player.userID];
                if (player != null)
                {
                    Dictinory.bradleykills++;
                }
            }
           if (entity is BaseHelicopter)
            {
                BasePlayer player;
                player = BasePlayer.FindByID(lastDamageName);
                CheckDb(player);
                var Dictinory = DataBase.PlayerInfo[player.userID];
                if (player != null)
                {
                    Dictinory.helikills++;
                }
            }
        }
        
        private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            BasePlayer player = entity.ToPlayer();
            CheckDb(player);
            var Dictinory = DataBase.PlayerInfo[player.userID];
            switch (item.info.shortname)
            {
                case "stones":
                    Dictinory.stones +=item.amount;
                    break;
                case "wood":
                    Dictinory.wood +=item.amount;
                    break;
                case "metal.ore":
                    Dictinory.irons +=item.amount;
                    break;
                case "sulfur.ore":
                    Dictinory.sulfur +=item.amount;
                    break;
            }
        }

        void OnDispenserBonus(ResourceDispenser dispenser, BaseEntity entity, Item item) => OnDispenserGather(dispenser, entity, item);

        void OnCollectiblePickup(Item item, BasePlayer player)
        {
            CheckDb(player);
            var Dictinory = DataBase.PlayerInfo[player.userID];
            switch (item.info.shortname)
            {
                case "stones":
                    Dictinory.stones +=item.amount;
                    break;
                case "wood":
                    Dictinory.wood +=item.amount;
                    break;
                case "metal.ore":
                    Dictinory.irons +=item.amount;
                    break;
                case "sulfur.ore":
                    Dictinory.sulfur +=item.amount;
                    break;
            }
        }
        
        #endregion
        
        #region Utils

        void CheckDb(BasePlayer player)
        {
            if (!DataBase.PlayerInfo.ContainsKey(player.userID)) AddPlayer(player);
        }
        
        private string GetPlaytimeClock(double time)
        {
            TimeSpan dateDifference = TimeSpan.FromSeconds((float)time); 
            var days = dateDifference.Days;
            var hours = dateDifference.Hours;
            hours += (days * 24);
            var mins = dateDifference.Minutes;
            var secs = dateDifference.Seconds;
            return string.Format("{0:00}:{1:00}:{2:00}", hours, mins, secs);
        }
        
        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        #endregion
    }
}

// --- End of file: Statistics.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RotatingBillboards.cs ---
// --- Original Local Path: RotatingBillboards.cs ---

using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using UnityEngine;
using System.Reflection;

namespace Oxide.Plugins
{
    [Info("RotatingBillboards", "k1lly0u", "0.1.0", ResourceId = 0)]
    class RotatingBillboards : RustPlugin
    {
        #region Fields
        StoredData storedData;
        private DynamicConfigFile data;

        private List<Rotator> billBoards;
        static RotatingBillboards instance;

        private Vector3 eyesAdjust;
        private FieldInfo serverinput;
        #endregion

        #region Oxide Hooks
        void Loaded()
        {
            billBoards = new List<Rotator>();
            data = Interface.Oxide.DataFileSystem.GetFile("billboard_data");
            eyesAdjust = new Vector3(0f, 1.5f, 0f);
            serverinput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            lang.RegisterMessages(Messages, this);
        }
        void OnServerInitialized()
        {
            LoadVariables();
            LoadData();
            instance = this;
            FindAllEntities();
        }
        void OnEntityKill(BaseNetworkable netEntity)
        {
            if (netEntity?.net?.ID == null) return;
            if (storedData.data.Contains(netEntity.net.ID))
            {
                storedData.data.Remove(netEntity.net.ID);
                return;
            }
        }
        void Unload()
        {
            var objects = UnityEngine.Object.FindObjectsOfType<Rotator>();
            if (objects != null)
            {
                foreach(var obj in objects)
                {
                    UnityEngine.Object.Destroy(obj);
                }
            }
        }
        #endregion

        #region Class
        class Rotator : Signage
        {
            private Signage entity;
            private float secsToTake;
            private float secsTaken;

            private Vector3 initialRot;
            private Vector3 startRot;
            private Vector3 endRot;

            private bool isRotating;

            void Awake()
            {
                entity = GetComponent<Signage>();                
                initialRot = entity.transform.eulerAngles;
                secsToTake = instance.configData.RotationSpeed;
                startRot = new Vector3(entity.transform.eulerAngles.x, 0.01f, entity.transform.eulerAngles.z);
                endRot = new Vector3(entity.transform.eulerAngles.x, 359.99f, entity.transform.eulerAngles.z);
                isRotating = false;
            }            
            void Destroy()
            {
                entity.transform.eulerAngles = initialRot;
                entity.transform.hasChanged = true;
                entity.SendNetworkUpdateImmediate();
                Destroy(this);
            }
            void FixedUpdate()
            {
                if (!isRotating) return;
                secsTaken = secsTaken + UnityEngine.Time.deltaTime;
                float single = Mathf.InverseLerp(0f, secsToTake, secsTaken);
                entity.transform.eulerAngles = Vector3.Lerp(startRot, endRot, single);
                if (single >= 1)
                {
                    entity.transform.eulerAngles = startRot;
                    secsTaken = 0;
                }
                entity.transform.hasChanged = true;
                entity.SendNetworkUpdateImmediate();
            }
            public void ToggleRotation()
            {
                if (isRotating)
                    isRotating = false;
                else isRotating = true;
            }
            public bool IsRotating() => isRotating;
        }
        #endregion

        #region Functions
        void FindAllEntities()
        {
            var signs = UnityEngine.Object.FindObjectsOfType<Signage>();
            foreach(var sign in signs)
            {
                if (sign == null) continue;
                if (storedData.data.Contains(sign.net.ID))
                {
                    if (!sign.GetComponent<Rotator>())
                    {
                        var rotator = sign.gameObject.AddComponent<Rotator>();
                        rotator.enabled = true;
                        billBoards.Add(rotator);
                        rotator.ToggleRotation();
                    }
                }
            }
        }
        object FindEntityFromRay(BasePlayer player)
        {
            var input = serverinput.GetValue(player) as InputState;
            Ray ray = new Ray(player.eyes.position, Quaternion.Euler(input.current.aimAngles) * Vector3.forward);
            RaycastHit hit;
            if (!Physics.Raycast(ray, out hit, 20))
                return null;

            var hitEnt = hit.collider.GetComponentInParent<Signage>();
            if (hitEnt != null)
                return hitEnt;
            return null;
        }
        #endregion

        #region Commands
        [ChatCommand("rot")]
        void cmdRot(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin()) return;
            if (args.Length == 0)
            {
                SendReply(player, msg("/rot add - Adds a rotator to the sign you are looking at", player.UserIDString));
                SendReply(player, msg("/rot remove - Removes a rotator from the sign you are looking at", player.UserIDString));
                SendReply(player, msg("/rot remove all - Removes all rotators and wipes data", player.UserIDString));
                SendReply(player, msg("/rot start - Starts the rotation of the sign you are looking at", player.UserIDString));
                SendReply(player, msg("/rot stop - Stops the rotation of the sign you are looking at", player.UserIDString));
                return;
            }
            switch (args[0].ToLower())
            {
                case "add":
                    {
                        var entity = FindEntityFromRay(player);
                        if (entity != null)
                        {
                            Signage sign = entity as Signage;
                            if (!storedData.data.Contains(sign.net.ID))
                            {
                                storedData.data.Add(sign.net.ID);
                                var rotator = sign.gameObject.AddComponent<Rotator>();
                                rotator.enabled = true;
                                billBoards.Add(rotator);
                                rotator.ToggleRotation();
                                SaveData();
                                SendReply(player, msg("You have successfully created a rotating billboard"));
                            }
                            else SendReply(player, msg("This sign already has a rotator attached to it"));
                        }
                        else SendReply(player, msg("Unable to find a valid sign"));
                    }
                    return;
                case "remove":
                    if (args.Length == 2 && args[1].ToLower() == "all")
                    {
                        foreach (var rotator in billBoards)                        
                            UnityEngine.Object.Destroy(rotator);                        
                        billBoards.Clear();
                        storedData.data.Clear();
                        SaveData();
                        SendReply(player, msg("Removed all rotating billboards"));
                    }
                    else
                    {
                        var entity = FindEntityFromRay(player);
                        if (entity != null)
                        {
                            BaseEntity sign = (entity as BaseEntity);
                            if (sign.GetComponent<Rotator>())
                            {
                                billBoards.Remove(sign.GetComponent<Rotator>());
                                UnityEngine.Object.Destroy(sign.GetComponent<Rotator>());
                                if (storedData.data.Contains(sign.net.ID))                                
                                    storedData.data.Remove(sign.net.ID);
                                SaveData();
                                SendReply(player, msg("You have successfully removed this rotating billboard"));
                            }
                            else SendReply(player, msg("This sign does not have a rotator attached to it"));
                        }
                        else SendReply(player, msg("Unable to find a valid sign"));
                    }
                    return;
                case "start":
                    {
                        var entity = FindEntityFromRay(player);
                        if (entity != null)
                        {
                            Rotator sign = (entity as BaseEntity).GetComponent<Rotator>();
                            if (sign != null)
                            {
                                if (sign.IsRotating())
                                    SendReply(player, msg("This sign is already rotating"));
                                else
                                {
                                    sign.ToggleRotation();
                                    SendReply(player, msg("Rotation started"));
                                }
                                return;
                            }
                            else SendReply(player, msg("This sign does not have a rotator attached to it"));
                        }
                        else SendReply(player, msg("Unable to find a valid sign"));
                    }
                    return;
                case "stop":
                    {
                        var entity = FindEntityFromRay(player);
                        if (entity != null)
                        {
                            Rotator sign = (entity as BaseEntity).GetComponent<Rotator>();
                            if (sign != null)
                            {
                                if (!sign.IsRotating())
                                    SendReply(player, msg("This sign is already stopped"));
                                else
                                {
                                    sign.ToggleRotation();
                                    SendReply(player, msg("Rotation stopped"));
                                }
                                return;
                            }
                            else SendReply(player, msg("This sign does not have a rotator attached to it"));
                        }
                        else SendReply(player, msg("Unable to find a valid sign"));
                    }
                    return;
                default:
                    break;
            }
        }

        string msg(string key, string userId = null) => lang.GetMessage(key, this, userId);
        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            {"Unable to find a valid sign", "Unable to find a valid sign" },
            {"This sign does not have a rotator attached to it","This sign does not have a rotator attached to it" },
            {"Rotation stopped","Rotation stopped" },
            {"This sign is already stopped","This sign is already stopped" },
            {"Rotation started","Rotation started" },
            {"This sign is already rotating","This sign is already rotating" },
            {"You have successfully removed this rotating billboard","You have successfully removed this rotating billboard" },
            {"Removed all rotating billboards","Removed all rotating billboards" },
            {"You have successfully created a rotating billboard","You have successfully created a rotating billboard" },
            {"/rot stop - Stops the rotation of the sign you are looking at","/rot stop - Stops the rotation of the sign you are looking at" },
            {"/rot start - Starts the rotation of the sign you are looking at","/rot start - Starts the rotation of the sign you are looking at" },
            {"/rot remove all - Removes all rotators and wipes data","/rot remove all - Removes all rotators and wipes data" },
            {"/rot remove - Removes a rotator from the sign you are looking at","/rot remove - Removes a rotator from the sign you are looking at" },
            {"/rot add - Adds a rotator to the sign you are looking at","/rot add - Adds a rotator to the sign you are looking at" }
        };
        #endregion

        #region Config        
        private ConfigData configData;
        class ConfigData
        {
            public float RotationSpeed { get; set; }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                RotationSpeed = 5f
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Data Management
        void SaveData() => data.WriteObject(storedData);
        void LoadData()
        {
            try
            {
                storedData = data.ReadObject<StoredData>();
            }
            catch
            {
                storedData = new StoredData();
            }
        }
        class StoredData
        {
            public List<uint> data = new List<uint>();
        }
        #endregion
    }
}


// --- End of file: RotatingBillboards.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Duel.cs ---
// --- Original Local Path: Duel.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Duel", "RustPlugin.ru", "4.2.0")]
    [Description("Automatic Duel (Bets) with GUI, weapons list, auto-created arenas, save players loot and position")]
    class Duel : RustPlugin
    {
        #region Messages&Config

        string notAllowed = "Вызов на дуэль запрещен";
        string duelCommand = "<color=orange>/duel <ник></color> - вызвать игрока на дуэль\n<color=orange><color=#ADFF2F>/duels</color> <ник></color> - <color=#ADFF2F>вызвать игрока на дуэль со ставками</color>\n<color=orange>/duel a</color> - принять вызов\n<color=orange>/duel c</color> - отменить вызов\n<color=orange>/duel stat</color> - статистика\n<color=orange>/duel top</color> - топ\nКомандная дуэль:\n<color=orange>/duel create [2-6]</color> - создать командную дуэль\n<color=orange>/duel join red/blue</color> - подать заявку\n<color=orange>/duel accept</color> - принять в дуэль (для создателя)\n<color=orange>/duel c</color> - покинуть дуэль";
        string dontHaveRequest = "У вас нет заявок на дуэль";
        string notFoundPlayer = "Игрок с именем <color=#7b9ef6>{0}</color> не найден";
        string alreadyHaveDuel = "<color=#7b9ef6>{0}</color> уже имеет активную дуэль";
        string youOnDuel = "Вы уже имеете активную дуэль";
        string noArenas = "Извините, все арены сейчас заняты";
        string noBuildAcess = "Вы должны быть авторизованы в шкафу";
        string cooldownMessage = "Вы сможете вызвать на дуэль через {0} секунд";
        string createRequest = "Вы вызвали <color=#7b9ef6>{0}</color> на дуэль!\n<color=orange>/duel c</color> - отменить вызов";
        string receiveRequest = "<color=#7b9ef6>{0}</color> вызвал вас на дуэль!\n<color=orange>/duel a</color> - принять вызов\n15 секунд до отмены\n<color=orange>/duel c</color> - отменить вызов";
        string youDontHaveRequest = "У вас нет активных вызовов";
        string cantCancelDuel = "Невозможно отменить начавшуюся дуэль.\nПобеди своего противника!";
        static string duelHasBeenCancelled = "Дуэль c <color=#7b9ef6>{0}</color> отменена.";
        static string duelStart = "Дуэль началась!";
        static string playerNotFound = "Игрок с именем {0} не найден";
        static string foundMultiplePlayers = "Найдено несколько игроков: <color=#7b9ef6>{0}</color>";

        static string guiChooseWeapon = "Выберите оружие из списка";
        static string guiYourChoose = "Вы выбрали: {0}";
        static string guiWaitForOpponentChoose = "Противник выбирает оружие";
        static string guiOpponentsWeapon = "Противник выбрал: {0}";
        static string guiStartAboutToBegin = "Начало через несколько секунд";
        static string guiSurrenderButton = "Сдаться";
        static string guiAutoCloseSec = "До выбора случайного оружия: {0}";
        static string guiPlayerSleep = "Ожидаем пока соперник проснётся";

        string statLoss = "Тебе засчитано поражение в дуэли";
        string statWin = "Тебе засчитана победа в дуэли";
        string notificationAboutWin = "[Дуэль] <color=#7b9ef6>{0}</color> vs <color=#7b9ef6>{1}</color>\nПобедитель: <color=#7b9ef6>{2}</color>";
        string cantBuild = "Ты не можешь строить на дуэли";
        string cantUseRecycle = "Ты не можешь использовать переработчик на дуэли";
        string cantUseNexusKits = "Ты не можешь использовать киты на дуэли";
        string cantTrade = "Ты не можешь обмениваться на дуэли";
        string cantRemove = "Ты не можешь ремувать на дуэли";
        string cantTp = "Ты не можешь пользоваться телепортом на дуэли";
        string cantUseKit = "Ты не можешь получить кит на дуэли";
        string cantUseCommand = "Вы не можете использовать /{0} на Duel";
        string cantUseBackPack = "Ты не можешь использовать рюкзак на дуэли";
        string cantUseSkins = "Ты не можешь использовать скины на дуэли";
        string cantUseKill = "Ты не можешь использовать kill на дуэли";
        string yourStat = "Ваша статистика по дуэлям:\nПобед: {0}\nПоражений: {1}\nКомандные дуэли:\nПобед:{2}\nПоражений:{3}";
        string emptyTop = "Статистика пуста как твоя кровать по ночам";
        string topWin = "Топ побед в дуэлях:";
        string topTeamWin = "\n\nТоп побед в командных дуэлях:";
        string topLosses = "\n\nТоп поражений в дуэлях:";
        string topTeamLoss = "\n\nТоп поражений в командных дуэлях:";
        string playerInTop = "\n{0}. <color=#469cd0>{1}</color>: {2}"; // номер. ник: значение

        static string returnPlayerReason = "Дуэль окончена.\nПричина: <color=orange>{0}</color>";
        static string returnReasonSleep = "Кто-то слишком долго спал";
        static string returnReasonGUIFail = "Кто-то слишком долго выбирает оружие";
        static string returnReasonLimitTime = "Время на дуэль вышло({0} секунд)";
        static string returnReasonDisconnect = "Соперник отключился";
        static string returnReasonSurrender = "Кто-то всё же решил сдаться";
        static string returnReasonUnload = "Плагин на время отключен. Попробуйте позже.";
        static string teamDuelCancelled = "Командная дуэль отменена\nПричина: не собрана за {0} сек";

        static string teamPlayerDisconnect = "[Дуэль] <color=#7b9ef6>{0}</color> вышел с сервера!";
        static string teamWinRed = "[Дуэль] Побеждает команда <color=red>RED</color>!";
        static string teamWinBlue = "[Дуэль] Побеждает команда <color=blue>BLUE</color>!";
        static string teamDuellerWounded = "[Дуэль] Один из дуэлянтов ранен.\nДуэль не начнётся, пока он ранен.";
        static string teamArensBusy = "[Дуэль] Пожалуйста, подождите. Все арены заняты.";
        static string teamCooldownToCreate = "Вы сможете создать командную дуэль через {0} сек";
        static string teamAlreadyCreated = "Извините, но командная дуэль уже создана. Присоединиться: /duel join red/blue";
        static string teamCreatedPermPref = "<color=yellow> Турнирную </color>";
        static string teamSucessCreated = "<color=#409ccd>{0}</color> создал{1}командную дуэль <color=#36978e>{2}</color> на <color=#36978e>{2}</color>!\nПодать заявку на участие в команде <color=red>RED</color>: /duel join red\nПодать заявку на участие в команде <color=blue>BLUE</color>: /duel join blue";
        static string teamCancelDuel = "Отменить дуэль: <color=orange>/duel c</color>";
        static string teamNotOwner = "Ты не создатель дуэли";
        static string teamNoSlotsBlue = "Свободных мест в команде blue нет";
        static string teamNoSlotsRed = "Свободных мест в команде red нет";
        static string teamJoinPermPref = "<color=yellow> Турнирная </color>";
        static string teamJoinRedPref = "<color=red>red</color>";
        static string teamJoinBluePref = "<color=blue>blue</color>";
        static string teamAboutToBegin = "[Дуэль] Начало через 5 секунд!";
        static string teamJoinAboutToBeginAnnounce = "[{0}Командная дуэль]\n<color=#7b9ef6>{1}</color> присоединился к команде {2}\nНабор окончен!\nДуэль скоро начнется";
        static string teamJoinAnnounce = "[{0}Командная дуэль]\n<color=#7b9ef6>{1}</color> присоединился к команде {2}\nСвободных мест:\n<color=red>red</color>: {3}\n<color=blue>blue</color>: {4}\nПодать заявку: <color=orange>/duel join red</color> или <color=orange>blue</color>";
        static string teamPlayerWont = "{0} не подавал заявку на дуэль";
        static string teamErrorNoCommand = "Ошибка. Выберите команду: /duel join red / blue";
        static string teamAlreadyRequest = "Вы уже подали заявку на командную дуэль. Ждите одобрения создателя";
        static string teamAlreadyStarted = "Ошибка. Дуэль уже началась!";
        static string teamNoPerm = "Извините, у вас нет доступа к турнирным дуэлям.\nПриобрести можно в магазине сервера.";
        static string teamSucessRequest = "Вы подали заявку.\nОжидайте, пока <color=#409ccd>{0}</color> одобрит её.\n<color=orange>/duel c</color> - отменить заявку.";
        static string teamNewRequest = "<color=#409ccd>{0}</color> подал заявку на вступление в дуэль[<color={1}>{1}</color>].\n<color=orange>/duel accept</color> <color=#409ccd>{0}</color> - принять\nСписок подавших заявку: <color=orange>/duel accept</color>";
        static string teamNoDuelsHowCreate = "Активных командных дуэлей нет. /duel create - создать новую";
        static string teamGuiWeapons = "Оружие дуэлянтов: ";
        static string teamGuiNoWeapon = "не выбрал";
        static string teamGuiBluePlayerColor = "#76b9d6";
        static string teamGuiRedPlayerColor = "red";
        static string teamGuiWeaponColor = "#e0e1e3";
        static string teamGuiWaiting = "Ожидаем других игроков\n60 секунд максимум";
        static string teamDamageTeammate = "<color=#7b9ef6>{0}</color>: Эй! Я твой союзник!";
        static string teamDeath = "[Дуэль] <color=#7b9ef6>{0}</color> [<color={1}>{1}</color>] погиб!\n<color=blue>Team Blue</color>: {2} человек\n<color=red>Team Red</color>: {3} человек";

        static float teamDuelRequestSecToClose = 300;
        float cooldownTeamDuelCreate = 180f;
        float cooldownRequestSec = 60;
        static float requestSecToClose = 20;

        static float duelMaxSec = 300;
        static float chooseWeaponMaxSec = 25f;
        static float teamChooseWeaponMaxSec = 60f;
        int maxWinsTop = 5;
        int maxLoseTop = 5;

        static bool debug = true;

        #endregion

        #region Variables
        [PluginReference]
        Plugin Trade;
        static string duelJoinPermission = "duel.join";
        static string duelCreatePermission = "duel.create";
        private readonly int triggerLayer = LayerMask.GetMask("Trigger");
        bool isIni = false;
        static FieldInfo buildingPrivlidges;
        private MethodInfo newbuildingid = typeof(BuildingBlock).GetMethod("NewBuildingID", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static);
        static List<ActiveDuel> createdDuels = new List<ActiveDuel>();
        static List<TeamDuel> createdTeamDuels = new List<TeamDuel>();
        static List<ulong?> toRemoveCorpse = new List<ulong?>();
        Dictionary<ulong, float> lastRequestTime = new Dictionary<ulong, float>();
        Dictionary<ulong, float> lastTeamDuelCreateTime = new Dictionary<ulong, float>();
        static Dictionary<string, ulong> Wears = new Dictionary<string, ulong> //item shortname : skinid
        {
            {"metal.facemask", 0}, //shirt 
            {"metal.plate.torso", 0}, // Hat
            {"shoes.boots", 0}, // Pants
            {"hoodie", 0}, // Boots
			{"pants", 0}, // tolsovka
            {"roadsign.kilt", 0} // dorognie znaki
        };
        static Dictionary<string, ulong> WearsBlue = new Dictionary<string, ulong> //item id : skinid
        {
            {"metal.facemask", 0}, //hoodie
            {"metal.plate.torso", 0}, // Hat
            {"shoes.boots", 0}, // Pants
            {"hoodie", 0}, // Boots
			{"pants", 14178}, // tolsovka
            {"roadsign.kilt", 0} // dorognie znaki
        };
        static Dictionary<string, ulong> WearsRed = new Dictionary<string, ulong> //item id : skinid
        {
            {"metal.facemask", 0}, //hoodie 
            {"metal.plate.torso", 0}, // Hat
            {"shoes.boots", 0}, // Pants
            {"hoodie", 0}, // Boots
			{"pants", 0}, // tolsovka
            {"roadsign.kilt", 0} // dorognie znaki
        };
        private List<BaseEntity> ArenaEntities = new List<BaseEntity>();
        #endregion

        #region Helperss
        [PluginReference]
        Plugin NoEscape;

        bool IsRaidBlock(BasePlayer player)
        {
            if (plugins.Exists("NoEscape"))
            {
                var time = (double)NoEscape.Call("ApiGetTime", player.userID);
                if (time > 0)
                {
                    SendReply(player, "У Вас рейдблок, Duel запрещена");
                    return true;
                }
            }
            return false;
        }

        #endregion

        #region ChatCommand
        [ChatCommand("duel")]
        void chatduel(BasePlayer player, string command, string[] arg)
        {
            if (!isIni)
            {
                SendReply(player, "<color=#FE5256>Duel не инициирована. Ожидайте........ </color>");
                return;
            }
            if (arg.Length == 0)
            {
                SendReply(player, duelCommand);
                return;
            }
            if (IsRaidBlock(player)) return;
            if (player.metabolism.radiation_poison.value > 5)
            {
                SendReply(player, "У Вас облучение радиацией. Duel запрещена");
                return;
            }
            string aim = (string)arg[0];

            if (aim == "join")
            {
                if (!canAcceptRequest(player)) return;
                if (IsDuelPlayer(player))
                {
                    player.ChatMessage("Вы уже дуэлянт");
                    return;
                }
                if (arg.Length == 2)
                {
                    string team = (string)arg[1];
                    if (team != null)
                        JoinTeamDuel(player, team);
                    return;
                }
                else
                {
                    if (createdTeamDuels.Count > 0)
                    {
                        var teamDuel = createdTeamDuels[0];
                        player.ChatMessage($"Ошибка. Укажите команду, к которой хотите присоединиться\nВ команде red: {teamDuel.playersAmount - teamDuel.teamred.Count} свобоных мест\nВ команде blue: {teamDuel.playersAmount - teamDuel.teamblue.Count} свобоных мест");
                        return;
                    }
                    else
                    {
                        player.ChatMessage("Ошибка. Пишите:\n/duel join red - присоединиться к команде red\n/duel join blue - присоединиться к команде blue");
                        return;
                    }

                }
            }

            if (aim == "accept")
            {
                if (arg.Length == 2)
                {
                    string requester = (string)arg[1];
                    var target = FindPlayersSingle(requester, player);
                    if (target != null)
                        AcceptRequestTeamDuel(player, target);
                    return;
                }
                else
                {
                    if (createdTeamDuels.Count > 0)
                    {
                        string msg = "";
                        var teamDuel = createdTeamDuels[0];
                        if (teamDuel.owner != player)
                        {
                            player.ChatMessage("Ты не создатель дуэли");
                            return;
                        }
                        if (teamDuel.requestPlayers.Count > 0)
                        {
                            foreach (var pl in teamDuel.requestPlayers)
                            {
                                msg += $"<color=#409ccd>{pl.Key.displayName}</color>, ";
                            }
                            player.ChatMessage($"Игроки, подавшие заявку: {msg}\nПринять: <color=orange>/duel accept</color> <color=#409ccd>name</color>");
                            return;
                        }
                        else
                        {
                            player.ChatMessage("Список с заявками пуст.");
                            return;
                        }
                    }
                    else
                    {
                        player.ChatMessage("Командная дуэль не создана");
                        return;
                    }
                }
            }
            if (aim == "create")
            {
                if (!CanCreateDuel(player, true)) return;
                if (arg.Length >= 2)
                {
                    string amount = (string)arg[1];
                    int intamount = 0;
                    if (Int32.TryParse(amount, out intamount))
                    {
                        if (intamount > 1 && intamount <= 6)
                        {
                            if (arg.Length == 3)
                            {
                                string perm = (string)arg[2];
                                if (perm == "perm")
                                {
                                    if (!HavePerm(duelCreatePermission, player.userID)) return;
                                    createTeamDuel(player, intamount, true);
                                    return;
                                }
                            }
                            createTeamDuel(player, intamount);
                            return;
                        }
                        else
                        {
                            player.ChatMessage("Ошибка. Количество игроков в команде должно быть от 2 до 6");
                            return;
                        }
                    }
                    return;
                }
                else
                {
                    player.ChatMessage("Ошибка. Укажите количество участников (от 2 до 6) в каждой команде\n/duel create [2-6]");
                    return;
                }
            }
            if (aim == "top")
            {
                showTop(player);
                return;
            }
            if (aim == "stat")
            {
                showStat(player);
                return;
            }
            if (aim == "c")
            {
                CancelRequest(player);
                return;
            }

            if (aim == "a")
            {
                if (createdTeamDuels.Count > 0)
                {
                    var teamDuel = createdTeamDuels[0];
                    if (teamDuel.requestPlayers.ContainsKey(player))
                    {
                        player.ChatMessage("Ты подал заявку на командную дуэль.\nНачать новую ты не можешь");
                        return;
                    }
                }
                if (!canAcceptRequest(player)) return;
                if (!IsDuelPlayer(player))
                {
                    SendReply(player, dontHaveRequest);
                    return;
                }
                if (IsPlayerOnActiveDuel(player))
                {
                    player.ChatMessage("Вы уже находитесь на дуэли.");
                    return;
                }
                AcceptRequest(player);
                return;
            }
            var victim = FindPlayersSingle(aim, player);
            if (victim != null)
            {
                if (createdTeamDuels.Count > 0)
                {
                    var teamDuel = createdTeamDuels[0];
                    if (teamDuel.requestPlayers.ContainsKey(player))
                    {
                        player.ChatMessage("Ты подал заявку на командную дуэль.\nНачать новую ты не можешь");
                        return;
                    }
                }
                if (createdTeamDuels.Count > 0)
                {
                    var teamDuel = createdTeamDuels[0];
                    if (teamDuel.requestPlayers.ContainsKey(victim))
                    {
                        player.ChatMessage("Невозможно вызвать этого игрока");
                        return;
                    }
                }
                if (createdTeamDuels.Count > 0)
                {
                    var teamDuel = createdTeamDuels[0];
                    if (teamDuel.owner == victim)
                    {
                        player.ChatMessage("Невозможно вызвать этого игрока");
                        return;
                    }
                }
                if (victim == player)
                {
                    player.ChatMessage("Вы не можете вызвать самого себя на дуэль");
                    return;
                }
                if (!CanCreateDuel(player)) return;
                string reason = CanDuel(victim);
                if (reason != null)
                {
                    SendReply(player, reason);
                    return;
                }

                CreateRequest(player, victim);
                return;
            }
        }

        #endregion

        #region Checks
        bool IsArenaZone(Vector3 pos)
        {
            foreach (var arena in arenaList)
            {
                if (Vector3.Distance(pos, arena.pos) < 100)
                    return true;
            }
            return false;
        }
        void RemoveGarbage(BaseEntity entity)
        {
            if (entity == null) return;
            if (entity?.net?.ID == null) return;
            if (!isIni) return;
            if (entity.transform.position.y > 900f)
            {
                var cont = entity as DroppedItemContainer;
                if (cont != null)
                {
                    if (IsArenaZone(cont.transform.position))
                    {
                        cont.ResetRemovalTime(0.1f);
                    }
                }
                var corpse = entity as BaseCorpse;
                if (corpse != null)
                {
                    if (toRemoveCorpse.Count == 0) return;
                    if (corpse)
                    {
                        if ((corpse is PlayerCorpse) && corpse?.parentEnt?.ToPlayer())
                        {
                            if (corpse?.parentEnt?.ToPlayer() != null)
                            {
                                if (toRemoveCorpse.Contains(corpse?.parentEnt?.ToPlayer().userID))
                                {
                                    corpse.ResetRemovalTime(0.1f);
                                    toRemoveCorpse.Remove(corpse?.parentEnt?.ToPlayer().userID);
                                    return;
                                }
                            }
                        }
                    }
                }
                if (entity is PlayerCorpse || entity.name.Contains("item_drop_backpack"))
                {
                    if (entity.transform.position.y > 900f)
                    {
                        NextTick(() =>
                        {
                            if (entity != null && !entity.IsDestroyed)
                            {
                                entity.Kill();
                            }
                        });
                    }
                }
                if (entity is WorldItem)
                {
                    if ((entity as WorldItem).item.GetOwnerPlayer() == null) return;
                    var activeDuel = PlayersActiveDuel((entity as WorldItem).item.GetOwnerPlayer().userID);
                    if (activeDuel != null)
                    {
                        activeDuel.dropedWeapons.Add((entity as WorldItem).item);
                        return;
                    }
                    if (NeedToRemoveFromTeamDuel((entity as WorldItem).item.GetOwnerPlayer().userID))
                    {
                        createdTeamDuels[0].droppedWeapons.Add((entity as WorldItem).item);
                    }
                }
            }
        }

        bool NeedToRemoveFromTeamDuel(ulong? userid)
        {
            if (createdTeamDuels.Count > 0)
            {
                if (createdTeamDuels[0].allPlayers.Find(x => x.player.userID == userid))
                    return true;
            }
            return false;
        }

        ActiveDuel PlayersActiveDuel(ulong? userid)
        {
            if (createdDuels.Count == 0) return null;
            foreach (var duel in createdDuels)
            {
                if (duel.player1.player.userID == userid && duel.player1.haveweapon)
                {
                    return duel;
                }
                if (duel.player2.player.userID == userid && duel.player2.haveweapon)
                {
                    return duel;
                }
            }
            return null;
        }

        bool NeedToRemoveGarbage(ulong? userid)
        {
            int createdDuelsN = createdDuels.Count;
            if (createdDuelsN == 0) return false;
            if (createdDuels.Find(x => x.player1.player.userID == userid || x.player2.player.userID == userid)) return true;
            return false;
        }

        bool IsDuelPlayer(BasePlayer player)
        {
            DuelPlayer dueller = player?.GetComponent<DuelPlayer>();
            if (dueller == null) return false;
            return true;
        }

        bool IsPlayerOnActiveDuel(BasePlayer player)
        {
            DuelPlayer dueller = player?.GetComponent<DuelPlayer>();
            if (dueller == null) return false;
            if (!dueller.canDoSomeThings) return true;
            return false;
        }

        string CanDuel(BasePlayer player)
        {
            if (IsDuelPlayer(player))
            {
                return String.Format(alreadyHaveDuel, player.displayName);
            }
            if (busyArena.Count == arenaList.Count)
            {
                return noArenas;
            }
            return null;
        }

        bool canAcceptRequest(BasePlayer player)
        {
            if (player.IsDead())
            {
                return false;
            }
            if (player.IsWounded())
            {
                SendReply(player, notAllowed);
                return false;
            }
            if (busyArena.Count == arenaList.Count)
            {
                SendReply(player, noArenas);
                return false;
            }
            return true;
        }

        bool CanCreateDuel(BasePlayer player, bool isTeamDuel = false)
        {
            float value = 0;
            if (lastRequestTime.TryGetValue(player.userID, out value) && !isTeamDuel)
            {
                if (UnityEngine.Time.realtimeSinceStartup - value < cooldownRequestSec)
                {
                    float when = cooldownRequestSec - (UnityEngine.Time.realtimeSinceStartup - value);
                    player.ChatMessage(String.Format(cooldownMessage, (int)when));
                    return false;
                }
            }
            if (player.IsWounded())
            {
                SendReply(player, notAllowed);
                return false;
            }
            if (IsDuelPlayer(player))
            {
                SendReply(player, youOnDuel);
                return false;
            }
            if (busyArena.Count == arenaList.Count)
            {
                SendReply(player, noArenas);
                return false;
            }
            if (!isTeamDuel)
                lastRequestTime[player.userID] = UnityEngine.Time.realtimeSinceStartup;
            return true;
        }
        #endregion

        #region DuelFunctions
        void CreateRequest(BasePlayer starter, BasePlayer opponent)
        {
            SendReply(starter, String.Format(createRequest, opponent.displayName));
            SendReply(opponent, String.Format(receiveRequest, starter.displayName));
            DuelPlayer dueller1 = starter.GetComponent<DuelPlayer>() ?? starter.gameObject.AddComponent<DuelPlayer>();
            DuelPlayer dueller2 = opponent.GetComponent<DuelPlayer>() ?? opponent.gameObject.AddComponent<DuelPlayer>();
            ActiveDuel activeDuel = starter.gameObject.AddComponent<ActiveDuel>();
            activeDuel.player1 = dueller1;
            activeDuel.player2 = dueller2;
            createdDuels.Add(activeDuel);
        }

        void AcceptRequest(BasePlayer player)
        {
            Arena arena = null;
            foreach (var duel in createdDuels)
            {
                if (duel.player2.player == player)
                {
                    if (!canAcceptRequest(player) || !canAcceptRequest(duel.player1.player))
                    {
                        CancelRequest(player);
                        return;
                    }
                    duel.arena = FreeArena();
                    arena = duel.arena;
                    duel.isRequest = false;
                    duel.timeWhenTp = UnityEngine.Time.realtimeSinceStartup;
                    duel.player1.spawnPos = arena.player1pos;
                    duel.player2.spawnPos = arena.player2pos;
                    Debug($"Началась Дуэль {duel.player1.player.displayName} : {duel.player2.player.displayName} {arena.name} Активных: {busyArena.Count}");
                    toRemoveCorpse.Add(duel.player1.player.userID);
                    toRemoveCorpse.Add(duel.player2.player.userID);
                    duel.player1.PrepairToDuel();
                    duel.player2.PrepairToDuel();
                    Trade?.CallHook("RemovePending", duel.player1.player);
                    Trade?.CallHook("RemovePending", duel.player2.player);
                    break;
                }
            }
        }

        public void CancelRequest(BasePlayer player)
        {
            if (createdTeamDuels.Count > 0)
            {
                var duel = createdTeamDuels[0];
                if (duel.owner == player && !duel.isStarted && !duel.allHere)
                {
                    if (duel.teamblue.Count > 0)
                        foreach (var dueller in duel.teamblue)
                        {
                            dueller.Destroy();
                        }
                    if (duel.teamred.Count > 0)
                        foreach (var dueller in duel.teamred)
                        {
                            dueller.Destroy();
                        }
                    PrintToChat("Командная дуэль отменена создателем");
                    duel.Destroy();
                    return;
                }
                if (duel.requestPlayers.ContainsKey(player))
                {
                    duel.requestPlayers.Remove(player);
                    player.ChatMessage("Вы покинули командную дуэль");
                    duel.owner.ChatMessage($"{player.displayName} отменил заявку на дуэль");
                    return;
                }
                var redplayer = duel.teamred.Find(x => x.player == player);
                if (redplayer != null)
                {
                    if (!redplayer.haveweapon && !duel.isStarted && !duel.allHere)
                    {
                        duel.teamred.Remove(redplayer);
                        redplayer.Destroy();
                        duel.owner.ChatMessage($"{player.displayName} покинул командную дуэль");
                        player.ChatMessage("Вы покинули командную дуэль");
                        return;
                    }
                    else
                    {
                        player.ChatMessage("Вы не можете покинуть начавшуюся дуэль");
                        return;
                    }
                }
                var blueplayer = duel.teamblue.Find(x => x.player == player);
                if (blueplayer != null)
                {
                    if (!blueplayer.haveweapon && !duel.isStarted && !duel.allHere)
                    {
                        duel.teamblue.Remove(blueplayer);
                        blueplayer.Destroy();
                        duel.owner.ChatMessage($"{player.displayName} покинул командную дуэль");
                        player.ChatMessage("Вы покинули командную дуэль");
                        return;
                    }
                    else
                    {
                        player.ChatMessage("Вы не можете покинуть начавшуюся дуэль");
                        return;
                    }
                }
            }
            if (FindOpponent(player) != null)
            {
                var duel = FindDuelByPlayer(player);
                if (duel != null)
                {
                    if (duel.isRequest)
                    {
                        duel.RequestRemove();
                        return;
                    }
                    else
                    {
                        player.ChatMessage(cantCancelDuel);
                        return;
                    }
                }
            }
            player.ChatMessage("Вы не участник дуэли");
        }

        static ActiveDuel FindDuelByPlayer(BasePlayer player)
        {
            foreach (var duel in createdDuels)
            {
                if (duel.player1.player == player)
                {
                    return duel;
                }
                if (duel.player2.player == player)
                {
                    return duel;
                }
            }
            return null;
        }

        public void EndDuel(BasePlayer player, int reason, string UserId, string UserIdLoss)
        {
            DuelPlayer dueller = player?.GetComponent<DuelPlayer>();
            if (dueller != null)
            {
                if (dueller.team != "")
                {
                    if (reason == 6)
                    {
                        if (dueller.savedHome)
                        {
                            dueller.ReturnPlayer(reason);
                        }
                        else
                        {
                            dueller.Destroy();
                        }
                        return;
                    }

                    if (reason == 0 || reason == 4)
                    {
                        dueller.ReturnPlayer(reason);
                    }
                    return;
                }
            }
            if (createdTeamDuels.Count > 0 && reason == 4)
            {
                if (createdTeamDuels[0].owner == player)
                {
                    createdTeamDuels[0].RequestRemove();
                    return;
                }
                if (createdTeamDuels[0].requestPlayers.ContainsKey(player))
                {
                    createdTeamDuels[0].requestPlayers.Remove(player);
                    createdTeamDuels[0].owner.ChatMessage($"[Дуэль] {player.displayName} вышел с сервера!");
                    return;
                }
            }
            if (createdDuels.Count == 0) return;
            DuelPlayer player1 = null;
            DuelPlayer player2 = null;
            foreach (var duel in createdDuels)
            {
                if (duel.player1.player == player)
                {
                    player1 = duel.player1;
                    player2 = duel.player2;
                    break;
                }
                if (duel.player2.player == player)
                {
                    player1 = duel.player1;
                    player2 = duel.player2;
                    break;
                }
            }
            if (reason == 0)
            {
                if (player1 != null)
                    if (player1.player == player)
                    {
                        player1.guiEnabled = false;
                        player1.canMove = true;
                        player1.ReturnPlayer(0);
                        return;
                    }
                if (player2 != null)
                    if (player2.player == player)
                    {
                        player2.guiEnabled = false;
                        player2.canMove = true;
                        player2.ReturnPlayer(0);
                        return;
                    }
            }
            if (reason == 7)
            {
                if (player1 != null)
                    if (player1.player == player)
                    {
                        player2.guiEnabled = false;
                        player2.canMove = true;
                        if (player2.induel)
                            player2.ReturnWithCooldown();
                        player2.induel = false;
                        return;
                    }
                if (player2 != null)
                    if (player2.player == player)
                    {
                        player1.guiEnabled = false;
                        player1.canMove = true;
                        if (player1.induel)
                            player1.ReturnWithCooldown();
                        player1.induel = false;
                        return;
                    }
            }
            if (player1 != null)
            {
                player1.guiEnabled = false;
                player1.canMove = true;
                player1.ReturnPlayer(reason);
            }
            if (player2 != null)
            {
                player2.guiEnabled = false;
                player2.canMove = true;
                player2.ReturnPlayer(reason);
            }
        }
        #endregion

        #region TeamDuel

        #region Class TeamDuel

        class TeamDuel : MonoBehaviour
        {
            public List<DuelPlayer> teamblue = new List<DuelPlayer>();
            public List<DuelPlayer> teamred = new List<DuelPlayer>();
            public List<DuelPlayer> allPlayers = new List<DuelPlayer>();
            public List<BasePlayer> statTeamBlue = new List<BasePlayer>();
            public List<BasePlayer> statTeamRed = new List<BasePlayer>();
            public Dictionary<BasePlayer, string> requestPlayers = new Dictionary<BasePlayer, string>();
            public BasePlayer owner;
            public Arena arena = null;
            public bool isRequest = true;
            public bool isStarted = false;
            public bool needCheckStart;
            public bool isActive = true;
            public bool allHere;
            public bool allReady;
            public bool isPermDuel = false;
            public bool randomWeaponsHasGiven = false;

            public float guiTime;
            public int playersAmount = -1;
            public float startTime;
            public float requestTime;
            public float lastTimeMessage = 0f;
            public List<Item> droppedWeapons = new List<Item>();
            void Awake()
            {
                requestTime = UnityEngine.Time.realtimeSinceStartup;
                allHere = false;
                allReady = false;
            }

            public void CheckOnline()
            {
                int redCount = teamred.Count;
                int blueCount = teamblue.Count;
                List<string> offPlayers = new List<string>();
                if (redCount > 0)
                {
                    for (int i = 0; i < redCount; i++)
                    {
                        if (teamred[i] == null)
                        {
                            offPlayers.Add(teamred[i].player.displayName);
                            allPlayers.Remove(teamred[i]);
                            teamred.Remove(teamred[i]);
                            break;
                        }
                    }
                }
                if (blueCount > 0)
                {
                    for (int i = 0; i < blueCount; i++)
                    {
                        if (teamblue[i] == null)
                        {
                            offPlayers.Add(teamblue[i].player.displayName);
                            allPlayers.Remove(teamblue[i]);
                            teamblue.Remove(teamblue[i]);
                            break;
                        }
                    }
                }
                redCount = teamred.Count;
                blueCount = teamblue.Count;
                int offPlayersCount = offPlayers.Count;
                if (offPlayersCount > 0)
                {
                    if (blueCount > 0)
                    {
                        for (int i = 0; i < blueCount; i++)
                        {
                            for (int j = 0; j < offPlayersCount; j++)
                                teamblue[i].player.ChatMessage(String.Format(teamPlayerDisconnect, offPlayers[j]));
                        }
                    }
                    if (redCount > 0)
                    {
                        for (int i = 0; i < redCount; i++)
                        {
                            for (int j = 0; j < offPlayersCount; j++)
                                teamred[i].player.ChatMessage(String.Format(teamPlayerDisconnect, offPlayers[j]));
                        }
                    }
                }
            }

            void Update()
            {
                if (isActive)
                {
                    CheckOnline();
                }
                if (!isStarted && !allHere && teamblue.Count > 0 && teamred.Count > 0)
                {
                    if ((teamblue.Count + teamred.Count) == (playersAmount * 2))
                    {
                        allHere = true;
                        int teamPlayersN = teamblue.Count;
                        for (int i = 0; i < teamPlayersN; i++)
                        {
                            var tmb = teamblue[i];
                            var tmr = teamred[i];
                            statTeamBlue.Add(tmb.player);
                            statTeamRed.Add(tmr.player);
                            allPlayers.Add(tmb);
                            allPlayers.Add(tmr);
                        }
                        Invoke("CheckDuellers", 5f);
                        needCheckStart = true;
                    }
                }

                if (needCheckStart)
                {
                    if (isStarted && isActive)
                    {
                        if (teamblue.Count == 0)
                        {
                            isStarted = false;
                            isActive = false;
                            ConsoleNetwork.BroadcastToAllClients("chat.add", 0, teamWinRed);
                            int statPlayersN = statTeamRed.Count;
                            for (int i = 0; i < statPlayersN; i++)
                            {
                                db.playerStat[statTeamRed[i].userID].teamwins++;
                                db.playerStat[statTeamBlue[i].userID].teamloss++;
                            }
                            Invoke("EndTeamDuelWithWinners", 5f);
                            return;
                        }
                        if (teamred.Count == 0)
                        {
                            isStarted = false;
                            isActive = false;
                            ConsoleNetwork.BroadcastToAllClients("chat.add", 0, teamWinBlue);
                            int statPlayersN = statTeamRed.Count;
                            for (int i = 0; i < statPlayersN; i++)
                            {
                                db.playerStat[statTeamBlue[i].userID].teamwins++;
                                db.playerStat[statTeamRed[i].userID].teamloss++;
                            }
                            Invoke("EndTeamDuelWithWinners", 5f);
                            return;
                        }
                        if (UnityEngine.Time.realtimeSinceStartup - startTime > duelMaxSec)
                        {
                            EndTeamDuel(3);
                            isActive = false;
                        }
                    }
                    if (allReady && !isStarted)
                    {
                        bool go = true;
                        int allPlayersCount = allPlayers.Count;
                        for (int i = 0; i < allPlayersCount; i++)
                        {
                            if (!allPlayers[i].haveweapon) go = false;
                        }
                        if (UnityEngine.Time.realtimeSinceStartup - guiTime > teamChooseWeaponMaxSec && !randomWeaponsHasGiven)
                        {
                            for (int i = 0; i < allPlayersCount; i++)
                            {
                                if (!allPlayers[i].haveweapon) GiveRandomWeapon(allPlayers[i].player);
                            }
                            randomWeaponsHasGiven = true;
                            go = true;
                        }
                        if (go)
                        {
                            startTime = UnityEngine.Time.realtimeSinceStartup;
                            isStarted = true;
                            allReady = false;
                            Invoke("StartTeamDuel", 5f);
                        }
                    }
                }
                if (isRequest && isActive)
                {
                    if (UnityEngine.Time.realtimeSinceStartup - requestTime > teamDuelRequestSecToClose)
                    {
                        RequestRemove();
                        isActive = false;
                    }
                }
            }

            public void CheckDuellers()
            {
                if (allReady) return;
                bool isWound = false;
                int allPlayersCount = allPlayers.Count;
                for (int i = 0; i < allPlayersCount; i++)
                {
                    if (allPlayers[i].player.IsWounded())
                    {
                        isWound = true;
                    }
                }
                if (isWound)
                {
                    if (lastTimeMessage != 0f && UnityEngine.Time.realtimeSinceStartup - lastTimeMessage > 10f)
                    {
                        for (int i = 0; i < allPlayersCount; i++)
                        {
                            allPlayers[i].player.ChatMessage(teamDuellerWounded);
                        }
                        lastTimeMessage = UnityEngine.Time.realtimeSinceStartup;
                        Invoke("CheckDuellers", 0.5f);
                        return;
                    }
                }
                arena = FindFreeTeamDuelArena(playersAmount);
                if (arena == null)
                {
                    if (lastTimeMessage != 0f && UnityEngine.Time.realtimeSinceStartup - lastTimeMessage > 10f)
                    {
                        for (int i = 0; i < allPlayersCount; i++)
                        {
                            allPlayers[i].player.ChatMessage(teamArensBusy);
                        }
                    }
                    lastTimeMessage = UnityEngine.Time.realtimeSinceStartup;
                    Invoke("CheckDuellers", 0.5f);
                    return;
                }
                SetSpawns();
                guiTime = UnityEngine.Time.realtimeSinceStartup;
                allReady = true;
                PrepareDuellers();
            }

            public void PrepareDuellers()
            {
                isRequest = false;
                int allPlayersN = allPlayers.Count;
                for (int i = 0; i < allPlayersN; i++)
                {
                    allPlayers[i].PrepairToDuel();
                }
            }

            public void StartTeamDuel()
            {
                int allPlayersN = allPlayers.Count;
                for (int i = 0; i < allPlayersN; i++)
                {
                    var dueller = allPlayers[i];
                    toRemoveCorpse.Add(dueller.player.userID);
                    dueller.guiEnabled = false;
                    CuiHelper.DestroyUi(dueller.player, "weaponsgui");
                    CuiHelper.DestroyUi(dueller.player, "weaponsguiteamweapons");
                    CuiHelper.DestroyUi(dueller.player, "mouse");
                    dueller.readyForBattle = true;
                    dueller.canMove = true;
                }
            }

            public void RequestRemove()
            {
                if (teamblue.Count > 0)
                {
                    foreach (DuelPlayer teamblueplayer in teamblue)
                    {
                        teamblueplayer.player.ChatMessage(String.Format(teamDuelCancelled, teamDuelRequestSecToClose));
                        teamblueplayer.Destroy();
                    }
                }
                if (teamred.Count > 0)
                {
                    foreach (DuelPlayer teamredplayer in teamred)
                    {
                        teamredplayer.player.ChatMessage(String.Format(teamDuelCancelled, teamDuelRequestSecToClose));
                        teamredplayer.Destroy();
                    }
                }
                Destroy();
            }

            public void EndTeamDuelWithWinners()
            {
                Debug($"Team Дуэль {playersAmount} * {playersAmount} от {owner.displayName} Окончена {arena.name}");
                int allPlayersN = allPlayers.Count;
                if (allPlayersN > 0)
                {
                    for (int i = 0; i < allPlayersN; i++)
                    {
                        allPlayers[i].ReturnPlayer(0);
                    }
                }
                Invoke("Destroy", 2f);
            }

            public void EndTeamDuel(int reason = 0)
            {
                Debug($"Team Дуэль {playersAmount} * {playersAmount} от {owner.displayName} Прервана {arena.name}");
                int allPlayersN = allPlayers.Count;
                if (allPlayersN > 0)
                {
                    for (int i = 0; i < allPlayersN; i++)
                    {
                        var dueller = allPlayers[i];
                        dueller.guiEnabled = false;
                        CuiHelper.DestroyUi(dueller.player, "weaponsgui");
                        CuiHelper.DestroyUi(dueller.player, "weaponsguiteamweapons");
                        CuiHelper.DestroyUi(dueller.player, "mouse");
                        dueller.ReturnPlayer(reason);
                    }
                }
                Invoke("Destroy", 2f);
            }
            public void Destroy()
            {
                int droppedWeaponsN = droppedWeapons.Count;
                if (droppedWeaponsN > 0)
                {
                    for (int i = 0; i < droppedWeaponsN; i++)
                    {
                        var item = droppedWeapons[i];
                        if (item != null) ItemManager.RemoveItem(item, 1f);
                    }
                    droppedWeapons.Clear();
                }
                busyArena.Remove(arena);
                createdTeamDuels.Remove(this);
                UnityEngine.Object.Destroy(this);
            }
        }

        #endregion

        #region TeamDuelFunctions

        public static void SetSpawns()
        {
            int i = 0;
            TeamDuel duel = createdTeamDuels[0];
            foreach (var player in duel.allPlayers)
            {
                if (player.team == "red")
                {
                    player.spawnPos = duel.arena.teamredSpawns[i];
                    i++;
                }
            }
            i = 0;
            foreach (var player in duel.allPlayers)
            {
                if (player.team == "blue")
                {
                    player.spawnPos = duel.arena.teamblueSpawns[i];
                    i++;
                }
            }
        }

        public static Arena FindFreeTeamDuelArena(int slot)
        {
            Arena randomarena = new Arena();
            List<Arena> freeArenas = new List<Arena>();
            Arena value = new Arena();
            foreach (var arena in arenaList)
            {
                if (!busyArena.Contains(arena) && arena.teamblueSpawns.Count >= slot)
                    freeArenas.Add(arena);
            }
            if (freeArenas.Count > 0)
            {
                int random = UnityEngine.Random.Range(0, freeArenas.Count);
                randomarena = freeArenas[random];
                busyArena.Add(randomarena);
                return randomarena;
            }
            return null;
        }

        void createTeamDuel(BasePlayer player, int amount, bool perm = false)
        {
            float value = 0;
            if (lastTeamDuelCreateTime.TryGetValue(player.userID, out value))
            {
                if (UnityEngine.Time.realtimeSinceStartup - value < cooldownTeamDuelCreate)
                {
                    var timetocreate = cooldownTeamDuelCreate - (UnityEngine.Time.realtimeSinceStartup - value);
                    player.ChatMessage(String.Format(teamCooldownToCreate, (int)timetocreate));
                    return;
                }
            }
            lastTeamDuelCreateTime[player.userID] = UnityEngine.Time.realtimeSinceStartup;
            if (createdTeamDuels.Count > 0)
            {
                player.ChatMessage(teamAlreadyCreated);
                return;
            }
            TeamDuel teamDuel = player.gameObject.AddComponent<TeamDuel>();
            teamDuel.owner = player;
            string ispermduel = " ";
            if (perm)
            {
                teamDuel.isPermDuel = true;
                ispermduel = teamCreatedPermPref;
            }
            teamDuel.playersAmount = amount;
            createdTeamDuels.Add(teamDuel);
            PrintToChat(String.Format(teamSucessCreated, player.displayName, ispermduel, amount));
            player.ChatMessage(teamCancelDuel);
            Debug($"Создана Team Дуэль {amount} * {amount} Создатель: {player.displayName}");
        }

        void AcceptRequestTeamDuel(BasePlayer owner, BasePlayer target)
        {
            if (createdTeamDuels.Count == 0)
            {
                owner.ChatMessage(teamNoDuelsHowCreate);
                return;
            }
            var duel = createdTeamDuels[0];
            if (duel.owner != owner)
            {
                owner.ChatMessage(teamNotOwner);
                return;
            }
            if (duel.requestPlayers.ContainsKey(target))
            {
                var team = duel.requestPlayers[target];
                if (team == "blue")
                {
                    if (duel.teamblue.Count == duel.playersAmount)
                    {
                        owner.ChatMessage(teamNoSlotsBlue);
                        return;
                    }
                    DuelPlayer duelPlayer = target.GetComponent<DuelPlayer>() ?? target.gameObject.AddComponent<DuelPlayer>();
                    duelPlayer.team = "blue";
                    duel.teamblue.Add(duelPlayer);
                }
                if (team == "red")
                {
                    if (duel.teamred.Count == duel.playersAmount)
                    {
                        owner.ChatMessage(teamNoSlotsRed);
                        return;
                    }
                    DuelPlayer duelPlayer = target.GetComponent<DuelPlayer>() ?? target.gameObject.AddComponent<DuelPlayer>();
                    duelPlayer.team = "red";
                    duel.teamred.Add(duelPlayer);
                }
                duel.requestPlayers.Remove(target);
                string where = "";
                if (team == "red") where = teamJoinRedPref;
                if (team == "blue") where = teamJoinBluePref;
                string ispermduel = "";
                if (duel.isPermDuel)
                    ispermduel = teamJoinPermPref;

                if (duel.teamblue.Count + duel.teamred.Count == duel.playersAmount * 2)
                {
                    for (int i = 0; i < duel.playersAmount; i++)
                    {
                        duel.teamblue[i].player.ChatMessage(teamAboutToBegin);
                        duel.teamred[i].player.ChatMessage(teamAboutToBegin);
                    }
                    PrintToChat(String.Format(teamJoinAboutToBeginAnnounce, ispermduel, target.displayName, where));
                    Debug($"Начинается Team Дуэль {duel.playersAmount} * {duel.playersAmount} Создатель: {duel.owner.displayName}");
                    return;
                }
                PrintToChat(String.Format(teamJoinAnnounce, ispermduel, target.displayName, where, duel.playersAmount - duel.teamred.Count, duel.playersAmount - duel.teamblue.Count));
            }
            else
            {
                owner.ChatMessage(String.Format(teamPlayerWont, target.displayName));
                return;
            }
        }

        void JoinTeamDuel(BasePlayer player, string team)
        {
            if (team != "blue" && team != "red")
            {
                player.ChatMessage(teamErrorNoCommand);
                return;
            }
            if (createdTeamDuels.Count > 0)
            {
                var teamDuel = createdTeamDuels[0];
                if (teamDuel.owner == player)
                {
                    if (team == "blue")
                    {
                        if (teamDuel.teamblue.Count == teamDuel.playersAmount)
                        {
                            player.ChatMessage(teamNoSlotsBlue);
                            return;
                        }
                        DuelPlayer duelPlayer = player.GetComponent<DuelPlayer>() ?? player.gameObject.AddComponent<DuelPlayer>();
                        duelPlayer.team = "blue";
                        teamDuel.teamblue.Add(duelPlayer);
                    }
                    if (team == "red")
                    {
                        if (teamDuel.teamred.Count == teamDuel.playersAmount)
                        {
                            player.ChatMessage(teamNoSlotsRed);
                            return;
                        }
                        DuelPlayer duelPlayer = player.GetComponent<DuelPlayer>() ?? player.gameObject.AddComponent<DuelPlayer>();
                        duelPlayer.team = "red";
                        teamDuel.teamred.Add(duelPlayer);
                    }
                    string where = "";
                    if (team == "red") where = teamJoinRedPref;
                    if (team == "blue") where = teamJoinBluePref;
                    string ispermduel = "";
                    if (teamDuel.isPermDuel)
                        ispermduel = teamJoinPermPref;
                    if (teamDuel.teamblue.Count + teamDuel.teamred.Count == teamDuel.playersAmount * 2)
                    {
                        for (int i = 0; i < teamDuel.playersAmount; i++)
                        {
                            teamDuel.teamblue[i].player.ChatMessage(teamAboutToBegin);
                            teamDuel.teamred[i].player.ChatMessage(teamAboutToBegin);
                        }
                        PrintToChat(String.Format(teamJoinAboutToBeginAnnounce, ispermduel, player.displayName, where));
                        return;
                    }
                    PrintToChat(String.Format(teamJoinAnnounce, ispermduel, player.displayName, where, teamDuel.playersAmount - teamDuel.teamred.Count, teamDuel.playersAmount - teamDuel.teamblue.Count));
                    return;
                }
                if (teamDuel.requestPlayers.ContainsKey(player))
                {
                    player.ChatMessage(teamAlreadyRequest);
                    return;
                }
                if (teamDuel.isStarted)
                {
                    player.ChatMessage(teamAlreadyStarted);
                    return;
                }
                if (teamDuel.isPermDuel)
                {
                    if (!HavePerm(duelJoinPermission, player.userID))
                    {
                        player.ChatMessage(teamNoPerm);
                        return;
                    }
                }
                if (team == "blue")
                {
                    if (teamDuel.teamblue.Count == teamDuel.playersAmount)
                    {
                        player.ChatMessage(teamNoSlotsBlue);
                        return;
                    }
                    teamDuel.requestPlayers[player] = team;
                }
                if (team == "red")
                {
                    if (teamDuel.teamred.Count == teamDuel.playersAmount)
                    {
                        player.ChatMessage(teamNoSlotsRed);
                        return;
                    }
                    teamDuel.requestPlayers[player] = team;
                }
                player.ChatMessage(String.Format(teamSucessRequest, teamDuel.owner.displayName));
                teamDuel.owner.ChatMessage(String.Format(teamNewRequest, player.displayName, team));
            }
            else
            {
                player.ChatMessage(teamNoDuelsHowCreate);
                return;
            }
        }
        #endregion

        #endregion

        #region Class ActiveDuel
        class ActiveDuel : MonoBehaviour
        {
            public DuelPlayer player1;
            public DuelPlayer player2;
            public bool isStarted;
            public bool aboutToStart;
            public bool isRequest;
            public bool isEnd;
            public bool bothReady = false;

            public float startTime;
            public float requestTime;
            public float guiTimeToRandom = 0f;
            public float timeWhenTp;

            public Arena arena = null;

            public List<Item> dropedWeapons = new List<Item>();
            void Awake()
            {
                isRequest = true;
                requestTime = UnityEngine.Time.realtimeSinceStartup;
                isStarted = false;
                aboutToStart = false;
                isEnd = false;
            }

            void Update()
            {
                float now = UnityEngine.Time.realtimeSinceStartup;
                if (isRequest)
                {
                    if (now - requestTime > requestSecToClose)
                    {
                        RequestRemove();
                        return;
                    }
                    return;
                }

                if (!bothReady && !isStarted && !isEnd)
                {
                    if (player1.isReady && player2.isReady)
                    {
                        guiTimeToRandom = now;
                        bothReady = true;
                    }
                    if (now - timeWhenTp > 60)
                    {
                        EndDuel(9);
                        isEnd = true;
                        return;
                    }
                }

                if (!aboutToStart)
                {
                    if (player1.readyForBattle && player2.readyForBattle)
                    {
                        aboutToStart = true;
                        TimerToStart();
                        return;
                    }
                }

                if (!isRequest && !isEnd)
                {
                    if (isStarted)
                    {
                        if (now - startTime > duelMaxSec)
                        {
                            isEnd = true;
                            EndDuel(3);
                            return;
                        }
                    }
                    if (!player1.player.IsConnected || !player2.player.IsConnected)
                    {
                        isEnd = true;
                        EndDuel(4);
                        return;
                    }
                    if (player1 == null || player2 == null)
                    {
                        isEnd = true;
                        EndDuel();
                        return;
                    }
                }
            }

            public void RequestRemove()
            {
                player1.player.ChatMessage(String.Format(duelHasBeenCancelled, player2.player.displayName));
                player2.player.ChatMessage(String.Format(duelHasBeenCancelled, player1.player.displayName));
                player1.Destroy();
                player2.Destroy();
                Destroy();
            }

            public void TimerToStart()
            {
                aboutToStart = true;
                Invoke("StartDuel", 5f);
            }

            public void StartDuel()
            {
                CancelInvoke("StartDuel");
                if (isStarted) return;
                startTime = UnityEngine.Time.realtimeSinceStartup;
                CuiHelper.DestroyUi(player1.player, "weaponsgui");
                CuiHelper.DestroyUi(player1.player, "mouse");
                CuiHelper.DestroyUi(player2.player, "weaponsgui");
                CuiHelper.DestroyUi(player2.player, "mouse");
                player1.guiEnabled = false;
                player2.guiEnabled = false;
                player1.readyForBattle = false;
                player2.readyForBattle = false;
                player1.canMove = true;
                player2.canMove = true;
                isStarted = true;
                player1.player.InitializeHealth(100, 100);
                player1.player.metabolism.bleeding.@value = 0;
                player2.player.InitializeHealth(100, 100);
                player2.player.metabolism.bleeding.@value = 0;
                player1.player.ChatMessage(duelStart);
                player2.player.ChatMessage(duelStart);
            }
            public void EndDuel(int reason = 0)
            {
                Debug($"Дуэль окончена {player1.player.displayName} и {player2.player.displayName} {arena.name}");
                if (player1 != null)
                {
                    if (!player1.isReturned)
                        player1.ReturnPlayer(reason);
                }
                if (player2 != null)
                {
                    if (!player2.isReturned)
                        player2.ReturnPlayer(reason);
                }
                isStarted = false;
                Destroy();
            }
            public void Destroy()
            {
                int dropedWeaponsN = dropedWeapons.Count;
                if (dropedWeaponsN > 0)
                {
                    for (int i = 0; i < dropedWeaponsN; i++)
                    {
                        var item = dropedWeapons[i];
                        if (item == null) continue;
                        ItemManager.RemoveItem(item, 1f);
                    }
                    dropedWeapons.Clear();
                }
                busyArena.Remove(arena);
                createdDuels.Remove(this);
                UnityEngine.Object.Destroy(this);
            }
        }
        #endregion

        #region Class DuelPlayer
        class DuelPlayer : MonoBehaviour
        {
            public BasePlayer player;

            public float health;
            public float calories;
            public float hydration;
            public float readyTime = 0f;

            public bool savedInventory;
            public bool savedHome;
            public bool canMove = true;
            public bool guiEnabled;
            public bool guiMouseEnabled;
            public bool haveweapon;
            public bool induel = true;
            public bool readyForBattle = false;
            public bool canDoSomeThings;
            public bool isDeath;
            public bool isTeamDuel;
            public bool isReturned = false;
            public bool isReady = false;

            public string currentClass;
            public string weapon = "";
            public string team = "";

            public Vector3 Home;
            public Vector3 spawnPos;

            //public List<ItemsToRestore> InvItems = new List<ItemsToRestore>();

            void Awake()
            {
                isDeath = false;
                canDoSomeThings = true;
                haveweapon = false;
                guiMouseEnabled = false;
                savedInventory = false;
                savedHome = false;
                player = GetComponent<BasePlayer>();
                newStat(player);
            }

            public void StopMove()
            {
                if (canMove) return;
                if (!player.IsConnected)
                {
                    ReturnPlayer(4);
                    return;
                }
                if (player.IsSleeping()) return;
                if (player.IsWounded())
                {
                    player.StopWounded();
                    player.UpdatePlayerCollider(false);
                }
                player.Teleport(spawnPos);
            }

            public void UpdateGUI()
            {
                CancelInvoke("UpdateGUI");
                if (team == "")
                {
                    if (DuellerArena().guiTimeToRandom > 0 && UnityEngine.Time.realtimeSinceStartup - DuellerArena().guiTimeToRandom > chooseWeaponMaxSec && !haveweapon)
                    {
                        GiveRandomWeapon(player);
                    }
                }
                if (!guiEnabled) return;
                //InvokeRepeating("UpdateGUI", 5f, 5f);
                Invoke("UpdateGUI", 1f);
                WeaponsGUI(player);
            }

            private ActiveDuel DuellerArena()
            {
                foreach (var duel in createdDuels)
                {
                    if (duel.player1 == this)
                    {
                        return duel;
                    }
                    if (duel.player2 == this)
                    {
                        return duel;
                    }
                }
                return null;
            }

            public void Stopper() //стопит чела
            {
                if (!canMove)
                {
                    StopMove();
                    Invoke("Stopper", 0.1f);
                }
            }

            public void PrepairToDuel()
            {
                if (player.IsDead())
                {
                    Invoke("PrepairToDuel", 1f);
                    return;
                }
                SavePlayer(player);
                canDoSomeThings = false;
                player.metabolism.Reset();
                player.metabolism.calories.Add(500);
                player.metabolism.hydration.Add(250);
                player.InitializeHealth(100, 100);
                if (player.IsWounded())
                {
                    player.StopWounded();
                    player.UpdatePlayerCollider(false);
                }
                TPPlayer(player, spawnPos);
                canMove = false;
                Invoke("Stopper", 2f);
                CheckReady();
            }

            public void ReturnWithCooldown()
            {
                if (induel)
                {
                    Invoke("ReturnWithCooldown", 5f);
                    induel = false;
                    return;
                }
                else
                {
                    ReturnPlayer(0);
                }
            }

            public void ReturnPlayer(int reason = 0)
            {
                if (isReturned) return;
                SendChatMessage(reason);
                if (!savedHome)
                {
                    Destroy();
                    return;
                }
                if (player.IsWounded())
                {
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.Wounded, false);
                    player.CancelInvoke("WoundingEnd");
                    player.CancelInvoke("WoundingTick");
                    player.SendNetworkUpdateImmediate(false);
                }
                CuiHelper.DestroyUi(player, "weaponsgui");
                CuiHelper.DestroyUi(player, "mouse");
                CuiHelper.DestroyUi(player, "weaponsguiteamweapons");
                canMove = true;
                player.InitializeHealth(health, 100);
                // player.health = health;
                player.metabolism.calories.@value = calories;
                player.metabolism.hydration.@value = hydration;
                player.metabolism.bleeding.@value = 0;
                TeleportHome();
                RestoreInventory(player); //проверить
                                        
                isReturned = true;
                Destroy();
            }

            public void SendChatMessage(int reason = 0)
            {
                switch (reason)
                {
                    case 0:
                        break;
                    case 1:
                        player.ChatMessage(String.Format(returnPlayerReason, returnReasonSleep));
                        break;
                    case 2:
                        player.ChatMessage(String.Format(returnPlayerReason, returnReasonGUIFail));
                        break;
                    case 3:
                        player.ChatMessage(String.Format(returnPlayerReason, String.Format(returnReasonLimitTime, duelMaxSec)));
                        break;
                    case 4:
                        player.ChatMessage(String.Format(returnPlayerReason, returnReasonDisconnect));
                        break;
                    case 5:
                        player.ChatMessage(String.Format(returnPlayerReason, returnReasonSurrender));
                        break;
                    case 6:
                        player.ChatMessage(String.Format(returnPlayerReason, returnReasonUnload));
                        break;
                    case 9:
                        player.ChatMessage("Один из дуэлянтов не проснулся за минуту");
                        break;
                }
            }

            public void Destroy()
            {
                if (toRemoveCorpse.Contains(player.userID)) toRemoveCorpse.Remove(player.userID);
                UnityEngine.Object.Destroy(this);
            }

            public void CheckReady()
            {
                if (!player.IsSleeping())
                {
                    guiEnabled = true;
                    isReady = true;
                    UpdateGUI();
                    return;
                }
                Invoke("CheckReady", 1f);
            }

            public void SaveHealth()
            {
                health = player.health;
                calories = player.metabolism.calories.value;
                hydration = player.metabolism.hydration.value;
            }
            public void SaveHome()
            {
                if (!savedHome)
                    Home = player.transform.position;
                savedHome = true;
            }

            public void SavePlayer(BasePlayer player)
            {
                SaveHome();
                SaveHealth();
                SaveInventory(player);
            }

            public void TeleportHome()
            {
                TPPlayer(player, Home);
                savedHome = false;
            }
            class PlayerInfo
            {
                public bool RestoreOnce = false;
                public List<SavedItem> Items;
            }

            static Dictionary<ulong, PlayerInfo> cachedInventories = new Dictionary<ulong, PlayerInfo>();

            bool SaveInventory(BasePlayer player)
            {
                List<SavedItem> items = GetPlayerItems(player);
                if (!cachedInventories.ContainsKey(player.userID))
                    cachedInventories.Add(player.userID, new PlayerInfo { });
                cachedInventories[player.userID].Items = items;
                StringBuilder sb = new StringBuilder(500);
                sb.Append(player.displayName + " SAVE" + '\n');
                foreach (var i in items)
                    sb.Append(i.shortname + '\n');
                sb.Clear();
                return true;
            }

            List<SavedItem> GetPlayerItems(BasePlayer player)
            {
                List<SavedItem> kititems = (from item in player.inventory.containerBelt.itemList where item != null select ProcessItem(item, "belt")).ToList();
                kititems.AddRange(from item in player.inventory.containerWear.itemList where item != null select ProcessItem(item, "wear"));
                kititems.AddRange(from item in player.inventory.containerMain.itemList where item != null select ProcessItem(item, "main"));
                player.inventory.Strip();
                return kititems;
            }

            //private IEnumerable<ItemsToRestore> GetItems(ItemContainer container, string containerName)
            //{

            //    return container.itemList.Select(item => new ItemsToRestore
            //    {
            //        itemid = item.info.itemid,
            //        container = containerName,
            //        amount = item.amount,
            //        ammo = weapon.primaryMagazine.contents,
            //        position = item.position,
            //        skin = item.skin,
            //        condition = item.condition,
            //        bptarget = item.blueprintTarget,
            //        contents = item.contents?.itemList.Select(item1 => new ItemsToRestore
            //        {
            //            itemid = item1.info.itemid,
            //            amount = item1.amount,
            //            condition = item1.condition
            //        }).ToArray()
            //});
            //}

            SavedItem ProcessItem(Item item, string container)
            {
                SavedItem iItem = new SavedItem
                {
                    shortname = item.info?.shortname,
                    amount = item.amount,
                    mods = new List<SavedItem>(),
                    container = container,
                    skinid = item.skin,
                    blueprint = item.blueprintTarget
                };
                if (item.info == null) return iItem;
                iItem.itemid = item.info.itemid;
                iItem.weapon = false;
                if (item.hasCondition)
                    iItem.condition = item.condition;
                FlameThrower flameThrower = item.GetHeldEntity()?.GetComponent<FlameThrower>();
                if (flameThrower != null)
                    iItem.flamefuel = flameThrower.ammo;
                if (item.info.category.ToString() != "Weapon") return iItem;
                BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
                if (weapon == null) return iItem;
                if (weapon.primaryMagazine == null) return iItem;
                iItem.ammoamount = weapon.primaryMagazine.contents;
                iItem.ammotype = weapon.primaryMagazine.ammoType.shortname;
                iItem.weapon = true;
                if (item.contents != null)
                    foreach (var mod in item.contents.itemList)
                        if (mod.info.itemid != 0)
                            iItem.mods.Add(ProcessItem(mod, "noun"));
                return iItem;
            }



            bool RestoreInventory(BasePlayer player)
            {
                if (!cachedInventories.ContainsKey(player.userID))
                    return false;
                player.inventory.Strip();
                StringBuilder sb = new StringBuilder(500);

                sb.Append($"RESTORE {player.displayName}\n");
                foreach (SavedItem kitem in cachedInventories[player.userID].Items)
                {
                    sb.Append($"{kitem.shortname}\n");
                    GiveItem(player, kitem.weapon ? BuildWeapon(kitem) : BuildItem(kitem), kitem.container);
                }
                sb.Clear();
                return true;
            }

            void GiveItem(BasePlayer player, Item item, string container)
            {
                if (item == null) return;
                ItemContainer cont;
                switch (container)
                {
                    case "wear":
                        cont = player.inventory.containerWear;
                        break;
                    case "belt":
                        cont = player.inventory.containerBelt;
                        break;
                    default:
                        cont = player.inventory.containerMain;
                        break;
                }
                item.MoveToContainer(cont);
            }

            Item BuildItem(SavedItem sItem)
            {
                if (sItem.amount < 1) sItem.amount = 1;
                Item item = ItemManager.CreateByItemID(sItem.itemid, sItem.amount, sItem.skinid);
                item.blueprintTarget = sItem.blueprint;
                if (item.hasCondition) item.condition = sItem.condition;
                FlameThrower flameThrower = item.GetHeldEntity()?.GetComponent<FlameThrower>();
                if (flameThrower)
                    flameThrower.ammo = sItem.flamefuel;
                return item;
            }

            Item BuildWeapon(SavedItem sItem)
            {
                Item item = ItemManager.CreateByItemID(sItem.itemid, 1, sItem.skinid);
                if (item.hasCondition)
                    item.condition = sItem.condition;
                var weapon = item.GetHeldEntity() as BaseProjectile;
                if (weapon != null)
                {
                    var def = ItemManager.FindItemDefinition(sItem.ammotype);
                    weapon.primaryMagazine.ammoType = def;
                    weapon.primaryMagazine.contents = sItem.ammoamount;
                }

                if (sItem.mods != null)
                    foreach (var mod in sItem.mods)
                        item.contents.AddItem(BuildItem(mod).info, 1);
                return item;
            }


        }
        #region Class ItemsToRestore
        class SavedItem
        {
            public string shortname;
            public int itemid;
            public string container;
            public float condition;
            public int amount;
            public int ammoamount;
            public string ammotype;
            public int flamefuel;
            public ulong skinid;
            public bool weapon;
            public int blueprint;
            public List<SavedItem> mods;
        }
        #endregion
        #endregion

        #region BasePlayersFunctions
        bool HavePerm(string permis, ulong userID)
        {
            if (permission.UserHasPermission(userID.ToString(), permis))
                return true;
            return false;
        }

        public static BasePlayer FindPlayersSingle(string nameOrIdOrIp, BasePlayer player)
        {
            var targets = FindPlayers(nameOrIdOrIp);
            if (targets.Count <= 0)
            {
                player.ChatMessage(String.Format(playerNotFound, nameOrIdOrIp));
                return null;
            }
            if (targets.Count > 1)
            {
                player.ChatMessage(String.Format(foundMultiplePlayers, string.Join(", ", targets.Select(p => p.displayName).ToArray())));
                return null;
            }
            return targets.First();
        }

        public static HashSet<BasePlayer> FindPlayers(string nameOrIdOrIp)
        {
            var players = new HashSet<BasePlayer>();
            if (string.IsNullOrEmpty(nameOrIdOrIp)) return players;
            foreach (var activePlayer in BasePlayer.activePlayerList)
            {
                if (activePlayer.UserIDString.Equals(nameOrIdOrIp))
                    players.Add(activePlayer);
                else if (!string.IsNullOrEmpty(activePlayer.displayName) && activePlayer.displayName.Contains(nameOrIdOrIp, CompareOptions.IgnoreCase))
                    players.Add(activePlayer);
                else if (activePlayer.net?.connection != null && activePlayer.net.connection.ipaddress.Equals(nameOrIdOrIp))
                    players.Add(activePlayer);
            }
            return players;
        }

        static void TPPlayer(BasePlayer player, Vector3 destination)
        {
            BaseMountable mount = player.GetMounted();
            if (mount != null)
            {
                mount.DismountPlayer(player);
            }
            if (player.net?.connection != null)
                player.ClientRPCPlayer(null, player, "StartLoading");
            StartSleeping(player);
            player.MovePosition(destination);
            if (player.net?.connection != null)
                player.ClientRPCPlayer(null, player, "ForcePositionTo", destination);
            //player.TransformChanged();
            if (player.net?.connection != null)
                player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
            player.UpdateNetworkGroup();
            player.SendNetworkUpdateImmediate(false);
            if (player.net?.connection == null) return;
            try { player.ClearEntityQueue(null); } catch { }
            player.SendFullSnapshot();
        }

        static void StartSleeping(BasePlayer player)
        {
            if (player.IsSleeping())
                return;
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, true);
            if (!BasePlayer.sleepingPlayerList.Contains(player))
                BasePlayer.sleepingPlayerList.Add(player);
            player.CancelInvoke("InventoryUpdate");
        }

        static DuelPlayer FindOpponent(BasePlayer player)
        {
            foreach (var duel in createdDuels)
            {
                if (duel.player1.player == player)
                    return duel.player2;
                if (duel.player2.player == player)
                    return duel.player1;
            }
            return null;
        }
        #endregion

        #region GUI
        [ConsoleCommand("duel")]
        void ccmdremove(ConsoleSystem.Arg arg)
        {
            if (arg.Connection?.player != null)
            {

                var player = arg.Player();


                string[] args = new string[0];
                if (arg.HasArgs()) args = arg.Args;
                if (args.Length == 0)
                {
                    return;
                }
                DuelPlayer dueller = player.GetComponent<DuelPlayer>();
                if (dueller == null) return;
                if (dueller.canDoSomeThings) return;
                if (args[0] == "surrender")
                {
                    db.playerStat[player.userID].losses++;
                    EndDuel(player, 5, "0", "0");
                    return;
                }
                if (dueller.weapon != "") return;
                dueller.weapon = args[0];
                GiveWeapon(player);
            }
        }

        static void WeaponsGUI(BasePlayer player)
        {
            DuelPlayer dueller = player.GetComponent<DuelPlayer>();
            if (dueller == null) return;
            if (!dueller.guiEnabled) return;

            CuiHelper.DestroyUi(player, "weaponsgui");
            if (!dueller.guiMouseEnabled)
            {
                var mouse = new CuiElementContainer();
                var mousepanel = mouse.Add(new CuiPanel
                {
                    Image = { Color = "0.8 0.2 0.2 0" },
                    RectTransform = { AnchorMin = "0.1 0.3", AnchorMax = "0.9 0.7" },
                    CursorEnabled = true
                }, "Hud", "mouse");
                CuiHelper.AddUi(player, mouse);
                dueller.guiMouseEnabled = true;
            }
            var elements = new CuiElementContainer();
            var panel = elements.Add(new CuiPanel
            {
                Image = { Color = "0 0.02 0 0.95" },
                RectTransform = { AnchorMin = "0.1 0.3", AnchorMax = "0.9 0.7" }
            }, "Hud", "weaponsgui");
            if (!dueller.haveweapon)
            {
                elements.Add(new CuiLabel
                {
                    Text = { Text = guiChooseWeapon, FontSize = 22, Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = "0 0.9", AnchorMax = "1 1" }
                }, panel);
                if (dueller.team == "")
                {
                    elements.Add(new CuiButton
                    {
                        Button = { Color = "1 1 1 0", Command = "duel surrender", FadeIn = 0 },
                        RectTransform = { AnchorMin = "0.8 0.0", AnchorMax = "0.99 0.1" },
                        Text = { Text = guiSurrenderButton, Color = "1 1 1 1", FontSize = 26, Align = TextAnchor.LowerRight }
                    }, panel);
                }
                int weaponsCount = weapons.Count;
                for (int i = 0; i < weaponsCount; i++)
                {
                    if (i / 5 == (int)0)
                    {
                        elements.Add(new CuiButton
                        {
                            Button = { Color = "1 1 1 0.2", Command = $"duel {weapons[i]}", FadeIn = 0 },
                            RectTransform = { AnchorMin = $"{i * 0.2f} 0.8", AnchorMax = $"{i * 0.2f + 0.2f} 0.9" },
                            Text = { Text = weapons[i], FontSize = 22, Align = TextAnchor.MiddleCenter }
                        }, panel);
                    }
                    if (i / 5 == (int)1)
                    {
                        elements.Add(new CuiButton
                        {
                            Button = { Color = "1 1 1 0.2", Command = $"duel {weapons[i]}", FadeIn = 0 },
                            RectTransform = { AnchorMin = $"{(i * 0.2f) - 1f} 0.65", AnchorMax = $"{(i * 0.2f + 0.2f) - 1f} 0.75" },
                            Text = { Text = weapons[i], FontSize = 22, Align = TextAnchor.MiddleCenter }
                        }, panel);
                    }
                    if (i / 5 == (int)2)
                    {
                        elements.Add(new CuiButton
                        {
                            Button = { Color = "1 1 1 0.2", Command = $"duel {weapons[i]}", FadeIn = 0 },
                            RectTransform = { AnchorMin = $"{(i * 0.2f - 2f)} 0.50", AnchorMax = $"{(i * 0.2f + 0.2f) - 2f} 0.60" },
                            Text = { Text = weapons[i], FontSize = 22, Align = TextAnchor.MiddleCenter }
                        }, panel);
                    }
                    if (i / 5 == (int)3)
                    {
                        elements.Add(new CuiButton
                        {
                            Button = { Color = "1 1 1 0.2", Command = $"duel {weapons[i]}", FadeIn = 0 },
                            RectTransform = { AnchorMin = $"{(i * 0.2f) - 3f} 0.35", AnchorMax = $"{(i * 0.2f + 0.2f) - 3f} 0.45" },
                            Text = { Text = weapons[i], FontSize = 22, Align = TextAnchor.MiddleCenter }
                        }, panel);
                    }
                    if (i / 5 == (int)4)
                    {
                        elements.Add(new CuiButton
                        {
                            Button = { Color = "1 1 1 0.2", Command = $"duel {weapons[i]}", FadeIn = 0 },
                            RectTransform = { AnchorMin = $"{(i * 0.2f) - 4f} 0.20", AnchorMax = $"{(i * 0.2f + 0.2f) - 4f} 0.30" },
                            Text = { Text = weapons[i], FontSize = 22, Align = TextAnchor.MiddleCenter }
                        }, panel);
                    }
                    if (i / 5 == (int)5)
                    {
                        elements.Add(new CuiButton
                        {
                            Button = { Color = "1 1 1 0.2", Command = $"duel {weapons[i]}", FadeIn = 0 },
                            RectTransform = { AnchorMin = $"{(i * 0.2f) - 5f} 0.05", AnchorMax = $"{(i * 0.2f + 0.2f) - 5f} 0.15" },
                            Text = { Text = weapons[i], FontSize = 22, Align = TextAnchor.MiddleCenter }
                        }, panel);
                    }
                }
            }
            if (dueller.team != "")
            {
                CuiHelper.DestroyUi(player, "weaponsguiteamweapons");
                var elementsteam = new CuiElementContainer();
                var panelteam = elementsteam.Add(new CuiPanel
                {
                    Image = { Color = "0 0.02 0 0.95" },
                    RectTransform = { AnchorMin = "0.0 0.71", AnchorMax = "1 0.9" }
                }, "Hud", "weaponsguiteamweapons");
                var duel = createdTeamDuels[0];
                elementsteam.Add(new CuiLabel
                {
                    Text = { Text = teamGuiWeapons, FontSize = 20, Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = "0.2 0.75", AnchorMax = "0.8 1" }
                }, panelteam);
                int ip = 0;
                int duelAllPlayersCount = duel.allPlayers.Count;
                for (int pli = 0; pli < duelAllPlayersCount; pli++)
                {
                    var pl = duel.allPlayers[pli];
                    string wp = teamGuiNoWeapon;
                    string clr = "";
                    if (pl.team == "blue") clr = teamGuiBluePlayerColor;
                    if (pl.team == "red") clr = teamGuiRedPlayerColor;
                    if (pl.weapon != "") wp = pl.weapon;
                    elementsteam.Add(new CuiLabel
                    {
                        Text = { Text = $"<color={clr}>{pl.player.displayName}</color> : <color={teamGuiWeaponColor}>{wp}</color>", FontSize = 12, Align = TextAnchor.MiddleCenter },
                        RectTransform = { AnchorMin = $"{ip * (1f / duel.allPlayers.Count)} 0.3", AnchorMax = $"{(ip * (1f / duel.allPlayers.Count)) + (1f / duel.allPlayers.Count)} 0.6" }
                    }, panelteam);
                    ip++;
                }
                if (dueller.guiEnabled)
                    CuiHelper.AddUi(player, elementsteam);
            }
            if (dueller.haveweapon && dueller.team == "")
            {
                elements.Add(new CuiLabel
                {
                    Text = { Text = String.Format(guiYourChoose, dueller.weapon), FontSize = 20, Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = "0 0.4", AnchorMax = "0.5 0.6" }
                }, panel);

                #region OpponentsWeapon
                ActiveDuel playersDuel = null;
                string opponentweapon = "";
                foreach (var duel in createdDuels)
                {
                    if (duel.player1 == dueller)
                    {
                        playersDuel = duel;
                        opponentweapon = duel.player2.weapon;
                        break;
                    }
                    if (duel.player2 == dueller)
                    {
                        playersDuel = duel;
                        opponentweapon = duel.player1.weapon;
                        break;
                    }
                }

                if (opponentweapon == "")
                {
                    elements.Add(new CuiLabel
                    {
                        Text = { Text = guiWaitForOpponentChoose, FontSize = 20, Align = TextAnchor.MiddleCenter },
                        RectTransform = { AnchorMin = "0.5 0.4", AnchorMax = "1 0.6" }
                    }, panel);
                }
                else
                {
                    elements.Add(new CuiLabel
                    {
                        Text = { Text = String.Format(guiOpponentsWeapon, opponentweapon), FontSize = 20, Align = TextAnchor.MiddleCenter },
                        RectTransform = { AnchorMin = "0.5 0.4", AnchorMax = "1 0.6" }
                    }, panel);

                    elements.Add(new CuiLabel
                    {
                        Text = { Text = guiStartAboutToBegin, FontSize = 22, Align = TextAnchor.MiddleCenter },
                        RectTransform = { AnchorMin = "0.3 0.0", AnchorMax = "0.7 0.2" }
                    }, panel);
                    if (dueller.guiEnabled)
                        CuiHelper.AddUi(player, elements);
                    return;
                }
                #endregion
            }
            if (dueller.team == "")
            {
                var opp = FindOpponent(player);
                var thisDuel = FindDuelByPlayer(player);
                int seconds = (int)chooseWeaponMaxSec - (int)(UnityEngine.Time.realtimeSinceStartup - thisDuel.guiTimeToRandom);
                if (seconds < 0) seconds = 25;
                if (opp != null && opp.isReady)
                {
                    elements.Add(new CuiLabel
                    {
                        Text = { Text = String.Format(guiAutoCloseSec, seconds), FontSize = 22, Align = TextAnchor.MiddleCenter },
                        RectTransform = { AnchorMin = "0.3 0.0", AnchorMax = "0.7 0.2" }
                    }, panel);
                }
                else
                {
                    elements.Add(new CuiLabel
                    {
                        Text = { Text = guiPlayerSleep, FontSize = 22, Align = TextAnchor.MiddleCenter },
                        RectTransform = { AnchorMin = "0.3 0.0", AnchorMax = "0.7 0.2" }
                    }, panel);
                }
            }
            if (dueller.team != "" && dueller.haveweapon)
            {
                elements.Add(new CuiLabel
                {
                    Text = { Text = teamGuiWaiting, FontSize = 22, Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = "0.3 0.0", AnchorMax = "0.7 0.2" }
                }, panel);
            }
            if (dueller.guiEnabled)
                CuiHelper.AddUi(player, elements);
        }
        #endregion

        #region Oxide
        void OnPlayerRespawned(BasePlayer player)
        {
            if (player.transform.position.y > 900f && !IsDuelPlayer(player))
            {
                new PluginTimers(this).Once(1, () =>
                {
                    player.Die();
                });
            }

            DuelPlayer dueller = player?.GetComponent<DuelPlayer>();
            if (dueller == null) return;
            if (!dueller.haveweapon) return;
            new PluginTimers(this).Once(1, () =>
            {
                EndDuel(player, 0, "0", "0");
            });
        }

        object OnEntityTakeDamage(BaseCombatEntity victim, HitInfo hitInfo)
        {
            //Disabling decay of the arena
            if (hitInfo.damageTypes.Has(Rust.DamageType.Decay))
            {
                if (IsArenaZone(victim.transform.position))
                {
                    hitInfo.damageTypes.Scale(Rust.DamageType.Decay, 0);
                }
            }
            var attacker = hitInfo.Initiator?.ToPlayer();
            var victimPlayer = (victim as BasePlayer);
            if (createdTeamDuels.Count > 0)
            {
                if (victim != null)
                {
                    if (victimPlayer != null)
                    {
                        DuelPlayer dueller = victimPlayer?.GetComponent<DuelPlayer>();
                        if (dueller != null)
                        {
                            if (!dueller.canMove) return false; //возвращать дамаг
                        }
                    }
                }
                if (attacker == null) return null;
                var dvictim = createdTeamDuels[0].allPlayers.Find(x => x.player == victimPlayer);
                var dattacker = createdTeamDuels[0].allPlayers.Find(x => x.player == hitInfo.Initiator?.ToPlayer());
                if (dvictim != null)
                {
                    if (dattacker != null)
                    {
                        if (dvictim.team == dattacker.team)
                        {
                            attacker.ChatMessage(String.Format(teamDamageTeammate, victimPlayer.displayName));
                            return false; //отмена дамага по однотимным
                        }
                    }
                }
                else
                    return null;
            }

            if (attacker != null)
            {
                if (victim != null)
                {
                    if (victimPlayer != null)
                    {
                        if (IsDuelPlayer(attacker) && !IsDuelPlayer(victimPlayer)) return false; //отмена на обычных игроков от дуэлянта
                    }
                    DuelPlayer dueller = attacker?.GetComponent<DuelPlayer>();
                    if (dueller == null) return null;
                    if (!dueller.haveweapon) return null;
                    if (IsDuelPlayer(attacker) && victimPlayer == null) return false; //отмена на всё, кроме baseplayer
                }
            }
            if (victim != null)
            {
                if (victimPlayer != null)
                {
                    if (FindOpponent(victimPlayer) != null)
                    {
                        if (IsDuelPlayer(victimPlayer) && !FindOpponent(victimPlayer).canMove) return false; //отмена на дамаг от телепорта (если он будет)
                    }
                }
            }
            return null;
        }

        void OnEntityDeath(BaseEntity entity, HitInfo hitinfo)
        {
            BasePlayer player = (entity as BasePlayer);
            if (player == null) return;
            DuelPlayer dueller = player?.GetComponent<DuelPlayer>();
            if (dueller == null) return;
            if (dueller.team != "" && dueller.haveweapon)
            {
                var duel = createdTeamDuels[0];
                if (dueller.team == "blue")
                {
                    duel.teamblue.Remove(dueller);
                }
                if (dueller.team == "red")
                {
                    duel.teamred.Remove(dueller);
                }
                int allPlayersN = duel.allPlayers.Count;
                for (int i = 0; i < allPlayersN; i++)
                {
                    duel.allPlayers[i].player.ChatMessage(String.Format(teamDeath, player.displayName, dueller.team, duel.teamblue.Count, duel.teamred.Count));
                }
                duel.allPlayers.Remove(dueller);

                dueller.guiEnabled = false;
                dueller.canMove = true;
                if (dueller.induel)
                    dueller.ReturnWithCooldown();
                dueller.induel = false;
                return;
            }
            var opponent = FindOpponent(player);
            if (opponent != null)
            {
                if (opponent.isDeath || dueller.isDeath || !dueller.haveweapon || !opponent.haveweapon) return;
                opponent.isDeath = true;
                player.ChatMessage(statLoss);
                var duel = FindDuelByPlayer(player);
                PrintToChat(String.Format(notificationAboutWin, duel.player1.player.displayName, duel.player2.player.displayName, opponent.player.displayName));
                opponent.player.ChatMessage(statWin);
                db.playerStat[opponent.player.userID].wins++;
                db.playerStat[player.userID].losses++;
                var Ts = (from x in Tops where x.SteamId == opponent.player.UserIDString || x.SteamId == player.UserIDString select x);
                foreach (var top in Ts)
                {
                    top.Win = opponent.player.UserIDString;
                    SaveData();
                }
                EndDuel(player, 7, opponent.player.UserIDString, player.UserIDString);
            }
        }

        void OnEntitySpawned(BaseEntity entity) => RemoveGarbage(entity); //remove corpses and etc

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                OnlinePlayer onlinePlayer;
                if (onlinePlayers.TryGetValue(player, out onlinePlayer))
                {
                    if (onlinePlayer.Trade != null)
                    {
                        TradeCloseBoxes(onlinePlayer.Trade);
                    }
                    else if (onlinePlayer.View != null)
                    {
                        CloseBoxView(player, onlinePlayer.View);
                    }
                }
            }


            foreach (var player in BasePlayer.activePlayerList)
            {
                EndDuel(player, 6, "0", "0");
                CuiHelper.DestroyUi(player, "weaponsguiteamweapons");
                CuiHelper.DestroyUi(player, "weaponsgui");
                CuiHelper.DestroyUi(player, "mouse");
            }
            if (createdTeamDuels.Count > 0)
                createdTeamDuels[0].Destroy();
            Puts("Арены удалены");
            foreach (var entity in ArenaEntities)
            {
                if (!entity.IsDestroyed)
                    entity.Kill();
            };
            SaveData();
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            OnlinePlayer onlinePlayer;
            if (onlinePlayers.TryGetValue(player, out onlinePlayer))
            {
                if (onlinePlayer.Trade != null)
                {
                    TradeCloseBoxes(onlinePlayer.Trade);
                }
                else if (onlinePlayer.View != null)
                {
                    CloseBoxView(player, onlinePlayer.View);
                }
            }

            DuelPlayer dueller = player?.GetComponent<DuelPlayer>();
            if (dueller == null) return;
            EndDuel(player, 4, "0", "0");
        }

        private object CanBuild(Planner plan, Construction prefab)
        {
            DuelPlayer dueller = plan.GetOwnerPlayer()?.GetComponent<DuelPlayer>();
            if (dueller == null) return null;
            if (dueller.canDoSomeThings) return null;
            SendReply(plan.GetOwnerPlayer(), cantBuild);
            return false;
        }

        private object canRemove(BasePlayer player)
        {
            DuelPlayer dueller = player?.GetComponent<DuelPlayer>();
            if (dueller == null) return null;
            if (dueller.canDoSomeThings) return null;
            SendReply(player, cantRemove);
            return true;
        }

        private object CanTrade(BasePlayer player)
        {
            DuelPlayer dueller = player?.GetComponent<DuelPlayer>();
            if (dueller == null) return null;
            if (dueller.canDoSomeThings) return null;
            return cantTrade;

        }

        private object BackpackItem(BasePlayer player)
        {
            DuelPlayer dueller = player?.GetComponent<DuelPlayer>();
            if (dueller == null) return null;
            if (dueller.canDoSomeThings) return null;
            return cantTrade;

        }
        private object ConsoleAlias(BasePlayer player)
        {
            DuelPlayer dueller = player?.GetComponent<DuelPlayer>();
            if (dueller == null) return null;
            if (dueller.canDoSomeThings) return null;
            return cantTrade;

        }


        private object CanTeleport(BasePlayer player)
        {
            DuelPlayer dueller = player?.GetComponent<DuelPlayer>();
            if (dueller == null) return null;
            if (dueller.canDoSomeThings) return null;
            return cantTp;
        }

        private object inDuel(BasePlayer player) => player?.GetComponent<DuelPlayer>() != null;

        private object canRedeemKit(BasePlayer player)
        {
            DuelPlayer dueller = player?.GetComponent<DuelPlayer>();
            if (dueller == null) return null;
            if (dueller.canDoSomeThings) return null;
            return cantUseKit;
        }

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (arg.cmd.Name == "kill")
            {
                DuelPlayer dueller = arg.Player()?.GetComponent<DuelPlayer>();
                if (dueller == null) return null;
                if (dueller.canDoSomeThings) return null;
                SendReply(arg.Player(), cantUseKill);
                return false;
            }
            if (arg.cmd?.FullName == "backpack.open")
            {
                DuelPlayer dueller = arg.Player()?.GetComponent<DuelPlayer>();
                if (dueller == null) return null;
                if (dueller.canDoSomeThings) return null;
                SendReply(arg.Player(), cantUseBackPack);
                return false;
            }
            return null;
        }

        public List<string> Commands = new List<string>()
        {
            "bp",
            "backpack",
            "skin",
            "skinbox",
            "rec",
            "tpa",
            "tpr",
            "sethome",
            "home",
            "kit",
            "remove"
        };

        object OnPlayerCommand(ConsoleSystem.Arg arg, BasePlayer player)
        {
            if (arg.Args == null) return null;
            foreach (var command in Commands)
            {
                if (string.Join(" ", arg.Args).Contains(command))
                {
                    DuelPlayer dueller = arg.Player()?.GetComponent<DuelPlayer>();
                    if (dueller == null) return null;
                    if (dueller.canDoSomeThings) return null;
                    SendReply(arg.Player(), cantUseCommand.Replace("{0}", command));
                    return false;
                }
            }
            return null;
        }

        void OnServerInitialized()
        {
            if (!permission.PermissionExists(duelCreatePermission)) permission.RegisterPermission(duelCreatePermission, this);
            if (!permission.PermissionExists(duelJoinPermission)) permission.RegisterPermission(duelJoinPermission, this);
            PrintWarning("Инициализация плагина выполнена. Ожидайте 10 секунд для инициализации файлов арен.");
            timer.Once(10f, () =>
            {
                CreateDuelArena();
                isIni = true;
            });
        }
        #endregion

        #region GiveItems

        public static void GiveRandomWeapon(BasePlayer player)
        {
            var rnd = new System.Random();
            string weapon = weapons[UnityEngine.Random.Range(0, weapons.Count)];
            DuelPlayer dueller = player.GetComponent<DuelPlayer>();
            if (dueller != null)
            {
                if (!dueller.haveweapon)
                {
                    dueller.weapon = weapon;
                    GiveWeapon(player);
                }
            }
        }

        public static void GiveWear(BasePlayer player)
        {
            DuelPlayer dueller = player.GetComponent<DuelPlayer>();
            if (dueller.team == "blue")
            {
                foreach (var item in WearsBlue)
                {
                    player.inventory.GiveItem(ItemManager.CreateByName(item.Key, 1, item.Value), player.inventory.containerWear);
                }
                return;
            }
            if (dueller.team == "red")
            {
                foreach (var item in WearsRed)
                {
                    player.inventory.GiveItem(ItemManager.CreateByName(item.Key, 1, item.Value), player.inventory.containerWear);
                }
                return;
            }
            foreach (var item in Wears)
            {
                player.inventory.GiveItem(ItemManager.CreateByName(item.Key, 1, item.Value), player.inventory.containerWear);
            }
        }
        static List<string> weapons = new List<string>
        {
            "M249",
            "LR-300",
            "AK-47",
            "Болт",
            "Берданка",
            "MP5",
            "Томпсон",
            "Смг",
            "Дробовик",
            "Двухстволка",
            "Пайп",
            "Питон",
            "П250",
            "M92",
            "Револьвер",
            "Лук",
            "Копьё",
            "Нож",
            "Арбалет",
            "ЕОКА",
            "Камень",
            "Меч"
        };

        public static void GiveAndShowItem(BasePlayer player, string item, int amount, ulong skindid = 0)
        {
            player.inventory.GiveItem(ItemManager.CreateByName(item, amount, skindid), player.inventory.containerBelt);
            player.Command("note.inv", new object[] { item, amount });
        }

        public static void GiveWeapon(BasePlayer player)
        {
            DuelPlayer dueller = player.GetComponent<DuelPlayer>();
            if (dueller == null) return;
            GiveWear(player);
            switch (dueller.weapon)
            {
                case "M249":
                    GiveAndShowItem(player, "lmg.m249", 1);
                    GiveAndShowItem(player, "bandage", 5);
                    GiveAndShowItem(player, "syringe.medical", 3);
                    GiveAndShowItem(player, "weapon.mod.flashlight", 1); //фонарик 
                    GiveAndShowItem(player, "weapon.mod.holosight", 1); //коллиматор
                    GiveAndShowItem(player, "ammo.rifle", 200); // 5.56
                    GiveAndShowItem(player, "ammo.rifle.hv", 200); // 5.56 мм ВС
                    break;
                case "AK-47":
                    GiveAndShowItem(player, "rifle.ak", 1, 10138);
                    GiveAndShowItem(player, "bandage", 5);
                    GiveAndShowItem(player, "syringe.medical", 3);
                    GiveAndShowItem(player, "weapon.mod.flashlight", 1); //фонарик 
                    GiveAndShowItem(player, "weapon.mod.holosight", 1); //коллиматор
                    GiveAndShowItem(player, "ammo.rifle", 200); // 5.56
                    GiveAndShowItem(player, "ammo.rifle.hv", 200); // 5.56 мм ВС
                    break;
                case "Болт":
                    GiveAndShowItem(player, "rifle.bolt", 1, 10117);
                    GiveAndShowItem(player, "bandage", 5);
                    GiveAndShowItem(player, "syringe.medical", 3);
                    GiveAndShowItem(player, "weapon.mod.flashlight", 1); //фонарик 
                    GiveAndShowItem(player, "weapon.mod.holosight", 1); //коллиматор
                    GiveAndShowItem(player, "ammo.rifle", 100); // 5.56
                    GiveAndShowItem(player, "ammo.rifle.hv", 100); // 5.56 мм ВС
                    break;
                case "LR-300":
                    GiveAndShowItem(player, "rifle.lr300", 1);
                    GiveAndShowItem(player, "bandage", 5);
                    GiveAndShowItem(player, "syringe.medical", 3);
                    GiveAndShowItem(player, "weapon.mod.flashlight", 1); //фонарик 
                    GiveAndShowItem(player, "weapon.mod.holosight", 1); //коллиматор
                    GiveAndShowItem(player, "ammo.rifle", 200); // 5.56
                    GiveAndShowItem(player, "ammo.rifle.hv", 200); // 5.56 мм ВС
                    break;
                case "Берданка":
                    GiveAndShowItem(player, "rifle.semiauto", 1);
                    GiveAndShowItem(player, "bandage", 5);
                    GiveAndShowItem(player, "syringe.medical", 3);
                    GiveAndShowItem(player, "weapon.mod.flashlight", 1); //фонарик 
                    GiveAndShowItem(player, "weapon.mod.holosight", 1); //коллиматор
                    GiveAndShowItem(player, "ammo.rifle", 100); // 5.56
                    GiveAndShowItem(player, "ammo.rifle.hv", 100); // 5.56 мм ВС
                    break;
                case "Питон":
                    GiveAndShowItem(player, "pistol.python", 1);
                    GiveAndShowItem(player, "bandage", 5);
                    GiveAndShowItem(player, "syringe.medical", 3);
                    GiveAndShowItem(player, "weapon.mod.holosight", 1); //коллиматор
                    GiveAndShowItem(player, "ammo.pistol", 100); // pistol bullet
                    GiveAndShowItem(player, "ammo.pistol.hv", 100); // 9 мм ВС
                    break;
                case "П250":
                    GiveAndShowItem(player, "pistol.semiauto", 1, 805925675);
                    GiveAndShowItem(player, "bandage", 5);
                    GiveAndShowItem(player, "syringe.medical", 3);
                    GiveAndShowItem(player, "weapon.mod.flashlight", 1); //фонарик 
                    GiveAndShowItem(player, "weapon.mod.holosight", 1); //коллиматор
                    GiveAndShowItem(player, "ammo.pistol", 100); // pistol bullet
                    GiveAndShowItem(player, "ammo.pistol.hv", 100); // 9 мм ВС
                    break;
                case "M92":
                    GiveAndShowItem(player, "pistol.m92", 1);
                    GiveAndShowItem(player, "bandage", 5);
                    GiveAndShowItem(player, "syringe.medical", 3);
                    GiveAndShowItem(player, "weapon.mod.flashlight", 1); //фонарик 
                    GiveAndShowItem(player, "weapon.mod.holosight", 1); //коллиматор
                    GiveAndShowItem(player, "ammo.pistol", 100); // pistol bullet
                    GiveAndShowItem(player, "ammo.pistol.hv", 100); // 9 мм ВС
                    break;
                case "Револьвер":
                    GiveAndShowItem(player, "pistol.revolver", 1);
                    GiveAndShowItem(player, "bandage", 5);
                    GiveAndShowItem(player, "syringe.medical", 3);
                    GiveAndShowItem(player, "ammo.pistol", 100); // 9 мм
                    GiveAndShowItem(player, "ammo.pistol.hv", 100); // 9 мм ВС
                    break;
                case "Лук":
                    GiveAndShowItem(player, "bow.hunting", 1);
                    GiveAndShowItem(player, "bandage", 5);
                    GiveAndShowItem(player, "syringe.medical", 3);
                    GiveAndShowItem(player, "arrow.wooden", 600); // arrows
                    break;
                case "Копьё":
                    GiveAndShowItem(player, "spear.wooden", 1);
                    GiveAndShowItem(player, "spear.wooden", 1);
                    GiveAndShowItem(player, "spear.wooden", 1);
                    GiveAndShowItem(player, "spear.wooden", 1);
                    GiveAndShowItem(player, "bandage", 5);
                    GiveAndShowItem(player, "syringe.medical", 3);
                    break;
                case "Нож":
                    GiveAndShowItem(player, "knife.bone", 1);
                    GiveAndShowItem(player, "bandage", 5);
                    GiveAndShowItem(player, "syringe.medical", 3);
                    break;
                case "Томпсон":
                    GiveAndShowItem(player, "smg.thompson", 1, 561462394);
                    GiveAndShowItem(player, "bandage", 5);
                    GiveAndShowItem(player, "syringe.medical", 3);
                    GiveAndShowItem(player, "weapon.mod.holosight", 1); //коллиматор
                    GiveAndShowItem(player, "ammo.pistol", 100); // pistol bullet
                    GiveAndShowItem(player, "ammo.pistol.hv", 100); // 9 мм ВС
                    break;
                case "Смг":
                    GiveAndShowItem(player, "smg.2", 1);
                    GiveAndShowItem(player, "bandage", 5);
                    GiveAndShowItem(player, "syringe.medical", 3);
                    GiveAndShowItem(player, "weapon.mod.flashlight", 1); //фонарик 
                    GiveAndShowItem(player, "weapon.mod.holosight", 1); //коллиматор
                    GiveAndShowItem(player, "ammo.pistol", 100); // pistol bullet
                    GiveAndShowItem(player, "ammo.pistol.hv", 100); // 9 мм ВС
                    break;
                case "Арбалет":
                    GiveAndShowItem(player, "crossbow", 1);
                    GiveAndShowItem(player, "bandage", 5);
                    GiveAndShowItem(player, "syringe.medical", 3);
                    GiveAndShowItem(player, "arrow.wooden", 600); // arrows
                    GiveAndShowItem(player, "weapon.mod.flashlight", 1); //фонарик 
                    GiveAndShowItem(player, "weapon.mod.holosight", 1); //коллиматор
                    break;
                case "Дробовик":
                    GiveAndShowItem(player, "shotgun.pump", 1, 731119713);
                    GiveAndShowItem(player, "bandage", 5);
                    GiveAndShowItem(player, "syringe.medical", 3);
                    GiveAndShowItem(player, "weapon.mod.flashlight", 1); //фонарик 
                    GiveAndShowItem(player, "weapon.mod.holosight", 1); //коллиматор
                    GiveAndShowItem(player, "ammo.shotgun", 100); // картечь
                    GiveAndShowItem(player, "ammo.shotgun.slug", 100); // пулевой
                    break;
                case "Пайп":
                    GiveAndShowItem(player, "shotgun.waterpipe", 1);
                    GiveAndShowItem(player, "bandage", 5);
                    GiveAndShowItem(player, "syringe.medical", 3);
                    GiveAndShowItem(player, "weapon.mod.flashlight", 1); //фонарик 
                    GiveAndShowItem(player, "weapon.mod.holosight", 1); //коллиматор
                    GiveAndShowItem(player, "ammo.shotgun", 100); // картечь
                    GiveAndShowItem(player, "ammo.shotgun.slug", 100); // пулевой
                    break;
                case "Двухстволка":
                    GiveAndShowItem(player, "shotgun.double", 1);
                    GiveAndShowItem(player, "bandage", 5);
                    GiveAndShowItem(player, "syringe.medical", 3);
                    GiveAndShowItem(player, "weapon.mod.flashlight", 1); //фонарик 
                    GiveAndShowItem(player, "weapon.mod.holosight", 1); //коллиматор
                    GiveAndShowItem(player, "ammo.shotgun", 100); // картечь
                    GiveAndShowItem(player, "ammo.shotgun.slug", 100); // пулевой
                    break;
                case "ЕОКА":
                    GiveAndShowItem(player, "pistol.eoka", 1);
                    GiveAndShowItem(player, "bandage", 5);
                    GiveAndShowItem(player, "syringe.medical", 3);
                    GiveAndShowItem(player, "ammo.handmade.shell", 100); // fuel
                    break;
                case "Камень":
                    GiveAndShowItem(player, "rock", 1, 807372963);
                    break;
                case "MP5":
                    GiveAndShowItem(player, "smg.mp5", 1, 800974015);
                    GiveAndShowItem(player, "bandage", 5);
                    GiveAndShowItem(player, "syringe.medical", 3);
                    GiveAndShowItem(player, "weapon.mod.flashlight", 1); //фонарик 
                    GiveAndShowItem(player, "weapon.mod.holosight", 1); //коллиматор
                    GiveAndShowItem(player, "ammo.pistol", 100); // pistol bullet
                    break;
                case "Меч":
                    GiveAndShowItem(player, "salvaged.sword", 1);
                    GiveAndShowItem(player, "bandage", 5);
                    GiveAndShowItem(player, "syringe.medical", 3);
                    break;
            }
            dueller.haveweapon = true;
            dueller.readyForBattle = true;
        }
        #endregion

        #region Statistic
        class StoredData
        {
            public Dictionary<ulong, Stat> playerStat = new Dictionary<ulong, Stat>();
            public StoredData() { }
        }
        static StoredData db;
        class Stat
        {
            public string name;
            public int wins;
            public int losses;
            public int teamwins;
            public int teamloss;
        }

        public static void newStat(BasePlayer player)
        {
            Stat value = new Stat();
            if (!db.playerStat.TryGetValue(player.userID, out value))
            {
                Stat stat = new Stat();
                stat.name = player.displayName;
                stat.wins = 0;
                stat.losses = 0;
                stat.teamwins = 0;
                stat.teamloss = 0;
                db.playerStat[player.userID] = stat;
                return;
            }
            if (db.playerStat[player.userID].name != player.displayName)
                db.playerStat[player.userID].name = player.displayName;
        }

        void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("DuelStavki", Tops);
            Interface.Oxide.DataFileSystem.WriteObject("Duel", db);
        }

        void OnServerSave()
        {
            SaveData();
        }

        void showStat(BasePlayer player)
        {
            newStat(player);
            SendReply(player, String.Format(yourStat, db.playerStat[player.userID].wins, db.playerStat[player.userID].losses, db.playerStat[player.userID].teamwins, db.playerStat[player.userID].teamloss));
        }

        void showTop(BasePlayer player)
        {
            if (db.playerStat.Count == 0)
            {
                SendReply(player, emptyTop);
                return;
            }
            string msg = topWin;
            Dictionary<string, int> namewin = new Dictionary<string, int>();
            Dictionary<string, int> namelosses = new Dictionary<string, int>();
            foreach (var pl in db.playerStat)
            {
                namewin[pl.Value.name] = pl.Value.wins;
                namelosses[pl.Value.name] = pl.Value.losses;
            }
            var reply = 125;
            if (reply == 0) { }
            int i = 0;
            int j = 0;
            foreach (var pair in namewin.OrderByDescending(pair => pair.Value))
            {
                i++;
                msg += String.Format(playerInTop, i, pair.Key, pair.Value);
                if (i == maxWinsTop) break;
            }
            msg += topLosses;
            foreach (var pair in namelosses.OrderByDescending(pair => pair.Value))
            {
                j++;
                msg += String.Format(playerInTop, j, pair.Key, pair.Value);
                if (j == maxLoseTop) break;
            }
            msg += topTeamWin;
            foreach (var pl in db.playerStat)
            {
                namewin[pl.Value.name] = pl.Value.teamwins;
                namelosses[pl.Value.name] = pl.Value.teamloss;
            }
            i = 0;
            j = 0;
            foreach (var pair in namewin.OrderByDescending(pair => pair.Value))
            {
                i++;
                msg += String.Format(playerInTop, i, pair.Key, pair.Value);
                if (i == maxWinsTop) break;
            }
            msg += topTeamLoss;
            foreach (var pair in namelosses.OrderByDescending(pair => pair.Value))
            {
                j++;
                msg += String.Format(playerInTop, j, pair.Key, pair.Value);
                if (j == maxLoseTop) break;
            }
            SendReply(player, msg);
        }
        #endregion

        #region Arena

        #region classArena
        public class Arena
        {
            public string name;
            public Vector3 player1pos;
            public Vector3 player2pos;
            public Vector3 pos;
            public List<Vector3> teamblueSpawns = new List<Vector3>();
            public List<Vector3> teamredSpawns = new List<Vector3>();
        }
        #endregion

        Arena FreeArena()
        {
            Arena randomarena = new Arena();
            List<Arena> freeArenas = new List<Arena>();
            Arena value = new Arena();
            foreach (var arena in arenaList)
            {
                if (!busyArena.Contains(arena))
                    freeArenas.Add(arena);
            }
            if (freeArenas.Count > 0)
            {
                int random = UnityEngine.Random.Range(0, freeArenas.Count);
                randomarena = freeArenas[random];
                busyArena.Add(randomarena);
                return randomarena;
            }
            return null;
        }

        static List<Arena> busyArena = new List<Arena>();
        static List<Arena> arenaList = new List<Arena>();
        void CreateDuelArena()
        {
            for (int i = 1; i < 8; i++)
            {
                int x = -3000;
                string path = $"Duel/DuelArena{i}";
                var data = Interface.GetMod().DataFileSystem.GetDatafile(path);
                if (data["default"] == null || data["entities"] == null)
                {
                    PrintError($"Нет файла DuelArena{i}");
                    return;
                }
                Arena arena = new Arena();

                arena.name = $"Арена{i}";

                if (i == 1)
                {
                    arena.player1pos = new Vector3(-2994.1f, 991.0f, 523.6f);
                    arena.player2pos = new Vector3(-2973.1f, 991.0f, 494.6f);

                    arena.teamblueSpawns.Add(new Vector3(-2988.8f, 991.0f, 531.6f));
                    arena.teamblueSpawns.Add(new Vector3(-2993.2f, 991.0f, 523.9f));
                    arena.teamblueSpawns.Add(new Vector3(-2994.6f, 991.0f, 522.8f));
                    arena.teamblueSpawns.Add(new Vector3(-3001.8f, 991.0f, 519.2f));
                    arena.teamblueSpawns.Add(new Vector3(-2996.0f, 991.0f, 526.5f));

                    arena.teamredSpawns.Add(new Vector3(-2970.9f, 991.0f, 491.6f));
                    arena.teamredSpawns.Add(new Vector3(-2973.7f, 991.0f, 494.1f));
                    arena.teamredSpawns.Add(new Vector3(-2972.5f, 991.0f, 495.3f));
                    arena.teamredSpawns.Add(new Vector3(-2978.6f, 991.0f, 489.9f));
                    arena.teamredSpawns.Add(new Vector3(-2967.0f, 991.0f, 498.6f));
                }
                if (i == 2)
                {
                    arena.player1pos = new Vector3(-2995.7f, 992.7f, 1005.0f);
                    arena.player2pos = new Vector3(-2980.1f, 992.7f, 1000.6f);
                }
                if (i == 3)
                {
                    arena.player1pos = new Vector3(-3002.7f, 998.7f, 1508.7f);
                    arena.player2pos = new Vector3(-2994.6f, 998.7f, 1493.6f);
                }
                if (i == 4)
                {
                    arena.player1pos = new Vector3(-3000.3f, 992.0f, 2011.3f);
                    arena.player2pos = new Vector3(-2975.3f, 992.0f, 2001.9f);
                }
                if (i == 5)
                {
                    arena.player1pos = new Vector3(-2985.5f, 991.7f, 2514.1f);
                    arena.player2pos = new Vector3(-2989.3f, 991.7f, 2496.8f);
                }
                if (i == 6)
                {
                    x = -2500;

                    arena.player1pos = new Vector3(-2515.1f, 1000.0f, 18.7f);
                    arena.player2pos = new Vector3(-2484.1f, 1000.0f, -22.4f);

                    arena.teamblueSpawns.Add(new Vector3(-2494.1f, 1000.0f, -29.1f));
                    arena.teamblueSpawns.Add(new Vector3(-2489.5f, 1000.0f, -25.2f));
                    arena.teamblueSpawns.Add(new Vector3(-2484.7f, 1000.0f, -21.6f));
                    arena.teamblueSpawns.Add(new Vector3(-2479.8f, 1000.0f, -18.2f));
                    arena.teamblueSpawns.Add(new Vector3(-2475.1f, 1000.0f, -14.4f));

                    arena.teamredSpawns.Add(new Vector3(-2524.1f, 1000.0f, 10.6f));
                    arena.teamredSpawns.Add(new Vector3(-2519.3f, 1000.0f, 14.2f));
                    arena.teamredSpawns.Add(new Vector3(-2514.5f, 1000.0f, 17.7f));
                    arena.teamredSpawns.Add(new Vector3(-2509.7f, 1000.0f, 21.4f));
                    arena.teamredSpawns.Add(new Vector3(-2505.0f, 1000.0f, 25.0f));
                    arenaList.Add(arena);
                    arena.pos = new Vector3(x, 1000, 0);

                    var preloadData1 = PreLoadData(data["entities"] as List<object>, new Vector3(x, 1000, 0), 1, true, true);
                    Paste(preloadData1, new Vector3(x, 1000, 0), true);
                    continue;
                }
                if (i == 7)
                {
                    x = -2500;

                    arena.player1pos = new Vector3(-2500.6f, 1000.0f, 521.1f);
                    arena.player2pos = new Vector3(-2488.4f, 1000.0f, 476.5f);

                    arena.teamblueSpawns.Add(new Vector3(-2505.6f, 1000.0f, 470.6f));
                    arena.teamblueSpawns.Add(new Vector3(-2503.2f, 1000.0f, 468.3f));
                    arena.teamblueSpawns.Add(new Vector3(-2495.4f, 1000.0f, 473.7f));
                    arena.teamblueSpawns.Add(new Vector3(-2483.8f, 1000.0f, 476.7f));
                    arena.teamblueSpawns.Add(new Vector3(-2470.8f, 1000.0f, 480.3f));
                    arena.teamblueSpawns.Add(new Vector3(-2471.4f, 1000.0f, 476.9f));

                    arena.teamredSpawns.Add(new Vector3(-2483.6f, 1000.0f, 526.3f));
                    arena.teamredSpawns.Add(new Vector3(-2485.6f, 1000.0f, 528.7f));
                    arena.teamredSpawns.Add(new Vector3(-2494.3f, 1000.0f, 523.3f));
                    arena.teamredSpawns.Add(new Vector3(-2506.7f, 1000.0f, 519.9f));
                    arena.teamredSpawns.Add(new Vector3(-2518.2f, 1000.0f, 516.6f));
                    arena.teamredSpawns.Add(new Vector3(-2517.6f, 1000.0f, 519.9f));
                    PrintWarning("Все спауны созданы");
                    arenaList.Add(arena);
                    arena.pos = new Vector3(x, 1000, 500);

                    PrintWarning("Все арены созданы");
                    var preloadData2 = PreLoadData(data["entities"] as List<object>, new Vector3(x, 1000, 500), 1, true, true);
                    Paste(preloadData2, new Vector3(x, 1000, 500), true);
                    continue;
                }
                arenaList.Add(arena);
                arena.pos = new Vector3(x, 1000, i * 500);

                var preloadData = PreLoadData(data["entities"] as List<object>, new Vector3(x, 1000, i * 500), 1, true, true);
                Paste(preloadData, new Vector3(x, 1000, i * 500), true);
            }

        }
        List<Dictionary<string, object>> PreLoadData(List<object> entities, Vector3 startPos, float RotationCorrection, bool deployables, bool inventories)
        {
            var eulerRotation = new Vector3(0f, RotationCorrection, 0f);
            var quaternionRotation = Quaternion.EulerRotation(eulerRotation);
            var preloaddata = new List<Dictionary<string, object>>();
            foreach (var entity in entities)
            {
                var data = entity as Dictionary<string, object>;
                if (!deployables && !data.ContainsKey("grade")) continue;
                var pos = (Dictionary<string, object>)data["pos"];
                var rot = (Dictionary<string, object>)data["rot"];
                var fixedRotation = Quaternion.EulerRotation(eulerRotation + new Vector3(Convert.ToSingle(rot["x"]), Convert.ToSingle(rot["y"]), Convert.ToSingle(rot["z"])));
                var tempPos = quaternionRotation * (new Vector3(Convert.ToSingle(pos["x"]), Convert.ToSingle(pos["y"]), Convert.ToSingle(pos["z"])));
                Vector3 newPos = tempPos + startPos;
                data.Add("position", newPos);
                data.Add("rotation", fixedRotation);
                if (!inventories && data.ContainsKey("items")) data["items"] = new List<object>();
                preloaddata.Add(data);
            }
            return preloaddata;
        }

        List<BaseEntity> Paste(List<Dictionary<string, object>> entities, Vector3 startPos, bool checkPlaced)
        {
            bool unassignid = true;
            uint buildingid = 0;
            var pastedEntities = new List<BaseEntity>();
            foreach (var data in entities)
            {
                try
                {
                    var prefabname = (string)data["prefabname"];
                    var skinid = ulong.Parse(data["skinid"].ToString());
                    var pos = (Vector3)data["position"];
                    var rot = (Quaternion)data["rotation"];

                    var entity = GameManager.server.CreateEntity(prefabname, pos, rot, true);
                    if (entity != null)
                    {
                        entity.transform.position = pos;
                        entity.transform.rotation = rot;

                        var buildingblock = entity.GetComponentInParent<BuildingBlock>();
                        if (buildingblock != null)
                        {
                            buildingblock.blockDefinition = PrefabAttribute.server.Find<Construction>(buildingblock.prefabID);
                            buildingblock.SetGrade((BuildingGrade.Enum)data["grade"]);
                            if (unassignid)
                            {
                                buildingid = BuildingManager.server.NewBuildingID();
                                unassignid = false;
                            }
                            buildingblock.buildingID = buildingid;
                        }
                        entity.skinID = skinid;
                        entity.Spawn();

                        bool killed = false;

                        if (killed) continue;

                        var basecombat = entity.GetComponentInParent<BaseCombatEntity>();
                        if (basecombat != null)
                        {
                            basecombat.ChangeHealth(basecombat.MaxHealth());
                        }


                        var box = entity.GetComponentInParent<StorageContainer>();
                        if (box != null)
                        {
                            box.inventory.Clear();
                            var items = data["items"] as List<object>;
                            var itemlist = new List<ItemAmount>();
                            foreach (var itemDef in items)
                            {
                                var item = itemDef as Dictionary<string, object>;
                                var itemid = Convert.ToInt32(item["id"]);
                                var itemamount = Convert.ToInt32(item["amount"]);
                                var itemskin = ulong.Parse(item["skinid"].ToString());
                                var itemcondition = Convert.ToSingle(item["condition"]);

                                var i = ItemManager.CreateByItemID(itemid, itemamount, itemskin);
                                if (i != null)
                                {
                                    i.condition = itemcondition;

                                    if (item.ContainsKey("magazine"))
                                    {
                                        var magazine = item["magazine"] as Dictionary<string, object>;
                                        var ammotype = int.Parse(magazine.Keys.ToArray()[0]);
                                        var ammoamount = int.Parse(magazine[ammotype.ToString()].ToString());
                                        var heldent = i.GetHeldEntity();
                                        if (heldent != null)
                                        {
                                            var projectiles = heldent.GetComponent<BaseProjectile>();
                                            if (projectiles != null)
                                            {
                                                projectiles.primaryMagazine.ammoType = ItemManager.FindItemDefinition(ammotype);
                                                projectiles.primaryMagazine.contents = ammoamount;
                                            }
                                        }
                                    }
                                    i?.MoveToContainer(box.inventory).ToString();
                                }
                            };
                        }

                        var sign = entity.GetComponentInParent<Signage>();
                        if (sign != null)
                        {
                            var imageByte = FileStorage.server.Get(sign.textureID, FileStorage.Type.png, sign.net.ID);

                            data.Add("sign", new Dictionary<string, object>
                            {
                                {"locked", sign.IsLocked() }
                            });

                            if (sign.textureID > 0 && imageByte != null)
                                ((Dictionary<string, object>)data["sign"]).Add("texture", Convert.ToBase64String(imageByte));
                        }

                        pastedEntities.Add(entity);
                        ArenaEntities.Add(entity);
                    }
                }
                catch (Exception e)
                {
                }
            }
            return pastedEntities;
        }
        #endregion

        #region Debug 

        public static void Debug(string message)
        {
            if (!debug) return;
            Interface.Oxide.LogWarning($"[Duel] {message}");
        }


        public List<DuelStavki> Tops = new List<DuelStavki>();
        public class DuelStavki
        {
            public DuelStavki(string SteamId, string Win, int item, int kolvo, bool weapon, int patron, string ammotype, int flamefuel)
            {
                this.SteamId = SteamId;
                this.Win = Win;
                this.item = item;
                this.kolvo = kolvo;
                this.weapon = weapon;
                this.patron = patron;
                this.ammotype = ammotype;
                this.flamefuel = flamefuel;
            }

            public string SteamId { get; set; }
            public string Win { get; set; }
            public int item { get; set; }
            public int kolvo { get; set; }
            public bool weapon { get; set; }
            public int patron { get; set; }
            public string ammotype { get; set; }
            public int flamefuel { get; set; }
            
        }
        #endregion

        #region Configuration Data

        private string box;
        private int slots;
        private float cooldownMinutes;
        private float maxRadius;
        private float pendingSeconds;
        private float radiationMax;

        [PluginReference]
        private Plugin Ignore;

        private Dictionary<string, DateTime> tradeCooldowns = new Dictionary<string, DateTime>();

        #endregion

        #region Trade State

        class OnlinePlayer
        {
            public BasePlayer Player;
            public StorageContainer View;
            public OpenTrade Trade;

            public PlayerInventory inventory
            {
                get
                {
                    return Player.inventory;
                }
            }

            public ItemContainer containerMain
            {
                get
                {
                    return Player.inventory.containerMain;
                }
            }

            public OnlinePlayer(BasePlayer player)
            {
            }

            public void Clear()
            {
                View = null;
                Trade = null;
            }
        }

        [OnlinePlayers]
        Hash<BasePlayer, OnlinePlayer> onlinePlayers = new Hash<BasePlayer, OnlinePlayer>();

        class OpenTrade
        {
            public OnlinePlayer source;
            public OnlinePlayer target;

            public BasePlayer sourcePlayer
            {
                get
                {
                    return source.Player;
                }
            }

            public BasePlayer targetPlayer
            {
                get
                {
                    return target.Player;
                }
            }

            public bool complete = false;
            public bool closing = false;

            public bool sourceAccept = false;
            public bool targetAccept = false;

            public OpenTrade(OnlinePlayer source, OnlinePlayer target)
            {
                this.source = source;
                this.target = target;
            }

            public OnlinePlayer GetOther(OnlinePlayer onlinePlayer)
            {
                if (source == onlinePlayer)
                {
                    return target;
                }

                return source;
            }

            public BasePlayer GetOther(BasePlayer player)
            {
                if (sourcePlayer == player)
                {
                    return targetPlayer;
                }

                return sourcePlayer;
            }

            public void ResetAcceptance()
            {
                sourceAccept = false;
                targetAccept = false;
            }

            public bool IsInventorySufficient()
            {
                if ((target.containerMain.capacity - target.containerMain.itemList.Count) < source.View.inventory.itemList.Count ||
                       (source.containerMain.capacity - source.containerMain.itemList.Count) < target.View.inventory.itemList.Count)
                {
                    return true;
                }

                return false;
            }

            public bool IsValid()
            {
                if (IsSourceValid() && IsTargetValid())
                    return true;

                return false;
            }

            public bool IsSourceValid()
            {
                if (sourcePlayer != null && sourcePlayer.IsConnected)
                    return true;

                return false;
            }

            public bool IsTargetValid()
            {
                if (targetPlayer != null && targetPlayer.IsConnected)
                    return true;

                return false;
            }
        }

        class PendingTrade
        {
            public BasePlayer Target;
            public Timer Timer;

            public PendingTrade(BasePlayer target)
            {
                Target = target;
            }

            public void Destroy()
            {
                if (Timer != null && !Timer.Destroyed)
                {
                    Timer.Destroy();
                }
            }
        }

        List<OpenTrade> openTrades = new List<OpenTrade>();
        Dictionary<BasePlayer, PendingTrade> pendingTrades = new Dictionary<BasePlayer, PendingTrade>();
        #endregion

        #region Initialization

        void Init()
        {
            Unsubscribe(nameof(CanNetworkTo));
        }

        void Loaded()
        {
            timer.Repeat(1f, 0, delegate
            {
                var check = (from x in Tops where x.Win != "" select x).Count();
                if (check > 0)
                {
                    DuelStavki con = (from x in Tops where x.Win != "" select x).FirstOrDefault();
                    string n1 = con.Win;
                    int n2 = con.item;
                    int n3 = con.kolvo;
                    bool weapon = con.weapon;
                    var item = ItemManager.CreateByItemID(n2, n3);
                    FlameThrower flameThrower = item.GetHeldEntity()?.GetComponent<FlameThrower>();
                    if (flameThrower)
                        flameThrower.ammo = con.flamefuel;
                    if (weapon)
                    {
                        BaseProjectile weapons = item.GetHeldEntity() as BaseProjectile;
                        weapons.primaryMagazine.contents = con.patron;
                        var def = ItemManager.FindItemDefinition(con.ammotype);
                        weapons.primaryMagazine.ammoType = def;
                    }

                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        if (player.UserIDString.Equals(n1) && !player.IsDead() && !player.IsSleeping() && !player.IsWounded() && !IsDuelPlayer(player))
                        {
                            player.inventory.GiveItem(item);
                            Tops.Remove(con);
                        }
                    }
                    SaveData();
                }
            });

            timer.Repeat(4f, 0, delegate
            {
                var check2 = (from x in Tops where x.Win == "" select x).Count();
                if (check2 > 0)
                {
                    DuelStavki con = (from x in Tops where x.Win == "" select x).FirstOrDefault();

                    foreach (var player in BasePlayer.activePlayerList)
                    {

                        if (player.UserIDString.Equals(con.SteamId) && !player.IsDead() && !player.IsSleeping() && !player.IsWounded() && !IsDuelPlayer(player))
                        {
                            timer.Once(3f, delegate
                            {
                                if (player.UserIDString.Equals(con.SteamId) && !player.IsDead() && !player.IsSleeping() && !player.IsWounded() && !IsDuelPlayer(player))
                                {
                                    if (con == null) return;
                                    bool weapon = con.weapon;
                                    var item = ItemManager.CreateByItemID(con.item, con.kolvo);
                                    FlameThrower flameThrower = item.GetHeldEntity()?.GetComponent<FlameThrower>();
                                    if (flameThrower)
                                        flameThrower.ammo = con.flamefuel;
                                    if (weapon)
                                    {
                                        BaseProjectile weapons = item.GetHeldEntity() as BaseProjectile;
                                        weapons.primaryMagazine.contents = con.patron;
                                        var def = ItemManager.FindItemDefinition(con.ammotype);
                                        weapons.primaryMagazine.ammoType = def;

                                    }
                                    player.inventory.GiveItem(item);
                                    Tops.Remove(con);
                                    SaveData();
                                }
                            });
                        }
                    }
                }
            });
            Tops = Interface.GetMod().DataFileSystem.ReadObject<List<DuelStavki>>("DuelStavki");
            buildingPrivlidges = typeof(BasePlayer).GetField("buildingPrivilege", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            db = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("Duel");
            LoadMessages();
            CheckConfig();
            box = GetConfig("Settings", "box", "assets/prefabs/deployable/woodenbox/woodbox_deployed.prefab");
            slots = GetConfig("Settings", "slots", 1);
            cooldownMinutes = GetConfig("Settings", "cooldownMinutes", 5f);
            maxRadius = GetConfig("Settings", "maxRadius", 5000f);
            pendingSeconds = GetConfig("Settings", "pendingSeconds", 25f);
            radiationMax = GetConfig("Settings", "radiationMax", 1f);
        }



        protected override void LoadDefaultConfig()
        {
            Config["Settings", "box"] = "assets/prefabs/deployable/woodenbox/woodbox_deployed.prefab";
            Config["Settings", "slots"] = 30;
            Config["Settings", "cooldownMinutes"] = 5;
            Config["Settings", "maxRadius"] = 5000f;
            Config["Settings", "pendingSeconds"] = 25f;
            Config["Settings", "radiationMax"] = 1;
            Config["VERSION"] = Version.ToString();
        }

        void CheckConfig()
        {
            if (Config["VERSION"] == null)
            {
                // FOR COMPATIBILITY WITH INITIAL VERSIONS WITHOUT VERSIONED CONFIG
                ReloadConfig();
            }
            else if (GetConfig<string>("VERSION", "") != Version.ToString())
            {
                // ADDS NEW, IF ANY, CONFIGURATION OPTIONS
                ReloadConfig();
            }
        }

        protected void ReloadConfig()
        {
            Config["VERSION"] = Version.ToString();

            // NEW CONFIGURATION OPTIONS HERE
            Config["Settings", "radiationMax"] = GetConfig("Settings", "radiationMax", 1f);
            // END NEW CONFIGURATION OPTIONS

            PrintToConsole("Upgrading configuration file");
            SaveConfig();
        }

        void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Inventory: You", "<color=#ADFF2F>[Дуэль]</color> У вас недостаточно места в инвентаре"},
                {"Inventory: Them", "<color=#ADFF2F>[Дуэль]</color> В его инвентаре недостаточно места"},
                {"Inventory: Generic", "<color=#ADFF2F>[Дуэль]</color> Недостаточное пространство инвентаря"},

                {"Player: Not Found", "<color=#ADFF2F>[Дуэль]</color> Не найдено ни одного игрока по этому имени"},
                {"Player: Unknown", "<color=#ADFF2F>[Дуэль]</color> Неизвестно"},
                {"Player: Yourself", "<color=#ADFF2F>[Дуэль]</color> Вы не можете дуэлиться с собой"},

                {"Status: Completing", "<color=#ADFF2F>[Дуэль]</color> Завершение приема ставок ..."},
                {"Status: No Pending", "<color=#ADFF2F>[Дуэль]</color> У вас нет запросов на дуэль"},
                {"Status: Pending", "<color=#ADFF2F>[Дуэль]</color> У него уже есть ожидающий запрос на дуэль"},
                {"Status: Received", "<color=#ADFF2F>[Дуэль]</color> Вы получили запрос на дуэль от {0}. Чтобы принять, введите <color=lime> /duels a </color>."},
                {"Status: They Interrupted", "<color=#ADFF2F>[Дуэль]</color> Игрок двинулся или закрыл окно ставок"},
                {"Status: You Interrupted", "<color=#ADFF2F>[Дуэль]</color> Вы двинулись или закрыли окно ставок"},

                {"Trade: Sent", "<color=#ADFF2F>[Дуэль]</color> Отправлен запрос на дуэль"},
                {"Trade: They Declined", "<color=#ADFF2F>[Дуэль]</color> Он отклонили ваш запрос на дуэль"},
                {"Trade: You Declined", "<color=#ADFF2F>[Дуэль]</color> Вы отклонили его запрос на дуэль"},
                {"Trade: They Accepted", "{0} принял."},
                {"Trade: You Accepted", "Вы приняли."},
                {"Trade: Pending", "Ожидание приема ставок."},

                {"Denied: Permission", "<color=#ADFF2F>[Дуэль]</color> У вас нет разрешения на это"},
                {"Denied: Privilege", "<color=#ADFF2F>[Дуэль]</color> Вы находитесь в чужой билд-зоне"},
                {"Denied: Swimming", "<color=#ADFF2F>[Дуэль]</color> Вы не можете сделать это во время плавания"},
                {"Denied: Falling", "<color=#ADFF2F>[Дуэль]</color> Вы не можете сделать это, падая"},
                {"Denied: Wounded", "<color=#ADFF2F>[Дуэль]</color> Вы не можете сделать это, пока раненые"},
                {"Denied: Irradiated", "<color=#ADFF2F>[Дуэль]</color> Вы не можете этого делать, пока облучаетесь"},
                {"Denied: Generic", "<color=#ADFF2F>[Дуэль]</color> Вы не можете сделать это прямо сейчас"},
                {"Denied: They Busy", "<color=#ADFF2F>[Дуэль]</color> Этот игрок занят"},
                {"Denied: They Ignored You", "О<color=#ADFF2F>[Дуэль]</color> н игнорирует вас"},
                {"Denied: Distance", "<color=#ADFF2F>[Дуэль]</color> Слишком далеко"},
                {"Item: BP", "BP"},
                {"Syntax: Trade Accept", "<color=#ADFF2F>[Дуэль]</color> Недопустимый синтаксис. /duels a"},
                {"Syntax: Trade", "<color=#ADFF2F>[Дуэль]</color> Недопустимый синтаксис. /duels \"ИМЯ ИГРОКА\""},
                {"Cooldown: Seconds", "<color=#ADFF2F>[Дуэль]</color> Вы делаете это слишком часто, повторите попытку через {0} секунд"},
                {"Cooldown: Minutes", "<color=#ADFF2F>[Дуэль]</color> Вы делаете это слишком часто, повторите попытку через {0} минут."}
            }, this);
        }

        #endregion

        #region Oxide Hooks

        object CanNetworkTo(BaseNetworkable entity, BasePlayer target)
        {
            if (entity == null || target == null || entity == target) return null;
            if (target.IsAdmin) return null;

            OnlinePlayer onlinePlayer;
            bool IsMyBox = false;
            if (onlinePlayers.TryGetValue(target, out onlinePlayer))
            {
                if (onlinePlayer.View != null && onlinePlayer.View.net.ID == entity.net.ID)
                {
                    IsMyBox = true;
                }
            }

            if (IsTradeBox(entity) && !IsMyBox) return false;

            return null;
        }

        void OnPlayerInit(BasePlayer player)
        {
            onlinePlayers[player].View = null;
            onlinePlayers[player].Trade = null;
        }



        void OnPlayerLootEnd(PlayerLoot inventory)
        {
            var player = inventory.GetComponent<BasePlayer>();
            if (player == null)
                return;

            OnlinePlayer onlinePlayer;
            if (onlinePlayers.TryGetValue(player, out onlinePlayer) && onlinePlayer.View != null)
            {
                if (onlinePlayer.View == inventory.entitySource && onlinePlayer.Trade != null)
                {
                    OpenTrade t = onlinePlayer.Trade;

                    if (!t.closing)
                    {
                        t.closing = true;
                        if (!onlinePlayer.Trade.complete)
                        {
                            if (onlinePlayer.Trade.sourcePlayer == player)
                            {
                                TradeReply(t, "Status: They Interrupted", "Status: You Interrupted");
                            }
                            else
                            {
                                TradeReply(t, "Status: You Interrupted", "Status: They Interrupted");
                            }
                        }
                        CloseBoxView(player, (StorageContainer)inventory.entitySource);
                    }
                }
            }
        }

        void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            if (container.playerOwner is BasePlayer)
            {
                OnlinePlayer onlinePlayer;
                if (onlinePlayers.TryGetValue(container.playerOwner, out onlinePlayer) && onlinePlayer.Trade != null)
                {
                    OpenTrade t = onlinePlayers[container.playerOwner].Trade;

                    if (!t.complete)
                    {
                        t.sourceAccept = false;
                        t.targetAccept = false;

                        if (t.IsValid())
                        {
                            ShowTrades(t, "Trade: Pending");
                        }
                        else
                        {
                            TradeCloseBoxes(t);
                        }
                    }
                }
            }
        }

        void OnItemRemovedFromContainer(ItemContainer container, Item item)
        {
            if (container.playerOwner is BasePlayer)
            {
                OnlinePlayer onlinePlayer;
                if (onlinePlayers.TryGetValue(container.playerOwner, out onlinePlayer) && onlinePlayer.Trade != null)
                {
                    OpenTrade t = onlinePlayers[container.playerOwner].Trade;
                    if (!t.complete)
                    {
                        t.sourceAccept = false;
                        t.targetAccept = false;

                        if (t.IsValid())
                        {
                            ShowTrades(t, "Trade: Pending");
                        }
                        else
                        {
                            TradeCloseBoxes(t);
                        }
                    }
                }
            }
        }

        #endregion

        #region Commands

        [ChatCommand("duels")]
        void cmdTrade(BasePlayer player, string command, string[] args)
        {
            if (!isIni)
            {
                SendReply(player, "<color=#FE5256>Duel не инициирована. Ожидайте........ </color>");
                return;
            }
            if (IsDuelPlayer(player))
            {
                player.ChatMessage("Вы уже дуэлянт");
                return;
            }
            if (IsPlayerOnActiveDuel(player))
            {
                player.ChatMessage("Вы уже находитесь на дуэли.");
                return;
            }
            if (IsRaidBlock(player)) return;
            if (player.metabolism.radiation_poison.value > 5)
            {
                SendReply(player, "У Вас облучение радиацией. Duel запрещена");
                return;
            }
            if (args.Length == 1)
            {
                if (args[0] == "a")
                {
                    if (pendingTrades.ContainsKey(player))
                    {
                        SendReply(player, GetMsg("Status: Pending", player));
                        return;
                    }
                    BasePlayer source = null;

                    foreach (KeyValuePair<BasePlayer, PendingTrade> kvp in pendingTrades)
                    {
                        if (kvp.Value.Target == player)
                        {
                            source = kvp.Key;
                            break;
                        }
                    }
                    if (IsDuelPlayer(source))
                    {
                        player.ChatMessage("Ваш противник уже находиться на Duel.");
                        return;
                    }
                    AcceptTrade(player);
                    return;
                }
            }

            /* if (createdTeamDuels.Count > 0)
                {
                    var teamDuel = createdTeamDuels[0];
                    if (teamDuel.requestPlayers.ContainsKey(player))
                    {
                        player.ChatMessage("Ты подал заявку на командную дуэль.\nНачать новую ты не можешь");
                        return;
                    }
                }*/
            //  if (!canAcceptRequest(player)) return;
            /*      if (!IsDuelPlayer(player))
                  {chatCom
                      SendReply(player, dontHaveRequest);
                      return;
                  }*/

            // AcceptRequest(player);

            if (args.Length != 1)
            {
                if (pendingTrades.ContainsKey(player))
                {
                    SendReply(player, GetMsg("Syntax: Trade Accept", player));
                }
                else
                {
                    SendReply(player, GetMsg("Syntax: Trade", player));
                }

                return;
            }

            var targetPlayer = FindPlayerByPartialName(args[0]);
            if (targetPlayer == null)
            {
                SendReply(player, GetMsg("Player: Not Found", player));
                return;
            }

            if (targetPlayer == player)
            {
                SendReply(player, GetMsg("Player: Yourself", player));
                return;
            }

            if (!CheckCooldown(player))
            {
                return;
            }

            if (Ignore != null)
            {
                var IsIgnored = Ignore.Call("IsIgnoredS", player.UserIDString, targetPlayer.UserIDString);
                if ((bool)IsIgnored == true)
                {
                    SendReply(player, GetMsg("Denied: They Ignored You", player));
                    return;
                }
            }

            OnlinePlayer onlineTargetPlayer;
            if (onlinePlayers.TryGetValue(targetPlayer, out onlineTargetPlayer) && onlineTargetPlayer.Trade != null)
            {
                SendReply(player, GetMsg("Denied: They Busy", player));
                return;
            }

            if (maxRadius > 0)
            {
                if (targetPlayer.Distance(player) > maxRadius)
                {
                    SendReply(player, GetMsg("Denied: Distance", player));
                    return;
                }
            }


            if (pendingTrades.ContainsKey(player))
            {
                SendReply(player, GetMsg("Status: Pending", player));
            }
            else
            {
                SendReply(targetPlayer, GetMsg("Status: Received", targetPlayer), player.displayName);
                SendReply(player, GetMsg("Trade: Sent", player));
                var pendingTrade = new PendingTrade(targetPlayer);
                pendingTrades.Add(player, pendingTrade);

                pendingTrade.Timer = timer.In(pendingSeconds, delegate ()
                {
                    if (pendingTrades.ContainsKey(player))
                    {
                        pendingTrades.Remove(player);
                        SendReply(player, GetMsg("Trade: They Declined", player));
                        SendReply(targetPlayer, GetMsg("Trade: You Declined", targetPlayer));
                    }
                });
            }
        }

        [ConsoleCommand("duels")]
        void ccTrade(ConsoleSystem.Arg arg)
        {
            string[] args = new string[0];
            if (arg.HasArgs()) args = arg.Args;
            if (args.Length == 0)
            {
                return;
            }
            cmdTrade(arg.Connection.player as BasePlayer, arg.cmd.Name, arg.Args);

        }

        [ConsoleCommand("duels.decline")]
        void ccTradeDecline(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;

            OnlinePlayer onlinePlayer;
            if (onlinePlayers.TryGetValue(player, out onlinePlayer) && onlinePlayer.Trade != null)
            {
                onlinePlayer.Trade.closing = true;
                var target = onlinePlayer.Trade.GetOther(player);
                SendReply(player, GetMsg("Trade: You Declined", player));
                SendReply(target, GetMsg("Trade: They Declined", target));

                TradeCloseBoxes(onlinePlayer.Trade);
            }
        }

        [ConsoleCommand("duels.accept")]
        void ccTradeAccept(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;

            OnlinePlayer onlinePlayer;
            if (onlinePlayers.TryGetValue(player, out onlinePlayer) && onlinePlayer.Trade != null)
            {
                var t = onlinePlayers[player].Trade;
                if (t.sourcePlayer == player)
                {
                    var i = t.target.View.inventory.itemList.Count;
                    var f = t.source.containerMain.capacity - t.source.containerMain.itemList.Count;
                    if (i > f)
                    {

                        TradeReply(t, "Inventory: Them", "Inventory: You");

                        t.sourceAccept = false;
                        ShowTrades(t, "Inventory: Generic");
                        return;
                    }

                    t.sourceAccept = true;
                }
                else if (t.targetPlayer == player)
                {
                    var i = t.source.View.inventory.itemList.Count;
                    var f = t.target.containerMain.capacity - t.target.containerMain.itemList.Count;
                    if (i > f)
                    {
                        TradeReply(t, "Inventory: You", "Inventory: Them");
                        t.targetAccept = false;
                        ShowTrades(t, "Inventory: Generic");
                        return;
                    }

                    t.targetAccept = true;
                }

                if (t.targetAccept == true && t.sourceAccept == true)
                {
                    if (t.IsInventorySufficient())
                    {
                        t.ResetAcceptance();
                        ShowTrades(t, "Inventory: Generic");
                        return;
                    }
                    if (t.complete)
                    {
                        return;
                    }
                    t.complete = true;

                    TradeCooldown(t);
                    CreateRequest(t.sourcePlayer, t.targetPlayer);
                    AcceptRequest(t.targetPlayer);

                    TradeReply(t, "Status: Completing");

                    timer.In(0.1f, () => FinishTrade(t));
                }
                else
                {
                    ShowTrades(t, "Trade: Pending");
                }
            }
        }

        #endregion

        #region GUI

        public string jsonTrade = @"[{""name"":""TradeMsg"",""parent"":""Overlay"",""components"":[{""type"":""UnityEngine.UI.Image"",""color"":""0 0 0 0.76"",""imagetype"":""Filled""},{""type"":""RectTransform"",""anchormax"":""0.77 0.91"",""anchormin"":""0.24 0.52""}]},{""name"":""SourceLabel{1}"",""parent"":""TradeMsg"",""components"":[{""type"":""UnityEngine.UI.Text"",""text"":""{sourcename}"",""fontSize"":""16"",""align"":""UpperLeft""},{""type"":""RectTransform"",""anchormax"":""0.48 0.98"",""anchormin"":""0.03 0.91""}]},{""name"":""TargetLabel{2}"",""parent"":""TradeMsg"",""components"":[{""type"":""UnityEngine.UI.Text"",""text"":""{targetname}"",""fontSize"":""17""},{""type"":""RectTransform"",""anchormax"":""0.97 0.98"",""anchormin"":""0.52 0.91""}]},{""name"":""SourceItemsPanel{3}"",""parent"":""TradeMsg"",""components"":[{""type"":""UnityEngine.UI.RawImage"",""color"":""0 0 0 0.52"",""imagetype"":""Filled""},{""type"":""RectTransform"",""anchormax"":""0.47 0.9"",""anchormin"":""0.03 0.13""}]},{""name"":""SourceItemsText"",""parent"":""SourceItemsPanel{3}"",""components"":[{""type"":""UnityEngine.UI.Text"",""text"":""{sourceitems}"",""fontSize"":""14"",""align"":""UpperLeft""},{""type"":""RectTransform"",""anchormax"":""0.99 0.99"",""anchormin"":""0.01 0.01""}]},{""name"":""TargetItemsPanel{4}"",""parent"":""TradeMsg"",""components"":[{""type"":""UnityEngine.UI.RawImage"",""color"":""0 0 0 0.52"",""imagetype"":""Filled""},{""type"":""RectTransform"",""anchormax"":""0.96 0.9"",""anchormin"":""0.52 0.13""}]},{""name"":""TargetItemsText"",""parent"":""TargetItemsPanel{4}"",""components"":[{""type"":""UnityEngine.UI.Text"",""text"":""{targetitems}"",""fontSize"":""14"",""align"":""UpperLeft""},{""type"":""RectTransform"",""anchormax"":""0.99 0.99"",""anchormin"":""0.01 0.01""}]},{""name"":""AcceptTradeButton{5}"",""parent"":""TradeMsg"",""components"":[{""type"":""UnityEngine.UI.Button"",""color"":""0 0.95 0.14 0.54"",""command"":""duels.accept""},{""type"":""RectTransform"",""anchormax"":""0.47 0.09"",""anchormin"":""0.35 0.03""}]},{""name"":""AcceptTradeLabel"",""parent"":""AcceptTradeButton{5}"",""components"":[{""type"":""UnityEngine.UI.Text"",""text"":""Принять"",""fontSize"":""13"",""align"":""MiddleCenter""},{""type"":""RectTransform"",""anchormax"":""1 1"",""anchormin"":""0 0""}]},{""name"":""DeclineTradeButton{6}"",""parent"":""TradeMsg"",""components"":[{""type"":""UnityEngine.UI.Button"",""color"":""0.95 0 0.02 0.61"",""command"":""duels.decline""},{""type"":""RectTransform"",""anchormax"":""0.15 0.09"",""anchormin"":""0.03 0.03""}]},{""name"":""DeclineTradeLabel"",""parent"":""DeclineTradeButton{6}"",""components"":[{""type"":""UnityEngine.UI.Text"",""text"":""Отклонить"",""fontSize"":""13"",""align"":""MiddleCenter""},{""type"":""RectTransform"",""anchormax"":""1 1"",""anchormin"":""0 0""}]},{""name"":""TargetStatusLabel{7}"",""parent"":""TradeMsg"",""components"":[{""type"":""UnityEngine.UI.Text"",""text"":""{targetstatus}"",""fontSize"":""14"",""align"":""UpperLeft""},{""type"":""RectTransform"",""anchormax"":""0.97 0.09"",""anchormin"":""0.52 0.01""}]}]
";
        private void ShowTrade(BasePlayer player, OpenTrade trade, string status)
        {
            HideTrade(player);

            OnlinePlayer onlinePlayer;
            if (!onlinePlayers.TryGetValue(player, out onlinePlayer))
            {
                return;
            }

            if (onlinePlayer.View == null)
            {
                return;
            }

            StorageContainer sourceContainer = onlinePlayer.View;
            StorageContainer targetContainer = null;
            BasePlayer target = null;

            if (trade.sourcePlayer == player && trade.target.View != null)
            {
                targetContainer = trade.target.View;
                target = trade.targetPlayer;
                if (target is BasePlayer)
                {
                    if (trade.targetAccept)
                    {
                        status += string.Format(GetMsg("Trade: They Accepted", player), CleanName(target.displayName));
                    }
                    else if (trade.sourceAccept)
                    {
                        status += GetMsg("Trade: You Accepted", player);
                    }
                }
                else
                {
                    return;
                }
            }
            else if (trade.targetPlayer == player && trade.source.View != null)
            {
                targetContainer = trade.source.View;
                target = trade.sourcePlayer;
                if (target is BasePlayer)
                {
                    if (trade.sourceAccept)
                    {
                        status += string.Format(GetMsg("Trade: They Accepted", player), CleanName(target.displayName));
                    }
                    else if (trade.targetAccept)
                    {
                        status += GetMsg("Trade: You Accepted", player);
                    }
                }
                else
                {
                    return;
                }
            }

            if (targetContainer == null || target == null)
            {
                return;
            }

            string send = jsonTrade;
            for (int i = 1; i < 100; i++)
            {
                send = send.Replace("{" + i + "}", Oxide.Core.Random.Range(9999, 99999).ToString());
            }

            send = send.Replace("{sourcename}", CleanName(player.displayName));
            if (target != null)
            {
                send = send.Replace("{targetname}", CleanName(target.displayName));
            }
            else
            {
                send = send.Replace("{targetname}", GetMsg("Player: Unknown", player));
            }
            send = send.Replace("{targetstatus}", status);

            List<string> sourceItems = new List<string>();
            foreach (Item i in sourceContainer.inventory.itemList)
            {
                string n = "";
                if (i.IsBlueprint())
                {
                    n = i.amount + " x <color=lightblue>" + i.blueprintTargetDef.displayName.english + " [" + GetMsg("Item: BP", player) + "]</color>";
                }
                else
                {
                    n = i.amount + " x " + i.info.displayName.english;
                }

                sourceItems.Add(n);
            }

            send = send.Replace("{sourceitems}", string.Join("\n", sourceItems.ToArray()));

            if (player != target)
            {
                List<string> targetItems = new List<string>();
                if (targetContainer != null)
                {
                    foreach (Item i in targetContainer.inventory.itemList)
                    {
                        string n2 = "";
                        if (i.IsBlueprint())
                        {
                            n2 = i.amount + " x <color=lightblue>" + i.blueprintTargetDef.displayName.english + " [" + GetMsg("Item: BP", player) + "]</color>";
                        }
                        else
                        {
                            n2 = i.amount + " x " + i.info.displayName.english;
                        }
                        targetItems.Add(n2);
                    }
                }

                send = send.Replace("{targetitems}", string.Join("\n", targetItems.ToArray()));
            }
            else
            {
                send = send.Replace("{targetitems}", "");
            }



            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", send);
        }

        private void HideTrade(BasePlayer player)
        {
            if (player.IsConnected)
            {
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "TradeMsg");
            }
        }

        #endregion

        #region Core Methods

        bool CheckCooldown(BasePlayer player)
        {
            if (cooldownMinutes > 0)
            {
                DateTime startTime;
                if (tradeCooldowns.TryGetValue(player.UserIDString, out startTime))
                {
                    var endTime = DateTime.Now;

                    var span = endTime.Subtract(startTime);
                    if (span.TotalMinutes > 0 && span.TotalMinutes < Convert.ToDouble(cooldownMinutes))
                    {
                        double timeleft = System.Math.Round(Convert.ToDouble(cooldownMinutes) - span.TotalMinutes, 2);
                        if (timeleft < 1)
                        {
                            double timelefts = System.Math.Round((Convert.ToDouble(cooldownMinutes) * 60) - span.TotalSeconds);
                            SendReply(player, string.Format(GetMsg("Cooldown: Seconds", player), timelefts.ToString()));
                        }
                        else
                        {
                            SendReply(player, string.Format(GetMsg("Cooldown: Minutes", player), System.Math.Round(timeleft).ToString()));
                        }
                        return false;
                    }
                    else
                    {
                        tradeCooldowns.Remove(player.UserIDString);
                    }
                }
            }

            return true;
        }

        void TradeCloseBoxes(OpenTrade trade)
        {
            if (trade.IsSourceValid())
            {
                CloseBoxView(trade.sourcePlayer, trade.source.View);
            }

            if (trade.IsTargetValid())
            {
                CloseBoxView(trade.targetPlayer, trade.target.View);
            }
        }

        void TradeReply(OpenTrade trade, string msg, string msg2 = null)
        {
            if (msg2 == null)
            {
                msg2 = msg;
            }
            SendReply(trade.targetPlayer, GetMsg(msg, trade.targetPlayer));
            SendReply(trade.sourcePlayer, GetMsg(msg2, trade.sourcePlayer));
        }

        void ShowTrades(OpenTrade trade, string msg)
        {
            ShowTrade(trade.sourcePlayer, trade, GetMsg(msg, trade.sourcePlayer));
            ShowTrade(trade.targetPlayer, trade, GetMsg(msg, trade.targetPlayer));
        }

        void TradeCooldown(OpenTrade trade)
        {
            PlayerCooldown(trade.targetPlayer);
            PlayerCooldown(trade.sourcePlayer);
        }

        void PlayerCooldown(BasePlayer player)
        {
            if (player.IsAdmin)
            {
                return;
            }
            if (tradeCooldowns.ContainsKey(player.UserIDString))
            {
                tradeCooldowns.Remove(player.UserIDString);
            }

            tradeCooldowns.Add(player.UserIDString, DateTime.Now);
        }

        void FinishTrade(OpenTrade t)
        {
            var source = t.source.View;
            var target = t.target.View;

            TradeCloseBoxes(t);
        }

        void AcceptTrade(BasePlayer player)
        {
            BasePlayer source = null;

            PendingTrade pendingTrade = null;

            foreach (KeyValuePair<BasePlayer, PendingTrade> kvp in pendingTrades)
            {
                if (kvp.Value.Target == player)
                {
                    pendingTrade = kvp.Value;
                    source = kvp.Key;
                    break;
                }
            }
            Puts($"Source {source.displayName} и {player}");
            if (source != null && pendingTrade != null)
            {
                pendingTrade.Destroy();
                pendingTrades.Remove(source);
                StartTrades(source, player);
            }
            else
            {
                SendReply(player, GetMsg("Status: No Pending", player));
            }
        }

        void StartTrades(BasePlayer source, BasePlayer target)
        {
            var trade = new OpenTrade(onlinePlayers[source], onlinePlayers[target]);
            StartTrade(source, target, trade);
            if (source != target)
            {
                StartTrade(target, source, trade);
            }
        }

        void StartTrade(BasePlayer source, BasePlayer target, OpenTrade trade)
        {
            OpenBox(source, source);

            if (!openTrades.Contains(trade))
            {
                openTrades.Add(trade);
            }
            onlinePlayers[source].Trade = trade;

            timer.In(0.1f, () => ShowTrade(source, trade, GetMsg("Trade: Pending", source)));
        }

        void OpenBox(BasePlayer player, BaseEntity target)
        {
            Subscribe(nameof(CanNetworkTo));
            var ply = onlinePlayers[player];
            if (ply.View == null)
            {
                OpenBoxView(player, target);
                return;
            }

            CloseBoxView(player, ply.View);
            timer.In(1f, () => OpenBoxView(player, target));
        }

        void OpenBoxView(BasePlayer player, BaseEntity targArg)
        {
            var pos = new Vector3(player.transform.position.x, player.transform.position.y - 1, player.transform.position.z);
            var corpse = GameManager.server.CreateEntity(box, pos) as StorageContainer;
            corpse.transform.position = pos;

            if (!corpse) return;

            StorageContainer view = corpse as StorageContainer;
            player.EndLooting();
            if (targArg is BasePlayer)
            {

                BasePlayer target = targArg as BasePlayer;
                ItemContainer container = new ItemContainer();
                container.playerOwner = player;
                container.ServerInitialize((Item)null, slots);
                if ((int)container.uid == 0)
                    container.GiveUID();

                view.enableSaving = false;
                view.Spawn();
                view.inventory = container;

                onlinePlayers[player].View = view;
                timer.In(0.1f, () => view.PlayerOpenLoot(player));
            }
        }

        void CloseBoxView(BasePlayer player, StorageContainer view)
        {

            OnlinePlayer onlinePlayer;
            if (!onlinePlayers.TryGetValue(player, out onlinePlayer)) return;
            if (onlinePlayer.View == null) return;

            HideTrade(player);
            if (onlinePlayer.Trade != null)
            {
                OpenTrade t = onlinePlayer.Trade;
                t.closing = true;

                if (t.sourcePlayer == player && t.targetPlayer != player && t.target.View != null)
                {
                    t.target.Trade = null;
                    CloseBoxView(t.targetPlayer, t.target.View);
                }
                else if (t.targetPlayer == player && t.sourcePlayer != player && t.source.View != null)
                {
                    t.source.Trade = null;
                    CloseBoxView(t.sourcePlayer, t.source.View);
                }

                if (openTrades.Contains(t))
                {
                    openTrades.Remove(t);
                }


            }

            if (view.inventory.itemList.Count > 0)
            {
                foreach (Item item in view.inventory.itemList.ToArray())
                {
                    if (item.position != -1)
                    {
                        BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
                        if (weapon != null)
                        {
                           
                            Puts("1");
                            Tops.Add(new DuelStavki(player.UserIDString, "", item.info.itemid, item.amount, true, weapon.primaryMagazine != null ? weapon.primaryMagazine.contents : 0, weapon.primaryMagazine != null ? weapon.primaryMagazine.ammoType.shortname : "", 0));
                        }
                        else
                        {
                            Puts("2");
                            //FlameThrower flameThrower = item.GetHeldEntity()?.GetComponent<FlameThrower>();
                            //if (flameThrower != null)
                            //    iItem.flamefuel = flameThrower.ammo;
                            FlameThrower flameThrower = item.GetHeldEntity()?.GetComponent<FlameThrower>();
                            Tops.Add(new DuelStavki(player.UserIDString, "", item.info.itemid, item.amount, false, 0, "", flameThrower != null ? flameThrower.ammo : 0));
                        }

                        //item.MoveToContainer(player.inventory.containerMain);
                        SaveData();
                    }
                }
            }
            if (player.inventory.loot.entitySource != null)
            {
                player.inventory.loot.Invoke("SendUpdate", 0.1f);
                view.SendMessage("PlayerStoppedLooting", player, SendMessageOptions.DontRequireReceiver);
                player.SendConsoleCommand("inventory.endloot", null);
            }

            player.inventory.loot.entitySource = null;
            player.inventory.loot.itemSource = null;
            player.inventory.loot.containers = new List<ItemContainer>();

            view.inventory = new ItemContainer();

            onlinePlayer.Clear();

            view.Kill(BaseNetworkable.DestroyMode.None);

            if (onlinePlayers.Values.Count(p => p.View != null) <= 0)
            {
                Unsubscribe(nameof(CanNetworkTo));
            }
        }

        bool CanPlayerTrade(BasePlayer player, string perm)
        {
            if (!permission.UserHasPermission(player.UserIDString, perm))
            {
                SendReply(player, GetMsg("Denied: Permission", player));
                return false;
            }
            if (!player.CanBuild())
            {
                SendReply(player, GetMsg("Denied: Privilege", player));
                return false;
            }
            if (radiationMax > 0 && player.radiationLevel > radiationMax)
            {
                SendReply(player, GetMsg("Denied: Irradiated", player));
                return false;
            }
            if (player.IsSwimming())
            {
                SendReply(player, GetMsg("Denied: Swimming", player));
                return false;
            }
            if (!player.IsOnGround())
            {
                SendReply(player, GetMsg("Denied: Falling", player));
                return false;
            }
            if (player.IsFlying)
            {
                SendReply(player, GetMsg("Denied: Falling", player));
                return false;
            }
            if (player.IsWounded())
            {
                SendReply(player, GetMsg("Denied: Wounded", player));
                return false;
            }

            var canTrade = Interface.Call("CanTrade", player);
            if (canTrade != null)
            {
                if (canTrade is string)
                {
                    SendReply(player, Convert.ToString(canTrade));
                }
                else
                {
                    SendReply(player, GetMsg("Denied: Generic", player));
                }
                return false;
            }

            return true;
        }

        #endregion

        #region HelpText
        private void SendHelpText(BasePlayer player)
        {
            var sb = new StringBuilder()
               .Append("")
               .Append("  ").Append("<color=\"#ffd479\">/duel \"Player Name\"</color> - Кинуть вызов игроку").Append("\n")
               .Append("  ").Append("<color=\"#ffd479\">/duel accept</color> - Принять вызов на дуэль").Append("\n");
            player.ChatMessage(sb.ToString());
        }
        #endregion

        #region Helper methods

        private bool IsTradeBox(BaseNetworkable entity)
        {
            foreach (KeyValuePair<BasePlayer, OnlinePlayer> kvp in onlinePlayers)
            {
                if (kvp.Value.View != null && kvp.Value.View.net.ID == entity.net.ID)
                {
                    return true;
                }
            }

            return false;
        }

        bool hasAccess(BasePlayer player, string permissionname)
        {
            if (player.IsAdmin) return true;
            return permission.UserHasPermission(player.UserIDString, permissionname);
        }

        private BasePlayer FindPlayerByPartialName(string name)
        {
            if (string.IsNullOrEmpty(name))
                return null;
            BasePlayer player = null;
            name = name.ToLower();
            var awakePlayers = BasePlayer.activePlayerList.ToArray();
            foreach (var p in awakePlayers)
            {
                if (p.net == null || p.net.connection == null)
                    continue;

                if (p.displayName == name)
                {
                    if (player != null)
                        return null;
                    player = p;
                }
            }

            if (player != null)
                return player;
            foreach (var p in awakePlayers)
            {
                if (p.net == null || p.net.connection == null)
                    continue;

                if (p.displayName.ToLower().IndexOf(name) >= 0)
                {
                    if (player != null)
                        return null;
                    player = p;
                }
            }

            return player;
        }



        private T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null)
            {
                return defaultValue;
            }

            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

        private T GetConfig<T>(string name, string name2, T defaultValue)
        {
            if (Config[name, name2] == null)
            {
                return defaultValue;
            }

            return (T)Convert.ChangeType(Config[name, name2], typeof(T));
        }

        string GetMsg(string key, BasePlayer player = null)
        {
            return lang.GetMessage(key, this, player == null ? null : player.UserIDString);
        }

        private string CleanName(string name)
        {
            return JsonConvert.ToString(name.Trim()).Replace("\"", "");
        }

        #endregion
    }
}
                            

// --- End of file: Duel.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XHeliHealth.cs ---
// --- Original Local Path: XHeliHealth.cs ---

using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("XHeliHealth", "Sempai#3239", "1.0.0")]
    internal class XHeliHealth : RustPlugin
    {
		
		private void Bradley(BradleyAPC apc)
		{
			if (apc == null) return;
			
			apc.InitializeHealth(config.Bradley.APCHealth, config.Bradley.APCHealth);
		}
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
		
		private void OnEntitySpawned(BaseEntity entity)
		{
			if (entity == null || entity.net == null) return;
			
			if (entity is BaseHelicopter)
			{
				if (config.Heli.HeliHealth) Heli(entity as BaseHelicopter);
			}
			
			if (entity is BradleyAPC)
			{
				if (config.Bradley.BradleyHealth) Bradley(entity as BradleyAPC);
			}
		}
		   		 		  						  	   		  	 	 		  						  		 			  	  	
        private class HealthConfig
        {				
            
			[JsonProperty("Настройка кастомного ХП вертолета")]
            public HeliSetting Heli = new HeliSetting();			

			public static HealthConfig GetNewConfiguration()
            {
                return new HealthConfig
                {
					Heli = new HeliSetting
					{
						HousingHealth = 10000,
						BladeHealth = 900,
						TailHealth = 500,
						HeliHealth = true
					},
					Bradley = new BradleySetting
					{
						APCHealth = 1000,
						BradleyHealth = true
					}
				};
			}			
			internal class HeliSetting
            {
				[JsonProperty("ХП переднего винта")]
                public int BladeHealth;				
				[JsonProperty("ХП заднего винта")]
                public int TailHealth;				
				[JsonProperty("Включить кастомное ХП вертолета")]
                public bool HeliHealth;						
                [JsonProperty("ХП корпуса вертолета")]
                public int HousingHealth;
            }			
			[JsonProperty("Настройка кастомного ХП танка")]
            public BradleySetting Bradley = new BradleySetting();		
			
			internal class BradleySetting
            {
				[JsonProperty("ХП танка")]
                public int APCHealth;				
				[JsonProperty("Включить кастомное ХП танка")]
                public bool BradleyHealth;
            } 			
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
		   		 		  						  	   		  	 	 		  						  		 			  	  	
            config = Config.ReadObject<HealthConfig>();
        }
		
		private void Heli(BaseHelicopter heli)
		{
			if (heli == null) return;
			
			heli.InitializeHealth(config.Heli.HousingHealth, config.Heli.HousingHealth);
			
			heli.weakspots[0].health = config.Heli.BladeHealth;
			heli.weakspots[1].health = config.Heli.TailHealth;
		}

        		
				
		private void OnServerInitialized()
		{
			PrintWarning("\n-----------------------------\n" +
			"     Author - Sempai\n" +
			"     VK - vk.com/rustnastroika\n" +
			"     Discord - Sempai#3239\n" +
			"     Config - v.3345\n" +
			"-----------------------------");
		}

        protected override void LoadDefaultConfig()
        {
            config = HealthConfig.GetNewConfiguration();

            PrintWarning("Создание начальной конфигурации плагина!!!");
        }
		
        private HealthConfig config;
		
			}
}


// --- End of file: XHeliHealth.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/DVBuildingUpgrade.cs ---
// --- Original Local Path: DVBuildingUpgrade.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("DVBuildingUpgrade", "ClayMond", "2.0.3")]
    public class DVBuildingUpgrade : RustPlugin
    {
        #region Classes
        private class CurrentGrade
        { 
            [JsonProperty("Текущий индекс улучшения")]
            public int Grade;
            [JsonProperty("Время до де-активации")]
            public int DeActivateTime = 40;

            [JsonProperty("Таймер обновления")]
            public Timer DeTimer;

            public void UpdateTime(BasePlayer player, int time)
            {
                DeActivateTime = time;
                DeTimer?.Destroy();
                instance.UpdateTimer(player);
            }
            
            public void UpGrade(BasePlayer player, int time)
            {
				if (player==null) return;
                if (Grade >= 0 && Grade < 4)
                {
                    UpdateTime(player, time);
                    Activate(player, Grade + 1, CONF_RemoveDefaultTime);
                }
                else if (Grade >= 4)
                {
                    DeActivate(player);
                }
                else 
                {
                    player.ChatMessage($"Неизвестная ошибка. Сообщите адмнистрации: <color=#F24525>{Grade}</color>");
                    return;
                }
            }

            public void Activate(BasePlayer player, int grade, int time)
            {
				if (player==null) return;
                if (grade != Grade)
                { 
                    player.ChatMessage($"");
                }
                
                Grade = grade;
                DeActivateTime = time;

                if (Grade > 0)
                {
                    CuiHelper.DestroyUi(player, instance.Layer);
                    
                    var container = new CuiElementContainer();

                    var image = grade < 5 ? "UpImage" : "RemoveImage";

                    container.Add(new CuiElement
                    {
                        Name = instance.Layer,
                        Parent = "Hud",
                        Components =
                        {   
                            new CuiRawImageComponent { Png = (string) instance.ImageLibrary.Call("GetImage", image), Color = HexToRustFormat("#F65050") },
                            new CuiRectTransformComponent {AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-184.3 673.95", OffsetMax = "-143 713.9"}
                        }
                    });

                    CuiHelper.AddUi(player, container);
                }
                else
                {
                    CuiHelper.DestroyUi(player, instance.Layer);
                }

                instance.UpdateTimer(player);
            }

            public void DeActivate(BasePlayer player) 
            {
				if (player==null) return;
                player.ChatMessage($"");
                Grade = 0;
                Activate(player, 0, 0);
            } 
            
        }

        #endregion
 
        #region Variables

        #region Config

        #region Remove

        private const float RefundPercent = 0.5f;
        private static string CONF_RemovePermission = "GradeDestroy.Remove";
        private static bool CONF_RemoveActivated = true;
        private static int CONF_RemoveTime = 14400;
        private static int CONF_RemoveDefaultTime = 40;
        private static int CONF_RemoveHitTime = 5;
        private static bool CONF_RemoveGameFriends = false;
        private static bool CONF_RemoveFriends;
        private static bool CONF_RemoveClans;
        private static bool CONF_RemoveByCup;
        private static bool CONF_BlockRemoveOnRaid = true;

        #endregion

        #region Upgrade

        private static bool CONF_UpActivated = true;
        private static string CONF_UpPermission = "GradeDestroy.Up";
        private static bool CONF_BlockUpgradeOnRaid = true;
        private static bool CONF_EnableOnHit;

        #endregion

        #region Other
        [PluginReference] Plugin ImageLibrary;
        
        private static List<string> CONF_GradeNames = new List<string>
        {
            "отключено",
            "дерево",
            "камень",
            "металл",
            "мвк",
            "ремув"
        };
        
        public static Dictionary<string, ItemBlueprint> DeployableToBlueprint = new Dictionary<string, ItemBlueprint>();

        #endregion
        
        #endregion

        #region System
        
        [PluginReference] private Plugin Friends, Clans, NoEscape;
        private string Layer = "UI.Remove";
        private static DVBuildingUpgrade instance;

        // Список объектов с кулдаунами до удаления
        Dictionary<uint, double> removeTimers = new Dictionary<uint, double>();
        // Информация об игроках
        private Dictionary<ulong, CurrentGrade> playerGrades = new Dictionary<ulong,CurrentGrade>();

        #endregion

        #endregion
 
        #region Initialization
          
        private void OnServerInitialized()
        {
            instance = this;
            LoadDefaultConfig();

            if (Interface.Oxide.DataFileSystem.ExistsDatafile("Temporary/DVBuildingUpgrade/Objects"))
            {
                removeTimers = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<uint, double>>("Temporary/DVBuildingUpgrade/Objects");
            }
            
            timer.Every(325, SaveData);
            
            foreach (var item in ItemManager.itemList)
            {
                var itemDep = item.GetComponent<ItemModDeployable>();
                var itemBlueprint = item.GetComponent<ItemBlueprint>();
                if (itemDep != null && itemBlueprint != null)
                {
                    DeployableToBlueprint[itemDep.entityPrefab.resourcePath] = itemBlueprint;
                }
            }
			
			if (ImageLibrary){        
			
				ImageLibrary.Call("AddImage", "https://i.imgur.com/7Ay2thv.png", "RemoveImage");
				ImageLibrary.Call("AddImage", "https://i.imgur.com/QoT9u4b.png", "UpImage");
			}
        }

        private void Unload()
        {
            SaveData();
            foreach (var p in BasePlayer.activePlayerList) CuiHelper.DestroyUi(p, Layer);
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("Temporary/DVBuildingUpgrade/Objects", removeTimers);
        }
        
        protected override void LoadDefaultConfig()
        {
            GetConfig("Удаление построек", "Разрешать игрокам удалять постройки", ref CONF_RemoveActivated);
            GetConfig("Удаление построек", "Разрешение для удаления построек", ref CONF_RemovePermission);
            GetConfig("Удаление построек", "Лимит времени для удаления (0 - бесконечно)", ref CONF_RemoveTime);
            GetConfig("Удаление построек", "Разрешить удалять постройки друзей", ref CONF_RemoveFriends);
            GetConfig("Удаление построек", "Разрешить удалять постройка со-кланов", ref CONF_RemoveClans);
            GetConfig("Удаление построек", "Разрешить удалять при авторизации в шкафу", ref CONF_RemoveByCup);
            GetConfig("Удаление построек", "Запрещать удалять во время рейда", ref CONF_BlockRemoveOnRaid);
            
            GetConfig("Улучшение построек", "Разрешать игрокам улучшать постройки", ref CONF_UpActivated);
            GetConfig("Улучшение построек", "Разрешение для улучшения построек", ref CONF_UpPermission);
            GetConfig("Улучшение построек", "Время автоматического включения улучшения", ref CONF_RemoveHitTime);
            GetConfig("Улучшение построек", "Включать режим автоматического улучшения при ручном улучшения", ref CONF_EnableOnHit);
            GetConfig("Улучшение построек", "Запрещать улучшать во время рейда", ref CONF_BlockUpgradeOnRaid);
            

            GetConfig("Остальное", "Отображение имён улучшения", ref CONF_GradeNames);
            
            Config.Save();
        }

        #endregion

        #region Functions

        private string CanRemove(BasePlayer player, BaseEntity entity)
        {
			if (player==null || entity==null) return "Ошибка";
            if (!player.IsBuildingAuthed())
            { 
                return "Вы не можете удалять постройки без шкафа</color>"; 
            }
             
            if (!player.CanBuild())
            {
                return "Вы не можете удалять в зоне действия<color=#F24525>чужого шкафа</color>!"; 
            }

            var time = GetRaidBlockTime(player.userID);
             
            if (time > 0)
            {
                return $"Вы не можете улучшать постройки! Подождите: {FormatTime(TimeSpan.FromSeconds(time))}</color>";
            }

            double maxRemoveTime;
            if (CONF_RemoveTime != 0 && removeTimers.TryGetValue(entity.net.ID, out maxRemoveTime) && maxRemoveTime <= CurrTimestamp())
            { 
                return "Вышло время удаления данного объекта!</color>";
            }

            bool isOwner = entity.OwnerID == player.userID;
            bool areFriends = (bool) (Friends?.Call("ApiIsFriend", player.userID, entity.OwnerID) ?? false);
            List<string> areClanMates = (List<string>) (Clans?.Call("GetClanMembers", player.userID) ?? new List<string>());
            
            if (CONF_RemoveByCup || CONF_RemoveFriends && areFriends || CONF_RemoveClans && areClanMates.Contains(entity.OwnerID.ToString()) || isOwner)
            {
                return "";
            }

            return "Вы можете удалять свои постройки, а также постройки друзей!</color>";
        }

        private string TryUpgrade(BasePlayer player, BuildingBlock block, CurrentGrade currentGrade)
        {
			if (player==null || block==null) return "Ошибка";
            if (currentGrade.Grade <= (int) block.lastGrade )
                return "";

            var time = GetRaidBlockTime(player.userID);
            
            if (time > 0)
            {
                return $"Вы не можете улучшать постройки! Подождите: {FormatTime(TimeSpan.FromSeconds(time))}</color>";
            }

            var building = BuildingManager.server.GetBuilding(block.buildingID);
            if (building != null && !building.HasBuildingPrivileges())
            {
                return $"Вы не можете использовать автоапгрейд <color=#F24525>без шкафа</color>.</color>";
            }

            if (CONF_BlockUpgradeOnRaid && NoEscape)
            {
                var blockTime = (bool) (NoEscape?.Call("IsRaidBlocked", player) ?? false);
                if (blockTime)
                {
                    currentGrade.DeActivate(player); 
                    return "Вы не можете авто-улучшать постройки во время рейда</color>!";
                }
            }
            
            if (block.SecondsSinceAttacked < 30)
            { 
                return $"Это объект можно будет улучшить через {FormatTime(TimeSpan.FromSeconds(30 - (int) block.SecondsSinceAttacked), maxSubstr:2)}</color>";
            }

            if (block.blockDefinition.checkVolumeOnUpgrade &&
                DeployVolume.Check(block.transform.position, block.transform.rotation, 
                    PrefabAttribute.server.FindAll<DeployVolume>(block.prefabID), ~(1 << block.gameObject.layer)))
            {
                return $"Улучшение данного объекта чем-то заблокированно</color>";
            }

            
            foreach (var check in block.blockDefinition.grades[currentGrade.Grade].costToBuild)
            {
                if (player.inventory.GetAmount(check.itemid) < check.amount)
                {
                    CuiHelper.DestroyUi(player, Layer);
                    currentGrade.DeActivate(player);
                    return "У вас не хватает ресурсов для автоматического улучшения!</color>";
                }
            }
            
            foreach (var check in block.blockDefinition.grades[currentGrade.Grade].costToBuild)
            {
                player.inventory.Take(null, check.itemid, (int) check.amount);
                player.Command("note.inv", check.itemid, check.amount * -1f);
            }
            
            block.SetGrade((BuildingGrade.Enum) currentGrade.Grade);
            block.UpdateSkin(); 
            block.SetHealthToMax();
            block.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            currentGrade.UpdateTime(player, CONF_RemoveDefaultTime);
            
            return "";
        }

        private void UpdateTimer(BasePlayer player)
        {
            CurrentGrade currentGrade = GetPlayerCurrentGrade(player);
            if (currentGrade.Grade == 0)
            {
                CuiHelper.DestroyUi(player, Layer);
                return;
            }
            
            CuiHelper.DestroyUi(player, Layer + ".Text");
            
            CuiElementContainer container = new CuiElementContainer();
            
            container.Add(new CuiLabel
            {
                Text = { Text = $"{CONF_GradeNames[currentGrade.Grade].ToUpper()}", FontSize = 9, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 20.7" }
            }, Layer, Layer + ".Text");

            CuiHelper.AddUi(player, container);
              
            currentGrade.DeActivateTime--;
            if (currentGrade.DeActivateTime < 0)
            { 
                currentGrade.DeActivate(player);
                CuiHelper.DestroyUi(player, Layer);
                return;
            }
            
            currentGrade.DeTimer?.Destroy();
            currentGrade.DeTimer = timer.Once(1, () => UpdateTimer(player));
        }

        #endregion

        #region Commands

        [ConsoleCommand("building.upgrade")]
        void cmdConsoleUpgrade(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection?.player as BasePlayer;

            if (player == null) return;

            CurrentGrade currentGrade = GetPlayerCurrentGrade(player);
            currentGrade.UpGrade(player, CONF_RemoveDefaultTime); 
        }
        
        [ChatCommand("remove")]
        private void cmdChatRemove(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            if (!CONF_RemoveActivated)
                return;
            
            CurrentGrade currentGrade = GetPlayerCurrentGrade(player);

            if (currentGrade.Grade == 5)
            {
                currentGrade.DeActivate(player);
            }
            else
            {
                currentGrade.Activate(player, 5, CONF_RemoveDefaultTime);
            }
        }

        [ChatCommand("up")]
        private void cmdChatUpgrade(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            if (!CONF_UpActivated)
                return;

            CurrentGrade currentGrade = GetPlayerCurrentGrade(player);

            switch (args.Length)
            {
                case 0:
                {
                    currentGrade.UpGrade(player, CONF_RemoveDefaultTime);
                    break;
                }
                case 1:
                {
                    int newGrade;
                    if (!int.TryParse(args[0], out newGrade) || newGrade < 0 || newGrade > 4)
                    {
                        SendReply(player, $"Введенный уровень улучшение <color=#D500C3>не существует</color>!\n" +
                                                $"Попробуйте:\n" +
                                                $"\n" + 
                                                $"0</color> => Отключить\n" +
                                                $"1</color> => дерево\n" +
                                                $"2</color> => камень\n" +
                                                $"3</color> => металл\n" +
                                                $"4</color> => мвк");
                        return;
                    }
                    currentGrade.Activate(player, newGrade, CONF_RemoveDefaultTime);
                    break;
                }
                default:
                {
                    cmdChatUpgrade(player, command, new string[] { });
                    return;
                }
            }
        }

        #endregion

        #region Hooks

        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            if (plan == null) return;
            BasePlayer player = plan?.GetOwnerPlayer();
            if (player == null)
                return;

            var baseEnt = go.ToBaseEntity();
            BuildingBlock block = go.ToBaseEntity().GetComponent<BuildingBlock>();

            if (CONF_RemoveTime != 0 && (block != null || baseEnt is Door))
            {
                removeTimers.Add(baseEnt.net.ID, CurrTimestamp() + CONF_RemoveTime);
            }
            
            if (block == null) 
                return;

            var currentGrade = GetPlayerCurrentGrade(player);
            if (currentGrade.Grade <= 0 || currentGrade.Grade > 4)
                return;

            var result = TryUpgrade(player, block, currentGrade);
            if (result != string.Empty)
            {
                player.ChatMessage(result);
            }
        }
        
        object OnHammerHit(BasePlayer player, HitInfo info)
        {
            if (info == null)
                return null;
            
            var currentGrade = GetPlayerCurrentGrade(player);

            var ent = info.HitEntity;
            if (ent == null)
                return null;
            
            if (currentGrade.Grade == 5)
            {
                if ((ent is BuildingBlock || DeployableToBlueprint.ContainsKey(ent.PrefabName)) && !ent.IsDestroyed)
                {
                    var tryRemoveResult = CanRemove(player, ent);
                    if (tryRemoveResult != "")
                        SendReply(player, tryRemoveResult);
                    else
                        RemoveEntity(player, ent);
                    return false;
                }
            }
            else if (currentGrade.Grade != 0)
            {
                var block = ent as BuildingBlock;
                if (block != null && HasUpgradePrivilege(player, block))
                {
                    var tryUpgradeResult = TryUpgrade(player, block, currentGrade);
                    if (tryUpgradeResult != string.Empty)
                        SendReply(player, tryUpgradeResult);
                    return false;
                }
            }
            else
            {
                if (CanRemove(player, ent) == string.Empty)
                {
                    var block = ent as BuildingBlock;
                    if (block != null && HasUpgradePrivilege(player, block))
                    {
                        double maxRemoveTime;
                        if (removeTimers.TryGetValue(block.net.ID, out maxRemoveTime) && player.SecondsSinceAttacked > 10) 
                        {
                            double leftRemove = maxRemoveTime - CurrTimestamp();
                            if (leftRemove < 0) 
                            {
                                SendReply(player, "Время удаления данного объекта<color=#D500C3>закончилось</color>!");
                            }
                            else
                            {
                                SendReply(player, $"Через<color=#F24525>{FormatTime(TimeSpan.FromSeconds(leftRemove), maxSubstr:2)}</color> вы не сможете удалить этот объект!");
                            }
                            
                            player.Hurt(0);
                        }
                    }
                }
            }
            
            return null;
        }

        private bool HasUpgradePrivilege(BasePlayer player, BaseEntity entity)
        {
            return !player.IsBuildingBlocked(entity.transform.position, entity.transform.rotation, entity.bounds);
        }

        object OnStructureUpgrade(BaseCombatEntity entity, BasePlayer player, BuildingGrade.Enum grade)
        {
			if (player==null) return null;
            if (CONF_EnableOnHit && permission.UserHasPermission(player.UserIDString, CONF_UpPermission))
            {
                CurrentGrade currentGrade = GetPlayerCurrentGrade(player);
                currentGrade.Activate(player, (int) grade, CONF_RemoveHitTime);
            }

            if (player.SecondsSinceAttacked > 10)
            { 
                SendReply(player, $"Вы можете удалить построенный объект в течении <color=#F24525>{FormatTime(TimeSpan.FromSeconds(CONF_RemoveTime), maxSubstr:2)}</color>");
                player.Hurt(0);
            }
            return null;
        }

        #endregion

        #region Utils
        
        private void RemoveEntity(BasePlayer player, BaseEntity hitEntity)
        {
			if (player==null || hitEntity==null) return;
            RefundEntity(player, hitEntity);
            
            var storageContainer = hitEntity as StorageContainer;
            if (storageContainer != null)
            {
                storageContainer.DropItems();
            }

            removeTimers.Remove(hitEntity.net.ID);
            hitEntity.Kill(BaseNetworkable.DestroyMode.Gib);
        }

        private static void RefundEntity(BasePlayer player, BaseEntity entity)
        {
			if (player==null || entity==null) return;
            if (entity.name == "assets/prefabs/deployable/planters/planter.small.deployed.prefab")
            {
                return;
            }

            List<ItemAmount> ingredientList = null;

            var entityBb = entity as BuildingBlock;
            ItemBlueprint itemBp;
            if (DeployableToBlueprint.TryGetValue(entity.name, out itemBp))
            {
                ingredientList = itemBp.ingredients;
            }
            else if (entityBb != null)
            {
                ingredientList = entityBb.blockDefinition.grades[(int) entityBb.grade].costToBuild;
            }

            if (ingredientList == null || ingredientList.Count == 0)
            {
                return;
            }
            
            foreach (ItemAmount ingredient in ingredientList)
            {
                var amount = (int)ingredient.amount;
                amount = amount == 0 ? 1 : amount;
                amount = (int) Math.Round( (double) amount * RefundPercent);

                if (amount <= 0)
                {
                    continue;
                }

                Item item = ItemManager.CreateByItemID(ingredient.itemid, amount);
                player.GiveItem(item);
            }
        }
        
        private CurrentGrade GetPlayerCurrentGrade(BasePlayer player)
        {
            CurrentGrade currentGrade;
            if (!playerGrades.TryGetValue(player.userID, out currentGrade))
                currentGrade = playerGrades[player.userID] = new CurrentGrade();
            return currentGrade;
        }

        public double GetRaidBlockTime(ulong userID)
        {
            if (!plugins.Find("NoEscape")) return 0;
            var time = plugins.Find("NoEscape").CallHook("ApiGetTime", userID);
            return Convert.ToDouble(time);
        }

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }
        
        public static string FormatTime(TimeSpan time, int maxSubstr = 5)
        {
            string result = string.Empty;

            int i = 0;
            if (time.Days != 0 && i < maxSubstr)
            {
                if (!string.IsNullOrEmpty(result))
                    result += " ";

                result += $"{Format(time.Days, "дней", "дня", "день")}";
                i++;
            }

            if (time.Hours != 0 && i < maxSubstr)
            {
                if (!string.IsNullOrEmpty(result))
                    result += " ";

                result += $"{Format(time.Hours, "часов", "часа", "час")}";
                i++;
            }

            if (time.Minutes != 0 && i < maxSubstr)
            {
                if (!string.IsNullOrEmpty(result))
                    result += " ";

                result += $"{Format(time.Minutes, "минут", "минуты", "минута")}";
                i++;
            }

            if (time.Seconds != 0 && i < maxSubstr)
            {
                if (!string.IsNullOrEmpty(result))
                    result += " ";

                result += $"{Format(time.Seconds, "секунд", "секунды", "секунда")}";
            }

            return result;
        }
        
        private static string Format(int units, string form1, string form2, string form3 )
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                return $"{units} {form1}";

            if (tmp >= 2 && tmp <= 4)
                return $"{units} {form2}";

            return $"{units} {form3}";
        }
        
        private bool GetConfig<T>(string mainMenu, string key, ref T var)
        {
            if (Config[mainMenu, key] != null)
            {
                var = Config.ConvertValue<T>(Config[mainMenu, key]);
                return false;
            }

            Config[mainMenu, key] = var;
            return true;
        }
        
        private static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        private static double CurrTimestamp() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;

        #endregion
    }
}

// --- End of file: DVBuildingUpgrade.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Clans-0.2.8.cs ---
// --- Original Local Path: Clans-0.2.8.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    using ClansEx;

    [Info("Clans", "k1lly0u", "0.2.8")]
    public class Clans : CovalencePlugin
    {
        #region Fields        
        private bool isInitialized = false;

        private Regex hexFilter = new Regex("^([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$");

        public static Clans Instance { get; private set; }

        private static readonly DateTime Epoch = new DateTime(1970, 1, 1);

        private static readonly double MaxUnixSeconds = (DateTime.MaxValue - Epoch).TotalSeconds;

        private const string COLORED_LABEL = "[{0}]{1}[/#]";
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            Instance = this;
            LoadData();
        }

        protected override void LoadDefaultMessages() => lang.RegisterMessages(Messages, this);

        private void OnServerInitialized()
        {
            if (!configData.Tags.Enabled)
                Unsubscribe(nameof(OnPluginLoaded));

            InitializeClans();
        }

        private void OnPluginLoaded(Plugin plugin)
        {
            if (configData.Tags.Enabled && plugin?.Title == "Better Chat")
                Interface.CallHook("API_RegisterThirdPartyTitle", this, new Func<IPlayer, string>(BetterChat_FormattedClanTag));
        }

        private void OnUserConnected(IPlayer player)
        {            
            Clan clan = storedData?.FindClanByID(player.Id);
            if (clan != null)
            {
                clan.OnPlayerConnected(player);
            }
            else
            {
                List<string> invites;
                if (storedData.playerInvites.TryGetValue(player.Id, out invites))
                {
                    player.Reply(string.Format(Message("Notification.PendingInvites", player.Id), invites.ToSentence(), "clan"));
                }
            }
        }

        private void OnUserDisconnected(IPlayer player) => storedData?.FindClanByID(player.Id)?.OnPlayerDisconnected(player);

        private void Unload()
        {
            SaveData();

            Instance = null;
        }
        #endregion

        #region Functions
        private void InitializeClans()
        {
            Puts("Initializing Clans...");

            List<string> purgedClans = ListPool.Get<string>();

            foreach (KeyValuePair<string, Clan> kvp in storedData.clans)
            {
                Clan clan = kvp.Value;

                if (clan.ClanMembers.Count == 0 || (configData.Purge.Enabled && UnixTimeStampUTC() - clan.LastOnlineTime > (configData.Purge.OlderThanDays * 86400)))
                {
                    purgedClans.Add(kvp.Key);
                    continue;
                }

                if (configData.Clans.Alliance.Enabled)
                {
                    for (int i = clan.AllianceInvites.Count - 1; i >= 0; i--)
                    {
                        KeyValuePair<string, double> allianceInvite = clan.AllianceInvites.ElementAt(i);

                        if (!storedData.clans.ContainsKey(allianceInvite.Key) || (UnixTimeStampUTC() - allianceInvite.Value > configData.Clans.Invites.AllianceInviteExpireTime))
                            clan.AllianceInvites.Remove(allianceInvite.Key);
                    }

                    for (int i = clan.Alliances.Count - 1; i >= 0; i--)
                    {
                        string allyTag = clan.Alliances.ElementAt(i);

                        if (!storedData.clans.ContainsKey(allyTag))
                            clan.Alliances.Remove(allyTag);
                    }
                }

                for (int i = clan.MemberInvites.Count - 1; i >= 0; i--)
                {
                    KeyValuePair<string, Clan.MemberInvite> memberInvite = clan.MemberInvites.ElementAt(i);

                    if (UnixTimeStampUTC() - memberInvite.Value.ExpiryTime > configData.Clans.Invites.MemberInviteExpireTime)
                        clan.MemberInvites.Remove(memberInvite.Key);
                }

                foreach (KeyValuePair<string, Clan.Member> member in clan.ClanMembers)
                    storedData.RegisterPlayer(member.Key, clan.Tag);
            }

            if (purgedClans.Count > 0)
            {
                Puts($"Purging {purgedClans.Count} expired or invalid clans");

                StringBuilder str = new StringBuilder();

                for (int i = 0; i < purgedClans.Count; i++)
                {
                    string tag = purgedClans[i];
                    Clan clan = storedData.clans[tag];
                    if (clan == null)
                        continue;

                    str.Append($"{(i > 0 ? "\n" : "")}Purged - [{tag}] | {clan.Description} | Owner: {clan.OwnerID} | Last Online: {UnixTimeStampToDateTime(clan.LastOnlineTime)}");

                    storedData.clans.Remove(tag);
                }

                if (configData.Purge.ListPurgedClans)
                {
                    Puts(str.ToString());

                    if (configData.Options.LogChanges)
                        LogToFile(Title, str.ToString(), this);
                }
            }

            Puts($"Loaded {storedData.clans.Count} clans!");

            ListPool.Free(ref purgedClans);

            if (configData.Tags.Enabled)
                Interface.CallHook("API_RegisterThirdPartyTitle", this, new Func<Oxide.Core.Libraries.Covalence.IPlayer, string>(BetterChat_FormattedClanTag));

            isInitialized = true;

            foreach (IPlayer player in players.Connected)
                OnUserConnected(player);

            TimedSaveData();
        }

        private bool ClanTagExists(string tag)
        {
            ICollection<string> collection = storedData.clans.Keys;
            for (int i = 0; i < collection.Count; i++)
            {
                if (collection.ElementAt(i).Equals(tag, StringComparison.OrdinalIgnoreCase))
                    return true;
            }

            return false;
        }

        private string FormatTime(double time)
        {
            TimeSpan dateDifference = TimeSpan.FromSeconds((float)time);
            int days = dateDifference.Days;
            int hours = dateDifference.Hours + (days * 24);

            int mins = dateDifference.Minutes;
            int secs = dateDifference.Seconds;

            if (hours > 0)
                return string.Format("{0:00}h:{1:00}m:{2:00}s", hours, mins, secs);
            else if (mins > 0)
                return string.Format("{0:00}m:{1:00}s", mins, secs);
            else return string.Format("{0:00}s", secs);
        }

        private string BetterChat_FormattedClanTag(IPlayer player)
        {            
            Clan clan = storedData.FindClanByID(player.Id);
            if (clan == null)
                return string.Empty;

            return $"[#{(string.IsNullOrEmpty(clan.TagColor) || !configData.Tags.CustomColors ? configData.Tags.TagColor.Replace("#", "") : clan.TagColor.Replace("#", ""))}][+{configData.Tags.TagSize}]{configData.Tags.TagOpen}{clan.Tag}{configData.Tags.TagClose}[/+][/#]";
        }

        private static int UnixTimeStampUTC() => (int)DateTime.UtcNow.Subtract(Epoch).TotalSeconds;

        private static DateTime UnixTimeStampToDateTime(double unixTimeStamp)
        {
            return unixTimeStamp > MaxUnixSeconds
                ? Epoch.AddMilliseconds(unixTimeStamp)
                : Epoch.AddSeconds(unixTimeStamp);
        }
        #endregion

        #region Clan Management   
        [HookMethod("CreateClan")]
        public void CreateClan(IPlayer player, string tag, string description)
        {
            if (player == null)
                return;

            if (storedData.FindClanByID(player.Id) != null)
            {
                player.Reply(Message("Notification.Create.InExistingClan", player.Id));
                return;
            }

            if (tag.Length < configData.Tags.TagLength.Minimum || tag.Length > configData.Tags.TagLength.Maximum)
            {
                player.Reply(string.Format(Message("Notification.Create.InvalidTagLength", player.Id), configData.Tags.TagLength.Minimum, configData.Tags.TagLength.Maximum));
                return;
            }

            if (ClanTagExists(tag))
            {
                player.Reply(Message("Notification.Create.ClanExists", player.Id));
                return;
            }

            storedData.clans[tag] = new Clan(player, tag, description);
            storedData.RegisterPlayer(player.Id, tag);

            player.Reply(string.Format(Message("Notification.Create.Success", player.Id), tag));

            Interface.CallHook("OnClanCreate", tag);

            if (configData.Options.LogChanges)
                LogToFile(Title, $"{player.Name} created the clan [{tag}]", this);
        }

        [HookMethod("InvitePlayer")]
        public bool InvitePlayer(IPlayer inviter, string targetId)
        {
            IPlayer invitee = covalence.Players.FindPlayerById(targetId) ?? null;
            if (invitee == null)
            {
                inviter.Reply(string.Format(Message("Notification.Generic.UnableToFindPlayer", inviter.Id), targetId));
                return false;
            }

            return InvitePlayer(inviter, invitee);
        }

        [HookMethod("InvitePlayer")]
        public bool InvitePlayer(IPlayer inviter, IPlayer invitee)
        {
            if (inviter == null || invitee == null)
                return false;

            Clan clan = storedData.FindClanByID(inviter.Id);
            if (clan == null)
            {
                inviter.Reply(Message("Notification.Generic.NoClan", inviter.Id));
                return false;
            }

            Clan other = storedData.FindClanByID(invitee.Id);
            if (other != null)
            {
                inviter.Reply(string.Format(Message("Notification.Invite.InClan", inviter.Id), invitee.Name));
                return false;
            }

            return clan.InvitePlayer(inviter, invitee);
        }

        [HookMethod("WithdrawInvite")]
        public bool WithdrawInvite(IPlayer player, string partialNameOrID)
        {
            if (player == null)
                return false;

            Clan clan = storedData.FindClanByID(player.Id);
            if (clan == null)
            {
                player.Reply(Message("Notification.Generic.NoClan", player.Id));
                return false;
            }

            if (!clan.IsOwner(player.Id) && !clan.IsModerator(player.Id))
            {
                player.Reply(Message("Notification.WithdrawInvite.NoPermissions", player.Id));
                return false;
            }

            foreach (KeyValuePair<string, Clan.MemberInvite> invite in clan.MemberInvites)
            {
                if (partialNameOrID.Equals(invite.Key) || invite.Value.DisplayName.Contains(partialNameOrID))
                {
                    storedData.RevokePlayerInvite(partialNameOrID, clan.Tag);

                    clan.MemberInvites.Remove(invite.Key);
                    clan.Broadcast("Notification.WithdrawInvite.Success", player.Name, invite.Value.DisplayName);
                    return true;
                }
            }

            player.Reply(string.Format(Message("Notification.WithdrawInvite.UnableToFind", player.Id), partialNameOrID));
            return false;
        }

        [HookMethod("RejectInvite")]
        public bool RejectInvite(IPlayer player, string tag)
        {
            if (player == null)
                return false;

            Clan clan = storedData.FindClan(tag);
            if (clan == null)
            {
                player.Reply(string.Format(Message("Notification.Generic.InvalidClan", player.Id), tag));
                return false;
            }

            if (!clan.MemberInvites.ContainsKey(player.Id))
            {
                player.Reply(string.Format(Message("Notification.RejectInvite.InvalidInvite", player.Id), tag));
                return false;
            }

            clan.MemberInvites.Remove(player.Id);

            storedData.OnInviteRejected(player.Id, clan.Tag);

            clan.Broadcast("Notification.RejectInvite.Reply", player.Name);
            player.Reply(string.Format(Message("Notification.RejectInvite.PlayerMessage", player.Id), tag));

            if (configData.Options.LogChanges)
                Instance.LogToFile(Instance.Title, $"{player.Name} rejected their invite to [{tag}]", Instance);

            return true;
        }

        [HookMethod("JoinClan")]
        public bool JoinClan(IPlayer player, string tag)
        {
            if (player == null || string.IsNullOrEmpty(tag))
                return false;

            Clan clan = storedData.FindClanByID(player.Id);
            if (clan != null)
            {
                player.Reply(Message("Notification.Join.InExistingClan", player.Id));
                return false;
            }

            clan = storedData.FindClan(tag);
            if (clan == null)
                return false;

            return clan.JoinClan(player);
        }

        [HookMethod("LeaveClan")]
        public bool LeaveClan(IPlayer player)
        {
            if (player == null)
                return false;

            Clan clan = storedData.FindClanByID(player.Id);
            if (clan == null)
            {
                player.Reply(Message("Notification.Generic.NoClan", player.Id));
                return false;
            }

            return clan.LeaveClan(player);
        }

        [HookMethod("KickPlayer")]
        public bool KickPlayer(IPlayer player, string playerId)
        {
            if (player == null)
                return false;

            Clan clan = storedData.FindClanByID(player.Id);
            if (clan == null)
            {
                player.Reply(Message("Notification.Generic.NoClan", player.Id));
                return false;
            }

            return clan.KickMember(player, playerId);
        }

        [HookMethod("PromotePlayer")]
        public bool PromotePlayer(IPlayer promoter, string targetId)
        {
            if (promoter == null)
                return false;

            Clan clan = storedData.FindClanByID(promoter.Id);
            if (clan == null)
            {
                promoter.Reply(Message("Notification.Generic.NoClan", promoter.Id));
                return false;
            }

            Clan other = storedData.FindClanByID(targetId);
            if (other == null || !clan.Tag.Equals(other.Tag))
            {
                string Name = covalence.Players.FindPlayer(targetId)?.Name ?? targetId;

                promoter.Reply(string.Format(Message("Notification.Promotion.TargetNoClan", promoter.Id), Name));
                return false;
            }

            return clan.PromotePlayer(promoter, targetId);
        }

        [HookMethod("DemotePlayer")]
        public bool DemotePlayer(IPlayer demoter, string targetId)
        {
            if (demoter == null)
                return false;

            Clan clan = storedData.FindClanByID(demoter.Id);
            if (clan == null)
            {
                demoter.Reply(Message("Notification.Generic.NoClan", demoter.Id));
                return false;
            }

            Clan other = storedData.FindClanByID(targetId);
            if (other == null || !clan.Tag.Equals(other.Tag))
            {
                string Name = covalence.Players.FindPlayer(targetId)?.Name ?? targetId;

                demoter.Reply(string.Format(Message("Notification.Promotion.TargetNoClan", demoter.Id), Name));
                return false;
            }

            return clan.DemotePlayer(demoter, targetId);
        }

        [HookMethod("DisbandClan")]
        public bool DisbandClan(IPlayer player)
        {
            Clan clan = storedData.FindClanByID(player.Id);

            if (clan == null)
            {
                player.Reply(Message("Notification.Generic.NoClan", player.Id));
                return false;
            }

            if (!clan.IsOwner(player.Id))
            {
                player.Reply(Message("Notification.Disband.NotOwner", player.Id));
                return false;
            }

            string tag = clan.Tag;

            clan.Broadcast("Notification.Disband.Reply", Array.Empty<object>());
            clan.DisbandClan();

            player.Reply(string.Format(Message("Notification.Disband.Success", player.Id), tag));

            return true;
        }
        #endregion

        #region Alliance Management
        [HookMethod("OfferAlliance")]
        public bool OfferAlliance(IPlayer player, string tag)
        {
            if (!configData.Clans.Alliance.Enabled)
                return false;

            Clan clan = storedData.FindClanByID(player.Id);
            if (clan == null)
            {
                player.Reply(Message("Notification.Generic.NoClan", player.Id));
                return false;
            }

            Clan alliedClan = storedData.FindClan(tag);
            if (alliedClan == null)
            {
                player.Reply(string.Format(Message("Notification.Generic.InvalidClan", player.Id), tag));
                return false;
            }

            if (!clan.IsOwner(player.Id))
            {
                player.Reply(Message("Notification.Alliance.NoPermissions", player.Id));
                return false;
            }

            if (clan.AllianceInvites.ContainsKey(tag) && (UnixTimeStampUTC() - clan.AllianceInvites[tag] < configData.Clans.Invites.AllianceInviteExpireTime))
            {
                player.Reply(string.Format(Message("Notification.Alliance.PendingInvite", player.Id), tag));
                return false;
            }

            if (clan.AllianceInviteCount >= configData.Clans.Invites.AllianceInviteLimit)
            {
                player.Reply(Message("Notification.Alliance.MaximumInvites", player.Id));
                return false;
            }

            if (clan.AllianceCount >= configData.Clans.Alliance.AllianceLimit)
            {
                player.Reply(Message("Notification.Alliance.MaximumAlliances", player.Id));
                return false;
            }

            clan.AllianceInvites[tag] = UnixTimeStampUTC();
            alliedClan.IncomingAlliances.Add(clan.Tag);

            player.Reply(string.Format(Message("Notification.Alliance.InviteSent", player.Id), tag, FormatTime(configData.Clans.Invites.AllianceInviteExpireTime)));

            alliedClan.Broadcast("Notification.Alliance.InviteReceived", clan.Tag, FormatTime(configData.Clans.Invites.AllianceInviteExpireTime), "ally");

            return true;
        }

        [HookMethod("WithdrawAlliance")]
        public bool WithdrawAlliance(IPlayer player, string tag)
        {
            if (!configData.Clans.Alliance.Enabled)
                return false;

            Clan clan = storedData.FindClanByID(player.Id);
            if (clan == null)
            {
                player.Reply(Message("Notification.Generic.NoClan", player.Id));
                return false;
            }

            Clan alliedClan = storedData.FindClan(tag);
            if (alliedClan == null)
            {
                player.Reply(string.Format(Message("Notification.Generic.InvalidClan", player.Id), tag));
                return false;
            }

            if (!clan.IsOwner(player.Id))
            {
                player.Reply(Message("Notification.Alliance.NoPermissions", player.Id));
                return false;
            }

            if (!clan.AllianceInvites.ContainsKey(tag))
            {
                player.Reply(string.Format(Message("Notification.Alliance.NoActiveInvite", player.Id), tag));
                return false;
            }

            clan.AllianceInvites.Remove(tag);
            alliedClan.IncomingAlliances.Remove(clan.Tag);

            clan.Broadcast("Notification.Alliance.WithdrawnClan", player.Name, tag);
            alliedClan.Broadcast("Notification.Alliance.WithdrawnTarget", clan.Tag);

            clan.MarkDirty();

            return true;
        }

        [HookMethod("AcceptAlliance")]
        public bool AcceptAlliance(IPlayer player, string tag)
        {
            if (!configData.Clans.Alliance.Enabled)
                return false;

            Clan clan = storedData.FindClanByID(player.Id);
            if (clan == null)
            {
                player.Reply(Message("Notification.Generic.NoClan", player.Id));
                return false;
            }

            Clan alliedClan = storedData.FindClan(tag);
            if (alliedClan == null)
            {
                player.Reply(string.Format(Message("Notification.Generic.InvalidClan", player.Id), tag));
                return false;
            }

            if (!clan.IsOwner(player.Id))
            {
                player.Reply(Message("Notification.Alliance.NoPermissions", player.Id));
                return false;
            }

            bool noActiveInvite = !alliedClan.AllianceInvites.ContainsKey(clan.Tag);

            if ((UnixTimeStampUTC() - alliedClan.AllianceInvites[clan.Tag] > configData.Clans.Invites.AllianceInviteExpireTime))
            {
                alliedClan.AllianceInvites.Remove(clan.Tag);
                noActiveInvite = true;
            }

            if (noActiveInvite)
            {
                player.Reply(string.Format(Message("Notification.Alliance.NoActiveInviteFrom", player.Id), tag));
                return false;
            }

            if (alliedClan.AllianceCount >= configData.Clans.Alliance.AllianceLimit)
            {
                player.Reply(string.Format(Message("Notification.Alliance.AtLimitTarget", player.Id), tag));
                return false;
            }

            if (clan.AllianceCount >= configData.Clans.Alliance.AllianceLimit)
            {
                player.Reply(string.Format(Message("Notification.Alliance.AtLimitSelf", player.Id), tag));
                return false;
            }

            clan.Alliances.Add(tag);
            clan.IncomingAlliances.Remove(tag);

            alliedClan.Alliances.Add(clan.Tag);
            alliedClan.AllianceInvites.Remove(clan.Tag);

            clan.MarkDirty();
            alliedClan.MarkDirty();

            clan.Broadcast("Notification.Alliance.Formed", clan.Tag, alliedClan.Tag);
            alliedClan.Broadcast("Notification.Alliance.Formed", clan.Tag, alliedClan.Tag);

            Interface.Oxide.CallHook("OnClanUpdate", clan.Tag);
            Interface.Oxide.CallHook("OnClanUpdate", alliedClan.Tag);

            return true;
        }

        [HookMethod("RejectAlliance")]
        public bool RejectAlliance(IPlayer player, string tag)
        {
            if (!configData.Clans.Alliance.Enabled)
                return false;

            Clan clan = storedData.FindClanByID(player.Id);
            if (clan == null)
            {
                player.Reply(string.Format(Message("Notification.Generic.InvalidClan", player.Id), tag));
                return false;
            }

            Clan alliedClan = storedData.FindClan(tag);
            if (alliedClan == null)
            {
                player.Reply(Message("Notification.Generic.InvalidClan", player.Id));
                return false;
            }

            if (!clan.IsOwner(player.Id))
            {
                player.Reply(Message("Notification.Alliance.NoPermissions", player.Id));
                return false;
            }

            if (!alliedClan.AllianceInvites.ContainsKey(clan.Tag) || (UnixTimeStampUTC() - alliedClan.AllianceInvites[clan.Tag] > configData.Clans.Invites.AllianceInviteExpireTime))
            {
                player.Reply(string.Format(Message("Notification.Alliance.NoActiveInvite", player.Id), tag));
                return false;
            }

            clan.IncomingAlliances.Remove(tag);

            alliedClan.AllianceInvites.Remove(clan.Tag);
            alliedClan.MarkDirty();

            clan.Broadcast("Notification.Alliance.Rejected", clan.Tag, alliedClan.Tag);
            alliedClan.Broadcast("Notification.Alliance.Rejected", clan.Tag, alliedClan.Tag);

            return true;
        }

        [HookMethod("RevokeAlliance")]
        public bool RevokeAlliance(IPlayer player, string tag)
        {
            if (!configData.Clans.Alliance.Enabled)
                return false;

            Clan clan = storedData.FindClanByID(player.Id);
            if (clan == null)
            {
                player.Reply(string.Format(Message("Notification.Generic.InvalidClan", player.Id), tag));
                return false;
            }

            Clan alliedClan = storedData.FindClan(tag);
            if (alliedClan == null)
            {
                player.Reply(Message("Notification.Generic.InvalidClan", player.Id));
                return false;
            }

            if (!clan.IsOwner(player.Id))
            {
                player.Reply(Message("Notification.Alliance.NoPermissions", player.Id));
                return false;
            }

            if (!clan.Alliances.Contains(alliedClan.Tag))
            {
                player.Reply(string.Format(Message("Notification.Alliance.NoActiveAlliance", player.Id), alliedClan.Tag));
                return false;
            }

            alliedClan.Alliances.Remove(clan.Tag);
            clan.Alliances.Remove(alliedClan.Tag);

            alliedClan.MarkDirty();
            clan.MarkDirty();

            clan.Broadcast("Notification.Alliance.Revoked", clan.Tag, alliedClan.Tag);
            alliedClan.Broadcast("Notification.Alliance.Revoked", clan.Tag, alliedClan.Tag);

            return true;
        }
        #endregion

        #region Chat
        private void ClanChat(IPlayer player, string message)
        {
            if (player == null)
                return;

            Clan clan = storedData.FindClanByID(player.Id);
            if (clan == null)
                return;

            string str = string.Format(Message("Chat.Alliance.Format"), clan.Tag, clan.GetRoleColor(player.Id), player.Name, message);

            clan.Broadcast(string.Format(Message("Chat.Clan.Prefix"), str));

            Interface.CallHook("OnClanChat", player, message, clan.Tag);
        }

        private void AllianceChat(IPlayer player, string message)
        {
            Clan clan = storedData.FindClanByID(player.Id);
            if (clan == null)
                return;

            string str = string.Format(Message("Chat.Alliance.Format"), clan.Tag, clan.GetRoleColor(player.Id), player.Name, message);

            clan.Broadcast(string.Format(Message("Chat.Alliance.Prefix"), str));

            for (int i = 0; i < clan.AllianceCount; i++)
            {
                Clan alliedClan = storedData.FindClan(clan.Alliances.ElementAt(i));
                if (alliedClan != null)
                {
                    alliedClan.Broadcast(string.Format(Message("Chat.Alliance.Prefix"), str));
                }
            }

            Interface.CallHook("OnAllianceChat", player, message, clan.Tag);
        }
        #endregion

        #region Chat Commands
        [Command("a")]
        private void cmdAllianceChat(IPlayer player, string command, string[] args)
        {
            if (!configData.Clans.Alliance.Enabled || args?.Length == 0)
                return;

            AllianceChat(player, string.Join(" ", args));
        }

        [Command("c")]
        private void cmdClanChat(IPlayer player, string command, string[] args)
        {
            if (args?.Length == 0)
                return;

            ClanChat(player, string.Join(" ", args));
        }

        [Command("cinfo")]
        private void cmdChatClanInfo(IPlayer player, string command, string[] args)
        {            
            if (args?.Length == 0)
            {
                player.Reply(Message("Notification.Generic.SpecifyClanTag", player.Id));
                return;
            }

            Clan clan = storedData.FindClan(args[0]);
            if (clan == null)
            {
                player.Reply(string.Format(Message("Notification.Generic.InvalidClan", player.Id), args[0]));
                return;
            }

            clan.PrintClanInfo(player);
        }

        [Command("clanhelp")]
        private void cmdChatClanHelp(IPlayer player, string command, string[] args)
        {
            StringBuilder sb = new StringBuilder();

            Clan clan = storedData.FindClanByID(player.Id);
            if (clan == null)
            {
                sb.Append(Message("Notification.ClanInfo.Title", player.Id));
                sb.Append(string.Format(Message("Notification.ClanHelp.NoClan", player.Id), "clan"));
                player.Reply(sb.ToString());
                return;
            }

            sb.Append(Message("Notification.ClanInfo.Title", player.Id));
            sb.Append(string.Format(Message("Notification.ClanHelp.Basic", player.Id), "clan", "c"));

            if (clan.IsModerator(player.Id) || clan.OwnerID.Equals(player.Id))
            {
                if (configData.Clans.Alliance.Enabled && clan.OwnerID.Equals(player.Id))
                    sb.Append(string.Format(Message("Notification.ClanHelp.Alliance", player.Id), "ally"));

                sb.Append(string.Format(Message("Notification.ClanHelp.Moderator", player.Id), "clan"));
            }

            if (clan.OwnerID.Equals(player.Id))
            {
                sb.Append(string.Format(Message("Notification.ClanHelp.Owner", player.Id), "clan"));

                if (configData.Tags.CustomColors)
                    sb.Append(string.Format(Message("Notification.ClanHelp.TagColor", player.Id), "clan"));
            }

            player.Reply(sb.ToString());

        }

        [Command("ally")]
        private void cmdChatClanAlly(IPlayer player, string command, string[] args)
        {
            if (!configData.Clans.Alliance.Enabled)
                return;

            if (args?.Length < 2)
            {
                player.Reply(string.Format(Message("Notification.ClanHelp.Alliance", player.Id), "ally"));
                return;
            }

            string tag = args[1];

            switch (args[0].ToLower())
            {
                case "invite":
                    OfferAlliance(player, tag);
                    return;
                case "withdraw":
                    WithdrawAlliance(player, tag);
                    return;
                case "accept":
                    AcceptAlliance(player, tag);
                    return;
                case "reject":
                    RejectAlliance(player, tag);
                    return;
                case "revoke":
                    RevokeAlliance(player, tag);
                    return;
                default:
                    player.Reply(string.Format(Message("Notification.ClanHelp.Alliance", player.Id), "ally"));
                    return;
            }
        }

        [Command("clan")]
        private void cmdChatClan(IPlayer player, string command, string[] args)
        {
            Clan clan = storedData.FindClanByID(player.Id);

            if (args?.Length == 0)
            {
                StringBuilder sb = new StringBuilder();
                if (clan == null)
                {
                    sb.Append(Message("Notification.ClanInfo.Title", player.Id));
                    sb.Append(Message("Notification.Clan.NotInAClan", player.Id));
                    sb.Append(string.Format(Message("Notification.Clan.Help", player.Id), "clanhelp"));
                    player.Reply(sb.ToString());
                    sb.Clear();
                }
                else
                {
                    sb.Append(Message("Notification.ClanInfo.Title", player.Id));
                    sb.Append(string.Format(Message((clan.IsOwner(player.Id) ? "Notification.Clan.OwnerOf" : clan.IsModerator(player.Id) ? "Notification.Clan.ModeratorOf" : "Notification.Clan.MemberOf"), player.Id), clan.Tag, clan.OnlineCount, clan.MemberCount));
                    sb.Append(string.Format(Message("Notification.Clan.MembersOnline", player.Id), clan.GetMembersOnline()));

                    sb.Append(string.Format(Message("Notification.Clan.Help", player.Id), "clanhelp"));
                    player.Reply(sb.ToString());
                    sb.Clear();
                }
                return;
            }

            string tag = clan?.Tag ?? string.Empty;

            switch (args[0].ToLower())
            {
                case "create":
                    if (args.Length < 2)
                    {
                        player.Reply(string.Format(Message("Notification.Clan.CreateSyntax", player.Id), "clan"));
                        return;
                    }

                    CreateClan(player, args[1], args.Length > 2 ? string.Join(" ", args.Skip(2)) : string.Empty);
                    return;

                case "leave":
                    LeaveClan(player);
                    return;

                case "invite":
                    if (args.Length < 2)
                    {
                        player.Reply(string.Format(Message("Notification.Clan.InviteSyntax", player.Id), "clan"));
                        return;
                    }

                    IPlayer invitee = players.FindPlayer(args[1]);
                    if (invitee == null)
                    {
                        player.Reply(string.Format(Message("Notification.Generic.UnableToFindPlayer", player.Id), args[1]));
                        return;
                    }

                    if (invitee == player)
                    {
                        player.Reply(Message("Notification.Generic.CommandSelf", player.Id));
                        return;
                    }

                    InvitePlayer(player, invitee);
                    return;

                case "withdraw":
                    if (args.Length < 2)
                    {
                        player.Reply(string.Format(Message("Notification.Clan.WithdrawSyntax", player.Id), "clan"));
                        return;
                    }

                    WithdrawInvite(player, args[1]);
                    return;

                case "accept":
                    if (args.Length < 2)
                    {
                        player.Reply(string.Format(Message("Notification.Clan.AcceptSyntax", player.Id), "clan"));
                        return;
                    }

                    JoinClan(player, args[1]);
                    return;

                case "reject":
                    if (args.Length < 2)
                    {
                        player.Reply(string.Format(Message("Notification.Clan.RejectSyntax", player.Id), "clan"));
                        return;
                    }

                    RejectInvite(player, args[1]);
                    return;

                case "kick":
                    if (args.Length < 2)
                    {
                        player.Reply(string.Format(Message("Notification.Clan.KickSyntax", player.Id), "clan"));
                        return;
                    }

                    string target = clan.FindPlayer(args[1]);
                    if (string.IsNullOrEmpty(target))
                    {
                        player.Reply(Message("Notification.Kick.NoPlayerFound", player.Id));
                        return;
                    }

                    if (target == player.Id)
                    {
                        player.Reply(Message("Notification.Generic.CommandSelf", player.Id));
                        return;
                    }

                    KickPlayer(player, target);
                    return;

                case "promote":
                    if (args.Length < 2)
                    {
                        player.Reply(string.Format(Message("Notification.Clan.PromoteSyntax", player.Id), "clan"));
                        return;
                    }

                    string promotee = clan.FindPlayer(args[1]);
                    if (string.IsNullOrEmpty(promotee))
                    {
                        player.Reply(string.Format(Message("Notification.Generic.UnableToFindPlayer", player.Id), args[1]));
                        return;
                    }

                    if (promotee == player.Id)
                    {
                        player.Reply(Message("Notification.Generic.CommandSelf", player.Id));
                        return;
                    }

                    PromotePlayer(player, promotee);
                    return;

                case "demote":
                    if (args.Length < 2)
                    {
                        player.Reply(string.Format(Message("Notification.Clan.DemoteSyntax", player.Id), "clan"));
                        return;
                    }

                    string demotee = clan.FindPlayer(args[1]);
                    if (string.IsNullOrEmpty(demotee))
                    {
                        player.Reply(string.Format(Message("Notification.Generic.UnableToFindPlayer", player.Id), args[1]));
                        return;
                    }

                    if (demotee == player.Id)
                    {
                        player.Reply(Message("Notification.Generic.CommandSelf", player.Id));
                        return;
                    }

                    DemotePlayer(player, demotee);
                    return;

                case "disband":
                    if (args.Length < 2 || !args[1].Equals("forever", StringComparison.OrdinalIgnoreCase))
                    {
                        player.Reply(string.Format(Message("Notification.Clan.DisbandSyntax", player.Id), "clan"));
                        return;
                    }

                    if (clan == null)
                    {
                        player.Reply(Message("Notification.Generic.NoClan", player.Id));
                        return;
                    }

                    if (!clan.IsOwner(player.Id))
                    {
                        player.Reply(Message("Notification.Disband.NotOwner", player.Id));
                        return;
                    }

                    clan.Broadcast("Notification.Disband.Reply", Array.Empty<object>());
                    clan.DisbandClan();

                    player.Reply(string.Format(Message("Notification.Disband.Success", player.Id), tag));
                    return;

                case "tagcolor":
                    if (!configData.Tags.CustomColors)
                    {
                        player.Reply(Message("Notification.Clan.TagColorDisabled", player.Id));
                        return;
                    }

                    if (args.Length < 2)
                    {
                        player.Reply(string.Format(Message("Notification.Clan.TagColorSyntax", player.Id), "clan"));
                        return;
                    }

                    if (!clan.IsOwner(player.Id))
                    {
                        player.Reply(Message("Notification.Disband.NotOwner", player.Id));
                        return;
                    }

                    string hexColor = args[1].ToUpper();

                    if (hexColor.Equals("RESET"))
                    {
                        clan.TagColor = string.Empty;
                        player.Reply(Message("Notification.Clan.TagColorReset", player.Id));
                        return;
                    }

                    if (hexColor.Length < 6 || hexColor.Length > 6 || !hexFilter.IsMatch(hexColor))
                    {
                        player.Reply(Message("Notification.Clan.TagColorFormat", player.Id));
                        return;
                    }

                    clan.TagColor = hexColor;
                    player.Reply(string.Format(Message("Notification.Clan.TagColorSet", player.Id), clan.TagColor));
                    return;

                default:
                    player.Reply(string.Format(Message("Notification.Clan.Help", player.Id), "clanhelp"));
                    return;
            }
        }

        #endregion

        #region API       
        private JObject GetClan(string tag)
        {
            if (!string.IsNullOrEmpty(tag))
                return storedData.FindClan(tag)?.ToJObject();

            return null;
        }

        private JArray GetAllClans() => new JArray(storedData.clans.Keys);
        
        private string GetClanOf(string playerId) => storedData.FindClanByID(playerId)?.Tag ?? null;

        private string GetClanOf(ulong playerId) => GetClanOf(playerId.ToString());

        private string GetClanOf(IPlayer player) => GetClanOf(player?.Id ?? string.Empty);

        #if RUST
        private string GetClanOf(BasePlayer player) => GetClanOf(player?.UserIDString ?? string.Empty);
        #endif

        #if HURTWORLD
        private string GetClanOf(PlayerSession session) => GetClanOf(session?.SteamId ?? string.Empty);
        #endif

        private List<string> GetClanMembers(ulong playerId) => GetClanMembers(playerId.ToString());
        
        private List<string> GetClanMembers(string playerId) => storedData.FindClanByID(playerId)?.ClanMembers.Keys.ToList() ?? new List<string>();

        private object HasFriend(ulong ownerId, ulong playerId) => HasFriend(ownerId.ToString(), playerId.ToString());
        private object HasFriend(string ownerId, string playerId)
        {
            Clan clanOwner = storedData.FindClanByID(ownerId);
            if (clanOwner == null)
                return null;

            Clan clanFriend = storedData.FindClanByID(playerId);
            if (clanFriend == null)
                return null;

            return clanOwner.Tag.Equals(clanFriend.Tag);
        }

        private bool IsClanMember(ulong playerId, ulong otherId) => IsClanMember(playerId.ToString(), otherId.ToString());
        private bool IsClanMember(string playerId, string otherId)
        {
            Clan clanPlayer = storedData.FindClanByID(playerId);
            if (clanPlayer == null)
                return false;

            Clan clanOther = storedData.FindClanByID(otherId);
            if (clanOther == null)
                return false;

            return clanPlayer.Tag.Equals(clanOther.Tag);
        }

        private bool IsMemberOrAlly(ulong playerId, ulong otherId) => IsMemberOrAlly(playerId.ToString(), otherId.ToString());
        
        private bool IsMemberOrAlly(string playerId, string otherId)
        {
            Clan playerClan = storedData.FindClanByID(playerId);
            if (playerClan == null)
                return false;

            Clan otherClan = storedData.FindClanByID(otherId);
            if (otherClan == null)
                return false;

            if ((playerClan.Tag.Equals(otherClan.Tag)) || playerClan.Alliances.Contains(otherClan.Tag))
                return true;

            return false;
        }
        
        private bool IsAllyPlayer(ulong playerId, ulong otherId) => IsAllyPlayer(playerId.ToString(), otherId.ToString());
        
        private bool IsAllyPlayer(string playerId, string otherId)
        {
            Clan playerClan = storedData.FindClanByID(playerId);
            if (playerClan == null)
                return false;

            Clan otherClan = storedData.FindClanByID(otherId);
            if (otherClan == null)
                return false;

            if (playerClan.Alliances.Contains(otherClan.Tag))
                return true;

            return false;
        }

        private List<string> GetClanAlliances(ulong playerId) => GetClanAlliances(playerId.ToString());

        private List<string> GetClanAlliances(string playerId)
        {
            Clan clan = storedData.FindClanByID(playerId);
            if (clan == null)
                return new List<string>();

            return new List<string>(clan.Alliances);
        }
        #endregion

        #region Clan
        [Serializable]
        public class Clan
        {
            public string Tag { get; set; }

            public string Description { get; set; }

            public string OwnerID { get; set; }

            public double CreationTime { get; set; }

            public double LastOnlineTime { get; set; }

            public Hash<string, Member> ClanMembers { get; set; } = new Hash<string, Member>();

            public Hash<string, MemberInvite> MemberInvites { get; set; } = new Hash<string, MemberInvite>();

            public HashSet<string> Alliances { get; set; } = new HashSet<string>();

            public Hash<string, double> AllianceInvites { get; set; } = new Hash<string, double>();

            public HashSet<string> IncomingAlliances { get; set; } = new HashSet<string>();

            public string TagColor { get; set; } = string.Empty;

            [JsonIgnore]
            public int OnlineCount { get; private set; }

            [JsonIgnore]
            public int ModeratorCount => ClanMembers.Count(x => x.Value.Role == Member.MemberRole.Moderator);

            [JsonIgnore]
            public int MemberCount => ClanMembers.Count;

            [JsonIgnore]
            public int MemberInviteCount => MemberInvites.Count;

            [JsonIgnore]
            public int AllianceCount => Alliances.Count;

            [JsonIgnore]
            public int AllianceInviteCount => AllianceInvites.Count;

            public Clan() { }

            public Clan(IPlayer player, string tag, string description)
            {
                this.Tag = tag;
                this.Description = description;
                CreationTime = LastOnlineTime = UnixTimeStampUTC();
                OwnerID = player.Id;
                ClanMembers.Add(player.Id, new Member(Member.MemberRole.Owner, player.Name));
                OnPlayerConnected(player);
            }

            #region Connection
            internal void OnPlayerConnected(IPlayer player)
            {
                if (player == null)
                    return;

                Member member;
                if (ClanMembers.TryGetValue(player.Id, out member))
                {
                    member.Player = player;                    
                    LastOnlineTime = UnixTimeStampUTC();
                    OnlineCount++;
                }

                MarkDirty();
            }

            internal void OnPlayerDisconnected(IPlayer player)
            {
                if (player == null)
                    return;

                Member member;
                if (ClanMembers.TryGetValue(player.Id, out member))
                {                    
                    member.Player = null;
                    LastOnlineTime = UnixTimeStampUTC();
                    OnlineCount--;
                }

                MarkDirty();
            }
            #endregion

            #region Clan Management
            internal bool InvitePlayer(IPlayer inviter, IPlayer invitee)
            {
                if (!IsOwner(inviter.Id) && !IsModerator(inviter.Id))
                {
                    inviter.Reply(Message("Notification.Invite.NoPermissions", inviter.Id));
                    return false;
                }

                if (ClanMembers.ContainsKey(invitee.Id))
                {
                    inviter.Reply(string.Format(Message("Notification.Invite.IsMember", inviter.Id), invitee.Name));
                    return false;
                }

                if (MemberInvites.ContainsKey(invitee.Id))
                {
                    inviter.Reply(string.Format(Message("Notification.Invite.HasPending", inviter.Id), invitee.Name));
                    return false;
                }

                if (MemberCount >= configData.Clans.MemberLimit)
                {
                    inviter.Reply(Message("Notification.Generic.ClanFull", inviter.Id));
                    return false;
                }

                if (MemberInviteCount >= configData.Clans.Invites.MemberInviteLimit)
                {
                    inviter.Reply(Message("Notification.Invite.InviteLimit", inviter.Id));
                    return false;
                }

                MemberInvites[invitee.Id] = new MemberInvite(invitee);

                Instance.storedData.AddPlayerInvite(invitee.Id, Tag);

                invitee.Reply(string.Format(Message("Notification.Invite.SuccesTarget", invitee.Id), Tag, Description, "clan"));
                Broadcast("Notification.Invite.SuccessClan", inviter.Name, invitee.Name);

                if (configData.Options.LogChanges)
                    Instance.LogToFile(Instance.Title, $"{inviter.Name} invited {invitee.Name} to [{Tag}]", Instance);

                return true;
            }

            internal bool JoinClan(IPlayer player)
            {
                if (!MemberInvites.ContainsKey(player.Id))
                    return false;

                if ((UnixTimeStampUTC() - MemberInvites[player.Id].ExpiryTime > configData.Clans.Invites.AllianceInviteExpireTime))
                {
                    MemberInvites.Remove(player.Id);
                    player.Reply(string.Format(Message("Notification.Join.ExpiredInvite", player.Id), Tag));
                    return false;
                }

                if (MemberCount >= configData.Clans.MemberLimit)
                {
                    player.Reply(Message("Notification.Generic.ClanFull", player.Id));
                    return false;
                }

                Instance.storedData.OnInviteAccepted(player.Id, Tag);

                MemberInvites.Remove(player.Id);
                List<string> currentMembers = ClanMembers.Keys.ToList();

                ClanMembers.Add(player.Id, new Member(Member.MemberRole.Member, player.Name));

                Instance.storedData.RegisterPlayer(player.Id, Tag);

                OnPlayerConnected(player);

                Broadcast("Notification.Join.Reply", player.Name);

                Interface.Oxide.CallHook("OnClanMemberJoined", player.Id, Tag);
                Interface.Oxide.CallHook("OnClanMemberJoined", player.Id, currentMembers);

                #if RUST
                Interface.Oxide.CallHook("OnClanMemberJoined", ulong.Parse(player.Id), Tag);
                Interface.Oxide.CallHook("OnClanMemberJoined", ulong.Parse(player.Id), currentMembers.ConvertAll(x => ulong.Parse(x)));
                #endif
                
                Interface.Oxide.CallHook("OnClanUpdate", Tag);

                if (configData.Options.LogChanges)
                    Instance.LogToFile(Instance.Title, $"{player.Name} joined [{Tag}]", Instance);

                return true;
            }

            internal bool LeaveClan(IPlayer player)
            {
                if (!ClanMembers.ContainsKey(player.Id))
                    return false;

                OnPlayerDisconnected(player);

                ClanMembers.Remove(player.Id);
                Instance.storedData.UnregisterPlayer(player.Id);

                player.Reply(string.Format(Message("Notification.Leave.PlayerMessage", player.Id), Tag));
                Broadcast("Notification.Leave.Reply", player.Name);

                MarkDirty();

                if (ClanMembers.Count == 0)
                {
                    Interface.Oxide.CallHook("OnClanMemberGone", player.Id, Tag);
                    Interface.Oxide.CallHook("OnClanMemberGone", player.Id, new List<string>());
                    
                    #if RUST
                    Interface.Oxide.CallHook("OnClanMemberGone", ulong.Parse(player.Id), Tag);
                    Interface.Oxide.CallHook("OnClanMemberGone", ulong.Parse(player.Id), new List<ulong>());
                    #endif

                    if (configData.Options.LogChanges)
                        Instance.LogToFile(Instance.Title, $"{player.Name} has left [{Tag}]", Instance);

                    DisbandClan();
                    return true;
                }

                if (OwnerID == player.Id)
                {
                    KeyValuePair<string, Member> newOwner = ClanMembers.OrderBy(x => x.Value.Role).First();

                    OwnerID = newOwner.Key;
                    ClanMembers[OwnerID].Role = Member.MemberRole.Owner;

                    Broadcast("Notification.Leave.NewOwner", ClanMembers[OwnerID].DisplayName);
                }
                
                List<string> members = ClanMembers.Keys.ToList();
                #if RUST
                Interface.Oxide.CallHook("OnClanMemberGone", ulong.Parse(player.Id), members.ConvertAll(x => ulong.Parse(x)));
                Interface.Oxide.CallHook("OnClanMemberGone", ulong.Parse(player.Id), Tag);
                #endif

                Interface.Oxide.CallHook("OnClanMemberGone", player.Id, members);
                Interface.Oxide.CallHook("OnClanMemberGone", player.Id, Tag);
                Interface.Oxide.CallHook("OnClanUpdate", Tag);

                if (configData.Options.LogChanges)
                    Instance.LogToFile(Instance.Title, $"{player.Name} has left [{Tag}]", Instance);
                
                return true;
            }

            internal bool KickMember(IPlayer player, string targetId)
            {
                if (!ClanMembers.ContainsKey(targetId))
                {
                    player.Reply(Message("Notification.Kick.NotClanmember", player.Id));
                    return false;
                }

                if (IsOwner(targetId))
                {
                    player.Reply(Message("Notification.Kick.IsOwner", player.Id));
                    return false;
                }

                if (!IsOwner(player.Id) && !IsModerator(player.Id))
                {
                    player.Reply(Message("Notification.Kick.NoPermissions", player.Id));
                    return false;
                }

                if ((IsOwner(targetId) || IsModerator(targetId)) && OwnerID != player.Id)
                {
                    player.Reply(Message("Notification.Kick.NotEnoughRank", player.Id));
                    return false;
                }

                Member member = ClanMembers[targetId];

                if (member.IsConnected && member.Player != null)
                {
                    member.Player.Reply(string.Format(Message("Notification.Kick.PlayerMessage", member.Player.Id), player.Name));

                    OnPlayerDisconnected(member.Player);
                }

                ClanMembers.Remove(targetId);
                Instance.storedData.UnregisterPlayer(targetId);

                Broadcast("Notification.Kick.Reply", player.Name, member.DisplayName);

                List<string> members = ClanMembers.Keys.ToList();
                
                #if RUST
                Interface.Oxide.CallHook("OnClanMemberGone", ulong.Parse(targetId), members.ConvertAll(x => ulong.Parse(x)));
                Interface.Oxide.CallHook("OnClanMemberGone", ulong.Parse(targetId), Tag);
                #endif
                
                Interface.Oxide.CallHook("OnClanMemberGone", targetId, members);
                Interface.Oxide.CallHook("OnClanMemberGone", targetId, Tag);
                Interface.Oxide.CallHook("OnClanUpdate", Tag);

                if (configData.Options.LogChanges)
                    Instance.LogToFile(Instance.Title, $"{member.DisplayName} was kicked from [{Tag}] by {player.Name}", Instance);

                return true;
            }

            internal bool PromotePlayer(IPlayer promoter, string targetId)
            {
                if (!IsOwner(promoter.Id))
                {
                    promoter.Reply(Message("Notification.Promotion.NoPermissions", promoter.Id));
                    return false;
                }

                if (IsOwner(targetId))
                {
                    promoter.Reply(Message("Notification.Promotion.IsOwner", promoter.Id));
                    return false;
                }

                if (IsModerator(targetId))
                {
                    promoter.Reply(Message("Notification.Promotion.IsModerator", promoter.Id));
                    return false;
                }

                if (IsMember(targetId) && ModeratorCount >= configData.Clans.ModeratorLimit)
                {
                    promoter.Reply(Message("Notification.Promotion.ModeratorLimit", promoter.Id));
                    return false;
                }

                Member member = ClanMembers[targetId];
                member.Role = (Member.MemberRole)(Math.Min((int)member.Role - 1, (int)Member.MemberRole.Member));

                MarkDirty();

                Broadcast("Notification.Promotion.Reply", member.DisplayName, string.Format(COLORED_LABEL, GetRoleColor(member.Role), member.Role), string.Format(COLORED_LABEL, GetRoleColor(promoter.Id), promoter.Name));
                Interface.Oxide.CallHook("OnClanUpdate", Tag);

                if (configData.Options.LogChanges)
                    Instance.LogToFile(Instance.Title, $"{member.DisplayName} was promototed to {member.Role} by {promoter.Name}", Instance);

                return true;
            }

            internal bool DemotePlayer(IPlayer demoter, string targetId)
            {
                if (!IsOwner(demoter.Id))
                {
                    demoter.Reply(Message("Notification.Demotion.NoPermissions", demoter.Id));
                    return false;
                }

                Member member = ClanMembers[targetId];
                if (IsMember(targetId))
                {
                    demoter.Reply(string.Format(Message("Notification.Demotion.IsMember", demoter.Id), member.DisplayName));
                    return false;
                }

                member.Role = member.Role + 1;

                MarkDirty();

                Broadcast("Notification.Demotion.Reply", member.DisplayName, string.Format(COLORED_LABEL, GetRoleColor(member.Role), member.Role), string.Format(COLORED_LABEL, GetRoleColor(demoter.Id), demoter.Name));

                Interface.Oxide.CallHook("OnClanUpdate", Tag);

                if (configData.Options.LogChanges)
                    Instance.LogToFile(Instance.Title, $"{member.DisplayName} was demoted to {member.Role} by {demoter.Name}", Instance);
                return true;
            }

            internal void DisbandClan()
            {
                List<string> clanMembers = ClanMembers.Keys.ToList();

                OnUnload();

                Instance.storedData.clans.Remove(Tag);

                foreach (KeyValuePair<string, Clan> kvp in Instance.storedData.clans)
                    kvp.Value.OnClanDisbanded(Tag);

                if (configData.Options.LogChanges)
                    Instance.LogToFile(Instance.Title, $"The clan [{Tag}] was disbanded", Instance);

                #if RUST
                Interface.CallHook("OnClanDisbanded", clanMembers.ConvertAll(x => ulong.Parse(x)));
                #endif
                Interface.CallHook("OnClanDisbanded", clanMembers);
                Interface.CallHook("OnClanDisbanded", Tag);
            }

            internal void OnClanDisbanded(string tag)
            {
                Alliances.Remove(tag);
                AllianceInvites.Remove(tag);
                IncomingAlliances.Remove(tag);
            }

            internal void OnUnload()
            {
                foreach (KeyValuePair<string, Member> kvp in ClanMembers)
                {
                    Instance.storedData.UnregisterPlayer(kvp.Key);

                    if (kvp.Value.Player != null)
                        OnPlayerDisconnected(kvp.Value.Player);
                }
            }

            internal bool IsAlliedClan(string otherClan) => Alliances.Contains(otherClan);

            internal void MarkDirty()
            {
                cachedClanInfo = string.Empty;
                membersOnline = string.Empty;
                serializedClanObject = null;
            }
            #endregion

            #region Clan Chat
            internal void Broadcast(string message)
            {
                foreach (Member member in ClanMembers.Values)
                    member.Player?.Reply(message);
            }

            internal void Broadcast(string key, params object[] args)
            {
                foreach (Member member in ClanMembers.Values)
                    member.Player?.Reply(string.Format(Message(key, member.Player.Id), args));
            }
            #endregion

            #region Clan Info
            [JsonIgnore]
            private string cachedClanInfo = string.Empty;

            [JsonIgnore]
            private string membersOnline = string.Empty;

            #if RUST
            internal void PrintClanInfo(BasePlayer player) => PrintClanInfo(player.IPlayer);
            #endif
            internal void PrintClanInfo(IPlayer player)
            {
                if (string.IsNullOrEmpty(cachedClanInfo))
                {
                    StringBuilder str = new StringBuilder();
                    str.Append(Message("Notification.ClanInfo.Title"));
                    str.Append(string.Format(Message("Notification.ClanInfo.Tag"), Tag));

                    if (!string.IsNullOrEmpty(Description))
                        str.Append(string.Format(Message("Notification.ClanInfo.Description"), Description));

                    List<string> online = ListPool.Get<string>();
                    List<string> offline = ListPool.Get<string>();

                    foreach (KeyValuePair<string, Member> kvp in ClanMembers)
                    {
                        string member = string.Format(COLORED_LABEL, GetRoleColor(kvp.Key), kvp.Value.DisplayName);

                        if (kvp.Value.IsConnected)
                            online.Add(member);
                        else offline.Add(member);
                    }

                    if (online.Count > 0)
                        str.Append(string.Format(Message("Notification.ClanInfo.Online"), online.ToSentence()));

                    if (offline.Count > 0)
                        str.Append(string.Format(Message("Notification.ClanInfo.Offline"), offline.ToSentence()));

                    ListPool.Free(ref online);
                    ListPool.Free(ref offline);

                    str.Append(string.Format(Message("Notification.ClanInfo.Established"), UnixTimeStampToDateTime(CreationTime)));
                    str.Append(string.Format(Message("Notification.ClanInfo.LastOnline"), UnixTimeStampToDateTime(LastOnlineTime)));

                    if (configData.Clans.Alliance.Enabled)
                        str.Append(string.Format(Message("Notification.ClanInfo.Alliances"), Alliances.Count > 0 ? Alliances.ToSentence() : Message("Notification.ClanInfo.Alliances.None")));

                    cachedClanInfo = str.ToString();
                }

                player.Reply(cachedClanInfo);
            }

            internal string GetMembersOnline()
            {
                if (string.IsNullOrEmpty(membersOnline))
                {
                    List<string> list = ListPool.Get<string>();

                    foreach (KeyValuePair<string, Member> kvp in ClanMembers)
                    {
                        if (kvp.Value.IsConnected)
                        {
                            string member = string.Format(COLORED_LABEL, GetRoleColor(kvp.Key), kvp.Value.DisplayName);
                            list.Add(member);
                        }
                    }

                    membersOnline = list.ToSentence();

                    ListPool.Free(ref list);
                }
                return membersOnline;
            }
            #endregion

            #region Roles
            public bool IsOwner(ulong playerId) => IsOwner(playerId.ToString());

            public bool IsOwner(string playerId) => ClanMembers[playerId].Role == Member.MemberRole.Owner;

            public bool IsModerator(ulong playerId) => IsModerator(playerId.ToString());

            public bool IsModerator(string playerId) => ClanMembers[playerId].Role == Member.MemberRole.Moderator;

            public bool IsCouncil(ulong playerId) => false;

            public bool IsMember(ulong playerId) => IsMember(playerId.ToString());

            public bool IsMember(string playerId) => ClanMembers[playerId].Role == Member.MemberRole.Member;

            public Member GetOwner() => ClanMembers[OwnerID];

            public string GetRoleColor(string Id) => GetRoleColor(ClanMembers[Id].Role);

            public string GetRoleColor(Member.MemberRole role)
            {
                if (role == Member.MemberRole.Owner)
                    return configData.Colors.Owner;

                if (role == Member.MemberRole.Moderator)
                    return configData.Colors.Moderator;

                return configData.Colors.Member;
            }
            #endregion

            [Serializable]
            public class Member
            {
                [JsonIgnore]
                public IPlayer Player { get; set; }

                [JsonProperty("Name")]
                public string DisplayName { get; set; } = string.Empty;

                public MemberRole Role { get; set; }

                [JsonIgnore]
                public bool IsConnected => Player?.IsConnected ?? false;

                [JsonIgnore]
                public bool MemberFFEnabled { get; set; } = false;

                [JsonIgnore]
                public bool AllyFFEnabled { get; set; } = false;

                public Member() { }

                public Member(MemberRole role, string name)
                {
                    this.Role = role;
                    this.DisplayName = name;
                }

                public enum MemberRole { Owner, Moderator, Member }
            }

            [Serializable]
            public class MemberInvite
            {
                [JsonProperty("Name")]
                public string DisplayName { get; set; }

                public double ExpiryTime { get; set; }

                public MemberInvite() { }

                public MemberInvite(IPlayer player)
                {
                    DisplayName = player.Name;
                    ExpiryTime = UnixTimeStampUTC();
                }

                public MemberInvite(string name)
                {
                    DisplayName = name;
                    ExpiryTime = UnixTimeStampUTC();
                }
            }

            [JsonIgnore]
            private JObject serializedClanObject;

            internal JObject ToJObject()
            {
                if (serializedClanObject != null)
                    return serializedClanObject;

                serializedClanObject = new JObject();
                serializedClanObject["tag"] = Tag;
                serializedClanObject["description"] = Description;
                serializedClanObject["owner"] = OwnerID;

                JArray jmoderators = new JArray();
                JArray jmembers = new JArray();

                foreach (KeyValuePair<string, Member> kvp in ClanMembers)
                {
                    if (kvp.Value.Role == Member.MemberRole.Moderator)
                        jmoderators.Add(kvp.Key);

                    jmembers.Add(kvp.Key);
                }

                serializedClanObject["moderators"] = jmoderators;
                serializedClanObject["members"] = jmembers;

                JArray jallies = new JArray();

                foreach (string ally in Alliances)
                    jallies.Add(ally);

                serializedClanObject["allies"] = jallies;

                JArray jinvallies = new JArray();

                foreach (KeyValuePair<string, double> ally in AllianceInvites)
                    jinvallies.Add(ally.Key);

                serializedClanObject["invitedallies"] = jinvallies;

                return serializedClanObject;
            }

            internal string FindPlayer(string partialNameOrID)
            {
                foreach (KeyValuePair<string, Member> kvp in ClanMembers)
                {
                    if (kvp.Key.Equals(partialNameOrID))
                        return kvp.Key;

                    if (kvp.Value.DisplayName.Contains(partialNameOrID, CompareOptions.OrdinalIgnoreCase))
                        return kvp.Key;
                }

                return string.Empty;
            }
        }
        #endregion

        #region Config        
        public static ConfigData configData;

        public class ConfigData
        {
            [JsonProperty(PropertyName = "Clan Options")]
            public ClanOptions Clans { get; set; }

            [JsonProperty(PropertyName = "Role Colors")]
            public ColorOptions Colors { get; set; }

            [JsonProperty(PropertyName = "Clan Tag Options")]
            public TagOptions Tags { get; set; }

            [JsonProperty(PropertyName = "Purge Options")]
            public PurgeOptions Purge { get; set; }

            [JsonProperty(PropertyName = "Settings")]
            public OtherOptions Options { get; set; }

            public class ClanOptions
            {
                [JsonProperty(PropertyName = "Member limit")]
                public int MemberLimit { get; set; }

                [JsonProperty(PropertyName = "Moderator limit")]
                public int ModeratorLimit { get; set; }

                [JsonProperty(PropertyName = "Alliance Options")]
                public AllianceOptions Alliance { get; set; }

                [JsonProperty(PropertyName = "Invite Options")]
                public InviteOptions Invites { get; set; }

                [JsonIgnore]
                public bool MemberFF => false;

                [JsonIgnore]
                public bool OwnerFF => false;

                public class AllianceOptions
                {
                    [JsonProperty(PropertyName = "Enable clan alliances")]
                    public bool Enabled { get; set; }

                    [JsonProperty(PropertyName = "Alliance limit")]
                    public int AllianceLimit { get; set; }

                    [JsonIgnore]
                    public bool AllyFF => false;

                    [JsonIgnore]
                    public bool OwnerFF => false;

                }

                public class InviteOptions
                {
                    [JsonProperty(PropertyName = "Maximum allowed member invites at any given time")]
                    public int MemberInviteLimit { get; set; }

                    [JsonProperty(PropertyName = "Member invite expiry time (seconds)")]
                    public int MemberInviteExpireTime { get; set; }

                    [JsonProperty(PropertyName = "Maximum allowed alliance invites at any given time")]
                    public int AllianceInviteLimit { get; set; }

                    [JsonProperty(PropertyName = "Alliance invite expiry time (seconds)")]
                    public int AllianceInviteExpireTime { get; set; }
                }
            }

            public class ColorOptions
            {
                [JsonProperty(PropertyName = "Clan owner color (hex)")]
                public string Owner { get; set; }

                [JsonProperty(PropertyName = "Clan moderator color (hex)")]
                public string Moderator { get; set; }

                [JsonProperty(PropertyName = "Clan member color (hex)")]
                public string Member { get; set; }

                [JsonProperty(PropertyName = "General text color (hex)")]
                public string TextColor { get; set; }
            }

            public class TagOptions
            {
                [JsonProperty(PropertyName = "Enable clan tags (requires BetterChat)")]
                public bool Enabled { get; set; }

                [JsonProperty(PropertyName = "Tag opening character")]
                public string TagOpen { get; set; }

                [JsonProperty(PropertyName = "Tag closing character")]
                public string TagClose { get; set; }

                [JsonProperty(PropertyName = "Tag color (hex)")]
                public string TagColor { get; set; }

                [JsonProperty(PropertyName = "Allow clan leaders to set custom tag colors (BetterChat only)")]
                public bool CustomColors { get; set; }

                [JsonProperty(PropertyName = "Tag size")]
                public int TagSize { get; set; }

                [JsonProperty(PropertyName = "Tag character limits")]
                public Range TagLength { get; set; }
            }

            public class PurgeOptions
            {
                [JsonProperty(PropertyName = "Enable clan purging")]
                public bool Enabled { get; set; }

                [JsonProperty(PropertyName = "Purge clans that havent been online for x amount of day")]
                public int OlderThanDays { get; set; }

                [JsonProperty(PropertyName = "List purged clans in console when purging")]
                public bool ListPurgedClans { get; set; }
            }

            public class OtherOptions
            {
                [JsonProperty(PropertyName = "Log clan and member changes")]
                public bool LogChanges { get; set; }

                [JsonProperty(PropertyName = "Data save interval (seconds)")]
                public int SaveInterval { get; set; }
            }

            public class Range
            {
                public int Minimum { get; set; }
                public int Maximum { get; set; }

                public Range() { }

                public Range(int minimum, int maximum)
                {
                    this.Minimum = minimum;
                    this.Maximum = maximum;
                }
            }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Clans = new ConfigData.ClanOptions
                {
                    Alliance = new ConfigData.ClanOptions.AllianceOptions
                    {
                        AllianceLimit = 2,                        
                        Enabled = true
                    },
                    Invites = new ConfigData.ClanOptions.InviteOptions
                    {
                        AllianceInviteExpireTime = 86400,
                        AllianceInviteLimit = 2,
                        MemberInviteExpireTime = 86400,
                        MemberInviteLimit = 8
                    },                   
                    MemberLimit = 8,
                    ModeratorLimit = 2,                    
                },
                Colors = new ConfigData.ColorOptions
                {
                    Member = "#fcf5cb",
                    Moderator = "#74c6ff",
                    Owner = "#a1ff46",
                    TextColor = "#e0e0e0"
                },                
                Options = new ConfigData.OtherOptions
                {
                    LogChanges = false,
                    SaveInterval = 900,
                },               
                Purge = new ConfigData.PurgeOptions
                {
                    Enabled = true,
                    ListPurgedClans = true,
                    OlderThanDays = 14,
                },
                Tags = new ConfigData.TagOptions
                {                    
                    CustomColors = false,
                    Enabled = true,
                    TagClose = "]",
                    TagColor = "#aaff55",
                    TagLength = new ConfigData.Range(2, 5),
                    TagOpen = "[",
                    TagSize = 15,
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new VersionNumber(0, 2, 0))
                configData = baseConfig;

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion

        #region Data Management
        public StoredData storedData;

        private DynamicConfigFile data;

        private void TimedSaveData()
        {
            timer.In(configData.Options.SaveInterval, () =>
            {
                SaveData();
                TimedSaveData();
            });
        }

        private void SaveData() => data.WriteObject(storedData);

        private void LoadData()
        {
            if (!Interface.Oxide.DataFileSystem.ExistsDatafile("clan_data") && Interface.Oxide.DataFileSystem.ExistsDatafile("clans_data"))
            {
                DynamicConfigFile oldData = Interface.Oxide.DataFileSystem.GetFile("clans_data");

                Dictionary<string, OldClan> clanData = oldData.ReadObject<Dictionary<string, OldClan>>();
                if (clanData != null && clanData.Count > 0)
                    RestoreClanData(clanData);
            }
            else
            {
                data = Interface.Oxide.DataFileSystem.GetFile("clan_data");
                storedData = data.ReadObject<StoredData>();
                
                if (storedData == null)
                    storedData = new StoredData();
            }
        }

        private void RestoreClanData(Dictionary<string, OldClan> clanData)
        {
            data = Interface.Oxide.DataFileSystem.GetFile("clan_data");
            storedData = new StoredData();

            foreach (KeyValuePair<string, OldClan> kvp in clanData)
            {
                Clan clan = storedData.clans[kvp.Key] = new Clan();

                clan.Tag = kvp.Key;
                clan.OwnerID = kvp.Value.ownerID;
                clan.CreationTime = clan.LastOnlineTime = UnixTimeStampUTC();

                foreach (KeyValuePair<string, string> memberKVP in kvp.Value.members)
                {
                    Clan.Member.MemberRole role = kvp.Value.ownerID == memberKVP.Key ? Clan.Member.MemberRole.Owner :
                                                  kvp.Value.moderators.Contains(memberKVP.Key) ? Clan.Member.MemberRole.Moderator :
                                                  Clan.Member.MemberRole.Member;

                    clan.ClanMembers[memberKVP.Key] = new Clan.Member(role, memberKVP.Value);
                }

                foreach(string alliance in kvp.Value.clanAlliances)
                    clan.Alliances.Add(alliance);

                foreach (string allianceInvite in kvp.Value.invitedAllies)
                    clan.AllianceInvites[allianceInvite] = UnixTimeStampUTC();

                foreach (KeyValuePair<string, string> memberInvite in kvp.Value.invitedPlayers)
                {
                    clan.MemberInvites[memberInvite.Key] = new Clan.MemberInvite(memberInvite.Value);
                    storedData.AddPlayerInvite(memberInvite.Key, clan.Tag);
                }

                foreach (string incomingAlliance in kvp.Value.pendingInvites)
                    clan.IncomingAlliances.Add(incomingAlliance);
            }

            SaveData();
        }

        [Serializable]
        public class StoredData
        {
            public Hash<string, Clan> clans = new Hash<string, Clan>();

            public Hash<string, List<string>> playerInvites = new Hash<string, List<string>>();

            [JsonIgnore]
            private Hash<string, string> playerLookup = new Hash<string, string>();

            public Clan FindClan(string tag)
            {
                Clan clan;
                if (clans.TryGetValue(tag, out clan))
                    return clan;

                string lower = tag.ToLower();

                foreach (KeyValuePair<string, Clan> kvp in clans)
                {
                    if (kvp.Key.ToLower().Equals(lower))
                        return kvp.Value;
                }

                return null;
            }

            public Clan FindClanByID(ulong playerId) => FindClanByID(playerId.ToString());

            public Clan FindClanByID(string playerId)
            {
                string tag;
                if (!playerLookup.TryGetValue(playerId, out tag))
                    return null;

                return FindClan(tag);
            }

            public Clan.Member FindMemberByID(ulong playerId) => FindMemberByID(playerId.ToString());

            public Clan.Member FindMemberByID(string playerId)
            {
                Clan.Member member = null;
                FindClanByID(playerId)?.ClanMembers.TryGetValue(playerId, out member);
                return member;
            }

            internal void RegisterPlayer(string playerId, string tag) => playerLookup[playerId] = tag;

            internal void UnregisterPlayer(string playerId) => playerLookup.Remove(playerId);

            internal void AddPlayerInvite(string target, string tag)
            {
                List<string> invites;
                if (!playerInvites.TryGetValue(target, out invites))
                    invites = playerInvites[target] = new List<string>();

                if (!invites.Contains(tag))
                    invites.Add(tag);
            }

            internal void RevokePlayerInvite(string target, string tag)
            {
                List<string> invites;
                if (!playerInvites.TryGetValue(target, out invites))
                    return;

                invites.Remove(tag);

                if (invites.Count == 0)
                    playerInvites.Remove(target);
            }

            internal void OnInviteAccepted(string target, string tag)
            {
                List<string> invites;
                if (!playerInvites.TryGetValue(target, out invites))
                    return;

                for (int i = invites.Count - 1; i >= 0; i--)
                {
                    string t = invites[i];

                    if (!t.Equals(tag))
                        FindClan(t)?.MemberInvites.Remove(target);

                    invites.RemoveAt(i);
                }

                if (invites.Count == 0)
                    playerInvites.Remove(target);
            }

            internal void OnInviteRejected(string target, string tag)
            {
                List<string> invites;
                if (!playerInvites.TryGetValue(target, out invites))
                    return;

                invites.Remove(tag);

                if (invites.Count == 0)
                    playerInvites.Remove(target);
            }
        }
        #endregion

        #region Data Conversion
        public class OldClan
        {
            public string clanTag = string.Empty;
            public string ownerID = string.Empty;

            public List<string> moderators = new List<string>();
            public Dictionary<string, string> members = new Dictionary<string, string>();
            public List<string> clanAlliances = new List<string>();

            public Dictionary<string, string> invitedPlayers = new Dictionary<string, string>();
            public List<string> invitedAllies = new List<string>();
            public List<string> pendingInvites = new List<string>();
        }
        #endregion

        #region Localization
        private static string Message(string key, string playerId = null) => string.Format(COLORED_LABEL, configData.Colors.TextColor, Instance.lang.GetMessage(key, Instance, playerId));

        private readonly Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["Notification.ClanInfo.Title"] = "[#ffa500]Clans[/#]",
            ["Notification.ClanInfo.Tag"] = "\nClanTag: [#b2eece]{0}[/#]",
            ["Notification.ClanInfo.Description"] = "\nDescription: [#b2eece]{0}[/#]",
            ["Notification.ClanInfo.Online"] = "\nMembers Online: {0}",
            ["Notification.ClanInfo.Offline"] = "\nMembers Offline: {0}",
            ["Notification.ClanInfo.Established"] = "\nEstablished: [#b2eece]{0}[/#]",
            ["Notification.ClanInfo.LastOnline"] = "\nLast Online: [#b2eece]{0}[/#]",
            ["Notification.ClanInfo.Alliances"] = "\nAlliances: [#b2eece]{0}[/#]",
            ["Notification.ClanInfo.Alliances.None"] = "None",

            ["Notification.Create.InExistingClan"] = "You are already a member of a clan",
            ["Notification.Create.NoPermission"] = "You do not have permission to create a clan",
            ["Notification.Create.InvalidTagLength"] = "The tag you have chosen is invalid. It must be between {0} and {1} characters long",
            ["Notification.Create.ClanExists"] = "A clan with that tag already exists",
            ["Notification.Create.Success"] = "You have formed the clan [#aaff55][{0}][/#]",

            ["Notification.Kick.IsOwner"] = "You can not kick the clan owner",
            ["Notification.Kick.NoPermissions"] = "You do not have sufficient permission to kick clan members",
            ["Notification.Kick.NotClanmember"] = "The target is not a member of your clan",
            ["Notification.Kick.Self"] = "You can not kick yourself",
            ["Notification.Kick.NotEnoughRank"] = "Only the clan owner can kick another ranking member",
            ["Notification.Kick.NoPlayerFound"] = "Unable to find a player with the specified name of ID",
            ["Notification.Kick.Reply"] = "{0} kicked {1} from the clan!",
            ["Notification.Kick.PlayerMessage"] = "{0} kicked you from the clan!",
            ["Notification.Kick.NoPermission"] = "You do not have permission to kick clan members",

            ["Notification.Leave.Reply"] = "{0} has left the clan!",
            ["Notification.Leave.PlayerMessage"] = "You have left the clan [#aaff55][{0}][/#]!",
            ["Notification.Leave.NewOwner"] = "{0} is now the clan leader!",
            ["Notification.Leave.NoPermission"] = "You do not have permission to leave this clan",

            ["Notification.Join.NoPermission"] = "You do not have permission to join a clan",
            ["Notification.Join.ExpiredInvite"] = "Your invite to {0} has expired!",
            ["Notification.Join.InExistingClan"] = "You are already a member of another clan",
            ["Notification.Join.Reply"] = "{0} has joined the clan!",

            ["Notification.Invite.NoPermissions"] = "You do not have sufficient permissions to invite other players",
            ["Notification.Invite.InviteLimit"] = "You already have the maximum number of invites allowed",
            ["Notification.Invite.HasPending"] = "{0} all ready has a pending clan invite",
            ["Notification.Invite.IsMember"] = "{0} is already a clan member",
            ["Notification.Invite.InClan"] = "{0} is already a member of another clan",
            ["Notification.Invite.NoPermission"] = "{0} does not have the required permission to join a clan",
            ["Notification.Invite.SuccesTarget"] = "You have been invited to join the clan: [#aaff55][{0}][/#] '{1}'\nTo join, type: [#ffd479]/{2} accept {0}[/#]",
            ["Notification.Invite.SuccessClan"] = "{0} has invited {1} to join the clan",
            ["Notification.PendingInvites"] = "You have pending clan invites from: {0}\nYou can join a clan type: [#ffd479]/{1} accept <tag>[/#]",

            ["Notification.WithdrawInvite.NoPermissions"] = "You do not have sufficient permissions to withdraw member invites",
            ["Notification.WithdrawInvite.UnableToFind"] = "Unable to find a invite for the player with {0}",
            ["Notification.WithdrawInvite.Success"] = "{0} revoked the member invitation for {0}",

            ["Notification.RejectInvite.InvalidInvite"] = "You do not have a invite to join [#aaff55][{0}][/#]",
            ["Notification.RejectInvite.Reply"] = "{0} has rejected their invition to join your clan",
            ["Notification.RejectInvite.PlayerMessage"] = "You have rejected the invitation to join [#aaff55][{0}][/#]",

            ["Notification.Promotion.NoPermissions"] = "You do not have sufficient permissions to promote other players",
            ["Notification.Promotion.TargetNoClan"] = "{0} is not a member of your clan",
            ["Notification.Promotion.IsOwner"] = "You can not promote the clan leader",          
            ["Notification.Promotion.ModeratorLimit"] = "You already have the maximum amount of moderators",
            ["Notification.Promotion.IsModerator"] = "You can not promote higher than the rank of moderator",
            ["Notification.Promotion.Reply"] = "{0} was promoted to rank of {1} by {2}",

            ["Notification.Demotion.NoPermissions"] = "You do not have sufficient permissions to demote other players",
            ["Notification.Demotion.IsOwner"] = "You can not demote the clan leader",
            ["Notification.Demotion.IsMember"] = "{0} is already at the lowest rank",
            ["Notification.Demotion.Reply"] = "{0} was demoted to rank of {1} by {2}",

            ["Notification.Alliance.NoPermissions"] = "You do not have sufficient permissions to manage alliances",
            ["Notification.Alliance.PendingInvite"] = "[#aaff55][{0}][/#] already has a pending alliance invite",
            ["Notification.Alliance.MaximumInvites"] = "You already have the maximum amount of alliance invites allowed",
            ["Notification.Alliance.MaximumAlliances"] = "You already have the maximum amount of alliances formed",
            ["Notification.Alliance.InviteSent"] = "You have sent a clan alliance invitation to [#aaff55][{0}][/#]\nThe invitation will expire in: {1}",
            ["Notification.Alliance.InviteReceived"] = "You have received a clan alliance invitation from [#aaff55][{0}][/#]\nTo accept, type: [#ffd479]/{2} accept {0}[/#]\nThe invitation will expire in: {1}",
            ["Notification.Alliance.NoActiveInvite"] = "You do not have an active alliance invitation for [#aaff55][{0}][/#]",
            ["Notification.Alliance.NoActiveInviteFrom"] = "You do not have an active alliance invitation from [#aaff55][{0}][/#]",
            ["Notification.Alliance.WithdrawnClan"] = "{0} has withdrawn an alliance invitation to [#aaff55][{1}][/#]",
            ["Notification.Alliance.WithdrawnTarget"] = "[#aaff55][{0}][/#] has withdrawn their alliance invitation",
            ["Notification.Alliance.AtLimitTarget"] = "[#aaff55][{0}][/#] currently has the maximum amount of alliances allowed",
            ["Notification.Alliance.AtLimitSelf"] = "Your clan currently has the maximum amount of alliances allowed",
            ["Notification.Alliance.Formed"] = "[#aaff55][{0}][/#] has formed an alliance with [#aaff55][{1}][/#]",
            ["Notification.Alliance.Rejected"] = "[#aaff55][{0}][/#] has rejected calls to form an alliance with [#aaff55][{1}][/#]",
            ["Notification.Alliance.Revoked"] = "[#aaff55][{0}][/#] has revoked their alliance with [#aaff55][{1}][/#]",
            ["Notification.Alliance.NoActiveAlliance"] = "You do not currently have an alliance with [#aaff55][{0}][/#]",

            ["Notification.ClanHelp.NoClan"] = "\nAvailable Commands:\n[#ffd479]/{0} create <tag> \"description\"[/#] - Create a new clan\n[#ffd479]/{0} accept <tag>[/#] - Join a clan by invitation\n[#ffd479]/{0} reject <tag>[/#] - Reject a clan invitation",
            ["Notification.ClanHelp.Basic"] = "\nAvailable Commands:\n[#ffd479]/{0}[/#] - Display your clan information\n[#ffd479]/{1} <message>[/#] - Send a message via clan chat\n[#ffd479]/{0} leave[/#] - Leave your current clan",
            ["Notification.ClanHelp.Alliance"] = "\n\n[#45b6fe]<size=14>Alliance Commands:</size>[/#]\n[#ffd479]/{0} invite <tag>[/#] - Invite a clan to become allies\n[#ffd479]/{0} withdraw <tag>[/#] - Withdraw an alliance invitation\n[#ffd479]/{0} accept <tag>[/#] - Accept an alliance invitation\n[#ffd479]/{0} reject <tag>[/#] - Reject an alliance invitation\n[#ffd479]/{0} revoke <tag>[/#] - Revoke an alliance",
            ["Notification.ClanHelp.Moderator"] = "\n\n[#b573ff]<size=14>Moderator Commands:</size>[/#]\n[#ffd479]/{0} invite <name or ID>[/#] - Invite a player to your clan\n[#ffd479]/{0} withdraw <name or ID>[/#] - Revoke a invitation\n[#ffd479]/{0} kick <name or ID>[/#] - Kick a member from your clan",
            ["Notification.ClanHelp.Owner"] = "\n\n[#a1ff46]<size=14>Owner Commands:</size>[/#]\n[#ffd479]/{0} promote <name or ID>[/#] - Promote a clan member\n[#ffd479]/{0} demote <name or ID>[/#] - Demote a clan member\n[#ffd479]/{0} disband forever[/#] - Disband your clan",

            ["Notification.Clan.NotInAClan"] = "\nYou are currently not a member of a clan",
            ["Notification.Clan.Help"] = "\nTo see available commands type: [#ffd479]/{0}[/#]",
            ["Notification.Clan.OwnerOf"] = "\nYou are the owner of: [#aaff55]{0}[/#] ({1}/{2})",
            ["Notification.Clan.ModeratorOf"] = "\nYou are a moderator of: [#aaff55]{0}[/#] ({1}/{2})",
            ["Notification.Clan.MemberOf"] = "\nYou are a member of: [#aaff55]{0}[/#] ({1}/{2})",
            ["Notification.Clan.MembersOnline"] = "\nMembers Online: {0}",

            ["Notification.Clan.CreateSyntax"] = "[#ffd479]/{0} create <tag> \"description\"[/#] - Create a new clan",
            ["Notification.Clan.InviteSyntax"] = "[#ffd479]/{0} invite <partialNameOrID>[/#] - Invite a player to your clan",
            ["Notification.Clan.WithdrawSyntax"] = "[#ffd479]/{0} withdraw <partialNameOrID>[/#] - Revoke a member invitation",
            ["Notification.Clan.AcceptSyntax"] = "[#ffd479]/{0} accept <tag>[/#] - Join a clan by invitation",
            ["Notification.Clan.RejectSyntax"] = "[#ffd479]/{0} reject <tag>[/#] - Reject a clan invitation",
            ["Notification.Clan.PromoteSyntax"] = "[#ffd479]/{0} promote <partialNameOrID>[/#] - Promote a clanFreb member to the next rank",
            ["Notification.Clan.DemoteSyntax"] = "[#ffd479]/{0} demote <partialNameOrID>[/#] - Demote a clan member to the next lowest rank",
            ["Notification.Clan.DisbandSyntax"] = "[#ffd479]/{0} disband forever[/#] - Disband your clan (this can not be undone)",
            ["Notification.Clan.KickSyntax"] = "[#ffd479]/{0} kick <partialNameOrID>[/#] - Kick a member from your clan",

            ["Notification.Clan.TagColorSyntax"] = "<color=#ffd479>/{0} tagcolor <hex (XXXXXX)></color> - Set a custom clan tag color",
            ["Notification.Clan.TagColorFormat"] = "<color=#ffd479>The hex string must be 6 characters long, and be a valid hex color</color>",
            ["Notification.Clan.TagColorReset"] = "<color=#ffd479>You have reset your clan's tag color</color>",
            ["Notification.Clan.TagColorSet"] = "<color=#ffd479>You have set your clan's tag color to</color> <color=#{0}>{0}</color>",
            ["Notification.Clan.TagColorDisabled"] = "<color=#ffd479>Custom tag colors are disabled on this server</color>",

            ["Notification.Disband.NotOwner"] = "You must be the clan owner to use this command",
            ["Notification.Disband.Success"] = "You have disbanded the clan [#aaff55][{0}][/#]",
            ["Notification.Disband.Reply"] = "The clan has been disbanded",
            ["Notification.Disband.NoPermission"] = "You do not have permission to disband this clan",

            ["Notification.Generic.ClanFull"] = "The clan is already at maximum capacity",
            ["Notification.Generic.NoClan"] = "You are not a member of a clan",
            ["Notification.Generic.InvalidClan"] = "The clan [#aaff55][{0}][/#] does not exist!",
            ["Notification.Generic.NoPermissions"] = "You have insufficient permission to use that command",
            ["Notification.Generic.SpecifyClanTag"] = "Please specify a clan tag",
            ["Notification.Generic.UnableToFindPlayer"] = "Unable to find a player with the name or ID {0}",
            ["Notification.Generic.CommandSelf"] = "You can not use this command on yourself",

            ["Chat.Alliance.Prefix"] = "[#a1ff46][ALLY CHAT][/#]: {0}",
            ["Chat.Clan.Prefix"] = "[#a1ff46][CLAN CHAT][/#]: {0}",
            ["Chat.Alliance.Format"] = "[{0}] [{1}]{2}[/#]: {3}",
        };
        #endregion

        #region ClansUI  
        #if RUST
        public bool HasFFEnabled(ulong playerID) => false;

        public void ToggleFF(ulong playerID) { }

        public void CreateClan(BasePlayer player, string tag, string description) => CreateClan(player.IPlayer, tag, description);

        public bool PromotePlayer(BasePlayer promoter, ulong targetId) => PromotePlayer(promoter.IPlayer, targetId.ToString());

        public bool DemotePlayer(BasePlayer demoter, ulong targetId) => DemotePlayer(demoter.IPlayer, targetId.ToString());

        public bool KickPlayer(BasePlayer player, ulong targetId) => KickPlayer(player.IPlayer, targetId.ToString());

        public bool InvitePlayer(BasePlayer player, ulong targetId) => InvitePlayer(player.IPlayer, targetId.ToString());

        public bool WithdrawInvite(BasePlayer player, string partialNameOrID) => WithdrawInvite(player.IPlayer, partialNameOrID);

        public bool OfferAlliance(BasePlayer player, string tag) => OfferAlliance(player.IPlayer, tag);

        public bool RevokeAlliance(BasePlayer player, string tag) => RevokeAlliance(player.IPlayer, tag);

        public bool WithdrawAlliance(BasePlayer player, string tag) => WithdrawAlliance(player.IPlayer, tag);

        public bool RejectAlliance(BasePlayer player, string tag) => RejectAlliance(player.IPlayer, tag);

        public bool AcceptAlliance(BasePlayer player, string tag) => AcceptAlliance(player.IPlayer, tag);

        public bool LeaveClan(BasePlayer player) => LeaveClan(player.IPlayer);

        public bool DisbandClan(BasePlayer player) => DisbandClan(player.IPlayer);
        #endif
        #endregion
    }

    namespace ClansEx
    {
        public static class StringExtensions
        {
            public static bool Contains(this string haystack, string needle, CompareOptions options)
            {
                return CultureInfo.InvariantCulture.CompareInfo.IndexOf(haystack, needle, options) >= 0;
            }
        }

        public static class ListPool
        {
            public static Dictionary<Type, object> directory = new Dictionary<Type, object>();

            public static void CreateCollection<T>(int capacity)
            {
                if (directory.ContainsKey(typeof(T)))
                    return;

                object obj = new ListCollection<T>(capacity);
                directory.Add(typeof(T), obj);
            }

            public static ListCollection<T> FindCollection<T>()
            {
                object obj;
                if (!directory.TryGetValue(typeof(T), out obj))
                {
                    obj = new ListCollection<T>();
                    directory.Add(typeof(T), obj);
                }

                return (ListCollection<T>)obj;
            }

            public static List<T> Get<T>() => GetList<List<T>>();
            
            public static List<T> Get<T>(int capacity)
            {
                List<T> list = GetList<List<T>>();
                list.Capacity = capacity;
                return list;
            }

            private static T GetList<T>() where T : class, new()
            {
                ListCollection<T> poolCollection = FindCollection<T>();
                if (poolCollection != null)
                {
                    if (poolCollection.stack.Count > 0)
                        return poolCollection.stack.Pop();
                }
                return Activator.CreateInstance<T>();
            }

            public static void Free<T>(ref List<T> list)
            {
                if (list == null)
                    return;

                list.Clear();

                FreeList<List<T>>(ref list);
            }

            private static void FreeList<T>(ref T t) where T : class
            {
                if (t == null)
                    return;

                ListCollection<T> poolCollection = FindCollection<T>();
                if (poolCollection != null && poolCollection.HasSpace)
                {
                    poolCollection.stack.Push(t);
                    t = default(T);
                }
                else
                {
                    t = null;
                }
            }

            public static void ClearPool()
            {
                directory.Clear();
            }

            public class ListCollection<T>
            {
                public Stack<T> stack;

                private readonly int maximumSize;

                public bool HasSpace { get { return stack.Count < maximumSize; } }

                public ListCollection(int maximumSize = 7)
                {
                    this.maximumSize = maximumSize;
                    stack = new Stack<T>(maximumSize + 1);
                }
            }
        }
    }
}


// --- End of file: Clans-0.2.8.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AuthLimits.cs ---
// --- Original Local Path: AuthLimits.cs ---

﻿namespace Oxide.Plugins
{
    [Info("AuthLimits", "Hougan", "0.0.1")]
    [Description("Ограничение на авторизация в шкафах/замках/турелях")]
    public class AuthLimits : RustPlugin
    {
        #region Variables

        private int MaxAuthorize = 5;
        private int DeAuthNumber = 1;

        #endregion

        #region Hooks

        private void OnCupboardAuthorize(BuildingPrivlidge privilege, BasePlayer player)
        {
            if (privilege.authorizedPlayers.Count >= MaxAuthorize)
            {
                var DeAuthId = privilege.authorizedPlayers[DeAuthNumber - 1];
                BasePlayer DeAuthorizated = BasePlayer.FindByID(DeAuthId.userid);

                SendReply(player, $"Вы превысили лимит авторизаций в одном шкафу, поэтому <color=#e34747>последний авторизовавшийся игрок</color> был выписан!");
                privilege.authorizedPlayers.RemoveAt(DeAuthNumber - 1);
                PrintWarning($"Игрок {player.displayName} [{player.userID}] превысил лимит авторизации в шкафу!");
            }
        }

        private object OnTurretAuthorize(AutoTurret turret, BasePlayer player)
        {
            if (turret.authorizedPlayers.Count >= MaxAuthorize)
            {
                SendReply(player, "Вы <color=#e34747>не можете</color> превысить лимит авторизации в турели!");
                PrintWarning($"Игрок {player.displayName} [{player.userID}] пытался превысить лимит авторизации в туреле!");
                return false;
            }
            return null;
        }

        private object OnCodeEntered(CodeLock codeLock, BasePlayer player, string code)
        {
            if (codeLock.whitelistPlayers.Count >= MaxAuthorize)
            {
                SendReply(player, "Вы <color=#e34747>не можете</color> превысить лимит авторизаций в замке!");
                PrintWarning($"Игрок {player.displayName} [{player.userID}] пытался превысить лимит авторизации в замке!");
                return false;
            }
            return null;
        }

        #endregion
    }
}

// --- End of file: AuthLimits.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/InfoPanel.cs ---
// --- Original Local Path: InfoPanel.cs ---


using System;
using System.Globalization;
using System.Runtime.Remoting.Messaging;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("InfoPanel", "Sparkless", "0.0.2")]
    public class InfoPanel : RustPlugin
    {
        [PluginReference] private Plugin ImageLibrary;
        private Configuration _config;

        private string CmdText = "/MENU";
        private string CmdCommand = "chat.say /menu";

        class Configuration
        {
            [JsonProperty("Название сервера")] 
            public string NameServer = "FURY RUST #1 MAX2";
            [JsonProperty("Иконка (где коробка)")] 
            public string StoreIcons = "https://i.imgur.com/J9ghJrj.png";
            [JsonProperty("Команда при нажатии на коробку")]
            public string CommandStore = "chat.say /store";
            [JsonProperty("Иконка(Онлайн)")] 
            public string OnlineIcons = "https://i.imgur.com/WvssHc7.png";
            [JsonProperty("Иконка(Спящих)")] 
            public string SleepIcons = "https://i.imgur.com/kzRLOJp.png";
            
             [JsonProperty("Иконка 1 кнопки")] 
             public string Knopka1 = "https://i.imgur.com/J9ghJrj.png";
             [JsonProperty("Иконка 2 кнопки")] 
             public string Knopka2 = "https://i.imgur.com/J9ghJrj.png";
             [JsonProperty("Иконка 3 кнопки")] 
             public string Knopka3 = "https://i.imgur.com/J9ghJrj.png";
             [JsonProperty("Иконка 4 кнопки")] 
             public string Knopka4 = "https://i.imgur.com/J9ghJrj.png";
             [JsonProperty("Иконка 5 кнопки")] 
             public string Knopka5 = "https://i.imgur.com/J9ghJrj.png";

             [JsonProperty("Текст на 1 кнопки")] 
             public string KnopkaText1 = "БЛОКИРОВКА ОРУЖИЙ";
             [JsonProperty("Текст на 2 кнопки")] 
             public string KnopkaText2 = "БЛОКИРОВКА ОРУЖИЙ";
             [JsonProperty("Текст на 3 кнопки")] 
             public string KnopkaText3 = "БЛОКИРОВКА ОРУЖИЙ";
             [JsonProperty("Текст на 4 кнопки")] 
             public string KnopkaText4 = "БЛОКИРОВКА ОРУЖИЙ";
             [JsonProperty("Текст на 5 кнопки")]
             public string KnopkaText5 = "БЛОКИРОВКА ОРУЖИЙ";

             [JsonProperty("Команда при нажатии на 1 кнопку")]
             public string CommandKnopka1 = "chat.say /store";
             [JsonProperty("Команда при нажатии на 2 кнопку")]
             public string CommandKnopka2 = "chat.say /store";
             [JsonProperty("Команда при нажатии на 3 кнопку")]
             public string CommandKnopka3 = "chat.say /store";
             [JsonProperty("Команда при нажатии на 4 кнопку")]
             public string CommandKnopka4 = "chat.say /store";
             [JsonProperty("Команда при нажатии на 5 кнопку")]
             public string CommandKnopka5 = "chat.say /store";
             
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
            }
            catch
            {
                Config.WriteObject(_config, false, $"{Interface.Oxide.ConfigDirectory}/{Name}.JsonEror");
                PrintError("Конфиг сломался, загружаю новый!...");
                LoadDefaultConfig();
            }
            SaveConfig();
        }
        protected override void LoadDefaultConfig() => _config = new Configuration();
        protected override void SaveConfig() => Config.WriteObject(_config);

        void OnServerInitialized()
        {
            
            ImageLibrary.Call("AddImage", _config.OnlineIcons, "onlineicons");
            ImageLibrary.Call("AddImage", _config.SleepIcons, "sleepicons");
            ImageLibrary.Call("AddImage", _config.StoreIcons, "storeicons");
            ImageLibrary.Call("AddImage", _config.Knopka1, "knopka1");
            ImageLibrary.Call("AddImage", _config.Knopka2, "knopka2");
            ImageLibrary.Call("AddImage", _config.Knopka3, "knopka3");
            ImageLibrary.Call("AddImage", _config.Knopka4, "knopka4");
            ImageLibrary.Call("AddImage", _config.Knopka5, "knopka5");
            BasePlayer.activePlayerList.ForEach(OnPlayerInit);
            PrintWarning($"Плагин сделал Sparkless");
            PrintWarning($"Хотите сменить команду /menu на что то другое? отпишите мне на форуме");
        }
        void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, "Layer");  
                CuiHelper.DestroyUi(player, "Open");  
            }  
        }

        private void OnPlayerInit(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerInit(player));
                return;
            }
			
            foreach (var players in BasePlayer.activePlayerList)
            {
                timer.Once(1, () =>
                {
                    DrawMenu(players);
                });
            }
        }
        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            foreach (var players in BasePlayer.activePlayerList)
            {
                timer.Once(1, () =>
                {
                   DrawMenu(players);
                });
            }
        }
        private string Layer = "Layer";

        private void DrawMenu(BasePlayer player)
        {
            var Sleepers = BasePlayer.sleepingPlayerList.Count.ToString();
            CuiHelper.DestroyUi(player, Layer);
            var container = new CuiElementContainer();
            var Panel = container.Add(new CuiPanel
            {
                Image = {Color = HexToCuiColor("#FFFFFF00")},
                RectTransform = {AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "0 -265", OffsetMax = "190 3"},
                CursorEnabled = false,
            }, "Overlay", Layer);
            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                {
                    new CuiImageComponent {FadeIn = 1f, Color = "0.6117647 0.6117647 0.6117647 0.1565329"},
                    new CuiRectTransformComponent {AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "5 -40", OffsetMax = "45 -2"}
                }
            });
            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                {
                    new CuiRawImageComponent()
                    {
                        Png = (string) ImageLibrary.Call("GetImage", "storeicons"),
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0 1",
                        AnchorMax = "0 1",
                        OffsetMax = "45 0",
                        OffsetMin = "5 -40"
                    },
                }
            });
            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                {
                    new CuiImageComponent {FadeIn = 1f, Color = "0.6117647 0.6117647 0.6117647 0.1565329"},
                    new CuiRectTransformComponent {AnchorMin = "0 1", AnchorMax = "0 1", OffsetMax = "190 0", OffsetMin = "49.5 -20"}
                }
            });
            container.Add(new CuiElement
            {
                Parent = Layer,
                Components = {
                    new CuiTextComponent() { Color = HexToCuiColor("#FFFFFFFF"), FadeIn = 1f, Text = _config.NameServer, FontSize = 12, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf" },
                    new CuiRectTransformComponent { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "50 -22", OffsetMax = "190 0"},
                }
            });
            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                {
                    new CuiImageComponent {FadeIn = 1f, Color = "0.6117647 0.6117647 0.6117647 0.1565329"},
                    new CuiRectTransformComponent {AnchorMin = "0 1", AnchorMax = "0 1", OffsetMax = "115 -22", OffsetMin = "50 -40"}
                }
            });
            container.Add(new CuiElement
            {
                Parent = Layer,
                Components = {
                    new CuiTextComponent() { Color = HexToCuiColor("#FFFFFFFF"), FadeIn = 1f, Text = $"{BasePlayer.activePlayerList.Count}/{ConVar.Server.maxplayers}", FontSize = 13, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf" },
                    new CuiRectTransformComponent { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "70 -40", OffsetMax = "115 -22"},
                }
            });
            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                {
                    new CuiRawImageComponent()
                    {
                        Png = (string) ImageLibrary.Call("GetImage", "onlineicons"),
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0 1",
                        AnchorMax = "0 1",
                        OffsetMax = "70 -22",
                        OffsetMin = "50 -39"
                    },
                }
            });
            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                {
                    new CuiImageComponent {FadeIn = 1f, Color = "0.6117647 0.6117647 0.6117647 0.1565329"},
                    new CuiRectTransformComponent {AnchorMin = "0 1", AnchorMax = "0 1", OffsetMax = "190 -22", OffsetMin = "120 -40"}
                }
            });
            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                {
                    new CuiRawImageComponent()
                    {
                        Png = (string) ImageLibrary.Call("GetImage", "sleepicons"),
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0 1",
                        AnchorMax = "0 1",
                        OffsetMax = "140 -22",
                        OffsetMin = "123 -40"
                    },
                }
            });
            container.Add(new CuiElement
            {
                Parent = Layer,
                Components = {
                    new CuiTextComponent() { Color = HexToCuiColor("#FFFFFFFF"), FadeIn = 1f, Text = $"{Sleepers}", FontSize = 12, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf" },
                    new CuiRectTransformComponent { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMax = "190 -22", OffsetMin = "140 -40"},
                }
            });
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "5 -60", OffsetMax = "45 -43"},
                Button = { Command = CmdCommand, Color =  "0.6117647 0.6117647 0.6117647 0.1565329"},
                Text = { Text = CmdText, FontSize = 14, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf" },
            }, Layer);
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "5 -40", OffsetMax = "45 -2"},
                Button = { Command = _config.CommandStore, Color =  HexToCuiColor("#FFFFFF00")},
                Text = { Text = "" }
            }, Layer);

            CuiHelper.AddUi(player, container);
        }


        private string Open = "Open";
        [ChatCommand("menu")]
        private void OpenMenu(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, Open);
            var container = new CuiElementContainer();
            var Panel = container.Add(new CuiPanel
            {
                Image = {Color = HexToCuiColor("#FFFFFF00")},
                RectTransform = {AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "0 -265", OffsetMax = "190 3"},
                CursorEnabled = false,
            }, "Overlay", Open);
            container.Add(new CuiElement
            {
                Parent = Open,
                Components =
                {
                    new CuiImageComponent {FadeIn = 1f, Color = "0.6117647 0.6117647 0.6117647 0.1565329"},
                    new CuiRectTransformComponent {AnchorMin = "0 1", AnchorMax = "0 1", OffsetMax = "190 -65", OffsetMin = "5 -100"}
                }
            });
            container.Add(new CuiElement
            {
                Parent = Open,
                Components =
                {
                    new CuiImageComponent {FadeIn = 1f, Color = "0.6117647 0.6117647 0.6117647 0.1565329"},
                    new CuiRectTransformComponent {AnchorMin = "0 1", AnchorMax = "0 1", OffsetMax = "190 -104", OffsetMin = "5 -139"}
                }
            });
            container.Add(new CuiElement
            {
                Parent = Open,
                Components =
                {
                    new CuiImageComponent {FadeIn = 1f, Color = "0.6117647 0.6117647 0.6117647 0.1565329"},
                    new CuiRectTransformComponent {AnchorMin = "0 1", AnchorMax = "0 1", OffsetMax = "190 -143", OffsetMin = "5 -178"}
                }
            });
            container.Add(new CuiElement
            {
                Parent = Open,
                Components =
                {
                    new CuiImageComponent {FadeIn = 1f, Color = "0.6117647 0.6117647 0.6117647 0.1565329"},
                    new CuiRectTransformComponent {AnchorMin = "0 1", AnchorMax = "0 1", OffsetMax = "190 -182", OffsetMin = "5 -218"}
                }
            });
            container.Add(new CuiElement
            {
                Parent = Open,
                Components =
                {
                    new CuiImageComponent {FadeIn = 1f, Color = "0.6117647 0.6117647 0.6117647 0.1565329"},
                    new CuiRectTransformComponent {AnchorMin = "0 1", AnchorMax = "0 1", OffsetMax = "190 -222", OffsetMin = "5 -258"}
                }
            });
            container.Add(new CuiElement
            {
                Parent = Open,
                Components =
                {
                    new CuiRawImageComponent()
                    {
                        Png = (string) ImageLibrary.Call("GetImage", "knopka1"),
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0 1",
                        AnchorMax = "0 1",
                        OffsetMax = "46.5 -65",
                        OffsetMin = "5 -100"
                    },
                }
            });
            container.Add(new CuiElement
            {
                Parent = Open,
                Components =
                {
                    new CuiRawImageComponent()
                    {
                        Png = (string) ImageLibrary.Call("GetImage", "knopka2"),
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0 1",
                        AnchorMax = "0 1",
                        OffsetMax = "46.5 -104",
                        OffsetMin = "5 -140"
                    },
                }
            });
            container.Add(new CuiElement
            {
                Parent = Open,
                Components =
                {
                    new CuiRawImageComponent()
                    {
                        Png = (string) ImageLibrary.Call("GetImage", "knopka3"),
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0 1",
                        AnchorMax = "0 1",
                        OffsetMax = "46.5 -143",
                        OffsetMin = "5 -178"
                    },
                }
            });
            container.Add(new CuiElement
            {
                Parent = Open,
                Components =
                {
                    new CuiRawImageComponent()
                    {
                        Png = (string) ImageLibrary.Call("GetImage", "knopka4"),
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0 1",
                        AnchorMax = "0 1",
                        OffsetMax = "46.5 -182",
                        OffsetMin = "5 -219"
                    },
                }
            });
            container.Add(new CuiElement
            {
                Parent = Open,
                Components =
                {
                    new CuiRawImageComponent()
                    {
                        Png = (string) ImageLibrary.Call("GetImage", "knopka5"),
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0 1",
                        AnchorMax = "0 1",
                        OffsetMax = "46.5 -220",
                        OffsetMin = "5 -257"
                    },
                }
            });
            container.Add(new CuiElement
            {
                Parent = Open,
                Components = {
                    new CuiTextComponent() { Color = HexToCuiColor("#FFFFFFFF"), FadeIn = 1f, Text = _config.KnopkaText1, FontSize = 12, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf" },
                    new CuiRectTransformComponent { AnchorMin = "0 1", AnchorMax = "0 1" , OffsetMin = "50 -100", OffsetMax = "190 -65"},
                }
            });
            container.Add(new CuiElement
            {
                Parent = Open,
                Components = {
                    new CuiTextComponent() { Color = HexToCuiColor("#FFFFFFFF"), FadeIn = 1f, Text = _config.KnopkaText2, FontSize = 12, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf" },
                    new CuiRectTransformComponent { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "50 -140", OffsetMax = "190 -104"},
                }
            });
            container.Add(new CuiElement
            {
                Parent = Open,
                Components = {
                    new CuiTextComponent() { Color = HexToCuiColor("#FFFFFFFF"), FadeIn = 1f, Text = _config.KnopkaText3, FontSize = 12, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf" },
                    new CuiRectTransformComponent { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "50 -178", OffsetMax = "190 -143"},
                }
            });
            container.Add(new CuiElement
            {
                Parent = Open,
                Components = {
                    new CuiTextComponent() { Color = HexToCuiColor("#FFFFFFFF"), FadeIn = 1f, Text = _config.KnopkaText4, FontSize = 12, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf" },
                    new CuiRectTransformComponent { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "50 -219", OffsetMax = "190 -182"},
                }
            });
            container.Add(new CuiElement
            {
                Parent = Open,
                Components = {
                    new CuiTextComponent() { Color = HexToCuiColor("#FFFFFFFF"), FadeIn = 1f, Text = _config.KnopkaText5, FontSize = 12, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf" },
                    new CuiRectTransformComponent { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "50 -257", OffsetMax = "190 -220"},
                }
            });
            container.Add(new CuiElement
            {
                Parent = Open,
                Components =
                {
                    new CuiImageComponent {FadeIn = 1f, Color = "1 0 0 0.1276685"},
                    new CuiRectTransformComponent {AnchorMin = "0 1", AnchorMax = "0 1", OffsetMax = "190 -45", OffsetMin = "174 -60"}
                }
            });
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "174 -60", OffsetMax = "190 -45"},
                Button = { Close = Open, Color =  HexToCuiColor("#FFFFFF00")},
                Text = { Text = "X", FontSize = 13, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf" },
            }, Open);
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "5 -100", OffsetMax = "190 -65"},
                Button = { Command = _config.CommandKnopka1, Close = Open, Color =  HexToCuiColor("#FFFFFF00")},
                Text = { Text = "" }
            }, Open);
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "5 -139", OffsetMax = "190 -104"},
                Button = { Command = _config.CommandKnopka2, Close = Open, Color =  HexToCuiColor("#FFFFFF00")},
                Text = { Text = "" }
            }, Open);
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "5 -178", OffsetMax = "190 -143"},
                Button = { Command = _config.CommandKnopka3, Close = Open, Color =  HexToCuiColor("#FFFFFF00")},
                Text = { Text = "" }
            }, Open);
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "5 -218", OffsetMax = "190 -182"},
                Button = { Command = _config.CommandKnopka4, Close = Open, Color =  HexToCuiColor("#FFFFFF00")},
                Text = { Text = "" }
            }, Open);
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "5 -258", OffsetMax = "190 -222"},
                Button = { Command = _config.CommandKnopka5, Close = Open, Color =  HexToCuiColor("#FFFFFF00")},
                Text = { Text = "" }
            }, Open);


            CuiHelper.AddUi(player, container);
        }
        
        #region Helpers

        private static string HexToCuiColor(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }
			
        #endregion
    }
}

// --- End of file: InfoPanel.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PlayingCards.cs ---
// --- Original Local Path: PlayingCards.cs ---

﻿using Newtonsoft.Json;
using System.Collections.Generic;
using System;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("PlayingCards", "k1lly0u", "0.1.1")]
    [Description("Casino image management system")]
    class PlayingCards : RustPlugin
    {
        #region Fields
        [PluginReference] Plugin ImageLibrary;

        private string imageUrl = "https://www.rustedit.io/images/casino/";

        public static bool IsReady { get; private set; }

        public static PlayingCards Instance { get; private set; }

        public static event Action OnImagesReady;
        #endregion

        #region Oxide Hooks
        private void OnServerInitialized()
        {
            Instance = this;
            IsReady = false;
            timer.In(5f, () => ImportCardImages());
        }
        
        private void Unload()
        {
            IsReady = false;
            Instance = null;
        }
        #endregion

        #region Import Images
        private void ImportCardImages(int attempts = 0)
        {
            if (!ImageLibrary)
            {
                if (attempts > 3)
                {
                    PrintError("This plugin requires ImageLibrary to manage the card images. Please install ImageLibrary to continue...");
                    return;
                }

                timer.In(10, () => ImportCardImages(attempts++));
                return;
            }

            Dictionary<string, Dictionary<ulong, string>> loadOrder = new Dictionary<string, Dictionary<ulong, string>>();

            string[] values = new string[] { "A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K" };
            string[] suits = new string[] { "C", "D", "H", "S" };
            int[] chips = new int[] { 1, 10, 50, 100, 500 };

            for (int i = 0; i < suits.Length; i++)
            {
                for (int j = 0; j < values.Length; j++)
                {
                    loadOrder.Add($"{values[j]}{suits[i]}", new Dictionary<ulong, string>() { [0U] = $"{imageUrl}{values[j]}{suits[i]}.png" });
                }
            }
            loadOrder.Add("blue_back", new Dictionary<ulong, string>() { [0U] = $"{imageUrl}blue_back.png" });
            loadOrder.Add("gray_back", new Dictionary<ulong, string>() { [0U] = $"{imageUrl}gray_back.png" });
            loadOrder.Add("green_back", new Dictionary<ulong, string>() { [0U] = $"{imageUrl}green_back.png" });
            loadOrder.Add("purple_back", new Dictionary<ulong, string>() { [0U] = $"{imageUrl}purple_back.png" });
            loadOrder.Add("red_back", new Dictionary<ulong, string>() { [0U] = $"{imageUrl}red_back.png" });
            loadOrder.Add("yellow_back", new Dictionary<ulong, string>() { [0U] = $"{imageUrl}yellow_back.png" });

            loadOrder.Add("board_blackjack", new Dictionary<ulong, string>() { [0U] = $"{imageUrl}board_blackjack.png" });
            loadOrder.Add("betting_stack", new Dictionary<ulong, string>() { [0U] = $"{imageUrl}betting_stack.png" });

            for (int i = 0; i < chips.Length; i++)
            {
                loadOrder.Add($"chip_{chips[i]}", new Dictionary<ulong, string>() { [0U] = $"{imageUrl}chip_{chips[i]}.png" });
            }

            ImageLibrary.Call("ImportItemList", "Casino - Playing card imagery", loadOrder, configData.ForceUpdate, (Action)OnImagesLoaded);  
            
            if (configData.ForceUpdate)
            {
                configData.ForceUpdate = false;
                SaveConfig();
            }
        }

        private void OnImagesLoaded()
        {
            IsReady = true;
            OnImagesReady?.Invoke();
        }

        public static void AddImage(string imageName, string fileName) => Instance.ImageLibrary.Call("AddImage", fileName, imageName, 0U);

        public static string GetCardImage(string value, string suit) => (string)Instance.ImageLibrary?.Call("GetImage", $"{value}{suit}");

        public static string GetChipImage(int value) => (string)Instance.ImageLibrary?.Call("GetImage", $"chip_{value}");

        public static string GetChipStackImage() => (string)Instance.ImageLibrary?.Call("GetImage", "betting_stack");

        public static string GetBoardImage(string gameType) => (string)Instance.ImageLibrary?.Call("GetImage", $"board_{gameType}");

        public static string GetCardBackground(string color) => (string)Instance.ImageLibrary?.Call("GetImage", $"{color}_back");
        #endregion

        #region Config        
        private ConfigData configData;
        private class ConfigData
        {
            [JsonProperty(PropertyName = "Force image update on load")]
            public bool ForceUpdate { get; set; }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                ForceUpdate = false,
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion
    }
}


// --- End of file: PlayingCards.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Crafts.cs ---
// --- Original Local Path: Crafts.cs ---

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using UnityEngine;
using VLB;
using WebSocketSharp;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("Crafts", "Mevent", "1.11.0⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠")]
    public class Crafts : RustPlugin
    {
        //TODO: Добавить время крафта

        #region Fields⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        [PluginReference] private Plugin ImageLibrary;

        private const string Layer = "UI.Crafts";

        private static Crafts _instance;
        
        private readonly List<int> _blockedLayers = new List<int>
        {
            (int) Rust.Layer.Water, (int) Rust.Layer.Construction, (int) Rust.Layer.Trigger,
            (int) Rust.Layer.Prevent_Building,
            (int) Rust.Layer.Deployed, (int) Rust.Layer.Tree
        };

        private enum WorkbenchLevel
        {
            None = 0,
            One = 1,
            Two = 2,
            Three = 3
        }

        private enum CraftType
        {
            Команда,
            Транспорт,
            Предмет,
            Переработчик
        }

        #endregion

        #region Config⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        private static Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Цвет кнопки когда все предметы присутствуют")]
            public string GreenColor = "#80FF8080";

            [JsonProperty(PropertyName = "Комманда меню крафта")]
            public string Command = "craft";

            [JsonProperty(PropertyName = "Включить дебаг?")]
            public bool useDebug = true;

            [JsonProperty(PropertyName = "Настройка цветов верстаков",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<WorkbenchLevel, WorkbenchConfig> Workbenchs =
                new Dictionary<WorkbenchLevel, WorkbenchConfig>
                {
                    [WorkbenchLevel.None] = new WorkbenchConfig("#00000080", "Верстак не требуется"),
                    [WorkbenchLevel.One] = new WorkbenchConfig("#80400080", "Верстак 1 уровня"),
                    [WorkbenchLevel.Two] = new WorkbenchConfig("#0080FF80", "Верстак 2 уровня"),
                    [WorkbenchLevel.Three] = new WorkbenchConfig("#FF000080", "Верстак 3 уровня")
                };

            [JsonProperty(PropertyName = "Настройка крафтов", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<CraftConfig> CraftsList = new List<CraftConfig>
            {
                new CraftConfig
                {
                    Enabled = true,
                    ImageURL = "https://i.imgur.com/YXjADeE.png",
                    Description = new List<string>
                    {
                        "Для создания требуется:",
                        "- Шестерни (5 шт)",
                        "- Дорожные знаки (5 шт)",
                        "- Металл (2000 шт)"
                    },
                    Command = "givecopter",
                    Permission = "crafts.all",
                    DisplayName = "Миникоптер",
                    ShortName = "electric.flasherlight",
                    SkinID = 2080145158,
                    Type = CraftType.Транспорт,
                    Prefab = "assets/content/vehicles/minicopter/minicopter.entity.prefab",
                    Level = WorkbenchLevel.One,
                    UseDistance = true,
                    Distance = 1.5f,
                    GiveCommand = string.Empty,
                    Ground = true,
                    Structure = true,
                    Items = new List<ItemForCraft>
                    {
                        new ItemForCraft("gears", 5, 0),
                        new ItemForCraft("roadsigns", 5, 0),
                        new ItemForCraft("metal.fragments", 2000, 0)
                    }
                },
                new CraftConfig
                {
                    Enabled = true,
                    ImageURL = "https://i.imgur.com/dmWQOm6.png",
                    Description = new List<string>
                    {
                        "Для создания требуется:",
                        "- Шестерни (5 шт)",
                        "- Дорожные знаки (5 шт)",
                        "- Металл (2000 шт)"
                    },
                    Command = "giverowboat",
                    Permission = "crafts.all",
                    DisplayName = "Деревянная лодка",
                    ShortName = "coffin.storage",
                    SkinID = 2080150023,
                    Type = CraftType.Транспорт,
                    Prefab = "assets/content/vehicles/boats/rowboat/rowboat.prefab",
                    Level = WorkbenchLevel.Two,
                    UseDistance = true,
                    Distance = 1.5f,
                    GiveCommand = string.Empty,
                    Ground = true,
                    Structure = true,
                    Items = new List<ItemForCraft>
                    {
                        new ItemForCraft("gears", 5, 0),
                        new ItemForCraft("roadsigns", 5, 0),
                        new ItemForCraft("metal.fragments", 2000, 0)
                    }
                },
                new CraftConfig
                {
                    Enabled = true,
                    ImageURL = "https://i.imgur.com/CgpVw2j.png",
                    Description = new List<string>
                    {
                        "Для создания требуется:",
                        "- Шестерни (5 шт)",
                        "- Дорожные знаки (5 шт)",
                        "- Металл (2000 шт)"
                    },
                    Command = "giverhibboat",
                    Permission = "crafts.all",
                    DisplayName = "Военная лодка",
                    ShortName = "electric.sirenlight",
                    SkinID = 2080150770,
                    Type = CraftType.Транспорт,
                    GiveCommand = string.Empty,
                    Prefab = "assets/content/vehicles/boats/rhib/rhib.prefab",
                    Level = WorkbenchLevel.Three,
                    UseDistance = true,
                    Distance = 1.5f,
                    Ground = true,
                    Structure = true,
                    Items = new List<ItemForCraft>
                    {
                        new ItemForCraft("gears", 5, 0),
                        new ItemForCraft("roadsigns", 5, 0),
                        new ItemForCraft("metal.fragments", 2000, 0)
                    }
                },
                new CraftConfig
                {
                    Enabled = true,
                    ImageURL = "https://i.imgur.com/eioxlvK.png",
                    Description = new List<string>
                    {
                        "Для создания требуется:",
                        "- Шестерни (5 шт)",
                        "- Дорожные знаки (5 шт)",
                        "- Металл (2000 шт)"
                    },
                    Command = "givesedan",
                    Permission = "crafts.all",
                    DisplayName = "Машина",
                    ShortName = "woodcross",
                    SkinID = 2080151780,
                    Type = CraftType.Транспорт,
                    GiveCommand = string.Empty,
                    Prefab = "assets/content/vehicles/sedan_a/sedantest.entity.prefab",
                    Level = WorkbenchLevel.Two,
                    UseDistance = true,
                    Distance = 1.5f,
                    Ground = true,
                    Structure = true,
                    Items = new List<ItemForCraft>
                    {
                        new ItemForCraft("gears", 5, 0),
                        new ItemForCraft("roadsigns", 5, 0),
                        new ItemForCraft("metal.fragments", 2000, 0)
                    }
                },
                new CraftConfig
                {
                    Enabled = true,
                    ImageURL = "https://i.imgur.com/cp2Xx2A.png",
                    Description = new List<string>
                    {
                        "Для создания требуется:",
                        "- Шестерни (5 шт)",
                        "- Дорожные знаки (5 шт)",
                        "- Металл (2000 шт)"
                    },
                    Command = "givehotair",
                    Permission = "crafts.all",
                    DisplayName = "Воздушный шар",
                    ShortName = "box.repair.bench",
                    SkinID = 2080152635,
                    Type = CraftType.Транспорт,
                    GiveCommand = string.Empty,
                    Prefab = "assets/prefabs/deployable/hot air balloon/hotairballoon.prefab",
                    Level = WorkbenchLevel.Three,
                    UseDistance = true,
                    Distance = 1.5f,
                    Ground = true,
                    Structure = true,
                    Items = new List<ItemForCraft>
                    {
                        new ItemForCraft("gears", 5, 0),
                        new ItemForCraft("roadsigns", 5, 0),
                        new ItemForCraft("metal.fragments", 2000, 0)
                    }
                },
                new CraftConfig
                {
                    Enabled = true,
                    ImageURL = "https://i.imgur.com/7JZE0Lr.png",
                    Description = new List<string>
                    {
                        "Для создания требуется:",
                        "- Шестерни (5 шт)",
                        "- Дорожные знаки (5 шт)",
                        "- Металл (2000 шт)"
                    },
                    Command = "givescrapheli",
                    Permission = "crafts.all",
                    DisplayName = "Грузовой вертолёт",
                    ShortName = "lantern",
                    SkinID = 2080154394,
                    Type = CraftType.Транспорт,
                    GiveCommand = string.Empty,
                    Prefab = "assets/content/vehicles/scrap heli carrier/scraptransporthelicopter.prefab",
                    Level = WorkbenchLevel.Three,
                    UseDistance = true,
                    Distance = 1.5f,
                    Ground = true,
                    Structure = true,
                    Items = new List<ItemForCraft>
                    {
                        new ItemForCraft("gears", 5, 0),
                        new ItemForCraft("roadsigns", 5, 0),
                        new ItemForCraft("metal.fragments", 2000, 0)
                    }
                },
                new CraftConfig
                {
                    Enabled = true,
                    ImageURL = "https://i.imgur.com/LLB2AVi.png",
                    Description = new List<string>
                    {
                        "Для создания требуется:",
                        "- Шестерни (5 шт)",
                        "- Дорожные знаки (5 шт)",
                        "- Металл (2000 шт)"
                    },
                    Command = "giverecycler",
                    Permission = "crafts.all",
                    DisplayName = "Домашний Переработчик",
                    ShortName = "research.table",
                    SkinID = 2186833264,
                    Type = CraftType.Переработчик,
                    Prefab = "assets/bundled/prefabs/static/recycler_static.prefab",
                    GiveCommand = string.Empty,
                    Level = WorkbenchLevel.Two,
                    UseDistance = true,
                    Distance = 1.5f,
                    Ground = true,
                    Structure = true,
                    Items = new List<ItemForCraft>
                    {
                        new ItemForCraft("gears", 5, 0),
                        new ItemForCraft("roadsigns", 5, 0),
                        new ItemForCraft("metal.fragments", 2000, 0)
                    }
                },
                new CraftConfig
                {
                    Enabled = true,
                    ImageURL = "https://i.imgur.com/mw1T17x.png",
                    Description = new List<string>
                    {
                        "Для создания требуется:",
                        "- Шестерни (5 шт)",
                        "- Дорожные знаки (5 шт)",
                        "- Металл (2000 шт)"
                    },
                    Command = "givelr300",
                    Permission = "crafts.all",
                    DisplayName = string.Empty,
                    ShortName = "rifle.lr300",
                    SkinID = 0,
                    Type = CraftType.Предмет,
                    Prefab = string.Empty,
                    GiveCommand = string.Empty,
                    Level = WorkbenchLevel.None,
                    UseDistance = true,
                    Distance = 1.5f,
                    Ground = true,
                    Structure = true,
                    Items = new List<ItemForCraft>
                    {
                        new ItemForCraft("gears", 5, 0),
                        new ItemForCraft("roadsigns", 5, 0),
                        new ItemForCraft("metal.fragments", 2000, 0)
                    }
                }
            };
            
            [JsonProperty(PropertyName = "Настройка переработчика")]
            public RecyclerConfig Recycler = new RecyclerConfig
            {
                Speed = 5f,
                Radius = 7.5f,
                Text = "<size=19>ПЕРЕРАБОТЧИК</size>\n<size=15>{0}/{1}</size>",
                Color = "#C5D0E6",
                Delay = 0.75f,
                Available = true,
                Owner = true,
                Amounts = new[] {0.9f, 0, 0, 0, 0, 0.5f, 0, 0, 0, 0.9f, 0.5f, 0.5f, 0, 1, 1, 0.5f, 0, 0, 0, 0, 0, 1, 1},
                Scale = 0.5f,
                DDraw = true,
                Building = true
            };
            
            [JsonProperty(PropertyName = "Настройка машины")]
            public CarConfig Car = new CarConfig
            {
                ActiveItems = new ActiveItemOptions
                {
                    Disable = true,
                    BlackList = new[]
                    {
                        "explosive.timed", "rocket.launcher", "surveycharge", "explosive.satchel"
                    }
                },
                Radius = 7.5f,
                Text = "<size=15>{0}/{1}</size>",
                Color = "#C5D0E6",
                Delay = 0.75f,
            };
        }
        
        private class CarConfig
        {
            [JsonProperty(PropertyName = "Активные предметы (которые в руки)")]
            public ActiveItemOptions ActiveItems;
            
            [JsonProperty(PropertyName = "Радиус в котором будет показан текст на машине")]
            public float Radius;
            
            [JsonProperty(PropertyName = "Текст на машине")]
            public string Text;
            
            [JsonProperty(PropertyName = "Цвет текста на машине")]
            public string Color;

            [JsonProperty(PropertyName = "Время показа текста на машине (сек)")]
            public float Delay;
        }
        
        public class ActiveItemOptions
        {
            [JsonProperty(PropertyName = "Запретить держать все предметы")]
            public bool Disable;

            [JsonProperty(PropertyName = "Список запрещённых к держанию предметов (shortname)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public string[] BlackList;
        }
        
        private class RecyclerConfig
        {
            [JsonProperty(PropertyName = "Скорость переработки")]
            public float Speed;

            [JsonProperty(PropertyName = "Радиус в котором будет показан текст на переработчике")]
            public float Radius;

            [JsonProperty(PropertyName = "Показывать дамаг на переработчике")]
            public bool DDraw;
            
            [JsonProperty(PropertyName = "Текст на переработчике")]
            public string Text;

            [JsonProperty(PropertyName = "Цвет текста на переработчике")]
            public string Color;

            [JsonProperty(PropertyName = "Время показа текста на переработчике (сек)")]
            public float Delay;
            
            [JsonProperty(PropertyName = "Можно ли подбирать переработчик")]
            public bool Available;
            
            [JsonProperty(PropertyName = "Подбор только владельцем?")]
            public bool Owner;
            
            [JsonProperty(PropertyName = "Право на постройку для подбора")]
            public bool Building;

            [JsonProperty(PropertyName = "Настройка BaseProtection",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public float[] Amounts;

            [JsonProperty(PropertyName = "Множитель урона по переработчику")]
            public float Scale;
        }

        private class WorkbenchConfig
        {
            [JsonProperty(PropertyName = "Цвет")] 
            public string Color;

            [JsonProperty(PropertyName = "Надпись")]
            public string Title;

            public WorkbenchConfig(string color, string title)
            {
                Color = color;
                Title = title;
            }
        }

        private class CraftConfig
        {
            [JsonProperty(PropertyName = "Включить крафт?")]
            public bool Enabled;

            [JsonProperty(PropertyName = "Картинка")]
            public string ImageURL;

            [JsonProperty(PropertyName = "Описание")]
            public List<string> Description;

            [JsonProperty(PropertyName = "Команда для получения")]
            public string Command;

            [JsonProperty(PropertyName = "Право на крафт")]
            public string Permission;

            [JsonProperty(PropertyName = "Отображаемое имя заменяемого предмета")]
            public string DisplayName;

            [JsonProperty(PropertyName = "Shortname заменяемого предмета")]
            public string ShortName;

            [JsonProperty(PropertyName = "Скин заменяемого предмета")]
            public ulong SkinID;

            [JsonProperty(PropertyName = "Тип предмета (Предмет/Команда/Транспорт)")]
            [JsonConverter(typeof(StringEnumConverter))]
            public CraftType Type;

            [JsonProperty(PropertyName = "Префаб (для транспорта)")]
            public string Prefab;

            [JsonProperty(PropertyName = "Команда при получении")]
            public string GiveCommand;

            [JsonProperty(PropertyName = "Уровень верстака")]
            public WorkbenchLevel Level;

            [JsonProperty(PropertyName = "Включить проверку на дистанцию?")]
            public bool UseDistance;

            [JsonProperty(PropertyName = "Дистанция")]
            public float Distance;
            
            [JsonProperty(PropertyName = "Установка на землю")]
            public bool Ground;
            
            [JsonProperty(PropertyName = "Установка на строения")]
            public bool Structure;
            
            [JsonProperty(PropertyName = "Настройка предметов для крафта",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ItemForCraft> Items;

            public Item ToItem()
            {
                var newItem = ItemManager.CreateByName(ShortName, 1, SkinID);
                if (newItem == null)
                {
                    Debug.LogError($"Error creating item with ShortName: '{ShortName}'");
                    return null;
                }

                if (!DisplayName.IsNullOrEmpty()) newItem.name = DisplayName;

                return newItem;
            }

            public void Give(BasePlayer player)
            {
                if (player == null) return;

                var item = ToItem();
                if (item == null) return;
                
                player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
            }
        }

        private class ItemForCraft
        {
            [JsonProperty(PropertyName = "Shortname")]
            public string ShortName;

            [JsonProperty(PropertyName = "Количество")]
            public int Amount;

            [JsonProperty(PropertyName = "Скин")] public ulong SkinID;

            public ItemForCraft(string shortname, int amount, ulong skin)
            {
                ShortName = shortname;
                Amount = amount;
                SkinID = skin;
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        protected override void LoadDefaultConfig()
        {
            _config = new Configuration();
        }

        #endregion

        #region Hooks⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        private void OnServerInitialized()
        {
            _instance = this;
            
            if (!ImageLibrary) PrintWarning("IMAGE LIBRARY IS NOT INSTALLED.");

            foreach (var item in _config.CraftsList)
            {
                if (!item.ImageURL.IsNullOrEmpty())
                    ImageLibrary?.Call("AddImage", item.ImageURL, item.ImageURL);

                if (!item.Command.IsNullOrEmpty())
                    AddCovalenceCommand(item.Command, nameof(CmdGiveItem));

                if (!item.Permission.IsNullOrEmpty() && !permission.PermissionExists(item.Permission))
                    permission.RegisterPermission(item.Permission, this);
            }

            foreach (var ent in BaseNetworkable.serverEntities)
            {
                OnEntitySpawned(ent as BaseEntity);
            }
            
            cmd.AddChatCommand(_config.Command, this, nameof(CmdChatOpenUI));
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, Layer);

            foreach (var component in UnityEngine.Object.FindObjectsOfType<RecyclerComponent>())
                if (component != null)
                    component.Kill();
            
            foreach (var component in UnityEngine.Object.FindObjectsOfType<CarController>())
                if (component != null)
                    component.Kill();
            
            _config = null;
            _instance = null;
        }

        private void OnEntityBuilt(Planner held, GameObject go)
        {
            if (held == null || go == null) return;

            var player = held.GetOwnerPlayer();
            if (player == null) return;

            var entity = go.ToBaseEntity();
            if (entity == null || entity.skinID == 0) return;

            var craft = _config.CraftsList.FirstOrDefault(x => (x.Type == CraftType.Транспорт || x.Type == CraftType.Переработчик) && x.SkinID == entity.skinID);
            if (craft == null) return;

            var transform = entity.transform;
            
            var itemName = !string.IsNullOrEmpty(craft.DisplayName)
                ? craft.DisplayName
                : ItemManager.FindItemDefinition(craft.ShortName)?.displayName.translated ?? "ITEM";
            
            NextTick(() =>
            {
                if (entity != null) 
                    entity.Kill();
            });
            
            RaycastHit rHit;
            if (Physics.Raycast(transform.position + new Vector3(0, 0.1f, 0), Vector3.down, out rHit, 4f,
                LayerMask.GetMask("Construction")) && rHit.GetEntity() != null)
            {
                if (!craft.Structure)
                {
                    Reply(player, OnStruct, itemName);
                    GiveCraft(player, craft);
                    return;
                }
            }
            else
            { 
                if (!craft.Ground)
                {
                    Reply(player, OnGround, itemName);
                    GiveCraft(player, craft);
                    return;
                }
            }

            SpawnVehicle(craft.Prefab, player.userID, craft.SkinID, transform.position, transform.rotation);
        }
        
        private object CanResearchItem(BasePlayer player, Item item)
        {
            if (player == null || item == null || !_config.CraftsList.Exists(x => x.Type == CraftType.Транспорт && x.SkinID == item.skin)) return null;
            return false;
        }

        private void OnEntitySpawned(BaseEntity entity)
        {
            if (entity == null) return;

            if (entity is Recycler) 
                entity.gameObject.AddComponent<RecyclerComponent>();

            if (entity is BasicCar)
                entity.gameObject.AddComponent<CarController>();
        }

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || entity.OwnerID == 0) return;

            var recycler = entity.GetComponent<RecyclerComponent>();
            if (recycler != null)
            {
                info.damageTypes.ScaleAll(_config.Recycler.Scale);
                recycler.DDraw();
            }

            var car = entity.GetComponent<CarController>();
            if (car != null)
            {
                car.ManageDamage(info);
                car.DDraw();
            }
        }

        private object OnRecyclerToggle(Recycler recycler, BasePlayer player)
        {
            if (recycler == null || player == null) return null;

            var component = recycler.GetComponent<RecyclerComponent>();
            if (component == null) return null;

            if (!recycler.IsOn())
            {
                foreach (var obj in recycler.inventory.itemList)
                    obj.CollectedForCrafting(player);

                component.StartRecycling();
            }
            else
            {
                component.StopRecycling();
            }

            return false;
        }

        private void OnHammerHit(BasePlayer player, HitInfo info)
        {
            if (player == null || info == null) return;

            var entity = info.HitEntity;
            if (entity == null) return;

            var component = entity.GetComponent<RecyclerComponent>();
            if (component == null) return;

            if (!_config.Recycler.Available)
            {
                Reply(player, NotTake);
                return;
            }
            
            component.TryPickup(player);
        }

        #endregion

        #region Commands⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        [ConsoleCommand("UI_Crafts")]
        private void CmdConsoleCraft(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            if (!arg.HasArgs())
            {
                DrawUI(player, isFirst: true);
                return;
            }

            switch (arg.Args[0].ToLower())
            {
                case "page":
                {
                    var page = 0;
                    if (!arg.HasArgs(2) || !int.TryParse(arg.Args[1], out page)) return;

                    DrawUI(player, page);
                    break;
                }
                case "craft":
                {
                    int itemid;
                    if (!arg.HasArgs(2) || !int.TryParse(arg.Args[1], out itemid)
                                        || !(itemid >= 0 && _config.CraftsList.Count > itemid)) return;

                    var craftItem = _config.CraftsList[itemid];
                    if (craftItem == null) return;

                    if (!HasWorkbench(player, craftItem.Level))
                    {
                        Reply(player, "NOT WORKBENCH");
                        return;
                    }

                    var playerItems = player.inventory.AllItems();

                    if (!HasAllItems(playerItems, craftItem))
                    {
                        Reply(player, "NOT.RESOURCES");
                        return;
                    }

                    for (var i = 0; i < craftItem.Items.Count; i++)
                    {
                        var item = craftItem.Items[i];
                        if (item == null) continue;
                        Take(playerItems, item.ShortName, item.SkinID, item.Amount);
                    }

                    GiveCraft(player, craftItem);
                    //CraftItem(player, craftItem);
                    Reply(player, "GIVED CRAFT",
                        !string.IsNullOrEmpty(craftItem.DisplayName)
                            ? craftItem.DisplayName
                            : ItemManager.FindItemDefinition(craftItem.ShortName).displayName.translated);
                    break;
                }
            }
        }

        private void CmdGiveItem(IPlayer iPlayer, string cmd, string[] args)
        {
            if (args.Length == 0) return;
            var player = BasePlayer.Find(args[0]);
            if (player == null)
            {
                Reply(iPlayer, "PLAYER NOT FOUND", args[0]);
                return;
            }

            var craftItem = _config.CraftsList.FirstOrDefault(x => x.Command == cmd);
            if (craftItem == null)
            {
                iPlayer.Reply("COMMAND NOT FOUND", cmd);
                return;
            }

            var item = craftItem.ToItem();
            if (item == null)
                return;

            var itemName = !string.IsNullOrEmpty(craftItem.DisplayName)
                ? craftItem.DisplayName
                : item.info.displayName.translated;

            player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
            Reply(player, "GIVED CRAFT", itemName);

            if (_config.useDebug) Reply(iPlayer, "GIVE.DEBUG", player.displayName, player.UserIDString, itemName);
        }

        private void CmdChatOpenUI(BasePlayer player, string cmd, string[] args)
        {
            DrawUI(player, isFirst: true);
        }

        #endregion

        #region Interface⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        private void DrawUI(BasePlayer player, int page = 0, bool isFirst = false)
        {
            var container = new CuiElementContainer();

            var playerItems = player.inventory.AllItems();

            #region First

            if (isFirst)
            {
                CuiHelper.DestroyUi(player, Layer);

                #region BG

                container.Add(new CuiPanel
                {
                    RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
                    Image =
                    {
                        Color = "0.1 0.1 0.05 0.75",
                        Sprite = "assets/content/ui/ui.background.transparent.radial.psd",
                        Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat"
                    },
                    CursorEnabled = true
                }, "Overlay", Layer);

                #endregion

                #region Title

                container.Add(new CuiLabel
                {
                    RectTransform =
                        {AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-200 200", OffsetMax = "200 300"},
                    Text =
                    {
                        Text = lang.GetMessage("Title", this, player.UserIDString), Align = TextAnchor.MiddleCenter,
                        FontSize = 28
                    }
                }, Layer);

                #endregion
            }

            #endregion

            #region Main

            container.Add(new CuiPanel
            {
                RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
                Image = {Color = "0 0 0 0"}
            }, Layer, Layer + ".Main");

            container.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = "1 1", AnchorMax = "1 1",
                    OffsetMin = "-45 -45", OffsetMax = "-5 -5"
                },
                Text =
                {
                    Text = "✕",
                    Align = TextAnchor.MiddleCenter,
                    FontSize = 28,
                    Color = "1 1 1 1"
                },
                Button =
                {
                    Color = "0 0 0 0",
                    Close = Layer
                }
            }, Layer + ".Main");

            #region Items

            var list = GetPlayerCrafts(player, page);

            if (list.Count > 0)
            {
                var xSwitch = -(220 * list.Count + 40 * (list.Count - 1)) / 2;

                for (var i = 0; i < list.Count; i++)
                {
                    var craft = list[i];

                    container.Add(new CuiPanel
                    {
                        RectTransform =
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{xSwitch} -100",
                            OffsetMax = $"{xSwitch + 220} 200"
                        },
                        Image = {Color = "0 0 0 0.5", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat"}
                    }, Layer + ".Main", Layer + $".Craft.{xSwitch}");

                    container.Add(new CuiElement
                    {
                        Parent = Layer + $".Craft.{xSwitch}",
                        Components =
                        {
                            new CuiRawImageComponent {Png = ImageLibrary.Call<string>("GetImage", craft.ImageURL)},
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-70 0", OffsetMax = "70 140"
                            }
                        }
                    });

                    container.Add(new CuiPanel
                    {
                        RectTransform =
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-85 -10", OffsetMax = "85 -5"
                        },
                        Image = {Color = "1 1 1 1", Sprite = "assets/content/ui/gameui/compass/alpha_mask.png"}
                    }, Layer + $".Craft.{xSwitch}");

                    container.Add(new CuiLabel
                    {
                        RectTransform =
                            {AnchorMin = "0 0.5", AnchorMax = "1 0.5", OffsetMin = "0 -130", OffsetMax = "0 -25"},
                        Text =
                        {
                            Text = string.Join("\n", craft.Description), Align = TextAnchor.UpperCenter,
                            FontSize = 14
                        }
                    }, Layer + $".Craft.{xSwitch}");

                    container.Add(new CuiPanel
                    {
                        RectTransform =
                            {AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 -50", OffsetMax = "0 -5"},
                        Image =
                        {
                            Color = HexToCuiColor(_config.Workbenchs[craft.Level].Color),
                            Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat"
                        }
                    }, Layer + $".Craft.{xSwitch}", Layer + $".Craft.{xSwitch}.Workbench");

                    container.Add(new CuiLabel
                    {
                        RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
                        Text =
                        {
                            Text = _config.Workbenchs[craft.Level].Title, Align = TextAnchor.MiddleCenter,
                            FontSize = 14
                        }
                    }, Layer + $".Craft.{xSwitch}.Workbench");

                    var active = HasAllItems(playerItems, craft) && HasWorkbench(player, craft.Level);
                    container.Add(new CuiButton
                    {
                        RectTransform =
                            {AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 -105", OffsetMax = "0 -55"},
                        Button =
                        {
                            Command = active ? $"UI_Crafts craft {_config.CraftsList.IndexOf(craft)}" : "",
                            Color = active ? HexToCuiColor(_config.GreenColor) : "0 0 0 0.5",
                            Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat",
                            Close = active ? Layer : ""
                        },
                        Text =
                        {
                            Text = lang.GetMessage("CREATE", this, player.UserIDString),
                            Align = TextAnchor.MiddleCenter, FontSize = 24
                        }
                    }, Layer + $".Craft.{xSwitch}");

                    xSwitch += 260;
                }
            }
            else
            {
                container.Add(new CuiLabel
                {
                    RectTransform =
                    {
                        AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-250 -150", OffsetMax = "250 150"
                    },
                    Text =
                    {
                        Text = lang.GetMessage("NOT CRAFTS", this, player.UserIDString),
                        Align = TextAnchor.MiddleCenter, FontSize = 34
                    }
                }, Layer + ".Main");
            }

            #endregion

            #region Pages

            if (list.Count > 0)
            {
                container.Add(new CuiButton
                {
                    RectTransform =
                        {AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "5 -25", OffsetMax = "55 25"},
                    Button =
                    {
                        Command = page > 0 ? $"UI_Crafts page {page - 1}" : "",
                        Color = "0 0 0 0"
                    },
                    Text =
                    {
                        Text = "<", Align = TextAnchor.MiddleCenter, FontSize = 40,
                        Color = page > 0 ? "1 1 1 1" : "1 1 1 0.5"
                    }
                }, Layer + ".Main");

                var count = _config.CraftsList.Count(craft => craft.Enabled &&
                                                              (string.IsNullOrEmpty(craft.Permission) ||
                                                               permission.UserHasPermission(player.UserIDString,
                                                                   craft.Permission)));
                
                container.Add(new CuiButton
                {
                    RectTransform =
                        {AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-55 -25", OffsetMax = "-5 25"},
                    Button =
                    {
                        Command = count > (page + 1) * 3 ? $"UI_Crafts page {page + 1}" : "",
                        Color = "0 0 0 0"
                    },
                    Text =
                    {
                        Text = ">", Align = TextAnchor.MiddleCenter, FontSize = 40,
                        Color = count > (page + 1) * 3 ? "1 1 1 1" : "1 1 1 0.5"
                    }
                }, Layer + ".Main");
            }

            #endregion

            #endregion

            CuiHelper.DestroyUi(player, Layer + ".Main");
            CuiHelper.AddUi(player, container);
        }
        
        #endregion

        #region Utils⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        private void GiveCraft(BasePlayer player, CraftConfig cfg)
        {
            switch (cfg.Type)
            {
                case CraftType.Команда:
                {
                    var command = cfg.GiveCommand.Replace("\n", "|")
                        .Replace("%steamid%", player.UserIDString, StringComparison.OrdinalIgnoreCase).Replace(
                            "%username%",
                            player.displayName, StringComparison.OrdinalIgnoreCase);

                    foreach (var check in command.Split('|')) Server.Command(check);
                    break;
                }
                default:
                {
                    cfg.Give(player);
                    break;
                }
            }
        }

        private void CraftItem(BasePlayer player, CraftConfig item)
        {
            var defenition = ItemManager.FindItemDefinition(item.ShortName);

            var task = Pool.Get<ItemCraftTask>();
            task.blueprint = defenition.Blueprint;
            task.endTime = 0.0f;
            task.taskUID = player.inventory.crafting.taskUID + 1;
            task.owner = player;
            task.instanceData = null;
            if (task.instanceData != null)
                task.instanceData.ShouldPool = false;
            task.amount = 1;
            task.skinID = (int) item.SkinID;

            player.inventory.crafting.queue.AddLast(task);
            if (task.owner != null)
                task.owner.Command("note.craft_add", (object) task.taskUID, (object) task.blueprint.targetItem.itemid,
                    (object) 1, (object) task.skinID);
        }

        private static bool HasWorkbench(BasePlayer player, WorkbenchLevel level)
        {
            return level == WorkbenchLevel.Three ? player.HasPlayerFlag(BasePlayer.PlayerFlags.Workbench3)
                : level == WorkbenchLevel.Two ? player.HasPlayerFlag(BasePlayer.PlayerFlags.Workbench3) ||
                                                player.HasPlayerFlag(BasePlayer.PlayerFlags.Workbench2)
                : level == WorkbenchLevel.One ? player.HasPlayerFlag(BasePlayer.PlayerFlags.Workbench3) ||
                                                player.HasPlayerFlag(BasePlayer.PlayerFlags.Workbench2) ||
                                                player.HasPlayerFlag(BasePlayer.PlayerFlags.Workbench1)
                : level == WorkbenchLevel.None;
        }

        private static bool HasAllItems(IReadOnlyList<Item> items, CraftConfig craftConfig)
        {
            for (var i = 0; i < craftConfig.Items.Count; i++)
            {
                var itemForCraft = craftConfig.Items[i];

                if (ItemCount(items, itemForCraft.ShortName, itemForCraft.SkinID) < itemForCraft.Amount) return false;
            }

            return true;
        }

        private static int ItemCount(IReadOnlyList<Item> items, string shortname, ulong skin)
        {
            var result = 0;

            for (var i = 0; i < items.Count; i++)
            {
                var item = items[i];
                if (item.info.shortname == shortname && (skin == 0 || item.skin == skin))
                    result += item.amount;
            }

            return result;
        }

        private void Take(IEnumerable<Item> itemList, string shortname, ulong skinId, int iAmount)
        {
            var num1 = 0;
            if (iAmount == 0) return;

            var list = Pool.GetList<Item>();

            foreach (var item in itemList)
            {
                if (item.info.shortname != shortname ||
                    skinId != 0 && item.skin != skinId) continue;

                var num2 = iAmount - num1;
                if (num2 <= 0) continue;
                if (item.amount > num2)
                {
                    item.MarkDirty();
                    item.amount -= num2;
                    num1 += num2;
                    break;
                }

                if (item.amount <= num2)
                {
                    num1 += item.amount;
                    list.Add(item);
                }

                if (num1 == iAmount)
                    break;
            }

            foreach (var obj in list)
                obj.RemoveFromContainer();

            Pool.FreeList(ref list);
        }

        private void SpawnVehicle(string prefab, ulong owner, ulong skin, Vector3 position,
            Quaternion rotation)
        {
            var entity = GameManager.server.CreateEntity(prefab, position, rotation);
            if (entity == null) return;
            entity.skinID = skin;
            entity.OwnerID = owner;
            entity.Spawn();
        }

        private static string HexToCuiColor(string hex)
        {
            if (string.IsNullOrEmpty(hex)) hex = "#FFFFFFFF";

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8) throw new Exception(hex);

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);
            Color color = new Color32(r, g, b, a);
            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }

        private List<CraftConfig> GetPlayerCrafts(BasePlayer player, int page, int count = 3)
        {
            var result = new List<CraftConfig>();
            var skipCount = page * count;

            for (var i = 0; i < _config.CraftsList.Count; i++)
            {
                var craft = _config.CraftsList[i];

                if (i < skipCount) continue;

                if (craft.Enabled && (string.IsNullOrEmpty(craft.Permission) ||
                                      permission.UserHasPermission(player.UserIDString, craft.Permission)))
                    result.Add(craft);

                if (result.Count >= count) break;
            }

            return result;
        }
        
        private static Color HexToUnityColor(string hex)
        {
            if (string.IsNullOrEmpty(hex)) hex = "#FFFFFFFF";

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8) throw new Exception(hex);

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return color;
        }
        
        private static void SetPlayerFlag(BasePlayer player, BasePlayer.PlayerFlags f, bool b)
        {
            if (b)
            {
                if (player.HasPlayerFlag(f)) return;
                player.playerFlags |= f;
            }
            else
            {
                if (!player.HasPlayerFlag(f)) return;
                player.playerFlags &= ~f;
            }

            player.SendNetworkUpdateImmediate();
        }

        #endregion

        #region Recycler Component⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        
        private class RecyclerComponent : FacepunchBehaviour
        {
            private Recycler recycler;

            private GroundWatch groundWatch;
            private DestroyOnGroundMissing groundMissing;

            [NonSerialized] private readonly BaseEntity[] SensesResults = new BaseEntity[64];

            private void Awake()
            {
                recycler = GetComponent<Recycler>();

                if (recycler.OwnerID != 0)
                {
                    recycler.baseProtection = ScriptableObject.CreateInstance<ProtectionProperties>();
                    recycler.baseProtection.amounts = _config.Recycler.Amounts;
                    
                    groundWatch = recycler.GetOrAddComponent<GroundWatch>();

                    groundMissing = recycler.GetOrAddComponent<DestroyOnGroundMissing>();
                }
            }

            public void DDraw()
            {
                if (recycler == null)
                {
                    Kill();
                    return;
                }

                if (recycler.OwnerID == 0 || !_config.Recycler.DDraw)
                    return;

                var inSphere = BaseEntity.Query.Server.GetInSphere(recycler.transform.position, _config.Recycler.Radius,
                    SensesResults, entity => entity is BasePlayer);
                if (inSphere == 0)
                    return;

                for (var i = 0; i < inSphere; i++)
                {
                    var user = SensesResults[i] as BasePlayer;
                    if (user == null || user.IsDestroyed || !user.IsConnected || user.IsNpc ||
                        !user.userID.IsSteamId()) continue;

                    if (user.Connection.authLevel < 2) SetPlayerFlag(user, BasePlayer.PlayerFlags.IsAdmin, true);

                    user.SendConsoleCommand("ddraw.text", _config.Recycler.Delay, HexToUnityColor(_config.Recycler.Color),
                        recycler.transform.position + new Vector3(0.25f, 1, 0), 
                        string.Format(_config.Recycler.Text, recycler.health, recycler._maxHealth));

                    if (user.Connection.authLevel < 2) SetPlayerFlag(user, BasePlayer.PlayerFlags.IsAdmin, false);
                }
            }

            #region Methods

            public void StartRecycling()
            {
                if (recycler.IsOn())
                    return;

                InvokeRepeating(RecycleThink, _config.Recycler.Speed, _config.Recycler.Speed);
                Effect.server.Run(recycler.startSound.resourcePath, recycler, 0U, Vector3.zero, Vector3.zero);
                recycler.SetFlag(BaseEntity.Flags.On, true);

                recycler.SendNetworkUpdateImmediate();
            }

            public void StopRecycling()
            {
                CancelInvoke(RecycleThink);

                if (!recycler.IsOn())
                    return;

                Effect.server.Run(recycler.stopSound.resourcePath, recycler, 0U, Vector3.zero, Vector3.zero);
                recycler.SetFlag(BaseEntity.Flags.On, false);
                recycler.SendNetworkUpdateImmediate();
            }

            public void RecycleThink()
            {
                var flag = false;
                var num1 = recycler.recycleEfficiency;
                for (var slot1 = 0; slot1 < 6; ++slot1)
                {
                    var slot2 = recycler.inventory.GetSlot(slot1);
                    if (slot2 != null)
                    {
                        if (Interface.CallHook("OnRecycleItem", recycler, slot2) != null)
                        {
                            if (HasRecyclable())
                                return;
                            StopRecycling();
                            return;
                        }

                        if (slot2.info.Blueprint != null)
                        {
                            if (slot2.hasCondition)
                                num1 = Mathf.Clamp01(
                                    num1 * Mathf.Clamp(slot2.conditionNormalized * slot2.maxConditionNormalized, 0.1f,
                                        1f));
                            var num2 = 1;
                            if (slot2.amount > 1)
                                num2 = Mathf.CeilToInt(Mathf.Min(slot2.amount, slot2.info.stackable * 0.1f));
                            if (slot2.info.Blueprint.scrapFromRecycle > 0)
                            {
                                var iAmount = slot2.info.Blueprint.scrapFromRecycle * num2;
                                if (slot2.info.stackable == 1 && slot2.hasCondition)
                                    iAmount = Mathf.CeilToInt(iAmount * slot2.conditionNormalized);
                                if (iAmount >= 1)
                                    recycler.MoveItemToOutput(ItemManager.CreateByName("scrap", iAmount));
                            }

                            if (!string.IsNullOrEmpty(slot2.info.Blueprint.RecycleStat))
                            {
                                var list = Pool.GetList<BasePlayer>();
                                Vis.Entities(transform.position, 3f, list, 131072);
                                foreach (var basePlayer in list)
                                    if (basePlayer.IsAlive() && !basePlayer.IsSleeping() &&
                                        basePlayer.inventory.loot.entitySource == recycler)
                                    {
                                        basePlayer.stats.Add(slot2.info.Blueprint.RecycleStat, num2,
                                            Stats.Steam | Stats.Life);
                                        basePlayer.stats.Save();
                                    }

                                Pool.FreeList(ref list);
                            }

                            slot2.UseItem(num2);
                            using (var enumerator = slot2.info.Blueprint.ingredients.GetEnumerator())
                            {
                                while (enumerator.MoveNext())
                                {
                                    var current = enumerator.Current;
                                    if (current != null && current.itemDef.shortname != "scrap")
                                    {
                                        var num3 = current.amount / slot2.info.Blueprint.amountToCreate;
                                        var num4 = 0;
                                        if (num3 <= 1.0)
                                        {
                                            for (var index = 0; index < num2; ++index)
                                                if (Random.Range(0.0f, 1f) <= num3 * (double) num1)
                                                    ++num4;
                                        }
                                        else
                                        {
                                            num4 = Mathf.CeilToInt(
                                                Mathf.Clamp(num3 * num1 * Random.Range(1f, 1f), 0.0f, current.amount) *
                                                num2);
                                        }

                                        if (num4 > 0)
                                        {
                                            var num5 = Mathf.CeilToInt(num4 / (float) current.itemDef.stackable);
                                            for (var index = 0; index < num5; ++index)
                                            {
                                                var iAmount = num4 > current.itemDef.stackable
                                                    ? current.itemDef.stackable
                                                    : num4;
                                                if (!recycler.MoveItemToOutput(ItemManager.Create(current.itemDef,
                                                    iAmount)))
                                                    flag = true;
                                                num4 -= iAmount;
                                                if (num4 <= 0)
                                                    break;
                                            }
                                        }
                                    }
                                }

                                break;
                            }
                        }
                    }
                }

                if (!flag && HasRecyclable())
                    return;
                StopRecycling();
            }

            public bool HasRecyclable()
            {
                for (var slot1 = 0; slot1 < 6; ++slot1)
                {
                    var slot2 = recycler.inventory.GetSlot(slot1);
                    if (slot2 != null)
                    {
                        var can = Interface.CallHook("CanRecycle", recycler, slot2);
                        if (can is bool)
                            return (bool) can;

                        if (slot2.info.Blueprint != null)
                            return true;
                    }
                }

                return false;
            }

            #endregion

            #region Destroy

            public void TryPickup(BasePlayer player)
            {
                if (_config.Recycler.Building && !player.CanBuild())
                {
                    player.ChatMessage("Для этого у вас должна быть способность строить!");
                    return;
                }

                if (_config.Recycler.Owner && recycler.OwnerID != player.userID)
                {
                    player.ChatMessage("Только владелец может подбирать переработчик!");
                    return;
                }

                if (recycler.SecondsSinceDealtDamage < 30f)
                {
                    player.ChatMessage("Переработчик был недавно поврежден, вы можете забрать его через 30 секунд!");
                    return;
                }

                recycler.Kill();
                
                var craft = _config.CraftsList.FirstOrDefault(x => x.Type == CraftType.Переработчик);
                if (craft == null)
                {
                    player.ChatMessage($"Обратитесь к администратору. Переработчик не может быть выдан");
                    return;
                }
                
                _instance?.GiveCraft(player, craft);
            }

            private void OnDestroy()
            {
                CancelInvoke();

                Destroy(this);
            }

            public void Kill()
            {
                Destroy(this);
            }

            #endregion
        }
        
        #endregion

        #region Car Component⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        public class CarController : FacepunchBehaviour
        {
            public BasicCar entity;
            public BasePlayer player;
            public bool isDieing;

            private bool allowHeldItems;
            private string[] disallowedItems;

            [NonSerialized] private readonly BaseEntity[] SensesResults = new BaseEntity[64];

            private void Awake()
            {
                entity = GetComponent<BasicCar>();

                allowHeldItems = !_config.Car.ActiveItems.Disable;
                disallowedItems = _config.Car.ActiveItems.BlackList;
            }

            private void Update()
            {
                UpdateHeldItems();
                CheckWaterLevel();
            }

            public void ManageDamage(HitInfo info)
            {
                if (isDieing)
                {
                    NullifyDamage(info);
                    return;
                }

                if (info.damageTypes.GetMajorityDamageType() == DamageType.Bullet)
                    info.damageTypes.ScaleAll(200);

                if (info.damageTypes.Total() >= entity.health)
                {
                    isDieing = true;
                    NullifyDamage(info);
                    OnDeath();
                    return;
                }
            }

            public void DDraw()
            {
                if (entity == null)
                {
                    Kill();
                    return;
                }

                if (entity.OwnerID == 0)
                    return;

                var inSphere = BaseEntity.Query.Server.GetInSphere(entity.transform.position, _config.Car.Radius,
                    SensesResults, ent => ent is BasePlayer);
                if (inSphere == 0)
                    return;

                for (var i = 0; i < inSphere; i++)
                {
                    var user = SensesResults[i] as BasePlayer;
                    if (user == null || user.IsDestroyed || !user.IsConnected || user.IsNpc ||
                        !user.userID.IsSteamId()) continue;

                    if (user.Connection.authLevel < 2) SetPlayerFlag(user, BasePlayer.PlayerFlags.IsAdmin, true);

                    user.SendConsoleCommand("ddraw.text", _config.Car.Delay, HexToUnityColor(_config.Car.Color),
                        entity.transform.position + new Vector3(0.25f, 1, 0), 
                        string.Format(_config.Car.Text, entity.health, entity._maxHealth));

                    if (user.Connection.authLevel < 2) SetPlayerFlag(user, BasePlayer.PlayerFlags.IsAdmin, false);
                }
            }
            
            private void NullifyDamage(HitInfo info)
            {
                info.damageTypes = new DamageTypeList();
                info.HitEntity = null;
                info.HitMaterial = 0;
                info.PointStart = Vector3.zero;
            }

            public void UpdateHeldItems()
            {
                if (player == null)
                    return;

                var item = player.GetActiveItem();
                if (item == null || item.GetHeldEntity() == null)
                    return;

                if (disallowedItems.Contains(item.info.shortname) || !allowHeldItems)
                {
                    _instance?.Reply(player, ItemNotAllowed);
                    
                    var slot = item.position;
                    item.SetParent(null);
                    item.MarkDirty();

                    Invoke(() =>
                    {
                        if (player == null || item == null) return;
                        item.SetParent(player.inventory.containerBelt);
                        item.position = slot;
                        item.MarkDirty();
                    }, 0.15f);
                }
            }

            public void CheckWaterLevel()
            {
                if (WaterLevel.Factor(entity.WorldSpaceBounds().ToBounds()) > 0.7f)                
                    StopToDie();                
            }

            public void StopToDie(bool death = true)
            {
                if (entity != null)
                {
                    entity.SetFlag(BaseEntity.Flags.Reserved1, false, false);

                    foreach (var wheel in entity.wheels)
                    {
                        wheel.wheelCollider.motorTorque = 0;
                        wheel.wheelCollider.brakeTorque = float.MaxValue;
                    }

                    entity.GetComponent<Rigidbody>().velocity = Vector3.zero;

                    if (player != null)
                        entity.DismountPlayer(player);
                }
                if (death) OnDeath();
            }

            private void OnDeath()
            {
                isDieing = true;

                if (player != null)                
                    player.EnsureDismounted();                

                Invoke(() =>
                {
                    Effect.server.Run("assets/prefabs/npc/patrol helicopter/effects/heli_explosion.prefab", transform.position);
                    _instance.NextTick(() =>
                    {
                        if (entity != null && !entity.IsDestroyed)
                            entity.DieInstantly();
                        Destroy(this);
                    });
                }, 5f);
            }

            public void Kill()
            {
                StopToDie(false);
                Destroy(this);
            }
        }

        #endregion
        
        #region Lang⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        private const string 
            NOTRESOURCES = "NOT.RESOURCES",
            PLAYERNOTFOUND = "PLAYER NOT FOUND",
            COMMANDNOTFOUND = "COMMAND NOT FOUND",
            GIVECRAFT = "GIVECRAFT",
            GIVEDEBUG = "GIVE.DEBUG",
            NOTWORKBENCH = "NOT WORKBENCH", 
            NOTCRAFTS = "NOT CRAFTS",
            CREATE = "CREATE",
            Title = "Title",
            OnGround = "OnGround",
            BuildDistance = "BuildDistance",
            OnStruct = "OnStruct",
            NotTake = "NotTake",
            ItemNotAllowed = "ItemNotAllowed";
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [NOTRESOURCES] = "Недостаточно ресурсов",
                [PLAYERNOTFOUND] = "Игрок {0} не найден",
                [COMMANDNOTFOUND] = "Комманда {0} не найдена",
                [GIVECRAFT] = "Поздравляем! Вы получили {0}",
                [GIVEDEBUG] = "Игроку {0} ({1}) выдано: {2}",
                [NOTWORKBENCH] = "Не достаточный уровень верстака для крафта!",
                [NOTCRAFTS] = "Для Вас нет доступных крафтов",
                [CREATE] = "<b>СОЗДАТЬ</b>",
                [Title] = "<b>МЕНЮ КРАФТОВ</b>",
                [OnGround] = "{0} нельзя ставить на землю!",
                [BuildDistance] = "Установка ближе {0}м к себе запрещена!",
                [OnStruct] = "{0} нельзя ставить на строения!",
                [NotTake] = "Подбор переработчиков выключен",
                [ItemNotAllowed] = "Предмет запрещён к ношению"
            }, this);
        }

        private void Reply(BasePlayer player, string key, params object[] obj)
        {
            SendReply(player, string.Format(lang.GetMessage(key, this, player.UserIDString), obj));
        }

        private void Reply(IPlayer player, string key, params object[] obj)
        {
            player.Reply(string.Format(lang.GetMessage(key, this, player.Id), obj));
        }

        #endregion
    }
}

// --- End of file: Crafts.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/IndestructableBuildings.cs ---
// --- Original Local Path: IndestructableBuildings.cs ---

using System;
using System.Collections.Generic;

using Rust;

namespace Oxide.Plugins
{

    [Info("Indestructable Buildings", "Mughisi", "1.0.1", ResourceId=966)]
    class IndestructableBuildings : RustPlugin
    {

        #region Configuration Data

        bool configChanged;

        // Plugin settings
        string defaultChatPrefix = "Protector";
        string defaultChatPrefixColor = "#008000ff";

        string chatPrefix;
        string chatPrefixColor;

        // Plugin options
        bool defaultProtectFoundations = true;
        bool defaultProtectAllBuildingBlocks = true;
        bool defaultInformPlayer = true;
        float defaultInformInterval = 30;

        bool protectFoundations;
        bool protectAllBuildingBlocks;
        bool informPlayer;
        float informInterval;

        // Messages
        string defaultHelpText = "Damage to {0} has been disabled.";
        string defaultInformMessage = "You cannot deal damage to {0}!";

        string helpText;
        string informMessage;

        #endregion

        class OnlinePlayer
        {
            public BasePlayer Player;
            public float LastInformTime;

            public OnlinePlayer(BasePlayer player)
            {
            }
        }

        [OnlinePlayers] Hash<BasePlayer, OnlinePlayer> onlinePlayers = new Hash<BasePlayer, OnlinePlayer>();
        DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);

        protected override void LoadDefaultConfig()
        {
            Log("Created a new default configuration file.");
            Config.Clear();
            LoadVariables();
        }

        void Loaded()
        {
            LoadVariables();

            // Save config changes when required
            if (configChanged)
            {
                Log("The configuration file was updated.");
                SaveConfig();
            }
        }

        void LoadVariables()
        {
            // Settings
            chatPrefix = Convert.ToString(GetConfigValue("Settings", "ChatPrefix", defaultChatPrefix));
            chatPrefixColor = Convert.ToString(GetConfigValue("Settings", "ChatPrefixColor", defaultChatPrefixColor));

            // Options
            protectFoundations = bool.Parse(Convert.ToString(GetConfigValue("Options", "ProtectFoundations", defaultProtectFoundations)));
            protectAllBuildingBlocks = bool.Parse(Convert.ToString(GetConfigValue("Options", "ProtectAllBuildingBlocks", defaultProtectAllBuildingBlocks)));
            informPlayer = bool.Parse(Convert.ToString(GetConfigValue("Options", "StickyGrenades", defaultInformPlayer)));
            informInterval = float.Parse(Convert.ToString(GetConfigValue("Options", "InformInterval", defaultInformInterval)));

            // Messages
            helpText = Convert.ToString(GetConfigValue("Messages", "HelpText", defaultHelpText));
            informMessage = Convert.ToString(GetConfigValue("Messages", "InformMessage", defaultInformMessage));
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            var block = entity as BuildingBlock;
            if (!block) return;
            if (((block.blockDefinition.hierachyName == "foundation" || block.blockDefinition.hierachyName == "foundation.triangle") && protectFoundations) || protectAllBuildingBlocks)
                info.damageTypes = new DamageTypeList();

            if (info.damageTypes.Total() != 0f) return;

            var player = info.Initiator as BasePlayer;
            if (player && informPlayer && onlinePlayers[player].LastInformTime + informInterval < GetTimestamp())
            {
                onlinePlayers[player].LastInformTime = GetTimestamp();
                SendChatMessage(player, informMessage, (protectAllBuildingBlocks ? "buildings" : "foundations"));
            }
        }

        void OnPlayerInit(BasePlayer player) 
            => onlinePlayers[player].LastInformTime = 0f;

        void SendHelpText(BasePlayer player)
        {
            if (!protectFoundations && !protectAllBuildingBlocks) return;
            SendChatMessage(player, helpText, (protectAllBuildingBlocks ? "buildings" : "foundations"));
        }

        #region Helper Methods

        void Log(string message) 
            => Puts("{0} : {1}", Title, message);

        void SendChatMessage(BasePlayer player, string message, params object[] arguments) 
            => PrintToChat(player, $"<color={chatPrefixColor}>{chatPrefix}</color>: {message}", arguments);
        
        object GetConfigValue(string category, string setting, object defaultValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;

            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[category] = data;
                configChanged = true;
            }

            if (!data.TryGetValue(setting, out value))
            {
                value = defaultValue;
                data[setting] = value;
                configChanged = true;
            }

            return value;
        }
        private long GetTimestamp()
            => Convert.ToInt64((System.DateTime.UtcNow.Subtract(epoch)).TotalSeconds);

        #endregion

    }

}


// --- End of file: IndestructableBuildings.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/GameStoresRUST.cs ---
// --- Original Local Path: GameStoresRUST.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using WebSocketSharp;

namespace Oxide.Plugins
{
    [Info("GameStoresRUST", "HOUGAN # GAMESTORES", "0.2.8")]
    public class GameStoresRUST : RustPlugin
    {
        #region References

        [PluginReference] private Plugin ImageLibrary;

        #endregion
        
        #region Classes
        
        private static class Delays
        {
            [JsonProperty("Игроки с активными запросами к АПИ")]
            public static List<ulong> ItemList = new List<ulong>();
            [JsonProperty("Количество запросов за последнюю секунду")]
            public static int RequestPerSecond = 0;
            [JsonProperty("Ограничение запросов в секунду")]
            public static int RequestPerSecondLimit = 20; 

            public static bool CanRequest(BasePlayer player)
            {
                if (RequestPerSecond > RequestPerSecondLimit)
                {
                    return false;
                }
                
                if (ItemList.Contains(player.userID))
                {
                    player.ChatMessage($"Пожалуйста, дождитесь <<окончания>> предыдущего действия!");
                    return false;
                }
                return true;
            }

            public static void FinishRequest(BasePlayer player)
            {
                if (ItemList.Contains(player.userID))
                    ItemList.Remove(player.userID);
            }
            
            public static IEnumerator MakeRequest(BasePlayer player)
            {
                RequestPerSecond++;
                
                if (ItemList.Contains(player.userID)) yield return null;
                ItemList.Add(player.userID);
                
                yield return new WaitForSeconds(3f);
                if (ItemList.Contains(player.userID))
                    ItemList.Remove(player.userID);
            }
        }

        private class Stats
        {
            
        }
        
        private class Configuration
        {
            public class API
            {
                [JsonProperty("ИД магазина в сервисе")]
                public string ShopID = "UNDEFINED";
                [JsonProperty("ИД сервера в сервисе")]
                public string ServerID = "UNDEFINED";
                [JsonProperty("Секретный ключ (не распространяйте его)")]
                public string SecretKey = "UNDEFINED";
            }
 
            public class Interface
            {
                [JsonProperty("Включить изображение корзины")]
                public bool BucketEnable = true;
                [JsonProperty("Ссылка на изображение корзины (BUCKET - стандартное изображение)")]
                public string BucketURL = "BUCKET";  
                [JsonProperty("Количество предметов на строке")]
                public int ItemOnString = 7; 
                [JsonProperty("Количество строк в интерфейсе")]
                public int StringAmount = 3;
                [JsonProperty("Сторона одного предмета")]
                public int ItemSide = 150; 
                [JsonProperty("Отступ между предметами")]
                public int ItemMargin = 5;
            }

            public class TOP
            {
                [JsonProperty("Отправлять данные топа игроков")]
                public bool UseTop = true;
            }
            
            [JsonProperty("Настройки API плагина")]
            public API APISettings = new API();
            [JsonProperty("Настройки интерфейса плагина")]
            public Interface InterfaceSettings = new Interface();
            [JsonProperty("Настройки статистики сервера")]
            public TOP TOPSettings = new TOP();
        }

        private class WItem
        {
            public string ID;
            public string Name;
            public int ItemID;
            public int Amount;
            public string ShortName;
            public string Command;
            public string ImageUrl;

            public bool Blocked;
            public double Block_Date = 0;
            public bool IsBlueprint;
            public bool IsCommand;
            public bool IsItem;
            
            public WItem(Dictionary<string, object> data, bool show = true)
            {
                try
                {
                    if (data.ContainsKey("id")) ID = data["id"].ToString();

                    if (data.ContainsKey("name")) Name       = data["name"].ToString();
                    if (data.ContainsKey("item_id")) ItemID  = System.Convert.ToInt32(data["item_id"]);
                    if (data.ContainsKey("amount")) Amount   = System.Convert.ToInt32(data["amount"]);
                    if (data.ContainsKey("command")) Command = data["command"].ToString();
                    if (data.ContainsKey("img")) ImageUrl    = data["img"].ToString();

                    if (data.ContainsKey("blocked")) Blocked = bool.Parse(data["blocked"].ToString());

                    if (data.ContainsKey("block_date") && data["block_date"] is int)
                    {
                        double.TryParse(data["block_date"].ToString(), out Block_Date);
                    }

                    if (data.ContainsKey("type"))
                    {
                        IsBlueprint = data["type"].ToString() == "bp";
                        IsCommand   = data["type"].ToString() == "command";
                        IsItem      = data["type"].ToString() == "item";
                    }

                    if (ItemID != 0)
                    {
                        var itemInfo = ItemManager.FindItemDefinition(ItemID);
                        if (itemInfo != null) ShortName = itemInfo.shortname;
                        else if (IDToShortName.ContainsKey(ItemID))
                        {
                            itemInfo = ItemManager.FindItemDefinition(IDToShortName[ItemID]);
                            if (itemInfo == null) return;

                            ShortName = itemInfo.shortname;
                        }
                    }

                    var imageLibrary = instance.plugins.Find("ImageLibrary");
                    if (imageLibrary != null)
                    {
                        if (ItemID == 0)
                        {
                            if ((bool) imageLibrary.Call("HasImage", $"IconGS.{ID}"))
                            {
                                string probablyId = (string) imageLibrary.Call("GetImage", $"IconGS.{ID}");
                                if (!probablyId.IsNullOrEmpty() && probablyId != instance.NoImageID && probablyId != instance.LoadingImageID)
                                    ImageUrl = probablyId;
                                return;
                            }

                            if (!ImageUrl.IsNullOrEmpty())
                            {
                                imageLibrary.Call("AddImage", ImageUrl.Replace("https", "http"), $"IconGS.{ID}");
                            }
                        }
                        else
                        {
                            string probablyId = (string) imageLibrary.Call("GetImage", ShortName);
                            if (!probablyId.IsNullOrEmpty() && probablyId != instance.NoImageID && probablyId != instance.LoadingImageID)
                                ImageUrl = probablyId;
                        }
                    }
                }
                catch (NullReferenceException e)
                {
                    Interface.Oxide.LogError(JsonConvert.SerializeObject(data)); 
                }
            }
        }
        
        #endregion
        
        #region Variables

        private static bool Initialized = false;
        private static GameStoresRUST instance;
        private static Configuration Settings = new Configuration();
        private string ShopURL = "UNDEFINED";
        private int StartBalance = 0;
        public string NoImageID = "";
        public string LoadingImageID = "";
        private Coroutine LoadingCoroutine;
        private string BaseRequest => $"https://gamestores.ru/api/?shop_id={Settings.APISettings.ShopID}&secret={Settings.APISettings.SecretKey}{(!Settings.APISettings.ServerID.IsNullOrEmpty() && Settings.APISettings.ServerID != "0" && Settings.APISettings.ServerID != "1" && Settings.APISettings.ServerID != "UNDEFINED" ? $"&server={Settings.APISettings.ServerID}" : "")}"; 
        
        #endregion

        #region Interface

        private void OnServerInitialized()
        {
            if (ImageLibrary)
            {
                NoImageID = (string) ImageLibrary.Call("GetImage", "NONE");
                LoadingImageID = (string) ImageLibrary.Call("GetImage", "LOADING");
            }
            
            if (Settings.InterfaceSettings.BucketURL.Contains("http") && plugins.Find("ImageLibrary") != null)
            {
                ImageLibrary.Call("AddImage", Settings.InterfaceSettings.BucketURL, "GameStoresRUSTBucket");
                LoadingCoroutine = ServerMgr.Instance.StartCoroutine(WaitForLoad());
            }
            else
            {
                BasePlayer.activePlayerList.ForEach(OnPlayerInit);  
            }
            
            instance = this;
            if (!Settings.TOPSettings.UseTop) Unsubscribe(nameof(OnEntityDeath));
            if (!Settings.TOPSettings.UseTop) Unsubscribe(nameof(OnPlayerDisconnected));
            
            if (Settings.APISettings.ShopID == "UNDEFINED" || Settings.APISettings.SecretKey == "UNDEFINED")
            {
                PrintError($"Verify that plugin is installed correct! Some of API settings are 'UNDEFINED'");
                return;
            } 
            
            FetchShopUrl();
            timer.Every(1, () => Delays.RequestPerSecond = 0);
        }

        private IEnumerator WaitForLoad()
        {
            while (!(bool) ImageLibrary.Call("HasImage", "GameStoresRUSTBucket"))
            {  
                PrintError($"Image of bucket is loading!");
                yield return new WaitForSeconds(1);
            } 

            PrintWarning("Image of bucket loaded correct!");
            BasePlayer.activePlayerList.ForEach(OnPlayerInit); 
            yield return 0;
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                Settings = Config.ReadObject<Configuration>();
                if (Settings?.APISettings == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Error reading config, creating one new config!");
                LoadDefaultConfig();
            }
            
            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig()
        { 
            Settings = new Configuration();
        } 
        
        protected override void SaveConfig() => Config.WriteObject(Settings);

        private void Unload() 
        {
            if (Initialized) StatHandler.SendStats();
            
            if (LoadingCoroutine != null) ServerMgr.Instance.StopCoroutine(LoadingCoroutine); 
            BasePlayer.activePlayerList.ForEach(p => CuiHelper.DestroyUi(p, IconLayer));
            BasePlayer.activePlayerList.ForEach(p => CuiHelper.DestroyUi(p, StoreLayer));
        } 

        #endregion

        #region Hooks

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            StatHandler.AddStat(new StatHandler.TimeStat(player));
        }

        private void OnPlayerInit(BasePlayer player)
        {
            if (player.IsReceivingSnapshot) 
            {
                NextTick(() => OnPlayerInit(player));
                return;
            }
            
            if (Settings.InterfaceSettings.BucketEnable)
                InitializeIcon(player);
        }

        #endregion
        
        #region Stats

        private static class StatHandler
        {
            internal class Stat
            {
                [JsonProperty("dataType")]
                public string DataType;
            }
            internal class KillStat : Stat
            {
                [JsonProperty("player_id")]
                public string PlayerUserId;
                [JsonProperty("victim_id")]
                public string VictimUserID;
                [JsonProperty("type")]
                public string Type;
                [JsonProperty("time")]
                public string Time;
            }
            internal class TimeStat : Stat
            {
                [JsonProperty("player_id")]
                public string PlayerID;
                [JsonProperty("username")]
                public string PlayerName;
                [JsonProperty("played")]
                public string Played;
                [JsonProperty("time")]
                public string Time;

                public TimeStat(BasePlayer player)
                {
                    PlayerID = player.UserIDString;
                    PlayerName = player.displayName;
                    DataType = "leave";
                    Played = player.secondsConnected.ToString(); 
                    Time = CurrentTime().ToString(); 
                }
            }
             
            private static List<Stat> Stats = new List<Stat>();
            public static void AddStat(Stat stat)
            {
                Stats.Add(stat);
                
                if (Stats.Count > 10)
                {
                    SendStats(); 
                    Stats.Clear();
                }
            }

            public static void SendStats()
            {
                if (Stats.Count == 0) return; 
                
                var obj = JsonConvert.SerializeObject(Stats);
                Request($"&method=topData&data={obj}", (i,s) => {});  
                Interface.Oxide.LogInfo($"GameStores sent stats successful!");  
            }
        }

        [ConsoleCommand("sendtop")]
        private void CmdSendTop(ConsoleSystem.Arg args)
        {
            if (args.Player() != null && !args.Player().IsAdmin) return;
            
            StatHandler.SendStats();
        }
        
        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null || info.Initiator == null)
                return;

            if (Settings.TOPSettings.UseTop)
            {
                BaseEntity initiator = info.Initiator;

                if (entity as BasePlayer == null && initiator as BasePlayer == null)
                    return;
                
                StatHandler.KillStat stat = new StatHandler.KillStat();

                if (initiator as BasePlayer != null) stat.PlayerUserId = initiator.ToPlayer().UserIDString;
                else if (initiator.PrefabName.Contains("agents")) stat.PlayerUserId = "1";

                if (entity as BasePlayer != null)
                {
                    stat.VictimUserID = entity.ToPlayer().UserIDString;
                    stat.Type = entity.ToPlayer().IsSleeping() ? "sleeper" : "kill";
                }
                else if (entity.PrefabName.Contains("agents"))
                {
                    stat.VictimUserID = "1";
                    stat.Type = "kill";
                }    

                stat.DataType = "death";

                stat.Time = CurrentTime().ToString();
                StatHandler.AddStat(stat);
            }
        }
        
        #endregion

        #region Commands

        [ChatCommand("store")]
        private void CmdChatStore(BasePlayer player, string command, string[] args)
        {
            if (!Initialized)
            {
                player.ChatMessage($"Подождите, магазин загружается....");
                return;
            }
            
            if (args.Length == 1 && args[0].ToLower() == "hide")
            {
                CuiHelper.DestroyUi(player, IconLayer);
            }
            else
            {
                if (!Delays.CanRequest(player)) return;
                InitializeStore(player, 0, true);
            }
        }

        [ConsoleCommand("UI_GameStoresRUST")]
        private void CmdConsoleCommand(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player == null) return;
            if (!args.HasArgs(1)) 
            { 
                player.SendConsoleCommand("chat.say /store");
                return;
            }

            switch (args.Args[0].ToLower())
            {
                case "page":
                {
                    int page = 0;
                    if (!args.HasArgs(2) || !int.TryParse(args.Args[1], out page)) return;
                    InitializeStore(player, page, false); 
                    break;
                }
                case "help":
                {
                    string helpLayer = StoreLayer + ".Help";
                    CuiHelper.DestroyUi(player, helpLayer);
                    
                    CuiElementContainer container = new CuiElementContainer();
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                        Button = { FadeIn = 1f, Color = "0 0 0 0.9", Material = "assets/content/ui/uibackgroundblur.mat", Close = helpLayer, Command = "closemenu" },
                        Text = { Text = "" }
                    }, StoreLayer, helpLayer); 
                    
                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0 0.6", AnchorMax = "1 0.78", OffsetMax = "0 0" },
                        Text = { FadeIn = 1f, Text = "ИНСТРУКЦИЯ ПОЛЬЗОВАТЕЛЯ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 34 }
                    }, helpLayer);
                    
                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0 0.3", AnchorMax = "1 0.72", OffsetMax = "0 0" },
                        Text = { FadeIn = 1f, Text = $"Здесь вы можете забрать товары приобретенные у нас в магазине!\n" +
                                                     $"Пополнить счёт можно различными способами: электронные кошельки, карты и т.д.\n" +
                                                     $"Авторизация в магазине происходит при помощи вашего аккаунта STEAM",
                                Font = "robotocondensed-regular.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter
                        }
                    }, helpLayer);
                    
                    string addText = StartBalance > 0 ? $"<size=18>При первой авторизации вы получите в подарок <b>{StartBalance} рублей</b>!</size>" : ""; 
                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0 0.1", AnchorMax = "1 0.48", OffsetMax = "0 0" },
                        Text = { FadeIn = 1f, Text = $"{ShopURL.ToUpper()}\n" +
                                                     $"{addText}", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 32}
                    }, helpLayer);

                    CuiHelper.AddUi(player, container);
                    break;
                } 
                case "take":
                {
                    if (!args.HasArgs(3)) return;
                    
                    int index = 0, id = 0;
                    if (!int.TryParse(args.Args[1], out index) || !int.TryParse(args.Args[2], out id)) return;

                    if (args.HasArgs(5) && args.Args[3].ToLower() == "blocked")
                    {
                        double left = 0;
                        if (!double.TryParse(args.Args[4], out left)) return;
                        
                        TimeSpan span = TimeSpan.FromSeconds(left);

                        string text = "";
                        if (span.Days >= 1)
                            text += $"{span.Days} дн. ";
                        if (span.Hours >= 1)
                            text += $"{span.Hours} ч. ";
                        if (span.Minutes >= 1)
                            text += $"{span.Minutes} мин. ";
                        if (span.Seconds >= 1)
                            text += $"{span.Seconds} сек.";
                        
                        ShowNotify(player, "Вы не можете забрать этот предмет из корзины!\n" +
                                           $"До его разблокировки осталось: {text}");
                        return;
                    }
                    
                    ShowNotify(player, "Подождите, ваш запрос обрабатывается!");
                    CuiElementContainer container = new CuiElementContainer();
                    
                    if (!Delays.CanRequest(player))
                    {
                        ShowNotify(player, "Подождите, ваш предыдущий запрос ещё обрабатывается!");
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                            Button = { Color = "1 1 1 0.2", Close = StoreLayer + ".BlockPanel." + index + ".Open", Command = $"UI_GameStoresRUST take {index} {id}"},
                            Text = { Text = "" }
                        }, StoreLayer + ".BlockPanel." + index ,StoreLayer + ".BlockPanel." + index + ".Open"); 

                        CuiHelper.AddUi(player, container);
                        return;
                    }
                    
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                        Button = { FadeIn = 1f, Color = "1 1 1 0.2", Close = StoreLayer + ".BlockPanel." + index + ".Open", Command = $"UI_GameStoresRUST take {index} {id}", Material = "" },
                        Text = { Text = "" }
                    }, StoreLayer + ".BlockPanel." + index ,StoreLayer + ".BlockPanel." + index + ".Open");
                    CuiHelper.AddUi(player, container);
                    
                    LogPlayerAction(player, $"---------------------------------");
                    LogPlayerAction(player, $"Запрос на получение предмета: {id}");
                    Request($"&item=true&steam_id={player.UserIDString}&id={id}", (i, s) =>
                    {
                        switch (i)
                        {
                            case 0:
                                LogPlayerAction(player, $"API не ответило на запрос: {id}");
                                PrintError("Api does not responded to a request");
                                if (player != null)
                                {
                                    player.ChatMessage($"Непредвиденная ошибка со стороны сервера, просим прощения!");
                                    CuiHelper.DestroyUi(player, StoreLayer);
                                }
                                break;
                            case 200:
                                Dictionary<string, object> response = JsonConvert.DeserializeObject<Dictionary<string, object>>(s, new KeyValuesConverter()); 
                                if (!response.ContainsKey("data"))
                                {
                                    LogPlayerAction(player, $"Ошибка получения товара, отсутствует Data [{id}]");
                                    
                                    container.Clear();
                                    CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel." + index + ".Open");
                                    container.Add(new CuiButton
                                    {
                                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                        Button = { FadeIn = 1f, Color = "1 0.5 0.5 0.2", Close = StoreLayer + ".BlockPanel." + index + ".Open", Command = $"UI_GameStoresRUST take {index} {id}", Material = "" },  
                                        Text = { Text = "" }
                                    }, StoreLayer + ".BlockPanel." + index ,StoreLayer + ".BlockPanel." + index + ".Open");
                                    ShowNotify(player, "Произошла непредвиденная ошибка, попробуйте позже!\n" +
                                                       "Ваш предмет в безопасности, не переживайте!");
                                    CuiHelper.AddUi(player, container);
                                    return;
                                } 
                                
                                LogPlayerAction(player, $"Товар отмечен полученным [{id}]");
                                Request($"&gived=true&id={id}", (code, newResponse) =>  
                                {
                                    if (code != 200 || JsonConvert.DeserializeObject<JObject>(newResponse)["result"].ToString() != "success")
                                    {
                                        container.Clear();
                                        CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel." + index + ".Open");
                                        container.Add(new CuiButton
                                        {
                                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                            Button = { FadeIn = 1f, Color = "1 0.5 0.5 0.2", Close = StoreLayer + ".BlockPanel." + index + ".Open", Command = $"UI_GameStoresRUST take {index} {id}", Material = "" },  
                                            Text = { Text = "" }
                                        }, StoreLayer + ".BlockPanel." + index ,StoreLayer + ".BlockPanel." + index + ".Open");
                                        ShowNotify(player, "Произошла непредвиденная ошибка, попробуйте позже!\n" +
                                                           "Ваш предмет в безопасности, не переживайте!");
                                        CuiHelper.AddUi(player, container);
                                        return;
                                    }
                                    ProcessTake(player, response["data"] as Dictionary<string, object>);
                                }, player);
                                
                                container.Clear();
                                CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel." + index + ".Open");
                                container.Add(new CuiButton
                                {
                                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                    Button = { FadeIn = 1f, Color = "0.5 1 0.5 0.2", Material = "" },
                                    Text = { Text = "" }
                                }, StoreLayer + ".BlockPanel." + index ,StoreLayer + ".BlockPanel." + index + ".Open");
                                CuiHelper.AddUi(player, container);
                                break;
                            case 404:
                                LogPlayerAction(player, $"Сайт не ответило на запрос: {id}");
                                player.ChatMessage($"Непредвиденная ошибка со стороны сервера, просим прощения!");
                                CuiHelper.DestroyUi(player, StoreLayer);
                                Debug.LogError("Response code: 404, please check your configurations");
                                break;
                        }
                    }, player);
                    break;
                }
            }
        }

        #endregion

        #region Interface

        private static string StoreLayer = "UI_GameStoresRUST_Store";
        private void InitializeStore(BasePlayer player, int page, bool first = true)
        {
            CuiElementContainer container = new CuiElementContainer();

            if (first)
            {
                CuiHelper.DestroyUi(player, StoreLayer);
                container.Add(new CuiPanel 
                {
                    CursorEnabled = true,
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Image = { Color = "0 0 0 0.9", Material = "assets/content/ui/uibackgroundblur.mat" },
                }, "Overlay", StoreLayer);
                
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.8 0.9", AnchorMax = "0.935 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0", Close = StoreLayer, Command = "closemenu" },
                    Text = { Text = "ВЫХОД", Align = TextAnchor.MiddleRight, Font = "robotocondensed-regular.ttf", FontSize = 28 }
                }, StoreLayer);
            }

            CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel");
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.9", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0" }
            }, StoreLayer, StoreLayer + ".BlockPanel");
                
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1.1", OffsetMax = "0 0" },
                Text = { Text = "Подождите, мы обрабатываем ваш запрос...", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 34 }
            }, StoreLayer + ".BlockPanel", StoreLayer + ".BlockPanel.Text"); 

            CuiHelper.AddUi(player, container);

            Request($"&method=basket&steam_id={player.UserIDString}", (code, response) =>
            {    
                switch (code)  
                {
                    case 0:
                    {
                        CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel.Text");
                        CuiElementContainer secondContainer = new CuiElementContainer(); 
                        secondContainer.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                            Text = { Text = "Непредвиденная ошибка, попробуйте позже!", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 38 }  
                        }, StoreLayer + ".BlockPanel", StoreLayer + ".BlockPanel.Text"); 
                        CuiHelper.AddUi(player, secondContainer);   
                        break;
                    }  
                    case 200: 
                    {
                        var firstInfo = JsonConvert.DeserializeObject<Dictionary<string, object>>(response, new KeyValuesConverter());
                        if (firstInfo.ContainsKey("result"))
                        {
                            if (firstInfo["result"].ToString() == "fail")
                            {
                                if (firstInfo["code"].ToString() == "104")
                                {
                                    CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel.Text");
                                    CuiElementContainer secondContainer = new CuiElementContainer();
                                    secondContainer.Add(new CuiLabel
                                    {
                                        RectTransform = { AnchorMin = "0 0.1", AnchorMax = "1 1", OffsetMax = "0 0" },
                                        Text = { Text = "Ваша корзина пуста", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 34 }
                                    }, StoreLayer + ".BlockPanel", StoreLayer + ".BlockPanel.Text");
                                    CuiHelper.AddUi(player, secondContainer);
                                } 
                                if (firstInfo["code"].ToString() == "105")
                                {
                                    CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel.Text");
                                    CuiElementContainer secondContainer = new CuiElementContainer();
                                    secondContainer.Add(new CuiLabel
                                    {
                                        RectTransform = { AnchorMin = "0 0.1", AnchorMax = "1 1", OffsetMax = "0 0" },
                                        Text = { Text = "Вы не авторизованы в магазине!\n" +
                                                        "Ссылку на авторизацию вы можете найти в разделе 'помощь'", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 34 }
                                    }, StoreLayer + ".BlockPanel", StoreLayer + ".BlockPanel.Text");
                                    CuiHelper.AddUi(player, secondContainer);
                                }
                            }
                            else
                            {
                                CuiElementContainer secondContainer = new CuiElementContainer();
                                
                                if (!(firstInfo["data"] is List<object>)) 
                                {
                                    PrintError("Unkown error #1");
                                    CuiHelper.DestroyUi(player, StoreLayer);
                                    return;
                                }
                                List<object> data = firstInfo["data"] as List<object>;
                                List<WItem> wItems = new List<WItem>();
                                
                                foreach (var check in data.Skip(page * 21).Take(21))
                                {
                                    wItems.Add(new WItem(check as Dictionary<string, object>));
                                }
                                
                                secondContainer.Add(new CuiLabel
                                {
                                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.14", OffsetMax = "0 0" },
                                    Text = { Text = (page + 1).ToString(), Align = TextAnchor.MiddleCenter, FontSize = 34 }
                                }, StoreLayer + ".BlockPanel");
                                
                                secondContainer.Add(new CuiButton
                                {
                                    RectTransform = { AnchorMin = "0.4 0.14", AnchorMax = "0.4 0.14", OffsetMin = "-40 -125", OffsetMax = "125 40" },
                                    Button = { Color = "0 0 0 0", Material = "", Command = page > 0 ? $"UI_GameStoresRUST page {page - 1}" : "" },
                                    Text = { Text = "<", Color = page > 0 ? "1 1 1 1" : "1 1 1 0.2", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 80 }
                                }, StoreLayer + ".BlockPanel");
            
                                secondContainer.Add(new CuiButton
                                {
                                    RectTransform = { AnchorMin = "0.6 0.14", AnchorMax = "0.6 0.14", OffsetMin = "-125 -125", OffsetMax = "40 40" },
                                    Button = { Color = "0 0 0 0", Material = "", Command = (page + 1) * 21 < data.Count ? $"UI_GameStoresRUST page {page + 1}" : "" },
                                    Text = { Text = ">", Color = (page + 1) * 21 < data.Count ? "1 1 1 1" : "1 1 1 0.2", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 80 }
                                }, StoreLayer + ".BlockPanel");


                                double xSwitch = 0;
                                double ySwitch = 0;
                                for (int i = 0; i < Settings.InterfaceSettings.ItemOnString * Settings.InterfaceSettings.StringAmount; i++)
                                {
                                    UI_RecountPosition(ref xSwitch, ref ySwitch, i, Settings.InterfaceSettings.ItemOnString * Settings.InterfaceSettings.StringAmount); 
                
                                    secondContainer.Add(new CuiButton 
                                    {
                                        RectTransform = { AnchorMin = "0.495 0.55", AnchorMax = "0.495 0.55", OffsetMin = $"{xSwitch} {ySwitch - Settings.InterfaceSettings.ItemSide}", OffsetMax = $"{xSwitch + Settings.InterfaceSettings.ItemSide} {ySwitch}" },
                                        Button = { Color = "1 1 1 0.03", Command = $""},
                                        Text = { Text = "" } 
                                    }, StoreLayer + ".BlockPanel", StoreLayer + $".BlockPanel.{i}"); 
                                }

                                /*if (player.IsAdmin) 
                                {
                                    LogToFile("Test", "123 - " + JsonConvert.SerializeObject(wItems), this);  
                                } */
                                foreach (var check in wItems.Select((i,t) => new { A = i, B = t}))
                                {
                                    if (check.A.IsBlueprint)
                                    {
                                        if (plugins.Find("ImageLibrary") != null)
                                        {
                                            secondContainer.Add(new CuiElement
                                            {
                                                Parent = StoreLayer + ".BlockPanel." + check.B,
                                                Components =
                                                {
                                                    new CuiRawImageComponent { Png = (string) plugins.Find("ImageLibrary").Call("GetImage", "blueprintbase") },
                                                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                                                }
                                            });
                                        }
                                        else
                                        {
                                            secondContainer.Add(new CuiElement
                                            {
                                                Parent = StoreLayer + ".BlockPanel." + check.B,
                                                Components =
                                                {
                                                    new CuiRawImageComponent { Url = "https://gamestores.ru/img/games/rust/blueprintbase.png" },
                                                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                                                }
                                            });
                                        }
                                    }
                                    if (!check.A.ImageUrl.Contains("http"))
                                    {
                                        secondContainer.Add(new CuiElement
                                        {
                                            Parent = StoreLayer + ".BlockPanel." + check.B,
                                            Components =
                                            {
                                                new CuiRawImageComponent { Png = check.A.ImageUrl },
                                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                                            }
                                        });
                                    }
                                    else
                                    {
                                        secondContainer.Add(new CuiElement
                                        {
                                            Parent = StoreLayer + ".BlockPanel." + check.B,
                                            Components =
                                            {
                                                new CuiRawImageComponent { Url = check.A.ImageUrl },
                                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                                            }
                                        });
                                    }

                                    if (check.A.Amount > 1)
                                    {
                                        secondContainer.Add(new CuiLabel
                                        {
                                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 5", OffsetMax = "-5 0" },
                                            Text = { Text = "x" + check.A.Amount, Align = TextAnchor.LowerRight, Font = "robotocondensed-regular.ttf", FontSize = 24 }
                                        }, StoreLayer + ".BlockPanel." + check.B);
                                    }

                                    if (check.A.Blocked)
                                    {
                                        double left = check.A.Block_Date - CurrentTime();
                                       
                                        secondContainer.Add(new CuiButton
                                        {
                                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                            Button = { Color = "1 0.5 0.5 0.2", Command = $"UI_GameStoresRUST take {check.B} {check.A.ID} blocked {left}" }, 
                                            Text = { Text = "", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 38 }
                                        }, StoreLayer + ".BlockPanel." + check.B ,StoreLayer + ".BlockPanel." + check.B + ".Open");
                                    }
                                    else
                                    {
                                        secondContainer.Add(new CuiButton
                                        {
                                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                            Button = { Color = "0 0 0 0", Close = StoreLayer + ".BlockPanel." + check.B + ".Open", Command = $"UI_GameStoresRUST take {check.B} {check.A.ID}" },
                                            Text = { Text = "" }
                                        }, StoreLayer + ".BlockPanel." + check.B ,StoreLayer + ".BlockPanel." + check.B + ".Open");
                                    }
                                }
                                
                                CuiHelper.AddUi(player, secondContainer);
                                CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel.Text");
                            }
                        }
                        break;
                    }
                }
            }, player);
        }

        private string IconLayer = "UI_GameStoresRUST_Bucket"; 
        private void InitializeIcon(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, IconLayer);
            CuiElementContainer container = new CuiElementContainer();
            if (Settings.InterfaceSettings.BucketURL.Contains("http"))
            {
                if (ImageLibrary)
                {
                    container.Add(new CuiElement
                    {
                        Parent = "Overlay",
                        Name = IconLayer,
                        Components =
                        {
                            new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "GameStoresRUSTBucket") },
                            new CuiRectTransformComponent { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "8 -40", OffsetMax = "43 -6" }
                        }
                    });

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                        Button = { Color = "0 0 0 0", Command = "chat.say /store" },
                        Text = { Text = "" }
                    }, IconLayer);
                }
                else
                {
                    container.Add(new CuiElement
                    {
                        Parent = "Overlay",
                        Name = IconLayer,
                        Components =
                        {
                            new CuiRawImageComponent { Url = Settings.InterfaceSettings.BucketURL }, 
                            new CuiRectTransformComponent { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "8 -40", OffsetMax = "43 -6" }
                        }
                    });

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                        Button = { Color = "0 0 0 0", Command = "chat.say /store" },
                        Text = { Text = "" }
                    }, IconLayer);
                }
            }
            else
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "8 -40", OffsetMax = "43 -6" }, 
                    Button = { Color = "1 1 1 0.6", Sprite = "assets/icons/open.png", Command = "chat.say /store" }, 
                    Text = { Text = "" }
                }, "Overlay", IconLayer);
            }

            CuiHelper.AddUi(player, container);
        }

        #endregion 

        #region Utils
        
        private void ShowNotify(BasePlayer player, string text)
        {
            CuiHelper.DestroyUi(player, StoreLayer + ".Notify");
            CuiElementContainer container = new CuiElementContainer();
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.85", AnchorMax = "1 0.93", OffsetMax = "0 0" },
                Text = { FadeIn = 1f, Text = text, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 16 }
            }, StoreLayer, StoreLayer + ".Notify");

            CuiHelper.AddUi(player, container);
        }
        
        private void ProcessTake(BasePlayer player, Dictionary<string, object> obj)
        { 
            //foreach (var check in obj)
             //   PrintError(check.Key + " -> " + check.Value); 
            LogPlayerAction(player, $"Начало обработки товара");
            WItem itemInfo = new WItem(obj);
            if (itemInfo.IsItem)
            {
                LogPlayerAction(player, $"Попытка получения предмета: {itemInfo.ShortName} [{itemInfo.Amount}]");
                var info = ItemManager.FindItemDefinition(itemInfo.ShortName);
                if (info == null) return;

                var item = ItemManager.Create(info, itemInfo.Amount);
                if (!player.inventory.GiveItem(item))
                {
                    LogPlayerAction(player, $"У игрока не было места для получения предмета, предмет выброшен {itemInfo.ShortName} [{itemInfo.Amount} {player.transform.position}]");
                    
                    item.Drop(player.transform.position, Vector3.down * 3);
                    ShowNotify(player, $"Вы успешно получили предмет  › <size=20>{info.displayName.english}</size> ‹\n" +
                                       $"У вас недостаточно места в инвентаре, <b>предмет брошен</b> под ноги!");
                }
                else
                {
                    LogPlayerAction(player, $"Предмет выдан игроку в инвентарь");
                    ShowNotify(player, $"Вы успешно получили предмет  › <size=20>{info.displayName.english}</size> ‹");
                }
            }

            if (itemInfo.IsCommand)
            {
                LogPlayerAction(player, $"Попытка получения команды");
                
                string command = itemInfo.Command.Replace("\n", "|").Replace("%steamid%", player.UserIDString, StringComparison.OrdinalIgnoreCase).Replace("%username%", player.displayName, StringComparison.OrdinalIgnoreCase);
                foreach (var check in command.Split('|'))
                {
                    LogPlayerAction(player, $"Исполнение команды: {check}");
                    Server.Command(check);
                }
                
                
                ShowNotify(player, $"Вы успешно получили предмет  › <size=20>{itemInfo.Name}</size> ‹\n" +
                                   $"Теперь вам доступны новые привилегии!");
            }

            if (itemInfo.IsBlueprint)
            { 
                LogPlayerAction(player, $"Попытка получения рецепта {itemInfo.ShortName}");
                Item create = ItemManager.CreateByItemID(-996920608);
                
                var info = ItemManager.FindItemDefinition(itemInfo.ShortName);
                create.blueprintTarget = info.itemid;
                                
                if (!player.inventory.GiveItem(create))
                {
                    create.Drop(player.transform.position, Vector3.down * 3);
                    ShowNotify(player, $"Вы успешно получили рецепт предмета  › <size=20>{info.displayName.english}</size> ‹\n" +
                                       $"У вас недостаточно места в инвентаре, <b>предмет брошен</b> под ноги!");
                }
                else
                {
                    LogPlayerAction(player, $"У игрока не было места для получения рецепта, рецепт выброшен {itemInfo.ShortName} [{itemInfo.Amount} {player.transform.position}]");
                    
                    LogPlayerAction(player, $"Рецепт выдан игроку в инвентарь");
                    ShowNotify(player, $"Вы успешно получили рецепт предмета  › <size=20>{info.displayName.english}</size> ‹");
                }
            }
        }
        
        private static readonly Dictionary<int,string> IDToShortName = new Dictionary<int,string>{[-1461508848]="rifle.ak",[2115555558]="ammo.handmade.shell",[-533875561]="ammo.pistol",[1621541165]="ammo.pistol.fire",[-422893115]="ammo.pistol.hv",[815896488]="ammo.rifle",[805088543]="ammo.rifle.explosive",[449771810]="ammo.rifle.incendiary",[1152393492]="ammo.rifle.hv",[1578894260]="ammo.rocket.basic",[1436532208]="ammo.rocket.fire",[542276424]="ammo.rocket.hv",[1594947829]="ammo.rocket.smoke",[-1035059994]="ammo.shotgun",[1818890814]="ammo.shotgun.fire",[1819281075]="ammo.shotgun.slug",[1685058759]="antiradpills",[93029210]="apple",[-1565095136]="apple.spoiled",[-1775362679]="arrow.bone",[-1775249157]="arrow.fire",[-1280058093]="arrow.hv",[-420273765]="arrow.wooden",[563023711]="autoturret",[790921853]="axe.salvaged",[-337261910]="bandage",[498312426]="barricade.concrete",[504904386]="barricade.metal",[-1221200300]="barricade.sandbags",[510887968]="barricade.stone",[-814689390]="barricade.wood",[1024486167]="barricade.woodwire",[2021568998]="battery.small",[97329]="bbq",[1046072789]="trap.bear",[97409]="bed",[-1480119738]="tool.binoculars",[1611480185]="black.raspberries",[-1386464949]="bleach",[93832698]="blood",[-1063412582]="blueberries",[-1887162396]="blueprintbase",[-55660037]="rifle.bolt",[919780768]="bone.club",[-365801095]="bone.fragments",[68998734]="botabag",[-853695669]="bow.hunting",[271534758]="box.wooden.large",[-770311783]="box.wooden",[-1192532973]="bucket.water",[-307490664]="building.planner",[707427396]="burlap.shirt",[707432758]="burlap.shoes",[-2079677721]="cactusflesh",[-1342405573]="tool.camera",[-139769801]="campfire",[-1043746011]="can.beans",[2080339268]="can.beans.empty",[-171664558]="can.tuna",[1050986417]="can.tuna.empty",[-1693683664]="candycaneclub",[523409530]="candycane",[1300054961]="cctv.camera",[-2095387015]="ceilinglight",[1428021640]="chainsaw",[94623429]="chair",[1436001773]="charcoal",[1711323399]="chicken.burned",[1734319168]="chicken.cooked",[-1658459025]="chicken.raw",[-726947205]="chicken.spoiled",[-341443994]="chocholate",[1540879296]="xmasdoorwreath",[94756378]="cloth",[3059095]="coal",[3059624]="corn",[2045107609]="clone.corn",[583366917]="seed.corn",[2123300234]="crossbow",[1983936587]="crude.oil",[1257201758]="cupboard.tool",[-1144743963]="diving.fins",[-1144542967]="diving.mask",[-1144334585]="diving.tank",[1066729526]="diving.wetsuit",[-1598790097]="door.double.hinged.metal",[-933236257]="door.double.hinged.toptier",[-1575287163]="door.double.hinged.wood",[-2104481870]="door.hinged.metal",[-1571725662]="door.hinged.toptier",[1456441506]="door.hinged.wood",[1200628767]="door.key",[-778796102]="door.closer",[1526866730]="xmas.door.garland",[1925723260]="dropbox",[1891056868]="ducttape",[1295154089]="explosive.satchel",[498591726]="explosive.timed",[1755466030]="explosives",[726730162]="facialhair.style01",[-1034048911]="fat.animal",[252529905]="femalearmpithair.style01",[471582113]="femaleeyebrow.style01",[-1138648591]="femalepubichair.style01",[305916740]="female_hairstyle_01",[305916742]="female_hairstyle_03",[305916744]="female_hairstyle_05",[1908328648]="fireplace.stone",[-2078972355]="fish.cooked",[-533484654]="fish.raw",[1571660245]="fishingrod.handmade",[1045869440]="flamethrower",[1985408483]="flameturret",[97513422]="flare",[1496470781]="flashlight.held",[1229879204]="weapon.mod.flashlight",[-1722829188]="floor.grill",[1849912854]="floor.ladder.hatch",[-1266285051]="fridge",[-1749787215]="boots.frog",[28178745]="lowgradefuel",[-505639592]="furnace",[1598149413]="furnace.large",[-1779401418]="gates.external.high.stone",[-57285700]="gates.external.high.wood",[98228420]="gears",[1422845239]="geiger.counter",[277631078]="generator.wind.scrap",[115739308]="burlap.gloves",[-522149009]="gloweyes",[3175989]="glue",[718197703]="granolabar",[384204160]="grenade.beancan",[-1308622549]="grenade.f1",[-217113639]="fun.guitar",[-1580059655]="gunpowder",[-1832205789]="male_hairstyle_01",[305916741]="female_hairstyle_02",[936777834]="attire.hide.helterneck",[-1224598842]="hammer",[-1976561211]="hammer.salvaged",[-1406876421]="hat.beenie",[-1397343301]="hat.boonie",[1260209393]="bucket.helmet",[-1035315940]="burlap.headwrap",[-1381682752]="hat.candle",[696727039]="hat.cap",[-2128719593]="coffeecan.helmet",[-1178289187]="deer.skull.mask",[1351172108]="heavy.plate.helmet",[-450738836]="hat.miner",[-966287254]="attire.reindeer.headband",[340009023]="riot.helmet",[124310981]="hat.wolf",[1501403549]="wood.armor.helmet",[698310895]="hatchet",[523855532]="hazmatsuit",[2045246801]="clone.hemp",[583506109]="seed.hemp",[-148163128]="attire.hide.boots",[-132588262]="attire.hide.skirt",[-1666761111]="attire.hide.vest",[-465236267]="weapon.mod.holosight",[-1211618504]="hoodie",[2133577942]="hq.metal.ore",[-1014825244]="humanmeat.burned",[-991829475]="humanmeat.cooked",[-642008142]="humanmeat.raw",[661790782]="humanmeat.spoiled",[-1440143841]="icepick.salvaged",[569119686]="bone.armor.suit",[1404466285]="heavy.plate.jacket",[-1616887133]="jacket.snow",[-1167640370]="jacket",[-1284735799]="jackolantern.angry",[-1278649848]="jackolantern.happy",[776005741]="knife.bone",[108061910]="ladder.wooden.wall",[255101535]="trap.landmine",[-51678842]="lantern",[-789202811]="largemedkit",[516382256]="weapon.mod.lasersight",[50834473]="leather",[-975723312]="lock.code",[1908195100]="lock.key",[-1097452776]="locker",[146685185]="longsword",[-1716193401]="rifle.lr300",[193190034]="lmg.m249",[371156815]="pistol.m92",[3343606]="mace",[825308669]="machete",[830965940]="mailbox",[1662628660]="male.facialhair.style02",[1662628661]="male.facialhair.style03",[1662628662]="male.facialhair.style04",[-1832205788]="male_hairstyle_02",[-1832205786]="male_hairstyle_04",[1625090418]="malearmpithair.style01",[-1269800768]="maleeyebrow.style01",[429648208]="malepubichair.style01",[-1832205787]="male_hairstyle_03",[-1832205785]="male_hairstyle_05",[107868]="map",[997973965]="mask.balaclava",[-46188931]="mask.bandana",[-46848560]="metal.facemask",[-2066726403]="bearmeat.burned",[-2043730634]="bearmeat.cooked",[1325935999]="bearmeat",[-225234813]="deermeat.burned",[-202239044]="deermeat.cooked",[-322501005]="deermeat.raw",[-1851058636]="horsemeat.burned",[-1828062867]="horsemeat.cooked",[-1966381470]="horsemeat.raw",[968732481]="meat.pork.burned",[991728250]="meat.pork.cooked",[-253819519]="meat.boar",[-1714986849]="wolfmeat.burned",[-1691991080]="wolfmeat.cooked",[179448791]="wolfmeat.raw",[431617507]="wolfmeat.spoiled",[688032252]="metal.fragments",[-1059362949]="metal.ore",[1265861812]="metal.plate.torso",[374890416]="metal.refined",[1567404401]="metalblade",[-1057402571]="metalpipe",[-758925787]="mining.pumpjack",[-1411620422]="mining.quarry",[88869913]="fish.minnows",[-2094080303]="smg.mp5",[843418712]="mushroom",[-1569356508]="weapon.mod.muzzleboost",[-1569280852]="weapon.mod.muzzlebrake",[449769971]="pistol.nailgun",[590532217]="ammo.nailgun.nails",[3387378]="note",[1767561705]="burlap.trousers",[106433500]="pants",[-1334615971]="heavy.plate.pants",[-135651869]="attire.hide.pants",[-1595790889]="roadsign.kilt",[-459156023]="pants.shorts",[106434956]="paper",[-578028723]="pickaxe",[-586116979]="jar.pickle",[-1379225193]="pistol.eoka",[-930579334]="pistol.revolver",[548699316]="pistol.semiauto",[142147109]="planter.large",[148953073]="planter.small",[102672084]="attire.hide.poncho",[640562379]="pookie.bear",[-1732316031]="xmas.present.large",[-2130280721]="xmas.present.medium",[-1725510067]="xmas.present.small",[1974032895]="propanetank",[-225085592]="pumpkin",[509654999]="clone.pumpkin",[466113771]="seed.pumpkin",[2033918259]="pistol.python",[2069925558]="target.reactive",[-1026117678]="box.repair.bench",[1987447227]="research.table",[540154065]="researchpaper",[1939428458]="riflebody",[-288010497]="roadsign.jacket",[-847065290]="roadsigns",[3506021]="rock",[649603450]="rocket.launcher",[3506418]="rope",[569935070]="rug.bear",[113284]="rug",[1916127949]="water.salt",[-1775234707]="salvaged.cleaver",[-388967316]="salvaged.sword",[2007564590]="santahat",[-1705696613]="scarecrow",[670655301]="hazmatsuit_scientist",[1148128486]="hazmatsuit_scientist_peacekeeper",[-141135377]="weapon.mod.small.scope",[109266897]="scrap",[-527558546]="searchlight",[-1745053053]="rifle.semiauto",[1223860752]="semibody",[-419069863]="sewingkit",[-1617374968]="sheetmetal",[2057749608]="shelves",[24576628]="shirt.collared",[-1659202509]="shirt.tanktop",[2107229499]="shoes.boots",[191795897]="shotgun.double",[-1009492144]="shotgun.pump",[2077983581]="shotgun.waterpipe",[378365037]="guntrap",[-529054135]="shutter.metal.embrasure.a",[-529054134]="shutter.metal.embrasure.b",[486166145]="shutter.wood.a",[1628490888]="sign.hanging.banner.large",[1498516223]="sign.hanging",[-632459882]="sign.hanging.ornate",[-626812403]="sign.pictureframe.landscape",[385802761]="sign.pictureframe.portrait",[2117976603]="sign.pictureframe.tall",[1338515426]="sign.pictureframe.xl",[-1455694274]="sign.pictureframe.xxl",[1579245182]="sign.pole.banner.large",[-587434450]="sign.post.double",[-163742043]="sign.post.single",[-1224714193]="sign.post.town",[644359987]="sign.post.town.roof",[-1962514734]="sign.wooden.huge",[-705305612]="sign.wooden.large",[-357728804]="sign.wooden.medium",[-698499648]="sign.wooden.small",[1213686767]="weapon.mod.silencer",[386382445]="weapon.mod.simplesight",[1859976884]="skull_fire_pit",[960793436]="skull.human",[1001265731]="skull.wolf",[1253290621]="sleepingbag",[470729623]="small.oil.refinery",[1051155022]="stash.small",[865679437]="fish.troutsmall",[927253046]="smallwaterbottle",[109552593]="smg.2",[-2092529553]="smgbody",[691633666]="snowball",[-2055888649]="snowman",[621575320]="shotgun.spas12",[-2118132208]="spear.stone",[-1127699509]="spear.wooden",[-685265909]="spikes.floor",[552706886]="spinner.wheel",[1835797460]="metalspring",[-892259869]="sticks",[-1623330855]="stocking.large",[-1616524891]="stocking.small",[789892804]="stone.pickaxe",[-1289478934]="stonehatchet",[-892070738]="stones",[-891243783]="sulfur",[889398893]="sulfur.ore",[-1625468793]="supply.signal",[1293049486]="surveycharge",[1369769822]="fishtrap.small",[586484018]="syringe.medical",[110115790]="table",[1490499512]="targeting.computer",[3552619]="tarp",[1471284746]="techparts",[456448245]="smg.thompson",[110547964]="torch",[1588977225]="xmas.decoration.baubels",[918540912]="xmas.decoration.candycanes",[-471874147]="xmas.decoration.gingerbreadmen",[205978836]="xmas.decoration.lights",[-1044400758]="xmas.decoration.pinecone",[-2073307447]="xmas.decoration.star",[435230680]="xmas.decoration.tinsel",[-864578046]="tshirt",[1660607208]="tshirt.long",[260214178]="tunalight",[-1847536522]="vending.machine",[-496055048]="wall.external.high.stone",[-1792066367]="wall.external.high",[562888306]="wall.frame.cell.gate",[-427925529]="wall.frame.cell",[995306285]="wall.frame.fence.gate",[-378017204]="wall.frame.fence",[447918618]="wall.frame.garagedoor",[313836902]="wall.frame.netting",[1175970190]="wall.frame.shopfront",[525244071]="wall.frame.shopfront.metal",[-1021702157]="wall.window.bars.metal",[-402507101]="wall.window.bars.toptier",[-1556671423]="wall.window.bars.wood",[61936445]="wall.window.glass.reinforced",[112903447]="water",[1817873886]="water.catcher.large",[1824679850]="water.catcher.small",[-1628526499]="water.barrel",[547302405]="waterjug",[1840561315]="water.purifier",[-460592212]="xmas.window.garland",[3655341]="wood",[1554697726]="wood.armor.jacket",[-1883959124]="wood.armor.pants",[-481416622]="workbench1",[-481416621]="workbench2",[-481416620]="workbench3",[-1151126752]="xmas.lightstring",[-1926458555]="xmas.tree"};
        
        private void UI_RecountPosition(ref double xSwitch, ref double ySwitch, int count, int max)
        {
            var stringAmount =  Math.Ceiling((double) max / Settings.InterfaceSettings.ItemOnString);
            var currentString = Math.Floor((double) count / Settings.InterfaceSettings.ItemOnString);
            var currentPosition = count % Settings.InterfaceSettings.ItemOnString;         

            
            var topYPosition = 0 + (float) stringAmount / 2 * Settings.InterfaceSettings.ItemSide + ((float) stringAmount / 2 - 1) * Settings.InterfaceSettings.ItemMargin;
            var topXPosition = 0 - (float) Settings.InterfaceSettings.ItemOnString / 2 * Settings.InterfaceSettings.ItemSide - ((float) Settings.InterfaceSettings.ItemOnString / 2 - 1) * Settings.InterfaceSettings.ItemMargin;        

            var curYPosition = topYPosition - currentString * Settings.InterfaceSettings.ItemSide - (currentString) * Settings.InterfaceSettings.ItemMargin;
            var curXPosition = topXPosition + currentPosition * Settings.InterfaceSettings.ItemSide + (currentPosition) * Settings.InterfaceSettings.ItemMargin;  

            xSwitch = curXPosition;
            ySwitch = curYPosition;
        }

        private void FetchShopUrl()
        {
            Request($"&info=true", (code, response) =>
            {
                PrintWarning($"-----------------------------");
                PrintWarning($" GameStores {Version} (c) 2019");
                try
                {
                    var firstInfo = JsonConvert.DeserializeObject<Dictionary<string, object>>(response, new KeyValuesConverter());
                    if (!firstInfo.ContainsKey("data"))
                    {
                        PrintError($"     Wrong Secret Key");
                        PrintWarning($"-----------------------------");
                    } 
                    else
                    {  
                        firstInfo = firstInfo["data"] as Dictionary<string, object>;
                        ShopURL = firstInfo["link"].ToString(); 
                        StartBalance = int.Parse(firstInfo["default_balance"].ToString());
                        PrintWarning("      Initialized - OK");
                        PrintWarning($"-----------------------------");
            
                        BasePlayer.activePlayerList.ForEach(OnPlayerInit);
                        Initialized = true;
                    } 
                }
                catch (JsonException e)
                { 
                    LogToFile("Errors", response, this);  
                    PrintError(" JSON Error! Saved to log!");
                    PrintWarning($"-----------------------------");
                }
            });
        }

        private static void Request(string ask, Action<int, string> callback, BasePlayer player = null, bool cancel = true)
        {
            if (player != null && !Delays.CanRequest(player))
            {
                instance.ShowNotify(player, "Вы делаете слишком много запросов к серверу!\n" +
                    "Подождите <b>одну секунду</b>!");
                instance.timer.Once(1f, () =>
                {
                    CuiHelper.DestroyUi(player, StoreLayer + ".Notify");
                    Request(ask, callback, player, cancel);
                });
                return;
            };
            if (player != null) ServerMgr.Instance.StartCoroutine(Delays.MakeRequest(player));
            
            instance.webrequest.Enqueue(instance.BaseRequest + ask, "", (code, response) =>
            {
                if (instance == null) return;
                
                switch (code)
                {
                    case 0:
                    {
                        instance.PrintError($"Time out waiting for GS API #1");
                        break; 
                    }
                    case 404:
                    {
                        instance.PrintError($"Plese check your configuration! [404] #2");
                        break;
                    }
                }
                if (player != null && cancel) Delays.FinishRequest(player);

                callback?.Invoke(code, response);
            }, instance, RequestMethod.GET);
        }
 
        private void LogPlayerAction(BasePlayer player, string text) => LogToFile($"{player.userID}", $"{DateTime.Now.ToShortTimeString()} {text}", this);
        private static double CurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;

        #endregion
    }
}


// --- End of file: GameStoresRUST.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Godmode.cs ---
// --- Original Local Path: Godmode.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust;
using Rust;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("Godmode", "Wulf/lukespragg/Arainrr/dFxPhoeniX", "4.2.14")]
    [Description("Allows players with permission to be invulnerable and god-like")]
    internal class Godmode : RustPlugin
    {
        #region Fields

        private const string PermAdmin = "godmode.admin";
        private const string PermInvulnerable = "godmode.invulnerable";
        private const string PermLootPlayers = "godmode.lootplayers";
        private const string PermLootProtection = "godmode.lootprotection";
        private const string PermNoAttacking = "godmode.noattacking";
        private const string PermToggle = "godmode.toggle";
        private const string PermUntiring = "godmode.untiring";
        private const string PermAutoEnable = "godmode.autoenable";

        private readonly object _false = false, _true = true;
        private Dictionary<ulong, float> _informHistory;
        private readonly StoredMetabolism _storedMetabolism = new StoredMetabolism();

        #endregion Fields

        #region Oxide Hook

        private void Init()
        {
            LoadData();
            permission.RegisterPermission(PermAdmin, this);
            permission.RegisterPermission(PermInvulnerable, this);
            permission.RegisterPermission(PermLootPlayers, this);
            permission.RegisterPermission(PermLootProtection, this);
            permission.RegisterPermission(PermNoAttacking, this);
            permission.RegisterPermission(PermToggle, this);
            permission.RegisterPermission(PermUntiring, this);
            permission.RegisterPermission(PermAutoEnable, this);

            AddCovalenceCommand(configData.godCommand, nameof(GodCommand));
            AddCovalenceCommand(configData.godsCommand, nameof(GodsCommand));
            if (configData.informOnAttack)
            {
                _informHistory = new Dictionary<ulong, float>();
            }
            if (!configData.disconnectDisable)
            {
                Unsubscribe(nameof(OnPlayerDisconnected));
            }
        }

        private void OnServerInitialized()
        {
            if (!_storedMetabolism.FetchDefaultMetabolism())
            {
                PrintError("Failed to fetch default metabolism data");
            }
            foreach (var god in storedData.godPlayers.ToArray())
            {
                if (!permission.UserHasPermission(god, PermToggle))
                {
                    storedData.godPlayers.Remove(god);
                    continue;
                }
                EnableGodmode(god, true);
            }
            CheckHooks();
        }

        private void OnServerSave()
        {
            timer.Once(Random.Range(0f, 60f), SaveData);
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (IsGod(player))
            {
                PlayerRename(player, true);
                ModifyMetabolism(player, true);
            }
            else if (permission.UserHasPermission(player.UserIDString, PermAutoEnable))
            {
                EnableGodmode(player.UserIDString);
            }
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (IsGod(player))
            {
                DisableGodmode(player.UserIDString);
            }
        }

        private void Unload()
        {
            foreach (var god in storedData.godPlayers.ToArray())
            {
                DisableGodmode(god, true);
            }
            SaveData();
        }

        private object CanBeWounded(BasePlayer player)
        {
            return IsGod(player) ? _false : null;
        }

        private object CanLootPlayer(BasePlayer target, BasePlayer looter)
        {
            if (target == null || looter == null || target == looter)
            {
                return null;
            }
            if (IsGod(target) && permission.UserHasPermission(target.UserIDString, PermLootProtection) && !permission.UserHasPermission(looter.UserIDString, PermLootPlayers))
            {
                Print(looter, Lang("NoLooting", looter.UserIDString));
                return _false;
            }
            return null;
        }

        private object OnEntityTakeDamage(BasePlayer player, HitInfo info)
        {
            if (player == null || !player.userID.IsSteamId())
            {
                return null;
            }
            var attacker = info?.InitiatorPlayer;
            if (IsGod(player) && permission.UserHasPermission(player.UserIDString, PermInvulnerable))
            {
                InformPlayers(player, attacker);
                NullifyDamage(ref info);
                return _true;
            }
            if (IsGod(attacker) && permission.UserHasPermission(attacker.UserIDString, PermNoAttacking))
            {
                InformPlayers(player, attacker);
                NullifyDamage(ref info);
                return _true;
            }
            return null;
        }

        private object OnRunPlayerMetabolism(PlayerMetabolism metabolism, BasePlayer player, float delta)
        {
            if (!IsGod(player))
            {
                return null;
            }
            metabolism.hydration.value = _storedMetabolism.GetMaxHydration();
            if (!permission.UserHasPermission(player.UserIDString, PermUntiring))
            {
                return null;
            }
            var currentCraftLevel = player.currentCraftLevel;
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench1, currentCraftLevel == 1f);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench2, currentCraftLevel == 2f);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench3, currentCraftLevel == 3f);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.SafeZone, player.InSafeZone());
            return _false;
        }

        #endregion Oxide Hook

        #region Methods

        private void CheckHooks()
        {
            if (storedData.godPlayers.Count > 0)
            {
                Subscribe(nameof(CanBeWounded));
                Subscribe(nameof(CanLootPlayer));
                Subscribe(nameof(OnEntityTakeDamage));
                Subscribe(nameof(OnRunPlayerMetabolism));
            }
            else
            {
                Unsubscribe(nameof(CanBeWounded));
                Unsubscribe(nameof(CanLootPlayer));
                Unsubscribe(nameof(OnEntityTakeDamage));
                Unsubscribe(nameof(OnRunPlayerMetabolism));
            }
        }

        private void InformPlayers(BasePlayer victim, BasePlayer attacker)
        {
            if (!configData.informOnAttack || victim == null || attacker == null || victim == attacker)
            {
                return;
            }
            if (!victim.userID.IsSteamId() || !attacker.userID.IsSteamId())
            {
                return;
            }
            float victimTime;
            if (!_informHistory.TryGetValue(victim.userID.Get(), out victimTime))
            {
                _informHistory.Add(victim.userID.Get(), 0);
            }
            float attackerTime;
            if (!_informHistory.TryGetValue(attacker.userID.Get(), out attackerTime))
            {
                _informHistory.Add(attacker.userID.Get(), 0);
            }
            var currentTime = Time.realtimeSinceStartup;
            if (IsGod(victim))
            {
                if (currentTime - victimTime > configData.informInterval)
                {
                    _informHistory[victim.userID.Get()] = currentTime;
                    Print(attacker, Lang("InformAttacker", attacker.UserIDString, victim.displayName));
                }
                if (currentTime - attackerTime > configData.informInterval)
                {
                    _informHistory[attacker.userID.Get()] = currentTime;
                    Print(victim, Lang("InformVictim", victim.UserIDString, attacker.displayName));
                }
            }
            else if (IsGod(attacker))
            {
                if (currentTime - victimTime > configData.informInterval)
                {
                    _informHistory[victim.userID.Get()] = currentTime;
                    Print(attacker, Lang("CantAttack", attacker.UserIDString, victim.displayName));
                }
                if (currentTime - attackerTime > configData.informInterval)
                {
                    _informHistory[attacker.userID.Get()] = currentTime;
                    Print(victim, Lang("InformVictim", victim.UserIDString, attacker.displayName));
                }
            }
        }

        #region Godmode Toggle

        private bool? ToggleGodmode(BasePlayer target, BasePlayer player)
        {
            var isGod = IsGod(target);
            if (Interface.CallHook("OnGodmodeToggle", target.UserIDString, !isGod) != null)
            {
                return null;
            }
            if (isGod)
            {
                DisableGodmode(target.UserIDString);
                if (player != null)
                {
                    if (target == player)
                    {
                        Print(player, Lang("GodmodeDisabled", player.UserIDString));
                    }
                    else
                    {
                        Print(player, Lang("GodmodeDisabledFor", player.UserIDString, target.displayName));
                        Print(target, Lang("GodmodeDisabledBy", target.UserIDString, player.displayName));
                    }
                }
                else
                {
                    Print(target, Lang("GodmodeDisabledBy", target.UserIDString, "server console"));
                }
                return false;
            }

            EnableGodmode(target.UserIDString);
            if (player != null)
            {
                if (target == player)
                {
                    Print(player, Lang("GodmodeEnabled", player.UserIDString));
                }
                else
                {
                    Print(player, Lang("GodmodeEnabledFor", player.UserIDString, target.displayName));
                    Print(target, Lang("GodmodeEnabledBy", target.UserIDString, player.displayName));
                }
            }
            else
            {
                Print(target, Lang("GodmodeEnabledBy", target.UserIDString, "server console"));
            }
            var targetId = target.UserIDString;
            if (configData.timeLimit > 0)
            {
                timer.Once(configData.timeLimit, () => DisableGodmode(targetId));
            }
            return true;
        }

        private bool EnableGodmode(string playerId, bool isInit = false)
        {
            if (string.IsNullOrEmpty(playerId) || !isInit && IsGod(playerId))
            {
                return false;
            }
            var player = RustCore.FindPlayerByIdString(playerId);
            if (player == null)
            {
                return false;
            }
            PlayerRename(player, true);
            ModifyMetabolism(player, true);
            if (!isInit)
            {
                storedData.godPlayers.Add(player.UserIDString);
                CheckHooks();
            }
            Interface.CallHook("OnGodmodeToggled", playerId, true);
            return true;
        }

        private bool DisableGodmode(string playerId, bool isUnload = false)
        {
            if (string.IsNullOrEmpty(playerId) || !IsGod(playerId))
            {
                return false;
            }
            var player = RustCore.FindPlayerByIdString(playerId);
            if (player == null)
            {
                return false;
            }
            PlayerRename(player, false);
            ModifyMetabolism(player, false);
            if (!isUnload)
            {
                storedData.godPlayers.Remove(player.UserIDString);
                CheckHooks();
            }
            Interface.CallHook("OnGodmodeToggled", playerId, false);
            return true;
        }

        private void PlayerRename(BasePlayer player, bool isGod)
        {
            if (player == null || !configData.showNamePrefix || string.IsNullOrEmpty(configData.namePrefix))
            {
                return;
            }
            var originalName = GetPayerOriginalName(player.userID.Get());
            if (isGod)
            {
                Rename(player, configData.namePrefix + originalName);
            }
            else
            {
                Rename(player, originalName);
            }
        }

        private void Rename(BasePlayer player, string newName)
        {
            if (player == null || string.IsNullOrEmpty(newName.Trim()))
            {
                return;
            }
            player._name = player.displayName = newName;
            if (player.IPlayer != null)
            {
                player.IPlayer.Name = newName;
            }
            if (player.net?.connection != null)
            {
                player.net.connection.username = newName;
            }
            permission.UpdateNickname(player.UserIDString, newName);
            Player.Teleport(player, player.transform.position);
            player.SendNetworkUpdateImmediate();
            //SingletonComponent<ServerMgr>.Instance.persistance.SetPlayerName(player.userID.Get(), newName);
        }

        private void ModifyMetabolism(BasePlayer player, bool isGod)
        {
            if (player == null || player.metabolism == null)
            {
                return;
            }
            if (isGod)
            {
                player.health = player.MaxHealth();
                _storedMetabolism.Unlimited(player.metabolism);
            }
            else
            {
                player.health = player.MaxHealth();
                _storedMetabolism.Restore(player.metabolism);
            }
        }

        #endregion Godmode Toggle

        #region Stored Metabolism

        private class StoredMetabolism
        {
            private struct Attribute
            {
                public float Min { get; private set; }
                public float Max { get; private set; }

                public Attribute(MetabolismAttribute attribute)
                {
                    Min = attribute.min;
                    Max = attribute.max;
                }

                public void Reset(MetabolismAttribute attribute)
                {
                    attribute.min = Min;
                    attribute.max = Max;
                }
            }

            public bool FetchDefaultMetabolism()
            {
                var playerPrefab = "assets/prefabs/player/player.prefab";
                var playerMetabolism = GameManager.server.FindPrefab(playerPrefab)?.GetComponent<PlayerMetabolism>();
                if (playerMetabolism != null)
                {
                    Store(playerMetabolism);
                    return true;
                }
                return false;
            }

            private Attribute calories;
            private Attribute hydration;
            private Attribute heartrate;
            private Attribute temperature;
            private Attribute poison;
            private Attribute radiation_level;
            private Attribute radiation_poison;
            private Attribute wetness;
            private Attribute dirtyness;
            private Attribute oxygen;
            private Attribute bleeding;

            // private Attribute comfort;
            // private Attribute pending_health;
            public float GetMaxHydration()
            {
                return hydration.Max;
            }
            public void Store(PlayerMetabolism playerMetabolism)
            {
                calories = new Attribute(playerMetabolism.calories);
                hydration = new Attribute(playerMetabolism.hydration);
                heartrate = new Attribute(playerMetabolism.heartrate);
                temperature = new Attribute(playerMetabolism.temperature);
                poison = new Attribute(playerMetabolism.poison);
                radiation_level = new Attribute(playerMetabolism.radiation_level);
                radiation_poison = new Attribute(playerMetabolism.radiation_poison);
                wetness = new Attribute(playerMetabolism.wetness);
                dirtyness = new Attribute(playerMetabolism.dirtyness);
                oxygen = new Attribute(playerMetabolism.oxygen);
                bleeding = new Attribute(playerMetabolism.bleeding);
                // comfort = new Attribute(playerMetabolism.comfort);
                // pending_health = new Attribute(playerMetabolism.pending_health);
            }

            public void Unlimited(PlayerMetabolism playerMetabolism)
            {
                playerMetabolism.calories.min = calories.Max;
                playerMetabolism.calories.value = calories.Max;
                // playerMetabolism.hydration.min = hydration.Max; // It causes the character to walk slowly
                playerMetabolism.hydration.value = hydration.Max;
                playerMetabolism.heartrate.min = heartrate.Max;
                playerMetabolism.heartrate.value = heartrate.Max;
                playerMetabolism.temperature.min = 37;
                playerMetabolism.temperature.max = 37;
                playerMetabolism.temperature.value = 37;
                playerMetabolism.poison.max = poison.Min;
                playerMetabolism.poison.value = poison.Min;
                playerMetabolism.radiation_level.max = radiation_level.Min;
                playerMetabolism.radiation_level.value = radiation_level.Min;
                playerMetabolism.radiation_poison.max = radiation_poison.Min;
                playerMetabolism.radiation_poison.value = radiation_poison.Min;
                playerMetabolism.wetness.max = wetness.Min;
                playerMetabolism.wetness.value = wetness.Min;
                playerMetabolism.dirtyness.max = dirtyness.Min;
                playerMetabolism.dirtyness.value = dirtyness.Min;
                playerMetabolism.oxygen.min = oxygen.Max;
                playerMetabolism.oxygen.value = oxygen.Max;
                playerMetabolism.bleeding.max = bleeding.Min;
                playerMetabolism.bleeding.value = bleeding.Min;

                playerMetabolism.SendChangesToClient();
            }

            public void Restore(PlayerMetabolism playerMetabolism)
            {
                calories.Reset(playerMetabolism.calories);
                hydration.Reset(playerMetabolism.hydration);
                heartrate.Reset(playerMetabolism.heartrate);
                temperature.Reset(playerMetabolism.temperature);
                poison.Reset(playerMetabolism.poison);
                radiation_level.Reset(playerMetabolism.radiation_level);
                radiation_poison.Reset(playerMetabolism.radiation_poison);
                wetness.Reset(playerMetabolism.wetness);
                dirtyness.Reset(playerMetabolism.dirtyness);
                oxygen.Reset(playerMetabolism.oxygen);
                bleeding.Reset(playerMetabolism.bleeding);
                // comfort.Reset(playerMetabolism.comfort);
                // pending_health.Reset(playerMetabolism.pending_health);

                playerMetabolism.Reset();

                playerMetabolism.calories.value = calories.Max;
                playerMetabolism.hydration.value = hydration.Max;

                playerMetabolism.SendChangesToClient();
            }
        }

        #endregion Stored Metabolism

        #endregion Methods

        #region Helpers

        private static void NullifyDamage(ref HitInfo info)
        {
            info.damageTypes = new DamageTypeList();
            info.HitMaterial = 0;
            info.PointStart = Vector3.zero;
        }

        private static string GetPayerOriginalName(ulong playerId)
        {
            return SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(playerId);
        }

        #endregion Helpers

        #region API

        private bool EnableGodmode(IPlayer iPlayer)
        {
            return EnableGodmode(iPlayer.Id);
        }

        private bool EnableGodmode(ulong playerId)
        {
            return EnableGodmode(playerId.ToString());
        }

        private bool DisableGodmode(IPlayer iPlayer)
        {
            return DisableGodmode(iPlayer.Id);
        }

        private bool DisableGodmode(ulong playerId)
        {
            return DisableGodmode(playerId.ToString());
        }

        private bool IsGod(ulong playerId)
        {
            return IsGod(playerId.ToString());
        }

        private bool IsGod(BasePlayer player)
        {
            return player != null && IsGod(player.UserIDString);
        }

        private bool IsGod(string playerId)
        {
            return storedData.godPlayers.Contains(playerId);
        }

        private string[] AllGods(string playerId) => AllGods();
        private string[] AllGods()
        {
            return storedData.godPlayers.ToArray();
        }

        #endregion API

        #region Commands

        private void GodCommand(IPlayer iPlayer, string command, string[] args)
        {
            if (args.Length > 0 && !iPlayer.HasPermission(PermAdmin) || !iPlayer.HasPermission(PermToggle))
            {
                Print(iPlayer, Lang("NotAllowed", iPlayer.Id, command));
                return;
            }
            if (args.Length == 0 && iPlayer.Id == "server_console")
            {
                Print(iPlayer, $"The server console cannot use {command}");
                return;
            }
            var target = args.Length > 0 ? RustCore.FindPlayer(args[0]) : iPlayer.Object as BasePlayer;
            if (args.Length > 0 && target == null)
            {
                Print(iPlayer, Lang("PlayerNotFound", iPlayer.Id, args[0]));
                return;
            }
            var obj = ToggleGodmode(target, iPlayer.Object as BasePlayer);
            if (obj.HasValue && iPlayer.Id == "server_console" && args.Length > 0)
            {
                if (obj.Value)
                {
                    Print(iPlayer, $"'{target?.displayName}' have enabled godmode");
                }
                else
                {
                    Print(iPlayer, $"'{target?.displayName}' have disabled godmode");
                }
            }
        }

        private void GodsCommand(IPlayer iPlayer, string command, string[] args)
        {
            if (!iPlayer.HasPermission(PermAdmin))
            {
                Print(iPlayer, Lang("NotAllowed", iPlayer.Id, command));
                return;
            }
            if (storedData.godPlayers.Count == 0)
            {
                Print(iPlayer, Lang("NoGods", iPlayer.Id));
                return;
            }
            var stringBuilder = new StringBuilder();
            stringBuilder.AppendLine();
            foreach (var god in storedData.godPlayers)
            {
                var player = RustCore.FindPlayerByIdString(god);
                stringBuilder.AppendLine(player == null ? god : player.ToString());
            }
            Print(iPlayer, stringBuilder.ToString());
        }

        #endregion Commands

        #region ConfigurationFile

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Inform On Attack (true/false)")]
            public bool informOnAttack = true;

            [JsonProperty(PropertyName = "Inform Interval (Seconds)")]
            public float informInterval = 15;

            [JsonProperty(PropertyName = "Show Name Prefix (true/false)")]
            public bool showNamePrefix = true;

            [JsonProperty(PropertyName = "Name Prefix (Default [God])")]
            public string namePrefix = "[God] ";

            [JsonProperty(PropertyName = "Time Limit (Seconds, 0 to Disable)")]
            public float timeLimit = 0f;

            [JsonProperty(PropertyName = "Disable godmode after disconnect (true/false)")]
            public bool disconnectDisable = false;

            [JsonProperty(PropertyName = "Chat Prefix")]
            public string prefix = "[Godmode]:";

            [JsonProperty(PropertyName = "Chat Prefix color")]
            public string prefixColor = "#00FFFF";

            [JsonProperty(PropertyName = "Chat steamID icon")]
            public ulong steamIDIcon = 0;

            [JsonProperty(PropertyName = "God commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public string[] godCommand = { "god", "godmode" };

            [JsonProperty(PropertyName = "Gods commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public string[] godsCommand = { "gods", "godlist" };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(configData);
        }

        #endregion ConfigurationFile

        #region DataFile

        private StoredData storedData;

        private class StoredData
        {
            public readonly HashSet<string> godPlayers = new HashSet<string>();
        }

        private void LoadData()
        {
            try
            {
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch
            {
                storedData = null;
            }
            if (storedData == null)
            {
                ClearData();
            }
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
        }

        private void ClearData()
        {
            storedData = new StoredData();
            SaveData();
        }

        #endregion DataFile

        #region LanguageFile

        private void Print(IPlayer iPlayer, string message)
        {
            iPlayer?.Reply(message,
                           iPlayer.Id == "server_console"
                                   ? $"{configData.prefix}"
                                   : $"<color={configData.prefixColor}>{configData.prefix}</color>");
        }

        private void Print(BasePlayer player, string message)
        {
            Player.Message(player, message, string.IsNullOrEmpty(configData.prefix) ? string.Empty : $"<color={configData.prefixColor}>{configData.prefix}</color>", configData.steamIDIcon);
        }

        private string Lang(string key, string id = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, id), args);
            }
            catch (Exception)
            {
                PrintError($"Error in the language formatting of '{key}'. (userid: {id}. lang: {lang.GetLanguage(id)}. args: {string.Join(" ,", args)})");
                throw;
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["GodmodeDisabled"] = "You have <color=#FF4500>Disabled</color> godmode",
                ["GodmodeDisabledBy"] = "Your godmode has been <color=#FF4500>Disabled</color> by {0}",
                ["GodmodeDisabledFor"] = "You have <color=#FF4500>Disabled</color> godmode for {0}",
                ["GodmodeEnabled"] = "You have <color=#FF4500>Enabled</color> godmode",
                ["GodmodeEnabledBy"] = "Your godmode has been <color=#FF4500>Enabled</color> by {0}",
                ["GodmodeEnabledFor"] = "You have <color=#FF4500>Enabled</color> godmode for {0}",
                ["InformAttacker"] = "{0} is in godmode and can't take any damage",
                ["InformVictim"] = "{0} just tried to deal damage to you",
                ["CantAttack"] = "You are in godmode and can't attack {0}",
                ["NoGods"] = "No players currently have godmode enabled",
                ["NoLooting"] = "You are not allowed to loot a player with godmode",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["PlayerNotFound"] = "Player '{0}' was not found"
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["GodmodeDisabled"] = "Ai <color=#FF4500>dezactivat</color> godmode",
                ["GodmodeDisabledBy"] = "Godmode-ul tău a fost <color=#FF4500>dezactivat</color> de către {0}",
                ["GodmodeDisabledFor"] = "Ai <color=#FF4500>dezactivat</color> godmode pentru {0}",
                ["GodmodeEnabled"] = "Ai <color=#FF4500>activat</color> godmode",
                ["GodmodeEnabledBy"] = "Godmode-ul tău a fost <color=#FF4500>activat</color> de către {0}",
                ["GodmodeEnabledFor"] = "Ai <color=#FF4500>activat</color> godmode pentru {0}",
                ["InformAttacker"] = "{0} este în godmode și nu poate primi daune",
                ["InformVictim"] = "{0} a încercat să-ți provoace daune",
                ["CantAttack"] = "Ești în godmode și nu-l poți ataca pe {0}",
                ["NoGods"] = "Momentan nu există jucători cu godmode activat",
                ["NoLooting"] = "Nu ai permisiunea de a fura de la un jucător cu godmode",
                ["NotAllowed"] = "Nu ai permisiunea de a utiliza comanda '{0}'",
                ["PlayerNotFound"] = "Jucătorul '{0}' nu a fost găsit"
            }, this, "ro");
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["GodmodeDisabled"] = "您的上帝模式 <color=#FF4500>已禁用</color>",
                ["GodmodeDisabledBy"] = "{0} <color=#FF4500>禁用了</color> 您的上帝模式",
                ["GodmodeDisabledFor"] = "您 <color=#FF4500>禁用了</color> {0} 的上帝模式",
                ["GodmodeEnabled"] = "您的上帝模式 <color=#FF4500>已启用</color>",
                ["GodmodeEnabledBy"] = "{0} <color=#FF4500>启用了</color> 您的上帝模式",
                ["GodmodeEnabledFor"] = "您 <color=#FF4500>启用了</color> {0} 的上帝模式",
                ["InformAttacker"] = "{0} 处于上帝模式，您不能伤害他",
                ["InformVictim"] = "{0} 想伤害您",
                ["CantAttack"] = "您处于上帝模式，不能伤害 {0}",
                ["NoGods"] = "当前没有玩家启用上帝模式",
                ["NoLooting"] = "您不能掠夺处于上帝模式的玩家",
                ["NotAllowed"] = "您没有权限使用 '{0}' 命令",
                ["PlayerNotFound"] = "玩家 '{0}' 未找到"
            }, this, "zh-CN");
        }

        #endregion LanguageFile
    }
}

// --- End of file: Godmode.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/UberTool (2).cs ---
// --- Original Local Path: UberTool (2).cs ---

using System; using System.Collections.Generic; using System.Collections; using System.Linq; using System.Globalization; using System.Text; using Oxide.Core; using Oxide.Core.Plugins; using Oxide.Core.Libraries.Covalence; using UnityEngine; using Network; using Facepunch; using System.Text.RegularExpressions; using ProtoBuf; using Oxide.Game.Rust.Cui; using static System.Math; using Newtonsoft.Json; using BTN = BUTTON; using Oxide.Game.Rust; using Oxide.Game.Rust.Libraries.Covalence;  namespace Oxide.Plugins { [Info("UberTool", "FuJiCuRa", "1.4.0", ResourceId = 78)] class UberTool : RustPlugin { [PluginReference] Plugin Clans;  StrdDt plyrPrfs = new StrdDt(); class StrdDt { public Dictionary<ulong, Plyrnf> PlyData = new Dictionary<ulong, Plyrnf>(); public StrdDt(){} } class Plyrnf { public float SF; public int DBG; public Plyrnf(){} }  public class EPlanner : MonoBehaviour { BasePlayer player; InputState stt; uint ctvtm; Construction.Target target; Construction.Target mvTrgt; BaseEntity mvTrgtSnp; Construction construction; Construction mvCnstrctn; Construction ryDfntn; Vector3 rttnOffst; Vector3 mvOffst; string lstCrsshr; string lstWrnng;  Planner plnnr; bool sPlnnr; bool sHmmr; bool isWireTool; HeldEntity hldItm; bool sRmvr; bool isAnotherHeld; Item ctvtmLnk; bool sTpDplybl; int dfltGrd; uint lstPrfb; bool initialized;  bool ctvTrgt; bool sPlcng; float tkDist; RaycastHit rayHit; BaseEntity rayEntity; IPlayer rayEntityOwner; string rayEntityName; Vector3 lastAimAngles; Socket_Base lastSocketBase; Vector3 lastSocketPos; BaseEntity lastSocketEntity; Construction.Placement lastPlacement; Ray lastRay; bool plannerInfoStatus; bool removerInfoStatus; bool hammerInfoStatus; bool lastSocketForce;  int cuiFontSize = 14; string cuiFontColor = "1 1 1 1"; string fontType = r("EbobgbPbaqrafrq-Erthyne.ggs"); float lastPosRotUpdate = 0f;  void Awake() { player = GetComponent<BasePlayer>(); stt = player.serverInput; UnEqp(); dfltGrd = uTs.plyrPrfs.PlyData[player.userID].DBG; lstPrfb = 72949757u; ctvtm = 0; construction = new Construction(); ryDfntn = new Construction(); construction.canBypassBuildingPermission = true; lastAimAngles = player.lastReceivedTick.inputState.aimAngles; lastSocketBase = default(Socket_Base); lastSocketPos = Vector3.zero; lastSocketEntity = default(BaseEntity); lastPlacement = default(Construction.Placement); rayEntity = default(BaseEntity); rttnOffst = Vector3.zero; mvOffst = Vector3.zero; }  void Start() { if (uTs.hideTips) player.SendConsoleCommand(r("tnzrgvc.uvqrtnzrgvc")); initialized = true; }  void UnEqp() { foreach (var item in player.inventory.containerBelt.itemList.Where(x => x.IsValid() && x.GetHeldEntity()).ToList()) { var slot = item.position; if ((item.info.shortname == "rock" && item.skin == 0uL) || item.info.shortname == "torch") { item.Remove(0f); continue; } else item.RemoveFromContainer(); player.inventory.UpdateContainer(0f, PlayerInventory.Type.Belt, player.inventory.containerBelt, false, 0f); uTs.timer.Once(0.15f, () => { if (item == null) return; item.MoveToContainer(player.inventory.containerBelt, slot, true); item.MarkDirty(); }); ItemManager.DoRemoves(); } if (player.inventory.containerWear.itemList.Count == 0) { var hz =  ItemManager.CreateByName("hazmatsuit_scientist", 1); player.inventory.GiveItem(hz, player.inventory.containerWear);  } uTs.timer.Once(0.3f, CrtTls); }  void GetTool(object[] tool) { var itemDef = ItemManager.FindItemDefinition((string)tool[1]); if (!itemDef) return; var p1 = player.inventory.FindItemID(itemDef.itemid); ulong skin = Convert.ToUInt64(tool[2]); if (p1 != null) { p1.skin = skin; p1.GetHeldEntity().skinID = skin; p1.name = (string)tool[0]; if (p1.CanMoveTo(player.inventory.containerBelt, -1, true)) { p1.MoveToContainer(player.inventory.containerBelt, -1, true); p1.MarkDirty(); } } else { var p2 = ItemManager.CreateByItemID(itemDef.itemid, 1, skin); if (p2 != null) { p2.name = (string)tool[0]; player.inventory.GiveItem(p2, player.inventory.containerBelt); p2.MarkDirty(); } } }  void CrtTls() { if (uTs.crtTlPlnnr) GetTool(uTs.playerTools[0]); if (uTs.crtTlRmvr) GetTool(uTs.playerTools[1]); if (uTs.crtTlHmmr) GetTool(uTs.playerTools[2]); }  bool GtCrrntTl() { sPlnnr = false; sRmvr = false; sHmmr = false; isWireTool = false; isAnotherHeld = false; DestroyInfo(); if (hldItm is Planner) { plnnr = hldItm as Planner; sPlnnr = true; sTpDplybl = plnnr.isTypeDeployable; DoPlannerInfo(); return true; } else if (hldItm is BaseProjectile && ctvtmLnk.skin == Convert.ToUInt64(uTs.playerTools[1][2])) { sRmvr = true; return true; } else if (hldItm is Hammer && ctvtmLnk.skin == Convert.ToUInt64(uTs.playerTools[2][2])) { sHmmr = true; DoHammerInfo(); return true; } else if (hldItm is AttackEntity) { isAnotherHeld = true; return true; } else if (hldItm is WireTool) { isWireTool = true; return true; }  return false; }  void ChkRmvr() { bool hsLsr = false; if (ctvtmLnk.info.shortname != (string)uTs.playerTools[1][1]) { sRmvr = false; hldItm = null; return; } ctvtmLnk.contents.flags = (ItemContainer.Flag)64; ctvtmLnk.contents.MarkDirty(); if (ctvtmLnk.contents != null && ctvtmLnk.contents.itemList.Count > 0) foreach ( var mod in ctvtmLnk.contents.itemList) if (mod.info.shortname == r("jrncba.zbq.ynfrefvtug")) { hsLsr = true; break; } if (!hsLsr) { var lMod =  ItemManager.CreateByName(r("jrncba.zbq.ynfrefvtug"), 1); if (lMod != null) if(lMod.MoveToContainer(ctvtmLnk.contents, -1, true)) hsLsr = true; else { sRmvr = false; hldItm = null; return; } } (hldItm as BaseProjectile).UnloadAmmo(ctvtmLnk, player); hldItm.SetLightsOn(true); DoRemoverInfo(); }  public void StHldItm(uint uid) { if (!initialized || uid == ctvtm) return; if (uid == 0u) { ctvtm = 0u; sPlnnr = false; sRmvr = false; sHmmr = false; isWireTool = false; sTpDplybl = false; construction = null; DestroyInfo(); return; } if (uid != ctvtm) { ctvtmLnk = player.inventory.containerBelt.FindItemByUID(uid); if (ctvtmLnk == null) return; ctvtm = uid; hldItm = ctvtmLnk.GetHeldEntity() as HeldEntity; if (hldItm == null) return; if (!GtCrrntTl()) return; if (sRmvr) { CuiHelper.DestroyUi(player, r("HgPebffUnveHV")); ChkRmvr(); } else if (sPlnnr || sHmmr) { construction = PrefabAttribute.server.Find<Construction>(sPlnnr && sTpDplybl && plnnr.GetDeployable() != null ? plnnr.GetDeployable().prefabID : lstPrfb); rttnOffst = Vector3.zero; if (sPlnnr) { if (sTpDplybl) DPlnnrUpdt(PType.Mode, ctvtmLnk.info.displayName.english); else DPlnnrUpdt(PType.Mode, $"{construction.info.name.english} ({((BuildingGrade.Enum)dfltGrd).ToString()})"); } else DPlnnrUpdt(PType.Mode); } } }  public void TckUpd(PlayerTick tick) { if (!initialized) return; bool changedInput = tick.inputState.aimAngles != lastAimAngles || tick.inputState.buttons != stt.previous.buttons || lastSocketForce; if (lastSocketForce) lastSocketForce = false; if (changedInput && !ctvTrgt) { rayHit = default(RaycastHit); lastAimAngles = tick.inputState.aimAngles; int layer = sRmvr && uTs.rmvrTlbjcts ? 1143089921 : 2097921; float range = 24f; if (sRmvr) range = uTs.rmvrTlDstnc; else if (sHmmr) range = uTs.hmmrTlDstnc; lastRay = new Ray(tick.position + new Vector3(0f, 1.5f, 0f), Quaternion.Euler(tick.inputState.aimAngles) * Vector3.forward); if (UnityEngine.Physics.Raycast(lastRay, out rayHit, range, layer, QueryTriggerInteraction.Ignore)) { var ent = rayHit.GetEntity(); if (ent != null && ent != rayEntity) { rayEntity = ent; ryDfntn = PrefabAttribute.server.Find<Construction>(rayEntity.prefabID); if (rayEntity.OwnerID > 0uL) rayEntityOwner = uTs.covalence.Players.FindPlayerById(rayEntity.OwnerID.ToString()); else rayEntityOwner = null; rayEntityName = ""; if (ryDfntn) rayEntityName = ryDfntn.info.name.english; if (rayEntityName.Length == 0) { if (rayEntity is BaseCombatEntity) { rayEntityName = (rayEntity as BaseCombatEntity).repair.itemTarget?.displayName.english; if (rayEntityName == null || rayEntityName.Length == 0) rayEntityName = rayEntity.ShortPrefabName; } else rayEntityName = rayEntity.ShortPrefabName; } if (ryDfntn == null && (rayEntity.PrefabName.EndsWith("static.prefab") || rayEntity.PrefabName.Contains("/deployable/"))) { ryDfntn = new Construction(); ryDfntn.rotationAmount = new Vector3(0,90f,0); ryDfntn.fullName = rayEntity.PrefabName; ryDfntn.maxplaceDistance = 8f; } } else if(ent == null) { rayEntity = null; ryDfntn = null; rayEntityOwner = null; rayEntityName = ""; } } else { rayEntity = null; ryDfntn = null; rayEntityOwner = null; rayEntityName = ""; } if (sPlnnr) { if (lstWrnng != string.Empty) DoWarning(string.Empty, true); target = default(Construction.Target); target.player = player; target.ray = lastRay; ChkPlcmnt(ref target, construction); if (target.socket != null && (target.socket != lastSocketBase || target.entity != lastSocketEntity || lastSocketForce)) { if (lastSocketForce) lastSocketForce = false; bool chEnt = false; if (uTs.adEffctFndtnsPlcmnt && construction.hierachyName.Contains("foundation") && lastSocketEntity != target.entity) { chEnt = true; SendEffectTo(3951505782, target.entity, player); } lastSocketEntity = target.entity; string name = target.entity.ShortPrefabName; if (target.entity is BuildingBlock) DPlnnrUpdt(PType.ConnectTo, $"{rayEntityName} [{target.entity.net.ID}] ({(target.entity as BuildingBlock).currentGrade.gradeBase.type.ToString()})"); else DPlnnrUpdt(PType.ConnectTo, $"{rayEntityName} [{target.entity.net.ID}]"); if (uTs.adEffctFndtnsPlcmnt && !chEnt && construction.hierachyName.Contains("foundation") && lastSocketBase != target.socket) SendEffectTo(3389733993, target.entity, player); lastSocketBase = target.socket; lastSocketPos = lastSocketEntity.transform.localToWorldMatrix.MultiplyPoint3x4(lastSocketBase.position); var s1 =  lastSocketBase.socketName.Replace($"{target.entity.ShortPrefabName}/sockets/","").TrimEnd('/','1','2','3','4').Replace("-"," ").Replace("–"," ");  DPlnnrUpdt(PType.ToSocket, $"{Oxide.Core.ExtensionMethods.TitleCase(s1)}"); lastPlacement = ChckPlcmnt(target, construction); if (lastPlacement != null) DPlnnrUpdt(PType.PosRot, $"{lastPlacement.position.ToString("N1")} | {lastPlacement.rotation.eulerAngles.y.ToString("N1")}°"); else DPlnnrUpdt(PType.PosRot); } if (sTpDplybl) { lastPlacement = ChckPlcmnt(target, construction); if (lastPlacement != null) { DPlnnrUpdt(PType.PosRot, $"{lastPlacement.position.ToString("N1")} | {lastPlacement.rotation.eulerAngles.ToString("N1")}"); DPlnnrUpdt(PType.ToSocket, "Terrain"); if (rayEntity) DPlnnrUpdt(PType.ConnectTo, $"{rayEntityName} [{rayEntity.net.ID}]"); } else { DPlnnrUpdt(PType.ToSocket); DPlnnrUpdt(PType.ConnectTo); DPlnnrUpdt(PType.PosRot); } } if (!sTpDplybl && !target.socket) { lastSocketBase = default(Socket_Base); lastSocketEntity = default(BaseEntity); DPlnnrUpdt(PType.ConnectTo); DPlnnrUpdt(PType.PosRot); DPlnnrUpdt(PType.ToSocket); } } else if (sHmmr) { if (lstWrnng != string.Empty) DoWarning(string.Empty, true); if (!ctvTrgt) { if (rayEntity && rayHit.distance <= uTs.hmmrTlDstnc) { if (ryDfntn && rayEntity is BuildingBlock) { DHmmrUpdt(HType.Target, $"{rayEntityName} [{rayEntity.net.ID}] ({(rayEntity as BuildingBlock).currentGrade.gradeBase.type.ToString()})"); DoCrosshair("0 1 0 0.75"); } else if (ryDfntn) { if(ryDfntn.fullName == StringPool.Get(3424003500)) { DHmmrUpdt(HType.Target, $"{rayEntityName} [{rayEntity.net.ID}] (Type: {(rayEntity as MiningQuarry).staticType})"); } else DHmmrUpdt(HType.Target, $"{rayEntityName} [{rayEntity.net.ID}]"); DoCrosshair("1 0.921568632 0.0156862754 0.75"); } else { DHmmrUpdt(HType.Target, $"{rayEntityName} [{rayEntity.net.ID}]"); } DHmmrUpdt(HType.Mode, "Modify"); DHmmrUpdt(HType.Building, rayEntity is DecayEntity ? $"ID {(rayEntity as DecayEntity).buildingID}" : "None");  if (ryDfntn) { float currentTime = UnityEngine.Time.realtimeSinceStartup; if (currentTime - lastPosRotUpdate >= 0.25f) { if (rayEntity is BuildingBlock) DHmmrUpdt(HType.PosRot, $"{rayEntity.transform.position.ToString("N1")} | {rayEntity.transform.rotation.eulerAngles.y.ToString("N1")}°"); else DHmmrUpdt(HType.PosRot, $"{rayEntity.transform.position.ToString("N1")} | {rayEntity.transform.rotation.eulerAngles.ToString("N1")}"); lastPosRotUpdate = currentTime; } if (rayEntityOwner != null) DHmmrUpdt(HType.Owner, $"{rayEntityOwner.Name}"); else DHmmrUpdt(HType.Owner, $"{rayEntity.OwnerID}"); } } else { DHmmrUpdt(HType.Target); DHmmrUpdt(HType.Building); DHmmrUpdt(HType.Mode, r("Zbqvsl")); DHmmrUpdt(HType.PosRot); DHmmrUpdt(HType.Owner); DoCrosshair("1 1 1 0.75"); } } else { DHmmrUpdt(HType.PosRot, $"{mvTrgt.entity.transform.position.ToString("N1")} | {mvTrgt.entity.transform.rotation.eulerAngles.ToString("N1")}"); DoCrosshair(string.Empty); } } else if (sRmvr) { DoCrosshair(string.Empty); if (rayEntity != null && rayHit.distance <= uTs.rmvrTlDstnc && (ryDfntn || (!ryDfntn && uTs.rmvrTlbjcts))) { DRmvrUpdt(RType.Remove, $"{rayEntityName} [{rayEntity.net.ID}]"); if (rayEntityOwner != null) DRmvrUpdt(RType.Owner, $"{rayEntityOwner.Name}"); else DRmvrUpdt(RType.Owner, $"{rayEntity.OwnerID}"); } else { DRmvrUpdt(RType.Remove); DRmvrUpdt(RType.Owner); } if (uTs.enblFllBldngRmvl && stt.IsDown(controlButtons[CmdType.RemoverHoldForAll]) && rayEntity is BuildingBlock) { DoWarning("1 0 0 0.75"); DRmvrUpdt(RType.Mode, "<color=#ffff00>Building</color>"); } else { DRmvrUpdt(RType.Mode, r("Fvatyr")); DoWarning(string.Empty); } } else if (isAnotherHeld) { if (hldItm is BaseLiquidVessel && (stt.WasJustReleased((BTN)1024) || stt.WasDown((BTN)2048))) { var vessel = hldItm as BaseLiquidVessel; if (vessel.AmountHeld() < 1) vessel.AddLiquid(ItemManager.FindItemDefinition("water"), vessel.MaxHoldable()); } else if (hldItm is BaseProjectile && stt.WasJustPressed((BTN)8192)) { var weapon = hldItm as BaseProjectile; if (!weapon.primaryMagazine.CanReload(player) && weapon.primaryMagazine.contents < weapon.primaryMagazine.capacity) { try { player.inventory.GiveItem(ItemManager.Create(weapon.primaryMagazine.ammoType, weapon.primaryMagazine.capacity - weapon.primaryMagazine.contents)); } catch{} ItemManager.DoRemoves(); } } else if (hldItm is FlameThrower && ( stt.WasJustPressed((BTN)8192) || stt.IsDown((BTN)1024))) { var flame = hldItm as FlameThrower; if ((stt.IsDown((BTN)1024) && flame.ammo < 2) || (stt.WasJustPressed((BTN)8192) && flame.ammo < flame.maxAmmo)) { flame.ammo = flame.maxAmmo; flame.SendNetworkUpdateImmediate(false); ItemManager.DoRemoves(); player.inventory.ServerUpdate(0f); } } else if (hldItm is Chainsaw && ( stt.WasJustPressed((BTN)8192) || stt.IsDown((BTN)1024) || stt.WasJustPressed((BTN)2048))) { var saw = hldItm as Chainsaw;  if ((stt.WasJustPressed((BTN)2048) && !saw.EngineOn())) { saw.SetEngineStatus(true); hldItm.SendNetworkUpdateImmediate(false); } else if ((stt.IsDown((BTN)1024) && saw.ammo < 2) || (stt.WasJustPressed((BTN)8192) && saw.ammo < saw.maxAmmo)) { saw.ammo = saw.maxAmmo; saw.SendNetworkUpdateImmediate(false); ItemManager.DoRemoves(); player.inventory.ServerUpdate(0f); } } } else if (isWireTool) {  } } else if (changedInput && ctvTrgt) { DHmmrUpdt(HType.PosRot, $"{mvTrgt.entity.transform.position.ToString("N1")} | {mvTrgt.entity.transform.rotation.eulerAngles.ToString("N1")}"); DoCrosshair(string.Empty, true); } if (sPlnnr && !sTpDplybl) { if (lastSocketBase != null && lastPlacement != null && lastSocketEntity) { OBB oBB = new OBB(lastPlacement.position, Vector3.one, lastPlacement.rotation, construction.bounds); Vector3 obb_pos = construction.hierachyName.Contains(r("sbhaqngvba")) ? oBB.position + (oBB.extents.y * Vector3.up) : oBB.position; Vector3 sock_pos = construction.hierachyName.Contains(r("sbhaqngvba")) ? new Vector3 (lastSocketPos.x, lastSocketEntity.transform.position.y, lastSocketPos.z) : lastSocketPos; player.SendConsoleCommand("ddraw.box", 0.05f, Color.green, obb_pos, 0.15f); player.SendConsoleCommand("ddraw.box", 0.05f, Color.green, sock_pos, 0.25f); player.SendConsoleCommand("ddraw.line", 0.05f, Color.green, obb_pos, sock_pos); } } }  void Update() { if (!ctvTrgt) return; if (!sPlcng && sHmmr) { if (mvTrgt.entity == null) { DoCrosshair("1 1 1 0.75"); mvTrgt = default(Construction.Target); sPlcng = false; ctvTrgt = false; return; } bool flag = mvTrgt.entity is SimpleBuildingBlock || mvCnstrctn.allSockets == null; mvTrgt.ray = player.eyes.BodyRay(); FndTrrnPlcmnt(ref mvTrgt, mvCnstrctn, tkDist, flag); Vector3 position = mvTrgt.entity.transform.position; Quaternion rotation = mvTrgt.entity.transform.rotation; Vector3 toPos = mvTrgt.position; Quaternion toRot = Quaternion.LookRotation(mvTrgt.entity.transform.up) * Quaternion.Euler(mvOffst); if (flag) { Vector3 direction = mvTrgt.ray.direction; direction.y = 0f; direction.Normalize(); toRot = Quaternion.Euler(mvOffst) * Quaternion.LookRotation(direction, Vector3.up); } var check = ChckPlcmnt(mvTrgt, mvCnstrctn); if (check != null) { toPos = check.position; toRot = check.rotation * Quaternion.Euler(mvOffst); } mvTrgt.entity.transform.position = Vector3.Lerp(position, toPos, UnityEngine.Time.deltaTime * 5f); mvTrgt.entity.transform.rotation = Quaternion.Lerp(rotation, toRot, UnityEngine.Time.deltaTime * 10f); DMvmntSnc(mvTrgt.entity); return; } else if (sPlcng) { if (mvTrgt.entity == null) { DoCrosshair("1 1 1 0.75"); mvTrgt = default(Construction.Target); sPlcng = false; ctvTrgt = false; return; } if (Vector3.Distance(mvTrgt.entity.transform.position, mvTrgt.position) <= 0.005f) { if (mvTrgtSnp && !(mvTrgtSnp is BuildingBlock)) { mvTrgt.entity.transform.position = mvTrgtSnp.transform.InverseTransformPoint(mvTrgt.position); mvTrgt.entity.transform.rotation = Quaternion.Inverse(mvTrgtSnp.transform.rotation) * Quaternion.Euler(mvTrgt.rotation); mvTrgt.entity.SetParent(mvTrgtSnp, 0u); } if (mvTrgtSnp) { DecayUpdate(mvTrgt.entity, true, mvCnstrctn.isBuildingPrivilege, mvTrgtSnp); mvTrgtSnp = null; } DMvmntSnc(mvTrgt.entity); DoCrosshair("1 1 1 0.75"); mvTrgt = default(Construction.Target); sPlcng = false; ctvTrgt = false; return; } mvTrgt.entity.transform.position = Vector3.Lerp(mvTrgt.entity.transform.position, mvTrgt.position, UnityEngine.Time.deltaTime * 10f); if (mvTrgtSnp == null || (mvTrgtSnp && !(mvTrgtSnp is BuildingBlock))) mvTrgt.entity.transform.rotation = Quaternion.Lerp(mvTrgt.entity.transform.rotation, Quaternion.Euler(mvTrgt.rotation), UnityEngine.Time.deltaTime * 10f); DMvmntSnc(mvTrgt.entity); return; } else if (!sPlcng && !sHmmr) { if (mvTrgt.valid) PlcOnTrgt(); else TrPlcTrgt(); } }  void DecayUpdate(BaseEntity entity, bool isAdding, bool isBuildingPrivilege, BaseEntity target = null) { DecayEntity dcEnt = entity as DecayEntity; if (dcEnt == null) return; BuildingManager.Building building = null; if (isAdding) { DecayEntity dcTgt = target != null ? target as DecayEntity : null; if (dcTgt != null) building = BuildingManager.server.GetBuilding(dcTgt.buildingID); if (building != null) { building.AddDecayEntity(dcEnt); if (isBuildingPrivilege) building.AddBuildingPrivilege(dcEnt as BuildingPrivlidge); building.Dirty(); dcEnt.buildingID = building.ID; } } else { building = BuildingManager.server.GetBuilding(dcEnt.buildingID); if (building != null) { if (building.decayEntities != null) building.RemoveDecayEntity(dcEnt); if (isBuildingPrivilege && building.buildingPrivileges != null) building.RemoveBuildingPrivilege(dcEnt as BuildingPrivlidge); building.Dirty(); } dcEnt.buildingID = 0u; } dcEnt.SendNetworkUpdate(BasePlayer.NetworkQueue.Update); if (entity.children != null) foreach (BaseEntity current in entity.children) DecayUpdate(current, isAdding, isBuildingPrivilege, isAdding ? entity : null); }  void PlcOnTrgt() { if (mvTrgtSnp && !(mvTrgtSnp is BuildingBlock)) { mvTrgt.entity.transform.position = mvTrgtSnp.transform.worldToLocalMatrix.MultiplyPoint3x4(mvTrgt.position); mvTrgt.entity.transform.rotation = Quaternion.Inverse(mvTrgtSnp.transform.rotation) * mvTrgt.entity.transform.rotation; mvTrgt.entity.SetParent(mvTrgtSnp, 0u); } if (mvTrgtSnp) { DecayUpdate(mvTrgt.entity, true, mvCnstrctn.isBuildingPrivilege, mvTrgtSnp); mvTrgtSnp = null; } DMvmntSnc(mvTrgt.entity); mvTrgt = default(Construction.Target); ctvTrgt = false; sPlcng = false; }  void TrPlcTrgt() { RaycastHit hit; mvTrgtSnp = null; int layer = mvCnstrctn.isBuildingPrivilege ? 2097152 : 27328769; if (Physics.Raycast(mvTrgt.entity.transform.position, mvTrgt.entity.transform.up * -1.0f, out hit, float.PositiveInfinity, layer)) { mvTrgt.position = hit.point; if (hit.collider is UnityEngine.TerrainCollider) { mvTrgt.rotation = Quaternion.LookRotation(Vector3.Cross(mvTrgt.entity.transform.right, hit.normal)).eulerAngles; DHmmrUpdt(HType.Building, "None"); } else { mvTrgtSnp = hit.GetEntity(); if (mvTrgtSnp) { mvTrgt.rotation = mvTrgt.entity.transform.rotation.eulerAngles; DHmmrUpdt(HType.Building, rayEntity is DecayEntity ? $"ID {(rayEntity as DecayEntity).buildingID}" : "None"); } else DHmmrUpdt(HType.Building, "None"); } sPlcng = true; return; } else { mvTrgt = default(Construction.Target); ctvTrgt = false; sPlcng = false; return; } }  public object GtMvTrgt() { if (ctvTrgt && mvTrgt.entity != null) return (uint)mvTrgt.entity.net.ID; return null; }  void DMvmntSnc(BaseEntity entity, bool isChild = false) { if (entity == null) { DoCrosshair("1 1 1 0.75"); mvTrgt = default(Construction.Target); sPlcng = false; ctvTrgt = false; return; } bool force2 = entity.PrefabName == StringPool.Get(2206646561) || entity.PrefabName == StringPool.Get(2335812770); if (isChild || force2) {  if (Net.sv.write.Start()) { Net.sv.write.PacketID(Message.Type.EntityDestroy); Net.sv.write.UInt32(entity.net.ID); Net.sv.write.UInt8(0); Net.sv.write.Send(new SendInfo(entity.net.group.subscribers)); } entity.SendNetworkUpdateImmediate(false); if (isChild) return; } else { if (Net.sv.write.Start()) { Net.sv.write.PacketID(Message.Type.GroupChange); Net.sv.write.EntityID(entity.net.ID); Net.sv.write.GroupID(entity.net.group.ID); Net.sv.write.Send(new SendInfo(entity.net.group.subscribers)); } if (Net.sv.write.Start()) { Net.sv.write.PacketID(Message.Type.EntityPosition); Net.sv.write.EntityID(entity.net.ID); Net.sv.write.Vector3(entity.GetNetworkPosition()); Net.sv.write.Vector3(entity.GetNetworkRotation().eulerAngles); Net.sv.write.Float(entity.GetNetworkTime()); Write write = Net.sv.write; SendInfo info = new SendInfo(entity.net.group.subscribers); info.method = SendMethod.ReliableUnordered; info.priority = Priority.Immediate; write.Send(info); } } if (force2 && entity && entity.children != null) foreach (BaseEntity current in entity.children) DMvmntSnc(current, true); }  public void DoTi() { if (!initialized || !hldItm) return; if (sPlnnr) { if (true) { if (stt.WasJustPressed(controlButtons[CmdType.PlannerPlace])) { DoPl(); return; } else if (stt.WasJustPressed(controlButtons[CmdType.PlannerRotate])) { Vector3 vector = Vector3.zero; if (construction && construction.canRotate) vector = construction.rotationAmount; rttnOffst.x = Mathf.Repeat(rttnOffst.x + vector.x, 360f); rttnOffst.y = Mathf.Repeat(rttnOffst.y + vector.y, 360f); rttnOffst.z = Mathf.Repeat(rttnOffst.z + vector.z, 360f); return; } } if (!sTpDplybl) { if (stt.WasJustPressed((BTN)2048)) { BldMnUI(uTs.plyrPrfs.PlyData[player.userID].SF); return; } else if (stt.IsDown(controlButtons[CmdType.PlannerTierChange])) { if (stt.WasJustPressed(controlButtons[CmdType.PlannerTierNext])) { dfltGrd++; if (dfltGrd > 4) dfltGrd = 0; uTs.plyrPrfs.PlyData[player.userID].DBG = dfltGrd; DPlnnrUpdt(PType.Mode, $"{construction.info.name.english} ({((BuildingGrade.Enum)dfltGrd).ToString()})"); return; } else if (stt.WasJustPressed(controlButtons[CmdType.PlannerTierPrev])) { dfltGrd--; if (dfltGrd < 0) dfltGrd = 4; uTs.plyrPrfs.PlyData[player.userID].DBG = dfltGrd; DPlnnrUpdt(PType.Mode, $"{construction.info.name.english} ({((BuildingGrade.Enum)dfltGrd).ToString()})"); return; } } } else if (sTpDplybl){} } else if (sHmmr) { if (ctvTrgt) { if (sPlcng){} else if (!sPlcng) { if (stt.WasJustPressed(controlButtons[CmdType.HammerTransform])) { if (mvTrgt.valid) PlcOnTrgt(); else TrPlcTrgt(); return; } else if (stt.WasJustPressed(controlButtons[CmdType.HammerRotate])) { Vector3 vector = Vector3.zero; if (mvCnstrctn && mvCnstrctn.canRotate) { if (stt.IsDown(controlButtons[CmdType.HammerRotateDirection])) vector =- mvCnstrctn.rotationAmount; else vector = mvCnstrctn.rotationAmount; } mvOffst.x = Mathf.Repeat(mvOffst.x + vector.x, 360f); mvOffst.y = Mathf.Repeat(mvOffst.y + vector.y, 360f); mvOffst.z = Mathf.Repeat(mvOffst.z + vector.z, 360f); return; } } } else if (!ctvTrgt) { if (stt.WasJustPressed(controlButtons[CmdType.HammerChangeGrade]) && rayEntity && rayEntity.IsValid() && rayEntity is BuildingBlock) { BuildingBlock block = rayEntity as BuildingBlock; var grade = (int)block.currentGrade.gradeBase.type; grade++; if (grade >= block.blockDefinition.grades.Length) grade = 1; block.SetGrade((BuildingGrade.Enum)grade); block.SetHealthToMax(); block.StartBeingRotatable(); rayEntity.SendNetworkUpdate(BasePlayer.NetworkQueue.Update); block.UpdateSkin(false); BuildingManager.Building building = BuildingManager.server.GetBuilding(block.buildingID); if (building != null) building.Dirty(); if (uTs.ffctPrmtngBlcksOn) Effect.server.Run("assets/bundled/prefabs/fx/build/promote_" + ((BuildingGrade.Enum)grade).ToString().ToLower() + ".prefab", rayEntity, 0u, Vector3.zero, Vector3.zero, null, false); } else if (stt.WasJustPressed(controlButtons[CmdType.HammerToggleOnOff]) && rayEntity && rayEntity.IsValid() && !(rayEntity is BuildingBlock)) { var r = rayEntity; if (r is StorageContainer || r is IOEntity) { bool isOn = r.HasFlag(BaseEntity.Flags.On); bool hasPower = isOn & r is IOEntity; if (r is SearchLight && !isOn) (r as SearchLight).secondsRemaining = float.PositiveInfinity; r.SetFlag(BaseEntity.Flags.On, !isOn, false); if(r is IOEntity) r.SetFlag(BaseEntity.Flags.Reserved8, !hasPower, false); r.SendNetworkUpdate(); return; } else if (r is MiningQuarry) { var q = r as MiningQuarry; q.staticType = (MiningQuarry.QuarryType)(int)q.staticType+1; if ((int)q.staticType > 3) q.staticType = (MiningQuarry.QuarryType)0; q.UpdateStaticDeposit(); } else if(r is EngineSwitch) { var miningQuarry = r.GetParentEntity() as MiningQuarry; if (miningQuarry) miningQuarry.EngineSwitch(true); } } else if (stt.WasJustPressed(controlButtons[CmdType.HammerRotate])) { if (!rayEntity || !rayEntity.IsValid() || ryDfntn == null || ryDfntn.rotationAmount.y == 0f) return; string effectPath = ryDfntn.deployable != null && ryDfntn.deployable.placeEffect.isValid ? ryDfntn.deployable.placeEffect.resourcePath : StringPool.Get(2598153373); if (stt.IsDown(controlButtons[CmdType.HammerRotateDirection])) rayEntity.transform.Rotate(-ryDfntn.rotationAmount); else rayEntity.transform.Rotate(ryDfntn.rotationAmount); if (rayEntity is StabilityEntity) { rayEntity.RefreshEntityLinks(); if (!uTs.vrrdStbltWhlBld && !(rayEntity as StabilityEntity).grounded) (rayEntity as StabilityEntity).UpdateSurroundingEntities(); if (rayEntity is BuildingBlock) { var conskin = rayEntity.gameObject.GetComponentInChildren<ConstructionSkin>(); if (conskin) conskin.Refresh(rayEntity as BuildingBlock); rayEntity.ClientRPC(null, r("ErserfuFxva")); } } DMvmntSnc(rayEntity); Effect.server.Run(effectPath, rayEntity, 0u, Vector3.zero, Vector3.zero, null, false); } else if (stt.WasJustPressed(controlButtons[CmdType.HammerTransform])) { if (mvTrgt.entity != null) { mvTrgt = default(Construction.Target); ctvTrgt = false; sPlcng = false; return; } if (!rayEntity || rayEntity is BuildingBlock || rayEntity.FindLinkedEntity<BuildingBlock>()) return; if (rayEntity is BaseMountable && (rayEntity as BaseMountable)._mounted != null) return; mvCnstrctn = PrefabAttribute.server.Find<Construction>(rayEntity.prefabID); if (mvCnstrctn == null) { if (!rayEntity.PrefabName.EndsWith("static.prefab") && !rayEntity.PrefabName.Contains("/deployable/")) return; mvCnstrctn = new Construction(); mvCnstrctn.rotationAmount = new Vector3(0,90f,0); mvCnstrctn.fullName = rayEntity.PrefabName; mvCnstrctn.maxplaceDistance = rayEntity is MiningQuarry ? 8f : 4f; mvCnstrctn.canRotate = true; } if (rayEntity is DecayEntity) { DecayUpdate(rayEntity, false, mvCnstrctn.isBuildingPrivilege); DHmmrUpdt(HType.Building, "None"); } mvTrgt = default(Construction.Target); mvOffst = Vector3.zero; if (rayEntity.HasParent()) { var position = rayEntity.transform.position; var rotation = rayEntity.transform.rotation; rayEntity.SetParent(null, 0u); rayEntity.transform.position = position; rayEntity.transform.rotation = rotation; DMvmntSnc(rayEntity); } if (rayEntity.children.Count == 0 || !rayEntity.HasParent()) { DMvmntSnc(rayEntity); } tkDist = Mathf.Clamp(Vector3.Distance(rayEntity.transform.position, lastRay.origin), mvCnstrctn.maxplaceDistance, mvCnstrctn.maxplaceDistance * 3f); mvTrgt.entity = rayEntity; sPlcng = false; ctvTrgt = true; DHmmrUpdt(HType.Mode, r("Ercbfvgvbavat")); } else if (stt.WasJustPressed(controlButtons[CmdType.HammerAuthInfo]) && !stt.WasDown(controlButtons[CmdType.HammerTransform]) && (uTs.nblHmmrTcInf || uTs.nblHmmrLckInf)) { string infoMsg = ""; if (uTs.nblHmmrTcInf && rayEntity && rayEntity is BuildingPrivlidge && rayEntity.Distance(player.transform.position) > 1.25f) { var hasClans = uTs.Clans != null ? true : false; var sb = new StringBuilder(); rayEntityName = (rayEntity as BaseCombatEntity).repair.itemTarget?.displayName.english; sb.Append($">\nAuthentication list of <color=#ffa500>{rayEntityName}</color> (<color=#00ffff>{rayEntity.net.ID}</color>)"); var iPlayer = uTs.covalence.Players.FindPlayerById(rayEntity.OwnerID.ToString()); if (iPlayer != null) { sb.Append($" | Owner: <color=#ffa500>{iPlayer.Name}</color> (<color=#00ffff>{iPlayer.Id}</color>) | "); if (iPlayer.IsConnected) sb.AppendLine($"Status: <color=#008000>Online</color>"); else sb.AppendLine($"Status: <color=#ffffff>Offline</color>"); } TextTable textTable = new TextTable(); textTable.AddColumn("Name"); textTable.AddColumn("UserID"); if (hasClans) textTable.AddColumn("Clan"); textTable.AddColumn("Status"); foreach (var nameID in (rayEntity as BuildingPrivlidge).authorizedPlayers.ToList()) { var authedP = uTs.covalence.Players.FindPlayerById(nameID.userid.ToString()); if (authedP == null) continue; if (hasClans) { var clanTag = "-"; string tag = (string)uTs.Clans?.Call("GetClanOf", Convert.ToUInt64(authedP.Id)); if (tag != null) clanTag = tag; textTable.AddRow(new string[]	{ authedP.Name, authedP.Id, clanTag, ((authedP as RustPlayer).IsConnected ? "<color=#008000>Online</color>" : "<color=#ffffff>Offline</color>").ToString() }); } else textTable.AddRow(new string[]	{ authedP.Name, authedP.Id, ((authedP as RustPlayer).IsConnected ? "<color=#008000>Online</color>" : "<color=#ffffff>Offline</color>").ToString() }); }  sb.AppendLine(textTable.ToString()); player.ConsoleMessage(sb.ToString()); infoMsg += $"<color=#ffa500>TC</color> (<color=#00ffff>{rayEntity.net.ID}</color>) authorized players sent to console"; } if (uTs.nblHmmrLckInf && rayEntity && rayEntity.HasSlot(BaseEntity.Slot.Lock) && rayEntity.GetSlot(BaseEntity.Slot.Lock) is CodeLock) { var hasClans = uTs.Clans != null ? true : false; var codeLock = (CodeLock)rayEntity.GetSlot(BaseEntity.Slot.Lock); var sb = new StringBuilder(); rayEntityName = (rayEntity as BaseCombatEntity).repair.itemTarget?.displayName.english; sb.Append($">\nCodeLock info for <color=#ffa500>{rayEntityName}</color> (<color=#00ffff>{rayEntity.net.ID}</color>)"); var iPlayer = uTs.covalence.Players.FindPlayerById(rayEntity.OwnerID.ToString()); if (iPlayer != null) { sb.Append($" | Owner: <color=#ffa500>{iPlayer.Name}</color> (<color=#00ffff>{iPlayer.Id}</color>) | "); if (iPlayer.IsConnected) sb.AppendLine($"Status: <color=#008000>Online</color>"); else sb.AppendLine($"Status: <color=#ffffff>Offline</color>"); }  string code = codeLock.hasCode ?  $"<color=#00ffff>{codeLock.code}</color>" : "<color=#00ffff>Not set</color>"; string guest = codeLock.hasGuestCode ?  $"<color=#00ffff>{codeLock.guestCode}</color>" : "<color=#00ffff>Not set</color>"; sb.AppendLine($"Lock code:  {code} | Guest code: {guest}");  if (codeLock.whitelistPlayers != null && codeLock.whitelistPlayers.Count > 0) { sb.AppendLine("Whitelisted:"); TextTable textTable = new TextTable(); textTable.AddColumn("Name"); textTable.AddColumn("UserID"); if (hasClans) textTable.AddColumn("Clan"); textTable.AddColumn("Status");  foreach (var userID in codeLock.whitelistPlayers.ToList()) { var authedP = uTs.covalence.Players.FindPlayerById(userID.ToString()); if (authedP == null) continue; if (hasClans) { string clanTag = (string)uTs.Clans?.Call("GetClanOf", Convert.ToUInt64(authedP.Id)); if (clanTag.Length == 0) clanTag = "-"; textTable.AddRow(new string[]	{ authedP.Name, authedP.Id, clanTag, (authedP.IsConnected ? "<color=#008000>Online</color>" : "<color=#ffffff>Offline</color>").ToString() }); } else textTable.AddRow(new string[]	{ authedP.Name, authedP.Id, (authedP.IsConnected ? "<color=#008000>Online</color>" : "<color=#ffffff>Offline</color>").ToString() }); }  sb.AppendLine(textTable.ToString()); } else sb.AppendLine("Whitelisted: <color=#ffffff>None</color>"); if (codeLock.guestPlayers != null && codeLock.guestPlayers.Count > 0) { sb.AppendLine("Guests:"); TextTable textTable = new TextTable(); textTable.AddColumn("Name"); textTable.AddColumn("UserID"); if (hasClans) textTable.AddColumn("Clan"); textTable.AddColumn("Status");  foreach (var userID in codeLock.guestPlayers.ToList()) { var authedP = uTs.covalence.Players.FindPlayerById(userID.ToString()); if (authedP == null) continue; if (hasClans) { string clanTag = (string)uTs.Clans?.Call("GetClanOf", Convert.ToUInt64(authedP.Id)); if (clanTag.Length == 0) clanTag = "-"; textTable.AddRow(new string[]	{ authedP.Name, authedP.Id, clanTag, (authedP.IsConnected ? "<color=#008000>Online</color>" : "<color=#ffffff>Offline</color>").ToString() }); } else textTable.AddRow(new string[]	{ authedP.Name, authedP.Id, (authedP.IsConnected ? "<color=#008000>Online</color>" : "<color=#ffffff>Offline</color>").ToString() }); }  sb.AppendLine(textTable.ToString()); } else sb.AppendLine("Guests: <color=#ffffff>None</color>"); player.ConsoleMessage(sb.ToString()); infoMsg += (infoMsg.Length > 0 ? "\n" : "") + $"<color=#ffa500>{rayEntityName == "Tool Cupboard" ? "TC" : rayEntityName}</color> (<color=#00ffff>{rayEntity.net.ID}</color>) CodeLock info sent to console"; } if (infoMsg.Length > 0) player.ChatMessage(uTs.ChatMsg(infoMsg)); } } } else if (sRmvr) { if (stt.WasJustPressed(controlButtons[CmdType.RemoverRemove])) { if (!stt.IsDown(controlButtons[CmdType.RemoverHoldForAll])) DoRm(); else if (stt.IsDown(controlButtons[CmdType.RemoverHoldForAll])) DoRm(true); } rayEntity = null; ryDfntn = null; } }  void FndTrrnPlcmnt(ref Construction.Target t, Construction c, float maxDistance, bool isQuarry = false ) { int layer = 27328769; if (isQuarry) layer = 10551297; RaycastHit[] hits = Physics.RaycastAll(t.ray, maxDistance, layer); if (hits.Length > 1) { GamePhysics.Sort(hits); for (int i = 0; i < hits.Length; i++) { if (hits[i].collider.transform.root != t.entity.transform.root) { t.position = t.ray.origin + t.ray.direction * hits[i].distance; t.normal = hits[i].normal; t.rotation = Vector3.zero; t.onTerrain = true; t.valid = true; if (!isQuarry) mvTrgtSnp = hits[i].GetEntity(); return; } } } t.position = t.ray.origin + t.ray.direction * maxDistance; t.normal = Vector3.up; t.rotation = Vector3.zero; t.onTerrain = true; t.valid = false; mvTrgtSnp = null; }  public void StBlckPrfb(uint p) { construction = PrefabAttribute.server.Find<Construction>(p); rttnOffst = Vector3.zero; lstPrfb = p; DPlnnrUpdt(PType.Mode, $"{construction.info.name.english} ({((BuildingGrade.Enum)dfltGrd).ToString()})"); lastPlacement = null; lastSocketForce = true; }  public void OnDestroy() { DoCrosshair(string.Empty, true); DoWarning(string.Empty, true); foreach (var item in player.inventory.AllItems().Where(x => x.IsValid()).ToList()) { if (item.skin == Convert.ToUInt64(uTs.playerTools[0][2]) || item.skin == Convert.ToUInt64(uTs.playerTools[1][2]) || item.skin == Convert.ToUInt64(uTs.playerTools[2][2])) { item.skin = 0uL; item.GetHeldEntity().skinID = 0uL; item.name = string.Empty; item.MarkDirty(); } } DestroyInfo(); GameObject.Destroy(this); }  void DoRm(bool remAl = false) { if (!rayEntity || (rayEntity is BasePlayer && !(rayEntity is NPCPlayer)) || (!uTs.rmvrTlbjcts && !ryDfntn)) return; if (rayEntity.IsValid()) { if (rayEntity is BuildingBlock) { if (uTs.enblFllBldngRmvl && remAl) { CollRm(rayEntity); return; } else { if (uTs.ffctRmvngBlcksOn) Effect.server.Run(uTs.ffctRmvngBlcks, rayEntity, 0u, Vector3.zero, Vector3.zero, null, false); rayEntity.Kill(BaseNetworkable.DestroyMode.Gib); rayEntity = null; ryDfntn = null; return; } } else { if (rayEntity is OreResourceEntity) (rayEntity as OreResourceEntity).CleanupBonus(); else if (rayEntity is BaseNpc || rayEntity is NPCPlayer || rayEntity is BradleyAPC || rayEntity is BaseHelicopter) (rayEntity as BaseCombatEntity).DieInstantly(); else { if (!uTs.entRemoval.Contains(rayEntity.transform.root)) uTs.entRemoval.Add(rayEntity.transform.root); rayEntity.Kill(BaseNetworkable.DestroyMode.Gib); } rayEntity = null; ryDfntn = null; } } else { GameManager.Destroy(rayEntity.gameObject, 0f); rayEntity = null; ryDfntn = null; } }  void CollRm(BaseEntity srcntt) { var bldngBlck = srcntt.GetComponent<BuildingBlock>(); if (bldngBlck) { var building = BuildingManager.server.GetBuilding(bldngBlck.buildingID); ServerMgr.Instance.StartCoroutine(DlyRm(building.buildingBlocks.ToList(), building.decayEntities.ToList(), building.buildingPrivileges.ToList())); } }  WaitForEndOfFrame wait = new WaitForEndOfFrame();  IEnumerator DlyRm(List<BuildingBlock> bLst, List<DecayEntity> dLst, List<BuildingPrivlidge> pLst) { var mode = uTs.gbsRmvBldng ? BaseNetworkable.DestroyMode.Gib : BaseNetworkable.DestroyMode.None; for (int i = 0; i < pLst.Count; i++) { if (!pLst[i].IsDestroyed) { if (pLst[i] == rayEntity) { rayEntity = null; ryDfntn = null; } pLst[i].Kill(mode); yield return wait; } } for (int i = 0; i < dLst.Count; i++) { if (!dLst[i].IsDestroyed) { if (dLst[i] == rayEntity) { rayEntity = null; ryDfntn = null; } dLst[i].Kill(mode); yield return wait; } } for (int i = 0; i < bLst.Count; i++) { if (!bLst[i].IsDestroyed) { if (bLst[i] == rayEntity) { rayEntity = null; ryDfntn = null; } bLst[i].Kill(mode); yield return wait; } } yield break; }  void DoPl() { ChkQrr(construction); Deployable dplybl = plnnr.GetDeployable(); GameObject gameObject = DoPlaG(target, construction); if (gameObject != null) { Interface.CallHook(r("BaRagvglOhvyg"), new object[] {plnnr, gameObject}); if (dplybl != null) { if (dplybl.placeEffect.isValid) { if (target.entity && target.socket) Effect.server.Run(dplybl.placeEffect.resourcePath, target.entity.transform.TransformPoint(target.socket.worldPosition), target.entity.transform.up, null, false); else Effect.server.Run(dplybl.placeEffect.resourcePath, target.position, target.normal, null, false); } BaseEntity bsntt = gameObject.ToBaseEntity(); if (!(bsntt is MiningQuarry) && target.entity != null && !(target.entity is BuildingBlock)) { bsntt.transform.position = target.entity.transform.worldToLocalMatrix.MultiplyPoint3x4(target.position); bsntt.transform.rotation = Quaternion.Inverse(target.entity.transform.rotation) * bsntt.transform.rotation; bsntt.SetParent(target.entity, 0u); } if (dplybl.wantsInstanceData && ctvtmLnk.instanceData != null) (bsntt as IInstanceDataReceiver).ReceiveInstanceData(ctvtmLnk.instanceData); if (dplybl.copyInventoryFromItem) { StorageContainer component2 = bsntt.GetComponent<StorageContainer>(); if (component2) { component2.ReceiveInventoryFromItem(ctvtmLnk); ctvtmLnk.OnVirginSpawn(); ctvtmLnk.MarkDirty(); } } } } }  void ChkPlcmnt(ref Construction.Target t, Construction c) { t.valid = false; if (c.socketHandle != null) { Vector3 worldPosition = c.socketHandle.worldPosition; Vector3 a = t.ray.origin + t.ray.direction * c.maxplaceDistance; Vector3 a2 = a - worldPosition; var oldDir = t.ray.direction; t.ray.direction = (a2 - t.ray.origin).normalized; } List<BaseEntity> list = Pool.GetList<BaseEntity>(); float num = 3.40282347E+38f; Vis.Entities<BaseEntity>(t.ray.origin, c.maxplaceDistance * 2f, list, 18874625, QueryTriggerInteraction.Collide); foreach (BaseEntity current in list) { Construction con = PrefabAttribute.server.Find<Construction>(current.prefabID); if (!(con == null)) { Socket_Base[] allSockets = con.allSockets; for (int i = 0; i < allSockets.Length; i++) { Socket_Base socket_Base = allSockets[i]; if (socket_Base.female && !socket_Base.femaleDummy) { RaycastHit raycastHit; if (socket_Base.GetSelectBounds(current.transform.position, current.transform.rotation).Trace(t.ray, out raycastHit, float.PositiveInfinity)) { if (raycastHit.distance >= 1f) { if (raycastHit.distance <= num) { if (!current.IsOccupied(socket_Base)) { Construction.Target trgt2 = default(Construction.Target); trgt2.socket = socket_Base; trgt2.entity = current; trgt2.ray = t.ray; trgt2.valid = true; trgt2.player = player; trgt2.rotation = rttnOffst; if (c.HasMaleSockets(trgt2)) { t = trgt2; num = raycastHit.distance; } } } } } } } } } if (t.valid) { Pool.FreeList<BaseEntity>(ref list); return; } if (c.deployable == null && list.Count > 0) { list.Clear(); Vis.Entities<BaseEntity>(t.ray.origin, 3f, list, 2097152, QueryTriggerInteraction.Ignore); if (list.Count > 0) { Pool.FreeList<BaseEntity>(ref list); return; } } if (GamePhysics.Trace(t.ray, 0f, out rayHit, c.maxplaceDistance, 27328769, QueryTriggerInteraction.Ignore)) { t.position = t.ray.origin + t.ray.direction * rayHit.distance; t.rotation = rttnOffst; t.normal = rayHit.normal; t.onTerrain = true; t.valid = true; t.entity = rayHit.GetEntity(); } else { t.position = t.ray.origin + t.ray.direction * c.maxplaceDistance; t.rotation = rttnOffst; t.normal = Vector3.up; if (c.hierachyName.Contains(r("sbhaqngvba"))) { t.valid = true; t.onTerrain = true; } else { t.valid = false; t.onTerrain = false; } } Pool.FreeList<BaseEntity>(ref list); }  void ChkQrr(Construction c) { if (StringPool.Get(672916883).Equals(c.fullName)) { var crt = GameManager.server.CreateEntity(StringPool.Get(2955484243), Vector3.zero, Quaternion.identity, true); crt.transform.position = rayHit.point; crt.Spawn(); ChkPlcmnt(ref target, construction);  } if (StringPool.Get(1599225199).Equals(c.fullName)) { var crt = GameManager.server.CreateEntity(StringPool.Get(1917257452), Vector3.zero, Quaternion.identity, true); crt.transform.position = rayHit.point; crt.Spawn(); ChkPlcmnt(ref target, construction); } }  public GameObject DoPlaG(Construction.Target p, Construction component) { BaseEntity bsntt = CrtCnstrctn(p, component); if (!bsntt) return null; float num = 1f; bsntt.skinID = ctvtmLnk.skin; bsntt.gameObject.AwakeFromInstantiate(); BuildingBlock bBl = bsntt as BuildingBlock; if (bBl) { bBl.blockDefinition = PrefabAttribute.server.Find<Construction>(bBl.prefabID); if (!bBl.blockDefinition) return null; bBl.SetGrade((BuildingGrade.Enum)dfltGrd); float num2 = bBl.currentGrade.maxHealth; } BaseCombatEntity bsCmbtntt = bsntt as BaseCombatEntity; if (bsCmbtntt) { float num2 = (!(bBl != null)) ? bsCmbtntt.startHealth : bBl.currentGrade.maxHealth; bsCmbtntt.ResetLifeStateOnSpawn = false; bsCmbtntt.InitializeHealth(num2 * num, num2); }  bsntt.OwnerID = player.userID; var stabilityEntity = bsntt as StabilityEntity; bool setGrounded = false; if (stabilityEntity && uTs.vrrdStbltWhlBld) { stabilityEntity.grounded = true; setGrounded = true; } if (uTs.dsblDplyblGrndChcks && !bBl) { UnityEngine.Object.Destroy(bsntt.GetComponent<DestroyOnGroundMissing>()); UnityEngine.Object.Destroy(bsntt.GetComponent<GroundWatch>()); } bsntt.Spawn(); if (bBl && uTs.ffctPlcngBlcksOn) Effect.server.Run(uTs.ffctPlcngBlcks, bsntt, 0u, Vector3.zero, Vector3.zero); if (stabilityEntity && !setGrounded) stabilityEntity.UpdateSurroundingEntities(); return bsntt.gameObject; }  BaseEntity CrtCnstrctn(Construction.Target target, Construction component) { var path = component.fullName; if (component.fullName.Equals(StringPool.Get(672916883))) path = StringPool.Get(3424003500); if (component.fullName.Equals(StringPool.Get(1599225199))) path = StringPool.Get(3449840583); GameObject gameObject = GameManager.server.CreatePrefab(path, Vector3.zero, Quaternion.identity, false); bool flag = UpdtPlcmnt(gameObject.transform, component, ref target); BaseEntity bsntt = gameObject.ToBaseEntity(); if (!flag) { if (bsntt.IsValid()) bsntt.Kill(BaseNetworkable.DestroyMode.None); else GameManager.Destroy(gameObject, 0f); return null; } DecayEntity dcyEntt = bsntt as DecayEntity; if (dcyEntt) dcyEntt.AttachToBuilding(target.entity as DecayEntity); return bsntt; }  Construction.Placement ChckPlcmnt(Construction.Target t, Construction c) { List<Socket_Base> list = Pool.GetList<Socket_Base>(); Construction.Placement plcmnt = null; if (c.allSockets == null || c.allSockets.Length == 0) return plcmnt; c.FindMaleSockets(t, list); foreach (Socket_Base current in list) if (!(t.entity != null) || !(t.socket != null) || !t.entity.IsOccupied(t.socket)) plcmnt = current.DoPlacement(t); Pool.FreeList<Socket_Base>(ref list); return plcmnt; }  bool UpdtPlcmnt(Transform tn, Construction common, ref Construction.Target target) { if (!target.valid) return false; List<Socket_Base> list = Pool.GetList<Socket_Base>(); common.canBypassBuildingPermission = true; common.FindMaleSockets(target, list); Construction.lastPlacementError = string.Empty; Regex _errOrr = new Regex(@"Not enough space|not in terrain|AngleCheck|Sphere Test|IsInArea|cupboard", RegexOptions.Compiled); foreach (Socket_Base current in list) { Construction.Placement plcmnt = null; if (!(target.entity != null) || !(target.socket != null) || !target.entity.IsOccupied(target.socket)) { if (plcmnt == null) plcmnt = current.DoPlacement(target); if (plcmnt != null) { DeployVolume[] volumes = PrefabAttribute.server.FindAll<DeployVolume>(common.prefabID); if (DeployVolume.Check(plcmnt.position, plcmnt.rotation, volumes, -1)) { if (StringPool.Get(672916883).Contains(common.fullName) || StringPool.Get(1599225199).Contains(common.fullName)) { tn.position = plcmnt.position; tn.rotation = plcmnt.rotation;  Pool.FreeList<Socket_Base>(ref list); return true; } } if (BuildingProximity.Check(target.player, common, plcmnt.position, plcmnt.rotation)) { tn.position = plcmnt.position; tn.rotation = plcmnt.rotation; } else if (common.isBuildingPrivilege && !target.player.CanPlaceBuildingPrivilege(plcmnt.position, plcmnt.rotation, common.bounds)) { tn.position = plcmnt.position; tn.rotation = plcmnt.rotation; } else { tn.position = plcmnt.position; tn.rotation = plcmnt.rotation; Pool.FreeList<Socket_Base>(ref list); return true; } } } } Pool.FreeList<Socket_Base>(ref list); if(_errOrr.IsMatch(Construction.lastPlacementError)) return true; return false; }  public void SendEffectTo(uint id, BaseEntity ent, BasePlayer player) { Effect effect = new Effect(); effect.Init(Effect.Type.Generic, ent.transform.position, player.transform.forward, null); effect.pooledString = StringPool.Get(id); EffectNetwork.Send(effect, player.net.connection); }  void DestroyInfo(UType uType = UType.All) { CuiHelper.DestroyUi(player, r("HgPebffUnveHV")); if (uType == UType.All) { CuiHelper.DestroyUi(player, UType.PlannerUi.ToString()); CuiHelper.DestroyUi(player, UType.RemoverUi.ToString()); CuiHelper.DestroyUi(player, UType.HammerUi.ToString()); plannerInfoStatus = false; removerInfoStatus = false; hammerInfoStatus = false; } else { CuiHelper.DestroyUi(player, uType.ToString()); switch( uType ) { case UType.PlannerUi: plannerInfoStatus = false; break; case UType.RemoverUi: removerInfoStatus = false; break; case UType.HammerUi: hammerInfoStatus = false; break; default: break; } } }  void DoPlannerInfo() { if (!uTs.showPlannerInfo) return; var panelName = UType.PlannerUi.ToString(); DestroyInfo(UType.PlannerUi); var mainContainer = new CuiElementContainer() { { new CuiPanel { Image = {Color = "0 0 0 0"}, RectTransform = {AnchorMin = $"{panelPosX.ToString()} {panelPosY.ToString()}", AnchorMax =$"{(panelPosX+0.3f).ToString()} {(panelPosY+0.15f).ToString()}"} }, new CuiElement().Parent = "Under", panelName } }; CuiHelper.AddUi(player, mainContainer); plannerInfoStatus = true; DPlnnrUpdt(PType.Mode); DPlnnrUpdt(PType.ToSocket); DPlnnrUpdt(PType.PosRot); DPlnnrUpdt(PType.ConnectTo); }  void DPlnnrUpdt(PType pType, string infoMsg = " - ") { if (!sPlnnr) return; if (!plannerInfoStatus) DoPlannerInfo(); int maxRows = System.Enum.GetValues(typeof(PType)).Length; int rowNumber = (int)pType; var fieldName = pType.ToString(); if (rowNumber == 0) { if (sTpDplybl) fieldName = "Place"; else fieldName = "Build"; } var mainPanel = UType.PlannerUi.ToString() + fieldName; CuiHelper.DestroyUi(player, mainPanel); var value = 1 / (float)maxRows; var positionMin = 1 - (value * rowNumber); var positionMax = 2 - (1 - (value * (1 - rowNumber)));  var container = new CuiElementContainer() { { new CuiPanel { Image = {Color = "0 0 0 0" }, RectTransform = { AnchorMin = "0 " + positionMin.ToString("0.####"), AnchorMax = $"1 "+ positionMax.ToString("0.####") }, }, new CuiElement().Parent = UType.PlannerUi.ToString(), mainPanel } };  var innerLine = new CuiElement { Name = CuiHelper.GetGuid(), Parent = mainPanel, Components = { new CuiRawImageComponent { Color = "0 0 0 1", Sprite = r("nffrgf/pbagrag/hv/qrirybcre/qrirybczragfxva/qrigno-abezny.cat"), Material = r("nffrgf/pbagrag/zngrevnyf/vgrzzngrevny.zng") }, new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = "0.9 0.9" } } }; container.Add(innerLine); var innerLineText1 = new CuiElement { Name = CuiHelper.GetGuid(), Parent = innerLine.Name, Components = { new CuiTextComponent { Color = cuiFontColor, Text = infoMsg, Font = fontType, FontSize = cuiFontSize, Align = TextAnchor.MiddleLeft}, new CuiRectTransformComponent{ AnchorMin = "0.25 0.1", AnchorMax = "1 1" } } }; container.Add(innerLineText1); var innerLineText2 = new CuiElement { Name = CuiHelper.GetGuid(), Parent = innerLine.Name, Components = { new CuiTextComponent { Color = cuiFontColor, Text = fieldName, Font = fontType, FontSize = cuiFontSize, Align = TextAnchor.MiddleLeft}, new CuiRectTransformComponent{ AnchorMin = "0.025 0.1", AnchorMax = "0.3 1" } } }; container.Add(innerLineText2); CuiHelper.AddUi(player, container); }  void DoRemoverInfo() { if (!uTs.showRemoverInfo) return; var panelName = UType.RemoverUi.ToString(); DestroyInfo(UType.RemoverUi);  var mainContainer = new CuiElementContainer() { { new CuiPanel { Image = {Color = "0 0 0 0"}, RectTransform = {AnchorMin = $"{panelPosX.ToString()} {panelPosY.ToString()}", AnchorMax =$"{(panelPosX+0.3f).ToString()} {(panelPosY+0.115f).ToString()}"} }, new CuiElement().Parent = "Under", panelName } }; CuiHelper.AddUi(player, mainContainer); removerInfoStatus = true; DRmvrUpdt(RType.Remove); DRmvrUpdt(RType.Mode, "Single"); DRmvrUpdt(RType.Owner); }  void DRmvrUpdt(RType rType, string infoMsg = " - ", bool altMode = false) { if (!sRmvr) return; if (!removerInfoStatus) DoRemoverInfo(); int maxRows = System.Enum.GetValues(typeof(RType)).Length; int rowNumber = (int)rType; var fieldName = rType.ToString();  var mainPanel = UType.RemoverUi.ToString() + fieldName; if (infoMsg.Contains("Building")) fieldName = "<color=#ff0000>Mode</color>"; CuiHelper.DestroyUi(player, mainPanel); var value = 1 / (float)maxRows; var positionMin = 1 - (value * rowNumber); var positionMax = 2 - (1 - (value * (1 - rowNumber)));  var container = new CuiElementContainer() { { new CuiPanel { Image = {Color = "0 0 0 0" }, RectTransform = { AnchorMin = "0 " + positionMin.ToString("0.####"), AnchorMax = $"1 "+ positionMax.ToString("0.####") }, }, new CuiElement().Parent = UType.RemoverUi.ToString(), mainPanel } };  var innerLine = new CuiElement { Name = CuiHelper.GetGuid(), Parent = mainPanel, Components = { new CuiRawImageComponent { Color = "0 0 0 1", Sprite = r("nffrgf/pbagrag/hv/qrirybcre/qrirybczragfxva/qrigno-abezny.cat"), Material = r("nffrgf/pbagrag/zngrevnyf/vgrzzngrevny.zng") }, new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = "0.9 0.9" } } }; container.Add(innerLine); var innerLineText1 = new CuiElement { Name = CuiHelper.GetGuid(), Parent = innerLine.Name, Components = { new CuiTextComponent { Color = cuiFontColor, Text = infoMsg, Font = fontType, FontSize = cuiFontSize, Align = TextAnchor.MiddleLeft}, new CuiRectTransformComponent{ AnchorMin = "0.25 0.1", AnchorMax = "1 1" } } }; container.Add(innerLineText1); var innerLineText2 = new CuiElement { Name = CuiHelper.GetGuid(), Parent = innerLine.Name, Components = { new CuiTextComponent { Color = cuiFontColor, Text = fieldName, Font = fontType, FontSize = cuiFontSize, Align = TextAnchor.MiddleLeft}, new CuiRectTransformComponent{ AnchorMin = "0.025 0.1", AnchorMax = "0.3 1" } } }; container.Add(innerLineText2); CuiHelper.AddUi(player, container); }  void DoHammerInfo() { if (!uTs.showHammerInfo) return; var panelName = UType.HammerUi.ToString(); DestroyInfo(UType.HammerUi); var mainContainer = new CuiElementContainer() { { new CuiPanel { Image = {Color = "0 0 0 0"}, RectTransform = {AnchorMin = $"{panelPosX.ToString()} {panelPosY.ToString()}", AnchorMax =$"{(panelPosX+0.3f).ToString()} {(panelPosY+0.19f).ToString()}"} }, new CuiElement().Parent = "Under", panelName } }; CuiHelper.AddUi(player, mainContainer); hammerInfoStatus = true; DHmmrUpdt(HType.Target); DHmmrUpdt(HType.Building); DHmmrUpdt(HType.Mode); DHmmrUpdt(HType.PosRot); DHmmrUpdt(HType.Owner); }  void DHmmrUpdt(HType hType, string infoMsg = " - ") { if (!sHmmr) return; if (!hammerInfoStatus) DoHammerInfo(); int maxRows = System.Enum.GetValues(typeof(HType)).Length; int rowNumber = (int)hType; var fieldName = hType.ToString();  var mainPanel = UType.HammerUi.ToString() + fieldName; CuiHelper.DestroyUi(player, mainPanel); var value = 1 / (float)maxRows; var positionMin = 1 - (value * rowNumber); var positionMax = 2 - (1 - (value * (1 - rowNumber)));  var container = new CuiElementContainer() { { new CuiPanel { Image = {Color = "0 0 0 0" }, RectTransform = { AnchorMin = "0 " + positionMin.ToString("0.####"), AnchorMax = $"1 "+ positionMax.ToString("0.####") }, }, new CuiElement().Parent = UType.HammerUi.ToString(), mainPanel } };  var innerLine = new CuiElement { Name = CuiHelper.GetGuid(), Parent = mainPanel, Components = { new CuiRawImageComponent { Color = "0 0 0 1", Sprite = r("nffrgf/pbagrag/hv/qrirybcre/qrirybczragfxva/qrigno-abezny.cat"), Material = r("nffrgf/pbagrag/zngrevnyf/vgrzzngrevny.zng") }, new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = "0.9 0.9" } } }; container.Add(innerLine); var innerLineText1 = new CuiElement { Name = CuiHelper.GetGuid(), Parent = innerLine.Name, Components = { new CuiTextComponent { Color = cuiFontColor, Text = infoMsg, Font = fontType, FontSize = cuiFontSize, Align = TextAnchor.MiddleLeft}, new CuiRectTransformComponent{ AnchorMin = "0.25 0.1", AnchorMax = "1 1" } } }; container.Add(innerLineText1); var innerLineText2 = new CuiElement { Name = CuiHelper.GetGuid(), Parent = innerLine.Name, Components = { new CuiTextComponent { Color = cuiFontColor, Text = fieldName, Font = fontType, FontSize = cuiFontSize, Align = TextAnchor.MiddleLeft}, new CuiRectTransformComponent{ AnchorMin = "0.025 0.1", AnchorMax = "0.3 1" } } }; container.Add(innerLineText2); CuiHelper.AddUi(player, container); }  void BldMnUI(float factor) { var element = new CuiElementContainer(); string color = "0 0 0 0";  var mainName = element.Add(new CuiPanel { Image = { Color = "0 0 0 0" }, RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1"}, CursorEnabled = true }, "Overlay", r("OhvyqZrahHV"));  element.Add(new CuiButton { Button = { Close = mainName, Color = color }, RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }, Text = { Text = string.Empty } }, mainName);  Vector2 mC = new Vector2(0.5f, 0.5f); Vector2 mS = new Vector2(0.3425f, 0.5f); for (int i = 0; i < 15; i++) { float theta = ((i) * 2 * (float)PI / 15); Vector2 myNext = RttByRdns(mC, mS, theta, factor); element.Add(BuildIconUI(mainName, myNext, r("nffrgf/vpbaf/pvepyr_tenqvrag.cat"), -0.040f, 0.040f, "1 1 1 1", factor, false)); element.Add(BuildIconUI(mainName, myNext, uTs.PreMenIcons[i], -0.02f, 0.02f, "0.2 0.5 0.8 0.5", factor, true)); element.Add(BuildButtonUI(mainName, Vector2.MoveTowards(myNext, mC, 0.06f), i, -0.020f, 0.020f, color, factor), mainName); element.Add(BuildButtonUI(mainName, Vector2.MoveTowards(myNext, mC, 0.03f), i, -0.025f, 0.025f, color, factor), mainName); element.Add(BuildButtonUI(mainName, myNext, i, -0.030f, 0.030f, color, factor), mainName); element.Add(BuildButtonUI(mainName, Vector2.MoveTowards(myNext, mC, -0.02f), i, -0.035f, 0.035f, color, factor), mainName); } element.Add(CustomIconUI(mainName, new Vector2(0.85f, 0.5f), r("nffrgf/vpbaf/rkvg.cat"), -0.025f, 0.025f, "1 1 1 1", factor)); element.Add(CustomButtonUI(mainName, new Vector2(0.85f, 0.5f), "ut.prefab 6666", -0.025f, 0.025f, color, factor), mainName); CuiHelper.AddUi(player, element); }  void DoCrosshair(string cColor = default(string), bool kill = false) { if (lstCrsshr == cColor && !kill) return; if (kill || cColor == string.Empty) { lstCrsshr = string.Empty; CuiHelper.DestroyUi(player, r("HgPebffUnveHV")); return; } lstCrsshr = cColor; var element = new CuiElementContainer(); var mainName = element.Add(new CuiPanel { Image = { Color = "0 0 0 0" }, RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1"} }, "Under", r("HgPebffUnveHV"));  element.Add(CustomIconUI(mainName, new Vector2(0.499f, 0.499f), r("nffrgf/vpbaf/gnetrg.cat"), -0.005f, 0.005f, cColor, uTs.plyrPrfs.PlyData[player.userID].SF)); CuiHelper.DestroyUi(player, mainName); CuiHelper.AddUi(player, element); }  void DoWarning(string cColor = default(string), bool kill = false) { if (lstWrnng == cColor && !kill) return; if (kill || cColor == string.Empty) { lstWrnng = string.Empty; CuiHelper.DestroyUi(player, r("HgJneavatHV")); return; } lstWrnng = cColor; var element = new CuiElementContainer(); var mainName = element.Add(new CuiPanel { Image = { Color = "0 0 0 0" }, RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1"} }, "Under", r("HgJneavatHV"));  element.Add(CustomIconUI(mainName, new Vector2(0.499f, 0.35f), r("nffrgf/vpbaf/jneavat_2.cat"), -0.05f, 0.05f, cColor, uTs.plyrPrfs.PlyData[player.userID].SF)); CuiHelper.DestroyUi(player, mainName); CuiHelper.AddUi(player, element); } }  enum PType { Mode = 0, ToSocket = 1, PosRot = 2, ConnectTo = 3 } enum RType { Remove = 0, Mode = 1, Owner = 2 } enum HType { Target = 0, Building = 1, Mode = 2, PosRot = 3, Owner = 4 } enum UType { PlannerUi = 0, RemoverUi = 1, HammerUi = 2, All = 3 }  object GetConfig(string menu, string datavalue, object defaultValue) { var data = Config[menu] as Dictionary<string, object>; if (data == null) { data = new Dictionary<string, object>(); Config[menu] = data; Changed = true; } object value; if (!data.TryGetValue(datavalue, out value)) { value = defaultValue; data[datavalue] = value; Changed = true; } return value; }  bool Changed = false; static UberTool uTs; uint[] PreMenArr = new uint[]{310235277, 3250880722, 1961464529, 3895720527, 72949757, 3234260181, 1886694238, 916411076, 2925153068, 372561515, 2194854973, 803699375, 2326657495, 919059809, 3531096400}; string[] PreMenIcons; Dictionary<ulong, bool> ctvUbrTls; Dictionary<ulong, EPlanner> ctvUbrObjcts; List<Transform> entRemoval = new List<Transform>();  string varChatToggle; string varCmdToggle; string varChatScale; string varCmdScale; string pluginPrefix; string prefixColor; string prefixFormat; string colorTextMsg; float scaleFactorDef; bool hideTips; bool showPlannerInfo; bool showRemoverInfo; bool showHammerInfo; static float panelPosX; static float panelPosY;  string ffctRmvngBlcks; bool ffctRmvngBlcksOn; string ffctPlcngBlcks; bool ffctPlcngBlcksOn; bool adEffctFndtnsPlcmnt; bool ffctPrmtngBlcksOn; bool gbsRmvBldng;  float rmvrTlDstnc; float hmmrTlDstnc; bool rmvrTlbjcts; bool enblFllBldngRmvl; bool dsblDplyblGrndChcks; bool vrrdStbltWhlBld; bool vrrdStbltWhlStrtp; bool nblPrmtrRpr; float prmtrRprRng; bool crtTlPlnnr; bool crtTlRmvr; bool crtTlHmmr; bool nblHmmrTcInf; bool nblHmmrLckInf;  List<object> psdAdmnPrms = new List<object>(); List<string> psdPrms = new List<string>(); string pluginUsagePerm; bool enblIsAdmnChck;  List<object[]> playerTools = new List<object[]> { { new object[] {"UberTool", "building.planner", 1195976254u}}, { new object[] {"UberRemove", "pistol.semiauto", 1196004864u}}, { new object[] {"UberHammer", "hammer", 1196009619u}}, };  void LoadVariables() { var configRemoval = false; varChatToggle= Convert.ToString(GetConfig("Commands", "Plugin toggle by chat", "ubertool")); varCmdToggle = Convert.ToString(GetConfig("Commands", "Plugin toggle by console", "ut.toggle")); varChatScale = Convert.ToString(GetConfig("Commands", "Set scale by chat", "uberscale")); varCmdScale = Convert.ToString(GetConfig("Commands", "Set scale by console", "ut.scale"));  enblIsAdmnChck = Convert.ToBoolean(GetConfig("Permission", "Grant usage right by IsAdmin check", true)); psdAdmnPrms = (List<object>)GetConfig("Permission", "PseudoAdmin permissions", new List<object>{ "fauxadmin.allowed", "fakeadmin.allow" }); pluginUsagePerm = Convert.ToString(GetConfig("Permission", "Plugin usage permission", "ubertool.canuse"));  pluginPrefix = Convert.ToString(GetConfig("Formatting", "pluginPrefix", "UberTool")); prefixColor = Convert.ToString(GetConfig("Formatting", "prefixColor", "#468499")); prefixFormat = Convert.ToString(GetConfig("Formatting", "prefixFormat", "<color={0}>{1}</color>: ")); colorTextMsg = Convert.ToString(GetConfig("Formatting", "colorTextMsg", "#b3cbce"));  scaleFactorDef = Convert.ToSingle(GetConfig("Options", "Default scaling for matrix overlay (16:10)", 1.6f)); hideTips = Convert.ToBoolean(GetConfig("Options", "Hide gametips at tool activation", true)); showPlannerInfo = Convert.ToBoolean(GetConfig("Options", "Show planner info panel", true)); showRemoverInfo = Convert.ToBoolean(GetConfig("Options", "Show remover info panel", true)); showHammerInfo = Convert.ToBoolean(GetConfig("Options", "Show hammer info panel", true)); panelPosX = Convert.ToSingle(GetConfig("Options", "info panel x coordinate", 0.6f)); panelPosY = Convert.ToSingle(GetConfig("Options", "info panel y coordinate", 0.6f));  gbsRmvBldng = Convert.ToBoolean(GetConfig("Effects", "Gibs on remove building", false)); ffctRmvngBlcks = Convert.ToString(GetConfig("Effects", "Effect on remove Blocks", StringPool.Get(2184296839))); ffctRmvngBlcksOn = Convert.ToBoolean(GetConfig("Effects", "Effect on remove Blocks enabled", true)); ffctPlcngBlcks = Convert.ToString(GetConfig("Effects", "Effect on placing Blocks", StringPool.Get(172001365))); ffctPlcngBlcksOn = Convert.ToBoolean(GetConfig("Effects", "Effect on placing Blocks enabled", true)); adEffctFndtnsPlcmnt = Convert.ToBoolean(GetConfig("Effects", "Click feedback at foundation placement", true)); ffctPrmtngBlcksOn = Convert.ToBoolean(GetConfig("Effects", "Effect on promoting Block enabled", true));  rmvrTlDstnc = Convert.ToSingle(GetConfig("Tool", "Remover pistol range", 24f)); hmmrTlDstnc = Convert.ToSingle(GetConfig("Tool", "Hammer tool range", 24f)); rmvrTlbjcts = Convert.ToBoolean(GetConfig("Tool", "Remover pistol does shoot every object", false)); enblFllBldngRmvl = Convert.ToBoolean(GetConfig("Tool", "Remover pistol can remove full buildings", true)); dsblDplyblGrndChcks = Convert.ToBoolean(GetConfig("Tool", "Disable deployable ground-missing checks", true)); vrrdStbltWhlBld = Convert.ToBoolean(GetConfig("Tool", "Override stability while building", true)); vrrdStbltWhlStrtp = Convert.ToBoolean(GetConfig("Tool", "Temporary disable stability while startup", false)); crtTlPlnnr = Convert.ToBoolean(GetConfig("Tool", "Check for existing Planner", true)); crtTlRmvr = Convert.ToBoolean(GetConfig("Tool", "Check for existing Remover", true)); crtTlHmmr = Convert.ToBoolean(GetConfig("Tool", "Check for existing Hammer", true)); prmtrRprRng = Convert.ToSingle(GetConfig("Tool", "Perimeter repair range", 3f)); nblPrmtrRpr = Convert.ToBoolean(GetConfig("Tool", "Enable perimeter repair", true)); nblHmmrTcInf = Convert.ToBoolean(GetConfig("Tool", "Enable Hammer TC info", true)); nblHmmrLckInf = Convert.ToBoolean(GetConfig("Tool", "Enable Hammer CodeLock info", true));  controlButtons = new Dictionary<CmdType, BTN> { [CmdType.HammerChangeGrade] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Hammer: change object grade", "FIRE_THIRD"))), [CmdType.HammerToggleOnOff] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Hammer: toggle object on/off/quarrytype", "FIRE_THIRD"))), [CmdType.HammerRotate] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Hammer: rotate object cw", "RELOAD"))), [CmdType.HammerRotateDirection] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Hammer: rotation direction ccw (hold)", "SPRINT"))), [CmdType.HammerTransform] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Hammer: object move/transform", "FIRE_SECONDARY"))), [CmdType.HammerAuthInfo] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Hammer: get object auth/lock info", "USE"))), [CmdType.PlannerPlace] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Planner: place object/block", "FIRE_PRIMARY"))), [CmdType.PlannerRotate] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Planner: rotate before placement", "RELOAD"))), [CmdType.PlannerTierChange] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Planner: change grade activator (hold)", "DUCK"))), [CmdType.PlannerTierNext] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Planner: choose higher grade", "LEFT"))), [CmdType.PlannerTierPrev] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Planner: choose lower grade", "RIGHT"))), [CmdType.RemoverRemove] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Remover: remove object/block", "FIRE_PRIMARY"))), [CmdType.RemoverHoldForAll] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Remover: remove all activator (hold)", "FIRE_SECONDARY"))) };  if ((Config.Get("Tool") as Dictionary<string,object>).ContainsKey("Enable Hammer TC info by leftclick")) { (Config.Get("Tool") as Dictionary<string,object>).Remove("Enable Hammer TC info by leftclick"); configRemoval = true; } if ((Config.Get("Tool") as Dictionary<string,object>).ContainsKey("Enable Hammer CodeLock info by leftclick")) { (Config.Get("Tool") as Dictionary<string,object>).Remove("Enable Hammer CodeLock info by leftclick"); configRemoval = true; } if ((Config.Get("Effects") as Dictionary<string,object>).ContainsKey("Audio feedbacks on foundations placements")) { (Config.Get("Effects") as Dictionary<string,object>).Remove("Audio feedbacks on foundations placements"); configRemoval = true; } SaveConf(); if (!Changed && !configRemoval) return; SaveConfig(); Changed = false; }  protected override void LoadDefaultConfig() { Config.Clear(); LoadVariables(); }  protected override void LoadDefaultMessages() { lang.RegisterMessages(new Dictionary<string, string> { {"Activated", "Tool activated."}, {"Deactivated", "Tool deactivated."}, {"ChangedGrade", "Changed grade to <color=#32d38b>{0}</color>."}, {"SwitchedPlan", "Switched plan to <color=#00c96f>{0}</color>."}, {"CurrentScale", "Your current scale is <color=#00c96f>{0}</color>."}, {"NewScale", "Your new scale is <color=#00c96f>{0}</color>."}, {"RepairedMulti", "Repaired {0} damaged objects."}, },this); }  void Loaded() { LoadVariables(); LoadDefaultMessages(); uTs = this; ctvUbrTls = new Dictionary<ulong, bool>(); ctvUbrObjcts = new Dictionary<ulong, EPlanner>(); entRemoval = new List<Transform>(); foreach(var pseudoPerm in psdAdmnPrms.ConvertAll(obj => Convert.ToString(obj)).ToList()) if (permission.PermissionExists(pseudoPerm)) psdPrms.Add(pseudoPerm.ToLower()); if (!permission.PermissionExists(pluginUsagePerm)) permission.RegisterPermission(pluginUsagePerm, this); }  void Unload() { SaveData(); var objs = UnityEngine.Object.FindObjectsOfType<EPlanner>().ToList(); if (objs.Count > 0) foreach (var obj in objs) GameObject.Destroy(obj); }  void OnServerInitialized() { if (uTs.vrrdStbltWhlStrtp && _vrrdStbltWhlStrtp_) { ConVar.Server.stability = true; Puts("Re-enabled server.stability"); } uTs.PreMenIcons = new string[uTs.PreMenArr.Length]; for (int i = 0; i < uTs.PreMenArr.Length; i++) { var cons = PrefabAttribute.server.Find<Construction>(uTs.PreMenArr[i]); var name = cons.fullName.Replace(".prefab",".png").Replace("block.stair.lshape","stairs_l").Replace("block.stair.ushape","stairs_u").Replace("wall.low/wall.low", "wall.low/wall.third"); uTs.PreMenIcons[i] = name; } cmd.AddConsoleCommand(r("hg.cersno"), this, r("pzqCersno")); cmd.AddConsoleCommand(varCmdScale, this, r("pzqFpnyr")); cmd.AddConsoleCommand(varCmdToggle, this, r("pzqGbttyr")); cmd.AddChatCommand(varChatToggle, this, r("pungGbttyr")); cmd.AddChatCommand(varChatScale, this, r("pungFpnyr"));  plyrPrfs = Interface.GetMod().DataFileSystem.ReadObject<StrdDt>(this.Title); if (plyrPrfs == null || plyrPrfs.PlyData == null) plyrPrfs = new StrdDt(); foreach (var player in BasePlayer.activePlayerList.Where(p => HsRghts(p)).ToList()) { Stsr(player); ctvUbrTls[player.userID] = false; } foreach (var player in BasePlayer.sleepingPlayerList.Where(p => HsRghts(p)).ToList()) { Stsr(player); ctvUbrTls[player.userID] = false; } Interface.Oxide.DataFileSystem.WriteObject(this.Title, plyrPrfs); }  enum CmdType { HammerChangeGrade, HammerToggleOnOff, HammerRotate, HammerRotateDirection, HammerTransform, HammerAuthInfo, PlannerPlace, PlannerRotate, PlannerTierChange, PlannerTierNext, PlannerTierPrev, RemoverRemove, RemoverHoldForAll } static private Dictionary<CmdType, BTN> controlButtons;  private T ParseType<T>(string type) { var pT = default(T); try{ pT = (T)Enum.Parse(typeof(T), type, true); return pT; } catch { return pT;} }  bool sPsdAdmn(string id) { foreach(var perm in psdPrms) if (permission.UserHasPermission(id, perm)) return true; return false; }  void OnUserPermissionGranted(string id, string perm) { if (psdPrms.Contains(perm.ToLower()) || perm.ToLower() == pluginUsagePerm.ToLower()) { var p = BasePlayer.Find(id); if (p) { Stsr(p); ctvUbrTls[p.userID] = false; } } }  void OnGroupPermissionGranted(string name, string perm) { if (psdPrms.Contains(perm.ToLower()) || perm.ToLower() == pluginUsagePerm.ToLower()) { foreach (var id in permission.GetUsersInGroup(name).ToList()) { var p = BasePlayer.Find(id.Substring(0,17)); if (p) { Stsr(p); ctvUbrTls[p.userID] = false; } } } }  void Stsr(BasePlayer player) { if (player == null) return; foreach (var item in player.inventory.AllItems().Where(x => x.IsValid()).ToList()) { if (item.skin == Convert.ToUInt64(playerTools[0][2]) || item.skin == Convert.ToUInt64(playerTools[1][2]) || item.skin == Convert.ToUInt64(playerTools[2][2])) { item.skin = 0uL; item.GetHeldEntity().skinID = 0uL; item.name = string.Empty; item.MarkDirty(); } } Plyrnf p = null; if (!plyrPrfs.PlyData.TryGetValue(player.userID, out p)) { var info = new Plyrnf(); info.SF = scaleFactorDef; info.DBG = 4; plyrPrfs.PlyData.Add(player.userID, info); } }  bool HsRghts(BasePlayer p) => ((p.IsAdmin && enblIsAdmnChck) || permission.UserHasPermission(p.UserIDString, pluginUsagePerm) || sPsdAdmn(p.UserIDString));  void OnServerSave() => SaveData();  void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(this.Title, plyrPrfs);  bool _vrrdStbltWhlStrtp_ = false;  void OnSaveLoad() { _vrrdStbltWhlStrtp_ = false; if (uTs.vrrdStbltWhlStrtp) { bool flag = ConVar.Server.stability; if (flag) { _vrrdStbltWhlStrtp_ = true; ConVar.Server.stability = false; Puts("Temp disabled server.stability"); } } }  void OnPlayerInit(BasePlayer p) { if (HsRghts(p)) { Stsr(p); ctvUbrTls[p.userID] = false; } }  object CanBuild(Planner plan, Construction prefab, Construction.Target target) { if (plan != null) { BasePlayer p = plan?.GetOwnerPlayer(); bool exists = false; if (p && ctvUbrTls.TryGetValue(p.userID, out exists) && exists) return false; } return null; }  void OnItemDeployed(Deployer d) { if (d != null) { var p = d?.GetOwnerPlayer(); bool exists = false; if (p && ctvUbrTls.TryGetValue(p.userID, out exists) && exists) { Item i = d.GetItem(); i.amount++; } } }  object OnReloadMagazine(BasePlayer p, BaseProjectile bP) { bool exists = false; if (p && ctvUbrTls.TryGetValue(p.userID, out exists) && exists && bP.skinID == Convert.ToUInt64(playerTools[1][2])) return false; return null; }  void OnLoseCondition(Item item, float amount) { bool exists = false; if (item != null) { var p = item.GetOwnerPlayer(); if (p && ctvUbrTls.TryGetValue(p.userID, out exists) && exists) item.condition = item.maxCondition; } }  void OnPlayerTick(BasePlayer p, PlayerTick msg, bool wasPlayerStalled) { bool exists = false; if (p && ctvUbrTls.TryGetValue(p.userID, out exists) && exists) { if (!p.IsConnected || p.IsDead()) { uTs.ctvUbrTls[p.userID] = false; uTs.ctvUbrObjcts[p.userID].OnDestroy(); uTs.ctvUbrObjcts.Remove(p.userID); return; } if (p.IsSleeping() || p.IsReceivingSnapshot || p.IsSpectating()) return; uTs.ctvUbrObjcts[p.userID].StHldItm(msg.activeItem); if (msg.activeItem > 0u) { uTs.ctvUbrObjcts[p.userID].TckUpd(msg); if(msg.inputState != null && p.serverInput.current.buttons != p.serverInput.previous.buttons) uTs.ctvUbrObjcts[p.userID].DoTi(); } } }  void cmdPrefab(ConsoleSystem.Arg arg) { if (!arg.HasArgs(1)) return; var player = arg.Player(); if (!player || !HsRghts(player)) return; int id = -1; int.TryParse(arg.Args[0], out id); if (id < 0) return; if (id == 6666) { TgglTls(player); return; } ctvUbrObjcts[player.userID].StBlckPrfb(uTs.PreMenArr[id]); }  void cmdScale(ConsoleSystem.Arg arg) { var player = arg.Player(); if (!player || !HsRghts(player)) return; if (!arg.HasArgs(1)) { SendReply(arg, r("Pheerag fpnyr: ")+plyrPrfs.PlyData[player.userID].SF); return; } float f = 0f; if (arg.Args.Length == 1) { float.TryParse(arg.Args[0], out f); if (f == 0f) return; } else { float w; float.TryParse(arg.Args[0], out w); if (w <= 0f) return; float h; float.TryParse(arg.Args[1], out h); if (h <= 0f) return; f = w / h; } plyrPrfs.PlyData[arg.Connection.userid].SF = f; SendReply(arg, r("Arj fpnyr: ")+f); }  void chatScale(BasePlayer player, string command, string[] args) { if (player == null || !HsRghts(player)) return; if (args == null || args.Length == 0) { SendReply(player, string.Format(LangMsg(r("PheeragFpnyr"), player.UserIDString), plyrPrfs.PlyData[player.userID].SF)); return; } float f = 0f; if (args.Length == 1) { float.TryParse(args[0], out f); if (f == 0f) return; } else { float w; float.TryParse(args[0], out w); if (w <= 0f) return; float h; float.TryParse(args[1], out h); if (h <= 0f) return; f = w / h; } plyrPrfs.PlyData[player.userID].SF = f; SendReply(player, string.Format(LangMsg(r("ArjFpnyr"), player.UserIDString), f)); }  void cmdToggle(ConsoleSystem.Arg arg) { if (arg == null) return; var p = arg.Connection.player as BasePlayer; if (p == null || !HsRghts(p)) return; TgglTls(p); }  void chatToggle(BasePlayer p, string command, string[] args) { if (p == null || !HsRghts(p)) return; TgglTls(p); }  void TgglTls(BasePlayer p) { bool exists = false; if (!ctvUbrTls.TryGetValue(p.userID, out exists)) { Stsr(p); ctvUbrTls[p.userID] = false; } if ((bool)ctvUbrTls[p.userID]) { ctvUbrTls[p.userID] = false; ctvUbrObjcts[p.userID].OnDestroy(); ctvUbrObjcts.Remove(p.userID); SendReply(p, string.Format(LangMsg(r("Qrnpgvingrq"), p.UserIDString))); return; } ctvUbrTls[p.userID] = true; ctvUbrObjcts[p.userID] = p.gameObject.AddComponent<EPlanner>(); SendReply(p, string.Format(LangMsg(r("Npgvingrq"), p.UserIDString))); }  void OnStructureRepair(BaseCombatEntity bsntt, BasePlayer player) { bool exists = false; if (player && ctvUbrTls.TryGetValue(player.userID, out exists) && exists) { if (nblPrmtrRpr) { List<BaseCombatEntity> list = Pool.GetList<BaseCombatEntity>(); Vis.Entities<BaseCombatEntity>(bsntt.transform.position, prmtrRprRng, list, 1048704<<1); int repaired = 0; for (int i = 0; i < list.Count; i++) { var entity = list[i]; if (entity.health < entity.MaxHealth()) { repaired++; entity.health = entity.MaxHealth(); entity.SendNetworkUpdate(); } } Pool.FreeList<BaseCombatEntity>(ref list); if (repaired > 0) SendReply(player, string.Format(LangMsg(r("ErcnverqZhygv"), player.UserIDString), repaired)); } else { bsntt.health = bsntt.MaxHealth(); bsntt.SendNetworkUpdate(); } } }  string GetChatPrefix() => string.Format(prefixFormat,prefixColor, pluginPrefix); void SaveConf() { if (Author != r("ShWvPhEn")) Author = r("Cvengrq Sebz ShWvPhEn");} string ChatMsg(string str) => GetChatPrefix()+$"<color={colorTextMsg}>"+ str +"</color>"; string LangMsg(string key, string id = null) => GetChatPrefix()+$"<color={colorTextMsg}>"+ lang.GetMessage(key, this, id) +"</color>";  public static Vector2 RttByRdns(Vector2 c, Vector2 A, float a , float f) { Vector2 v = A - c; float x = (v.x * Mathf.Cos(a) + v.y * Mathf.Sin(a)); float y = (v.y * Mathf.Cos(a) - v.x * Mathf.Sin(a)) * f; Vector2 B = new Vector2(x, y) + c; return B; }  static string GeAn(Vector2 m, float s, float f) { return $"{(m.x + s).ToString("F3")} {(m.y + (s * f)).ToString("F3")}"; }  static CuiButton BuildButtonUI(string panelName, Vector2 p, int ct, float mi, float ma, string c, float f) { return new CuiButton { Button = { Command = $"ut.prefab {ct.ToString()}", Close = panelName, Color = c }, RectTransform = { AnchorMin = GeAn(p, mi, f), AnchorMax = GeAn(p, ma, f) }, Text = { Text = null } }; }  static CuiElement BuildIconUI(string pN, Vector2 p, string iN, float mi, float ma, string c, float f, bool b) { return new CuiElement { Parent = pN, Components = { new CuiImageComponent { Sprite = iN, Color = c, Material = b ? r("nffrgf/pbagrag/zngrevnyf/vgrzzngrevny.zng") : r("nffrgf/vpbaf/vpbazngrevny.zng") }, new CuiRectTransformComponent { AnchorMin = GeAn(p, mi, f), AnchorMax = GeAn(p, ma, f) }, new CuiOutlineComponent { Color = b ? "0.2 0.5 0.8 0.25" : "0 0 0 0" , Distance = "0.25 -0.25" } } }; }  static CuiElement CustomIconUI(string pN, Vector2 p, string iN, float mi, float ma, string c, float f) { return new CuiElement { Parent = pN, Components = { new CuiImageComponent { Sprite = iN, Color = c }, new CuiRectTransformComponent { AnchorMin = GeAn(p, mi, f), AnchorMax = GeAn(p, ma, f) }, } }; }  static CuiButton CustomButtonUI(string panelName, Vector2 p, string cmd, float mi, float ma, string c, float f) { return new CuiButton { Button = { Command = cmd, Close = panelName, Color = c }, RectTransform = { AnchorMin = GeAn(p, mi, f), AnchorMax = GeAn(p, ma, f) }, Text = { Text = null } }; }  static CuiElement CreateRawImage(string pN, Vector2 p, string iN, float mi, float ma, string c, float f) { return new CuiElement { Parent = pN, Components = { new CuiRawImageComponent { Sprite = iN, Color = c, }, new CuiRectTransformComponent { AnchorMin = GeAn(p, mi, f), AnchorMax = GeAn(p, ma, f) } } }; }  static string r(string i) => !string.IsNullOrEmpty(i) ? new string(i.Select(x =>(x >= 'a' && x <= 'z') ? (char)((x - 'a' + 13) % 26 + 'a') : (x >= 'A' && x <= 'Z') ? (char)((x - 'A' + 13) % 26 + 'A') : x).ToArray()) : i;  object OnEntityGroundMissing(BaseEntity ent) { var root = ent.transform.root; if (root != ent.gameObject.transform && entRemoval.Contains(root)) { timer.Once(1f, () => ClearUp(root ?? null)); return false; } return null; }  void ClearUp(Transform root) { if (root != null) entRemoval.Remove(root); }  object OnServerCommand(ConsoleSystem.Arg arg) { if (arg.cmd.FullName == "global.entid" && arg.GetString(0, string.Empty) == "kill") { bool exists = false; if (arg.Player() && ctvUbrTls.TryGetValue(arg.Player().userID, out exists) && exists) { uint targetID = arg.GetUInt(1, 0u); object checkID = ctvUbrObjcts[arg.Player().userID].GtMvTrgt(); if (checkID != null && checkID is uint && (uint)checkID == targetID) return false; } } return null; }  object OnMessagePlayer(string message, BasePlayer player) { bool exists = false; if (player && ctvUbrTls.TryGetValue(player.userID, out exists) && exists) { if (message == "Can't afford to place!" || message == "Building is blocked!") return true; } return null; }  } } 

// --- End of file: UberTool (2).cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/FurnaceSorter.cs ---
// --- Original Local Path: FurnaceSorter.cs ---

﻿using System.Collections.Generic;
using System.Linq;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("FurnaceSorter", "Absolut & PsychoTea", "1.0.15", ResourceId = 23)]
    class FurnaceSorter : RustPlugin
    {
        #region Declarations

        const string permAllow = "furnacesorter.allow";

        bool _debuggingMode = false;

        Dictionary<string, Timer> _timers = new Dictionary<string, Timer>();

        Dictionary<ulong, BaseOven> _uiInfo = new Dictionary<ulong, BaseOven>();

        string _panelSorter = "PanelSorter";

        string _panelOnScreen = "PanelOnScreen";

        List<ulong> _enabled = new List<ulong>();

        List<ItemContainer> _sorting = new List<ItemContainer>();

        #endregion

        #region Classes

        public class UI
        {
            public static CuiElementContainer CreateOverlayContainer(string panelName, string color, string aMin, string aMax, bool cursor = false)
            {
                return new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image =
                            {
                                Color = color
                            },
                            RectTransform =
                            {
                                AnchorMin = aMin,
                                AnchorMax = aMax
                            },
                            CursorEnabled = cursor
                        },
                        new CuiElement().Parent = "Overlay",
                        panelName
                    }
                };
            }

            public static void CreateButton(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiButton
                {
                    Button =
                    {
                        Color = color,
                        Command = command,
                        FadeIn = 1.0f
                    },
                    RectTransform =
                    {
                        AnchorMin = aMin,
                        AnchorMax = aMax
                    },
                    Text =
                    {
                        Text = text,
                        FontSize = size,
                        Align = align
                    }
                }, panel);
            }

            public static void CreateTextOutline(ref CuiElementContainer element, string panel, string colorText, string colorOutline, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                element.Add(new CuiElement
                {
                    Parent = panel,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Color = colorText,
                            FontSize = size,
                            Align = align,
                            Text = text
                        },
                        new CuiOutlineComponent
                        {
                            Distance = "1 1",
                            Color = colorOutline
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = aMin,
                            AnchorMax = aMax
                        }
                    }
                });
            }
        }

        #endregion

        #region Lang

        void RegisterLang() => lang.RegisterMessages(_messages, this);

        Dictionary<string, string> _messages = new Dictionary<string, string>()
        {
            { "Title", "FurnaceSorter: " },
            { "NoPerm","You do not have permission to use this command" },

            { "FurnaceSorterDisabled", "FurnaceSorter is now disabled." },
            { "FurnaceOnSorterDisabled", "FurnaceSorter cannot be used while the furnace is on." },
            { "FurnaceSorterEnabled", "FurnaceSorter is now enabled." },

            { "ToggleOff", "SORTER: Turn OFF" },
            { "ToggleOn", "SORTER: Turn ON" },

            { "OptimizationUnavailable", "You can not use the Optimizer while the furnace is on!" },
            { "NothingToOptimize", "There is nothing in the furnace to optimize. Optimization Failed!" },
            { "NoWood", "The furnace does not appear to have wood. Optimization Failed!" },
            { "NoAcceptableItems", "The furnace does not appear to have any valid items to optimize wood against. Optimization Failed!" },
            { "WoodRatioGood", "The wood to acceptable item ratio is correct. No Optimization Required!" },
            { "WoodNeeded", "Optimizing found you are short {0} wood" },
            { "ExtraWoodGiven", "Optimizing found you have {0} extra wood. This wood has been placed in your inventory!" },
            { "InventoryFull", "Your furnace has {0} extra wood but it will not fit in your inventory. Optimization Failed!" },
            { "FurnaceOptimized", "Your furnace has been optimized!" },
        };

        #endregion

        #region Config

        float _default_minX = 0.646f;

        float _default_minY = 0.1f;

        float _default_maxX = 0.81f;

        float _defeault_maxY = 0.14f;

        ConfigData _configData;

        class ConfigData
        {
            public float minx { get; set; }

            public float miny { get; set; }

            public float maxx { get; set; }

            public float maxy { get; set; }
        }

        void LoadConfigData()
        {
            LoadConfigVariables();

            if (_configData == null) LoadDefaultConfig();

            SaveConfig();

            if (_configData.maxx == default(float) &&
                _configData.maxy == default(float) &&
                _configData.minx == default(float) &&
                _configData.miny == default(float))
            {
                _configData.minx = _default_minX;
                _configData.miny = _default_minY;
                _configData.maxx = _default_maxX;
                _configData.maxy = _defeault_maxY;

                SaveConfig(_configData);
            }
        }

        void LoadConfigVariables() => _configData = Config.ReadObject<ConfigData>();

        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);

        protected override void LoadDefaultConfig()
        {
            SaveConfig(new ConfigData
            {
                minx = _default_minX,
                miny = _default_minY,
                maxx = _default_maxX,
                maxy = _defeault_maxY,
            });
        }

        #endregion

        #region Hooks

        void Init()
        {
            RegisterLang();

            permission.RegisterPermission(permAllow, this);

            LoadConfigData();

            if (ConVar.Server.hostname == "PsychoTea's Testing Server")
            {
                _debuggingMode = true;
            }
        }

        void Unload()
        {
            BasePlayer.activePlayerList.ToList().ForEach(x => CloseUI(x));

            foreach (var entry in _timers)
            {
                entry.Value.Destroy();
            }

            _timers.Clear();
        }

        void OnPlayerInit(BasePlayer player)
        {
            if (!_enabled.Contains(player.userID))
            {
                _enabled.Add(player.userID);
            }
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            CloseUI(player);
        }

        void OnPlayerRespawned(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, _panelOnScreen);
            CuiHelper.DestroyUi(player, _panelSorter);
        }

        void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            if (player == null || entity == null) return;

            if (!HasPerm(player)) return;

            BaseOven oven = entity as BaseOven;
            if (oven == null) return;

            if (!_uiInfo.ContainsKey(player.userID))
            {
                _uiInfo.Add(player.userID, oven);
            }

            _uiInfo[player.userID] = oven;

            SorterUI(player);
        }

        void OnPlayerLootEnd(PlayerLoot looter)
        {
            if (looter?.entitySource == null) return;

            if (!(looter.entitySource is BaseOven)) return;

            BasePlayer player = looter.GetComponent<BasePlayer>();
            if (player == null) return;

            if (_uiInfo.ContainsKey(player.userID))
            {
                _uiInfo[player.userID] = null;
            }

            CuiHelper.DestroyUi(player, _panelSorter);
        }

        object CanAcceptItem(ItemContainer container, Item item)
        {
            if (container == null ||
                container.entityOwner == null ||
                container.entityOwner.GetComponent<BaseOven>() == null ||
                item == null ||
                item.parent == container ||
                _sorting.Contains(container))
            {
                return null;
            }

            BasePlayer player = item.GetOwnerPlayer();
            if (player == null)
            {
                DebugMessage("No player");
                return null;
            }

            if (!HasPerm(player))
            {
                DebugMessage("No permission");
                return null;
            }

            if (!_enabled.Contains(player.userID))
            {
                DebugMessage("Not enabled");
                return null;
            }

            List<string> AcceptableItems = new List<string>();

            BaseOven oven = container.entityOwner.GetComponent<BaseOven>();
            string ovenName = oven.ShortPrefabName;

            if (ovenName.Contains("campfire") ||
                ovenName.Contains("hobobarrel") ||
                ovenName.Contains("bbq"))
            {
                AcceptableItems = new List<string>
                {
                    "bearmeat",
                    "deermeat.raw",
                    "humanmeat.raw",
                    "meat.boar",
                    "wolfmeat.raw",
                    "can.beans.empty",
                    "can.tuna.empty",
                    "chicken.raw",
                    "fish.raw"
                };
            }
            else if (ovenName.Contains("furnace"))
            {
                AcceptableItems = new List<string>
                {
                    "hq.metal.ore",
                    "metal.ore",
                    "sulfur.ore",
                    "can.beans.empty",
                    "can.tuna.empty"
               };
            }
            else if (ovenName.Contains("refinery"))
            {
                AcceptableItems = new List<string>
                {
                    "crude.oil"
                };
            }

            if (!AcceptableItems.Contains(item.info.shortname))
            {
                DebugMessage($"not acceptable item {item.info.shortname}");
                return null;
            }

            if (container.entityOwner.GetComponent<BaseOven>().IsOn())
            {
                _enabled.Remove(player.userID);
                OnScreen(player, "FurnaceOnSorterDisabled");
                SorterUI(player);
                return null;
            }

            var totalAmount = item.amount;

            DebugMessage($"TotalAmount = {totalAmount}");

            List<Item> lessThanMax = new List<Item>();
            List<Item> items = new List<Item>();

            bool containsCharcoal = false;

            foreach (var entry in container.itemList)
            {
                if (entry.info.displayName.english == "Charcoal")
                {
                    DebugMessage($"Contains Charcoal");

                    containsCharcoal = true;
                }

                if (entry.info.shortname == item.info.shortname)
                {
                    items.Add(entry);
                    totalAmount += entry.amount;

                    if (entry.amount < item.MaxStackable())
                    {
                        lessThanMax.Add(entry);
                    }

                    DebugMessage($"TotalAmount = {totalAmount}");
                }
            }

            var newSlots = container.capacity - container.itemList.Count();
            
            if (lessThanMax.Count == 0)
            {
                if (containsCharcoal && newSlots <= 1)
                {
                    return ItemContainer.CanAcceptResult.CannotAccept;
                }

                if (!containsCharcoal && newSlots <= 2)
                {
                    return ItemContainer.CanAcceptResult.CannotAccept;
                }
            }

            if (ovenName.Contains("refinery"))
            {
                newSlots -= 2;
            }
            else
            {
                newSlots -= containsCharcoal ? 1 : 2;
            }

            if (newSlots > totalAmount) newSlots = totalAmount;

            DebugMessage($"{newSlots} - Available Slots");

            var totalSlots = items.Count();

            if (totalSlots == 0)
            {
                totalSlots += newSlots;
            }
            else
            {
                newSlots = 0;
            }

            if (totalSlots > totalAmount)
            {
                totalSlots = totalAmount;
            }

            var remainder = totalAmount % totalSlots;

            DebugMessage($"Remainder: {remainder}");

            var SplitableAmount = totalAmount - remainder;

            DebugMessage($"SplitAmount: {SplitableAmount}");

            var eachStack = SplitableAmount / totalSlots;

            DebugMessage($"EachStack: {eachStack}");

            if (eachStack > item.MaxStackable())
            {
                eachStack = item.MaxStackable();

                remainder = totalAmount - (eachStack * totalSlots);
            }

            SortFurnace(player, container, item, eachStack, items, item.info.shortname, remainder, newSlots);

            return ItemContainer.CanAcceptResult.CannotAccept;
        }

        private Item FindBurnable(BaseOven oven)
        {
            foreach (var item in oven.inventory.itemList)
            {
                if (item.info.GetComponent<ItemModBurnable>() == null)
                {
                    continue;
                }

                if (oven.fuelType == null)
                {
                    continue;
                }

                if (oven.fuelType != item.info)
                {
                    continue;
                }

                return item;
            }

            return null;
        }

        #endregion

        #region Commands

        [ConsoleCommand("UI_ToggleSorter")]
        void UIToggleSorterConsoleCommand(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            if (!HasPerm(player)) return;

            if (!_enabled.Contains(player.userID))
            {
                _enabled.Add(player.userID);

                OnScreen(player, "FurnaceSorterEnabled");
                SorterUI(player);

                return;
            }

            _enabled.Remove(player.userID);

            OnScreen(player, "FurnaceSorterDisabled");
            SorterUI(player);
        }

        #endregion

        #region GUI

        void SorterUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, _panelSorter);

            var element = UI.CreateOverlayContainer(_panelSorter, "0 0 0 0", $"{_configData.minx} {_configData.miny}", $"{_configData.maxx} {_configData.maxy}");

            if (_enabled.Contains(player.userID)) UI.CreateButton(ref element, _panelSorter, "0.584 0.29 0.211 1.0", GetMessage("ToggleOff", player), 12, "0 0", "0.6 1", $"UI_ToggleSorter {3}");

            else UI.CreateButton(ref element, _panelSorter, "0.439 0.509 0.294 1.0", GetMessage("ToggleOn", player), 12, "0 0", "0.6 1", $"UI_ToggleSorter {3}");

            CuiHelper.AddUi(player, element);
        }

        void OnScreen(BasePlayer player, string msg)
        {
            if (_timers.ContainsKey(player.userID.ToString()))
            {
                _timers[player.userID.ToString()].Destroy();
                _timers.Remove(player.userID.ToString());
            }
            CuiHelper.DestroyUi(player, _panelOnScreen);
            var element = UI.CreateOverlayContainer(_panelOnScreen, "0.0 0.0 0.0 0.0", "0.3 0.5", "0.7 0.8");
            UI.CreateTextOutline(ref element, _panelOnScreen, string.Empty, "0 0 0 1", GetMessage(msg, player), 32, "0.0 0.0", "1.0 1.0");
            CuiHelper.AddUi(player, element);
            _timers.Add(player.userID.ToString(), timer.Once(4, () => CuiHelper.DestroyUi(player, _panelOnScreen)));
        }

        void CloseUI(BasePlayer player)
        {
            if (player == null) return;

            if (_uiInfo.ContainsKey(player.userID))
            {
                _uiInfo.Remove(player.userID);
            }

            if (_timers.ContainsKey(player.userID.ToString()))
            {
                _timers[player.userID.ToString()].Destroy();
                _timers.Remove(player.userID.ToString());
            }

            if (_enabled.Contains(player.userID))
            {
                _enabled.Remove(player.userID);
            }

            CuiHelper.DestroyUi(player, _panelOnScreen);

            CuiHelper.DestroyUi(player, _panelSorter);
        }

        #endregion

        #region Functions

        void SortFurnace(BasePlayer player, ItemContainer container, Item originalItem, int stackAmount, List<Item> existingItems, string shortname, int remainder, int newSlots)
        {
            _sorting.Add(container);

            DebugMessage("Starting Sort");

            ItemDefinition def = ItemManager.FindItemDefinition(shortname);

            foreach (var entry in existingItems.Where(x => x != null))
            {
                entry.amount = stackAmount;
            }

            while (newSlots > 0)
            {
                var newItem = ItemManager.Create(def, stackAmount);
                newItem.MoveToContainer(container, -1, false);

                newSlots--;
            }

            if (remainder > 0)
            {
                foreach (var entry in container.itemList.Where(k => k.info.shortname == originalItem.info.shortname))
                {
                    DebugMessage($"Amount: {entry.amount} - Remainder Amount: {remainder}");

                    if (entry.amount != entry.MaxStackable())
                    {
                        entry.amount++;
                        remainder--;

                        DebugMessage($"Amount: {entry.amount} - Remainder Amount: {remainder}");
                    }

                    if (remainder == 0)
                    {
                        DebugMessage($"Remainder = 0");

                        originalItem.RemoveFromContainer();
                        originalItem.Remove(0f);

                        break;
                    }

                    DebugMessage("Continuing...");
                }

                DebugMessage($"Remainder > 0 - Remainder Amount: {remainder}");
                DebugMessage($"OriginalItem Amount - {originalItem.amount}");

                originalItem.amount = remainder;

                DebugMessage($"OriginalItem Amount - {originalItem.amount}");

                originalItem.MarkDirty();
            }
            else
            {
                DebugMessage($"Remainder = 0");

                originalItem.RemoveFromContainer();
                originalItem.Remove(0f);
            }

            _sorting.Remove(container);
            container.MarkDirty();
        }

        #endregion

        #region Helpers

        void SendMessage(BasePlayer player, string key, params object[] args)
        {
            string message = GetMessage(key, player, args);

            SendReply(player, $"<color=orange>{GetMessage("Title", player)}</color><color=#A9A9A9>{message}</color>");
        }

        string GetMessage(string key, BasePlayer player = null, params object[] args)
        {
            return string.Format(lang.GetMessage(key, this, player?.UserIDString), args);
        }

        void DebugMessage(string message)
        {
            if (!_debuggingMode) return;

            Puts(message);
        }

        bool HasPerm(BasePlayer player, string perm = permAllow) => player.IsAdmin || permission.UserHasPermission(player.UserIDString, perm);

        #endregion
    }
}


// --- End of file: FurnaceSorter.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AutoReply.cs ---
// --- Original Local Path: AutoReply.cs ---

using Oxide.Core;
//using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
//using System.Reflection;
//using System.Linq;
using UnityEngine;
using System.Text.RegularExpressions;


namespace Oxide.Plugins
{
    [Info("AutoReply", "4seti [Lunatiq] for Rust Planet", "1.5.0", ResourceId = 908)]
    public class AutoReply : RustPlugin
    {

        #region Utility Methods

        private void Log(string message)
        {
            Puts("{0}: {1}", Title, message);
        }
		
        private void Warn(string message)
        {
            PrintWarning("{0}: {1}", Title, message);
        }

        private void Error(string message)
        {
            PrintError("{0}: {1}", Title, message);
        }

		void ReplyChat(BasePlayer player, string msg)
		{
			player.ChatMessage(string.Format("<color=#81D600>{0}</color>: {1}", ReplyName, msg));
		}

		#endregion

		#region Default and private params
		private Dictionary<string, Dictionary<ulong, float>> antiSpam = new Dictionary<string, Dictionary<ulong, float>>();
		private int replyInterval = 5;		
		private int minPriveledge = 0;
        private bool forceAdmin = false;
		
		private Dictionary<string, string> messages;		
		private Dictionary<string, string> defMsg = new Dictionary<string, string>()
		{
			{"attribSet", "Attribute {0} set to {1}"},  
			{"newWord", "New word was added to check: <color=#81F23F>{0}</color> for group: <color=#81F23F>{1}</color>"}, 
			{"newGroup", "New word group was added to check: <color=#81F23F>{0}</color> baseword: {1} with reply: <color=#81F23F>{2}</color>"}, 
			{"removedGroup", "Word group \"<color=#81F23F>{0}</color>\" was removed!"}, 			
			{"newChar", "New char replacement was added to check: <color=#F23F3F>{0}</color>-><color=#81F23F>{1}</color>"}, 
			{"charRemoved", "Char replacement was removed from check: <color=#F23F3F>{0}</color>"},
			{"groupParams", "Full matching: <color=#81F23F>{0}</color>, Drop message:  <color=#81F23F>{1}</color>"},
			{"charNotFound", "Char replacement not found in check: <color=#F23F3F>{0}</color>"},			
			{"baseWordExist", "This baseword or part of it (<color=#F23F3F>{0}</color>) already exists in group <color=#81F23F>{1}</color>"},
			{"newCharExists", "Char already persist in the check: <color=#81F23F>{0}</color>"}, 
			{"replyChanged", "Reply changed for word group: <color=#81F23F>{0}</color>"}, 			
			{"replyAdded", "Reply added for word group: <color=#81F23F>{0}</color> with number: <color=#81F23F>{1}</color>"}, 	
			{"replyRemoved", "Reply removed for word group: <color=#81F23F>{0}</color> with number: <color=#81F23F>{1}</color>"}, 
			{"replyNotFound", "Reply â<color=#81F23F>{0}</color> not found for word group: <color=#81F23F>{1}</color>"}, 			
			{"Error", "Something went wrong"},
			{"noGroup", "No groups found!"},
			{"matchChanged", "Match for group: <color=#81F23F>{0}</color>, changed to <color=#81F23F>{1}</color>"},
			{"matchNotFound", "Group: <color=#81F23F>{0}</color> not found"},
			{"dropChanged", "AutoDrop for group: <color=#81F23F>{0}</color>, changed to <color=#81F23F>{1}</color>"},
			{"newWordExists", "Word already persist in the check: <color=#F23F3F>{0}</color>"},
			{"wordGroupExist", "Word group with that name exist: <color=#F23F3F>{0}</color>"},
			{"wordGroupDontExist", "Word group with that name don't exist: <color=#F23F3F>{0}</color> use <color=#F23F3F>/ar_new</color> first"},			
			{"newAttr", "New attribute added! Name: {0}, Text: {1}"},
			{"attrRemoved", "Attribute removed! Name: {0}"},	
			{"attrEdited", "Attribute edited! Name: {0}, New value: {1}"},				
			{"attrNoFound", "Attribute not found! Name: {0}"},	
			{"attrExist", "Attribute \"{0}\" already exist"},
			{"newGroupError", "Error! Should be: <color=#F23F3F>/ar_new groupname baseword replymsg params(optional)</color>"},
			{"changeReplyError", "Error! Should be: <color=#F23F3F>/ar_reply add/del/set (set or del is by nums (check /ar_list)) groupname replymsg attribs</color>"},
			{"attrAdded", "Attrib: <color=#F23F3F>{0}</color> added for word group <color=#F23F3F>{1}</color>"},
			{"attrDeleted", "Attrib: <color=#F23F3F>{0}</color> deleted for word group <color=#F23F3F>{1}</color>"},
			{"attrCleared", "Attributes cleared for word group <color=#F23F3F>{0}</color>"},
			{"attrWordExist", "Attrib: <color=#F23F3F>{0}</color> exists in word group <color=#F23F3F>{1}</color>"},
			{"attrNotExist", "Attrib: <color=#F23F3F>{0}</color> do not exists in word group <color=#F23F3F>{1}</color>"},			
			{"attrUnknown", "UNKNOWN Attrib: <color=#F23F3F>{0}</color>"},		
			{"attrCritError", "Error! Should be like that: <color=#81F23F>/ar_wa add/del/clear groupname ReplyNum attrib</color>"},
			{"wordAdded", "Word: <color=#F23F3F>{0}</color> added for word group <color=#F23F3F>{1}</color>"},
			{"wordDeleted", "Word: <color=#F23F3F>{0}</color> deleted for word group <color=#F23F3F>{1}</color>"},
			{"wordWordExist", "Word: <color=#F23F3F>{0}</color> exists in word group <color=#F23F3F>{1}</color>"},
			{"wordNotExist", "Word: <color=#F23F3F>{0}</color> do not exists in word group <color=#F23F3F>{1}</color>"},				
			{"wordCritError", "Error! Should be like that: <color=#81F23F>/ar_word add/del groupname word</color>"},
			{"listGroupReply", "Group Name: <color=#81F23F>{0}</color> with <color=#81F23F>{1}</color> hits total" },
			{"listWords", "Words to lookup: <color=#81F23F>{0}</color>"},
			{"listAttribs", "Attributes for reply: <color=#81F23F>{0}</color>"},
			{"usageOfExc", "Usage of \"!\" at word start is forbidden use \"?\" instead"},
            {"ForceOn", "Force Admins check was <color=#81F23F>ENABLED</color>"},
            {"ForceOff", "Force Admins check was <color=#F23F3F>DISABLED</color>"}
		};
		Dictionary<string, Wordgroup> Wordgroups = new Dictionary<string, Wordgroup>();

		
		private Dictionary<string, string> attributes;
		private Dictionary<string, string> defAttr = new Dictionary<string, string>()
		{
			{"time", "by_plugin"},
			{"player", "by_plugin"},
			{"online", "by_plugin"},
			{"sleepers", "by_plugin"},
            {"gametime", "by_plugin"},
			{"lastwipe", "???"},
			{"nextwipe", "???"}
		};
		void Unload()
		{
			SaveData();
		}
		private string ReplyName = "AutoReply";
		
		private Dictionary<char, char> replaceChars;
		private Dictionary<char, char> defChar = new Dictionary<char, char>()
		{
			{'Ñ', 'c'},
			{'Ð°', 'a'},
			{'Ð¾', 'o'},    
			{'Ðµ', 'e'}, 
			{'Ñ', 'p'}, 					
			{'Ð²', 'b'}			
		};		
		#endregion
		#region Default inits
        void Loaded()
        {
            Log("Loaded");
        }
	
		protected override void LoadDefaultConfig()
        {
            Warn("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }
		
		// Gets a config value of a specific type
        private T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null)
                return defaultValue;
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }
		private void LoadData()
		{
			try
			{
				Wordgroups = Interface.GetMod().DataFileSystem.ReadObject<Dictionary<string, Wordgroup>>("AutoReply");
				antiSpam = new Dictionary<string, Dictionary<ulong, float>>();
				foreach (var wordgroup in Wordgroups)
				{
                    antiSpam.Add(wordgroup.Key, new Dictionary<ulong, float>());
                }
				Log("Old AutoReply data loaded!");
			}
			catch
			{
				Wordgroups = new Dictionary<string, Wordgroup>();
				antiSpam = new Dictionary<string, Dictionary<ulong, float>>();
				Warn("Old Data corrupted, new AutoReply data file initiated!");
				SaveData();
			}			
		}
		void SaveData()
		{
			Interface.GetMod().DataFileSystem.WriteObject<Dictionary<string, Wordgroup>>("AutoReply", Wordgroups);
			Log("Data saved!");
		}
		#endregion
		
        void OnServerInitialized()
        {
            try
            {
                LoadConfig();
                var version = GetConfig<Dictionary<string, object>>("version", null);
                VersionNumber verNum = new VersionNumber(Convert.ToUInt16(version["Major"]), Convert.ToUInt16(version["Minor"]), Convert.ToUInt16(version["Patch"]));
				
				//Get message dictionary for plugin commands (for Admins) from config
				messages = new Dictionary<string, string>();
                var cfgMessages = GetConfig<Dictionary<string, object>>("messages", null);
                if (cfgMessages != null)
                    foreach (var pair in cfgMessages)
                        messages[pair.Key] = Convert.ToString(pair.Value);			
				//Get char replace list from config
				replaceChars = new Dictionary<char, char>();
				var cfgChar = GetConfig<Dictionary<string, object>>("replaceChars", null);
                if (cfgChar != null)
                    foreach (var pair in cfgChar)
                        replaceChars[Convert.ToChar(pair.Key)] = Convert.ToChar(pair.Value);		
								
				//Get attributes list from config
				attributes = new Dictionary<string, string>();
				var cfgAttr = GetConfig<Dictionary<string, object>>("attributes", null);
				if (cfgAttr != null)
                    foreach (var pair in cfgAttr)
                        attributes[pair.Key] = Convert.ToString(pair.Value);
						
				#region version checker
				if (verNum < Version || defMsg.Count > messages.Count)
                {
                    //placeholder for future version updates
					foreach (var pair in defMsg)
                        if (!messages.ContainsKey(pair.Key))
                            messages[pair.Key] = pair.Value;
							
					foreach (var pair in defAttr)
                        if (!attributes.ContainsKey(pair.Key))
                            attributes[pair.Key] = pair.Value;
					Config["attributes"] = attributes;
                    Config["messages"] = messages;
					Config["version"] = Version;					
					SaveConfig();
                    Warn("Config version updated to: " + Version.ToString() + " please check it");
                }
				#endregion
				ReplyName = GetConfig<string>("ReplyName", ReplyName);
				replyInterval = GetConfig<int>("replyInterval", 30);	
				minPriveledge = GetConfig<int>("minPriveledge", 0);
				LoadData();
            }
            catch (Exception ex)
            {
                Error("OnServerInitialized failed: " + ex.Message);
            }
            
        }
		
		private void LoadVariables()
        {
            Config["messages"] = defMsg;
			Config["replaceChars"] = defChar;
			Config["attributes"] = defAttr;
			Config["replyInterval"] = 30;
			Config["minPriveledge"] = 0;
			Config["ReplyName"] = ReplyName;
			Config["version"] = Version;
        }
        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
			BasePlayer player = null;
			string msg = "";
			try
			{
				if (arg == null) return null;
				if (arg.connection.player == null) return null;
				if (arg.cmd.namefull.ToString() != "chat.say") return null;
				
				if (arg.connection.player is BasePlayer)
				{
					player = arg.connection.player as BasePlayer;
					if (player.net.connection.authLevel > minPriveledge && !forceAdmin) return null;
				}
				else return null;
				
				msg = arg.GetString(0, "text").ToLower();		
				
				if (msg == null) return null;
				else if (msg == "") return null;
				else if (msg.Substring(0, 1).Equals("/") || msg.Substring(0, 1).Equals("!")) return null;
				
				if (player == null) return null;
			}
			catch
			{
				return null;
			}            

			//Fixing alphabets abuse			
			foreach(var pair in replaceChars)
			{
				msg = msg.Replace(pair.Key, pair.Value);				
			}				
			List<string> foundGroup = new List<string>();
			foreach(var pair in Wordgroups)
			{	
				foreach(var item in pair.Value.Words)
				{
					if(!pair.Value.FullMatch)
					{
						if (msg.Contains(item))
						{
							foundGroup.Add(pair.Key);
							break;
						}
					}
					else
					{
						if (msg == item)
						{
							foundGroup.Add(pair.Key);
							break;
						}					
					}
				}
			}
            if (foundGroup.Count > 0)
			{
				bool blocked = false;
				foreach (var fgroup in foundGroup)
				{
					if (antiSpam[fgroup].ContainsKey(player.userID))
					{
						if ((Time.realtimeSinceStartup - antiSpam[fgroup][player.userID]) > replyInterval)
						{

							replyToPlayer(player, fgroup);
							antiSpam[fgroup][player.userID] = Time.realtimeSinceStartup;
						}
					}
					else
					{
						antiSpam[fgroup].Add(player.userID, Time.realtimeSinceStartup);
						replyToPlayer(player, fgroup);
					}
                    Wordgroups[fgroup].Hits++;
					if (Wordgroups[fgroup].Hits % 20 == 0) SaveData();
                    if (Wordgroups[fgroup].Drop)
                            blocked = true;
                }
				if (blocked)
					return false;
			}			
			return null;
		}
		
		private void replyToPlayer(BasePlayer player, string group)
		{		
			foreach(var v in Wordgroups[group].Replies)
			{
				ReplyChat(player, replyBuilder(v.Value, player.displayName));
			}								
		}
		
		private string replyBuilder(string text, string playerName)
		{
			Regex regex = new Regex(@"{(\w+)}", RegexOptions.IgnoreCase);
			string attrText;
			string curMatch;
			foreach (Match match in regex.Matches(text))
			{
				attrText = string.Empty;
				curMatch = match.Groups[1].Value.ToLower();
                if (attributes.ContainsKey(curMatch))
				{
					if (attributes[curMatch] == "by_plugin")
					{
						switch (curMatch)
						{
							case "time":
								attrText = DateTime.Now.ToString("HH:mm:ss");
								break;
							case "player":
								attrText = playerName;
								break;
							case "online":
								attrText = BasePlayer.activePlayerList.Count.ToString();
								break;
							case "sleepers":
								attrText = BasePlayer.sleepingPlayerList.Count.ToString();
								break;
							case "gametime":
								attrText = TOD_Sky.Instance.Cycle.DateTime.ToString("dd/MM/yy HH:mm");
								break;
							default:
								attrText = "";
								break;
						}
					}
					else
						attrText = attributes[curMatch];
					text = text.Replace("{" + curMatch + "}", attrText, StringComparison.OrdinalIgnoreCase);
				}
			}	
			return text;			
		}
		
		[ChatCommand("ar")]
		void cmdAr(BasePlayer player, string cmd, string[] args)
		{
			if (player.net.connection.authLevel == 0) return;			
			if (args.Length > 2)
			{
				if (args[0] == "c") //adding/deleting new char to replace
				{
					try
					{
						if(args[1] == "add") 
						{
							if (!replaceChars.ContainsKey(Convert.ToChar(args[2])))
							{
								replaceChars.Add(Convert.ToChar(args[2].ToLower()), Convert.ToChar(args[3].ToLower()));
								Config["replaceChars"] = replaceChars;
								ReplyChat(player, string.Format(messages["newChar"], args[2], args[3]));	
							}	
							else	
							{
								ReplyChat(player, string.Format(messages["newCharExists"], args[2]));	
							}
						}	
						else if(args[1] == "del")
						{	
							if (replaceChars.ContainsKey(Convert.ToChar(args[2])))
							{
								replaceChars.Remove(Convert.ToChar(args[2].ToLower()));								
								Config["replaceChars"] = replaceChars;		
								ReplyChat(player, string.Format(messages["charRemoved"], args[2]));
							}
							else
							{
								ReplyChat(player, string.Format(messages["charNotFound"], args[2]));
							}							
						}
					}		
					catch		
					{
						ReplyChat(player, messages["Error"]);	
					}					
				}
				else if(args[0] == "a") //adding/deleting new attribute for word list
				{
					try
					{
						if(args[1] == "add") 
						{
							if (!attributes.ContainsKey(args[2]))
							{
								attributes.Add(args[2].ToLower(), args[3]);
								Config["attributes"] = attributes;
								ReplyChat(player, string.Format(messages["newAttr"], args[2], args[3]));	
							}	
							else	
							{
								ReplyChat(player, string.Format(messages["attrExist"], args[2]));	
							}	
						}
						else if(args[1] == "del") 
						{
							if (attributes.ContainsKey(args[2]))
							{
								if (attributes[args[2]] == "by_plugin")
								{
									ReplyChat(player, string.Format(messages["Error"]));
									return;
								}
								//removeAttr(args[2].ToLower()); 
								attributes.Remove(args[2].ToLower());
								Config["attributes"] = attributes;
								ReplyChat(player, string.Format(messages["attrRemoved"], args[2]));	
							}	
							else	
							{
								ReplyChat(player, string.Format(messages["attrNotFound"], args[2]));	
							}	
						}
						else if(args[1] == "set") 
						{
							if (attributes.ContainsKey(args[2]))
							{
								if (attributes[args[2]] == "by_plugin")
								{
									ReplyChat(player, string.Format(messages["Error"]));
									return;
								}
								attributes[args[2].ToLower()] = args[3];
								Config["attributes"] = attributes;
								ReplyChat(player, string.Format(messages["attrEdited"], args[2], args[3]));	
							}	
							else	
							{
								ReplyChat(player, string.Format(messages["attrNotFound"], args[2]));	
							}	
						}
					}		
					catch		
					{
						ReplyChat(player, messages["Error"]);	
					}				
				}
				SaveConfig();
			}
		}

		[ChatCommand("ar_save")]
		void cmdSave(BasePlayer player, string cmd, string[] args)
		{
			if (player.net.connection.authLevel == 0) return;
			SaveData();
			ReplyChat(player, "Data Saved!");
		}

		[ChatCommand("ar_load")]
		void cmdLoad(BasePlayer player, string cmd, string[] args)
		{
			if (player.net.connection.authLevel == 0) return;
			LoadData();
			ReplyChat(player, "Data Loaded!");
		}


		private bool checkWord(BasePlayer player, string baseWord)
		{
			bool found = true;
			string foundGroup = "";
			foreach(var pair in Wordgroups)
			{	
				foreach(var item in pair.Value.Words)
				{					
					if(!pair.Value.FullMatch)
					{
						if (baseWord.Contains(item))
						{
							found = false;
							foundGroup = pair.Key;					
							break;
						}
					}
					else
					{
						if (baseWord == item)
						{
							found = false;
							foundGroup = pair.Key;			
							break;
						}					
					}					
				}
			}
			if (!found)
			{
				ReplyChat(player, string.Format(messages["baseWordExist"], baseWord, foundGroup));				
			}
			return found;
		}
		
		//Adding new word group
		[ChatCommand("ar_new")]
		void cmdArNew(BasePlayer player, string cmd, string[] args)
		{
			if (player.net.connection.authLevel == 0) return;			
			if (args.Length > 2)
			{
				if (!Wordgroups.ContainsKey(args[0]))
				{
					string groupName = args[0].ToLower();
					string baseWord = args[1].ToLower();
					if (baseWord.Substring(0, 1).Equals("!"))
					{
						ReplyChat(player, messages["usageOfExc"]);	
						return;
					}
					string reply = args[2];
					
					if (!checkWord(player, baseWord))
						return;
					List<string> attrCheck = checkAttributes(reply);
					if (attrCheck.Count > 0)
					{
						ReplyChat(player, string.Format(messages["attrUnknown"], string.Join(", ", attrCheck.ToArray())));
						return;
					}
                    Wordgroups.Add(groupName, new Wordgroup(baseWord, reply));
					ReplyChat(player, string.Format(messages["newGroup"], groupName, baseWord, reply));
					antiSpam.Add(groupName, new Dictionary<ulong, float>());
					SaveData();					
				}
				else
				{
					ReplyChat(player, string.Format(messages["wordGroupExist"], args[0]));
					return;
				}
			
			}
			else
				ReplyChat(player, messages["newGroupError"]);	
		}
		
		//Change reply
		[ChatCommand("ar_reply")]
		void cmdArReply(BasePlayer player, string cmd, string[] args)
		{
			if (player.net.connection.authLevel == 0) return;			
			if (args.Length > 2)
			{
				string groupName = args[1];
				if (Wordgroups.ContainsKey(groupName))
				{
					string mode = args[0];					
					if (mode == "add")
					{
						string reply = args[2];
						int newReply = Wordgroups[groupName].Replies.Count;
						List<string> attrCheck = checkAttributes(reply);
						if (attrCheck.Count > 0)
						{
							ReplyChat(player, string.Format(messages["attrUnknown"], string.Join(", ", attrCheck.ToArray())));
							return;
						}
						Wordgroups[groupName].Replies.Add(newReply, reply);
						ReplyChat(player, string.Format(messages["replyAdded"], groupName, newReply));
						SaveData();
						
					}	
					else if(mode == "del")
					{
						int removeKey = Convert.ToInt32(args[2]);
						if(Wordgroups[groupName].Replies.ContainsKey(removeKey))
						{
							Wordgroups[groupName].Replies.Remove(removeKey);
							ReplyChat(player, string.Format(messages["replyRemoved"], groupName, removeKey));					
							SaveData();
						}
						else
							ReplyChat(player, string.Format(messages["replyNotFound"], removeKey, groupName));				
					}
					else if(mode == "set")
					{
						int setKey = Convert.ToInt32(args[2]);
						string reply = args[3];
						if(Wordgroups[groupName].Replies.ContainsKey(setKey))
						{
							List<string> attrCheck = checkAttributes(reply);
							if (attrCheck.Count > 0)
							{
								ReplyChat(player, string.Format(messages["attrUnknown"], string.Join(", ", attrCheck.ToArray())));
								return;
							}
							Wordgroups[groupName].Replies[setKey] = reply;
							ReplyChat(player, string.Format(messages["replyChanged"], groupName, setKey));
							SaveData();
						}
						else
							ReplyChat(player, string.Format(messages["replyNotFound"], setKey, groupName));		
					}
					else
						ReplyChat(player, messages["Error"]);
				}
				else
				{
					ReplyChat(player, string.Format(messages["wordGroupDontExist"], args[0]));
					return;
				}
			
			}
			else
				ReplyChat(player, messages["changeReplyError"]);	
		}

		private List<string> checkAttributes(string text)
		{
			Regex regex = new Regex(@"{(\w+)}", RegexOptions.IgnoreCase);
			List<string> missedAttribs = new List<string>();

			foreach (Match match in regex.Matches(text))
			{
				if (!attributes.ContainsKey(match.Groups[1].Value.ToLower()))
					missedAttribs.Add(match.Groups[1].Value.ToLower());
            }
			return missedAttribs;
		} 
		
		//Change autodrop
		[ChatCommand("ar_drop")]
		void cmdArDrop(BasePlayer player, string cmd, string[] args)
		{
			if (player.net.connection.authLevel == 0) return;
			if (args.Length > 1)
			{
				string group = args[0];
				bool drop = Convert.ToBoolean(args[1]);
				if (Wordgroups.ContainsKey(group))
				{
					Wordgroups[group].Drop = drop;
					ReplyChat(player, string.Format(messages["dropChanged"], group, drop.ToString()));
					SaveData();
				}
				else
					ReplyChat(player, string.Format(messages["matchNotFound"], group));
			}
			else
				ReplyChat(player, messages["Error"]);
		}

		//Change matching
		[ChatCommand("ar_match")]
		void cmdArMatch(BasePlayer player, string cmd, string[] args)
		{
			if (player.net.connection.authLevel == 0) return;		
			if (args.Length > 1)
			{
				string group = args[0];
				bool match = Convert.ToBoolean(args[1]);
				if (Wordgroups.ContainsKey(group))
				{
					Wordgroups[group].FullMatch = match;
					ReplyChat(player, string.Format(messages["matchChanged"], group, match.ToString()));
					SaveData();
				}
				else
					ReplyChat(player, string.Format(messages["matchNotFound"], group));							
			}
			else
				ReplyChat(player, messages["Error"]);	
		}
		//Remove whole group
		[ChatCommand("ar_remove")]
		void cmdArRemove(BasePlayer player, string cmd, string[] args)
		{
			if (player.net.connection.authLevel == 0) return;
			if (args.Length == 0) return;
			string groupname = args[0];
				
			if (Wordgroups.ContainsKey(groupname))
			{
				Wordgroups.Remove(groupname);
				antiSpam.Remove(groupname);
                SaveData();
				ReplyChat(player, string.Format(messages["removedGroup"], groupname));
			}
		}
		//Foce check admins
		[ChatCommand("ar_force")]
        void cmdArForce(BasePlayer player, string cmd, string[] args)
        {
            if (player.net.connection.authLevel == 0) return;
            if (forceAdmin)
                ReplyChat(player, messages["ForceOff"]);
            else
                ReplyChat(player, messages["ForceOn"]);
            forceAdmin = !forceAdmin;
        }
		//Add word for word group
		[ChatCommand("ar_word")]
		void cmdArWord(BasePlayer player, string cmd, string[] args)
		{
			if (player.net.connection.authLevel == 0) return;			
			if (args.Length > 2)
			{
				if (Wordgroups.ContainsKey(args[1]))
				{
					string groupName = args[1].ToLower();
					string mode = args[0].ToLower();
					string word = args[2].ToLower();

					if (mode == "add")
					{
						if (!checkWord(player, word))
							return;
						if (!Wordgroups[groupName].Words.Contains(word))
						{
							if (word.Substring(0, 1).Equals("!"))
							{
								ReplyChat(player, messages["usageOfExc"]);	
								return;
							}
							Wordgroups[groupName].Words.Add(word);
							ReplyChat(player, string.Format(messages["wordAdded"], word, groupName));
							SaveData();
							return;							
						}
						else
							ReplyChat(player, string.Format(messages["wordWordExist"], word, groupName));	
						return;
					}
					else if (mode == "del")
					{
						if (Wordgroups[groupName].Words.Contains(word))
						{
							Wordgroups[groupName].Words.Remove(word);
							ReplyChat(player, string.Format(messages["wordDeleted"], word, groupName));
							SaveData();
							return;							
						}
						else
							ReplyChat(player, string.Format(messages["wordNotExist"], word, groupName));	
						return;			
					}
					else
					{
						ReplyChat(player, messages["wordCritError"]);	
					}
				}
				else
				{
					ReplyChat(player, string.Format(messages["wordGroupDontExist"], args[0]));
					return;
				}
			
			}
			else
				ReplyChat(player, messages["wordCritError"]);	
		}

		[ChatCommand("ar_list")]
		void cmdArList(BasePlayer player, string cmd, string[] args)
		{
			if (player.net.connection.authLevel == 0) return;

			if (args.Length == 0)
				if (Wordgroups.Count > 0)
				{
					foreach (var group in Wordgroups)
					{
						ReplyChat(player, string.Format(messages["listGroupReply"], group.Key, group.Value.Hits));
					}
				}
				else
				{
					ReplyChat(player, messages["noGroup"]);
				}
			else
				if (args[0] == "attr")
				foreach (var pair in attributes)
				{
					ReplyChat(player, string.Format("{0} -> {1}", pair.Key, pair.Value.Quote()));
				}
		}

		[ChatCommand("ar_info")]
		void cmdArInfo(BasePlayer player, string cmd, string[] args)
		{
			if (player.net.connection.authLevel == 0) return;

			if (args.Length == 0) return;

			string groupName = args[0];
			if (Wordgroups.ContainsKey(groupName))
			{
				ReplyChat(player, string.Format(messages["listGroupReply"], groupName, Wordgroups[groupName].Hits));
				ReplyChat(player, string.Format(messages["groupParams"], Wordgroups[groupName].FullMatch, Wordgroups[groupName].Drop));
				ReplyChat(player, string.Format(messages["listWords"], string.Join(", ", Wordgroups[groupName].Words.ToArray())));
				foreach (var v in Wordgroups[groupName].Replies)
				{
					ReplyChat(player, string.Format("<color=#F5D400>[{0}]</color> - {1}", v.Key, v.Value.Quote()));
					//if (v.Value.ReplyAttr.Count > 0)
					//	ReplyChat(player, string.Format("A:{0}", string.Join(", ", v.Value.ReplyAttr.ToArray())));
				}
			}
			else
			{
				ReplyChat(player, messages["noGroup"]);
			}
		}

		public class Wordgroup
		{
			public List<string> Words;
			public Dictionary<int, string> Replies;
			public bool FullMatch;
			public bool Drop;
			public int Hits;

			public Wordgroup(string baseword, string baseReply)
			{
				Words = new List<string>();
				Words.Add(baseword);
				Replies = new Dictionary<int, string>();
				Replies.Add(0, baseReply);
                FullMatch = false;
				Drop = true;
				Hits = 0;
            }
		}
		public class ReplyEntry
		{
			public string Reply;
			public List<string> ReplyAttr;
			public ReplyEntry()
			{
				Reply = string.Empty;
				ReplyAttr = new List<string>();
            }
			public ReplyEntry(string reply, List<string> attrs)
			{
				Reply = reply;
                if (attrs == null)
					ReplyAttr = new List<string>();
				else
					ReplyAttr = attrs;
            }
		}	
    }
}

// --- End of file: AutoReply.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XMiniCopterPlus.cs ---
// --- Original Local Path: XMiniCopterPlus.cs ---

using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("XMiniCopterPlus", "https://topplugin.ru/ / https://discord.com/invite/5DPTsRmd3G", "1.0.31")]
    class XMiniCopterPlus : RustPlugin
    {
		#region Configuration

        private CopterConfig config;

        private class CopterConfig
        {		
            internal class CopterSetting
            {				    
				[JsonProperty("SkinID")] 
                public ulong CopterSkinID;				
				[JsonProperty("Имя")] 
                public string CopterName;			
            }	
			
			internal class WorkSetting
            {            			
				[JsonProperty("Включить третье место")]
                public bool Chair = true;				
				[JsonProperty("Включить стеш")]
                public bool Stash = true;
            }			      
			
			[JsonProperty("Настройки коптера")]
            public CopterSetting Copter = new CopterSetting();
			[JsonProperty("Общее")]
            public WorkSetting Settings = new WorkSetting();
			
			public static CopterConfig GetNewConfiguration()
            {
                return new CopterConfig
                {
					Settings = new WorkSetting
					{
						Chair = false,
						Stash = true
					},
					Copter = new CopterSetting
					{
						CopterSkinID = 2199754843,
						CopterName = "КОПТЕР"
					}
				};
			}
        }

        protected override void LoadDefaultConfig()
        {
            config = CopterConfig.GetNewConfiguration();

            PrintWarning("Создание начальной конфигурации плагина!!!");
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();

            config = Config.ReadObject<CopterConfig>();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
		
		#region Commands
		
		[ConsoleCommand("c_give")]
        void cmdConsoleCommand(ConsoleSystem.Arg args)
        {
			if (args.Player() != null) return;
			
			BasePlayer player = BasePlayer.FindByID(ulong.Parse(args.Args[0]));
			
			if (player == null) return;
			
			Item item = ItemManager.CreateByName("woodcross", int.Parse(args.Args[1]), config.Copter.CopterSkinID);
            item.name = config.Copter.CopterName;
			
            player.GiveItem(item);
        }

        #endregion	
		
        #region Hooks
		
		private void OnServerInitialized()
		{		
			PrintWarning("\n-----------------------------\n" +
			"     Author - https://topplugin.ru/ / https://discord.com/invite/5DPTsRmd3G\n" +
			"     VK - https://vk.com/rustnastroika\n" +
			"     Discord - https://discord.com/invite/5DPTsRmd3G\n" +
			"     Config - v.1539\n" +
			"-----------------------------");
		}
		
        private void OnEntitySpawned(MiniCopter copter)
        {
            if (copter.mountPoints.Count < 3 && copter.ShortPrefabName == "minicopter.entity")
            {
				if (config.Settings.Chair) copter.mountPoints.Add(SpawnPassenger(copter));
				
				timer.Once(0.1f, () => {
                    if (config.Settings.Chair) Chair(copter);
		            if (config.Settings.Stash) Stash(copter);
				});
            }
        }
		
		private void OnEntityBuilt(Planner plan, GameObject go)
        {
            SpawnEntity(go.ToBaseEntity());
        }
		
        #endregion

        #region Entity
		
		private void SpawnEntity(BaseEntity entity)
        {
            if (entity == null) return;
			
            if (entity.skinID == config.Copter.CopterSkinID)
			{
				var copter = GameManager.server.CreateEntity("assets/content/vehicles/minicopter/minicopter.entity.prefab", entity.transform.position, entity.transform.rotation = Quaternion.Euler(new Vector3(0f, 0f, 0f)));
                                
                copter.Spawn(); 						
				NextTick(() => { entity.Kill(); });
			}			
        }

        private void Chair(MiniCopter copter)
        {
            BaseEntity entity = GameManager.server.CreateEntity("assets/prefabs/vehicle/seats/passengerchair.prefab");
			
            if (entity == null) return;
			
            entity.transform.localPosition = new Vector3(0f, 0.4f, -1.0f);
			entity.transform.localRotation = Quaternion.Euler(new Vector3(0, 180, 0));

			entity.Spawn();
			entity.SetParent(copter);
        }            
			
		private void Stash(MiniCopter copter)
        {
			foreach (var container in copter.GetComponentsInChildren<StorageContainer>()) {
				if (container.name == "assets/content/vehicles/boats/rowboat/subents/rowboat_storage.prefab") return;
			}	
			
			BaseEntity entity = GameManager.server.CreateEntity("assets/content/vehicles/boats/rowboat/subents/rowboat_storage.prefab") as StorageContainer;

            if (entity == null) return;
			
            entity.transform.localPosition = new Vector3(0f, 0.44f, -0.677f);
			entity.transform.localRotation = Quaternion.Euler(new Vector3(0, 180, 0));

			entity.Spawn();
			entity.SetParent(copter);
        }

        MiniCopter.MountPointInfo SpawnPassenger(MiniCopter copter)
        {
            return new MiniCopter.MountPointInfo
            {
				pos = new Vector3(0f, 0.335f, -1.35f),
                rot = new Vector3(0, 180, 0),
                prefab = copter.mountPoints[1].prefab,
                mountable = copter.mountPoints[1].mountable,
            };
        }
			
        #endregion
    }
}

// --- End of file: XMiniCopterPlus.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Picklock.cs ---
// --- Original Local Path: Picklock.cs ---

using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Picklock", "TopPlugin.ru", "1.0.2")]
    public class Picklock : RustPlugin
    {
        #region Config
        private PluginConfig _config;

        protected override void LoadDefaultConfig() => _config = PluginConfig.DefaultConfig();

        protected override void LoadConfig() { base.LoadConfig(); _config = Config.ReadObject<PluginConfig>(); Config.WriteObject(_config, true); }

        protected override void SaveConfig() => Config.WriteObject(_config);

        public class CrateConfig
        {
            [JsonProperty("Prefab")] public string Prefab;
            [JsonProperty("Минимальное кол-во")] public int MinAmount;
            [JsonProperty("Максимальное кол-во")] public int MaxAmount;
            [JsonProperty("Шанс выпадения предмета [0.0-100.0]")] public float Chance;
        }

        private class PluginConfig
        {
            [JsonProperty("Время открытия замка [sec.]")] public float TimeUnlock;
            [JsonProperty("Вероятность открытия замка [%]")] public float ChanceUnlock;
            [JsonProperty("Расстояние от игрока до замка [m]")] public float DistanceUnlock;
            [JsonProperty("Открывать при помощи отмычки дверной замок? [true/false]")] public bool IsKeyLock;
            [JsonProperty("Открывать при помощи отмычки кодовый замок? [true/false]")] public bool IsCodeLock;
            [JsonProperty("Открывать только замки плагина Raidable Bases? [true/false]")] public bool OnlyRaidableBases;
            [JsonProperty("Открывать дверь после взлома замка? [true/false]")] public bool IsOpenDoor;
            [JsonProperty("Настройка появления отмычек в ящиках")] public List<CrateConfig> Crates;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    TimeUnlock = 10f,
                    ChanceUnlock = 5f,
                    DistanceUnlock = 3f,
                    IsKeyLock = true,
                    IsCodeLock = true,
                    OnlyRaidableBases = false,
                    IsOpenDoor = true,
                    Crates = new List<CrateConfig>
                    {
                        new CrateConfig
                        {
                            Prefab = "assets/bundled/prefabs/radtown/crate_elite.prefab",
                            MinAmount = 1,
                            MaxAmount = 2,
                            Chance = 15f
                        },
                        new CrateConfig
                        {
                            Prefab = "assets/bundled/prefabs/radtown/crate_normal.prefab",
                            MinAmount = 1,
                            MaxAmount = 1,
                            Chance = 10f
                        }
                    }
                };
            }
        }
        #endregion Config

        #region Oxide Hooks
        private static Picklock ins;

        void Init() => ins = this;

        void OnServerInitialized() => LoadDefaultMessages();

        void Unload()
        {
            foreach (ulong steamID in UnlockPlayers)
            {
                BasePlayer player = BasePlayer.FindByID(steamID);
                if (player != null) CuiHelper.DestroyUi(player, "BG_Unlock");
            }
            ins = null;
        }

        void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (input.WasJustReleased(BUTTON.FIRE_THIRD) && UnlockPlayers.Contains(player.userID))
            {
                UnlockPlayers.Remove(player.userID);
                CuiHelper.DestroyUi(player, "BG_Unlock");
            }
            if (input.WasJustPressed(BUTTON.FIRE_THIRD) && player.GetActiveItem() != null && player.GetActiveItem().skin == 2591851360 && !UnlockPlayers.Contains(player.userID))
            {
                BaseEntity target = RaycastAll<BaseEntity>(player.eyes.HeadRay());
                if (target == null) return;
                BaseLock key = (BaseLock)(target.ShortPrefabName.Contains("lock.key") ? target : target.GetSlot(BaseEntity.Slot.Lock));
                if (key == null) return;
                if (_config.OnlyRaidableBases && !isRaidableBases(key)) return;
                if ((_config.IsKeyLock && key is KeyLock) || (_config.IsCodeLock && key is CodeLock))
                {
                    UnlockPlayers.Add(player.userID);
                    Unlock(player, key, _config.TimeUnlock);
                }
            }
        }

        void OnLootSpawn(LootContainer container)
        {
            if (container == null || container.inventory == null) return;
            if (_config.Crates.Any(x => x.Prefab == container.PrefabName))
            {
                CrateConfig config = _config.Crates.Where(x => x.Prefab == container.PrefabName).FirstOrDefault();
                if (UnityEngine.Random.Range(0f, 100f) <= config.Chance)
                {
                    if (container.inventory.itemList.Count == container.inventory.capacity) container.inventory.capacity++;
                    Item picklock = GetPicklock(UnityEngine.Random.Range(config.MinAmount, config.MaxAmount + 1));
                    if (!picklock.MoveToContainer(container.inventory)) picklock.Remove();
                }
            }
        }

        object CanStackItem(Item item, Item targetItem)
        {
            if (item == null || targetItem == null) return null;
            if (item.info.itemid == targetItem.info.itemid && item.skin != targetItem.skin) return false;
            return null;
        }

        object CanCombineDroppedItem(DroppedItem drItem, DroppedItem anotherDrItem)
        {
            if (drItem == null || anotherDrItem == null) return null;
            if (drItem.item.info.itemid == anotherDrItem.item.info.itemid && drItem.item.skin != anotherDrItem.item.skin) return false;
            return null;
        }

        Item OnItemSplit(Item item, int amount)
        {
            if (item.skin == 2591851360)
            {
                item.amount -= amount;
                Item newItem = ItemManager.CreateByItemID(item.info.itemid, amount, item.skin);
                newItem.name = item.name;
                item.MarkDirty();
                return newItem;
            }
            return null;
        }
        #endregion Oxide Hooks

        #region Helper
        [PluginReference] Plugin RaidableBases;

        List<ulong> UnlockPlayers = new List<ulong>();

        void Unlock(BasePlayer player, BaseLock key, float time)
        {
            if (!UnlockPlayers.Contains(player.userID)) return;
            if (Vector3.Distance(player.transform.position, key.transform.position) > _config.DistanceUnlock || player == null || key == null || player.IsDead() || player.IsWounded() || player.IsSleeping())
            {
                UnlockPlayers.Remove(player.userID);
                CuiHelper.DestroyUi(player, "BG_Unlock");
                return;
            }
            UnlockGUI(player, time);
            if (time <= 0f)
            {
                UnlockPlayers.Remove(player.userID);
                CuiHelper.DestroyUi(player, "BG_Unlock");
                if (UnityEngine.Random.Range(0f, 100f) <= _config.ChanceUnlock)
                {
                    Door door = key.GetParentEntity() as Door;
                    if (door != null && _config.IsOpenDoor) door.SetOpen(true);
                    if (key != null && !key.IsDestroyed) key.Kill();
                }
                else
                {
                    Item picklock = player.GetActiveItem();
                    if (picklock != null)
                    {
                        if (picklock.amount > 1) picklock.amount--;
                        else NextTick(() => picklock.Remove());
                        player.inventory.containerBelt.MarkDirty();
                    }
                    Effect effect = new Effect("assets/bundled/prefabs/fx/item_break.prefab", player, 0, new Vector3(), new Vector3());
                    EffectNetwork.Send(effect, player.Connection);
                }
                return;
            }
            timer.In(0.1f, () => Unlock(player, key, time - 0.1f));
        }

        BaseEntity RaycastAll<T>(Ray ray) where T : BaseEntity
        {
            RaycastHit[] hits = Physics.RaycastAll(ray);
            GamePhysics.Sort(hits);
            float distance = _config.DistanceUnlock;
            BaseEntity target = null;
            foreach (RaycastHit hit in hits)
            {
                BaseEntity ent = hit.GetEntity();
                if (ent is T && hit.distance < distance)
                {
                    target = ent;
                    break;
                }
            }
            return target;
        }

        Item GetPicklock(int amount)
        {
            Item item = ItemManager.CreateByName("sticks", amount, 2591851360);
            item.name = "Picklock";
            return item;
        }

        private bool isRaidableBases(BaseEntity entity) => (bool)RaidableBases?.Call("EventTerritory", entity.transform.position);
        #endregion Helper

        #region GUI
        void UnlockGUI(BasePlayer player, float time)
        {
            CuiHelper.DestroyUi(player, "BG_Unlock");

            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                Image = { Color = "0.16 0.16 0.14 0.95", Material = "assets/content/ui/uibackgroundblur.mat" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-100 -5", OffsetMax = "100 5" },
                CursorEnabled = false,
            }, "Hud", "BG_Unlock");

            container.Add(new CuiElement
            {
                Parent = "BG_Unlock",
                Components =
                {
                    new CuiImageComponent { Color = "0.25 0.3 0.15 0.95", Material = "assets/content/ui/uibackgroundblur.mat" },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = $"{1f - time / _config.TimeUnlock} 0.95" }
                }
            });

            container.Add(new CuiElement
            {
                Parent = "BG_Unlock",
                Components =
                {
                    new CuiTextComponent() { Color = "0.79 0.75 0.72 0.95", Text = GetMessage("GUI", player.userID, Math.Round(time, 1)), Align = TextAnchor.MiddleCenter, FontSize = 8 },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });

            CuiHelper.AddUi(player, container);
        }
        #endregion GUI

        #region Lang
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["GUI"] = "{0} SEC. LEFT",
                ["NoTarget"] = "The specified player <color=#ce3f27>was not found</color>!",
                ["GivePicklock"] = "The player <color=#55aaff>{0}</color> <color=#738d43>has been given</color> a <color=#55aaff>Picklock</color> item (<color=#55aaff>{1}</color> pieces)"
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["GUI"] = "ОСТАЛОСЬ {0} СЕК.",
                ["NoTarget"] = "Указанный игрок <color=#ce3f27>не найден</color>!",
                ["GivePicklock"] = "Игроку <color=#55aaff>{0}</color> <color=#738d43>выдан</color> предмет <color=#55aaff>Picklock</color> (<color=#55aaff>{1}</color> шт.)"
            }, this, "ru");
        }

        string GetMessage(string langKey, ulong UID) => ins.lang.GetMessage(langKey, ins, UID.ToString());

        string GetMessage(string langKey, ulong UID, params object[] args) => (args.Length == 0) ? GetMessage(langKey, UID) : string.Format(GetMessage(langKey, UID), args);
        #endregion Lang

        #region MoveItem
        void MoveItem(BasePlayer player, Item item)
        {
            int spaceCountItem = GetSpaceCountItem(player, item.info.shortname, item.MaxStackable(), item.skin);
            int inventoryItemCount;
            if (spaceCountItem > item.amount) inventoryItemCount = item.amount;
            else inventoryItemCount = spaceCountItem;

            if (inventoryItemCount > 0)
            {
                Item itemInventory = ItemManager.CreateByName(item.info.shortname, inventoryItemCount, item.skin);
                if (item.skin != 0) itemInventory.name = item.name;

                item.amount -= inventoryItemCount;
                MoveInventoryItem(player, itemInventory);
            }

            if (item.amount > 0) MoveOutItem(player, item);
        }

        int GetSpaceCountItem(BasePlayer player, string shortname, int stack, ulong skinID)
        {
            int slots = player.inventory.containerMain.capacity + player.inventory.containerBelt.capacity;
            int taken = player.inventory.containerMain.itemList.Count + player.inventory.containerBelt.itemList.Count;
            int result = (slots - taken) * stack;
            foreach (Item item in player.inventory.AllItems()) if (item.info.shortname == shortname && item.skin == skinID && item.amount < stack) result += stack - item.amount;
            return result;
        }

        void MoveInventoryItem(BasePlayer player, Item item)
        {
            if (item.amount <= item.MaxStackable())
            {
                foreach (Item itemInv in player.inventory.AllItems())
                {
                    if (itemInv.info.shortname == item.info.shortname && itemInv.skin == item.skin && itemInv.amount < itemInv.MaxStackable())
                    {
                        if (itemInv.amount + item.amount <= itemInv.MaxStackable())
                        {
                            itemInv.amount += item.amount;
                            itemInv.MarkDirty();
                            return;
                        }
                        else
                        {
                            item.amount -= itemInv.MaxStackable() - itemInv.amount;
                            itemInv.amount = itemInv.MaxStackable();
                        }
                    }
                }
                if (item.amount > 0) player.inventory.GiveItem(item);
            }
            else
            {
                while (item.amount > item.MaxStackable())
                {
                    Item thisItem = ItemManager.CreateByName(item.info.shortname, item.MaxStackable(), item.skin);
                    if (item.skin != 0) thisItem.name = item.name;
                    player.inventory.GiveItem(thisItem);
                    item.amount -= item.MaxStackable();
                }
                if (item.amount > 0) player.inventory.GiveItem(item);
            }
        }

        void MoveOutItem(BasePlayer player, Item item)
        {
            if (item.amount <= item.MaxStackable()) item.Drop(player.transform.position, Vector3.up);
            else
            {
                while (item.amount > item.MaxStackable())
                {
                    Item thisItem = ItemManager.CreateByName(item.info.shortname, item.MaxStackable(), item.skin);
                    if (item.skin != 0) thisItem.name = item.name;
                    thisItem.Drop