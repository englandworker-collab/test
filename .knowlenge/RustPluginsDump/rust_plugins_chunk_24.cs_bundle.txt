(player.transform.position, Vector3.up);
                    item.amount -= item.MaxStackable();
                }
                if (item.amount > 0) item.Drop(player.transform.position, Vector3.up);
            }
        }
        #endregion MoveItem

        #region Commands
        [ConsoleCommand("givepicklock")]
        void ConsoleGivePicklock(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length != 2) return;
            BasePlayer player = arg.Player();
            BasePlayer target = BasePlayer.FindByID(Convert.ToUInt64(arg.Args[0]));
            int amount = Convert.ToInt32(arg.Args[1]);
            if (amount <= 0) return;
            if (player == null)
            {
                if (target == null)
                {
                    Puts("The specified player was not found!");
                    return;
                }
                MoveItem(target, GetPicklock(amount));
                Puts($"The player {target.displayName} has been given a Picklock item ({amount} pieces)");
            }
            else
            {
                if (player.IsAdmin)
                {
                    if (target == null)
                    {
                        PrintToChat(player, GetMessage("NoTarget", player.userID));
                        return;
                    }
                    MoveItem(target, GetPicklock(amount));
                    PrintToChat(player, GetMessage("GivePicklock", player.userID, target.displayName, amount));
                }
            }
        }
        #endregion Commands
    }
}

// --- End of file: Picklock.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/UberTool (1).cs ---
// --- Original Local Path: UberTool (1).cs ---

using Facepunch;
using Network;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Oxide.Game.Rust.Libraries.Covalence;
using ProtoBuf;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using UnityEngine;
using BTN = BUTTON;

namespace Oxide.Plugins
{
    [Info("UberTool", "Skuli Dropek", "1.4.19", ResourceId = 78)]
    [Description("The ultimative build'n'place solution without any borders or other known limits")]
    internal class UberTool : RustPlugin
    {
        [PluginReference]
        private Plugin Clans, ImageLibrary;
        private StrdDt playerPrefs = new StrdDt();

        private class StrdDt
        {
            public Dictionary<ulong,
            Plyrnf> playerData = new Dictionary<ulong,
            Plyrnf>();

            public StrdDt() { }
        }

        private class Plyrnf
        {
            public float SF;
            public int DBG;

            public Plyrnf() { }
        }

        private const string WIRE_EFFECT = "assets/prefabs/tools/wire/effects/plugeffect.prefab";

        private object CanUseWires(BasePlayer player)
        {
            EPlanner planner = player.GetComponent<EPlanner>();

            if (planner != null && planner.isWireTool)
            {
                return player.serverInput.IsDown(BTN.FIRE_SECONDARY);
            }

            return null;
        }

        public class EPlanner : MonoBehaviour
        {
            private BasePlayer player;
            private InputState serverInput;
            private uint ctvtm;
            private Construction.Target target;
            private Construction.Target mvTrgt;
            private BaseEntity mvTrgtSnp;
            private Construction construction;
            private Construction mvCnstrctn;
            private Construction rayDefinition;
            private Vector3 rttnOffst;
            private Vector3 mvOffst;
            private string lstCrsshr;
            private string lstWrnng;
            private Planner plnnr;
            private bool isPlanner;
            private bool isHammering;
            internal bool isWireTool;
            internal bool isLightDeployer;
            private HeldEntity heldItem;
            private bool sRmvr;
            private bool isAnotherHeld;
            private Item ctvtmLnk;
            private bool sTpDplybl;
            private int dfltGrd;
            private uint lstPrfb;
            private bool initialized;
            private bool ctvTrgt;
            private bool isPlacing;
            private float tkDist;
            private RaycastHit rayHit;
            private BaseEntity rayEntity;
            private IPlayer rayEntityOwner;
            private string rayEntityName;
            private Vector3 lastAimAngles;
            private Socket_Base lastSocketBase;
            private Vector3 lastSocketPos;
            private BaseEntity lastSocketEntity;
            private Construction.Placement lastPlacement;
            private Ray lastRay;
            private bool plannerInfoStatus;
            private bool removerInfoStatus;
            private bool hammerInfoStatus;
            private bool lastSocketForce;
            private int cuiFontSize = 14;
            private string cuiFontColor = "1 1 1 1";
            private string fontType = r("EbobgbPbaqrafrq-Erthyne.ggs");
            private float lastPosRotUpdate = 0f;


            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                serverInput = player.serverInput;
                Unequip();
                dfltGrd = Instance.playerPrefs.playerData[player.userID].DBG;
                lstPrfb = 72949757u;
                ctvtm = 0;
                construction = new Construction();
                rayDefinition = new Construction();
                construction.canBypassBuildingPermission = true;
                lastAimAngles = player.lastReceivedTick.inputState.aimAngles;
                lastSocketBase =
            default(Socket_Base);
                lastSocketPos = Vector3.zero;
                lastSocketEntity =
            default(BaseEntity);
                lastPlacement =
            default(Construction.Placement);
                rayEntity =
            default(BaseEntity);
                rttnOffst = Vector3.zero;
                mvOffst = Vector3.zero;
            }

            private void Start()
            {
                if (Instance.hideTips) player.SendConsoleCommand(r("tnzrgvc.uvqrtnzrgvc"));
                initialized = true;
            }

            private void Unequip()
            {
                foreach (Item item in player.inventory.containerBelt.itemList.Where(x => x.IsValid() && x.GetHeldEntity()).ToList())
                {
                    int slot = item.position;
                    if (item.info.shortname == "rock" && item.skin == 0uL || item.info.shortname == "torch")
                    {
                        item.Remove(0f);
                        continue;
                    }
                    else
                    {
                        item.RemoveFromContainer();
                    }

                    player.inventory.UpdateContainer(0f, PlayerInventory.Type.Belt, player.inventory.containerBelt, false, 0f);
                    Instance.timer.Once(0.15f, () =>
                    {
                        if (item == null) return;
                        item.MoveToContainer(player.inventory.containerBelt, slot, true);
                        item.MarkDirty();
                    });
                    ItemManager.DoRemoves();
                }

                if (player.inventory.containerWear.itemList.Count == 0)
                {
                    Item hz = ItemManager.CreateByName("hazmatsuit_scientist", 1);
                    player.inventory.GiveItem(hz, player.inventory.containerWear);
                }

                Instance.timer.Once(0.3f, CrtTls);
            }

            private void GetTool(object[] tool)
            {
                ItemDefinition itemDef = ItemManager.FindItemDefinition((string)tool[1]);
                if (!itemDef) return;
                Item p1 = player.inventory.FindItemID(itemDef.itemid);
                ulong skin = Convert.ToUInt64(tool[2]);
                if (p1 != null)
                {
                    p1.skin = skin;
                    p1.GetHeldEntity().skinID = skin;
                    p1.name = (string)tool[0];
                    if (p1.CanMoveTo(player.inventory.containerBelt, -1, true))
                    {
                        p1.MoveToContainer(player.inventory.containerBelt, -1, true);
                        p1.MarkDirty();
                    }
                }
                else
                {
                    Item p2 = ItemManager.CreateByItemID(itemDef.itemid, 1, skin);
                    if (p2 != null)
                    {
                        p2.name = (string)tool[0];
                        player.inventory.GiveItem(p2, player.inventory.containerBelt);
                        p2.MarkDirty();
                    }
                }
            }

            private void CrtTls()
            {
                if (Instance.checkExistingPlanner) GetTool(Instance.playerTools[0]);
                if (Instance.checkExistingRemover) GetTool(Instance.playerTools[1]);
                if (Instance.checkExistingHammer) GetTool(Instance.playerTools[2]);
            }

            private bool GetCurrentTool()
            {
                isPlanner = false;
                sRmvr = false;
                isHammering = false;
                isWireTool = false;
                isAnotherHeld = false;
                isLightDeployer = false;
                DestroyInfo();
                if (heldItem is Planner)
                {
                    plnnr = heldItem as Planner;
                    isPlanner = true;
                    sTpDplybl = plnnr.isTypeDeployable;
                    DoPlannerInfo();
                    return true;
                }
                else if (heldItem is BaseProjectile && ctvtmLnk.skin == Convert.ToUInt64(Instance.playerTools[1][2]))
                {
                    sRmvr = true;
                    return true;
                }
                else if (heldItem is Hammer && ctvtmLnk.skin == Convert.ToUInt64(Instance.playerTools[2][2]))
                {
                    isHammering = true;
                    DoHammerInfo();
                    return true;
                }
                else if (heldItem is AttackEntity)
                {
                    isAnotherHeld = true;
                    return true;
                }
                else if (heldItem is WireTool)
                {
                    isWireTool = true;
                    return true;
                }
                else if (heldItem is PoweredLightsDeployer)
                {
                    isLightDeployer = true;
                    return true;
                }

                if (!isWireTool && (source != null || isWiring))
                {
                    if (sourceSlot != null)
                        sourceSlot.linePoints = new Vector3[0];

                    source = null;
                    sourceSlot = null;
                    isWiring = false;
                }

                return false;
            }

            private void CheckRemover()
            {
                bool hsLsr = false;
                if (ctvtmLnk.info.shortname != (string)Instance.playerTools[1][1])
                {
                    sRmvr = false;
                    heldItem = null;
                    return;
                }

                ctvtmLnk.contents.flags = (ItemContainer.Flag)64;
                ctvtmLnk.contents.MarkDirty();
                if (ctvtmLnk.contents != null && ctvtmLnk.contents.itemList.Count > 0) foreach (Item mod in ctvtmLnk.contents.itemList) if (mod.info.shortname == r("jrncba.zbq.ynfrefvtug"))
                        {
                            hsLsr = true;
                            break;
                        }

                if (!hsLsr)
                {
                    Item lMod = ItemManager.CreateByName(r("jrncba.zbq.ynfrefvtug"), 1);
                    if (lMod != null) if (lMod.MoveToContainer(ctvtmLnk.contents, -1, true))
                        {
                            hsLsr = true;
                        }
                        else
                        {
                            sRmvr = false;
                            heldItem = null;
                            return;
                        }
                }

                (heldItem as BaseProjectile).UnloadAmmo(ctvtmLnk, player);
                heldItem.SetLightsOn(true);
                DoRemoverInfo();
            }

            public void SetHeldItem(uint uid)
            {
                if (!initialized || uid == ctvtm) return;
                if (uid == 0u)
                {
                    ctvtm = 0u;
                    isPlanner = false;
                    sRmvr = false;
                    isHammering = false;
                    isWireTool = false;
                    sTpDplybl = false;
                    construction = null;
                    isLightDeployer = false;
                    DestroyInfo();
                    return;
                }

                if (uid != ctvtm)
                {
                    ctvtmLnk = player.inventory.containerBelt.FindItemByUID(uid);
                    if (ctvtmLnk == null) return;
                    ctvtm = uid;
                    heldItem = ctvtmLnk.GetHeldEntity() as HeldEntity;
                    if (heldItem == null) return;
                    if (!GetCurrentTool()) return;
                    if (sRmvr)
                    {
                        CuiHelper.DestroyUi(player, r("HgPebffUnveHV"));
                        CheckRemover();
                    }
                    else if (isPlanner || isHammering)
                    {
                        construction = PrefabAttribute.server.Find<Construction>(
                        isPlanner && sTpDplybl && plnnr.GetDeployable() != null ? plnnr.GetDeployable().prefabID : lstPrfb);
                        rttnOffst = Vector3.zero;
                        if (isPlanner)
                        {
                            if (sTpDplybl) DoPlannerUpdate(PType.Mode, ctvtmLnk.info.displayName.english);
                            else DoPlannerUpdate(PType.Mode, $"{construction.info.name.english} ({((BuildingGrade.Enum)dfltGrd).ToString()})");
                        }
                        else
                        {
                            DoPlannerUpdate(PType.Mode);
                        }
                    }
                }
            }

            private bool isWiring = false;

            public void TickUpdate(PlayerTick tick)
            {
                if (!initialized)
                    return;

                bool changedInput = tick.inputState.aimAngles != lastAimAngles || tick.inputState.buttons != serverInput.previous.buttons || lastSocketForce;

                if (lastSocketForce)
                    lastSocketForce = false;

                if (changedInput && !ctvTrgt)
                {
                    rayHit = default(RaycastHit);
                    lastAimAngles = tick.inputState.aimAngles;
                    int layer = sRmvr && Instance.removeToolObjects ? 1143089921 : 2097921;
                    float range = 24f;

                    if (sRmvr)
                        range = Instance.removeToolRange;
                    else if (isHammering)
                        range = Instance.hammerToolRange;

                    lastRay = new Ray(tick.position + new Vector3(0f, 1.5f, 0f), Quaternion.Euler(tick.inputState.aimAngles) * Vector3.forward);

                    if (Physics.Raycast(lastRay, out rayHit, range, layer, QueryTriggerInteraction.Ignore))
                    {
                        BaseEntity ent = rayHit.GetEntity();
                        if (ent != null && ent != rayEntity)
                        {
                            rayEntity = ent;
                            rayDefinition = PrefabAttribute.server.Find<Construction>(rayEntity.prefabID);
                            if (rayEntity.OwnerID > 0uL) rayEntityOwner = Instance.covalence.Players.FindPlayerById(rayEntity.OwnerID.ToString());
                            else rayEntityOwner = null;
                            rayEntityName = "";
                            if (rayDefinition) rayEntityName = rayDefinition.info.name.english;
                            if (rayEntityName.Length == 0)
                            {
                                if (rayEntity is BaseCombatEntity)
                                {
                                    rayEntityName = (rayEntity as BaseCombatEntity).repair.itemTarget?.displayName.english;
                                    if (rayEntityName == null || rayEntityName.Length == 0) rayEntityName = rayEntity.ShortPrefabName;
                                }
                                else
                                {
                                    rayEntityName = rayEntity.ShortPrefabName;
                                }
                            }

                            if (rayDefinition == null && (rayEntity.PrefabName.EndsWith("static.prefab") || rayEntity.PrefabName.Contains("/deployable/")))
                            {
                                rayDefinition = new Construction();
                                rayDefinition.rotationAmount = new Vector3(0, 90f, 0);
                                rayDefinition.fullName = rayEntity.PrefabName;
                                rayDefinition.maxplaceDistance = 8f;
                            }
                        }
                        else if (ent == null)
                        {
                            rayEntity = null;
                            rayDefinition = null;
                            rayEntityOwner = null;
                            rayEntityName = "";
                        }
                    }
                    else
                    {
                        rayEntity = null;
                        rayDefinition = null;
                        rayEntityOwner = null;
                        rayEntityName = "";
                    }

                    if (isPlanner)
                    {
                        if (lstWrnng != string.Empty)
                            DoWarning(string.Empty, true);

                        target = default(Construction.Target);
                        target.player = player;
                        target.ray = lastRay;
                        CheckPlacement(ref target, construction);

                        if (target.socket != null && (target.socket != lastSocketBase || target.entity != lastSocketEntity || lastSocketForce))
                        {
                            if (lastSocketForce)
                                lastSocketForce = false;

                            bool chEnt = false;
                            if (Instance.effectFoundationPlacement && construction.hierachyName.Contains("foundation") && lastSocketEntity != target.entity)
                            {
                                chEnt = true;
                                SendEffectTo(3951505782, target.entity, player);
                            }

                            lastSocketEntity = target.entity;
                            string name = target.entity.ShortPrefabName;

                            if (target.entity is BuildingBlock)
                                DoPlannerUpdate(PType.ConnectTo, $"{rayEntityName} [{target.entity.net.ID}] ({(target.entity as BuildingBlock).currentGrade.gradeBase.type.ToString()})");
                            else DoPlannerUpdate(PType.ConnectTo, $"{rayEntityName} [{target.entity.net.ID}]");

                            if (Instance.effectFoundationPlacement && !chEnt && construction.hierachyName.Contains("foundation") && lastSocketBase != target.socket)
                                SendEffectTo(3389733993, target.entity, player);

                            lastSocketBase = target.socket;
                            lastSocketPos = lastSocketEntity.transform.localToWorldMatrix.MultiplyPoint3x4(lastSocketBase.position);

                            string s1 = lastSocketBase.socketName.Replace($"{target.entity.ShortPrefabName}/sockets/", "").TrimEnd('/', '1', '2', '3', '4').Replace("-", " ").Replace("–", " ");

                            DoPlannerUpdate(PType.ToSocket, $"{Oxide.Core.ExtensionMethods.TitleCase(s1)}");
                            lastPlacement = CheckPlacement(target, construction);

                            if (lastPlacement != null)
                                DoPlannerUpdate(PType.PosRot, $"{lastPlacement.position.ToString("N1")} | {lastPlacement.rotation.eulerAngles.y.ToString("N1")}°");
                            else DoPlannerUpdate(PType.PosRot);
                        }

                        if (sTpDplybl)
                        {
                            lastPlacement = CheckPlacement(target, construction);

                            if (lastPlacement != null)
                            {
                                DoPlannerUpdate(PType.PosRot, $"{lastPlacement.position.ToString("N1")} | {lastPlacement.rotation.eulerAngles.ToString("N1")}");
                                DoPlannerUpdate(PType.ToSocket, "Terrain");
                                if (rayEntity) DoPlannerUpdate(PType.ConnectTo, $"{rayEntityName} [{rayEntity.net.ID}]");
                            }
                            else
                            {
                                DoPlannerUpdate(PType.ToSocket);
                                DoPlannerUpdate(PType.ConnectTo);
                                DoPlannerUpdate(PType.PosRot);
                            }
                        }

                        if (!sTpDplybl && !target.socket)
                        {
                            lastSocketBase = default(Socket_Base);
                            lastSocketEntity = default(BaseEntity);

                            DoPlannerUpdate(PType.ConnectTo);
                            DoPlannerUpdate(PType.PosRot);
                            DoPlannerUpdate(PType.ToSocket);
                        }
                    }
                    else if (isHammering)
                    {
                        if (lstWrnng != string.Empty)
                            DoWarning(string.Empty, true);

                        if (!ctvTrgt)
                        {
                            if (rayEntity && rayHit.distance <= Instance.hammerToolRange)
                            {
                                if (rayDefinition && rayEntity is BuildingBlock)
                                {
                                    DoHammerUpdate(HType.Target, $"{rayEntityName} [{rayEntity.net.ID}] ({(rayEntity as BuildingBlock).currentGrade.gradeBase.type.ToString()})");
                                    DoCrosshair("0 1 0 0.75");
                                }
                                else if (rayDefinition)
                                {
                                    if (rayDefinition.fullName == StringPool.Get(3424003500))
                                        DoHammerUpdate(HType.Target, $"{rayEntityName} [{rayEntity.net.ID}] (Type: {(rayEntity as MiningQuarry).staticType})");
                                    else DoHammerUpdate(HType.Target, $"{rayEntityName} [{rayEntity.net.ID}]");

                                    DoCrosshair("1 0.921568632 0.0156862754 0.75");
                                }
                                else
                                {
                                    DoHammerUpdate(HType.Target, $"{rayEntityName} [{rayEntity.net.ID}]");
                                }

                                DoHammerUpdate(HType.Mode, "Modify");
                                DoHammerUpdate(HType.Building, rayEntity is DecayEntity ? $"ID {(rayEntity as DecayEntity).buildingID}" : "None");

                                if (rayDefinition)
                                {
                                    float currentTime = Time.realtimeSinceStartup;
                                    if (currentTime - lastPosRotUpdate >= 0.25f)
                                    {
                                        if (rayEntity is BuildingBlock)
                                            DoHammerUpdate(HType.PosRot, $"{rayEntity.transform.position.ToString("N1")} | {rayEntity.transform.rotation.eulerAngles.y.ToString("N1")}°");
                                        else DoHammerUpdate(HType.PosRot, $"{rayEntity.transform.position.ToString("N1")} | {rayEntity.transform.rotation.eulerAngles.ToString("N1")}");

                                        lastPosRotUpdate = currentTime;
                                    }

                                    if (rayEntityOwner != null)
                                        DoHammerUpdate(HType.Owner, $"{rayEntityOwner.Name}");
                                    else DoHammerUpdate(HType.Owner, $"{rayEntity.OwnerID}");

                                    DoHammerUpdate(HType.SteamID, $"{rayEntity.OwnerID}");
                                }
                            }
                            else
                            {
                                DoHammerUpdate(HType.Target);
                                DoHammerUpdate(HType.Building);
                                DoHammerUpdate(HType.Mode, r("Zbqvsl"));
                                DoHammerUpdate(HType.PosRot);
                                DoHammerUpdate(HType.Owner);
                                DoCrosshair("1 1 1 0.75");
                            }
                        }
                        else
                        {
                            DoHammerUpdate(HType.PosRot, $"{mvTrgt.entity.transform.position.ToString("N1")} | {mvTrgt.entity.transform.rotation.eulerAngles.ToString("N1")}");
                            DoCrosshair(string.Empty);
                        }
                    }
                    else if (sRmvr)
                    {
                        DoCrosshair(string.Empty);
                        if (rayEntity != null && rayHit.distance <= Instance.removeToolRange && (rayDefinition || !rayDefinition && Instance.removeToolObjects))
                        {
                            DoRemoverUpdate(RType.Remove, $"{rayEntityName} [{rayEntity.net.ID}]");
                            if (rayEntityOwner != null) DoRemoverUpdate(RType.Owner, $"{rayEntityOwner.Name}");
                            else DoRemoverUpdate(RType.Owner, $"{rayEntity.OwnerID}");
                        }
                        else
                        {
                            DoRemoverUpdate(RType.Remove);
                            DoRemoverUpdate(RType.Owner);
                        }

                        if (Instance.enableFullRemove && serverInput.IsDown(controlButtons[CmdType.RemoverHoldForAll]) && rayEntity is BuildingBlock)
                        {
                            DoWarning("1 0 0 0.75");
                            DoRemoverUpdate(RType.Mode, "<color=#ffff00>Building</color>");
                        }
                        else
                        {
                            DoRemoverUpdate(RType.Mode, r("Fvatyr"));
                            DoWarning(string.Empty);
                        }
                    }
                    else if (isAnotherHeld)
                    {
                        if (heldItem is BaseLiquidVessel && (serverInput.WasJustReleased((BTN)1024) || serverInput.WasDown((BTN)2048)))
                        {
                            BaseLiquidVessel vessel = heldItem as BaseLiquidVessel;
                            if (vessel.AmountHeld() < 1) vessel.AddLiquid(ItemManager.FindItemDefinition("water"), vessel.MaxHoldable());
                        }
                        else if (heldItem is BaseProjectile && serverInput.WasJustPressed((BTN)8192))
                        {
                            BaseProjectile weapon = heldItem as BaseProjectile;
                            if (!weapon.primaryMagazine.CanReload(player) && weapon.primaryMagazine.contents < weapon.primaryMagazine.capacity)
                            {
                                try
                                {
                                    player.inventory.GiveItem(ItemManager.Create(weapon.primaryMagazine.ammoType, weapon.primaryMagazine.capacity - weapon.primaryMagazine.contents));
                                }
                                catch { }

                                ItemManager.DoRemoves();
                            }
                        }
                        else if (heldItem is FlameThrower && (serverInput.WasJustPressed((BTN)8192) || serverInput.IsDown((BTN)1024)))
                        {
                            FlameThrower flame = heldItem as FlameThrower;
                            if (serverInput.IsDown((BTN)1024) && flame.ammo < 2 || serverInput.WasJustPressed((BTN)8192) && flame.ammo < flame.maxAmmo)
                            {
                                flame.ammo = flame.maxAmmo;
                                flame.SendNetworkUpdateImmediate(false);
                                ItemManager.DoRemoves();
                                player.inventory.ServerUpdate(0f);
                            }
                        }
                        else if (heldItem is Chainsaw && (serverInput.WasJustPressed((BTN)8192) || serverInput.IsDown((BTN)1024) || serverInput.WasJustPressed((BTN)2048)))
                        {
                            Chainsaw saw = heldItem as Chainsaw;
                            if (serverInput.WasJustPressed((BTN)2048) && !saw.EngineOn())
                            {
                                saw.SetEngineStatus(true);
                                heldItem.SendNetworkUpdateImmediate(false);
                            }
                            else if (serverInput.IsDown((BTN)1024) && saw.ammo < 2 || serverInput.WasJustPressed((BTN)8192) && saw.ammo < saw.maxAmmo)
                            {
                                saw.ammo = saw.maxAmmo;
                                saw.SendNetworkUpdateImmediate(false);
                                ItemManager.DoRemoves();
                                player.inventory.ServerUpdate(0f);
                            }
                        }
                    }
                    else if (isLightDeployer)
                    {
                        PoweredLightsDeployer lightsDeployer = heldItem as PoweredLightsDeployer;
                        if (lightsDeployer == null)
                            return;

                        if (player.serverInput.WasJustPressed(BTN.FIRE_SECONDARY))
                        {
                            lightsDeployer.DoFinish();
                            return;
                        }

                        if (player.serverInput.WasJustPressed(BTN.FIRE_PRIMARY))
                        {
                            RaycastHit raycastHit;
                            if (Physics.Raycast(player.eyes.HeadRay(), out raycastHit, 5f))
                            {
                                if (heldItem.GetItem() == null)
                                {
                                    return;
                                }
                                if (heldItem.GetItem().amount < 1)
                                {
                                    return;
                                }
                                if (!heldItem.IsVisible(raycastHit.point, Single.PositiveInfinity))
                                {
                                    return;
                                }

                                if (Vector3.Distance(raycastHit.point, player.eyes.position) > 5f)
                                {
                                    player.ChatMessage("Too far away!");
                                    return;
                                }

                                int amountToUse = 1;
                                if (lightsDeployer.active != null)
                                {
                                    if (lightsDeployer.active.IsFinalized())
                                        return;

                                    float length = 0f;
                                    Vector3 position = lightsDeployer.active.transform.position;
                                    if (lightsDeployer.active.points.Count > 0)
                                    {
                                        position = lightsDeployer.active.points[lightsDeployer.active.points.Count - 1].point;
                                        length = Vector3.Distance(raycastHit.point, position);
                                    }
                                    length = Mathf.Max(length, lightsDeployer.lengthPerAmount);
                                    float item1 = (float)heldItem.GetItem().amount * lightsDeployer.lengthPerAmount;
                                    if (length > item1)
                                    {
                                        length = item1;
                                        raycastHit.point = position + (Vector3Ex.Direction(raycastHit.point, position) * length);
                                    }
                                    length = Mathf.Min(item1, length);
                                    amountToUse = Mathf.CeilToInt(length / lightsDeployer.lengthPerAmount);
                                }
                                else
                                {
                                    AdvancedChristmasLights component = GameManager.server.CreateEntity(lightsDeployer.poweredLightsPrefab.resourcePath, raycastHit.point, Quaternion.LookRotation(raycastHit.normal, player.eyes.HeadUp()), true).GetComponent<AdvancedChristmasLights>();
                                    component.Spawn();
                                    lightsDeployer.active = component;
                                    amountToUse = 1;
                                }

                                lightsDeployer.active.AddPoint(raycastHit.point, raycastHit.normal);
                                lightsDeployer.SetFlag(BaseEntity.Flags.Reserved8, lightsDeployer.active != null, false, true);
                                lightsDeployer.active.AddLengthUsed(amountToUse);
                                lightsDeployer.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                            }
                        }
                    }
                    else if (isWireTool)
                    {
                        if (player.serverInput.WasJustPressed(BTN.FIRE_SECONDARY))
                        {
                            source = null;
                            sourceSlot = null;

                            if (isWiring)
                            {
                                isWiring = false;
                                player.ChatMessage("Cancelled current IO connection");
                            }

                            return;
                        }

                        if (player.serverInput.WasJustPressed(BTN.FIRE_PRIMARY))
                        {
                            RaycastHit raycastHit;
                            Ray ray = player.eyes.HeadRay();
                            if (Physics.Raycast(ray, out raycastHit, 5f))
                            {
                                IOEntity ioEntity = raycastHit.GetEntity() as IOEntity;
                                if (!isWiring)
                                {
                                    if (ioEntity != null)
                                    {
                                        IOEntity.IOSlot[] slots = ioEntity.outputs;

                                        IOEntity.IOSlot target = null;
                                        float distance = float.PositiveInfinity;

                                        for (int i = 0; i < slots.Length; i++)
                                        {
                                            IOEntity.IOSlot slot = slots[i];

                                            if (slot.connectedTo.Get(true) == null)
                                            {
                                                Vector3 point2origin = ray.origin - ioEntity.transform.TransformPoint(slot.handlePosition);
                                                Vector3 point2closestPointOnLine = point2origin - Vector3.Dot(point2origin, ray.direction) * ray.direction;
                                                float d = point2closestPointOnLine.magnitude;
                                                if (d < distance)
                                                {
                                                    distance = d;
                                                    target = slot;
                                                }
                                            }
                                        }

                                        if (target != null && distance < 0.2f)
                                        {
                                            source = ioEntity;
                                            sourceSlot = target;
                                            isWiring = true;

                                            player.ChatMessage($"Begin Wiring - From {source.ShortPrefabName} (Slot {sourceSlot.niceName})");
                                            player.SendConsoleCommand("ddraw.sphere", 30f, Color.green, source.transform.TransformPoint(sourceSlot.handlePosition), 0.025f);
                                            Effect.server.Run(WIRE_EFFECT, ioEntity.transform.position);
                                        }
                                        else player.ChatMessage("No valid IO Entity found");
                                    }
                                }
                                else
                                {
                                    if (ioEntity == null)
                                        player.ChatMessage("Select another IO slot to make a connection");
                                    else
                                    {
                                        if (ioEntity == source)
                                        {
                                            player.ChatMessage("You can not connect a IO entity to itself");
                                            return;
                                        }

                                        IOEntity.IOSlot[] slots = ioEntity.inputs;

                                        IOEntity.IOSlot target = null;
                                        float distance = float.PositiveInfinity;
                                        int index = -1;
                                        
                                        for (int i = 0; i < slots.Length; i++)
                                        {
                                            IOEntity.IOSlot slot = slots[i];

                                            if (slot.connectedTo.Get(true) == null)
                                            {
                                                Vector3 point2origin = ray.origin - ioEntity.transform.TransformPoint(slot.handlePosition);
                                                Vector3 point2closestPointOnLine = point2origin - Vector3.Dot(point2origin, ray.direction) * ray.direction;
                                                float d = point2closestPointOnLine.magnitude;
                                                if (d < distance)
                                                {
                                                    distance = d;
                                                    target = slot;
                                                    index = i;
                                                }
                                            }
                                        }

                                        if (target != null && distance < 0.2f)
                                        {
                                            player.SendConsoleCommand("ddraw.sphere", 30f, Color.green, ioEntity.transform.TransformPoint(target.handlePosition), 0.025f);

                                            sourceSlot.connectedTo = new IOEntity.IORef();
                                            sourceSlot.connectedTo.ioEnt = ioEntity;
                                            sourceSlot.connectedTo.Set(ioEntity);
                                            sourceSlot.connectedToSlot = index;

                                            target.connectedTo = new IOEntity.IORef();
                                            target.connectedTo.ioEnt = source;
                                            target.connectedTo.Set(source);

                                            source.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                                            ioEntity.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

                                            source.MarkDirtyForceUpdateOutputs();
                                            ioEntity.MarkDirtyForceUpdateOutputs();

                                            player.ChatMessage($"Connected IO from {source.ShortPrefabName} (Slot {sourceSlot.niceName}) -> {ioEntity.ShortPrefabName} (Slot {target.niceName})");

                                            Effect.server.Run(WIRE_EFFECT, ioEntity.transform.position);

                                            source = null;
                                            sourceSlot = null;
                                            isWiring = false;
                                        }                                        
                                        else player.ChatMessage("Failed to make a connection");
                                    }
                                }
                            }
                        }
                    }
                }
                else if (changedInput && ctvTrgt)
                {
                    DoHammerUpdate(HType.PosRot, $"{mvTrgt.entity.transform.position.ToString("N1")} | {mvTrgt.entity.transform.rotation.eulerAngles.ToString("N1")}");
                    DoCrosshair(string.Empty, true);
                }

                if (isPlanner && !sTpDplybl) if (lastSocketBase != null && lastPlacement != null && lastSocketEntity)
                    {
                        OBB oBB = new OBB(lastPlacement.position, Vector3.one, lastPlacement.rotation, construction.bounds);
                        Vector3 obb_pos = construction.hierachyName.Contains(r("sbhaqngvba")) ? oBB.position + oBB.extents.y * Vector3.up : oBB.position;
                        Vector3 sock_pos = construction.hierachyName.Contains(r("sbhaqngvba")) ? new Vector3(lastSocketPos.x, lastSocketEntity.transform.position.y, lastSocketPos.z) : lastSocketPos;
                        player.SendConsoleCommand("ddraw.box", 0.05f, Color.green, obb_pos, 0.15f);
                        player.SendConsoleCommand("ddraw.box", 0.05f, Color.green, sock_pos, 0.25f);
                        player.SendConsoleCommand("ddraw.line", 0.05f, Color.green, obb_pos, sock_pos);
                    }
            }

            private IOEntity source;
            private IOEntity.IOSlot sourceSlot;

            private void Update()
            {
                if (!ctvTrgt) return;
                if (!isPlacing && isHammering)
                {
                    if (mvTrgt.entity == null)
                    {
                        DoCrosshair("1 1 1 0.75");
                        mvTrgt =
                    default(Construction.Target);
                        isPlacing = false;
                        ctvTrgt = false;
                        return;
                    }

                    bool flag = mvTrgt.entity is SimpleBuildingBlock || mvCnstrctn.allSockets == null;
                    mvTrgt.ray = player.eyes.BodyRay();
                    FndTrrnPlcmnt(ref mvTrgt, mvCnstrctn, tkDist, flag);
                    Vector3 position = mvTrgt.entity.transform.position;
                    Quaternion rotation = mvTrgt.entity.transform.rotation;
                    Vector3 toPos = mvTrgt.position;
                    Quaternion toRot = Quaternion.LookRotation(mvTrgt.entity.transform.up) * Quaternion.Euler(mvOffst);
                    if (flag)
                    {
                        Vector3 direction = mvTrgt.ray.direction;
                        direction.y = 0f;
                        direction.Normalize();
                        toRot = Quaternion.Euler(mvOffst) * Quaternion.LookRotation(direction, Vector3.up);
                    }

                    Construction.Placement check = CheckPlacement(mvTrgt, mvCnstrctn);
                    if (check != null)
                    {
                        toPos = check.position;
                        toRot = check.rotation * Quaternion.Euler(mvOffst);
                    }

                    mvTrgt.entity.transform.position = Vector3.Lerp(position, toPos, Time.deltaTime * 5f);
                    mvTrgt.entity.transform.rotation = Quaternion.Lerp(rotation, toRot, Time.deltaTime * 10f);
                    DMvmntSnc(mvTrgt.entity);
                    return;
                }
                else if (isPlacing)
                {
                    if (mvTrgt.entity == null)
                    {
                        DoCrosshair("1 1 1 0.75");
                        mvTrgt =
                    default(Construction.Target);
                        isPlacing = false;
                        ctvTrgt = false;
                        return;
                    }

                    if (Vector3.Distance(mvTrgt.entity.transform.position, mvTrgt.position) <= 0.005f)
                    {
                        if (mvTrgtSnp && !(mvTrgtSnp is BuildingBlock))
                        {
                            mvTrgt.entity.transform.position = mvTrgtSnp.transform.InverseTransformPoint(mvTrgt.position);
                            mvTrgt.entity.transform.rotation = Quaternion.Inverse(mvTrgtSnp.transform.rotation) * Quaternion.Euler(mvTrgt.rotation);
                            mvTrgt.entity.SetParent(mvTrgtSnp, 0u);
                        }

                        if (mvTrgtSnp)
                        {
                            DecayUpdate(mvTrgt.entity, true, mvCnstrctn.isBuildingPrivilege, mvTrgtSnp);
                            mvTrgtSnp = null;
                        }

                        DMvmntSnc(mvTrgt.entity);
                        DoCrosshair("1 1 1 0.75");
                        mvTrgt =
                    default(Construction.Target);
                        isPlacing = false;
                        ctvTrgt = false;
                        return;
                    }

                    mvTrgt.entity.transform.position = Vector3.Lerp(mvTrgt.entity.transform.position, mvTrgt.position, Time.deltaTime * 10f);
                    if (mvTrgtSnp == null || mvTrgtSnp && !(mvTrgtSnp is BuildingBlock))
                        mvTrgt.entity.transform.rotation = Quaternion.Lerp(mvTrgt.entity.transform.rotation, Quaternion.Euler(mvTrgt.rotation), Time.deltaTime * 10f);
                    DMvmntSnc(mvTrgt.entity);
                    return;
                }
                else if (!isPlacing && !isHammering)
                {
                    if (mvTrgt.valid) PlaceOnTarget();
                    else TrPlcTrgt();
                }
            }

            private void DecayUpdate(BaseEntity entity, bool isAdding, bool isBuildingPrivilege, BaseEntity target = null)
            {
                DecayEntity decayEntity = entity as DecayEntity;
                if (decayEntity == null) return;
                BuildingManager.Building building = null;
                if (isAdding)
                {
                    DecayEntity decayTarget = target != null ? target as DecayEntity : null;
                    if (decayTarget != null) building = BuildingManager.server.GetBuilding(decayTarget.buildingID);

                    if (building != null)
                    {
                        building.AddDecayEntity(decayEntity);
                        if (isBuildingPrivilege) building.AddBuildingPrivilege(decayEntity as BuildingPrivlidge);
                        building.Dirty();
                        decayEntity.buildingID = building.ID;
                    }
                }
                else
                {
                    building = BuildingManager.server.GetBuilding(decayEntity.buildingID);
                    if (building != null)
                    {
                        if (building.decayEntities != null) building.RemoveDecayEntity(decayEntity);
                        if (isBuildingPrivilege && building.buildingPrivileges != null) building.RemoveBuildingPrivilege(decayEntity as BuildingPrivlidge);
                        building.Dirty();
                    }

                    decayEntity.buildingID = 0u;
                }

                decayEntity.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                if (entity.children != null) foreach (BaseEntity current in entity.children) DecayUpdate(current, isAdding, isBuildingPrivilege, isAdding ? entity : null);
            }

            private void PlaceOnTarget()
            {
                if (mvTrgtSnp && !(mvTrgtSnp is BuildingBlock))
                {
                    mvTrgt.entity.transform.position = mvTrgtSnp.transform.worldToLocalMatrix.MultiplyPoint3x4(mvTrgt.position);
                    mvTrgt.entity.transform.rotation = Quaternion.Inverse(mvTrgtSnp.transform.rotation) * mvTrgt.entity.transform.rotation;
                    mvTrgt.entity.SetParent(mvTrgtSnp, 0u);
                }

                if (mvTrgtSnp)
                {
                    DecayUpdate(mvTrgt.entity, true, mvCnstrctn.isBuildingPrivilege, mvTrgtSnp);
                    mvTrgtSnp = null;
                }

                DMvmntSnc(mvTrgt.entity);
                mvTrgt =
            default(Construction.Target);
                ctvTrgt = false;
                isPlacing = false;
            }

            private void TrPlcTrgt()
            {
                RaycastHit hit;
                mvTrgtSnp = null;
                int layer = mvCnstrctn.isBuildingPrivilege ? 2097152 : 27328769;
                if (Physics.Raycast(mvTrgt.entity.transform.position, mvTrgt.entity.transform.up * -1.0f, out hit, float.PositiveInfinity, layer))
                {
                    mvTrgt.position = hit.point;
                    if (hit.collider is TerrainCollider)
                    {
                        mvTrgt.rotation = Quaternion.LookRotation(Vector3.Cross(mvTrgt.entity.transform.right, hit.normal)).eulerAngles;
                        DoHammerUpdate(HType.Building, "None");
                    }
                    else
                    {
                        mvTrgtSnp = hit.GetEntity();
                        if (mvTrgtSnp)
                        {
                            mvTrgt.rotation = mvTrgt.entity.transform.rotation.eulerAngles;
                            DoHammerUpdate(HType.Building, rayEntity is DecayEntity ? $"ID {(rayEntity as DecayEntity).buildingID}" : "None");
                        }
                        else
                        {
                            DoHammerUpdate(HType.Building, "None");
                        }
                    }

                    isPlacing = true;
                    return;
                }
                else
                {
                    mvTrgt = default(Construction.Target);
                    ctvTrgt = false;
                    isPlacing = false;
                    return;
                }
            }

            public object GtMvTrgt()
            {
                if (ctvTrgt && mvTrgt.entity != null) return (uint)mvTrgt.entity.net.ID;
                return null;
            }

            private void DMvmntSnc(BaseEntity entity, bool isChild = false)
            {
                if (entity == null)
                {
                    DoCrosshair("1 1 1 0.75");
                    mvTrgt = default(Construction.Target);
                    isPlacing = false;
                    ctvTrgt = false;
                    return;
                }

                bool force2 = entity.PrefabName == StringPool.Get(2206646561) || entity.PrefabName == StringPool.Get(2335812770);
                if (isChild || force2)
                {
                    if (Net.sv.write.Start())
                    {
                        Net.sv.write.PacketID(Message.Type.EntityDestroy);
                        Net.sv.write.UInt32(entity.net.ID);
                        Net.sv.write.UInt8(0);
                        Net.sv.write.Send(new SendInfo(entity.net.group.subscribers));
                    }

                    entity.SendNetworkUpdateImmediate(false);
                    if (isChild) return;
                }
                else
                {
                    if (Net.sv.write.Start())
                    {
                        Net.sv.write.PacketID(Message.Type.GroupChange);
                        Net.sv.write.EntityID(entity.net.ID);
                        Net.sv.write.GroupID(entity.net.group.ID);
                        Net.sv.write.Send(new SendInfo(entity.net.group.subscribers));
                    }

                    if (Net.sv.write.Start())
                    {
                        Net.sv.write.PacketID(Message.Type.EntityPosition);
                        Net.sv.write.EntityID(entity.net.ID);

                        Net.sv.write.WriteObject(entity.GetNetworkPosition());
                        Net.sv.write.WriteObject(entity.GetNetworkRotation().eulerAngles);

                        Net.sv.write.Float(entity.GetNetworkTime());
                        SendInfo info = new SendInfo(entity.net.group.subscribers)
                        {
                            method = SendMethod.ReliableUnordered,
                            priority = Priority.Immediate
                        };
                        Net.sv.write.Send(info);
                    }
                }

                if (force2 && entity && entity.children != null)
                    foreach (BaseEntity current in entity.children)
                        DMvmntSnc(current, true);
            }

            public void DoTick()
            {
                if (!initialized || !heldItem) return;

                if (isPlanner)
                {
                    if (true)
                    {
                        if (serverInput.WasJustPressed(controlButtons[CmdType.PlannerPlace]))
                        {
                            DoPlacement();
                            return;
                        }
                        else if (serverInput.WasJustPressed(controlButtons[CmdType.PlannerRotate]))
                        {
                            Vector3 vector = Vector3.zero;
                            if (construction && construction.canRotateBeforePlacement)
                                vector = construction.rotationAmount;
                            rttnOffst.x = Mathf.Repeat(rttnOffst.x + vector.x, 360f);
                            rttnOffst.y = Mathf.Repeat(rttnOffst.y + vector.y, 360f);
                            rttnOffst.z = Mathf.Repeat(rttnOffst.z + vector.z, 360f);
                            return;
                        }
                    }

                    if (!sTpDplybl)
                    {
                        if (serverInput.WasJustPressed((BTN)2048))
                        {
                            BldMnUI(Instance.playerPrefs.playerData[player.userID].SF);
                            return;
                        }

                        if (serverInput.IsDown(controlButtons[CmdType.PlannerTierChange]))
                        {
                            if (serverInput.WasJustPressed(controlButtons[CmdType.PlannerTierNext]))
                            {
                                dfltGrd++;
                                if (dfltGrd > 4) dfltGrd = 0;
                                Instance.playerPrefs.playerData[player.userID].DBG = dfltGrd;
                                DoPlannerUpdate(PType.Mode, $"{construction.info.name.english} ({((BuildingGrade.Enum)dfltGrd).ToString()})");
                                return;
                            }
                            else if (serverInput.WasJustPressed(controlButtons[CmdType.PlannerTierPrev]))
                            {
                                dfltGrd--;
                                if (dfltGrd < 0) dfltGrd = 4;
                                Instance.playerPrefs.playerData[player.userID].DBG = dfltGrd;
                                DoPlannerUpdate(PType.Mode, $"{construction.info.name.english} ({((BuildingGrade.Enum)dfltGrd).ToString()})");
                                return;
                            }
                        }
                    }
                    else if (sTpDplybl) { }
                }
                else if (isHammering)
                {
                    if (ctvTrgt)
                    {
                        if (isPlacing) { }
                        else if (!isPlacing)
                        {
                            if (serverInput.WasJustPressed(controlButtons[CmdType.HammerTransform]))
                            {
                                if (mvTrgt.valid) PlaceOnTarget();
                                else TrPlcTrgt();
                                return;
                            }
                            else if (serverInput.WasJustPressed(controlButtons[CmdType.HammerRotate]))
                            {
                                Vector3 vector = Vector3.zero;
                                if (mvCnstrctn && mvCnstrctn.canRotateAfterPlacement)
                                {
                                    if (serverInput.IsDown(controlButtons[CmdType.HammerRotateDirection])) vector = -mvCnstrctn.rotationAmount;
                                    else vector = mvCnstrctn.rotationAmount;
                                }

                                mvOffst.x = Mathf.Repeat(mvOffst.x + vector.x, 360f);
                                mvOffst.y = Mathf.Repeat(mvOffst.y + vector.y, 360f);
                                mvOffst.z = Mathf.Repeat(mvOffst.z + vector.z, 360f);
                                return;
                            }
                        }
                    }
                    else if (!ctvTrgt)
                    {
                        if (serverInput.WasJustPressed(controlButtons[CmdType.HammerChangeGrade]) && rayEntity && rayEntity.IsValid() && rayEntity is BuildingBlock)
                        {
                            BuildingBlock block = rayEntity as BuildingBlock;
                            int grade = (int)block.currentGrade.gradeBase.type;
                            grade++;
                            if (grade >= block.blockDefinition.grades.Length) grade = 1;
                            block.SetGrade((BuildingGrade.Enum)grade);
                            block.SetHealthToMax();
                            block.StartBeingRotatable();
                            rayEntity.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                            block.UpdateSkin(false);
                            BuildingManager.Building building = BuildingManager.server.GetBuilding(block.buildingID);
                            if (building != null) building.Dirty();
                            if (Instance.effectPromotingBlock) Effect.server.Run("assets/bundled/prefabs/fx/build/promote_" + ((BuildingGrade.Enum)grade).ToString().ToLower() + ".prefab", rayEntity, 0u, Vector3.zero, Vector3.zero, null, false);
                        }
                        else if (serverInput.WasJustPressed(controlButtons[CmdType.HammerToggleOnOff]) && rayEntity && rayEntity.IsValid() && !(rayEntity is BuildingBlock))
                        {
                            BaseEntity r = rayEntity;
                            if (r is StorageContainer || r is IOEntity)
                            {
                                bool isOn = r.HasFlag(BaseEntity.Flags.On);
                                bool hasPower = isOn & r is IOEntity;
                                r.SetFlag(BaseEntity.Flags.On, !isOn, false);
                                if (r is IOEntity) r.SetFlag(BaseEntity.Flags.Reserved8, !hasPower, false);
                                r.SendNetworkUpdate();
                                return;
                            }
                            else if (r is MiningQuarry)
                            {
                                MiningQuarry q = r as MiningQuarry;
                                q.staticType = (MiningQuarry.QuarryType)(int)q.staticType + 1;
                                if ((int)q.staticType > 3) q.staticType = (MiningQuarry.QuarryType)0;
                                q.UpdateStaticDeposit();
                            }
                            else if (r is EngineSwitch)
                            {
                                MiningQuarry miningQuarry = r.GetParentEntity() as MiningQuarry;
                                if (miningQuarry) miningQuarry.EngineSwitch(true);
                            }
                        }
                        else if (serverInput.WasJustPressed(controlButtons[CmdType.HammerRotate]))
                        {
                            if (!rayEntity || !rayEntity.IsValid() || rayDefinition == null || rayDefinition.rotationAmount.y == 0f) return;
                            string effectPath = rayDefinition.deployable != null && rayDefinition.deployable.placeEffect.isValid ? rayDefinition.deployable.placeEffect.resourcePath : StringPool.Get(2598153373);
                            if (serverInput.IsDown(controlButtons[CmdType.HammerRotateDirection])) rayEntity.transform.Rotate(-rayDefinition.rotationAmount);
                            else rayEntity.transform.Rotate(rayDefinition.rotationAmount);
                            if (rayEntity is StabilityEntity)
                            {
                                rayEntity.RefreshEntityLinks();
                                if (!Instance.overrideStabilityBuilding && !(rayEntity as StabilityEntity).grounded) (rayEntity as StabilityEntity).UpdateSurroundingEntities();
                                if (rayEntity is BuildingBlock)
                                {
                                    ConstructionSkin conskin = rayEntity.gameObject.GetComponentInChildren<ConstructionSkin>();
                                    if (conskin) conskin.Refresh(rayEntity as BuildingBlock);
                                    rayEntity.ClientRPC(null, r("ErserfuFxva"));
                                }
                            }

                            DMvmntSnc(rayEntity);
                            Effect.server.Run(effectPath, rayEntity, 0u, Vector3.zero, Vector3.zero, null, false);
                        }
                        else if (serverInput.WasJustPressed(controlButtons[CmdType.HammerTransform]))
                        {
                            if (mvTrgt.entity != null)
                            {
                                mvTrgt =
                            default(Construction.Target);
                                ctvTrgt = false;
                                isPlacing = false;
                                return;
                            }

                            if (!rayEntity || rayEntity is BuildingBlock || rayEntity.FindLinkedEntity<BuildingBlock>()) return;
                            if (rayEntity is BaseMountable && (rayEntity as BaseMountable)._mounted != null) return;
                            mvCnstrctn = PrefabAttribute.server.Find<Construction>(rayEntity.prefabID);
                            if (mvCnstrctn == null)
                            {
                                if (!rayEntity.PrefabName.EndsWith("static.prefab") && !rayEntity.PrefabName.Contains("/deployable/")) return;
                                mvCnstrctn = new Construction();
                                mvCnstrctn.rotationAmount = new Vector3(0, 90f, 0);
                                mvCnstrctn.fullName = rayEntity.PrefabName;
                                mvCnstrctn.maxplaceDistance = rayEntity is MiningQuarry ? 8f : 4f;
                                mvCnstrctn.canRotateBeforePlacement = mvCnstrctn.canRotateAfterPlacement = true;
                            }

                            if (rayEntity is DecayEntity)
                            {
                                DecayUpdate(rayEntity, false, mvCnstrctn.isBuildingPrivilege);
                                DoHammerUpdate(HType.Building, "None");
                            }

                            mvTrgt =
                        default(Construction.Target);
                            mvOffst = Vector3.zero;
                            if (rayEntity.HasParent())
                            {
                                Vector3 position = rayEntity.transform.position;
                                Quaternion rotation = rayEntity.transform.rotation;
                                rayEntity.SetParent(null, 0u);
                                rayEntity.transform.position = position;
                                rayEntity.transform.rotation = rotation;
                                DMvmntSnc(rayEntity);
                            }

                            if (rayEntity.children.Count == 0 || !rayEntity.HasParent()) DMvmntSnc(rayEntity);
                            tkDist = Mathf.Clamp(Vector3.Distance(rayEntity.transform.position, lastRay.origin), mvCnstrctn.maxplaceDistance, mvCnstrctn.maxplaceDistance * 3f);
                            mvTrgt.entity = rayEntity;
                            isPlacing = false;
                            ctvTrgt = true;
                            DoHammerUpdate(HType.Mode, r("Ercbfvgvbavat"));
                        }
                        else if (serverInput.WasJustPressed(controlButtons[CmdType.HammerAuthInfo]) && !serverInput.WasDown(controlButtons[CmdType.HammerTransform]) && (Instance.enableHammerTCInfo || Instance.enableHammerCodelockInfo))
                        {
                            string infoMsg = "";
                            if (Instance.enableHammerTCInfo && rayEntity && rayEntity is BuildingPrivlidge)
                            {
                                bool hasClans = Instance.Clans != null ? true : false;
                                StringBuilder sb = new StringBuilder();
                                rayEntityName = (rayEntity as BaseCombatEntity).repair.itemTarget?.displayName?.english;
                                sb.Append(
                                $">\nBuilding privilege authorized users for <color=#ffa500>{rayEntityName}</color> (<color=#00ffff>{rayEntity.net.ID}</color>)");
                                IPlayer iPlayer = Instance.covalence.Players.FindPlayerById(rayEntity.OwnerID.ToString());
                                if (iPlayer != null)
                                {
                                    sb.Append(
                                    $" | Owner: <color=#ffa500>{iPlayer.Name}</color> (<color=#00ffff>{iPlayer.Id}</color>) | ");
                                    if (iPlayer.IsConnected) sb.AppendLine($"Status: <color=#008000>Online</color>");
                                    else sb.AppendLine($"Status: <color=#ffffff>Offline</color>");
                                }

                                TextTable textTable = new TextTable();
                                textTable.AddColumn("Name");
                                textTable.AddColumn("UserID");
                                if (hasClans) textTable.AddColumn("Clan");
                                textTable.AddColumn("Status");
                                foreach (PlayerNameID nameID in (rayEntity as BuildingPrivlidge).authorizedPlayers.ToList())
                                {
                                    IPlayer authedP = Instance.covalence.Players.FindPlayerById(nameID.userid.ToString());
                                    if (authedP == null) continue;
                                    if (hasClans)
                                    {
                                        string clanTag = "-";
                                        string tag = (string)Instance.Clans?.Call("GetClanOf", Convert.ToUInt64(authedP.Id));
                                        if (tag != null) clanTag = tag;
                                        textTable.AddRow(new string[] {
                                            authedP.Name,
                                            authedP.Id,
                                            clanTag,
                                            ((authedP as RustPlayer).IsConnected ? "<color=#008000>Online</color>": "<color=#ffffff>Offline</color>").ToString()
                                        });
                                    }
                                    else
                                    {
                                        textTable.AddRow(new string[] {
                                            authedP.Name,
                                            authedP.Id,
                                            ((authedP as RustPlayer).IsConnected ? "<color=#008000>Online</color>": "<color=#ffffff>Offline</color>").ToString()
                                        });
                                    }
                                }

                                sb.AppendLine(textTable.ToString());
                                player.ConsoleMessage(sb.ToString());
                                infoMsg += $"<color=#ffa500>TC</color> (<color=#00ffff>{rayEntity.net.ID}</color>) authorized players sent to console";
                            }

                            if (Instance.enableHammerCodelockInfo && rayEntity && rayEntity.HasSlot(BaseEntity.Slot.Lock) && rayEntity.GetSlot(BaseEntity.Slot.Lock) is CodeLock)
                            {
                                bool hasClans = Instance.Clans != null ? true : false;
                                CodeLock codeLock = (CodeLock)rayEntity.GetSlot(BaseEntity.Slot.Lock);
                                StringBuilder sb = new StringBuilder();
                                rayEntityName = (rayEntity as BaseCombatEntity).repair.itemTarget?.displayName.english;
                                sb.Append(
                                $">\nCodeLock authorized users attached to <color=#ffa500>{rayEntityName}</color> (<color=#00ffff>{rayEntity.net.ID}</color>)");
                                IPlayer iPlayer = Instance.covalence.Players.FindPlayerById(rayEntity.OwnerID.ToString());
                                if (iPlayer != null)
                                {
                                    sb.Append(
                                    $" | Owner: <color=#ffa500>{iPlayer.Name}</color> (<color=#00ffff>{iPlayer.Id}</color>) | ");
                                    if (iPlayer.IsConnected) sb.AppendLine($"Status: <color=#008000>Online</color>");
                                    else sb.AppendLine($"Status: <color=#ffffff>Offline</color>");
                                }

                                string code = codeLock.hasCode ? $"<color=#00ffff>{codeLock.code}</color>" : "<color=#00ffff>Not set</color>";
                                string guest = codeLock.hasGuestCode ? $"<color=#00ffff>{codeLock.guestCode}</color>" : "<color=#00ffff>Not set</color>";
                                sb.AppendLine($"Lock code:  {code} | Guest code: {guest}");
                                if (codeLock.whitelistPlayers != null && codeLock.whitelistPlayers.Count > 0)
                                {
                                    sb.AppendLine("Whitelisted:");
                                    TextTable textTable = new TextTable();
                                    textTable.AddColumn("Name");
                                    textTable.AddColumn("UserID");
                                    if (hasClans) textTable.AddColumn("Clan");
                                    textTable.AddColumn("Status");

                                    foreach (ulong userID in codeLock.whitelistPlayers.ToList())
                                    {
                                        IPlayer authedP = Instance.covalence.Players.FindPlayerById(userID.ToString());
                                        if (authedP == null) continue;
                                        if (hasClans)
                                        {
                                            string clanTag = (string)Instance.Clans?.Call("GetClanOf", Convert.ToUInt64(authedP.Id));
                                            if (string.IsNullOrEmpty(clanTag))
                                                clanTag = "-";

                                            textTable.AddRow(new string[] {
                                                authedP.Name,
                                                authedP.Id,
                                                clanTag,
                                                (authedP.IsConnected ? "<color=#008000>Online</color>": "<color=#ffffff>Offline</color>").ToString()
                                            });
                                        }
                                        else
                                        {
                                            textTable.AddRow(new string[] {
                                                authedP.Name,
                                                authedP.Id,
                                                (authedP.IsConnected ? "<color=#008000>Online</color>": "<color=#ffffff>Offline</color>").ToString()
                                            });
                                        }
                                    }

                                    sb.AppendLine(textTable.ToString());
                                }
                                else
                                {
                                    sb.AppendLine("Whitelisted: <color=#ffffff>None</color>");
                                }

                                if (codeLock.guestPlayers != null && codeLock.guestPlayers.Count > 0)
                                {
                                    sb.AppendLine("Guests:");
                                    TextTable textTable = new TextTable();
                                    textTable.AddColumn("Name");
                                    textTable.AddColumn("UserID");
                                    if (hasClans) textTable.AddColumn("Clan");
                                    textTable.AddColumn("Status");
                                    foreach (ulong userID in codeLock.guestPlayers.ToList())
                                    {
                                        IPlayer authedP = Instance.covalence.Players.FindPlayerById(userID.ToString());
                                        if (authedP == null) continue;
                                        if (hasClans)
                                        {
                                            string clanTag = (string)Instance.Clans?.Call("GetClanOf", Convert.ToUInt64(authedP.Id));
                                            if (clanTag.Length == 0) clanTag = "-";
                                            textTable.AddRow(new string[] {
                                                authedP.Name,
                                                authedP.Id,
                                                clanTag,
                                                (authedP.IsConnected ? "<color=#008000>Online</color>": "<color=#ffffff>Offline</color>").ToString()
                                            });
                                        }
                                        else
                                        {
                                            textTable.AddRow(new string[] {
                                                authedP.Name,
                                                authedP.Id,
                                                (authedP.IsConnected ? "<color=#008000>Online</color>": "<color=#ffffff>Offline</color>").ToString()
                                            });
                                        }
                                    }

                                    sb.AppendLine(textTable.ToString());
                                }
                                else
                                {
                                    sb.AppendLine("Guests: <color=#ffffff>None</color>");
                                }

                                player.ConsoleMessage(sb.ToString());
                                infoMsg += (infoMsg.Length > 0 ? "\n" : "") + $"<color=#ffa500>{(rayEntityName == " Tool Cupboard " ? " TC " : rayEntityName)}</color> (<color=#00ffff>{rayEntity.net.ID}</color>) CodeLock info sent to console";
                            }
                            if (infoMsg.Length > 0) player.ChatMessage(Instance.ChatMsg(infoMsg));
                        }
                    }
                }
                else if (sRmvr)
                {
                    if (serverInput.WasJustPressed(controlButtons[CmdType.RemoverRemove]))
                    {
                        if (!serverInput.IsDown(controlButtons[CmdType.RemoverHoldForAll])) DoRm();
                        else if (serverInput.IsDown(controlButtons[CmdType.RemoverHoldForAll])) DoRm(true);
                    }

                    rayEntity = null;
                    rayDefinition = null;
                }
            }

            private void FndTrrnPlcmnt(ref Construction.Target t, Construction c, float maxDistance, bool isQuarry = false)
            {
                int layer = 27328769;
                if (isQuarry) layer = 10551297;
                RaycastHit[] hits = Physics.RaycastAll(t.ray, maxDistance, layer);
                if (hits.Length > 1)
                {
                    GamePhysics.Sort(hits);
                    for (int i = 0; i < hits.Length; i++)
                        if (hits[i].collider.transform.root != t.entity.transform.root)
                        {
                            t.position = t.ray.origin + t.ray.direction * hits[i].distance;
                            t.normal = hits[i].normal;
                            t.rotation = Vector3.zero;
                            t.onTerrain = true;
                            t.valid = true;
                            if (!isQuarry) mvTrgtSnp = hits[i].GetEntity();
                            return;
                        }
                }

                t.position = t.ray.origin + t.ray.direction * maxDistance;
                t.normal = Vector3.up;
                t.rotation = Vector3.zero;
                t.onTerrain = true;
                t.valid = false;
                mvTrgtSnp = null;
            }

            public void SetBlockPrefab(uint p)
            {
                construction = PrefabAttribute.server.Find<Construction>(p);
                rttnOffst = Vector3.zero;
                lstPrfb = p;
                DoPlannerUpdate(PType.Mode, $"{construction.info.name.english} ({((BuildingGrade.Enum)dfltGrd).ToString()})");
                lastPlacement = null;
                lastSocketForce = true;
            }

            public void OnDestroy()
            {
                DoCrosshair(string.Empty, true);
                DoWarning(string.Empty, true);
                foreach (Item item in player.inventory.AllItems().Where(x => x.IsValid()).ToList())
                    if (item.skin == Convert.ToUInt64(Instance.playerTools[0][2]) || item.skin == Convert.ToUInt64(Instance.playerTools[1][2]) || item.skin == Convert.ToUInt64(Instance.playerTools[2][2]))
                    {
                        item.skin = 0uL;
                        item.GetHeldEntity().skinID = 0uL;
                        item.name = string.Empty;
                        item.MarkDirty();
                    }

                DestroyInfo();
                Destroy(this);
            }

            private void DoRm(bool remAl = false)
            {
                if (!rayEntity || rayEntity is BasePlayer && !(rayEntity is NPCPlayer) || !Instance.removeToolObjects && !rayDefinition) return;
                if (rayEntity.IsValid())
                {
                    if (rayEntity is BuildingBlock)
                    {
                        if (Instance.enableFullRemove && remAl)
                        {
                            CollRm(rayEntity);
                            return;
                        }
                        else
                        {
                            if (Instance.effectRemoveBlocksOn) Effect.server.Run(Instance.effectRemoveBlocks, rayEntity, 0u, Vector3.zero, Vector3.zero, null, false);
                            rayEntity.Kill(BaseNetworkable.DestroyMode.Gib);
                            rayEntity = null;
                            rayDefinition = null;
                            return;
                        }
                    }
                    else
                    {
                        if (rayEntity is OreResourceEntity)
                        {
                            (rayEntity as OreResourceEntity).CleanupBonus();
                        }
                        else if (rayEntity is BaseNpc || rayEntity is NPCPlayer || rayEntity is BradleyAPC || rayEntity is BaseHelicopter)
                        {
                            (rayEntity as BaseCombatEntity).DieInstantly();
                        }
                        else
                        {
                            if (!Instance.entRemoval.Contains(rayEntity.transform.root)) Instance.entRemoval.Add(rayEntity.transform.root);
                            rayEntity.Kill(BaseNetworkable.DestroyMode.Gib);
                        }

                        rayEntity = null;
                        rayDefinition = null;
                    }
                }
                else
                {
                    GameManager.Destroy(rayEntity.gameObject, 0f);
                    rayEntity = null;
                    rayDefinition = null;
                }
            }

            private void CollRm(BaseEntity srcntt)
            {
                BuildingBlock bldngBlck = srcntt.GetComponent<BuildingBlock>();
                if (bldngBlck)
                {
                    BuildingManager.Building building = BuildingManager.server.GetBuilding(bldngBlck.buildingID);
                    ServerMgr.Instance.StartCoroutine(DlyRm(building.buildingBlocks.ToList(), building.decayEntities.ToList(), building.buildingPrivileges.ToList()));
                }
            }

            private WaitForEndOfFrame wait = new WaitForEndOfFrame();

            private IEnumerator DlyRm(List<BuildingBlock> bLst, List<DecayEntity> dLst, List<BuildingPrivlidge> pLst)
            {
                BaseNetworkable.DestroyMode mode = Instance.showGibsOnRemove ? BaseNetworkable.DestroyMode.Gib : BaseNetworkable.DestroyMode.None;
                for (int i = 0; i < pLst.Count; i++)
                    if (!pLst[i].IsDestroyed)
                    {
                        if (pLst[i] == rayEntity)
                        {
                            rayEntity = null;
                            rayDefinition = null;
                        }

                        pLst[i].Kill(mode);
                        yield
                        return wait;
                    }

                for (int i = 0; i < dLst.Count; i++)
                    if (!dLst[i].IsDestroyed)
                    {
                        if (dLst[i] == rayEntity)
                        {
                            rayEntity = null;
                            rayDefinition = null;
                        }

                        dLst[i].Kill(mode);
                        yield
                        return wait;
                    }

                for (int i = 0; i < bLst.Count; i++)
                    if (!bLst[i].IsDestroyed)
                    {
                        if (bLst[i] == rayEntity)
                        {
                            rayEntity = null;
                            rayDefinition = null;
                        }

                        bLst[i].Kill(mode);
                        yield
                        return wait;
                    }

                yield
                break;
            }

            private void DoPlacement()
            {
                ChkQrr(construction);
                Deployable dplybl = plnnr.GetDeployable();
                GameObject gameObject = DoPlaG(target, construction);
                if (gameObject != null)
                {
                    Interface.CallHook(r("BaRagvglOhvyg"), new object[] {
                        plnnr,
                        gameObject
                    });
                    if (dplybl != null)
                    {
                        if (dplybl.placeEffect.isValid)
                        {
                            if (target.entity && target.socket) Effect.server.Run(dplybl.placeEffect.resourcePath, target.entity.transform.TransformPoint(target.socket.worldPosition), target.entity.transform.up, null, false);
                            else Effect.server.Run(dplybl.placeEffect.resourcePath, target.position, target.normal, null, false);
                        }

                        BaseEntity bsntt = gameObject.ToBaseEntity();
                        if (!(bsntt is MiningQuarry) && !(bsntt is Elevator) && !(target.entity is BuildingBlock) && target.entity != null)
                        {
                            bsntt.transform.position = target.entity.transform.worldToLocalMatrix.MultiplyPoint3x4(target.position);
                            bsntt.transform.rotation = Quaternion.Inverse(target.entity.transform.rotation) * bsntt.transform.rotation;
                            bsntt.SetParent(target.entity, 0u);
                        }

                        if (dplybl.wantsInstanceData && ctvtmLnk.instanceData != null) (bsntt as IInstanceDataReceiver).ReceiveInstanceData(ctvtmLnk.instanceData);
                        if (dplybl.copyInventoryFromItem)
                        {
                            StorageContainer component2 = bsntt.GetComponent<StorageContainer>();
                            if (component2)
                            {
                                component2.ReceiveInventoryFromItem(ctvtmLnk);
                                ctvtmLnk.OnVirginSpawn();
                                ctvtmLnk.MarkDirty();
                            }
                        }
                        if (bsntt is SleepingBag)
                            (bsntt as SleepingBag).deployerUserID = player.userID;
                                                
                        bsntt.OnDeployed(bsntt.GetParentEntity(), player, plnnr.GetItem());

                        if (Instance.setDeployableOwner)
                            bsntt.OwnerID = player.userID;
                    }
                }
            }

            private void CheckPlacement(ref Construction.Target t, Construction c)
            {
                t.valid = false;
                if (c.socketHandle != null)
                {
                    Vector3 worldPosition = c.socketHandle.worldPosition;
                    Vector3 a = t.ray.origin + t.ray.direction * c.maxplaceDistance;
                    Vector3 a2 = a - worldPosition;
                    Vector3 oldDir = t.ray.direction;
                    t.ray.direction = (a2 - t.ray.origin).normalized;
                }

                List<BaseEntity> list = Pool.GetList<BaseEntity>();
                float num = 3.40282347E+38f;
                Vis.Entities<BaseEntity>(t.ray.origin, c.maxplaceDistance * 2f, list, 18874625, QueryTriggerInteraction.Collide);
                foreach (BaseEntity current in list)
                {
                    Construction con = PrefabAttribute.server.Find<Construction>(current.prefabID);
                    if (!(con == null))
                    {
                        Socket_Base[] allSockets = con.allSockets;
                        for (int i = 0; i < allSockets.Length; i++)
                        {
                            Socket_Base socket_Base = allSockets[i];
                            if (socket_Base.female && !socket_Base.femaleDummy)
                            {
                                RaycastHit raycastHit;
                                if (socket_Base.GetSelectBounds(current.transform.position, current.transform.rotation).Trace(t.ray, out raycastHit, float.PositiveInfinity)) if (raycastHit.distance >= 1f) if (raycastHit.distance <= num) if (!current.IsOccupied(socket_Base))
                                            {
                                                Construction.Target trgt2 =
                                            default(Construction.Target);
                                                trgt2.socket = socket_Base;
                                                trgt2.entity = current;
                                                trgt2.ray = t.ray;
                                                trgt2.valid = true;
                                                trgt2.player = player;
                                                trgt2.rotation = rttnOffst;
                                                if (c.HasMaleSockets(trgt2))
                                                {
                                                    t = trgt2;
                                                    num = raycastHit.distance;
                                                }
                                            }
                            }
                        }
                    }
                }

                if (t.valid)
                {
                    Pool.FreeList<BaseEntity>(ref list);
                    return;
                }

                if (c.deployable == null && list.Count > 0)
                {
                    list.Clear();
                    Vis.Entities<BaseEntity>(t.ray.origin, 3f, list, 2097152, QueryTriggerInteraction.Ignore);
                    if (list.Count > 0)
                    {
                        Pool.FreeList<BaseEntity>(ref list);
                        return;
                    }
                }

                if (GamePhysics.Trace(t.ray, 0f, out rayHit, c.maxplaceDistance, 27328769, QueryTriggerInteraction.Ignore))
                {
                    t.position = t.ray.origin + t.ray.direction * rayHit.distance;
                    t.rotation = rttnOffst;
                    t.normal = rayHit.normal;
                    t.onTerrain = true;
                    t.valid = true;
                    t.entity = rayHit.GetEntity();
                }
                else
                {
                    t.position = t.ray.origin + t.ray.direction * c.maxplaceDistance;
                    t.rotation = rttnOffst;
                    t.normal = Vector3.up;
                    if (c.hierachyName.Contains(r("sbhaqngvba")))
                    {
                        t.valid = true;
                        t.onTerrain = true;
                    }
                    else
                    {
                        t.valid = false;
                        t.onTerrain = false;
                    }
                }

                Pool.FreeList<BaseEntity>(ref list);
            }

            private void ChkQrr(Construction c)
            {
                if (StringPool.Get(672916883).Equals(c.fullName))
                {
                    BaseEntity crt = GameManager.server.CreateEntity(StringPool.Get(2955484243), Vector3.zero, Quaternion.identity, true);
                    crt.transform.position = rayHit.point;
                    crt.Spawn();
                    CheckPlacement(ref target, construction);
                }

                if (StringPool.Get(1599225199).Equals(c.fullName))
                {
                    BaseEntity crt = GameManager.server.CreateEntity(StringPool.Get(1917257452), Vector3.zero, Quaternion.identity, true);
                    crt.transform.position = rayHit.point;
                    crt.Spawn();
                    CheckPlacement(ref target, construction);
                }
            }

            public GameObject DoPlaG(Construction.Target p, Construction component)
            {
                BaseEntity bsntt = CrtCnstrctn(p, component);
                if (!bsntt)
                {
                    return null;
                }
                float num = 1f;
                bsntt.skinID = ctvtmLnk.skin;
                bsntt.gameObject.AwakeFromInstantiate();
                BuildingBlock bBl = bsntt as BuildingBlock;
                if (bBl)
                {
                    bBl.blockDefinition = PrefabAttribute.server.Find<Construction>(bBl.prefabID);
                    if (!bBl.blockDefinition) return null;
                    bBl.SetGrade((BuildingGrade.Enum)dfltGrd);
                    float num2 = bBl.currentGrade.maxHealth;
                }

                BaseCombatEntity bsCmbtntt = bsntt as BaseCombatEntity;
                if (bsCmbtntt)
                {
                    float num2 = !(bBl != null) ? bsCmbtntt.startHealth : bBl.currentGrade.maxHealth;
                    bsCmbtntt.ResetLifeStateOnSpawn = false;
                    bsCmbtntt.InitializeHealth(num2 * num, num2);
                }

                bsntt.OwnerID = player.userID;

                StabilityEntity stabilityEntity = bsntt as StabilityEntity;
                bool setGrounded = false;
                if (stabilityEntity && Instance.overrideStabilityBuilding)
                {
                    stabilityEntity.grounded = true;
                    setGrounded = true;
                }

                if (Instance.disableGroundMissingChecks && !bBl)
                {
                    Destroy(bsntt.GetComponent<DestroyOnGroundMissing>());
                    Destroy(bsntt.GetComponent<GroundWatch>());
                }

                bsntt.Spawn();
                if (bBl && Instance.effectPlacingBlocksOn) Effect.server.Run(Instance.effectPlacingBlocks, bsntt, 0u, Vector3.zero, Vector3.zero);
                if (stabilityEntity && !setGrounded) stabilityEntity.UpdateSurroundingEntities();
                return bsntt.gameObject;
            }

            private BaseEntity CrtCnstrctn(Construction.Target target, Construction component)
            {
                string path = component.fullName;
                if (component.fullName.Equals(StringPool.Get(672916883))) path = StringPool.Get(3424003500);
                if (component.fullName.Equals(StringPool.Get(1599225199))) path = StringPool.Get(3449840583);
                GameObject gameObject = GameManager.server.CreatePrefab(path, Vector3.zero, Quaternion.identity, false);
                bool flag = UpdtPlcmnt(gameObject.transform, component, ref target);
                BaseEntity bsntt = gameObject.ToBaseEntity();

                Elevator elevator = bsntt as Elevator;
                if (elevator && rayEntity is Elevator)
                {
                    List<EntityLink> list = rayEntity.FindLink("elevator/sockets/elevator-female")?.connections;
                    if (list.Count > 0 && (list[0].owner as Elevator) != null)
                    {
                        player.ChatMessage("You can only stack elevators on the top level");
                        return null;
                    }

                    elevator.transform.position = rayEntity.transform.position + (Vector3.up * 3f);
                    elevator.transform.rotation = rayEntity.transform.rotation;

                    elevator.GetEntityLinks(true);
                    flag = true;
                }

                if (!flag)
                {
                    if (bsntt.IsValid()) bsntt.Kill(BaseNetworkable.DestroyMode.None);
                    else GameManager.Destroy(gameObject, 0f);
                    return null;
                }

                DecayEntity dcyEntt = bsntt as DecayEntity;
                if (dcyEntt) dcyEntt.AttachToBuilding(target.entity as DecayEntity);
                return bsntt;
            }

            private Construction.Placement CheckPlacement(Construction.Target t, Construction c)
            {
                List<Socket_Base> list = Pool.GetList<Socket_Base>();
                Construction.Placement plcmnt = null;
                if (c.allSockets == null || c.allSockets.Length == 0) return plcmnt;
                c.FindMaleSockets(t, list);
                foreach (Socket_Base current in list)
                    if (!(t.entity != null) || !(t.socket != null) || !t.entity.IsOccupied(t.socket)) plcmnt = current.DoPlacement(t);
                Pool.FreeList<Socket_Base>(ref list);
                return plcmnt;
            }

            private bool UpdtPlcmnt(Transform tn, Construction common, ref Construction.Target target)
            {
                if (!target.valid) return false;
                List<Socket_Base> list = Pool.GetList<Socket_Base>();
                common.canBypassBuildingPermission = true;
                common.FindMaleSockets(target, list);
                Construction.lastPlacementError = string.Empty;
                Regex _errOrr = new Regex(@"Not enough space|not in terrain|AngleCheck|Sphere Test|IsInArea|cupboard", RegexOptions.Compiled);
                foreach (Socket_Base current in list)
                {
                    Construction.Placement plcmnt = null;
                    if (!(target.entity != null) || !(target.socket != null) || !target.entity.IsOccupied(target.socket))
                    {
                        if (plcmnt == null) plcmnt = current.DoPlacement(target);
                        if (plcmnt != null)
                        {
                            DeployVolume[] volumes = PrefabAttribute.server.FindAll<DeployVolume>(common.prefabID);
                            if (DeployVolume.Check(plcmnt.position, plcmnt.rotation, volumes, -1)) if (StringPool.Get(672916883).Contains(common.fullName) || StringPool.Get(1599225199).Contains(common.fullName))
                                {
                                    tn.position = plcmnt.position;
                                    tn.rotation = plcmnt.rotation;
                                    Pool.FreeList<Socket_Base>(ref list);
                                    return true;
                                }

                            if (BuildingProximity.Check(target.player, common, plcmnt.position, plcmnt.rotation))
                            {
                                tn.position = plcmnt.position;
                                tn.rotation = plcmnt.rotation;
                            }
                            else if (common.isBuildingPrivilege && !target.player.CanPlaceBuildingPrivilege(plcmnt.position, plcmnt.rotation, common.bounds))
                            {
                                tn.position = plcmnt.position;
                                tn.rotation = plcmnt.rotation;
                            }
                            else
                            {
                                tn.position = plcmnt.position;
                                tn.rotation = plcmnt.rotation;
                                Pool.FreeList<Socket_Base>(ref list);
                                return true;
                            }
                        }
                    }
                }

                Pool.FreeList<Socket_Base>(ref list);
                if (_errOrr.IsMatch(Construction.lastPlacementError)) return true;
                return false;
            }

            public void SendEffectTo(uint id, BaseEntity ent, BasePlayer player)
            {
                Effect effect = new Effect();
                effect.Init(Effect.Type.Generic, ent.transform.position, player.transform.forward, null);
                effect.pooledString = StringPool.Get(id);
                EffectNetwork.Send(effect, player.net.connection);
            }

            private void DestroyInfo(UType uType = UType.All)
            {
                CuiHelper.DestroyUi(player, r("HgPebffUnveHV"));
                if (uType == UType.All)
                {
                    CuiHelper.DestroyUi(player, UType.PlannerUi.ToString());
                    CuiHelper.DestroyUi(player, UType.RemoverUi.ToString());
                    CuiHelper.DestroyUi(player, UType.HammerUi.ToString());
                    plannerInfoStatus = false;
                    removerInfoStatus = false;
                    hammerInfoStatus = false;
                }
                else
                {
                    CuiHelper.DestroyUi(player, uType.ToString());
                    switch (uType)
                    {
                        case UType.PlannerUi:
                            plannerInfoStatus = false;
                            break;
                        case UType.RemoverUi:
                            removerInfoStatus = false;
                            break;
                        case UType.HammerUi:
                            hammerInfoStatus = false;
                            break;
                        default:
                            break;
                    }
                }
            }

            private void DoPlannerInfo()
            {
                if (!Instance.showPlannerInfo) return;
                string panelName = UType.PlannerUi.ToString();
                DestroyInfo(UType.PlannerUi);
                CuiElementContainer mainContainer = new CuiElementContainer() {
                    {
                        new CuiPanel {
                            Image = {
                                Color = "0 0 0 0"
                            },
                            RectTransform = {
                                AnchorMin = $"{panelPosX.ToString()} {panelPosY.ToString()}",
                                AnchorMax = $"{(panelPosX + 0.3f).ToString()} {(panelPosY + 0.15f).ToString()}"
                            }
                        },
                        new CuiElement().Parent = "Under",
                        panelName
                    }
                };
                CuiHelper.AddUi(player, mainContainer);
                plannerInfoStatus = true;
                DoPlannerUpdate(PType.Mode);
                DoPlannerUpdate(PType.ToSocket);
                DoPlannerUpdate(PType.PosRot);
                DoPlannerUpdate(PType.ConnectTo);
            }

            private void DoPlannerUpdate(PType pType, string infoMsg = " - ")
            {
                if (!isPlanner) return;
                if (!plannerInfoStatus) DoPlannerInfo();
                int maxRows = Enum.GetValues(typeof(PType)).Length;
                int rowNumber = (int)pType;
                string fieldName = pType.ToString();
                if (rowNumber == 0)
                {
                    if (sTpDplybl) fieldName = "Place";
                    else fieldName = "Build";
                }

                string mainPanel = UType.PlannerUi.ToString() + fieldName;
                CuiHelper.DestroyUi(player, mainPanel);
                float value = 1 / (float)maxRows;
                float positionMin = 1 - value * rowNumber;
                float positionMax = 2 - (1 - value * (1 - rowNumber));
                CuiElementContainer container = new CuiElementContainer() {
                    {
                        new CuiPanel {
                            Image = {
                                Color = "0 0 0 0"
                            },
                            RectTransform = {
                                AnchorMin = "0 " + positionMin.ToString("0.####"),
                                AnchorMax = $"1 " + positionMax.ToString("0.####")
                            },
                        },
                        new CuiElement().Parent = UType.PlannerUi.ToString(),
                        mainPanel
                    }
                };
                CuiElement innerLine = new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = mainPanel,
                    Components = {
                        new CuiRawImageComponent {
                            Color = "0 0 0 1",
                            Sprite = r("nffrgf/pbagrag/hv/qrirybcre/qrirybczragfxva/qrigno-abezny.cat"),
                            Material = r("nffrgf/pbagrag/zngrevnyf/vgrzzngrevny.zng")
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0 0",
                            AnchorMax = "0.9 0.9"
                        }
                    }
                };
                container.Add(innerLine);
                CuiElement innerLineText1 = new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = innerLine.Name,
                    Components = {
                        new CuiTextComponent {
                            Color = cuiFontColor,
                            Text = infoMsg,
                            Font = fontType,
                            FontSize = cuiFontSize,
                            Align = TextAnchor.MiddleLeft
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0.25 0.1",
                            AnchorMax = "1 1"
                        }
                    }
                };
                container.Add(innerLineText1);
                CuiElement innerLineText2 = new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = innerLine.Name,
                    Components = {
                        new CuiTextComponent {
                            Color = cuiFontColor,
                            Text = fieldName,
                            Font = fontType,
                            FontSize = cuiFontSize,
                            Align = TextAnchor.MiddleLeft
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0.025 0.1",
                            AnchorMax = "0.3 1"
                        }
                    }
                };
                container.Add(innerLineText2);
                CuiHelper.AddUi(player, container);
            }

            private void DoRemoverInfo()
            {
                if (!Instance.showRemoverInfo) return;
                string panelName = UType.RemoverUi.ToString();
                DestroyInfo(UType.RemoverUi);
                CuiElementContainer mainContainer = new CuiElementContainer() {
                    {
                        new CuiPanel {
                            Image = {
                                Color = "0 0 0 0"
                            },
                            RectTransform = {
                                AnchorMin = $"{panelPosX.ToString()} {panelPosY.ToString()}",
                                AnchorMax = $"{(panelPosX + 0.3f).ToString()} {(panelPosY + 0.115f).ToString()}"
                            }
                        },
                        new CuiElement().Parent = "Under",
                        panelName
                    }
                };
                CuiHelper.AddUi(player, mainContainer);
                removerInfoStatus = true;
                DoRemoverUpdate(RType.Remove);
                DoRemoverUpdate(RType.Mode, "Single");
                DoRemoverUpdate(RType.Owner);
            }

            private void DoRemoverUpdate(RType rType, string infoMsg = " - ", bool altMode = false)
            {
                if (!sRmvr) return;
                if (!removerInfoStatus) DoRemoverInfo();
                int maxRows = Enum.GetValues(typeof(RType)).Length;
                int rowNumber = (int)rType;
                string fieldName = rType.ToString();
                string mainPanel = UType.RemoverUi.ToString() + fieldName;
                if (infoMsg.Contains("Building")) fieldName = "<color=#ff0000>Mode</color>";
                CuiHelper.DestroyUi(player, mainPanel);
                float value = 1 / (float)maxRows;
                float positionMin = 1 - value * rowNumber;
                float positionMax = 2 - (1 - value * (1 - rowNumber));
                CuiElementContainer container = new CuiElementContainer() {
                    {
                        new CuiPanel {
                            Image = {
                                Color = "0 0 0 0"
                            },
                            RectTransform = {
                                AnchorMin = "0 " + positionMin.ToString("0.####"),
                                AnchorMax = $"1 " + positionMax.ToString("0.####")
                            },
                        },
                        new CuiElement().Parent = UType.RemoverUi.ToString(),
                        mainPanel
                    }
                };
                CuiElement innerLine = new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = mainPanel,
                    Components = {
                        new CuiRawImageComponent {
                            Color = "0 0 0 1",
                            Sprite = r("nffrgf/pbagrag/hv/qrirybcre/qrirybczragfxva/qrigno-abezny.cat"),
                            Material = r("nffrgf/pbagrag/zngrevnyf/vgrzzngrevny.zng")
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0 0",
                            AnchorMax = "0.9 0.9"
                        }
                    }
                };
                container.Add(innerLine);
                CuiElement innerLineText1 = new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = innerLine.Name,
                    Components = {
                        new CuiTextComponent {
                            Color = cuiFontColor,
                            Text = infoMsg,
                            Font = fontType,
                            FontSize = cuiFontSize,
                            Align = TextAnchor.MiddleLeft
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0.25 0.1",
                            AnchorMax = "1 1"
                        }
                    }
                };
                container.Add(innerLineText1);
                CuiElement innerLineText2 = new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = innerLine.Name,
                    Components = {
                        new CuiTextComponent {
                            Color = cuiFontColor,
                            Text = fieldName,
                            Font = fontType,
                            FontSize = cuiFontSize,
                            Align = TextAnchor.MiddleLeft
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0.025 0.1",
                            AnchorMax = "0.3 1"
                        }
                    }
                };
                container.Add(innerLineText2);
                CuiHelper.AddUi(player, container);
            }

            private void DoHammerInfo()
            {
                if (!Instance.showHammerInfo) return;
                string panelName = UType.HammerUi.ToString();
                DestroyInfo(UType.HammerUi);
                CuiElementContainer mainContainer = new CuiElementContainer() {
                    {
                        new CuiPanel {
                            Image = {
                                Color = "0 0 0 0"
                            },
                            RectTransform = {
                                AnchorMin = $"{panelPosX.ToString()} {panelPosY.ToString()}",
                                AnchorMax = $"{(panelPosX + 0.3f).ToString()} {(panelPosY + 0.19f).ToString()}"
                            }
                        },
                        new CuiElement().Parent = "Under",
                        panelName
                    }
                };
                CuiHelper.AddUi(player, mainContainer);
                hammerInfoStatus = true;
                DoHammerUpdate(HType.Target);
                DoHammerUpdate(HType.Building);
                DoHammerUpdate(HType.Mode);
                DoHammerUpdate(HType.PosRot);
                DoHammerUpdate(HType.Owner);
                DoHammerUpdate(HType.SteamID);
            }

            private void DoHammerUpdate(HType hType, string infoMsg = " - ")
            {
                if (!isHammering) return;
                if (!hammerInfoStatus) DoHammerInfo();
                int maxRows = Enum.GetValues(typeof(HType)).Length;
                int rowNumber = (int)hType;
                string fieldName = hType.ToString();
                string mainPanel = UType.HammerUi.ToString() + fieldName;
                CuiHelper.DestroyUi(player, mainPanel);
                float value = 1 / (float)maxRows;
                float positionMin = 1 - value * rowNumber;
                float positionMax = 2 - (1 - value * (1 - rowNumber));
                CuiElementContainer container = new CuiElementContainer() {
                    {
                        new CuiPanel {
                            Image = {
                                Color = "0 0 0 0"
                            },
                            RectTransform = {
                                AnchorMin = "0 " + positionMin.ToString("0.####"),
                                AnchorMax = $"1 " + positionMax.ToString("0.####")
                            },
                        },
                        new CuiElement().Parent = UType.HammerUi.ToString(),
                        mainPanel
                    }
                };
                CuiElement innerLine = new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = mainPanel,
                    Components = {
                        new CuiRawImageComponent {
                            Color = "0 0 0 1",
                            Sprite = r("nffrgf/pbagrag/hv/qrirybcre/qrirybczragfxva/qrigno-abezny.cat"),
                            Material = r("nffrgf/pbagrag/zngrevnyf/vgrzzngrevny.zng")
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0 0",
                            AnchorMax = "0.9 0.9"
                        }
                    }
                };
                container.Add(innerLine);
                CuiElement innerLineText1 = new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = innerLine.Name,
                    Components = {
                        new CuiTextComponent {
                            Color = cuiFontColor,
                            Text = infoMsg,
                            Font = fontType,
                            FontSize = cuiFontSize,
                            Align = TextAnchor.MiddleLeft
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0.25 0.1",
                            AnchorMax = "1 1"
                        }
                    }
                };
                container.Add(innerLineText1);
                CuiElement innerLineText2 = new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = innerLine.Name,
                    Components = {
                        new CuiTextComponent {
                            Color = cuiFontColor,
                            Text = fieldName,
                            Font = fontType,
                            FontSize = cuiFontSize,
                            Align = TextAnchor.MiddleLeft
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0.025 0.1",
                            AnchorMax = "0.3 1"
                        }
                    }
                };
                container.Add(innerLineText2);
                CuiHelper.AddUi(player, container);
            }

            private void BldMnUI(float factor)
            {
                CuiElementContainer element = new CuiElementContainer();
                string color = "0 0 0 0";
                string mainName = element.Add(
                new CuiPanel
                {
                    Image = {
                        Color = "0 0 0 0"
                    },
                    RectTransform = {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    },
                    CursorEnabled = true
                },
                "Overlay", r("OhvyqZrahHV"));
                element.Add(
                new CuiButton
                {
                    Button = {
                        Close = mainName,
                        Color = color
                    },
                    RectTransform = {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    },
                    Text = {
                        Text = string.Empty
                    }
                },
                mainName);
                Vector2 mC = new Vector2(0.5f, 0.5f);
                Vector2 mS = new Vector2(0.3425f, 0.475f);

                for (int i = 0; i < 20; i++)
                {
                    float scaled = 1f;
                    if ((i > 0 && i < 6) || (i > 8 && i < 11) || (i > 12 && i < 15))
                        scaled = 0.75f;

                    Vector2 center = RotateByRadians(mC, mS, index2Degrees[i] * Mathf.Deg2Rad, factor);
                    element.Add(BuildIconUI(mainName, center, r("nffrgf/vpbaf/pvepyr_tenqvrag.cat"), -0.040f * scaled, 0.040f * scaled, "1 1 1 1", factor, false));
                    element.Add(BuildIconUI(mainName, center, r("nffrgf/vpbaf/pvepyr_tenqvrag.cat"), -0.040f * scaled, 0.040f * scaled, "1 1 1 1", factor, false));
                    element.Add(BuildRawIconUI(mainName, center, Instance.prefabIdToImage[Instance.constructionIds[i]], -0.02f * scaled, 0.02f * scaled, "0.2 0.5 0.8 0.5", factor, true));
                    element.Add(BuildButtonUI(mainName, Vector2.MoveTowards(center, mC, 0.06f), i, -0.020f * scaled, 0.020f * scaled, color, factor), mainName);
                    element.Add(BuildButtonUI(mainName, Vector2.MoveTowards(center, mC, 0.03f), i, -0.025f * scaled, 0.025f * scaled, color, factor), mainName);
                    element.Add(BuildButtonUI(mainName, center, i, -0.030f * scaled, 0.030f * scaled, color, factor), mainName);
                    element.Add(BuildButtonUI(mainName, Vector2.MoveTowards(center, mC, -0.02f), i, -0.035f * scaled, 0.035f * scaled, color, factor), mainName);
                }

                element.Add(CustomIconUI(mainName, new Vector2(0.85f, 0.5f), r("nffrgf/vpbaf/rkvg.cat"), -0.025f, 0.025f, "1 1 1 1", factor));
                element.Add(CustomButtonUI(mainName, new Vector2(0.85f, 0.5f), "ut.prefab 6666", -0.025f, 0.025f, color, factor), mainName);
                CuiHelper.AddUi(player, element);
            }

            private float[] index2Degrees = new float[]
            {
                0f,
                19.2235f,
                32.06471f,
                45.24706f,
                59.02941f,
                72.00588f,
                85.00588f,
                103.4823f,
                126.0588f,
                143.9412f,
                158.8235f,
                177f,
                199.9765f,
                216.0588f,
                230.9412f,
                250.1176f,
                271.2941f,
                293.4706f,
                315.6471f,
                338.8235f,
            };

            private void DoCrosshair(string cColor = default(string), bool kill = false)
            {
                if (lstCrsshr == cColor && !kill) return;
                if (kill || cColor == string.Empty)
                {
                    lstCrsshr = string.Empty;
                    CuiHelper.DestroyUi(player, r("HgPebffUnveHV"));
                    return;
                }

                lstCrsshr = cColor;
                CuiElementContainer element = new CuiElementContainer();
                string mainName = element.Add(
                new CuiPanel
                {
                    Image = {
                        Color = "0 0 0 0"
                    },
                    RectTransform = {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                },
                "Under", r("HgPebffUnveHV"));
                element.Add(CustomIconUI(mainName, new Vector2(0.499f, 0.499f), r("nffrgf/vpbaf/gnetrg.cat"), -0.005f, 0.005f, cColor, Instance.playerPrefs.playerData[player.userID].SF));
                CuiHelper.DestroyUi(player, mainName);
                CuiHelper.AddUi(player, element);
            }

            private void DoWarning(string cColor = default(string), bool kill = false)
            {
                if (lstWrnng == cColor && !kill) return;
                if (kill || cColor == string.Empty)
                {
                    lstWrnng = string.Empty;
                    CuiHelper.DestroyUi(player, r("HgJneavatHV"));
                    return;
                }

                lstWrnng = cColor;
                CuiElementContainer element = new CuiElementContainer();
                string mainName = element.Add(
                new CuiPanel
                {
                    Image = {
                        Color = "0 0 0 0"
                    },
                    RectTransform = {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                },
                "Under", r("HgJneavatHV"));
                element.Add(CustomIconUI(mainName, new Vector2(0.499f, 0.35f), r("nffrgf/vpbaf/jneavat_2.cat"), -0.05f, 0.05f, cColor, Instance.playerPrefs.playerData[player.userID].SF));
                CuiHelper.DestroyUi(player, mainName);
                CuiHelper.AddUi(player, element);
            }
        }

        private enum PType
        {
            Mode = 0,
            ToSocket = 1,
            PosRot = 2,
            ConnectTo = 3
        }

        private enum RType
        {
            Remove = 0,
            Mode = 1,
            Owner = 2
        }

        private enum HType
        {
            Target = 0,
            Building = 1,
            Mode = 2,
            PosRot = 3,
            Owner = 4,
            SteamID = 5,
        }

        private enum UType
        {
            PlannerUi = 0,
            RemoverUi = 1,
            HammerUi = 2,
            All = 3
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            Dictionary<string,
            object> data = Config[menu] as Dictionary<string,
            object>;
            if (data == null)
            {
                data = new Dictionary<string,
                object>();
                Config[menu] = data;
                Changed = true;
            }

            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }

            return value;
        }

        private bool Changed = false;
        private static UberTool Instance;

        private string[] iconFileNames = new string[]
        {
            "wall.low",
            "block.stair.ushape",
            "block.stair.lshape",
            "block.stair.spiral",
            "block.stair.spiral.triangle",
            "roof.triangle",
            "roof",
            "foundation",
            "foundation.triangle",
            "foundation.steps",
            "ramp",
            "floor",
            "floor.triangle",
            "floor.frame",
            "floor.triangle.frame",
            "wall",
            "wall.doorway",
            "wall.window",
            "wall.frame",
            "wall.half"
        };

        private List<uint> constructionIds = new List<uint>();


        private Dictionary<uint, string> prefabIdToImage = new Dictionary<uint, string>();

        private Dictionary<ulong, bool> ctvUbrTls;
        private Dictionary<ulong, EPlanner> activeUberObjects;
        private List<Transform> entRemoval = new List<Transform>();
        private string varChatToggle;
        private string varCmdToggle;
        private string varChatScale;
        private string varCmdScale;
        private string pluginPrefix;
        private string prefixColor;
        private string prefixFormat;
        private string colorTextMsg;
        private float scaleFactorDef;
        private bool hideTips;
        private bool showPlannerInfo;
        private bool showRemoverInfo;
        private bool showHammerInfo;
        private static float panelPosX;
        private static float panelPosY;
        private string effectRemoveBlocks;
        private bool effectRemoveBlocksOn;
        private string effectPlacingBlocks;
        private bool effectPlacingBlocksOn;
        private bool effectFoundationPlacement;
        private bool effectPromotingBlock;
        private bool showGibsOnRemove;
        private float removeToolRange;
        private float hammerToolRange;
        private bool removeToolObjects;
        private bool enableFullRemove;
        private bool disableGroundMissingChecks;
        private bool overrideStabilityBuilding;
        private bool disableStabilityStartup;
        private bool enablePerimeterRepair;
        private float perimeterRepairRange;
        private bool checkExistingPlanner;
        private bool checkExistingRemover;
        private bool checkExistingHammer;
        private bool enableHammerTCInfo;
        private bool enableHammerCodelockInfo;
        private List<object> pseudoAdminPerms = new List<object>();
        private List<string> psdPrms = new List<string>();
        private string pluginUsagePerm;
        private bool enableIsAdminCheck;
        private bool setDeployableOwner;

        private List<object[]> playerTools = new List<object[]> {
            {
                new object[] {
                    "UberTool",
                    "building.planner",
                    1195976254u
                }
            },
            {
                new object[] {
                    "UberRemove",
                    "pistol.semiauto",
                    1196004864u
                }
            },
            {
                new object[] {
                    "UberHammer",
                    "hammer",
                    1196009619u
                }
            },
        };

        private void LoadVariables()
        {
            bool configRemoval = false;
            setDeployableOwner = Convert.ToBoolean(GetConfig("Deployables", "Set player as deployable owner on placement", true));

            varChatToggle = Convert.ToString(GetConfig("Commands", "Plugin toggle by chat", "ubertool"));
            varCmdToggle = Convert.ToString(GetConfig("Commands", "Plugin toggle by console", "ut.toggle"));
            varChatScale = Convert.ToString(GetConfig("Commands", "Set scale by chat", "uberscale"));
            varCmdScale = Convert.ToString(GetConfig("Commands", "Set scale by console", "ut.scale"));
            enableIsAdminCheck = Convert.ToBoolean(GetConfig("Permission", "Grant usage right by IsAdmin check", true));
            pseudoAdminPerms = (List<object>)GetConfig("Permission", "PseudoAdmin permissions", new List<object> {
                "fauxadmin.allowed",
                "fakeadmin.allow"
            });
            pluginUsagePerm = Convert.ToString(GetConfig("Permission", "Plugin usage permission", "ubertool.canuse"));
            pluginPrefix = Convert.ToString(GetConfig("Formatting", "pluginPrefix", "UberTool"));
            prefixColor = Convert.ToString(GetConfig("Formatting", "prefixColor", "#468499"));
            prefixFormat = Convert.ToString(GetConfig("Formatting", "prefixFormat", "<color={0}>{1}</color>: "));
            colorTextMsg = Convert.ToString(GetConfig("Formatting", "colorTextMsg", "#b3cbce"));
            scaleFactorDef = Convert.ToSingle(GetConfig("Options", "Default scaling for matrix overlay (16:10)", 1.6f));
            hideTips = Convert.ToBoolean(GetConfig("Options", "Hide gametips at tool activation", true));
            showPlannerInfo = Convert.ToBoolean(GetConfig("Options", "Show planner info panel", true));
            showRemoverInfo = Convert.ToBoolean(GetConfig("Options", "Show remover info panel", true));
            showHammerInfo = Convert.ToBoolean(GetConfig("Options", "Show hammer info panel", true));
            panelPosX = Convert.ToSingle(GetConfig("Options", "info panel x coordinate", 0.6f));
            panelPosY = Convert.ToSingle(GetConfig("Options", "info panel y coordinate", 0.6f));
            showGibsOnRemove = Convert.ToBoolean(GetConfig("Effects", "Gibs on remove building", false));
            effectRemoveBlocks = Convert.ToString(GetConfig("Effects", "Effect on remove Blocks", StringPool.Get(2184296839)));
            effectRemoveBlocksOn = Convert.ToBoolean(GetConfig("Effects", "Effect on remove Blocks enabled", true));
            effectPlacingBlocks = Convert.ToString(GetConfig("Effects", "Effect on placing Blocks", StringPool.Get(172001365)));
            effectPlacingBlocksOn = Convert.ToBoolean(GetConfig("Effects", "Effect on placing Blocks enabled", true));
            effectFoundationPlacement = Convert.ToBoolean(GetConfig("Effects", "Click feedback at foundation placement", true));
            effectPromotingBlock = Convert.ToBoolean(GetConfig("Effects", "Effect on promoting Block enabled", true));
            removeToolRange = Convert.ToSingle(GetConfig("Tool", "Remover pistol range", 24f));
            hammerToolRange = Convert.ToSingle(GetConfig("Tool", "Hammer tool range", 24f));
            removeToolObjects = Convert.ToBoolean(GetConfig("Tool", "Remover pistol does shoot every object", false));
            enableFullRemove = Convert.ToBoolean(GetConfig("Tool", "Remover pistol can remove full buildings", true));
            disableGroundMissingChecks = Convert.ToBoolean(GetConfig("Tool", "Disable deployable ground-missing checks", true));
            overrideStabilityBuilding = Convert.ToBoolean(GetConfig("Tool", "Override stability while building", true));
            disableStabilityStartup = Convert.ToBoolean(GetConfig("Tool", "Temporary disable stability while startup", false));
            checkExistingPlanner = Convert.ToBoolean(GetConfig("Tool", "Check for existing Planner", true));
            checkExistingRemover = Convert.ToBoolean(GetConfig("Tool", "Check for existing Remover", true));
            checkExistingHammer = Convert.ToBoolean(GetConfig("Tool", "Check for existing Hammer", true));
            perimeterRepairRange = Convert.ToSingle(GetConfig("Tool", "Perimeter repair range", 3f));
            enablePerimeterRepair = Convert.ToBoolean(GetConfig("Tool", "Enable perimeter repair", true));
            enableHammerTCInfo = Convert.ToBoolean(GetConfig("Tool", "Enable Hammer TC info", true));
            enableHammerCodelockInfo = Convert.ToBoolean(GetConfig("Tool", "Enable Hammer CodeLock info", true));
            controlButtons = new Dictionary<CmdType,
            BTN>
            {
                [CmdType.HammerChangeGrade] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Hammer: change object grade", "FIRE_THIRD"))),
                [CmdType.HammerToggleOnOff] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Hammer: toggle object on/off/quarrytype", "FIRE_THIRD"))),
                [CmdType.HammerRotate] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Hammer: rotate object cw", "RELOAD"))),
                [CmdType.HammerRotateDirection] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Hammer: rotation direction ccw (hold)", "SPRINT"))),
                [CmdType.HammerTransform] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Hammer: object move/transform", "FIRE_SECONDARY"))),
                [CmdType.HammerAuthInfo] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Hammer: get object auth/lock info", "USE"))),
                [CmdType.PlannerPlace] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Planner: place object/block", "FIRE_PRIMARY"))),
                [CmdType.PlannerRotate] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Planner: rotate before placement", "RELOAD"))),
                [CmdType.PlannerTierChange] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Planner: change grade activator (hold)", "DUCK"))),
                [CmdType.PlannerTierNext] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Planner: choose higher grade", "LEFT"))),
                [CmdType.PlannerTierPrev] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Planner: choose lower grade", "RIGHT"))),
                [CmdType.RemoverRemove] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Remover: remove object/block", "FIRE_PRIMARY"))),
                [CmdType.RemoverHoldForAll] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Remover: remove all activator (hold)", "FIRE_SECONDARY")))
            };
            if ((Config.Get("Tool") as Dictionary<string, object>).ContainsKey("Enable Hammer TC info by leftclick"))
            {
                (Config.Get("Tool") as Dictionary<string, object>).Remove("Enable Hammer TC info by leftclick");
                configRemoval = true;
            }

            if ((Config.Get("Tool") as Dictionary<string, object>).ContainsKey("Enable Hammer CodeLock info by leftclick"))
            {
                (Config.Get("Tool") as Dictionary<string, object>).Remove("Enable Hammer CodeLock info by leftclick");
                configRemoval = true;
            }

            if ((Config.Get("Effects") as Dictionary<string, object>).ContainsKey("Audio feedbacks on foundations placements"))
            {
                (Config.Get("Effects") as Dictionary<string, object>).Remove("Audio feedbacks on foundations placements");
                configRemoval = true;
            }

            SaveConf();
            if (!Changed && !configRemoval) return;
            SaveConfig();
            Changed = false;
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(
            new Dictionary<string, string> {
                {
                    "Activated",
                    "Tool activated."
                },
                {
                    "Deactivated",
                    "Tool deactivated."
                },
                {
                    "ChangedGrade",
                    "Changed grade to <color=#32d38b>{0}</color>."
                },
                {
                    "SwitchedPlan",
                    "Switched plan to <color=#00c96f>{0}</color>."
                },
                {
                    "CurrentScale",
                    "Your current scale is <color=#00c96f>{0}</color>."
                },
                {
                    "NewScale",
                    "Your new scale is <color=#00c96f>{0}</color>."
                },
                {
                    "RepairedMulti",
                    "Repaired {0} damaged objects."
                },
            },
            this);
        }

        private void Loaded()
        {
            LoadVariables();
            LoadDefaultMessages();
            Instance = this;
            ctvUbrTls = new Dictionary<ulong,
            bool>();
            activeUberObjects = new Dictionary<ulong, EPlanner>();
            entRemoval = new List<Transform>();

            foreach (string pseudoPerm in pseudoAdminPerms.ConvertAll(obj => Convert.ToString(obj)).ToList())
            {
                if (permission.PermissionExists(pseudoPerm)) psdPrms.Add(pseudoPerm.ToLower());
            }

            if (!permission.PermissionExists(pluginUsagePerm)) permission.RegisterPermission(pluginUsagePerm, this);
        }

        private void Unload()
        {
            SaveData();
            List<EPlanner> objs = UnityEngine.Object.FindObjectsOfType<EPlanner>().ToList();
            if (objs.Count > 0)
            {
                for (int i = 0; i < objs.Count; i++)
                {
                    UnityEngine.Object.Destroy(objs[i]);
                }
            }
        }

        private const string IMAGE_URL = "http://www.rustedit.io/images/ubertool/{0}.png";

        private bool noImageLibrary = true;

        private void OnServerInitialized()
        {
            if (Instance.disableStabilityStartup && _disableStabilityStartup)
            {
                ConVar.Server.stability = true;
                Puts("Re-enabled server.stability");
            }

            Dictionary<string, Dictionary<ulong, string>> itemList = new Dictionary<string, Dictionary<ulong, string>>();

            for (int i = 0; i < iconFileNames.Length; i++)
            {
                string icon = iconFileNames[i];
                itemList.Add(icon, new Dictionary<ulong, string>
                {
                    [0] = string.Format(IMAGE_URL, icon)
                });
            }

            if (!ImageLibrary)
            {
                PrintError("UberTool requires ImageLibrary to display build menu icons! Please install ImageLibrary");
            }
            else ImageLibrary?.Call("ImportItemList", this.Title, itemList, false, new Action(GetIconIds));

            cmd.AddConsoleCommand(r("hg.cersno"), this, r("pzqCersno"));
            cmd.AddConsoleCommand(varCmdScale, this, r("pzqFpnyr"));
            cmd.AddConsoleCommand(varCmdToggle, this, r("pzqGbttyr"));
            cmd.AddChatCommand(varChatToggle, this, r("pungGbttyr"));
            cmd.AddChatCommand(varChatScale, this, r("pungFpnyr"));
            playerPrefs = Interface.GetMod().DataFileSystem.ReadObject<StrdDt>(Title);
            if (playerPrefs == null || playerPrefs.playerData == null) playerPrefs = new StrdDt();
            foreach (BasePlayer player in BasePlayer.activePlayerList.Where(p => HasPermission(p)).ToList())
            {
                Stsr(player);
                ctvUbrTls[player.userID] = false;
            }

            foreach (BasePlayer player in BasePlayer.sleepingPlayerList.Where(p => HasPermission(p)).ToList())
            {
                Stsr(player);
                ctvUbrTls[player.userID] = false;
            }

            UpdateHooks();

            Interface.Oxide.DataFileSystem.WriteObject(Title, playerPrefs);
        }

        private void UpdateHooks()
        {
            if (activeUberObjects.Count > 0)
            {
                Subscribe(nameof(CanBuild));
                Subscribe(nameof(OnItemDeployed));
                Subscribe(nameof(OnReloadMagazine));
                Subscribe(nameof(OnLoseCondition));
                Subscribe(nameof(OnPlayerTick));
                Subscribe(nameof(OnStructureRepair));
                Subscribe(nameof(OnServerCommand));
                Subscribe(nameof(OnMessagePlayer));
            }
            else
            {
                Unsubscribe(nameof(CanBuild));
                Unsubscribe(nameof(OnItemDeployed));
                Unsubscribe(nameof(OnReloadMagazine));
                Unsubscribe(nameof(OnLoseCondition));
                Unsubscribe(nameof(OnPlayerTick));
                Unsubscribe(nameof(OnStructureRepair));
                Unsubscribe(nameof(OnServerCommand));
                Unsubscribe(nameof(OnMessagePlayer));
            }
        }

        private void GetIconIds()
        {
            for (int i = 0; i < iconFileNames.Length; i++)
            {
                string shortname = iconFileNames[i];
                string prefabPath = string.Empty;
                foreach (string s in GameManifest.Current.entities)
                {
                    if (ToShortName(s).Equals(shortname))
                    {
                        prefabPath = s;
                        break;
                    }
                }

                if (string.IsNullOrEmpty(prefabPath))
                {
                    PrintError("Failed to find prefab ID for {shortname}");
                    continue;
                }
                constructionIds.Add(GameManager.server.FindPrefab(prefabPath).ToBaseEntity().prefabID);
                prefabIdToImage.Add(constructionIds[i], (string)ImageLibrary?.Call("GetImage", shortname));
            }

            PrintWarning("ImageLibrary has finished processing UberTool's required images. UberTool is now active");
            noImageLibrary = false;
        }

        private string ToShortName(string name)
        {
            return name.Split('/').Last().Replace(".prefab", "");
        }

        private enum CmdType
        {
            HammerChangeGrade,
            HammerToggleOnOff,
            HammerRotate,
            HammerRotateDirection,
            HammerTransform,
            HammerAuthInfo,
            PlannerPlace,
            PlannerRotate,
            PlannerTierChange,
            PlannerTierNext,
            PlannerTierPrev,
            RemoverRemove,
            RemoverHoldForAll
        }

        private static Dictionary<CmdType,
        BTN> controlButtons;

        private T ParseType<T>(string type)
        {
            T pT =
        default(T);
            try
            {
                pT = (T)Enum.Parse(typeof(T), type, true);
                return pT;
            }
            catch
            {
                return pT;
            }
        }

        private bool sPsdAdmn(string id)
        {
            foreach (string perm in psdPrms)
                if (permission.UserHasPermission(id, perm)) return true;
            return false;
        }

        private void OnUserPermissionGranted(string id, string perm)
        {
            if (psdPrms.Contains(perm.ToLower()) || perm.ToLower() == pluginUsagePerm.ToLower())
            {
                BasePlayer p = BasePlayer.Find(id);
                if (p)
                {
                    Stsr(p);
                    ctvUbrTls[p.userID] = false;
                }
            }
        }

        private void OnGroupPermissionGranted(string name, string perm)
        {
            if (psdPrms.Contains(perm.ToLower()) || perm.ToLower() == pluginUsagePerm.ToLower()) foreach (string id in permission.GetUsersInGroup(name).ToList())
                {
                    BasePlayer p = BasePlayer.Find(id.Substring(0, 17));
                    if (p)
                    {
                        Stsr(p);
                        ctvUbrTls[p.userID] = false;
                    }
                }
        }

        private void Stsr(BasePlayer player)
        {
            if (player == null) return;
            foreach (Item item in player.inventory.AllItems().Where(x => x.IsValid()).ToList())
                if (item.skin == Convert.ToUInt64(playerTools[0][2]) || item.skin == Convert.ToUInt64(playerTools[1][2]) || item.skin == Convert.ToUInt64(playerTools[2][2]))
                {
                    item.skin = 0uL;
                    item.GetHeldEntity().skinID = 0uL;
                    item.name = string.Empty;
                    item.MarkDirty();
                }

            Plyrnf p = null;
            if (!playerPrefs.playerData.TryGetValue(player.userID, out p))
            {
                Plyrnf info = new Plyrnf();
                info.SF = scaleFactorDef;
                info.DBG = 4;
                playerPrefs.playerData.Add(player.userID, info);
            }
        }

        private bool HasPermission(BasePlayer p)
        {
            return p.IsAdmin && enableIsAdminCheck || permission.UserHasPermission(p.UserIDString, pluginUsagePerm) || sPsdAdmn(p.UserIDString);
        }

        private void OnServerSave()
        {
            SaveData();
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Title, playerPrefs);
        }

        private bool _disableStabilityStartup = false;

        private void OnSaveLoad()
        {
            _disableStabilityStartup = false;
            if (Instance.disableStabilityStartup)
            {
                bool flag = ConVar.Server.stability;
                if (flag)
                {
                    _disableStabilityStartup = true;
                    ConVar.Server.stability = false;
                    Puts("Temp disabled server.stability");
                }
            }
        }

        private void OnPlayerConnected(BasePlayer p)
        {
            if (HasPermission(p))
            {
                Stsr(p);
                ctvUbrTls[p.userID] = false;
            }
        }

        private object CanBuild(Planner plan, Construction prefab, Construction.Target target)
        {
            if (plan != null)
            {
                BasePlayer p = plan?.GetOwnerPlayer();
                bool exists = false;
                if (p && ctvUbrTls.TryGetValue(p.userID, out exists) && exists) return false;
            }

            return null;
        }

        private void OnItemDeployed(Deployer d)
        {
            if (d != null)
            {
                BasePlayer p = d?.GetOwnerPlayer();
                bool exists = false;
                if (p && ctvUbrTls.TryGetValue(p.userID, out exists) && exists)
                {
                    Item i = d.GetItem();
                    i.amount++;
                }
            }
        }

        private object OnReloadMagazine(BasePlayer p, BaseProjectile bP)
        {
            bool exists = false;
            if (p && ctvUbrTls.TryGetValue(p.userID, out exists) && exists && bP.skinID == Convert.ToUInt64(playerTools[1][2])) return false;
            return null;
        }

        private void OnLoseCondition(Item item, float amount)
        {
            bool exists = false;
            if (item != null)
            {
                BasePlayer p = item.GetOwnerPlayer();
                if (p && ctvUbrTls.TryGetValue(p.userID, out exists) && exists) item.condition = item.maxCondition;
            }
        }

        private void OnPlayerTick(BasePlayer p, PlayerTick msg, bool wasPlayerStalled)
        {
            bool exists = false;
            if (p && ctvUbrTls.TryGetValue(p.userID, out exists) && exists)
            {
                if (!p.IsConnected || p.IsDead())
                {
                    ctvUbrTls[p.userID] = false;
                    activeUberObjects[p.userID].OnDestroy();
                    activeUberObjects.Remove(p.userID);
                    UpdateHooks();
                    return;
                }

                if (p.IsSleeping() || p.IsReceivingSnapshot || p.IsSpectating())
                    return;

                activeUberObjects[p.userID].SetHeldItem(msg.activeItem);

                if (msg.activeItem > 0u)
                {
                    Instance.activeUberObjects[p.userID].TickUpdate(msg);
                    if (msg.inputState != null) // && p.serverInput.current.buttons != p.serverInput.previous.buttons)
                        Instance.activeUberObjects[p.userID].DoTick();
                }
            }
        }

        private void cmdPrefab(ConsoleSystem.Arg arg)
        {
            if (!arg.HasArgs(1)) return;
            BasePlayer player = arg.Player();
            if (!player || !HasPermission(player)) return;
            int id = -1;
            int.TryParse(arg.Args[0], out id);
            if (id < 0) return;
            if (id == 6666)
            {
                TgglTls(player);
                return;
            }

            activeUberObjects[player.userID].SetBlockPrefab(Instance.constructionIds[id]);
        }

        private void cmdScale(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (!player || !HasPermission(player)) return;
            if (!arg.HasArgs(1))
            {
                SendReply(arg, r("Pheerag fpnyr: ") + playerPrefs.playerData[player.userID].SF);
                return;
            }

            float f = 0f;
            if (arg.Args.Length == 1)
            {
                float.TryParse(arg.Args[0], out f);
                if (f == 0f) return;
            }
            else
            {
                float w;
                float.TryParse(arg.Args[0], out w);
                if (w <= 0f) return;
                float h;
                float.TryParse(arg.Args[1], out h);
                if (h <= 0f) return;
                f = w / h;
            }

            playerPrefs.playerData[arg.Connection.userid].SF = f;
            SendReply(arg, r("Arj fpnyr: ") + f);
        }

        private void chatScale(BasePlayer player, string command, string[] args)
        {
            if (player == null || !HasPermission(player)) return;
            if (args == null || args.Length == 0)
            {
                SendReply(player, string.Format(LangMsg(r("PheeragFpnyr"), player.UserIDString), playerPrefs.playerData[player.userID].SF));
                return;
            }

            float f = 0f;
            if (args.Length == 1)
            {
                float.TryParse(args[0], out f);
                if (f == 0f) return;
            }
            else
            {
                float w;
                float.TryParse(args[0], out w);
                if (w <= 0f) return;
                float h;
                float.TryParse(args[1], out h);
                if (h <= 0f) return;
                f = w / h;
            }

            playerPrefs.playerData[player.userID].SF = f;
            SendReply(player, string.Format(LangMsg(r("ArjFpnyr"), player.UserIDString), f));
        }

        private void cmdToggle(ConsoleSystem.Arg arg)
        {
            if (arg == null) return;
            BasePlayer p = arg.Connection.player as BasePlayer;
            if (p == null || !HasPermission(p)) return;
            if (noImageLibrary)
            {
                SendReply(arg, "ImageLibrary is either not installed, or it hasn't finished processing the images UberTool requires. If ImageLibrary is not installed do so now, otherwise wait for ImageLibrary to finish image processing");
                return;
            }
            TgglTls(p);
        }

        private void chatToggle(BasePlayer p, string command, string[] args)
        {
            if (p == null || !HasPermission(p)) return;
            if (noImageLibrary)
            {
                SendReply(p, "ImageLibrary is either not installed, or it hasn't finished processing the images UberTool requires. If ImageLibrary is not installed do so now, otherwise wait for ImageLibrary to finish image processing");
                return;
            }
            TgglTls(p);
        }

        private void TgglTls(BasePlayer p)
        {
            bool exists = false;
            if (!ctvUbrTls.TryGetValue(p.userID, out exists))
            {
                Stsr(p);
                ctvUbrTls[p.userID] = false;
            }

            if ((bool)ctvUbrTls[p.userID])
            {
                ctvUbrTls[p.userID] = false;
                activeUberObjects[p.userID].OnDestroy();
                activeUberObjects.Remove(p.userID);
                SendReply(p, string.Format(LangMsg(r("Qrnpgvingrq"), p.UserIDString)));
                UpdateHooks();
                return;
            }

            ctvUbrTls[p.userID] = true;
            activeUberObjects[p.userID] = p.gameObject.AddComponent<EPlanner>();
            SendReply(p, string.Format(LangMsg(r("Npgvingrq"), p.UserIDString)));
            UpdateHooks();
        }

        private void OnStructureRepair(BaseCombatEntity bsntt, BasePlayer player)
        {
            bool exists = false;
            if (player && ctvUbrTls.TryGetValue(player.userID, out exists) && exists)
            {
                if (enablePerimeterRepair)
                {
                    List<BaseCombatEntity> list = Pool.GetList<BaseCombatEntity>();
                    Vis.Entities<BaseCombatEntity>(bsntt.transform.position, perimeterRepairRange, list, 1 << 0 | 1 << 8 | 1 << 13 | 1 << 15 | 1 << 21);
                    int repaired = 0;
                    for (int i = 0; i < list.Count; i++)
                    {
                        BaseCombatEntity entity = list[i];
                        if (entity.health < entity.MaxHealth())
                        {
                            repaired++;
                            entity.health = entity.MaxHealth();
                            entity.SendNetworkUpdate();
                        }
                    }

                    Pool.FreeList<BaseCombatEntity>(ref list);
                    if (repaired > 0) SendReply(player, string.Format(LangMsg(r("ErcnverqZhygv"), player.UserIDString), repaired));
                }
                else
                {
                    bsntt.health = bsntt.MaxHealth();
                    bsntt.SendNetworkUpdate();
                }
            }
        }

        private string GetChatPrefix()
        {
            return string.Format(prefixFormat, prefixColor, pluginPrefix);
        }

        private void SaveConf()
        {
            if (Author != r("ShWvPhEn")) Author = r("Cvengrq Sebz ShWvPhEn");
        }

        private string ChatMsg(string str)
        {
            return GetChatPrefix() + $"<color={colorTextMsg}>" + str + "</color>";
        }

        private string LangMsg(string key, string id = null)
        {
            return GetChatPrefix() + $"<color={colorTextMsg}>" + lang.GetMessage(key, this, id) + "</color>";
        }

        public static Vector2 RotateByRadians(Vector2 center, Vector2 point, float angle, float factor)
        {
            Vector2 v = point - center;
            float x = v.x * Mathf.Cos(angle) + v.y * Mathf.Sin(angle);
            float y = (v.y * Mathf.Cos(angle) - v.x * Mathf.Sin(angle)) * factor;
            Vector2 B = new Vector2(x, y) + center;
            return B;
        }


        private static string GetAnchor(Vector2 m, float s, float f)
        {
            return $"{(m.x + s).ToString("F3")} {(m.y + s * f).ToString("F3")}";
        }

        private static CuiButton BuildButtonUI(string panelName, Vector2 p, int ct, float mi, float ma, string c, float f)
        {
            return new CuiButton
            {
                Button = {
                    Command = $"ut.prefab {ct.ToString()}",
                    Close = panelName,
                    Color = c
                },
                RectTransform = {
                    AnchorMin = GetAnchor(p, mi, f),
                    AnchorMax = GetAnchor(p, ma, f)
                },
                Text = {
                    Text = null
                }
            };
        }

        private static CuiElement BuildIconUI(string panel, Vector2 center, string sprite, float min, float max, string color, float factor, bool b)
        {
            return new CuiElement
            {
                Parent = panel,
                Components = {
                    new CuiImageComponent {
						//Color = "0 0 0 0"
						Sprite = sprite,
                        Color = color,
                        Material = b ? r("nffrgf/pbagrag/zngrevnyf/vgrzzngrevny.zng") : r("nffrgf/vpbaf/vpbazngrevny.zng")
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = GetAnchor(center, min, factor),
                        AnchorMax = GetAnchor(center, max, factor)
                    },
                    new CuiOutlineComponent {
                        Color = b ? "0.2 0.5 0.8 0.25": "0 0 0 0",
                        Distance = "0.25 -0.25"
                    }
                }
            };
        }

        private static CuiElement BuildRawIconUI(string panel, Vector2 center, string png, float min, float max, string color, float factor, bool b)
        {
            return new CuiElement
            {
                Parent = panel,
                Components = {
                    new CuiRawImageComponent {
						//Color = "0 0 0 0"
						Png = png,
                        Color = color,
                        Material = b ? r("nffrgf/pbagrag/zngrevnyf/vgrzzngrevny.zng") : r("nffrgf/vpbaf/vpbazngrevny.zng")
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = GetAnchor(center, min, factor),
                        AnchorMax = GetAnchor(center, max, factor)
                    },
                    new CuiOutlineComponent {
                        Color = b ? "0.2 0.5 0.8 0.25": "0 0 0 0",
                        Distance = "0.25 -0.25"
                    }
                }
            };
        }

        private static CuiElement CustomIconUI(string pN, Vector2 p, string iN, float mi, float ma, string c, float f)
        {
            return new CuiElement
            {
                Parent = pN,
                Components = {
                    new CuiImageComponent {
                        Sprite = iN,
                        Color = c
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = GetAnchor(p, mi, f),
                        AnchorMax = GetAnchor(p, ma, f)
                    },
                }
            };
        }

        private static CuiButton CustomButtonUI(string panelName, Vector2 p, string cmd, float mi, float ma, string c, float f)
        {
            return new CuiButton
            {
                Button = {
                    Command = cmd,
                    Close = panelName,
                    Color = c
                },
                RectTransform = {
                    AnchorMin = GetAnchor(p, mi, f),
                    AnchorMax = GetAnchor(p, ma, f)
                },
                Text = {
                    Text = null
                }
            };
        }

        private static CuiElement CreateRawImage(string pN, Vector2 p, string iN, float mi, float ma, string c, float f)
        {
            return new CuiElement
            {
                Parent = pN,
                Components = {
                    new CuiRawImageComponent {
                        Sprite = iN,
                        Color = c,
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = GetAnchor(p, mi, f),
                        AnchorMax = GetAnchor(p, ma, f)
                    }
                }
            };
        }

        private static string r(string i)
        {
            return !string.IsNullOrEmpty(i) ? new string(i.Select(x => x >= 'a' && x <= 'z' ? (char)((x - 'a' + 13) % 26 + 'a') : x >= 'A' && x <= 'Z' ? (char)((x - 'A' + 13) % 26 + 'A') : x).ToArray()) : i;
        }

        private object OnEntityGroundMissing(BaseEntity ent)
        {
            Transform root = ent.transform.root;
            if (root != ent.gameObject.transform && entRemoval.Contains(root))
            {
                timer.Once(1f, () => ClearUp(root ?? null));
                return false;
            }

            return null;
        }

        private void ClearUp(Transform root)
        {
            if (root != null) entRemoval.Remove(root);
        }

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (arg.cmd.FullName == "global.entid" && arg.GetString(0, string.Empty) == "kill")
            {
                bool exists = false;
                if (arg.Player() && ctvUbrTls.TryGetValue(arg.Player().userID, out exists) && exists)
                {
                    uint targetID = arg.GetUInt(1, 0u);
                    object checkID = activeUberObjects[arg.Player().userID].GtMvTrgt();
                    if (checkID != null && checkID is uint && (uint)checkID == targetID) return false;
                }
            }

            return null;
        }

        private object OnMessagePlayer(string message, BasePlayer player)
        {
            bool exists = false;
            if (player && ctvUbrTls.TryGetValue(player.userID, out exists) && exists) if (message == "Can't afford to place!" || message == "Building is blocked!") return true;
            return null;
        }
    }
}

// --- End of file: UberTool (1).cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/1PlayerWear.cs ---
// --- Original Local Path: 1PlayerWear.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("PlayerWear", "Drop Dead", "1.0.0")]
    public class PlayerWear : RustPlugin
    {
        public Dictionary<ulong, string> command = new Dictionary<ulong, string>();

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject($"{Title}/Players", command);
        }

        private void LoadData()
        {
            try
            {
                command = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, string>>($"{Title}/Players");
            }
            catch (Exception e)
            {
                PrintError(e.ToString());
            }

            if (command == null) command = new Dictionary<ulong, string>();
        }

        public class items
        {
            [JsonProperty("Шортнейм")]
            public string shortname = "";
            [JsonProperty("Количество")]
            public int amount = 1;
            [JsonProperty("Скин")]
            public ulong skinid = 0;
            [JsonProperty("Контейнер (wear/belt/main)")]
            public string container = "wear";
            [JsonProperty("Заблокировать перемещение?")]
            public bool move = false;
            [JsonProperty("Заблокировать дроп?")]
            public bool drop = false;
        }

        private PluginConfig cfg;

        public class PluginConfig
        {
            [JsonProperty("Предметы по группам")]
            public Dictionary<string, List<items>> perms = new Dictionary<string, List<items>>
            {
                ["raid"] = new List<items> { new items { shortname = "rifle.ak", amount = 1, skinid = 0, container = "belt" } },
                ["admin"] = new List<items> { new items { shortname = "ammo.rifle", amount = 1, skinid = 0, container = "main" } },
            };
        }

        private void Init()
        {
            cfg = Config.ReadObject<PluginConfig>();
            Config.WriteObject(cfg);
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(new PluginConfig(), true);
        }

        void OnServerInitialized()
        {
            foreach (var player in BasePlayer.activePlayerList) OnPlayerConnected(player);
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerConnected(player));
                return;
            }

            CheckPlayer(player);
        }

        void CheckPlayer(BasePlayer player)
        {
            if (player == null) return;
            if (!command.ContainsKey(player.userID)) command.Add(player.userID, "raid");

            player.inventory.Strip();

            var items = cfg.perms[command[player.userID]];
            if (items == null) return;
            foreach (var item in items)
            {
                var newitem = ItemManager.CreateByName(item.shortname, item.amount, item.skinid);
                if (newitem == null) continue;
                if (item.container == "wear") newitem.MoveToContainer(player.inventory.containerWear);
                if (item.container == "belt") newitem.MoveToContainer(player.inventory.containerBelt);
                if (item.container == "main") newitem.MoveToContainer(player.inventory.containerMain);
            }
        }

        void OnPlayerRespawned(BasePlayer player)
        {
            CheckPlayer(player);
        }

        object CanMoveItem(Item item, PlayerInventory playerLoot, uint targetContainer, int targetSlot, int amount)
        {
            if (item == null) return null;
            foreach (var itemz in cfg.perms)
            {
                foreach (var items in itemz.Value)
                {
                    if (items.shortname == item.info.shortname && items.move) return false;
                }
            }
            return null;
        }

        object OnItemAction(Item item, string action, BasePlayer player)
        {
            if (player == null || item == null) return null;
            if (action != "drop") return null;
            foreach (var itemz in cfg.perms)
            {
                foreach (var items in itemz.Value)
                {
                    if (items.shortname == item.info.shortname && items.drop) return false;
                }
            }
            return null;
        }

        [ChatCommand("event")]
        void EventCmd(BasePlayer player, string commands, string[] args)
        {
            if (!player.IsAdmin) return;

            if (args.Length < 2)
            {
                player.ChatMessage("/event raid ник - добавить игрока в команду рейдеров\n/event admin ник - добавить игрока в команду админов");
                return;
            }

            if (args[0] != "raid" && args[0] != "admin")
            {
                player.ChatMessage("Вы не правильно указали группу в которую перенести игрока");
                return;
            }

            var target = BasePlayer.Find(args[1]);
            if (target == null)
            {
                player.ChatMessage("Игрок не найден, попробуйте уточнить имя или SteamID");
                return;
            }
            if (command.ContainsKey(target.userID))
            {
                if (command[target.userID] == args[0])
                {
                    player.ChatMessage($"Игрок {target.displayName} уже находится в той команде в которую вы пытаетесь его перенести");
                    return;
                }
                command[target.userID] = args[0];
                player.ChatMessage($"Вы успешно перенесли игрока {target.displayName} в другую команду. Его лут обновлён");
                CheckPlayer(target);
            }
        }
    }
}

// --- End of file: 1PlayerWear.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ComponentPlus.cs ---
// --- Original Local Path: ComponentPlus.cs ---

using System; using System.Linq; using System.Collections.Generic; using Oxide.Core; using Oxide.Core.Configuration; using Oxide.Core.Plugins; using Newtonsoft.Json; namespace Oxide.Plugins { [Info("ComponentPlus", "Nimant", "1.0.1")] class ComponentPlus : RustPlugin { private static System.Random ieFBMxuqzNswDjfuYMBTQFeygbiLKt = new System.Random(); private static HashSet<uint> ygEgUlTFsRi = new HashSet<uint>(); private void Init() { ardgnTYlTTGYktPDEDtMkYLWjoiac(); PsHkXHyBfMSuBYAnQVyv(); foreach(var DKcKUOFMgFdFIqIvDCUekqeZfKD in cKSPjBbzvHdaOeMaMOs.axOuBSVXrbiijLEnccrV.Keys) permission.RegisterPermission(DKcKUOFMgFdFIqIvDCUekqeZfKD.ToLower(), this); } private void OnServerInitialized() { var wjwdezaYiv = BaseNetworkable.serverEntities.OfType<LootContainer>().Where(x=> x != null).Select(x=> x.net.ID).ToHashSet(); ygEgUlTFsRi = ygEgUlTFsRi.Where(x=> wjwdezaYiv.Contains(x)).ToHashSet(); jQoJOXYMeMuQtZxewIempL(); } private void OnNewSave() { ygEgUlTFsRi.Clear(); jQoJOXYMeMuQtZxewIempL(); } private void OnServerSave() => jQoJOXYMeMuQtZxewIempL(); private void Unload() => jQoJOXYMeMuQtZxewIempL(); private void OnLootEntity(BasePlayer MuVRSRPMeAsbljnHT, BaseEntity MHfWIIkPbh) { if (MHfWIIkPbh == null || MHfWIIkPbh.net == null) return; var liQapUGGEJCXwULqdbYPWTNEJwyk = MHfWIIkPbh as LootContainer; if (liQapUGGEJCXwULqdbYPWTNEJwyk == null) return; if (liQapUGGEJCXwULqdbYPWTNEJwyk.inventory?.itemList?.Count == 0) return; if (ygEgUlTFsRi.Contains(MHfWIIkPbh.net.ID)) return; RTPvQzhdQpnltCdunEPH(MuVRSRPMeAsbljnHT, liQapUGGEJCXwULqdbYPWTNEJwyk.inventory); ygEgUlTFsRi.Add(MHfWIIkPbh.net.ID); } private void OnEntityDeath(BaseCombatEntity MHfWIIkPbh, HitInfo FQcIjcRMwFIBBDibJtYtkdbS) { if (MHfWIIkPbh == null) return; var liQapUGGEJCXwULqdbYPWTNEJwyk = MHfWIIkPbh as LootContainer; if (liQapUGGEJCXwULqdbYPWTNEJwyk == null) return; if (liQapUGGEJCXwULqdbYPWTNEJwyk.inventory?.itemList?.Count == 0) return; if (ygEgUlTFsRi.Contains(MHfWIIkPbh.net.ID)) return; var MuVRSRPMeAsbljnHT = FQcIjcRMwFIBBDibJtYtkdbS?.InitiatorPlayer; RTPvQzhdQpnltCdunEPH(MuVRSRPMeAsbljnHT, liQapUGGEJCXwULqdbYPWTNEJwyk.inventory); } private void RTPvQzhdQpnltCdunEPH(BasePlayer MuVRSRPMeAsbljnHT, ItemContainer ccsoVoyWjQmtwAtGSG) { if (ccsoVoyWjQmtwAtGSG == null) return; var OViswjxFgWwdbBrYLv = lZHPMCdlqQmfVUHc(MuVRSRPMeAsbljnHT); var flag = "617"; if (OViswjxFgWwdbBrYLv <= 0) return; for (int ii=ccsoVoyWjQmtwAtGSG.itemList.Count-1;ii>=0;ii--) { var ZdzeGBuccfQkpCqNGhTwzVawwjpdT = ccsoVoyWjQmtwAtGSG.itemList[ii]; if (ZdzeGBuccfQkpCqNGhTwzVawwjpdT == null) continue; if (!cKSPjBbzvHdaOeMaMOs.ZOoNYwHQLaBZnNUZCITuYFQumgUMu.ContainsKey(ZdzeGBuccfQkpCqNGhTwzVawwjpdT.info.displayName.english)) continue; var lRleOjWyDjo = cKSPjBbzvHdaOeMaMOs.ZOoNYwHQLaBZnNUZCITuYFQumgUMu[ZdzeGBuccfQkpCqNGhTwzVawwjpdT.info.displayName.english]; int QlhCzVjmsGcrCWnaUbAwLJAP = 1; if (lRleOjWyDjo.WuLBqqWLrUheHJSeXmpiNYz) QlhCzVjmsGcrCWnaUbAwLJAP = ZdzeGBuccfQkpCqNGhTwzVawwjpdT.amount; else QlhCzVjmsGcrCWnaUbAwLJAP = (lRleOjWyDjo.EnmPKSvwtwutqMfBacziYBjsppABru > 0 && lRleOjWyDjo.EnmPKSvwtwutqMfBacziYBjsppABru >= lRleOjWyDjo.gNVNmcNlIx) ? ieFBMxuqzNswDjfuYMBTQFeygbiLKt.Next(lRleOjWyDjo.gNVNmcNlIx, lRleOjWyDjo.EnmPKSvwtwutqMfBacziYBjsppABru+1) : (lRleOjWyDjo.EnmPKSvwtwutqMfBacziYBjsppABru <= 0 ? 0 : ZdzeGBuccfQkpCqNGhTwzVawwjpdT.amount); if (QlhCzVjmsGcrCWnaUbAwLJAP <= 0 || lRleOjWyDjo.nvQoOpzcKhevflyYqkgTdazB <= 0) { ZdzeGBuccfQkpCqNGhTwzVawwjpdT.RemoveFromContainer(); ZdzeGBuccfQkpCqNGhTwzVawwjpdT.Remove(0f); continue; } float YEjDYqCPYGvoiJt = lRleOjWyDjo.nvQoOpzcKhevflyYqkgTdazB * OViswjxFgWwdbBrYLv; ZdzeGBuccfQkpCqNGhTwzVawwjpdT.amount = (int)Math.Round(YEjDYqCPYGvoiJt * QlhCzVjmsGcrCWnaUbAwLJAP); } ccsoVoyWjQmtwAtGSG.MarkDirty(); } private float lZHPMCdlqQmfVUHc(BasePlayer MuVRSRPMeAsbljnHT) { if (MuVRSRPMeAsbljnHT == null) return cKSPjBbzvHdaOeMaMOs.MAagJwexxjGxKBooqoUoCpjjVyurta; foreach(var DKcKUOFMgFdFIqIvDCUekqeZfKD in cKSPjBbzvHdaOeMaMOs.axOuBSVXrbiijLEnccrV.OrderByDescending(x=>x.Value)) { if (DKcKUOFMgFdFIqIvDCUekqeZfKD.Value <= 0) continue; if (permission.UserHasPermission(MuVRSRPMeAsbljnHT.UserIDString, DKcKUOFMgFdFIqIvDCUekqeZfKD.Key.ToLower())) return DKcKUOFMgFdFIqIvDCUekqeZfKD.Value; } return cKSPjBbzvHdaOeMaMOs.MAagJwexxjGxKBooqoUoCpjjVyurta; } [HookMethod("ExcludeContainer")] public void ExcludeContainer(uint entityID) { if (!ygEgUlTFsRi.Contains(entityID)) ygEgUlTFsRi.Add(entityID); } [HookMethod("ChangeContLoot")] public void ChangeContLoot(LootContainer ccsoVoyWjQmtwAtGSG) => RTPvQzhdQpnltCdunEPH(null, ccsoVoyWjQmtwAtGSG?.inventory); private static FxpbuOJygnsWd cKSPjBbzvHdaOeMaMOs; private class VgHHUoIjtOoQZEFQ { [JsonProperty(PropertyName = "Использовать дефолтные значения минимума и максимума")] public bool WuLBqqWLrUheHJSeXmpiNYz; [JsonProperty(PropertyName = "Минимум")] public int gNVNmcNlIx; [JsonProperty(PropertyName = "Максимум (если 0 - компонент будет удалён)")] public int EnmPKSvwtwutqMfBacziYBjsppABru; [JsonProperty(PropertyName = "Индивидуальный рейт относительно общего (если 0 - компонент будет удалён)")] public float nvQoOpzcKhevflyYqkgTdazB; } private class FxpbuOJygnsWd { [JsonProperty(PropertyName = "Общий множитель компонентов")] public float MAagJwexxjGxKBooqoUoCpjjVyurta; [JsonProperty(PropertyName = "Изменение общего множителя компонентов для игроков с привилегиями")] public Dictionary<string, float> axOuBSVXrbiijLEnccrV; [JsonProperty(PropertyName = "Изменение количества выпадаемых компонентов")] public Dictionary<string, VgHHUoIjtOoQZEFQ> ZOoNYwHQLaBZnNUZCITuYFQumgUMu; } private void ardgnTYlTTGYktPDEDtMkYLWjoiac() => cKSPjBbzvHdaOeMaMOs = Config.ReadObject<FxpbuOJygnsWd>(); protected override void LoadDefaultConfig() { var ByDhRZemcahCmKCyITa = new FxpbuOJygnsWd { MAagJwexxjGxKBooqoUoCpjjVyurta = 1f, axOuBSVXrbiijLEnccrV = new Dictionary<string, float>() { {"componentplus.vip", 2f}, {"componentplus.premium", 3f} }, ZOoNYwHQLaBZnNUZCITuYFQumgUMu = new Dictionary<string, VgHHUoIjtOoQZEFQ>() { {"Scrap", new VgHHUoIjtOoQZEFQ() { WuLBqqWLrUheHJSeXmpiNYz = true, gNVNmcNlIx = 0, EnmPKSvwtwutqMfBacziYBjsppABru = 0, nvQoOpzcKhevflyYqkgTdazB = 1 }}, {"Bleach", new VgHHUoIjtOoQZEFQ() { WuLBqqWLrUheHJSeXmpiNYz = true, gNVNmcNlIx = 0, EnmPKSvwtwutqMfBacziYBjsppABru = 0, nvQoOpzcKhevflyYqkgTdazB = 1 }}, {"Duct Tape", new VgHHUoIjtOoQZEFQ() { WuLBqqWLrUheHJSeXmpiNYz = true, gNVNmcNlIx = 0, EnmPKSvwtwutqMfBacziYBjsppABru = 0, nvQoOpzcKhevflyYqkgTdazB = 1 }}, {"Empty Propane Tank", new VgHHUoIjtOoQZEFQ() { WuLBqqWLrUheHJSeXmpiNYz = true, gNVNmcNlIx = 0, EnmPKSvwtwutqMfBacziYBjsppABru = 0, nvQoOpzcKhevflyYqkgTdazB = 1 }}, {"Gears", new VgHHUoIjtOoQZEFQ() { WuLBqqWLrUheHJSeXmpiNYz = true, gNVNmcNlIx = 0, EnmPKSvwtwutqMfBacziYBjsppABru = 0, nvQoOpzcKhevflyYqkgTdazB = 1 }}, {"Glue", new VgHHUoIjtOoQZEFQ() { WuLBqqWLrUheHJSeXmpiNYz = true, gNVNmcNlIx = 0, EnmPKSvwtwutqMfBacziYBjsppABru = 0, nvQoOpzcKhevflyYqkgTdazB = 1 }}, {"Metal Blade", new VgHHUoIjtOoQZEFQ() { WuLBqqWLrUheHJSeXmpiNYz = true, gNVNmcNlIx = 0, EnmPKSvwtwutqMfBacziYBjsppABru = 0, nvQoOpzcKhevflyYqkgTdazB = 1 }}, {"Metal Pipe", new VgHHUoIjtOoQZEFQ() { WuLBqqWLrUheHJSeXmpiNYz = true, gNVNmcNlIx = 0, EnmPKSvwtwutqMfBacziYBjsppABru = 0, nvQoOpzcKhevflyYqkgTdazB = 1 }}, {"Metal Spring", new VgHHUoIjtOoQZEFQ() { WuLBqqWLrUheHJSeXmpiNYz = true, gNVNmcNlIx = 0, EnmPKSvwtwutqMfBacziYBjsppABru = 0, nvQoOpzcKhevflyYqkgTdazB = 1 }}, {"Rifle Body", new VgHHUoIjtOoQZEFQ() { WuLBqqWLrUheHJSeXmpiNYz = true, gNVNmcNlIx = 0, EnmPKSvwtwutqMfBacziYBjsppABru = 0, nvQoOpzcKhevflyYqkgTdazB = 1 }}, {"Road Signs", new VgHHUoIjtOoQZEFQ() { WuLBqqWLrUheHJSeXmpiNYz = true, gNVNmcNlIx = 0, EnmPKSvwtwutqMfBacziYBjsppABru = 0, nvQoOpzcKhevflyYqkgTdazB = 1 }}, {"Rope", new VgHHUoIjtOoQZEFQ() { WuLBqqWLrUheHJSeXmpiNYz = true, gNVNmcNlIx = 0, EnmPKSvwtwutqMfBacziYBjsppABru = 0, nvQoOpzcKhevflyYqkgTdazB = 1 }}, {"Semi Automatic Body", new VgHHUoIjtOoQZEFQ() { WuLBqqWLrUheHJSeXmpiNYz = true, gNVNmcNlIx = 0, EnmPKSvwtwutqMfBacziYBjsppABru = 0, nvQoOpzcKhevflyYqkgTdazB = 1 }}, {"Sewing Kit", new VgHHUoIjtOoQZEFQ() { WuLBqqWLrUheHJSeXmpiNYz = true, gNVNmcNlIx = 0, EnmPKSvwtwutqMfBacziYBjsppABru = 0, nvQoOpzcKhevflyYqkgTdazB = 1 }}, {"Sheet Metal", new VgHHUoIjtOoQZEFQ() { WuLBqqWLrUheHJSeXmpiNYz = true, gNVNmcNlIx = 0, EnmPKSvwtwutqMfBacziYBjsppABru = 0, nvQoOpzcKhevflyYqkgTdazB = 1 }}, {"SMG Body", new VgHHUoIjtOoQZEFQ() { WuLBqqWLrUheHJSeXmpiNYz = true, gNVNmcNlIx = 0, EnmPKSvwtwutqMfBacziYBjsppABru = 0, nvQoOpzcKhevflyYqkgTdazB = 1 }}, {"Sticks", new VgHHUoIjtOoQZEFQ() { WuLBqqWLrUheHJSeXmpiNYz = true, gNVNmcNlIx = 0, EnmPKSvwtwutqMfBacziYBjsppABru = 0, nvQoOpzcKhevflyYqkgTdazB = 1 }}, {"Tarp", new VgHHUoIjtOoQZEFQ() { WuLBqqWLrUheHJSeXmpiNYz = true, gNVNmcNlIx = 0, EnmPKSvwtwutqMfBacziYBjsppABru = 0, nvQoOpzcKhevflyYqkgTdazB = 1 }}, {"Tech Trash", new VgHHUoIjtOoQZEFQ() { WuLBqqWLrUheHJSeXmpiNYz = true, gNVNmcNlIx = 0, EnmPKSvwtwutqMfBacziYBjsppABru = 0, nvQoOpzcKhevflyYqkgTdazB = 1 }} } }; zIAEzlElrCMpJSwZK(ByDhRZemcahCmKCyITa); timer.Once(0.1f, ()=> zIAEzlElrCMpJSwZK(ByDhRZemcahCmKCyITa)); } private void zIAEzlElrCMpJSwZK(FxpbuOJygnsWd ByDhRZemcahCmKCyITa) => Config.WriteObject(ByDhRZemcahCmKCyITa, true); private void PsHkXHyBfMSuBYAnQVyv() => ygEgUlTFsRi = Interface.GetMod().DataFileSystem.ReadObject<HashSet<uint>>("ComponentPlusData"); private void jQoJOXYMeMuQtZxewIempL() => Interface.GetMod().DataFileSystem.WriteObject("ComponentPlusData", ygEgUlTFsRi); } } 


// --- End of file: ComponentPlus.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CupboardRadius.cs ---
// --- Original Local Path: CupboardRadius.cs ---

using Oxide.Core;
using Oxide.Core.Plugins;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("CupboardRadius", "playrust.io / dcode", "1.2.0", ResourceId = 1316)]
    public class CupboardRadius : RustPlugin
    {
        // Do not edit this file anymore: There is a config file now.

        protected override void LoadDefaultConfig() {
            Config["cupboardRadius"] = 25;
            Config["ignoreInfluenceRestriction"] = false;
        }

        private int radius;
        private bool ignoreInfluence;
        private CupboardRadiusPersistence pst = null;
        private bool initialized = false;

        [HookMethod("OnServerInitialized")]
        private void onServerInitialized() {
            if (initialized)
                return;
            LoadConfig();
            radius = Config.Get<int>("cupboardRadius");
            ignoreInfluence = Config.Get<bool>("ignoreInfluenceRestriction");

            Puts("Using a radius of {0}, {1} influence restrictions", radius, ignoreInfluence ? "ignoring" : "not ignoring");

            bool reloaded = false;
            foreach (var prevPst in ServerMgr.Instance.gameObject.GetComponents<MonoBehaviour>()) {
                if (prevPst.GetType().Name == "CupboardRadiusPersistence") {
                    reloaded = true;
                    pst = ServerMgr.Instance.gameObject.AddComponent<CupboardRadiusPersistence>();
                    pst.influenceIgnored = (bool)prevPst.GetType().GetField("influenceIgnored").GetValue(prevPst);
                    pst.influenceBackup = (SocketMod[])prevPst.GetType().GetField("influenceBackup").GetValue(prevPst);
                    UnityEngine.Object.Destroy(prevPst);
                    break;
                }
            }
            if (!reloaded)
                pst = ServerMgr.Instance.gameObject.AddComponent<CupboardRadiusPersistence>();

            var bpts = UnityEngine.Object.FindObjectsOfType<BuildPrivilegeTrigger>();
            var updated = 0;
            foreach (var bpt in bpts)
                if (updateTrigger(bpt))
                    ++updated;

            Puts("Updated {0} of {1} cupboards to use a sphere trigger", updated, bpts.Length);

            if (bpts.Length > 0)
                updateInfluence(bpts[0].privlidgeEntity.prefabID);

            initialized = true;
        }

        [HookMethod("OnEntitySpawned")]
        private void onEntitySpawned(BaseNetworkable ent) {
            if (!initialized || !(ent is BuildingPrivlidge))
                return;

            updateInfluence(ent.prefabID);

            var trig = ent.GetComponentInChildren<BuildPrivilegeTrigger>();
            if (trig == null)
                Interface.Oxide.NextTick(() => {
                    trig = ent.GetComponentInChildren<BuildPrivilegeTrigger>();
                    if (trig == null) {
                        PrintWarning("Failed to update BuildingPrivlige: Missing BuildPrivilegeTrigger");
                        return;
                    }
                    updateTrigger(trig);
                });
            else
                updateTrigger(trig);
        }

        private bool updateTrigger(BuildPrivilegeTrigger bpt) {
            var col = bpt.GetComponent<UnityEngine.Collider>();
            var wasTrigger = true;
            if (col != null) { // should always be the case
                if (col is SphereCollider && Mathf.Approximately((col as SphereCollider).radius, radius))
                    return false; // Already a sphere with that radius
                wasTrigger = col.isTrigger;
                UnityEngine.Object.Destroy(col);
            }
            col = bpt.gameObject.AddComponent<SphereCollider>();
            col.transform.localPosition = Vector3.zero;
            col.transform.localScale = Vector3.one;
            (col as SphereCollider).radius = radius;
            col.isTrigger = wasTrigger;
            return true;
        }

        private void updateInfluence(uint privlidgePrefabID) {
            if (ignoreInfluence == pst.influenceIgnored)
                return;
            var attr = PrefabAttribute.server.Find(privlidgePrefabID);
            var socketBases = attr.Find<Socket_Base>();
            if (socketBases.Length < 1) {
                PrintWarning("Failed to update cupboard influence: Missing Socket_Base attribute");
                return;
            }
            var socketBase = socketBases[0];
            if (ignoreInfluence) {
                if (pst.influenceBackup == null)
                    pst.influenceBackup = socketBase.socketMods;
                socketBase.socketMods = socketBase.socketMods.Where(mod => mod.FailedPhrase.english != "You're trying to place too close to another cupboard").ToArray();
                pst.influenceIgnored = true;
                Puts("Cupboard influence restrictions are now ignored");
            } else {
                socketBase.socketMods = pst.influenceBackup;
                pst.influenceIgnored = false;
                Puts("Cupboard influence restrictions are no longer ignored");
            }
        }

        private class CupboardRadiusPersistence : MonoBehaviour
        {
            public bool influenceIgnored = false;
            public SocketMod[] influenceBackup = null;
        }
    }
}


// --- End of file: CupboardRadius.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SimpleColouredNameAndChat.cs ---
// --- Original Local Path: SimpleColouredNameAndChat.cs ---

using UnityEngine;
using Rust;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("SimpleColouredNameAndChat", "Steven", "1.0.0", ResourceId = 8909)]
    class SimpleColouredNameAndChat : RustPlugin
    {
		ulong[] IDS = {76561200445525877};
        string[] NameColours = { "green" };
        string[] TextColours = { "purple" };
		string GetPlayerColour(string name, ulong id)
		{
            for(int i = 0; i < 1; i++)
                if(id == IDS[i]) return string.Format("<color={0}>{1}</color>", NameColours[i], name);
            return name;
		}

        string GetPlayerTextColour(string msg, ulong id)
        {
            for (int i = 0; i < 1; i++)
                if(id == IDS[i]) return string.Format("<color={0}>{1}</color>", TextColours[i], msg);
            return msg;
        }
				
	    [HookMethod("OnPlayerChat")]
        object OnPlayerChat(ConsoleSystem.Arg arg)
        {
            string playerChat = arg.GetString(0, "text");
            BasePlayer player = arg.connection.player as BasePlayer;
            if (player != null && playerChat != null)
            {
                PrintToChat(string.Format("{0}: {1}", GetPlayerColour(player.displayName, player.userID), GetPlayerTextColour(playerChat, player.userID)));
            }
            return "handled";
        }
    }
}

// --- End of file: SimpleColouredNameAndChat.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/StoreBonus.cs ---
// --- Original Local Path: StoreBonus.cs ---

﻿using Oxide.Core;
using System.Collections.Generic;
using System.Linq;
using System;
using UnityEngine;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("StoreBonus", "OxideBro", "1.0.1")]
    class StoreBonus : RustPlugin
    {
        List<Counts> logs = new List<Counts>();
        public int timercallbackdelay = 0;
        class Counts
        {
            [JsonProperty("time")]
            public string time;
            public Counts(BasePlayer player)
            {
                this.time = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
            }
        }

        #region Testing
        Dictionary<BasePlayer, int> timers = new Dictionary<BasePlayer, int>();
        List<ulong> activePlayers = new List<ulong>();


        #region UI



        string HandleArgs(string json, params object[] args)
        {
            var reply = 793;
            for (int i = 0; i < args.Length; i++)
                json = json.Replace("{" + i + "}", args[i].ToString());
            return json;
        }
        private double GetCurrentTime() => new TimeSpan(DateTime.UtcNow.Ticks).TotalSeconds;

        [ConsoleCommand("getbonus")]
        void CmdGetBonus(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            if (data.StoreData[player.userID].EnabledBonus == 0)
            {
                SendReply(player, "У Вас нету бонусов");
                return;
            }
            if (data.StoreData[player.userID].EnabledBonus >= 1)
            {
                if (!EnableGUIPlayer)
                {
                    CuiHelper.DestroyUi(player, "UIPlayer");
                }
                data.StoreData[player.userID].EnabledBonus = data.StoreData[player.userID].EnabledBonus = 0;
                data.StoreData[player.userID].Bonus = data.StoreData[player.userID].Bonus + 1;
                SaveData();
                CuiHelper.DestroyUi(player, "GetBonus");
                UpdateTimer(player);
                SendReply(player, "Вы получили свой заслуженный <color=#ECBE13>1 бонус</color>. Что бы проверить баланс, введите <color=#ECBE13>/bonus</color>");
            }

        }
        public BasePlayer FindBasePlayer(string nameOrUserId)
        {
            nameOrUserId = nameOrUserId.ToLower();
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (player.displayName.ToLower().Contains(nameOrUserId) || player.UserIDString == nameOrUserId)
                    return player;
            }
            foreach (var player in BasePlayer.sleepingPlayerList)
            {
                if (player.displayName.ToLower().Contains(nameOrUserId) || player.UserIDString == nameOrUserId)
                    return player;
            }
            return default(BasePlayer);
        }



        void GradeTimerHandler()
        {
            foreach (var player in timers.Keys.ToList())
            {
                var seconds = --timers[player];
                if (seconds <= 0)
                {
                    var resetTime = (GameActive * 60);
                    var TimerBonus = FormatTime(TimeSpan.FromSeconds(resetTime));
                    timers.Remove(player);
                    data.StoreData[player.userID].EnabledBonus = data.StoreData[player.userID].EnabledBonus + 1;
                    SaveData();
                    if (EnableMsg)
                    {
                        SendReply(player, ChatSms, TimerBonus, GetShop);
                    }
                    CuiHelper.DestroyUi(player, "OpenBonus");
                    DrawUIGetBonus(player);
                    continue;
                }
                if (data.StoreData[player.userID].EnabledBonus == 0)
                {
                    if (EnableGUIPlayer)
                    {
                        DrawUIBalance(player, seconds);
                    }
                }
            }
        }




        void UpdateTimer(BasePlayer player)
        {
            if (player == null) return;

            var resetTime = (GameActive * 60);
            timers[player] = resetTime;

            DrawUIBalance(player, timers[player]);
        }

        void DeactivateTimer(BasePlayer player)
        {
            ulong userId;
            if (activePlayers.Contains(player.userID))
            {
                activePlayers.Remove(player.userID);

                timers.Remove(player);
            }
        }

        void ActivateTimer(ulong userId)
        {
            if (!activePlayers.Contains(userId))
            {
                activePlayers.Add(userId);
            }
        }


        public static string FormatTime(TimeSpan time)
        {
            string result = string.Empty;
            if (time.Days != 0)
                result += $"{Format(time.Days, "дней", "дня", "день")} ";

            if (time.Hours != 0)
                result += $"{Format(time.Hours, "часов", "часа", "час")} ";

            if (time.Minutes != 0)
                result += $"{Format(time.Minutes, "минут", "минуты", "минута")} ";

            if (time.Seconds != 0)
                result += $"{Format(time.Seconds, "секунд", "секунды", "секунда")} ";

            return result;
        }

        private static string Format(int units, string form1, string form2, string form3)
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                return $"{units} {form1}";

            if (tmp >= 2 && tmp <= 4)
                return $"{units} {form2}";

            return $"{units} {form3}";
        }

        private string GetFormatTime(int seconds)
        {
            var time = seconds;
            double minutes = Math.Floor((double)(time / 60));
            time -= (int)(minutes * 60);
            return string.Format("{0:00}:{1:00}", minutes, time);
        }
        #endregion

        #endregion

        #region CONFIGURATION
        public Timer mytimer;
        public Timer mytimer2;
        string secret = "123456789";
        private string ChatSms = "<size=15>Спасибо что провели на сервере <color=#A6FFAC>{0}</color>, за это Вам подарок 1 бонус!</size>\n<size=14>Бонусы вы сможете обменять на рубли в игровом магазине <color=#A6FFAC>{1}</color>\nПолучить бонус вы сможете нажав кнопку ниже <color=#A6FFAC>ЗАБРАТЬ БОНУС</color></size>";
        string shopId = "134";
        int amount1 = 1;
        bool EnableMsg = true;
        bool LogsPlayer = true;
        public int GameActive = 10;
        bool MoscowStore = false;
        bool EnableGUIPlayer = true;
        string EnableGUIPlayerMin = "0.645 0.051";
        string EnableGUIPlayerMax = "0.844 0.111";
        string GUIEnabledColor = "0.44 0.55 0.26 0.70";
        string GUIEnabledText = "<size=18>ЗАБРАТЬ БОНУС</size>";
        public string GetShop = "shop.gamestores.ru";

        private void LoadDefaultConfig()
        {
            GetConfig("Настройки", "Секретный ключ магазина (SECRET.KEY GameStores)", ref secret);
            GetConfig("Настройки", "ID магазина (SHOP.ID GameStores)", ref shopId);
            GetConfig("Настройки", "Курс 1 бонуса (руб)", ref amount1);
            GetConfig("Настройки", "Время активности на сервере за какое выдаеться бонус (минуты)", ref GameActive);
            GetConfig("Настройки", "Название магазина", ref GetShop);
            GetConfig("Настройки", "Включить логирование обмена средств", ref LogsPlayer);
            GetConfig("Настройки", "У Вас магазин Moscow.ovh (true = да, false = GameStores)", ref MoscowStore);

            GetConfig("Сообщения", "Включить сообщение о выдаче бонуса игроку в чат", ref EnableMsg);

            GetConfig("GUI Баланс", "Включить панель баланса", ref EnableGUIPlayer);
            GetConfig("GUI Баланс", "Anchor Min", ref EnableGUIPlayerMin);
            GetConfig("GUI Баланс", "Anchor Max", ref EnableGUIPlayerMax);
            SaveConfig();
        }

        private void GetConfig<T>(string menu, string Key, ref T var)
        {
            if (Config[menu, Key] != null)
            {
                var = (T)Convert.ChangeType(Config[menu, Key], typeof(T));
            }
            Config[menu, Key] = var;
        }

        #endregion

        #region COMMANDS
        [ChatCommand("bonus")]
        void cmdChatBonus(BasePlayer player, string command, string[] args)
        {
            if (data.StoreData[player.userID].Bonus == 0)
            {

                var resetTime = (GameActive * 60);
                var TimerBonus = (resetTime / 60);
                SendReply(player, $"<size=15>У вас нету бонусов =(\nИграйте и получайте их только у нас!\nЗа <color=#A6FFAC>{TimerBonus} мин. </color>активной игры вы получаете <color=#A6FFAC>1 бонус</color>.</size>");
                return;
            }
            if (args.Count() == 0)
            {
                DrawUI(player);
                return;
            }
            if (args.Count() == 1)
            {
                SendReply(player, "Вы не правильно ввели команду.\nИспользуйте /bonus или /bonus get Кол-ство или /bonus get all");
                return;
            }
            if (args[0] == "get")
            {

                if (args[1] == "all")
                {
                    int amount2 = (data.StoreData[player.userID].Bonus * amount1);
                    if (MoscowStore)
                    {
                        APIChangeUserBalance(player.userID, amount2, null);
                    }
                    if (!MoscowStore)
                    {
                        MoneyPlus(player.userID, amount2);
                    }
                    SendReply(player, $"<size=15>Вы обменяли {data.StoreData[player.userID].Bonus} бон. на <color=RED>{amount2}</color> руб..\nДеньги зачислены на Ваш игровой счет в магазине</size>");
                    data.StoreData[player.userID].Bonus = data.StoreData[player.userID].Bonus = 0;
                    return;
                }

                int amounts;
                if (!int.TryParse(args[1], out amounts))
                {
                    SendReply(player, "Необходимо ввести число!");
                    return;
                }
                if (amounts <= 0)
                {
                    SendReply(player, "Необходимо ввести положительное число больше 0!");
                    return;
                }
                int amounts1 = (amounts * amount1);
                if (data.StoreData[player.userID].Bonus < amounts)
                {
                    SendReply(player, $"<size=15>У вас не хватает бонусов. На балансе: {data.StoreData[player.userID].Bonus}</size>");
                    return;
                }
                if (MoscowStore)
                {
                    APIChangeUserBalance(player.userID, amounts1, null);
                }
                if (!MoscowStore)
                {
                    MoneyPlus(player.userID, amounts1);
                }
                data.StoreData[player.userID].Bonus = data.StoreData[player.userID].Bonus - amounts;
                SendReply(player, $"<size=15>Вы обменяли {amounts} бон. на {amounts1} руб. Осталось: {data.StoreData[player.userID].Bonus}.\nДеньги зачислены на Ваш игровой счет в магазине</size>");
                if (LogsPlayer)
                {
                    logs.Add(new Counts(player));
                    if (LogsPlayer)
                    {
                        LogToFile("log", $"ID:{logs.Count - 1} ({DateTime.Now.ToShortTimeString()}) {player.displayName} ({player.userID}) обменял  {amounts} бон. на {amounts1} руб", this);
                    }
                }
            }
        }

        [ConsoleCommand("bonus.plus")]
        void cmdStoreBonusAdd(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (arg.Connection != null) return;

            if (arg.Args.Length != 2)
            {
                SendReply(arg, $"YOU NEED WRITE 2 PARAMS");
                return;
            }

            ulong userid;
            if (!ulong.TryParse(arg.Args[0], out userid))
            {
                SendReply(arg, $"FIRST PARAM NEED BE AS STEAM_ID");
                return;
            }
            int amount;
            if (!int.TryParse(arg.Args[1], out amount))
            {
                SendReply(arg, $"SECOND PARAM NEED BE AS AMOUNT");
                return;
            }
            data.StoreData[userid].Bonus = data.StoreData[userid].Bonus + amount;
            Puts($"Игроку {userid} выдано бонусов: {amount}. Текущий баланс: {data.StoreData[userid].Bonus}");
            LogToFile("logConsoleBonus", $"({DateTime.Now.ToShortTimeString()}) Игроку {userid} выдано бонусов: {amount}. Текущий баланс: {data.StoreData[userid].Bonus}", this);
            SaveData();
        }

        [ConsoleCommand("bonus.minus")]
        void cmdStoreBonusRemove(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null) return;

            if (arg.Args.Length != 2)
            {
                SendReply(arg, $"YOU NEED WRITE 2 PARAMS");
                return;
            }

            ulong userid;
            if (!ulong.TryParse(arg.Args[0], out userid))
            {
                SendReply(arg, $"FIRST PARAM NEED BE AS STEAM_ID");
                return;
            }
            int amount;
            if (!int.TryParse(arg.Args[1], out amount))
            {
                SendReply(arg, $"SECOND PARAM NEED BE AS AMOUNT");
                return;
            }
            if (data.StoreData[userid].Bonus < amount)
            {
                Puts("У игрока нету столько бонусов, у него: " + data.StoreData[userid].Bonus);
                return;
            }
            data.StoreData[userid].Bonus = data.StoreData[userid].Bonus - amount;
            Puts($"Игроку {userid} удалено бонусов: {amount}. Текущий баланс: {data.StoreData[userid].Bonus}");
            LogToFile("logConsoleBonus", $"({DateTime.Now.ToShortTimeString()}) Игроку {userid} удалено бонусов: {amount}. Текущий баланс: {data.StoreData[userid].Bonus}", this);
            SaveData();
        }

        [ConsoleCommand("money.plus")]
        void cmdStoreMoneyAdd(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null) return;
            if (arg.Args.Length != 2)
            {
                SendReply(arg, $"YOU NEED WRITE 2 PARAMS");
                return;
            }
            ulong userid;
            if (!ulong.TryParse(arg.Args[0], out userid))
            {
                SendReply(arg, $"FIRST PARAM NEED BE AS STEAM_ID");
                return;
            }
            int amount;
            if (!int.TryParse(arg.Args[1], out amount))
            {
                SendReply(arg, $"SECOND PARAM NEED BE AS AMOUNT");
                return;
            }
            if (MoscowStore)
            {
                APIChangeUserBalance(userid, amount, null);
            }
            if (!MoscowStore)
            {
                MoneyPlus(userid, amount);
            }
            Puts($"Игроку {userid} выдано рублей: {amount}");
            LogToFile("logConsoleMoney", $"({DateTime.Now.ToShortTimeString()}) Игроку {userid} выдано рублей: {amount}", this);

        }

        [ConsoleCommand("money.minus")]
        void cmdStoreMoneyRemove(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null) return;

            if (arg.Args.Length != 2)
            {
                SendReply(arg, $"YOU NEED WRITE 2 PARAMS");
                return;
            }
            var reply = 0;
            ulong userid;
            if (!ulong.TryParse(arg.Args[0], out userid))
            {
                SendReply(arg, $"FIRST PARAM NEED BE AS STEAM_ID");
                return;
            }
            int amount;
            if (!int.TryParse(arg.Args[1], out amount))
            {
                SendReply(arg, $"SECOND PARAM NEED BE AS AMOUNT");
                return;
            }
            if (MoscowStore)
            {
                APIChangeUserBalance(userid, amount, null);
            }
            if (!MoscowStore)
            {
                MoneyMinus(userid, amount);
            }
            Puts($"Игроку {userid} снято рублей: {amount}");
            LogToFile("logConsoleMoney", $"({DateTime.Now.ToShortTimeString()}) Игроку {userid} снято рублей: {amount}", this);
        }

        [ConsoleCommand("bonusclose")]
        void CmdDestroyGui(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            DestroyUI(player);
        }
        [ConsoleCommand("drawui")]
        void DrawUIPlayer(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            DrawUI(player);
        }
        [ConsoleCommand("acceptclose")]
        void CmdDestroyGuiAccept(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            DestroyUIAccept(player);
        }


        [ConsoleCommand("bonus.accept")]
        void CmdBonusGetAllAccept(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            DestroyUIAccept(player);
            DrawUIAccept(player);
        }

        [ConsoleCommand("bonus.getall")]
        void CmdBonusGetAll(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (!player)
            {
                SendReply(arg, "Может быть вызвана только в игре!");
                return;
            }

            var resetTime = (GameActive * 60);
            var TimerBonus = (resetTime / 60);
            if (data.StoreData[player.userID].Bonus == 0)
            {
                SendReply(player, $"<size=15>У Вас нету бонусов =(\nИграйте и получайте их только у нас!\nЗа <color=#A6FFAC>{TimerBonus} мин. </color>активной игры вы получаете <color=#A6FFAC>1 бонус</color>.</size>");
                return;
            }
            int amount2 = (data.StoreData[player.userID].Bonus * amount1);
            if (MoscowStore)
            {
                APIChangeUserBalance(player.userID, amount2, null);
            }
            if (!MoscowStore)
            {
                MoneyPlus(player.userID, amount2);
            }
            SendReply(player, $"<size=15>Вы обменяли {data.StoreData[player.userID].Bonus} бон. на {amount2} руб.\nДеньги зачислены на Ваш игровой счет в магазине</size>");
            DestroyUI(player);
            if (LogsPlayer)
            {
                int amount3 = (data.StoreData[player.userID].Bonus * amount1);
                logs.Add(new Counts(player));
                if (LogsPlayer)
                {
                    LogToFile("log", $"ID:{logs.Count - 1} ({DateTime.Now.ToShortTimeString()}) {player.displayName} ({player.userID}) обменял {data.StoreData[player.userID].Bonus} бон. на {amount2} руб", this);
                }
            }
            data.StoreData[player.userID].Bonus = data.StoreData[player.userID].Bonus = 0;
        }
        #endregion

        #region UI
        void DrawUIBalance(BasePlayer player, int seconds)
        {
            CuiHelper.DestroyUi(player, "OpenBonus");

            int Balance = (data.StoreData[player.userID].Bonus);
            CuiElementContainer Container = new CuiElementContainer();
            CuiElement OpenBonus = new CuiElement
            {
                Name = "OpenBonus",
                Parent = "UIPlayer",
                Components =
                {
                    new CuiTextComponent {
                        Text = $"<size=15><color=#D3D3D3>Баланс бонусов: <color=#ECBE13>{Balance}</color></color></size>\n<size=14><color=#D3D3D3>Следующий бонус через <color=#ECBE13>{GetFormatTime(seconds)}</color></color></size>",
                        Align = TextAnchor.MiddleCenter,
                        Color = "1 1 1 1",
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0.13 0",
                        AnchorMax = "1 1"
                    },
                        new CuiOutlineComponent {
                            Color = "0 0 0 0.5",
                            Distance = "1.0 -0.5"
                        }
                }
            };
            Container.Add(OpenBonus);
            CuiHelper.AddUi(player, Container);

        }

        void DrawUIGetBonus(BasePlayer player)
        {
            DrawUIPlayer(player);
            CuiHelper.DestroyUi(player, "OpenBonus");
            CuiElementContainer Container = new CuiElementContainer();

            CuiElement GetBonus = new CuiElement
            {
                Name = "GetBonus",
                Parent = "UIPlayer",
                Components =
                {
                    new CuiButtonComponent
                    {
                        Command = "getbonus",
                        Color = GUIEnabledColor,
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                }
            };
            CuiElement TextGetBonus = new CuiElement
            {
                Name = "TextGetBonus",
                Parent = "GetBonus",
                Components =
                {
                    new CuiTextComponent {
                        Text = GUIEnabledText,
                        Align = TextAnchor.MiddleCenter
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    },
                        new CuiOutlineComponent {
                            Color = "0 0 0 0.5", Distance = "1.0 -0.5"

                        }
                }
            };
            Container.Add(GetBonus);
            Container.Add(TextGetBonus);
            CuiHelper.AddUi(player, Container);

        }

        void DrawUIPlayer(BasePlayer player)
        {

            DestroyUIPlayer(player);
            CuiElementContainer Container = new CuiElementContainer();
            CuiElement BonusIcon = new CuiElement
            {
                Name = "BonusIcon",
                Parent = "UIPlayer",
                Components = {
                        new CuiRawImageComponent {
                            Url = "http://rustplugin.ru/info/iconUI.png",
                            Color = "0.75 0.75 0.75 1.00"
                        },
                        new CuiRectTransformComponent {
                        AnchorMin = "0.02 0.2",
                        AnchorMax = "0.095 0.75"
                        }
                }
            };
            CuiElement BPUI = new CuiElement
            {
                Name = "BPUI",
                Parent = "UIPlayer",
                Components = {
                        new CuiImageComponent {
                            Color = "0 0 0 0.8"
                        },
                        new CuiRectTransformComponent {
                             AnchorMin = "0 0",
                        AnchorMax = "0.12 0.98"
                        }
                    }
            };
            CuiElement UIPlayer = new CuiElement
            {
                Name = "UIPlayer",
                Parent = "Hud",
                Components =
                {
                    new CuiButtonComponent
                    {
                        Command = "drawui",
                        Color = "0.75 0.75 0.75 0.2",
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = EnableGUIPlayerMin,
                        AnchorMax = EnableGUIPlayerMax
                    }
                }
            };

            Container.Add(UIPlayer);
            Container.Add(BPUI);
            Container.Add(BonusIcon);
            CuiHelper.AddUi(player, Container);

            var resetTime = (GameActive * 60);
            if (EnableGUIPlayer)
            {
                DrawUIBalance(player, resetTime);
            }

        }

        void DrawUIAccept(BasePlayer player)
        {
            int amount2 = (data.StoreData[player.userID].Bonus * amount1);
            CuiElementContainer Container = new CuiElementContainer();
            CuiElement PlayerUI1 = new CuiElement
            {
                Name = "PlayerUI1",
                Parent = "ContainerUI",
                Components = {
                        new CuiImageComponent {
                            Color = "0.75 0.75 0.75 0.2"
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0.343 0.204",
                            AnchorMax = "0.635 0.725"
                        }
                    }

            };
            CuiElement BackGroundAccept = new CuiElement
            {
                Name = "BackgroundAccept",
                Parent = "Overlay",
                Components = {
                        new CuiImageComponent {
                            Color = "0 0 0 0.95"
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0.300 0.400",
                            AnchorMax = "0.700 0.550"
                        }
                    }
            };
            CuiElement BackgroundAcceptText = new CuiElement
            {
                Name = "BackgroundAcceptText",
                Parent = "BackgroundAccept",
                Components =
                {
                    new CuiTextComponent {
                        Text = $"<size=18>Вы действительно хотите обменять <color=#ECBE13>{data.StoreData[player.userID].Bonus}</color> бон. на <color=#ECBE13>{amount2}</color> руб ?</size>",
                        Align = TextAnchor.MiddleCenter
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0 0.6",
                        AnchorMax = "1 1"
                    },
                        new CuiOutlineComponent {
                            Color = "0 0 0 0.5", Distance = "1.0 -0.5"

                        }
                }
            };
            CuiElement CloseButton1 = new CuiElement
            {
                Name = "CloseButton1",
                Parent = "BackgroundAccept",
                Components =
                {
                    new CuiButtonComponent
                    {
                        Command = "acceptclose",
                        Color = "1.00 0.09 0.20 0.7",
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0.55 0.1",
                        AnchorMax = "0.8 0.5"
                    },
                    new CuiNeedsCursorComponent()
                }
            };
            CuiElement CloseButtonText1 = new CuiElement
            {
                Name = "CloseButtonText1",
                Parent = "CloseButton1",
                Components =
                {
                    new CuiTextComponent {
                        Text = $"<size=18>Отменить</size>",
                        Align = TextAnchor.MiddleCenter
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    },
                        new CuiOutlineComponent {
                            Color = "0 0 0 0.5", Distance = "1.0 -0.5"

                        }
                }
            };
            CuiElement AcceptButton = new CuiElement
            {
                Name = "AcceptButton",
                Parent = "BackgroundAccept",
                Components =
                {
                    new CuiButtonComponent
                    {
                        Command = "bonus.getall",
                        Color = "0.00 1.00 0.10 0.7",
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0.2 0.1",
                        AnchorMax = "0.5 0.5"
                    },
                    new CuiNeedsCursorComponent()
                }
            };
            CuiElement AcceptButtonText = new CuiElement
            {
                Name = "AcceptButtonText",
                Parent = "AcceptButton",
                Components =
                {
                    new CuiTextComponent {
                        Text = $"<size=18>Подтвердить</size>",
                        Align = TextAnchor.MiddleCenter
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    },
                        new CuiOutlineComponent {
                            Color = "0 0 0 0.5", Distance = "1.0 -0.5"

                        }
                }
            };
            Container.Add(PlayerUI1);
            Container.Add(BackGroundAccept);
            Container.Add(BackgroundAcceptText);
            Container.Add(CloseButton1);
            Container.Add(CloseButtonText1);
            Container.Add(AcceptButton);
            Container.Add(AcceptButtonText);
            CuiHelper.AddUi(player, Container);
        }

        void DrawUI(BasePlayer player)
        {
            int Hours = (data.StoreData[player.userID].GameTime * 60);
            int amount2 = (data.StoreData[player.userID].Bonus * amount1);
            CuiElementContainer Container = new CuiElementContainer();
            CuiElement ContainerUI = new CuiElement
            {
                Name = "ContainerUI",
                Parent = "Hud",
                Components = {
                        new CuiImageComponent {
                            Color = "0 0 0 0"
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1"
                        },
                        new CuiNeedsCursorComponent()
                    }
            };
            CuiElement PlayerUI = new CuiElement
            {
                Name = "PlayerUI",
                Parent = "ContainerUI",
                Components = {
                        new CuiImageComponent {
                            Color = "0 0 0 0.75"
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0.343 0.204",
                            AnchorMax = "0.635 0.725"
                        }
                    }
            };

            CuiElement PlayerName = new CuiElement
            {
                Name = "PlayerName",
                Parent = "PlayerUI",
                Components = {
                        new CuiTextComponent {
                            Text = $"<color=#ECBE13><size=20>СИСТЕМА БОНУСОВ</size></color>\n\n<size=24>{player.displayName}</size>\nВремя на сервере: <color=#ECBE13>{FormatTime(TimeSpan.FromSeconds(Hours))}</color>\n\n<size=17>Бонусов на балансе: <color=#ECBE13>{data.StoreData[player.userID].Bonus}</color></size>\n<size=12>(Вы сможете получить по текущему курсу <color=#ECBE13>{amount2} руб.</color>)</size>\n\nКурс бонусов на сегодня: <color=#ECBE13>1 бонус = {amount1} руб.</color>\nЧто бы обменять бонусы, нажмите ОБМЕНЯТЬ!\n\n\n\n\n\n\n\nЧто бы обменять определенное количество введите в чате:\n<color=#ECBE13>/bonus get Количество</color>",
                            Align = TextAnchor.UpperCenter
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0 0",
                            AnchorMax = "1 0.95"
                        },
                        new CuiOutlineComponent {
                            Color = "0 0 0 0.5", Distance = "1.0 -0.5"
                        }
                    }
            };
            CuiElement CloseButton = new CuiElement
            {
                Name = "CloseButton",
                Parent = "PlayerUI",
                Components =
                {
                    new CuiButtonComponent
                    {
                        Command = "bonusclose",
                        Color = "0 0 0 0.5",
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0.868 0.87",
                        AnchorMax = "0.998 0.998"
                    },
                }
            };
            CuiElement CloseButtonText = new CuiElement
            {
                Name = "CloseButtonText",
                Parent = "CloseButton",
                Components =
                {
                    new CuiTextComponent {
                        Text = $"<size=18>X</size>",
                        Align = TextAnchor.MiddleCenter
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    },
                        new CuiOutlineComponent {
                            Color = "0 0 0 0.5", Distance = "1.0 -0.5"

                        }
                }
            };
            CuiElement Button = new CuiElement
            {
                Name = "Button",
                Parent = "PlayerUI",
                Components =
                {
                    new CuiButtonComponent
                    {
                        Command = "bonus.accept",
                        Color = "1.00 1.00 1.00 0.2",
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0.02 0.23",
                        AnchorMax = "0.98 0.4"
                    },

                }
            };
            CuiElement ButtonText = new CuiElement
            {
                Name = "ButtonText",
                Parent = "Button",
                Components =
                {
                    new CuiTextComponent {
                        Text = $"<size=19>Обменять все бонусы на <color=#ECBE13>{amount2} руб.</color></size>",
                        Align = TextAnchor.MiddleCenter
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    },
                        new CuiOutlineComponent {
                            Color = "0 0 0 0.7", Distance = "1.0 -0.5"

                        }
                }
            };

            Container.Add(ContainerUI);
            Container.Add(PlayerUI);
            Container.Add(PlayerName);
            Container.Add(CloseButton);
            Container.Add(CloseButtonText);
            Container.Add(Button);
            Container.Add(ButtonText);
            CuiHelper.AddUi(player, Container);
        }

        void DestroyUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "ContainerUI");
            CuiHelper.DestroyUi(player, "BackgroundAccept");
        }
        void DestroyUIPlayer(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "UIPlayer");
        }
        void DestroyUIAccept(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "BackgroundAccept");
            CuiHelper.DestroyUi(player, "PlayerUI1");
        }
        #endregion

        #region OXIDE HOOKS

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyUI(player);
                DestroyUIPlayer(player);
                DeactivateTimer(player);
            }
            SaveData();
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            DeactivateTimer(player);
        }


        void OnServerInitialized()
        {
            LoadDefaultConfig();
            StoreData = Interface.Oxide.DataFileSystem.GetFile("StoreBonus/StorePlayerData");
            LoadData();
            timer.Every(1f, GradeTimerHandler);
            foreach (var player in BasePlayer.activePlayerList)
            {
                OnPlayerInit(player);
            }

            mytimer = timer.Repeat(60f, 0, () =>
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    data.StoreData[player.userID].GameTime = data.StoreData[player.userID].GameTime + 1;
                }
            });

            var resetTime = (GameActive * 60);
            var TimerBonus = (resetTime / 60);
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (!player.IsSleeping())
                {
                    SaveData();
                    CuiHelper.DestroyUi(player, "OpenBonus");
                    if (data.StoreData[player.userID].EnabledBonus == 0)
                    {
                        if (EnableGUIPlayer)
                        {
                            DrawUIBalance(player, resetTime);
                        }
                    }
                }
            }
        }

        void LoadData()
        {
            logs = logsFile.ReadObject<List<Counts>>();

            try
            {
                data = Interface.GetMod().DataFileSystem.ReadObject<DataStorage>("StoreBonus/StorePlayerData");
            }

            catch
            {
                data = new DataStorage();
            }
        }

        void OnPlayerSleepEnded(BasePlayer player)
        {
            if (data.StoreData.ContainsKey(player.userID))
            {
                if (EnableGUIPlayer)
                {
                    DrawUIPlayer(player);
                }
                if (data.StoreData[player.userID].EnabledBonus != 0)
                {
                    DrawUIGetBonus(player);
                    return;
                }

            }
            else
            {
                OnPlayerInit(player);
            }
        }


        void SaveData()
        {
            logsFile.WriteObject(logs);
            StoreData.WriteObject(data);
        }

        void OnPlayerInit(BasePlayer player)
        {
            if (player == null) return;

            if (!data.StoreData.ContainsKey(player.userID))
            {
                data.StoreData.Add(player.userID, new STOREDATA()
                {
                    Name = player.displayName,
                    EnabledBonus = 0,
                    Bonus = 0,
                    GameTime = 0,
                });
                SaveData();
            }
            if (data.StoreData.ContainsKey(player.userID))
            {
                if (EnableGUIPlayer)
                {
                    DrawUIPlayer(player);
                }
            }
            if (data.StoreData[player.userID].Bonus > 0)
            {
                SendReply(player, "У вас есть не использованые бонусы!\nЧтобы их проверить наберите команду <color=#fee3b4>/bonus</color>");
            }
            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                data.StoreData[player.userID].Name = player.displayName.ToString();
            }

            if (data.StoreData[player.userID].EnabledBonus == 0)
            {
                UpdateTimer(player);
                ActivateTimer(player.userID);
            }
            else
            {
                DrawUIGetBonus(player);
            }

        }
        #endregion

        #region Money
        void APIChangeUserBalance(ulong steam, int balanceChange, Action<string> callback)
        {
            plugins.Find("RustStore").CallHook("APIChangeUserBalance", steam, balanceChange, new Action<string>((result) =>
            {
                if (result == "SUCCESS")
                {
                    if (LogsPlayer)
                    {
                        LogToFile("logWEB", $"ID:{logs.Count - 1} ({DateTime.Now.ToShortTimeString()}): Отправлен запрос пользователем {steam} на пополнение баланса в размере: {balanceChange}", this);
                    }
                    return;
                }
                if (LogsPlayer) { LogToFile("logError", $"ID:{logs.Count - 1} ({DateTime.Now.ToShortTimeString()}): Баланс не был изменен, ошибка: {result}", this); }
            }));
        }

        void MoneyPlus(ulong userId, int amount)
        {
            ExecuteApiRequest(new Dictionary<string, string>()
            {
                { "action", "moneys" },
                { "type", "plus" },
                { "steam_id", userId.ToString() },
                { "amount", amount.ToString() }
            });
        }

        void MoneyMinus(ulong userId, int amount)
        {
            ExecuteApiRequest(new Dictionary<string, string>()
            {
                { "action", "moneys" },
                { "type", "minus" },
                { "steam_id", userId.ToString() },
                { "amount", amount.ToString() }
            });
        }

        void ExecuteApiRequest(Dictionary<string, string> args)
        {
            string url = $"http://panel.gamestores.ru/api?shop_id={shopId}&secret={secret}" +
                     $"{string.Join("", args.Select(arg => $"&{arg.Key}={arg.Value}").ToArray())}";
            webrequest.EnqueueGet(url, (i, s) =>
            {
                if (i != 200)
                {
                    if (LogsPlayer)
                    {
                        LogToFile("logError", $"ID:{logs.Count - 1} ({DateTime.Now.ToShortTimeString()}): {url}\nCODE {i}: {s}", this);
                    }
                }
                else
                {
                    if (LogsPlayer)
                    {
                        LogToFile("logWEB", $"ID:{logs.Count - 1} ({DateTime.Now.ToShortTimeString()}): {s}", this);
                    }
                }
            }, this);
        }

        #endregion

        #region DATA

        class DataStorage
        {
            public Dictionary<ulong, STOREDATA> StoreData = new Dictionary<ulong, STOREDATA>();
            public DataStorage() { }
        }

        class STOREDATA
        {
            public string Name;
            public int EnabledBonus;
            public int Bonus;
            public int GameTime;
        }

        DataStorage data;

        private DynamicConfigFile StoreData;
        DynamicConfigFile logsFile = Interface.Oxide.DataFileSystem.GetFile("StoreBonus/StoreLogs");

        #endregion

    }
}
                    

// --- End of file: StoreBonus.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SmallDecay.cs ---
// --- Original Local Path: SmallDecay.cs ---

﻿using System.Collections.Generic;
using System.Linq;
using ConVar;
using Newtonsoft.Json;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("SmallDecay", "Sempai#3239", "0.0.1")]
    [Description("Гниение Mercury")]
    class SmallDecay : RustPlugin
    {
        #region Reference
        [PluginReference] Plugin IQChat;
        public void SendChat(BasePlayer player, string Message, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            if (IQChat)
                IQChat?.Call("API_ALERT_PLAYER", player, Message);
            else player.SendConsoleCommand("chat.add", channel, 0, Message);
        }
        #endregion

        #region Configuration

        private static Configuration config = new Configuration();
        private class Configuration
        {
            [JsonProperty("Через сколько времени снимать ХП смоллтешу(секунды)")]
            public int DecayTime;
            [JsonProperty("Сколько ХП снимать соллтешу(У тайника - 150 ХП)")]
            public int DecayDamage;
            [JsonProperty("Сообщение игроку")]
            public string MessagePlayer;

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                   DecayTime = 10,
                   DecayDamage = 1,
                   MessagePlayer = "Ваш тайник будет гнить каждые 3462 секунд",
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning("Ошибка #175" + $"чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию! #138");
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        public List<StashContainer> SmollData = new List<StashContainer>();

        #region Hooks
        void OnEntitySpawned(BaseNetworkable entity)
        {
            var Stash = entity?.GetComponent<StashContainer>();
            if (Stash == null) return;
            DecayWrite(Stash);
        }
        void OnEntityKill(BaseNetworkable entity)
        {
            var Stash = entity?.GetComponent<StashContainer>();
            if (Stash == null) return;
            SmollData.Remove(Stash);
        }
        private void OnServerInitialized()
        {
            SmollData = UnityEngine.Object.FindObjectsOfType<StashContainer>().ToList();
            PrintWarning($"Найдено {SmollData.Count} тайников. Начинается гниение");
            DecayStart();
        }
        #endregion

        void DecayStart()
        {
            timer.Every(config.DecayTime, () =>
            {
                if (SmollData.Count == 0) return;
                for(int i = 0; i < SmollData.Count; i++)
                {
                    var Stash = SmollData[i];
                    Stash.health -= config.DecayDamage;
                    if (Stash.health <= 0)
                    {
                        SmollData.Remove(Stash);
                        Stash.Kill();
                    }
                }
            });
        }

        void DecayWrite(StashContainer stash)
        {
            if (stash == null) return;
            var player = BasePlayer.FindByID(stash.OwnerID);
            if(player == null)
            {
                PrintError("R");
                return;
            }
            SmollData.Add(stash);
            SendChat(player, config.MessagePlayer);
        }
    }
}


// --- End of file: SmallDecay.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/1RatesController.cs ---
// --- Original Local Path: 1RatesController.cs ---

using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("RatesController", "Vlad-00003", "2.2.4")]
    [Description("Rate and Time controller - can change rates based on current game time")]
    /*
     * Author info:
     *   E-mail: Vlad-00003@mail.ru
     *   Vk: vk.com/vlad_00003
     * v2.1.2:
     *   Оптимизирована функция создания стандартных привелегий
     *   Опитмизирована функия получения текущих рейтов игрока
     * v2.1.3
     *   Исправлена NRE OnEntityTakeDamage в случае, если урон наносился не игроком(огонь от разрывных к примеру)
     *   Улучшение производительности - если Множители лута выключена - плагин полностью отписывается от хуков.
     *   При атаке игроком Аэрдропа лут больше не обновляется.
     * v2.1.4
     *   Небольшая переработка кода, исправлена ошибка при компиляции.
     *   теперь лут в бочках будет умножаться при разрушении бочки, а не при ударе.
     * v2.1.5
     *   Исправлена небольшая ошибка, из-за которой даже при выключенном множетеле лута множитель всё равно работал
     * v2.1.6
     *   Временный фикс ошибки, связанной с изменившемися id предметов
     * v2.1.7
     *   Исправлено ускорение работы печей, а так же настройка "Стандартное время переработки ресурсов (в секундах)"
     * v2.1.8
     *   ИСправлен дюп с умножением предметов по рейтам
     * v2.2.0
     *   Изменён принцип работы списка предметов, на который не действуют множители. Добавлен переключатель, который определяет режим работы списка -"Чёрный или белый список?".
     *      При установке значения в true (изначальное) - список будет функционировать как раньше - как чёрный.
     *        т.е. множители лута будут действовать на всё, кроме внесённого в список.
     *      При установке значения в false - список будет функционировать как белый.
     *        т.е. множители лута будут действовать ТОЛЬКО на то, что внесено в список.
     *   Содержимое старого списка будет автоматически перенесено в новый.
     */

    class RatesController : RustPlugin
    {
        private bool isDay;

        private string PickUpDayString = "Рейт поднимаемых ресурсов днём";
        private string PickUpNightString = "Рейт поднимаемых ресурсов ночью";
        private string GatherDayString = "Рейт добываемых ресурсов днём";
        private string GatherNightString = "Рейт добываемых ресурсов ночью";
        private string QuerryDayString = "Рейт добываемых ресурсов в карьере днём";
        private string QuerryNightString = "Рейт добываемых ресурсов в карьере ночью";
        private string LootDayString = "Рейт лута днём(если включен)";
        private string LootNightString = "Рейт лута ночью(если включен)";
        private string SmeltDayString = "Скорость работы печей днём";
        private string SmeltNightString = "Скорость работы печей ночью";
        private ItemDefinition hqmo;

        private string DefaultRatesCfg = "Общие рейты ресурсов";
        private string CustomRatesCfg = "Изменение рейтов для игроков с привилегиями";
        private string DefaultPickupRatesCfg = "Стандартные рейты поднимаемых ресурсов";
        private string DefaultGatherRatesCfg = "Стандартные рейты добываемых ресурсов";
        private string DefaultSmeltRatesCfg = "Стандартное время переработки ресурсов (в секундах)";
        private string DefaultQuerryRatesCfg = "Стандартные рейты добываемых ресурсов в карьере";
        private string PrefixCfg = "Префикс в чате";
        private string PrefixColorCfg = "Цвет префикса в чате";
        private string UseLootMultyplierCfg = "Использовать умножение лута(выключите для совместимости с контроллерами лута)";
        private string BlacklistedLootCfgOld = "Список лута, на который не действуют множители";
        private string ListedLootCfg = "Список лута";
        private string IsBlacklistCfg =
            "Чёрный или белый список? (true - чёрный - множители действуют на всё, кроме внесённого)";
        private string DayStartCfg = "Час начала дня(игровое время)";
        private string DayLenghtCfg = "Длина дня(в минутах)";
        private string NightStartCfg = "Час начала ночи(игровое время)";
        private string NightLenghtCfg = "Длина ночи(в минутах)";
        private string WarnChatCfg = "Выводить сообщения в чат о начале дня или ночи";
        private string CoalRateDayCfg = "Рейт угля при сжигании дерева днём";
        private string CoalRateNightCfg = "Рейт угля при сжигании дерева ночью";
        private string CoalChanceDayCfg = "Шанс производства угля днём";
        private string CoalChanceNightCfg = "Шанс производства угля ночью";
        private string MoreHQMCfg = "Добавить металл высокого качества во все рудные жилы";

        private List<string> AvaliableMods;
        private Dictionary<string, float> SmeltBackup = new Dictionary<string, float>();
        //Откат обновления ящиков
        Dictionary<uint, EntityLootetrs> CratesCD = new Dictionary<uint, EntityLootetrs>();

        private class EntityLootetrs
        {
            public List<ulong> Looters;
            public DateTime NextUpdate;

            public EntityLootetrs()
            {
                Looters = new List<ulong>();
            }
            
            public bool IsUpdateBlocked(BasePlayer player)
            {
                if (NextUpdate > DateTime.UtcNow)
                    return true;
                if (player?.userID == null)
                    return true;
                return Looters.Contains(player.userID);
            }
            public void AddLooter(ulong looter, int minutes = 2)
            {
                Looters.Add(looter);
                NextUpdate = DateTime.UtcNow.AddMinutes(minutes);
            }
        }

        //Список рудных жил и их бонусов
        //Dictionary<BaseEntity, Dictionary<string, float>> DefaultFinishBonuses = new Dictionary<BaseEntity, Dictionary<string, float>>();

        private double CoalRate = 1f;
        private int CoalChance = 25;
        private double SmeltRate = 1f;
        private double GatherRate = 1f;
        private double PickupRate = 1f;
        private double QuerryRate = 1f;
        private double LootRate = 1f;

        #region config setup

        private string Prefix = "[Rates controller]";//Префикс плагина в чате
        private bool UseLootMultyplier = true; //Использовать множители лута
        private string PrefixColor = "#ff0000";//Цвет префикса
        private float DayStart = 6f;//Час, когда начинается день
        private float NightStart = 18f;//Час, когда начинается ночь
        private uint DayLenght = 30u;//Длинна дня
        private uint NightLenght = 30u;//Длинна ночи
        private bool WarnChat = true;//Выводить ли в чат оповещения о смене дня\ночи и рейтов.
        private bool MoreHQM = true; //Добавить ли во все рудные жилы мвк?

        //Стандартные рейты, для игроков без привелегий
        private Dictionary<string, double> DefaultRates = new Dictionary<string, double>();
        //Рейты для игроков с привелегиями
        private Dictionary<string, Dictionary<string, double>> CustomRates = new Dictionary<string, Dictionary<string, double>>();

        private double CoalRateDay = 1f;
        private double CoalRateNight = 1f;
        private int CoalChanceDay = 25;
        private int CoalChanceNight = 25;
        private Dictionary<string, double> DefaultSmeltRates = new Dictionary<string, double>();
        private Dictionary<string, double> DefaultGatherRates = new Dictionary<string, double>();
        private Dictionary<string, double> DefaultPickupRates = new Dictionary<string, double>();
        private Dictionary<string, double> DefaultQuerryRates = new Dictionary<string, double>();
        private List<string> ListedLoot = new List<string>();
        private bool IsBlackList = true;

        #endregion

        #region Loading config

        //Загрузка стандартного конфиг-файла. Вызывается ТОЛЬКО в случае отсутствия файла PluginName.json в папке config
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Благодарим за приобритение плагина на сайте RustPlugin.ru.\n Если вы приобрели плагин в другом месте - вы теряете все гарантии.");
        }

        void LoadConfigValues()
        {
            AvaliableMods = new List<string>()
            {
                GatherDayString,
                GatherNightString,
                PickUpDayString,
                PickUpNightString,
                QuerryDayString,
                QuerryNightString,
                LootDayString,
                LootNightString,
                SmeltDayString,
                SmeltNightString
            };
            Dictionary<string, object> defaultRates = CreatePerms(AvaliableMods, 1f);
            Dictionary<string, object> customRates = new Dictionary<string, object>()
            {
                ["ratescontroller.premium"] = CreatePerms(AvaliableMods, 3f),
                ["ratescontroller.vip"] = CreatePerms(AvaliableMods, 2f)
            };
            Dictionary<string, object> defaultGatherRates = new Dictionary<string, object>()
            {
                { "Animal Fat", 1.0},
                {"Bear Meat", 1.0},
                {"Bone Fragments", 1.0},
                {"Cloth", 1.0},
                {"High Quality Metal Ore", 1.0},
                {"Human Skull", 1.0},
                {"Leather", 1.0},
                {"Metal Ore", 1.0},
                {"Pork", 1.0},
                {"Raw Chicken Breast", 1.0},
                {"Raw Human Meat", 1.0},
                {"Raw Wolf Meat", 1.0},
                {"Stones", 1.0},
                {"Sulfur Ore", 1.0},
                {"Wolf Skull", 1.0},
                {"Wood", 1.0},
                {"Raw Deer Meat", 1.0 },
                {"Cactus Flesh", 1.0 }
            };
            Dictionary<string, object> defaultPickupRates = new Dictionary<string, object>()
            {
                {"Metal Ore", 1.0},
                {"Stones", 1.0},
                {"Sulfur Ore", 1.0},
                {"Wood", 1.0},
                {"Hemp Seed", 1.0},
                {"Corn Seed", 1.0},
                {"Pumpkin Seed", 1.0},
                {"Cloth", 1.0},
                {"Pumpkin", 1.0},
                {"Corn", 1.0},
                {"Wolf Skull", 1.0}
            };
            Dictionary<string, object> defaultQuerryRates = new Dictionary<string, object>()
            {
                {"High Quality Metal Ore", 1.0},
                {"Metal Fragments", 1.0},
                {"Metal Ore", 1.0},
                {"Stones", 1.0},
                {"Sulfur Ore", 1.0}
            };
            List<object> listedLoot = new List<object>()
            {
                "Rotten Apple",
                "Spoiled Wolf Meat",
                "Spoiled Chicken",
                "Spoiled Human Meat"
            };
            Dictionary<string, object> defaultSmeltRates = new Dictionary<string, object>();
            //var itemDefinitions = ItemManager.itemList;
            var itemDefinitions = ItemManager.GetItemDefinitions();
            foreach (var item in itemDefinitions)
            {
                // Записываем стандартные рейты готовки
                var cookable = item.GetComponent<ItemModCookable>();
                if (cookable == null) continue;
                defaultSmeltRates.Add(item.displayName.english, cookable.cookTime);
                SmeltBackup.Add(item.displayName.english, cookable.cookTime);
            }
            //Older version compatibility
            if (Config[BlacklistedLootCfgOld] != null)
            {
                //PrintWarning("Old config detected. Getting old values....");
                GetConfig(BlacklistedLootCfgOld, ref listedLoot);
                //PrintWarning("Got values: {0}",string.Join(" | ",listedLoot.Select(x => x.ToString())));
                Config.Remove(BlacklistedLootCfgOld);
                //PrintWarning("Old config var removed");
            }

            //PrintWarning("Getting value by the new address with data: {0}",
            //    string.Join(" | ", listedLoot.Select(x => x.ToString())));
            GetConfig(ListedLootCfg,ref listedLoot);
            //PrintWarning("Got values: {0}", string.Join(" | ", listedLoot.Select(x => x.ToString())));

            GetConfig(IsBlacklistCfg,ref IsBlackList);
            GetConfig(DefaultRatesCfg, ref defaultRates);
            GetConfig(CustomRatesCfg, ref customRates);
            GetConfig(DefaultPickupRatesCfg, ref defaultPickupRates);
            GetConfig(DefaultGatherRatesCfg, ref defaultGatherRates);
            GetConfig(DefaultSmeltRatesCfg, ref defaultSmeltRates);
            GetConfig(DefaultQuerryRatesCfg, ref defaultQuerryRates);
            GetConfig(PrefixCfg, ref Prefix);
            GetConfig(PrefixColorCfg, ref PrefixColor);
            GetConfig(UseLootMultyplierCfg, ref UseLootMultyplier);
            GetConfig(DayStartCfg, ref DayStart);
            GetConfig(DayLenghtCfg, ref DayLenght);
            GetConfig(NightStartCfg, ref NightStart);
            GetConfig(NightLenghtCfg, ref NightLenght);
            GetConfig(WarnChatCfg, ref WarnChat);
            GetConfig(CoalRateDayCfg, ref CoalRateDay);
            GetConfig(CoalRateNightCfg, ref CoalRateNight);
            GetConfig(CoalChanceDayCfg, ref CoalChanceDay);
            GetConfig(CoalChanceNightCfg, ref CoalChanceNight);
            GetConfig(MoreHQMCfg, ref MoreHQM);
            SaveConfig();

            ListedLoot = listedLoot.Select(x => x.ToString()).ToList();

            foreach (var item in defaultRates)
            {
                double mod;
                if (!double.TryParse(item.Value.ToString(), out mod))
                {
                    PrintWarning($"Default rates for {item.Key} is incorrect and will not work until it will be resolved.");
                    continue;
                }
                DefaultRates.Add(item.Key, mod);
            }

            foreach (var item in customRates)
            {
                Dictionary<string, object> perms = (Dictionary<string, object>)item.Value;
                Dictionary<string, double> Perms = new Dictionary<string, double>();
                foreach (var p in perms)
                {
                    double mod;
                    if (!double.TryParse(p.Value.ToString(), out mod))
                    {
                        PrintWarning($"Custom rates for {item.Key} - {p.Key} is incorrect and will not work until it will be resolved.");
                        continue;
                    }
                    Perms.Add(p.Key, mod);
                }
                CustomRates.Add(item.Key, Perms);
            }

            foreach (var item in defaultGatherRates)
            {
                double mod;
                if (!double.TryParse(item.Value.ToString(), out mod))
                {
                    PrintWarning($"Default gather rates for {item.Key} is incorrect and will not work until it will be resolved.");
                    continue;
                }
                DefaultGatherRates.Add(item.Key, mod);
            }

            foreach (var item in defaultPickupRates)
            {
                double mod;
                if (!double.TryParse(item.Value.ToString(), out mod))
                {
                    PrintWarning($"Default pickup rates for {item.Key} is incorrect and will not work until it will be resolved.");
                    continue;
                }
                DefaultPickupRates.Add(item.Key, mod);
            }

            foreach (var item in defaultQuerryRates)
            {
                double mod;
                if (!double.TryParse(item.Value.ToString(), out mod))
                {
                    PrintWarning($"Default quarry rates for {item.Key} is incorrect and will not work until it will be resolved.");
                    continue;
                }
                DefaultQuerryRates.Add(item.Key, mod);
            }

            foreach (var item in defaultSmeltRates)
            {
                double mod;
                if (!double.TryParse(item.Value.ToString(), out mod))
                {
                    PrintWarning($"Default smelt rates for {item.Key} is incorrect and will not work until it will be resolved.");
                    continue;
                }
                DefaultSmeltRates.Add(item.Key, mod);
            }

        }
        #endregion

        #region localization
        void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["LootRate"] = "Loot from lootboxes x{rates}\n",
                ["CoalRate"] = "Coal producing rates is x{rates}\n",
                ["No Permission"] = "You don't have permission to use this command.",
                ["Day Starts"] = "The Day is starting!\n",
                ["Night Starts"] = "The Night is starting!\n",
                ["PickupRates"] = "Pickup rates was changed to x{rates}\n",
                ["GatherRates"] = "Gather rates was changed to x{rates}\n",
                ["QuerryRates"] = "Quarry gathering rate was changed to x{rates}\n",
                ["Smelt Rate"] = "Smelt Rate was changed to x{rates}\n",
                ["PersonalRates"] = "Your personal rates:\n",
                ["PickUpRatesPers"] = "Your personal Pickup rates is x{rates}\n",
                ["GatherRatesPers"] = "Your personal Gather rates is x{rates}\n",
                ["QueryPers"] = "Your personal Query rates is x{rates}\n",
                ["SmeltPers"] = "Your personal Smelt rates is x{rates}\n",
                ["LootPers"] = "Your personal Loot rates is x{rates}"
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["LootRate"] = "Рейты лута x{rates}\n",
                ["CoalRate"] = "Рейты производства угля x{rates}\n",
                ["No Permission"] = "Недостаточно прав на выполнение данной команды.",
                ["Day Starts"] = "Начинается день!\n",
                ["Night Starts"] = "Начинается ночь!\n",
                ["PickupRates"] = "Рейты подбираемых предметов x{rates}\n",
                ["GatherRates"] = "Рейты добычи изменены на x{rates}\n",
                ["QuerryRates"] = "Рейты добычи ресурсов в карьерах изменены на x{rates}\n",
                ["Smelt Rate"] = "Скорость работы печей x{rates}\n",
                ["PersonalRates"] = "Ваши личные рейты:\n",
                ["PickUpRatesPers"] = "Рейты подбираемых предметов x{rates}\n",
                ["GatherRatesPers"] = "Рейты добычи x{rates}\n",
                ["QueryPers"] = "Рейты работы карьера x{rates}\n",
                ["SmeltPers"] = "Рейты переплавки x{rates}\n",
                ["LootPers"] = "Рейты лута x{rates}"
            }, this, "ru");
        }
        #endregion

        #region initializing
        void OnServerInitialized()
        {
            //Загружаем конфиг из файла
            LoadConfigValues();

            //Подгружаем данные локализации
            LoadMessages();
            hqmo = ItemManager.FindItemDefinition("hq.metal.ore");
            if (!UseLootMultyplier)
            {
                Unsubscribe("OnContainerDropItems");
                Unsubscribe("OnLootEntity");
            }
            //Инициализируем управление временем - получаем компоненту времени
            timer.Once(3, GetTimeComponent);

            foreach (var perm in CustomRates.Keys)
            {
                permission.RegisterPermission($"{perm}".ToLower(), this);
                //PrintWarning($"{Title}.{perm}".ToLower());
            }
            var curtime = covalence.Server.Time;
            //Если при старте на сервере день - ставим в false, дабы вызывалось событие OnDayStart()
            isDay = (!(DayStart <= curtime.Hour) || !(curtime.Hour < NightStart));

            UpdateFurnaces();
        }

        //Вызывается при выгрузке плагина
        void Unload()
        {
            //Очищаем привящку к ивнту
            if (timeComponent != null)
                timeComponent.OnHour -= OnHour;
            //Восстанавливаем стандартное время переплавки
            foreach (var item in ItemManager.GetItemDefinitions())
            {
                if (!SmeltBackup.ContainsKey(item.displayName.english)) continue;
                var cookable = item.GetComponent<ItemModCookable>();
                if (cookable != null)
                {
                    cookable.cookTime = SmeltBackup[item.displayName.english];
                }
            }
        }

        #endregion

        #region Time managment

        //Переменная, для хранения компоненты времени
        private TOD_Time timeComponent = null;

        //Заморожено ли время.
        private bool Frozen = false;

        #region main
        //Колличество попыток определения компоненты
        private uint componentSearchAttempts = 0;

        //Инициализация управления временем
        private void GetTimeComponent()
        {
            //Если Instance == 0,
            if (TOD_Sky.Instance == null)
            {
                //Увеличиваем номер попытки
                ++componentSearchAttempts;
                if (this.componentSearchAttempts < 50)
                {
                    PrintWarning("Restarting timer for GetTimeComponent(). Attempt " + componentSearchAttempts.ToString() + "/10.");
                    timer.Once(3, GetTimeComponent);
                }
                else
                {
                    RaiseError("Could not find required component after 50 attempts. Plugin will not work without it.\nTry to reload it ant if this won't fix the issue contact the developer - https://vk.com/vlad_00003");
                }

                return;
            }

            if (TOD_Sky.Instance != null && componentSearchAttempts >= 0)
            {
                Puts("Found TOD_Time component after attempt " + componentSearchAttempts.ToString() + ".");
            }

            //Записываем компаненту времени
            timeComponent = TOD_Sky.Instance.Components.Time;

            if (timeComponent == null)
            {
                RaiseError("Could not fetch time component. Plugin will not work without it.");
                return;
            }

            //Добавляем ивент к событию
            timeComponent.OnHour += OnHour;

            //Вызываем функцию, дабы узнать текущее время суток.
            OnHour();

        }

        //Идёт ли прогресс времени, данные хватаем из игры
        //Ибо костылями - мир полнится....
        private bool ProgressTime
        {
            get
            {
                return timeComponent.ProgressTime; 
            }
            set
            {
                timeComponent.ProgressTime = value;
            }
        }

        //Обработчик события OnHour
        private void OnHour()
        {
            if (DayStart <= CurrentHour && CurrentHour < NightStart)
            {
                if (isDay) return;
                //Устанавливаем время суток на День
                isDay = true;
                //Вызываем процедуру обновления длинны суток
                UpdateDayLenght(DayLenght, false);
                Interface.Oxide.CallHook("OnDayStart");
            }
            else
            {
                if (!isDay) return;
                //Устанавливаем время суток на ночь
                isDay = false;
                //Вызываем процедуру обновления длинны суток
                UpdateDayLenght(NightLenght, true);
                Interface.Oxide.CallHook("OnNightStart");
            }
        }
		//timeComponent.DayLengthInMinutes = dayLength * (24.0f / (TOD_Sky.Instance.SunsetTime - TOD_Sky.Instance.SunriseTime));
		//timeComponent.DayLengthInMinutes = nightLength * (24.0f / (24.0f - (TOD_Sky.Instance.SunsetTime - TOD_Sky.Instance.SunriseTime)));
        //Функция, обновляющяя длительность суток в зависимости от времени суток в игре.
        void UpdateDayLenght(uint Lenght, bool night)
        {
            float dif = NightStart - DayStart;
            if (night)
            {
                dif = (24 - dif);
            }
            float part = 24.0f / dif;
            float newLenght = part * Lenght;
            if (newLenght <= 0) newLenght = 0.1f;
            timeComponent.DayLengthInMinutes = newLenght;
        }

        #endregion

        #region Helpers

        //Возвращает текущий час
        public float CurrentHour => TOD_Sky.Instance.Cycle.Hour;

        #endregion

        #endregion

        #region Rate controller
        //Бочки с лутом
        //void ClearContainer(LootContainer container)
        //{
        //    while (container.inventory.itemList.Count > 0)
        //    {
        //        var item = container.inventory.itemList[0];
        //        item.RemoveFromContainer();
        //        item.Remove(0f);
        //    }
        //}
        //private void OnEntitySpawned(BaseNetworkable entity)
        //{
        //    if (!UseLootMultyplier) { return; }
        //    if (entity is SupplyDrop) { return; }
        //    if (entity is LockedByEntCrate) { return; }
        //    if (entity is Stocking) { return; }
        //    if (entity is LootContainer)
        //    {
        //        var lootbox = entity as LootContainer;

        //        ClearContainer(lootbox);
        //        lootbox.PopulateLoot();

        //        foreach (Item lootitem in lootbox.inventory.itemList.ToList())
        //        {
        //            if (lootitem.info.stackable > 1)
        //            {
        //                if (BlacklistedLoot.Contains(lootitem.info.displayName.english) || BlacklistedLoot.Contains(lootitem.info.shortname)) continue;
        //                lootitem.amount = (int)(lootitem.amount * LootRate);
        //            }
        //        }
        //    }
        //}
        //private void UpdateLoot()
        //{
        //    foreach (var container in UnityEngine.Object.FindObjectsOfType<LootContainer>())
        //    {
        //        if (container is SupplyDrop) { continue; }
        //        if (container is LockedByEntCrate) { continue; }
        //        if (container is Stocking) { continue; }
        //        ClearContainer(container);
        //        container.PopulateLoot();
        //        foreach (Item lootitem in container.inventory.itemList.ToList())
        //        {
        //            if (lootitem.info.stackable > 1)
        //            {
        //                if (BlacklistedLoot.Contains(lootitem.info.displayName.english) || BlacklistedLoot.Contains(lootitem.info.shortname)) continue;
        //                lootitem.amount = (int)(lootitem.amount * LootRate);
        //            }
        //        }
        //    }
        //}
        //void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        //{
        //    var lootcont = entity as LootContainer;
        //    if (lootcont is SupplyDrop) return;
        //    var player = info.InitiatorPlayer;
        //    if (player == null) return;

        //    if (!lootcont || !lootcont.displayHealth) return;
        //    if (lootcont.OwnerID == player.userID) return;
        //    lootcont.OwnerID = player.userID;

        //    lootcont.SpawnLoot();

        //    double rate;
        //    if (isDay)
        //    {
        //        rate = GetUserRates(player.UserIDString, LootDayString);
        //    }
        //    else
        //    {
        //        rate = GetUserRates(player.UserIDString, LootNightString);
        //    }

        //    foreach (var lootitem in lootcont.inventory.itemList)
        //    {
        //        if (lootitem.info.stackable > 1)
        //        {
        //            if (BlacklistedLoot.Contains(lootitem.info.displayName.english) || BlacklistedLoot.Contains(lootitem.info.shortname)) continue;
        //            var new_amount = (int)(lootitem.amount * rate);
        //            lootitem.amount = new_amount > 1 ? new_amount : 1;
        //        }
        //    }
        //}
        void OnContainerDropItems(ItemContainer container)
        {
            if (container == null)
                return;
            
            var lootcont = container.entityOwner as LootContainer;
            if (lootcont == null || CratesCD.ContainsKey(lootcont.net.ID))
                return;
			
            var basePlayer = lootcont.lastAttacker as BasePlayer;
            var player = basePlayer != null ? basePlayer : null;
            if(player == null) return;
            double rate = GetUserRates(player.UserIDString, isDay ? LootDayString : LootNightString);

            UpdateLoot(lootcont, rate);
        }
        //TODO Пересоздавать контейнер вместо обновления лута
        void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            if (entity is SupplyDrop) return;
            if (entity is LockedByEntCrate) return;
            if (entity is Stocking) return;

            var container = entity as LootContainer;
            if (!container || container.net?.ID == null) return;
            EntityLootetrs entityLootetrs;
            var netId = container.net.ID;
            if (!CratesCD.TryGetValue(netId, out entityLootetrs))
            {
                entityLootetrs = new EntityLootetrs();
                CratesCD[netId] = entityLootetrs;
            }
            
            if(entityLootetrs.IsUpdateBlocked(player))
                return;
            
            entityLootetrs.AddLooter(player.userID);
            container.SpawnLoot();

            var rate = GetUserRates(player.UserIDString, isDay ? LootDayString : LootNightString);

            UpdateLoot(container, rate);
        }
        private void UpdateLoot(LootContainer container, double rate, ulong pIayerid = 0 )
        {
            //double rate = GetUserRates(player.UserIDString, isDay ? LootDayString : LootNightString);
            //double rate = GetUserRates(pIayerid, isDay ? LootDayString : LootNightString);
            if (container?.inventory?.itemList == null)
                return;
            foreach (var lootItem in container.inventory.itemList)
            {
                if (lootItem.info.stackable <= 1) continue;
                if (IsBlackList && ListedLootContains(lootItem)) continue;
                if (!IsBlackList && !ListedLootContains(lootItem)) continue;
                var newAmount = (int) (lootItem.amount * rate);
                lootItem.amount = newAmount > 1 ? newAmount : 1;
            }
        }

        private bool ListedLootContains(Item item) => ListedLoot.Contains(item.info.displayName.english) || ListedLoot.Contains(item.info.shortname);

        private void UpdateFurnaces()
        {
            foreach (var oven in BaseNetworkable.serverEntities.OfType<BaseOven>())
            {
                if (!oven.HasFlag(BaseEntity.Flags.On))
                    continue;
                double ovenMultiplier = GetUserRates(oven.OwnerID.ToString(), isDay ? SmeltDayString : SmeltNightString);
                if (ovenMultiplier > 10f) ovenMultiplier = 10f;
                if (ovenMultiplier < 0.1f) ovenMultiplier = 0.1f;
                StartCooking(oven, ovenMultiplier);
            }
        }
        float CookingTemperature(BaseOven.TemperatureType temperature)
        {
            switch (temperature)
            {
                case BaseOven.TemperatureType.Warming:
                    return 50f;
                case BaseOven.TemperatureType.Cooking:
                    return 200f;
                case BaseOven.TemperatureType.Smelting:
                    return 1000f;
                case BaseOven.TemperatureType.Fractioning:
                    return 1500f;
                default:
                    return 15f;
            }
        }
        object OnOvenToggle(BaseOven oven, BasePlayer player)
        {
            if (oven.HasFlag(BaseEntity.Flags.On))
                return null;
            double ovenMultiplier = GetUserRates(oven.OwnerID.ToString(), isDay ? SmeltDayString : SmeltNightString);
            if (ovenMultiplier > 10f) ovenMultiplier = 10f;
            if (ovenMultiplier < 0.1f) ovenMultiplier = 0.1f;
            StartCooking(oven, ovenMultiplier);
            return false;
        }
        void StartCooking(BaseOven oven, double ovenMultiplier)
        {
            if (FindBurnable(oven) == null)
                return;
            oven.inventory.temperature = CookingTemperature(oven.temperature);
            oven.UpdateAttachmentTemperature();
            oven.CancelInvoke(oven.Cook);
            oven.InvokeRepeating(oven.Cook, (float)(0.5f / ovenMultiplier), (float)(0.5f / ovenMultiplier));
            //InvokeHandler.InvokeRepeating(oven, oven.Cook, (float)(0.5f / ovenMultiplier), (float)(0.5f / ovenMultiplier));
            oven.SetFlag(BaseEntity.Flags.On, true);
        }
        Item FindBurnable(BaseOven oven)
        {
            if (oven.inventory == null)
                return null;
            foreach (Item current in oven.inventory.itemList)
            {
                ItemModBurnable component = current.info.GetComponent<ItemModBurnable>();
                if (component && (oven.fuelType == null || current.info == oven.fuelType))
                    return current;
            }
            return null;
        }

        private void OnDayStart()
        {
            CoalRate = CoalRateDay;
            CoalChance = CoalChanceDay;
            SmeltRate = DefaultRates[SmeltDayString];
            GatherRate = DefaultRates[GatherDayString];
            PickupRate = DefaultRates[PickUpDayString];
            QuerryRate = DefaultRates[QuerryDayString];
            LootRate = DefaultRates[LootDayString];
            //Обновляем скорость переплавки
            UpdateSmeltTime();
            UpdateFurnaces();

            //Оповещаем игоков о смене времени суток
            if (WarnChat)
            {
                RatesToChat();
            }
        }
        private void OnNightStart()
        {
            CoalRate = CoalRateNight;
            CoalChance = CoalChanceNight;
            SmeltRate = DefaultRates[SmeltNightString];
            GatherRate = DefaultRates[GatherNightString];
            PickupRate = DefaultRates[PickUpNightString];
            QuerryRate = DefaultRates[QuerryNightString];
            LootRate = DefaultRates[LootNightString];
            //Обновляем скорость переплавки
            UpdateSmeltTime();
            UpdateFurnaces();

            //Оповещаем игоков о смене времени суток
            if (WarnChat)
            {
                RatesToChat();
            }
        }
        private void RatesToChat()
        {
            string Message = string.Empty;
            Message = isDay ? GetMsg("Day Starts") : GetMsg("Night Starts");
            Message += GetMsg("GatherRates").Replace("{rates}", GatherRate.ToString());
            Message += GetMsg("PickupRates").Replace("{rates}", PickupRate.ToString());
            Message += GetMsg("QuerryRates").Replace("{rates}", QuerryRate.ToString());
            Message += GetMsg("Smelt Rate").Replace("{rates}", SmeltRate.ToString());
            Message += GetMsg("CoalRate").Replace("{rates}", CoalRate.ToString());
            if (UseLootMultyplier)
                Message += GetMsg("LootRate").Replace("{rates}", LootRate.ToString());
            SendToChat(Message);
        }


        void OnCollectiblePickup(Item item, BasePlayer player)
        {
            double mod = 1f;
            if (DefaultPickupRates.ContainsKey(item.info.displayName.english))
            {
                mod = DefaultPickupRates[item.info.displayName.english];
            }
            int new_amount;
            if (isDay)
            {
                new_amount = (int)(item.amount * GetUserRates(player.UserIDString, PickUpDayString) * mod);
                item.amount = new_amount > 1 ? new_amount : 1;
                return;
            }
            new_amount = (int)(item.amount * GetUserRates(player.UserIDString, PickUpNightString) * mod);
            item.amount = new_amount > 1 ? new_amount : 1;
        }
        void OnGrowableGathered(GrowableEntity plant, Item item, BasePlayer player, ulong playerid = 2952192)
        {
            double mod = 1f;
            if (DefaultPickupRates.ContainsKey(item.info.displayName.english))
            {
                mod = DefaultPickupRates[item.info.displayName.english];
            }
            var newAmount  = (int)(item.amount * GetUserRates(player.UserIDString, isDay ? PickUpDayString : PickUpNightString) * mod);
            var diff = newAmount - item.amount;
            if(diff > 0)
                player.Command("note.inv", item.info.itemid,diff,item.name,BaseEntity.GiveItemReason.ResourceHarvested);
            item.amount = newAmount > 1 ? newAmount : 1;
        }
        void OnEntityKill(BaseNetworkable entity)
        {
            var id = entity?.net?.ID;
            if (id.HasValue)
                CratesCD.Remove(id.Value);
            
        }
        void OnDispenserBonus(ResourceDispenser disp, BasePlayer player, Item item)
        {
            if (player == null) return;
            double mod = 1f;
            if (DefaultGatherRates.ContainsKey(item.info.displayName.english))
            {
                mod = DefaultGatherRates[item.info.displayName.english];
            }
            double rate = GetUserRates(player.UserIDString, isDay ? GatherDayString : GatherNightString);
            var newAmount = (int)(item.amount * rate * mod);
            item.amount = newAmount > 1 ? newAmount : 1;
        }
        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            if (!entity.ToPlayer()) return;
            double mod = 1f;
            if (DefaultGatherRates.ContainsKey(item.info.displayName.english))
            {
                mod = DefaultGatherRates[item.info.displayName.english];
            }
            double rate = GetUserRates(entity.ToPlayer().UserIDString, isDay ? GatherDayString : GatherNightString);
            var newAmount = (int)(item.amount * rate * mod);
            item.amount = newAmount > 1 ? newAmount : 1;

            if (!MoreHQM || dispenser.gatherType != ResourceDispenser.GatherType.Ore) return;
            bool HaveHQM = dispenser.finishBonus.Any(x => x.itemDef.shortname == "hq.metal.ore");
            var reply = 2883;
            if (!HaveHQM)
            {
                dispenser.finishBonus.Add(new ItemAmount(hqmo, 2f));
            }
        }
        void OnQuarryGather(MiningQuarry quarry, Item item)
        {
            double mod = 1f;
            if (DefaultQuerryRates.ContainsKey(item.info.displayName.english))
            {
                mod = DefaultQuerryRates[item.info.displayName.english];
            }
            int newAmount;
            if (isDay)
            {
                newAmount = (int)(item.amount * GetUserRates(quarry.OwnerID, QuerryDayString) * mod);
                item.amount = newAmount > 1 ? newAmount : 1;
                return;
            }
            newAmount = (int)(item.amount * GetUserRates(quarry.OwnerID, QuerryNightString) * mod);
            item.amount = newAmount > 1 ? newAmount : 1;
        }
        void OnFuelConsume(BaseOven oven, Item fuel, ItemModBurnable burnable)
        {
            if (oven == null) return;
            burnable.byproductAmount = (int)Math.Ceiling(CoalRate);
            burnable.byproductChance = (100 - CoalChance) / 100f;
            if (burnable.byproductChance == 0)
            {
                burnable.byproductChance = -1;
            }
        }
        void UpdateSmeltTime()
        {
            var itemDefinitions = ItemManager.GetItemDefinitions();
            foreach (var item in itemDefinitions)
            {
                var cookable = item.GetComponent<ItemModCookable>();
                if (cookable != null)
                {
                    if (DefaultSmeltRates.ContainsKey(item.displayName.english))
                    {
                        cookable.cookTime = (float)(DefaultSmeltRates[item.displayName.english] / SmeltRate);
                    }
                    else
                    {
                        DefaultSmeltRates.Add(item.displayName.english, cookable.cookTime);
                        cookable.cookTime = (float)(DefaultSmeltRates[item.displayName.english] / SmeltRate);
                    }
                }
            }
        }
        #endregion

        #region Сonsole commands⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        [ConsoleCommand("env.freeze")]
        void TimeFreeze(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            if (Frozen)
            {
                //Puts("The time is already frozen!");
                arg.ReplyWith("The time is already frozen!");
                return;
            }
            Frozen = true;
            ProgressTime = false;
            //Puts("The time was frozen.");
            arg.ReplyWith("The time was frozen.");
        }

        [ConsoleCommand("env.unfreeze")]
        void TimeUnFreeze(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            if (!Frozen)
            {
                arg.ReplyWith("The time is not frozen!");
                return;
            }
            Frozen = false;
            ProgressTime = true;
            arg.ReplyWith("The time was unfrozen.");
        }

        [ConsoleCommand("rates.show")]
        void ShowRates(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            if (arg.Args == null)
            {
                arg.ReplyWith("Usage rates.show steamid [type]");
                return;
            }
            var target = covalence.Players.FindPlayer(arg.Args[0]);
            if (target == null)
            {
                arg.ReplyWith("User not found or multiply user mathces");
                return;
            }
            if (arg.Args.Length >= 2)
            {
                arg.ReplyWith(GetUserRates(target.Id, arg.Args[1]).ToString());
                return;
            }
            string reply = $"User '{target.Name}' current rates:\n";
            foreach (var p in AvaliableMods)
            {
                reply += p + ": " + GetUserRates(target.Id, p).ToString() + " \n";
            }
            arg.ReplyWith(reply);
        }
        #endregion

        #region Chat commands
        [ChatCommand("rates")]
        private void ShowRatesChat(BasePlayer player, string command, string[] args)
        {
            string reply = GetMsg("PersonalRates", player.UserIDString);
            if (isDay)
            {
                reply += GetMsg("GatherRatesPers", player.UserIDString).Replace("{rates}", GetUserRates(player.UserIDString, GatherDayString).ToString());
                reply += GetMsg("PickUpRatesPers", player.UserIDString).Replace("{rates}", GetUserRates(player.UserIDString, PickUpDayString).ToString());
                reply += GetMsg("QueryPers", player.UserIDString).Replace("{rates}", GetUserRates(player.UserIDString, QuerryDayString).ToString());
                reply += GetMsg("SmeltPers", player.UserIDString).Replace("{rates}", GetUserRates(player.UserIDString, SmeltDayString).ToString());
                reply += GetMsg("LootPers", player.UserIDString).Replace("{rates}", GetUserRates(player.UserIDString, LootDayString).ToString());
                SendToChat(player, reply);
                return;
            }
            reply += GetMsg("GatherRatesPers", player.UserIDString).Replace("{rates}", GetUserRates(player.UserIDString, GatherNightString).ToString());
            reply += GetMsg("PickUpRatesPers", player.UserIDString).Replace("{rates}", GetUserRates(player.UserIDString, PickUpNightString).ToString());
            reply += GetMsg("QueryPers", player.UserIDString).Replace("{rates}", GetUserRates(player.UserIDString, QuerryNightString).ToString());
            reply += GetMsg("SmeltPers", player.UserIDString).Replace("{rates}", GetUserRates(player.UserIDString, SmeltNightString).ToString());
            reply += GetMsg("LootPers", player.UserIDString).Replace("{rates}", GetUserRates(player.UserIDString, LootNightString).ToString());
            SendToChat(player, reply);
        }
        #endregion

        #region Helpers
        private void GetConfig<T>(string Key, ref T var)
        {
            if (Config[Key] != null)
            {
                var = (T)Convert.ChangeType(Config[Key], typeof(T));
            }
            Config[Key] = var;
        }

        //Функция, отправляющая сообщение в чат конкретному пользователю, добавляет префикс
        private void SendToChat(BasePlayer Player, string Message)
        {
            PrintToChat(Player, "<color=" + PrefixColor + ">" + Prefix + "</color> " + Message);
        }

        //Перезгрузка функции отправки собщения в чат - отправляет сообщение всем пользователям
        private void SendToChat(string Message)
        {
            PrintToChat("<color=" + PrefixColor + ">" + Prefix + "</color> " + Message);
        }

        //Функция получения строки из языкового файла
        string GetMsg(string key, object userID = null) => lang.GetMessage(key, this, userID?.ToString());
        double GetUserRates(string steamId, string RateType)
        {
            /*
             * Из списка кастомных привелегий выбираем только те, на которые у игрока есть привелегия.
             * выбираем только сами привелегии, без названий. Только содерживое
             * Из них выбираем те, где есть нужный нам тип рейтов. И выбираем только нужные нам типы рейтов.
             */
            var playergroups = CustomRates.Where(i => permission.UserHasPermission(steamId, i.Key)).Select(i => i.Value).
                Where(i => i.ContainsKey(RateType)).Select(i => i[RateType]);
            return playergroups.Any() ? playergroups.Aggregate((i1, i2) => i1 > i2 ? i1 : i2) : DefaultRates[RateType];
        }
        //Перегрузка функции. Ибо мне так будет проще)
        double GetUserRates(ulong steamId, string RateType) => GetUserRates(steamId.ToString(), RateType);

        Dictionary<string, object> CreatePerms(List<string> mods, double rate)
        {
            return mods.ToDictionary(x => x, x => (object)rate);
        }


        #endregion
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////////


// --- End of file: 1RatesController.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ZLevelsRemastered.cs ---
// --- Original Local Path: ZLevelsRemastered.cs ---

// Reference: Oxide.Core.MySql
// Reference: Oxide.Core.SQLite

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Oxide.Core;
using Oxide.Core.Database;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Zeiser Levels Remastered", "Zeiser/Visagalis", "1.6.6", ResourceId = 1453)]
    [Description("Lets players level up as they harvest different resources and when crafting")]

    class ZLevelsRemastered : RustPlugin
    {
        [PluginReference]
        Plugin EventManager;

        #region SQL Things

        readonly Core.MySql.Libraries.MySql _mySql = new Core.MySql.Libraries.MySql();
        readonly Core.SQLite.Libraries.SQLite _sqLite = new Core.SQLite.Libraries.SQLite();
        Connection _mySqlConnection;
        Connection _sqLiteConnection;
        public Dictionary<ulong, Dictionary<string, long>> playerList = new Dictionary<ulong, Dictionary<string, long>>();
        readonly string sqLiteDBFile = "ZLevelsRemastered.db";

        void StartConnection()
        {
            if (usingMySQL() && _mySqlConnection == null)
            {
                _mySqlConnection = _mySql.OpenDb(dbConnection["Host"].ToString(), Convert.ToInt32(dbConnection["Port"]),
                    dbConnection["Database"].ToString(), dbConnection["Username"].ToString(),
                    dbConnection["Password"].ToString(), this);
                Puts("Connection opened.(MySQL)");
            }
            else
            {
                _sqLiteConnection = _sqLite.OpenDb(sqLiteDBFile, this);
                CheckConnection();
            }
        }

        void CheckConnection()
        {
            var tableStucture = new Dictionary<string, string>
            {
                {"UserID", "INTEGER\tNOT NULL"},
                {"Name", "TEXT\tNOT NULL"},
                {"WCLevel", "INTEGER"},
                {"WCPoints", "INTEGER"},
                {"MLevel", "INTEGER"},
                {"MPoints", "INTEGER"},
                {"SLevel", "INTEGER"},
                {"SPoints", "INTEGER"},
                {"CLevel", "INTEGER"},
                {"CPoints", "INTEGER"},
                {"LastDeath", "INTEGER"},
                {"LastLoginDate", "INTEGER"},
                {"XPMultiplier", "INTEGER\tNOT NULL\tDEFAULT 100"}
            };

            var queryText = "CREATE TABLE IF NOT EXISTS \"RPG_User\" (";
            foreach (var structItem in tableStucture)
            {
                queryText += "`" + structItem.Key + "` " + structItem.Value + ", ";
            }
            queryText += "PRIMARY KEY(UserID))";
            var sql = new Sql(queryText);
            _sqLite.Query(sql, _sqLiteConnection, list =>
            {
                //CheckTableIntegrity(tableStucture);
            });
        }

        /* TODO: Will finish this one day!
        void CheckTableIntegrity(Dictionary<string, string> tableStucture)
        {
            var sql = new Sql("PRAGMA table_info(RPG_User)");
            _sqLite.Query(sql, _sqLiteConnection, list =>
            {
                if (list.Count > 0) // Save to DB failed.
                    foreach (var listItem in list)
                    {
                        string currColumn = listItem["type"] +
                                            (listItem["notnull"].ToString() == "1" ? "\tNOT NULL" : "") +
                                            (listItem["dflt_value"].ToString() != string.Empty ? "\tDEFAULT " + listItem["dflt_value"].ToString() : "");

                        if (tableStucture[listItem["name"].ToString()] != currColumn)
                            alterTable(currColumn, tableStucture[listItem["name"].ToString()]);
                    }

            });
        }

        void alterTable(string currColumn, string fixedColumn)
        {
            Puts("Altering table from: [" + currColumn + "] to [" + fixedColumn + "]");
            var sql = new Sql("BEGIN TRANSACTION;PRAGMA schema_version;");
            _sqLite.Query(sql, _sqLiteConnection, list =>
            {
                if (list.Count > 0)
                {
                    Puts("1");
                    int schemaVersion = Convert.ToInt32(list[0]["schema_version"]);
                    var sql2 = new Sql("PRAGMA writable_schema=ON;");
                    _sqLite.Query(sql2, _sqLiteConnection, list2 =>
                    {
                        Puts("2");
                        var sql3 = new Sql("SELECT * FROM sqlite_master WHERE type='table' and name='RPG_User';");
                        _sqLite.Query(sql3, _sqLiteConnection, list3 =>
                        {
                            if (list3.Count > 0)
                            {
                                Puts("3");
                                string modifiedSql = list3[0]["sql"].ToString();
                                Puts("Before: " + modifiedSql);
                                modifiedSql = modifiedSql.Replace(currColumn, fixedColumn);
                                Puts("After: " + modifiedSql);
                                var sql4 =
                                    new Sql("UPDATE sqlite_master SET sql=@0 WHERE type='table' and name='RPG_User';",
                                        modifiedSql);
                                _sqLite.Query(sql4, _sqLiteConnection, list4 =>
                                {
                                    if (list4.Count > 0)
                                    {
                                        Puts("4");
                                        var sql5 =
                                            new Sql("PRAGMA schema_version=" + ++schemaVersion +
                                                    ";PRAGMA writable_schema=OFF;END TRANSACTION");
                                        _sqLite.Query(sql5, _sqLiteConnection, list5 =>
                                        {
                                            Puts("5");
                                            var sql6 = new Sql("PRAGMA integrity_check");
                                            _sqLite.Query(sql5, _sqLiteConnection, list6 =>
                                            {
                                                if (list6.Count > 0)
                                                {
                                                    Puts("6");
                                                    Puts(list6[0]["integrity_check"].ToString());
                                                }
                                            });
                                        });
                                    }
                                });
                            }
                        });
                    });
                }
            });
        }
        */

        public void setPointsAndLevel(ulong userID, string skill, long points, long level)
        {
            if (!playerList.ContainsKey(userID))
                playerList.Add(userID, new Dictionary<string, long>());

            setPlayerData(userID, skill + "Points", points == 0 ? getLevelPoints(level) : points);
            setPlayerData(userID, skill + "Level", level);
        }

        public void loadUser(BasePlayer player)
        {
            var statsInit = new Dictionary<string, long>();
            foreach (var skill in Skills.ALL)
            {
                statsInit.Add(skill + "Level", 1);
                statsInit.Add(skill + "Points", 10);
            }
            var currTime = ToEpochTime(DateTime.UtcNow);
            statsInit.Add("LastDeath", currTime);
            statsInit.Add("LastLoginDate", currTime);
            statsInit.Add("XPMultiplier", 100);
            var sql = Sql.Builder.Append("SELECT * FROM RPG_User WHERE UserID = @0", player.userID);

            if (usingMySQL())
            {
                _mySql.Query(sql, _mySqlConnection, list =>
                {
                    initPlayer(player, statsInit, list);
                });
            }
            else
            {
                _sqLite.Query(sql, _sqLiteConnection, list =>
                {
                    initPlayer(player, statsInit, list);
                });
            }
        }

        void initPlayer(BasePlayer player, Dictionary<string, long> statsInit, List<Dictionary<string, object>> sqlData)
        {
            var needToSave = true;
            var tempElement = new Dictionary<string, long>();
            if (sqlData.Count > 0)
            {
                foreach (var key in statsInit.Keys)
                {
                    if (sqlData[0][key] != DBNull.Value)
                        tempElement.Add(key, Convert.ToInt64(sqlData[0][key]));
                }

                needToSave = false;
            }

            foreach (var tempItem in tempElement)
                statsInit[tempItem.Key] = tempItem.Value;

            initPlayerData(player, statsInit);
            if (needToSave)
                saveUser(player);

            RenderUI(player);
        }

        void setPlayerData(ulong userID, string key, long value)
        {
            if (playerList[userID].ContainsKey(key))
                playerList[userID][key] = value;
            else
                playerList[userID].Add(key, value);
        }

        void initPlayerData(BasePlayer player, Dictionary<string, long> playerData)
        {
            foreach (var skill in Skills.ALL)
                setPointsAndLevel(player.userID, skill, playerData[skill + "Points"], playerData[skill + "Level"]);

            foreach (var dataItem in playerData)
            {
                if (dataItem.Key.EndsWith("Level") || dataItem.Key.EndsWith("Points"))
                    continue;
                setPlayerData(player.userID, dataItem.Key, dataItem.Value);
            }
        }

        void OnPlayerLootEnd(PlayerLoot inventory)
        {
            var player = inventory.GetComponent<BasePlayer>();
            if (player != null && inPlayerList(player.userID))
            {
                RenderUI(player);
            }
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            if (guioff.Contains(player.userID))
                guioff.Remove(player.userID);
            else
                CuiHelper.DestroyUi(player, "StatsUI");

            if (inPlayerList(player.userID))
            {
                saveUser(player);

                if (playerList.ContainsKey(player.userID))
                    playerList.Remove(player.userID);
            }
        }

        void OnPlayerInit(BasePlayer player)
        {
            long multiplier = 100;
            var playerPermissions = permission.GetUserPermissions(player.UserIDString);
            if (playerPermissions.Any(x => x.ToLower().StartsWith("zlvlboost")))
            {
                var perm = playerPermissions.First(x => x.ToLower().StartsWith("zlvlboost"));
                if (!long.TryParse(perm.ToLower().Replace("zlvlboost", ""), out multiplier))
                    multiplier = 100;
            }
            editMultiplierForPlayer(multiplier, player.userID);

            loadUser(player);
        }

        public void SaveUsers()
        {
            foreach (var user in BasePlayer.activePlayerList)
                saveUser(user);
        }

        static string EncodeNonAsciiCharacters(string value)
        {
            var sb = new StringBuilder();
            foreach (var c in value)
            {
                if (c > 127)
                {
                    // This character is too big for ASCII
                    var encodedValue = "";
                    sb.Append(encodedValue);
                }
                else
                {
                    sb.Append(c);
                }
            }
            return sb.ToString();
        }

        public void saveUser(BasePlayer player)
        {
            if (!playerList.ContainsKey(player.userID))
            {
                Puts("Trying to save player, who haven't been loaded yet? Player name: " + player.displayName);
                return;
            }

            var statsInit = getConnectedPlayerDetailsData(player.userID);

            var name = EncodeNonAsciiCharacters(player.displayName);
            var sqlText =
                "REPLACE INTO RPG_User (UserID, Name, WCLevel, WCPoints, MLevel, MPoints, SLevel, SPoints, CLevel, CPoints, LastDeath, LastLoginDate, XPMultiplier) " +
                "VALUES (@0, @1, @2, @3, @4, @5, @6, @7, @8, @9, @10, @11, @12)";
            var sql = Sql.Builder.Append(sqlText,
                player.userID, //0
                name, //1
                statsInit["WCLevel"], //2
                statsInit["WCPoints"], //3
                statsInit["MLevel"], //4
                statsInit["MPoints"], //5
                statsInit["SLevel"], //6
                statsInit["SPoints"], //7
                statsInit["CLevel"], //8
                statsInit["CPoints"], //9
                statsInit["LastDeath"], //10
                statsInit["LastLoginDate"], //11
                statsInit["XPMultiplier"]); //12
            if (usingMySQL())
            {
                _mySql.Insert(sql, _mySqlConnection, list =>
                {
                    if (list == 0) // Save to DB failed.
                        Puts("OMG WE DIDN'T SAVED IT!: " + sql.SQL);
                });
            }
            else
            {
                _sqLite.Insert(sql, _sqLiteConnection, list =>
                {
                    if (list == 0) // Save to DB failed.
                        Puts("OMG WE DIDN'T SAVED IT!: " + sql.SQL);
                });
            }
        }

        public Dictionary<string, long> getConnectedPlayerDetailsData(ulong userID)
        {
            if (!playerList.ContainsKey(userID)) return null;

            var statsInit = new Dictionary<string, long>();
            foreach (var skill in Skills.ALL)
            {
                statsInit.Add(skill + "Level", getLevel(userID, skill));
                statsInit.Add(skill + "Points", getPoints(userID, skill));
            }
            statsInit.Add("LastDeath", playerList[userID]["LastDeath"]);
            statsInit.Add("LastLoginDate", playerList[userID]["LastLoginDate"]);
            statsInit.Add("XPMultiplier", playerList[userID]["XPMultiplier"]);
            return statsInit;
        }

        #endregion

        public static class Skills
        {
            public static string CRAFTING = "C";
            public static string WOODCUTTING = "WC";
            public static string SKINNING = "S";
            public static string MINING = "M";
            public static string[] ALL = { WOODCUTTING, MINING, SKINNING, CRAFTING };
        }

        List<ulong> guioff = new List<ulong>();

        Dictionary<string, string> colors = new Dictionary<string, string>()
        {
            {Skills.WOODCUTTING, "#FFDDAA"},
            {Skills.MINING, "#DDDDDD"},
            {Skills.SKINNING, "#FFDDDD"},
            {Skills.CRAFTING, "#CCFF99"}
        };

        class CraftData
        {
            public Dictionary<string, CraftInfo> CraftList = new Dictionary<string, CraftInfo>();
        }

        CraftData _craftData;

        #region Stats
        [HookMethod("SendHelpText")]
        void SendHelpText(BasePlayer player)
        {
            var text = "/stats - Displays your stats.\n/statsui - Displays/hides stats UI.\n/statinfo [statsname] - Displays information about stat.\n" +
                          "/topskills - Display max levels reached so far.";
            player.ChatMessage(text);
        }

        [ChatCommand("topskills")]
        void StatsTopCommand(BasePlayer player, string command, string[] args)
        {
            PrintToChat(player, "Max stats on server so far:");
            foreach (var skill in Skills.ALL)
            {
                if (!IsSkillDisabled(skill))
                    printMaxSkillDetails(player, skill);
            }
        }

        void printMaxSkillDetails(BasePlayer player, string skill)
        {
            var sql = Sql.Builder.Append("SELECT * FROM RPG_User ORDER BY " + skill + "Level DESC," + skill + "Points DESC LIMIT 1;");
            if (usingMySQL())
            {
                _mySql.Query(sql, _mySqlConnection, list =>
                {
                    if (list.Count > 0)
                        printMaxSkillDetails(player, skill, list);
                });
            }
            else
            {
                _sqLite.Query(sql, _sqLiteConnection, list =>
                {
                    if (list.Count > 0)
                        printMaxSkillDetails(player, skill, list);
                });
            }
        }

        void printMaxSkillDetails(BasePlayer player, string skill, List<Dictionary<string, object>> sqlData)
        {
            PrintToChat(player,
                            "<color=" + colors[skill] + ">" + messages[skill + "Skill"] + ": " +
                            sqlData[0][skill + "Level"] + " (XP: " + sqlData[0][skill + "Points"] + ")</color> <- " +
                            sqlData[0]["Name"]);
        }

        [ConsoleCommand("zinfo")]
        void InfoCommand(ConsoleSystem.Arg arg)
        {
            if (arg.connection != null)
                return;

            if (arg.Args == null || arg.Args.Length != 1)
            {
                Puts("Syntax is: zinfo name/steamid");
                Puts("Example: zinfo visagalis");
                return;
            }
            var playerName = arg.Args[0];
            var player = rust.FindPlayer(playerName);

            if (player != null)
            {

                var playerData = getConnectedPlayerDetailsData(player.userID);
                if (playerData == null)
                    Puts("PlayerData IS NULL!!!");

                Puts("Stats for player: [" + player.displayName + "]");
                Puts("Woodcutting: " + playerData["WCLevel"] + " XP: [" + playerData["WCPoints"] + "]");
                Puts("Mining: " + playerData["MLevel"] + " XP: [" + playerData["MPoints"] + "]");
                Puts("Skinning: " + playerData["SLevel"] + " XP: [" + playerData["SPoints"] + "]");
                Puts("Crafting: " + playerData["CLevel"] + " XP: [" + playerData["CPoints"] + "]");
                Puts("XP Multiplier: " + playerData["XPMultiplier"] + " % ");
            }
        }

        [ConsoleCommand("zlvl")]
        void ZlvlCommand(ConsoleSystem.Arg arg)
        {
            if (arg.connection != null)
                return;

            if (arg.Args == null || arg.Args.Length != 3)
            {
                Puts("Syntax is: zlvl name/steamid skill [OPERATOR]NUMBER");
                Puts("Example: zlvl Visagalis WC /2 -- visagalis gets his WC level divided by 2.");
                Puts("Example: zlvl * * +3 -- Everyone currently playing in the server gets +3 for all skills.");
                Puts("Example: zlvl ** * /2 -- Everyone (including offline players) gets their level divided by 2.");
                Puts("Instead of names you can use wildcard(*): * - affects online players, ** - affects all players");
                Puts("Possible operators: *(XP Modified %), +(Adds level), -(Removes level), /(Divides level)");
                return;
            }
            var playerName = arg.Args[0];
            var p = rust.FindPlayer(playerName);

            if (p != null || (playerName == "*" || playerName == "**"))
            {
                var playerMode = 0; // Exact player
                if (playerName == "*")
                    playerMode = 1; // Online players
                else if (playerName == "**")
                    playerMode = 2; // All players
                var skill = arg.Args[1].ToUpper();
                if (skill == Skills.WOODCUTTING || skill == Skills.MINING || skill == Skills.SKINNING ||
                    skill == Skills.CRAFTING || skill == "*")
                {
                    var allSkills = skill == "*";
                    var mode = 0; // 0 = SET, 1 = ADD, 2 = SUBTRACT, 3 = multiplier, 4 = divide
                    int value;
                    var correct = false;
                    if (arg.Args[2][0] == '+')
                    {
                        mode = 1;
                        correct = int.TryParse(arg.Args[2].Replace("+", ""), out value);
                    }
                    else if (arg.Args[2][0] == '-')
                    {
                        mode = 2;
                        correct = int.TryParse(arg.Args[2].Replace("-", ""), out value);
                    }
                    else if (arg.Args[2][0] == '*')
                    {
                        mode = 3;
                        correct = int.TryParse(arg.Args[2].Replace("*", ""), out value);
                    }
                    else if (arg.Args[2][0] == '/')
                    {
                        mode = 4;
                        correct = int.TryParse(arg.Args[2].Replace("/", ""), out value);
                    }
                    else
                    {
                        correct = int.TryParse(arg.Args[2], out value);
                    }
                    if (correct)
                    {
                        if (mode == 3) // Change XP Multiplier.
                        {
                            if (!allSkills)
                            {
                                Puts("XPMultiplier is changeable for all skills! Use * instead of " + skill + ".");
                                return;
                            }
                            if (playerMode == 1)
                            {
                                foreach (var currPlayer in BasePlayer.activePlayerList)
                                    editMultiplierForPlayer(value, currPlayer.userID);
                            }
                            else if (playerMode == 2)
                                editMultiplierForPlayer(value);
                            else if (p != null)
                                editMultiplierForPlayer(value, p.userID);

                            Puts("XP rates has changed to " + value + "% of normal XP for " + (playerMode == 1 ? "ALL ONLINE PLAYERS" : (playerMode == 2 ? "ALL PLAYERS" : p.displayName)));
                            return;
                        }

                        if (playerMode == 1)
                        {
                            foreach (var currPlayer in BasePlayer.activePlayerList)
                                adminModifyPlayerStats(skill, value, mode, currPlayer);
                        }
                        else if (playerMode == 2)
                            adminModifyPlayerStats(skill, value, mode);
                        else
                            adminModifyPlayerStats(skill, value, mode, p);

                    }
                }
                else
                {
                    Puts("Incorrect skill. Possible skills are: WC, M, S, C, *(All skills).");
                }
            }
            else
            {
                Puts("Player with name: " + arg.Args[0] + " haven't been found online.");
            }
        }

        void adminModifyPlayerStats(string skill, long level, int mode, BasePlayer p = null)
        {
            if (skill == "*")
            {
                foreach (var currSkill in Skills.ALL)
                {
                    if (p == null)
                    {
                        var action = "";
                        switch (mode)
                        {
                            case 1:
                                action = "+";
                                break;
                            case 2:
                                action = "-";
                                break;
                            case 4:
                                action = "/";
                                break;
                        }
                        if (string.IsNullOrEmpty(action))
                        {
                            Puts("You can't just SET everyone's level, use + - or / operator.");
                            return;
                        }
                        var sqlText = "UPDATE RPG_User SET ";
                        var skillLevel = currSkill + "Level";
                        sqlText += skillLevel + "=" + skillLevel + action + level + ", ";
                        sqlText += currSkill + "Points=0;" +
                                   (levelCaps[currSkill].ToString() != "0" ? ("UPDATE RPG_User SET " + skillLevel + "=" + levelCaps[currSkill] + " WHERE " + skillLevel + ">" + levelCaps[currSkill] + ";") : "") +
                                   "UPDATE RPG_User SET " + skillLevel + "=1 WHERE " + skillLevel + "< 1;";
                        var sql = Sql.Builder.Append(sqlText);
                        if (usingMySQL())
                            _mySql.ExecuteNonQuery(sql, _mySqlConnection);
                        else
                            _sqLite.ExecuteNonQuery(sql, _sqLiteConnection);

                        foreach (var onlinePlayer in BasePlayer.activePlayerList)
                            loadUser(onlinePlayer);
                    }
                    else
                    {
                        var modifiedLevel = getLevel(p.userID, currSkill);
                        if (mode == 0) // SET
                            modifiedLevel = level;
                        else if (mode == 1) // ADD
                            modifiedLevel += level;
                        else if (mode == 2) // SUBTRACT
                            modifiedLevel -= level;
                        else if (mode == 4) // DIVIDE
                            modifiedLevel /= level;
                        if (modifiedLevel < 1)
                            modifiedLevel = 1;
                        if (modifiedLevel > Convert.ToInt32(levelCaps[currSkill]) &&
                            Convert.ToInt32(levelCaps[currSkill]) != 0)
                        {
                            modifiedLevel = Convert.ToInt32(levelCaps[currSkill]);
                            // Don't allow to ADD levels above limits.
                            Puts(
                                "Warning! You tried to level up player above levelCaps, use SET if you want to have player level over levelCaps.");
                        }

                        setPointsAndLevel(p.userID, currSkill, getLevelPoints(modifiedLevel), modifiedLevel);
                        RenderUI(p);
                        Puts(messages[currSkill + "Skill"] + " Level for [" + p.displayName + "] has been set to: [" +
                             modifiedLevel +
                             "]");
                        SendReply(p,
                            "Admin has set your " + messages[currSkill + "Skill"] + " level to: [" + modifiedLevel +
                            "] ");
                    }
                }
            }
            else
            {
                if (p == null)
                {
                    var action = "";
                    switch (mode)
                    {
                        case 1:
                            action = "+";
                            break;
                        case 2:
                            action = "-";
                            break;
                        case 4:
                            action = "/";
                            break;
                    }
                    if (string.IsNullOrEmpty(action))
                    {
                        Puts("You can't just SET everyone's level, use + - or / operator.");
                        return;
                    }
                    var sqlText = "UPDATE RPG_User SET ";
                    var skillLevel = skill + "Level";
                    sqlText += skillLevel + "=" + skillLevel + action + level + ", ";
                    sqlText += skill + "Points=0;" +
                               (levelCaps[skill].ToString() != "0" ? ("UPDATE RPG_User SET " + skillLevel + "=" + levelCaps[skill] + " WHERE " + skillLevel + ">" + levelCaps[skill] + ";") : "") +
                               "UPDATE RPG_User SET " + skillLevel + "=1 WHERE " + skillLevel + "< 1;";
                    var sql = Sql.Builder.Append(sqlText);
                    if (usingMySQL())
                        _mySql.ExecuteNonQuery(sql, _mySqlConnection);
                    else
                        _sqLite.ExecuteNonQuery(sql, _sqLiteConnection);

                    foreach (var onlinePlayer in BasePlayer.activePlayerList)
                        loadUser(onlinePlayer);
                    return;
                }
                var modifiedLevel = getLevel(p.userID, skill);
                if (mode == 0) // SET
                    modifiedLevel = level;
                else if (mode == 1) // ADD
                    modifiedLevel += level;
                else if (mode == 2) // SUBTRACT
                    modifiedLevel -= level;
                else if (mode == 4) // DIVIDE
                    modifiedLevel /= level;
                if (modifiedLevel < 1)
                    modifiedLevel = 1;
                if (modifiedLevel > Convert.ToInt32(levelCaps[skill]) && Convert.ToInt32(levelCaps[skill]) != 0)
                {
                    modifiedLevel = Convert.ToInt32(levelCaps[skill]); // Don't allow to ADD levels above limits.
                    Puts("Warning! You tried to level up player above levelCaps, use SET if you want to have player level over levelCaps.");
                }

                setPointsAndLevel(p.userID, skill, getLevelPoints(modifiedLevel), modifiedLevel);
                RenderUI(p);
                Puts(messages[skill + "Skill"] + " Level for [" + p.displayName + "] has been set to: [" + modifiedLevel + "]");
                SendReply(p, "Admin has set your " + messages[skill + "Skill"] + " level to: [" + modifiedLevel + "] ");
            }
        }

        void editMultiplierForPlayer(long multiplier, ulong userID = ulong.MinValue)
        {
            var sqlText = "UPDATE RPG_User SET XPMultiplier = @0";
            if (userID != ulong.MinValue)
                sqlText += " WHERE UserID = @1";

            if (userID == ulong.MinValue)
            {
                foreach (var playerDetails in playerList)
                {
                    playerDetails.Value["XPMultiplier"] = multiplier;
                }
            }
            else
            {
                if (playerList.ContainsKey(userID))
                    playerList[userID]["XPMultiplier"] = multiplier;
            }
            var sql = Sql.Builder.Append(sqlText, multiplier, userID);

            if (usingMySQL())
                _mySql.ExecuteNonQuery(sql, _mySqlConnection);
            else
                _sqLite.ExecuteNonQuery(sql, _sqLiteConnection);
        }

        [ChatCommand("stats")]
        void StatsCommand(BasePlayer player, string command, string[] args)
        {
            var text = "<color=blue>ZLevels Remastered [" + Version + "] by Visagalis</color>\n" + "<color=yellow>" +
                          (string)messages["StatsHeadline"] + "</color>\n";

            foreach (var skill in Skills.ALL)
            {
                text += getStatPrint(player, skill);
            }

            rust.SendChatMessage(player, text, null, "76561198002115162");

            var details = playerList[player.userID];
            if (details.ContainsKey("LastDeath"))
            {
                var currentTime = DateTime.UtcNow;
                var lastDeath = ToDateTimeFromEpoch(details["LastDeath"]);
                var timeAlive = currentTime - lastDeath;
                PrintToChat(player, "Time alive: " + ReadableTimeSpan(timeAlive));
                if (details["XPMultiplier"].ToString() != "100")
                    PrintToChat(player, "XP rates for you are " + details["XPMultiplier"] + "%");
            }

            RenderUI(player);
        }

        public static string ReadableTimeSpan(TimeSpan span)
        {
            var formatted = string.Format("{0}{1}{2}{3}{4}",
                (span.Days / 7) > 0 ? string.Format("{0:0} weeks, ", span.Days / 7) : string.Empty,
                span.Days % 7 > 0 ? string.Format("{0:0} days, ", span.Days % 7) : string.Empty,
                span.Hours > 0 ? string.Format("{0:0} hours, ", span.Hours) : string.Empty,
                span.Minutes > 0 ? string.Format("{0:0} minutes, ", span.Minutes) : string.Empty,
                span.Seconds > 0 ? string.Format("{0:0} seconds, ", span.Seconds) : string.Empty);

            if (formatted.EndsWith(", ")) formatted = formatted.Substring(0, formatted.Length - 2);

            return formatted;
        }

        [ChatCommand("statinfo")]
        void StatInfoCommand(BasePlayer player, string command, string[] args)
        {
            var messagesText = "";
            long xpMultiplier = 100;
            if (inPlayerList(player.userID))
                xpMultiplier = playerList[player.userID]["XPMultiplier"];

            if (args.Length == 1)
            {
                var statname = args[0].ToLower();
                switch (statname)
                {
                    case "mining":
                        messagesText = "<color=" + colors[Skills.MINING] + ">Mining</color>" + (IsSkillDisabled(Skills.MINING) ? "(DISABLED)" : "") + "\n";
                        messagesText += "XP per hit: <color=" + colors[Skills.MINING] + ">" + ((int)pointsPerHit[Skills.MINING] * (xpMultiplier / 100f)) + "</color>\n";
                        messagesText += "Bonus materials per level: <color=" + colors[Skills.MINING] + ">" + ((getGathMult(2, Skills.MINING) - 1) * 100).ToString("0.##") + "%</color>\n";
                        break;
                    case "woodcutting":
                        messagesText = "<color=" + colors[Skills.WOODCUTTING] + ">Woodcutting</color>" + (IsSkillDisabled(Skills.WOODCUTTING) ? "(DISABLED)" : "") + "\n";
                        messagesText += "XP per hit: <color=" + colors[Skills.WOODCUTTING] + ">" + ((int)pointsPerHit[Skills.WOODCUTTING] * (xpMultiplier / 100f)) + "</color>\n";
                        messagesText += "Bonus materials per level: <color=" + colors[Skills.WOODCUTTING] + ">" + ((getGathMult(2, Skills.WOODCUTTING) - 1) * 100).ToString("0.##") + "%</color>\n";
                        break;
                    case "skinning":
                        messagesText = "<color=" + colors[Skills.SKINNING] + '>' + "Skinning" + "</color>" + (IsSkillDisabled(Skills.SKINNING) ? "(DISABLED)" : "") + "\n";
                        messagesText += "XP per hit: <color=" + colors[Skills.SKINNING] + ">" + ((int)pointsPerHit[Skills.SKINNING] * (xpMultiplier / 100f)) + "</color>\n";
                        messagesText += "Bonus materials per level: <color=" + colors[Skills.SKINNING] + ">" + ((getGathMult(2, Skills.SKINNING) - 1) * 100).ToString("0.##") + "%</color>\n";
                        break;
                    case "crafting":
                        messagesText = "<color=" + colors[Skills.CRAFTING] + '>' + "Crafting" + "</color>" + (IsSkillDisabled(Skills.CRAFTING) ? "(DISABLED)" : "") + "\n";
                        messagesText += "XP gain: <color=" + colors[Skills.SKINNING] + ">You get " + craftingDetails["XPPerTimeSpent"] + " XP per " + craftingDetails["TimeSpent"] + "s spent crafting.</color>\n";
                        messagesText += "Bonus: <color=" + colors[Skills.SKINNING] + ">Crafting time is decreased by " + craftingDetails["PercentFasterPerLevel"] + "% per every level.</color>\n";
                        break;
                    default:
                        messagesText = "No such stat: " + args[0];
                        messagesText += "\nYou must choose from these stats: <color=" + colors[Skills.MINING] + ">Mining</color>, <color=" + colors[Skills.SKINNING] + ">Skinning</color>, <color=" + colors[Skills.WOODCUTTING] + ">Woodcutting</color>, <color=" + colors[Skills.CRAFTING] + ">Crafting</color>";
                        break;
                }
            }
            else
            {
                messagesText = "You must choose from these stats: <color=" + colors[Skills.MINING] + ">Mining</color>, <color=" + colors[Skills.SKINNING] + ">Skinning</color>, <color=" + colors[Skills.WOODCUTTING] + ">Woodcutting</color>, <color=" + colors[Skills.CRAFTING] + ">Crafting</color>";
            }
            PrintToChat(player, messagesText);
        }

        [ChatCommand("statsui")]
        void StatsUICommand(BasePlayer player, string command, string[] args)
        {
            if (guioff.Contains(player.userID))
            {
                guioff.Remove(player.userID);
                RenderUI(player);
            }
            else
            {
                guioff.Add(player.userID);
                CuiHelper.DestroyUi(player, "StatsUI"); ;
            }
        }

        void OnPlayerSleepEnded(BasePlayer player)
        {
            if (inPlayerList(player.userID))
                RenderUI(player);
        }

        void OnLootEntity(BasePlayer looter, BaseEntity target)
        {
            if (!guioff.Contains(looter.userID))
            {
                CuiHelper.DestroyUi(looter, "StatsUI");
            }
        }

        void OnLootPlayer(BasePlayer looter, BasePlayer beingLooter)
        {
            OnLootEntity(looter, null);
        }

        void OnLootItem(BasePlayer looter, Item lootedItem)
        {
            OnLootEntity(looter, null);
        }

        void FillElements(ref CuiElementContainer elements, string mainPanel, int rowNumber, int maxRows, long level, int percent, string skillName, string progressColor, int fontSize, string xpBarAnchorMin, string xpBarAnchorMax)
        {
            var value = 1 / (float)maxRows;
            var positionMin = 1 - (value * rowNumber);
            var positionMax = 2 - (1 - (value * (1 - rowNumber)));
            var xpBarPlaceholder1 = new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = mainPanel,
                Components =
                        {
                            new CuiImageComponent { Color = "0.4 0.4 0.4 0.2" },
                            new CuiRectTransformComponent{ AnchorMin = "0 " + positionMin.ToString("0.####"), AnchorMax = $"1 "+ positionMax.ToString("0.####") }
                        }
            };
            elements.Add(xpBarPlaceholder1);

            var innerXPBar1 = new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = xpBarPlaceholder1.Name,
                Components =
                        {
                            new CuiImageComponent { Color = "0 0 0 0.8"},
                            new CuiRectTransformComponent{ AnchorMin = xpBarAnchorMin, AnchorMax = xpBarAnchorMax }
                        }
            };
            elements.Add(innerXPBar1);

            var innerXPBarProgress1 = new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = innerXPBar1.Name,
                Components =
                        {
                            new CuiImageComponent() { Color = progressColor},
                            new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = (percent / 100.0) + " 1" }
                        }
            };
            elements.Add(innerXPBarProgress1);

            var innerXPBarText1 = new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = innerXPBar1.Name,
                Components =
                        {
                            new CuiTextComponent { Color = "1 1 1 1", Text = skillName, FontSize = fontSize, Align = TextAnchor.MiddleCenter},
                            new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = "1 1" }
                        }
            };
            elements.Add(innerXPBarText1);

            var xpText1 = new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = xpBarPlaceholder1.Name,
                Components =
                        {
                            new CuiTextComponent { Text = percent + "%", FontSize = fontSize, Align = TextAnchor.MiddleRight, Color = "0.749019608 0.760784314 0.780392157 1" },
                            new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = $"0.98 1" }
                        }
            };
            elements.Add(xpText1);

            var lvText1 = new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = xpBarPlaceholder1.Name,
                Components =
                        {
                            new CuiTextComponent { Text = "Lv." + level, FontSize = fontSize, Align = TextAnchor.MiddleLeft, Color = "0.749019608 0.760784314 0.780392157 1" },
                            new CuiRectTransformComponent{ AnchorMin = "0.01 0", AnchorMax = $"0.5 1" }
                        }
            };
            elements.Add(lvText1);
        }

        void RenderUI(BasePlayer player)
        {
            if (guioff.Contains(player.userID))
                return;
            var skillColors = new Dictionary<string, string>();
            skillColors.Add("WC", "0.8 0.4 0 1");
            skillColors.Add("M", "0.1 0.5 0.8 0.6");
            skillColors.Add("S", "0.8 0.1 0 0.6");
            skillColors.Add("C", "0.2 0.72 0.5 0.8");
            var enabledSkillCount = 0;
            foreach (var skill in Skills.ALL)
            {
                if (!IsSkillDisabled(skill))
                    enabledSkillCount++;
            }

            CuiHelper.DestroyUi(player, "StatsUI");

            var elements = new CuiElementContainer();
            var mainName = elements.Add(new CuiPanel
            {
                Image =
                {
                    Color = "0.1 0.1 0.1 0.0"
                },
                RectTransform =
                {
                    AnchorMin = "0.69 0.0140",
                    AnchorMax = "0.83 0.1335"
                }
            }, "Hud", "StatsUI");

            var fontSize = 12;
            var xpBarAnchorMin = "0.16 0.1";
            var xpBarAnchorMax = "0.88 0.9";
            var currentSKillIndex = 1;


            foreach (var skill in Skills.ALL)
            {
                if (!IsSkillDisabled(skill))
                {
                    FillElements(ref elements, mainName, currentSKillIndex, enabledSkillCount, getLevel(player.userID, skill), getExperiencePercentInt(player,
                        skill), messages[skill + "Skill"].ToString(), skillColors[skill], fontSize, xpBarAnchorMin, xpBarAnchorMax);
                    currentSKillIndex++;
                }
            }

            CuiHelper.AddUi(player, elements);
        }

        string getStatPrint(BasePlayer player, string skill)
        {
            if (IsSkillDisabled(skill))
                return "";

            var skillMaxed = (int)levelCaps[skill] != 0 && getLevel(player.userID, skill) == (int)levelCaps[skill];
            var bonusText = "";
            if (skill == Skills.CRAFTING)
                bonusText =
                    (getLevel(player.userID, skill) * (int)craftingDetails["PercentFasterPerLevel"]).ToString("0.##");
            else
                bonusText = ((getGathMult(getLevel(player.userID, skill), skill) - 1) * 100).ToString("0.##");

            return string.Format("<color=" + colors[skill] + '>' + (string)messages["StatsText"] + "</color>\n",
                (string)messages[skill + "Skill"],
                getLevel(player.userID, skill) + (Convert.ToInt32(levelCaps[skill]) > 0 ? ("/" + levelCaps[skill]) : ""),
                getPoints(player.userID, skill),
                skillMaxed ? "â" : getLevelPoints(getLevel(player.userID, skill) + 1).ToString(),
                bonusText,
                getExperiencePercent(player, skill),
                getPenaltyPercent(player, skill) + "%");

        }

        #endregion

        #region Main/Other

        /// <summary>
        /// Converts the given date value to epoch time.
        /// </summary>
        long ToEpochTime(DateTime dateTime)
        {
            var date = dateTime.ToUniversalTime();
            var ticks = date.Ticks - new DateTime(1970, 1, 1, 0, 0, 0, 0).Ticks;
            var ts = ticks / TimeSpan.TicksPerSecond;
            return ts;
        }

        /// <summary>
        /// Converts the given epoch time to a <see cref="DateTime"/> with <see cref="DateTimeKind.Utc"/> kind.
        /// </summary>
        DateTime ToDateTimeFromEpoch(long intDate)
        {
            var timeInTicks = intDate * TimeSpan.TicksPerSecond;
            return new DateTime(1970, 1, 1, 0, 0, 0, 0).AddTicks(timeInTicks);
        }

        void Loaded()
        {
            StartConnection();

            if ((_craftData = Interface.GetMod().DataFileSystem.ReadObject<CraftData>("ZLevelsCraftDetails")) == null)
            {
                _craftData = new CraftData();
            }

            foreach (var player in BasePlayer.activePlayerList)
            {
                loadUser(player);
            }
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity is BasePlayer)
            {
                var player = (BasePlayer)entity;
                var isPlaying = EventManager?.Call("isPlaying", player);
                if (!inPlayerList(player.userID) || (isPlaying is bool && (bool)isPlaying)) return;

                var penaltyText = "<color=#FF0000>You have lost XP for dying:";
                var penaltyExist = false;
                foreach (var skill in Skills.ALL)
                {
                    if (!IsSkillDisabled(skill))
                    {
                        var penalty = GetPenalty(player, skill);
                        if (penalty > 0)
                        {
                            penaltyText += "\n* -" + penalty + " " + messages[skill + "Skill"] + " XP.";
                            removePoints(player.userID, skill, penalty);
                            penaltyExist = true;
                        }
                    }
                }
                penaltyText += "</color>";

                if (penaltyExist)
                    PrintToChat(player, penaltyText);
                SetPlayerLastDeathDate(player.userID);
                RenderUI(player);
            }

        }

        void SetPlayerLastDeathDate(ulong userID) => setPlayerData(userID, "LastDeath", ToEpochTime(DateTime.UtcNow));

        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            var player = entity as BasePlayer;
            if (player == null) return;

            if (!IsSkillDisabled(Skills.WOODCUTTING))
                if ((int)dispenser.gatherType == 0) levelHandler(player, item, Skills.WOODCUTTING);
            if (!IsSkillDisabled(Skills.MINING))
                if ((int)dispenser.gatherType == 1) levelHandler(player, item, Skills.MINING);
            if (!IsSkillDisabled(Skills.SKINNING))
                if ((int)dispenser.gatherType == 2) levelHandler(player, item, Skills.SKINNING);
        }

        void OnCollectiblePickup(Item item, BasePlayer player)
        {
            var skillName = string.Empty;
            switch (item.info.shortname.ToLower())
            {
                case "wood":
                    skillName = Skills.WOODCUTTING;
                    break;
                case "cloth":
                case "mushroom":
                case "corn":
                case "pumpkin":
                case "seed.hemp":
                case "seed.pumpkin":
                case "seed.corn":
                    skillName = Skills.SKINNING;
                    break;
                case "metal.ore":
                case "sulfur.ore":
                case "stones":
                    skillName = Skills.MINING;
                    break;
            }

            if (!string.IsNullOrEmpty(skillName))
                levelHandler(player, item, skillName);
            else
                Puts("Developer missed this item, which can be picked up: [" + item.info.shortname + "]. Let him know on Oxide forums!");
        }

        void levelHandler(BasePlayer player, Item item, string skill)
        {
            var xpPercentBefore = getExperiencePercent(player, skill);
            var Level = getLevel(player.userID, skill);
            var Points = getPoints(player.userID, skill);
            item.amount = (int)(item.amount * getGathMult(Level, skill));

            var pointsToGet = (int)pointsPerHit[skill];
            var xpMultiplier = Convert.ToInt64(playerList[player.userID]["XPMultiplier"]);
            Points += Convert.ToInt64(pointsToGet * (xpMultiplier / 100f));
            getPointsLevel(Points, skill);
            try
            {
                if (Points >= getLevelPoints(Level + 1))
                {
                    var maxLevel = (int)levelCaps[skill] > 0 && Level + 1 > (int)levelCaps[skill];
                    if (!maxLevel)
                    {
                        Level = getPointsLevel(Points, skill);
                        PrintToChat(player, string.Format("<color=" + colors[skill] + '>' + (string)messages["LevelUpText"] + "</color>",
                            (string)messages[skill + "Skill"],
                            Level,
                            Points,
                            getLevelPoints(Level + 1),
                            ((getGathMult(Level, skill) - 1) * 100).ToString("0.##")
                            )
                        );
                    }
                }
            }
            catch (Exception ex)
            {
                Puts(ex.Message);
            }

            setPointsAndLevel(player.userID, skill, Points, Level);

            var xpPercentAfter = getExperiencePercent(player, skill);
            if (!xpPercentAfter.Equals(xpPercentBefore))
                RenderUI(player);
        }

        #endregion

        #region Utility

        long getLevelPoints(long level) => 110 * level * level - 100 * level;

        long getPointsLevel(long points, string skill)
        {
            var a = 110;
            var b = 100;
            var c = -points;
            var x1 = (-b - Math.Sqrt(b * b - 4 * a * c)) / (2 * a);
            if ((int)levelCaps[skill] == 0 || (int)-x1 <= (int)levelCaps[skill])
                return (int)-x1;
            return (int)levelCaps[skill];
        }

        double getGathMult(long skillLevel, string skill)
        {
            return 1 + Convert.ToDouble(resourceMultipliers[skill]) * 0.1 * (skillLevel - 1);
        }

        bool inPlayerList(UInt64 userID)
        {
            return playerList.ContainsKey(userID);

        }

        #endregion

        #region Saving

        void OnServerSave() => SaveUsers();

        void Unload()
        {
            SaveUsers();
            if (_mySqlConnection != null)
                _mySqlConnection = null;
            else
            {
                _sqLiteConnection = null;
            }

            foreach (var player in BasePlayer.activePlayerList)  // destroy UI when unloading.
            {
                if (guioff.Contains(player.userID))
                    return;
                CuiHelper.DestroyUi(player, "StatsUI");
            }
        }
        #endregion

        #region Config

        Dictionary<string, object> resourceMultipliers;
        Dictionary<string, object> levelCaps;
        Dictionary<string, object> pointsPerHit;
        Dictionary<string, object> craftingDetails;
        Dictionary<string, object> percentLostOnDeath;
        Dictionary<string, object> messages;
        Dictionary<string, object> dbConnection;

        protected override void LoadDefaultConfig() { }

        void Init()
        {
            resourceMultipliers = checkCfg<Dictionary<string, object>>("ResourcePerLevelMultiplier", new Dictionary<string, object>{
                {Skills.WOODCUTTING, 2.0d},
                {Skills.MINING, 2.0d},
                {Skills.SKINNING, 2.0d}
            });
            levelCaps = checkCfg<Dictionary<string, object>>("LevelCaps", new Dictionary<string, object>{
                {Skills.WOODCUTTING, 200},
                {Skills.MINING, 200},
                {Skills.SKINNING, 200},
                {Skills.CRAFTING, -1}
            });
            pointsPerHit = checkCfg<Dictionary<string, object>>("PointsPerHit", new Dictionary<string, object>{
                {Skills.WOODCUTTING, 30},
                {Skills.MINING, 30},
                {Skills.SKINNING, 30}
            });
            craftingDetails = checkCfg<Dictionary<string, object>>("CraftingDetails", new Dictionary<string, object>{
                { "TimeSpent", 1},
                { "XPPerTimeSpent", 3},
                { "PercentFasterPerLevel", 5 }
            });
            percentLostOnDeath = checkCfg<Dictionary<string, object>>("PercentLostOnDeath", new Dictionary<string, object>{
                {Skills.WOODCUTTING, 50},
                {Skills.MINING, 50},
                {Skills.SKINNING, 50},
                {Skills.CRAFTING, 50}
            });

            dbConnection = checkCfg<Dictionary<string, object>>("dbConnection", new Dictionary<string, object>{
                {"UseMySQL", false },
                {"Host", "127.0.0.1"},
                {"Port", 3306 },
                {"Username", "user" },
                {"Password", "password" },
                {"Database", "db" },
                {"GameProtocol", Rust.Protocol.network }
            });

            messages = checkCfg<Dictionary<string, object>>("Messages", new Dictionary<string, object>{
                {"StatsHeadline", "Level stats (/statinfo [statname] - To get more information about skill)"},
                {"StatsText",   "-{0}"+
                            "\nLevel: {1} (+{4}% bonus) \nXP: {2}/{3} [{5}].\n<color=red>-{6} XP loose on death.</color>"},
                {"LevelUpText", "{0} Level up"+
                            "\nLevel: {1} (+{4}% bonus) \nXP: {2}/{3}"},
                {"WCSkill", "Woodcutting"},
                {"MSkill", "Mining"},
                {"SSkill", "Skinning"},
                {"CSkill", "Crafting" }
            });
            SaveConfig();
        }

        T checkCfg<T>(string conf, T def)
        {
            if (Config[conf] != null)
            {
                return (T)Config[conf];
            }
            else
            {
                Config[conf] = def;
                return def;
            }
        }
        #endregion

        #region Adds&Removse

        void removePoints(UInt64 userID, string skill, long points)
        {
            if (playerList[userID][skill + "Points"] - 10 > points)
                playerList[userID][skill + "Points"] -= points;
            else
                playerList[userID][skill + "Points"] = 10;

            setLevel(userID, skill, getPointsLevel(playerList[userID][skill + "Points"], skill));
        }

        #endregion

        #region Gets&Sets

        long getLevel(UInt64 userID, string skill)
        {
            if (!playerList.ContainsKey(userID))
                Puts("Trying to get [" + messages[skill + "Skill"] + "]. For player who's SteamID: [" + userID + "]. He is not on a user list yet?");
            if (!playerList[userID].ContainsKey(skill + "Level"))
                playerList[userID].Add(skill + "Level", 1);

            return playerList[userID][skill + "Level"];
        }

        long getPoints(UInt64 userID, string skill)
        {
            if (!playerList[userID].ContainsKey(skill + "Points"))
                playerList[userID].Add(skill + "Points", 11);

            return playerList[userID][skill + "Points"];
        }

        void setLevel(UInt64 userID, string skill, long level)
        {
            setPlayerData(userID, skill + "Level", level);
        }

        #endregion

        #region New stuff

        bool IsSkillDisabled(string skill)
        {
            return levelCaps[skill].ToString() == "-1";
        }

        bool usingMySQL()
        {
            return Convert.ToBoolean(dbConnection["UseMySQL"]);
        }

        int GetPenalty(BasePlayer player, string skill)
        {
            var penalty = 0;
            var penaltyPercent = getPenaltyPercent(player, skill);
            penalty = Convert.ToInt32(getPercentAmount(playerList[player.userID][skill + "Level"], penaltyPercent));
            return penalty;
        }

        int getPenaltyPercent(BasePlayer player, string skill)
        {
            var penaltyPercent = 0;
            var details = playerList[player.userID];

            if (details.ContainsKey("LastDeath"))
            {
                var currentTime = DateTime.UtcNow;
                var lastDeath = ToDateTimeFromEpoch(details["LastDeath"]);
                var timeAlive = currentTime - lastDeath;
                if (timeAlive.TotalMinutes > 10)
                {
                    penaltyPercent = ((int)percentLostOnDeath[skill] - ((int)timeAlive.TotalHours * (int)percentLostOnDeath[skill] / 10));
                    if (penaltyPercent < 0)
                        penaltyPercent = 0;
                }
            }
            return penaltyPercent;
        }

        object OnItemCraftFinished(ItemCraftTask task, Item item)
        {
            if (IsSkillDisabled(Skills.CRAFTING))
                return null;

            var crafter = task.owner;
            var xpPercentBefore = getExperiencePercent(crafter, Skills.CRAFTING);
            if (task.blueprint == null)
            {
                Puts("There is problem obtaining task.blueprint on 'OnItemCraftFinished' hook! This is usually caused by some incompatable plugins.");
                return null;
            }
            var experienceGain = Convert.ToInt32(Math.Floor((task.blueprint.time + 0.99f) / (int)craftingDetails["TimeSpent"]));//(int)task.blueprint.time / 10;
            if (experienceGain == 0)
                return null;

            long Level = 0;
            long Points = 0;
            try
            {
                Level = getLevel(crafter.userID, Skills.CRAFTING);
                Points = getPoints(crafter.userID, Skills.CRAFTING);
            }
            catch (Exception ex)
            {
                Puts("Problem when getting level/points for player. Error:" + ex.StackTrace);
            }
            Points += experienceGain * (int)craftingDetails["XPPerTimeSpent"];
            if (Points >= getLevelPoints(Level + 1))
            {
                var maxLevel = (int)levelCaps[Skills.CRAFTING] > 0 && Level + 1 > (int)levelCaps[Skills.CRAFTING];
                if (!maxLevel)
                {
                    Level = getPointsLevel(Points, Skills.CRAFTING);
                    PrintToChat(crafter, string.Format("<color=" + colors[Skills.CRAFTING] + '>' + (string)messages["LevelUpText"] + "</color>",
                        (string)messages["CSkill"],
                        Level,
                        Points,
                        getLevelPoints(Level + 1),
                        (getLevel(crafter.userID, Skills.CRAFTING) * Convert.ToDouble(craftingDetails["PercentFasterPerLevel"]))
                        )
                    );
                }
            }
            try
            {
                if (item.info.shortname != "lantern_a" && item.info.shortname != "lantern_b")
                {
                    setPointsAndLevel(crafter.userID, Skills.CRAFTING, Points, Level);
                }
            }
            catch (Exception ex)
            {
                Puts("Problem when setting crafting xp/level for player. Error information:" + ex.StackTrace);
            }

            try
            {
                var xpPercentAfter = getExperiencePercent(crafter, Skills.CRAFTING);
                if (!xpPercentAfter.Equals(xpPercentBefore))
                    RenderUI(crafter);
            }
            catch (Exception ex)
            {
                Puts("Problem when checking if we should RenderUI: " + ex.StackTrace);
            }

            if (task.amount > 0) return null;
            if (task.blueprint != null && task.blueprint.name.Contains("(Clone)"))
            {
                var behaviours = task.blueprint.GetComponents<MonoBehaviour>();
                foreach (var behaviour in behaviours)
                {
                    if (behaviour.name.Contains("(Clone)")) UnityEngine.Object.Destroy(behaviour);
                }
                task.blueprint = null;
            }
            return null;
        }

        object OnItemCraft(ItemCraftTask task, BasePlayer crafter)
        {
            if (IsSkillDisabled(Skills.CRAFTING))
                return null;

            var Level = getLevel(crafter.userID, Skills.CRAFTING);

            var craftingTime = task.blueprint.time;
            var amountToReduce = task.blueprint.time * ((float)(Level * (int)craftingDetails["PercentFasterPerLevel"]) / 100);
            craftingTime -= amountToReduce;
            if (craftingTime < 0)
                craftingTime = 0;
            if (craftingTime == 0)
            {
                try
                {
                    foreach (var entry in _craftData.CraftList)
                    {
                        var itemname = task.blueprint.targetItem.shortname;
                        if (entry.Value.shortName == itemname && entry.Value.Enabled)
                        {
                            var amount = task.amount;
                            if (amount >= entry.Value.MinBulkCraft && amount <= entry.Value.MaxBulkCraft)
                            {
                                var item = GetItem(itemname);
                                var final_amount = task.blueprint.amountToCreate * amount;
                                var newItem = ItemManager.CreateByItemID(item.itemid, (int)final_amount);
                                crafter.inventory.GiveItem(newItem);

                                var returnstring = "You have crafted <color=#66FF66>" + amount + "</color> <color=#66FFFF>" + item.displayName.english + "</color>\n[Batch Amount: <color=#66FF66>" + final_amount + "</color>]";
                                PrintToChat(crafter, returnstring);
                                return false;
                            }
                        }
                    }
                }
                catch
                {
                    GenerateItems();
                }
            }

            if (!task.blueprint.name.Contains("(Clone)"))
                task.blueprint = UnityEngine.Object.Instantiate(task.blueprint);
            task.blueprint.time = craftingTime;
            return null;
        }

        int MaxB = 999;
        int MinB = 10;
        int Cooldown = 0;

        /*
            Thanks Norn for this piece of code!
            It was borrowed from his plugin:
            http://oxidemod.org/threads/magic-craft.11784/
        */
        void GenerateItems(bool reset = false)
        {
            if (!reset)
            {
                var config_protocol = dbConnection["GameProtocol"].ToString();
                if (config_protocol != Rust.Protocol.network.ToString())
                {
                    dbConnection["GameProtocol"] = Rust.Protocol.network.ToString();
                    Puts("Updating item list from protocol " + config_protocol + " to protocol " + dbConnection["GameProtocol"] + ".");
                    GenerateItems(true);
                    SaveConfig();
                    return;
                }
            }

            if (reset)
            {
                Interface.GetMod().DataFileSystem.WriteObject("ZLevelsCraftDetails.old", _craftData);
                _craftData.CraftList.Clear();
                Puts("Generating new item list...");
            }

            mcITEMS = ItemManager.itemList.ToDictionary(i => i.shortname);
            int loaded = 0, enabled = 0;
            foreach (var definition in mcITEMS)
            {
                if (definition.Value.shortname.Length >= 1)
                {
                    CraftInfo p;
                    if (_craftData.CraftList.TryGetValue(definition.Value.shortname, out p))
                    {
                        if (p.Enabled) { enabled++; }
                        loaded++;
                    }
                    else
                    {
                        var z = new CraftInfo
                        {
                            shortName = definition.Value.shortname,
                            MaxBulkCraft = MaxB,
                            MinBulkCraft = MinB,
                            Enabled = true
                        };
                        _craftData.CraftList.Add(definition.Value.shortname, z);
                        loaded++;
                    }
                }
            }
            var inactive = loaded - enabled;
            Puts("Loaded " + loaded + " items. (Enabled: " + enabled + " | Inactive: " + inactive + ").");
            Interface.GetMod().DataFileSystem.WriteObject("ZLevelsCraftDetails", _craftData);
        }

        class CraftInfo
        {
            public int MaxBulkCraft;
            public int MinBulkCraft;
            public string shortName;
            public bool Enabled;
        }

        Dictionary<string, ItemDefinition> mcITEMS;

        ItemDefinition GetItem(string shortname)
        {
            if (string.IsNullOrEmpty(shortname) || mcITEMS == null) return null;
            ItemDefinition item;
            if (mcITEMS.TryGetValue(shortname, out item)) return item;
            return null;
        }

        long getPointsNeededForNextLevel(long level)
        {
            var startingPoints = getLevelPoints(level);
            var nextLevelPoints = getLevelPoints(level + 1);
            var pointsNeeded = nextLevelPoints - startingPoints;
            return pointsNeeded;
        }

        long getPercentAmount(long level, int percent)
        {
            var points = getPointsNeededForNextLevel(level);
            var percentPoints = (points * percent) / 100;
            return percentPoints;
        }

        int getExperiencePercentInt(BasePlayer player, string skill)
        {
            var Level = getLevel(player.userID, skill);
            var startingPoints = getLevelPoints(Level);
            var nextLevelPoints = getLevelPoints(Level + 1) - startingPoints;
            var Points = getPoints(player.userID, skill) - startingPoints;
            var experienceProc = Convert.ToInt32((Points / (double)nextLevelPoints) * 100);
            if (experienceProc >= 100)
                experienceProc = 99;
            else if (experienceProc == 0)
                experienceProc = 1;
            return experienceProc;
        }

        string getExperiencePercent(BasePlayer player, string skill)
        {
            var percent = getExperiencePercentInt(player, skill) + "%";
            return percent;
        }

        #endregion
    }
}


// --- End of file: ZLevelsRemastered.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TimedPermissions.cs ---
// --- Original Local Path: TimedPermissions.cs ---

using System.Text.RegularExpressions;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using System;

namespace Oxide.Plugins
{
    [Info("Timed Permissions", "LaserHydra", "1.2.1", ResourceId = 1926)]
    [Description("Allows you to grant permissions or groups for a specific time")]
    class TimedPermissions : CovalencePlugin
    {
        static TimedPermissions Instance = null;
        static List<Player> _players = new List<Player>();

        #region Classes

        class Player
        {
            PluginTimers timer = new PluginTimers(Interface.Oxide.RootPluginManager.GetPlugin("TimedPermissions"));
            public List<TimedPermission> permissions = new List<TimedPermission>();
            public List<TimedGroup> groups = new List<TimedGroup>();
            public string name = "unknown";
            public string steamID = "0";

            public Player()
            {
                timer.Repeat(60, 0, () => Update());
            }

            internal Player(IPlayer player)
            {
                steamID = player.Id;
                name = player.Name;

                timer.Repeat(60, 0, () => Update());
            }

            internal Player(string steamID)
            {
                this.steamID = steamID;

                timer.Repeat(1, 0, () => Update());
            }

            internal static Player Get(IPlayer player) => Get(player.Id);

            internal static Player Get(string steamID) => _players.Find((p) => p.steamID == steamID);

            internal static Player GetOrCreate(IPlayer player)
            {
                Player pl = Get(player);

                if (pl == null)
                {
                    pl = new Player(player);

                    _players.Add(pl);
                    SaveData(ref _players);
                }

                return pl;
            }

            internal static Player GetOrCreate(string steamID)
            {
                Player pl = Get(steamID);

                if (pl == null)
                {
                    pl = new Player(steamID);

                    _players.Add(pl);
                    SaveData(ref _players);
                }

                return pl;
            }

            internal void AddPermission(string permission, DateTime expireDate)
            {
                permissions.Add(new TimedPermission(permission, expireDate));
                Instance.permission.GrantUserPermission(steamID, permission, null);

                Instance.Puts($"----> {name} ({steamID}) - Permission Granted: {permission} for {expireDate - DateTime.Now}" + Environment.NewLine);

                SaveData(ref _players);
            }

            internal void RemovePermission(string permission)
            {
                permissions.Remove(TimedPermission.Get(permission, this));
                Instance.permission.RevokeUserPermission(steamID, permission);
                
                Instance.Puts($"----> {name} ({steamID}) - Permission Expired: {permission}" + Environment.NewLine);

                if (groups.Count == 0 && permissions.Count == 0)
                    _players.Remove(this);

                SaveData(ref _players);
            }

            internal void AddGroup(string group, DateTime expireDate)
            {
                groups.Add(new TimedGroup(group, expireDate));
                Instance.permission.AddUserGroup(steamID, group);

                Instance.Puts($"----> {name} ({steamID}) - Added to Group: {group} for {expireDate - DateTime.Now}" + Environment.NewLine);

                SaveData(ref _players);
            }

            internal void RemoveGroup(string group)
            {
                groups.Remove(TimedGroup.Get(group, this));
                Instance.permission.RemoveUserGroup(steamID, group);
                
                Instance.Puts($"----> {name} ({steamID}) - Group Expired: {group}" + Environment.NewLine);

                if (groups.Count == 0 && permissions.Count == 0)
                    _players.Remove(this);

                SaveData(ref _players);
            }

            internal void UpdatePlayer(IPlayer player) => name = player.Name;
            
            internal void Update()
            {
                foreach (TimedPermission perm in CopyList(permissions))
                    if (perm.Expired)
                        RemovePermission(perm.permission);

                foreach (TimedGroup group in CopyList(groups))
                    if (group.Expired)
                        RemoveGroup(group.group);
            }

            List<T> CopyList<T>(List<T> list)
            {
                T[] array = new T[list.Count];
                list.CopyTo(array);

                return array.ToList();
            }

            public override bool Equals(object obj)
            {
                if(obj is Player)
                    return ((Player) obj).steamID == steamID;

                return false;
            }

            public override int GetHashCode() => steamID.GetHashCode();
        }

        class TimedPermission
        {
            public string permission = string.Empty;
            public string _expireDate = "00/00/00/00/0000";

            internal DateTime expireDate
            {
                get
                {
                    int[] date = (from val in _expireDate.Split('/') select Convert.ToInt32(val)).ToArray();
                    return new DateTime(date[4], date[3], date[2], date[1], date[0], 0);
                }
                set
                {
                    _expireDate = $"{value.Minute}/{value.Hour}/{value.Day}/{value.Month}/{value.Year}";
                }
            }

            internal bool Expired
            {
                get
                {
                    return DateTime.Compare(DateTime.Now, expireDate) > 0;
                }
            }

            public TimedPermission()
            {
            }

            internal TimedPermission(string permission, DateTime expireDate)
            {
                this.permission = permission;
                this.expireDate = expireDate;
            }

            internal static TimedPermission Get(string permission, Player player) => player.permissions.Find((p) => p.permission == permission);

            public override bool Equals(object obj) => ((TimedPermission) obj).permission == permission;

            public override int GetHashCode() => permission.GetHashCode();
        }

        class TimedGroup
        {
            public string group = string.Empty;
            public string _expireDate = "00/00/00/00/0000";

            internal DateTime expireDate
            {
                get
                {
                    int[] date = (from val in _expireDate.Split('/') select Convert.ToInt32(val)).ToArray();
                    return new DateTime(date[4], date[3], date[2], date[1], date[0], 0);
                }
                set
                {
                    _expireDate = $"{value.Minute}/{value.Hour}/{value.Day}/{value.Month}/{value.Year}";
                }
            }

            internal bool Expired
            {
                get
                {
                    return DateTime.Compare(DateTime.Now, expireDate) > 0;
                }
            }

            public TimedGroup()
            {
            }

            internal TimedGroup(string group, DateTime expireDate)
            {
                this.group = group;
                this.expireDate = expireDate;
            }

            internal static TimedGroup Get(string group, Player player) => player.groups.Find((p) => p.group == group);

            public override bool Equals(object obj) => ((TimedGroup) obj).group == group;

            public override int GetHashCode() => group.GetHashCode();
        }

        #endregion

        #region Plugin General

        ////////////////////////////////////////
        ///     Plugin Related Hooks
        ////////////////////////////////////////

        void Loaded()
        {
            Instance = this;

            LoadMessages();
            LoadData(ref _players);

            PrintWarning("This plugin was moved! New URL: http://oxidemod.org/plugins/timed-permissions.1926/");
            timer.Repeat(120, 0, () => PrintWarning("This plugin was moved! New URL: http://oxidemod.org/plugins/timed-permissions.1926/"));
        }

        ////////////////////////////////////////
        ///     Config & Message Loading
        ////////////////////////////////////////

        void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"No Permission", "You don't have permission to use this command."},
                {"Invalid Time Format", "Invalid Time Format: Ex: 1d12h30m | d = days, h = hours, m = minutes"},
                {"Player Has No Info", "There is no info about this player."},
                {"Player Info", $"Info about <color=#C4FF00>{{player}}</color>:{Environment.NewLine}<color=#C4FF00>Groups</color>: {{groups}}{Environment.NewLine}<color=#C4FF00>Permissions</color>: {{permissions}}"}
            }, this);
        }
        
        #endregion

        #region Commands

        [Command("grantperm", "global.grantperm"), Permission("timedpermissions.use")]
        void cmdGrantPerm(IPlayer player, string cmd, string[] args)
        {
            if (args.Length != 3)
            {
                player.Reply($"Syntax: {(player.ConnectedPlayer.LastCommand == CommandType.Console ? string.Empty : "/")}grantperm <player|steamid> <permission> <time Ex: 1d12h30m>");
                return;
            }
            
            ulong steamID = 0;
            IPlayer target = null;
            string permission = args[1];
            DateTime expireDate;

            if(!TryConvert(args[0], out steamID))
                target = GetPlayer(args[0], player);

            if (steamID == 0 && target == null)
                return;

            if (!TryGetDateTime(args[2], out expireDate))
            {
                player.Reply(GetMsg("Invalid Time Format", player?.Id ?? null));
                return;
            }

            if (target != null)
            {
                if (Player.GetOrCreate(target) == null)
                    _players.Add(new Player(target));

                Player.GetOrCreate(target).AddPermission(permission, expireDate);
            }
            else if (steamID != 0)
            {
                if (Player.GetOrCreate(steamID.ToString()) == null)
                    _players.Add(new Player(steamID.ToString()));

                Player.GetOrCreate(steamID.ToString()).AddPermission(permission, expireDate);
            }
        }

        [Command("addgroup", "global.addgroup"), Permission("timedpermissions.use")]
        void cmdAddGroup(IPlayer player, string cmd, string[] args)
        {
            if (args.Length != 3)
            {
                player.Reply($"Syntax: {(player == null ? string.Empty : "/")}addgroup <player|steamid> <group> <time Ex: 1d12h30m>");
                return;
            }

            ulong steamID = 0;
            IPlayer target = null;
            string group = args[1];
            DateTime expireDate;

            if (!TryConvert(args[0], out steamID))
                target = GetPlayer(args[0], player);

            if (steamID == 0 && target == null)
                return;

            if (!TryGetDateTime(args[2], out expireDate))
            {
                player.Reply(GetMsg("Invalid Time Format", player?.Id ?? null));
                return;
            }

            if (target != null)
            {
                if (Player.GetOrCreate(target) == null)
                    _players.Add(new Player(target));

                Player.GetOrCreate(target).AddGroup(group, expireDate);
            }
            else if (steamID != 0)
            {
                if (Player.GetOrCreate(steamID.ToString()) == null)
                    _players.Add(new Player(steamID.ToString()));

                Player.GetOrCreate(steamID.ToString()).AddGroup(group, expireDate);
            }
        }

        [Command("pinfo", "global.pinfo"), Permission("timedpermissions.use")]
        void cmdPlayerInfo(IPlayer player, string cmd, string[] args)
        {
            if (args.Length != 3)
            {
                player.Reply($"Syntax: {(player == null ? string.Empty : "/")}pinfo <player|steamid>");
                return;
            }

            ulong steamID = 0;
            IPlayer target = null;
            string group = args[1];

            if (!TryConvert(args[0], out steamID))
                target = GetPlayer(args[0], player);

            if (steamID == 0 && target == null)
                return;

            if (target != null)
            {
                if (Player.GetOrCreate(target) == null)
                    _players.Add(new Player(target));

                Player pl = Player.Get(target);

                if (pl == null)
                    player.Reply(GetMsg("Player Has No Info"));
                else
                {
                    string msg = GetMsg("Player info");
                    
                    msg = msg.Replace("{player}", $"{pl.name} ({pl.steamID})");
                    msg = msg.Replace("{groups}", string.Join(", ", (from g in pl.groups select $"{g.@group} until {g.expireDate}").ToArray()));
                    msg = msg.Replace("{permissions}", string.Join(", ", (from p in pl.permissions select $"{p.permission} until {p.expireDate}").ToArray()));

                    player.Reply(msg);
                }
            }
            else if (steamID != 0)
            {
                if (Player.GetOrCreate(steamID.ToString()) == null)
                    _players.Add(new Player(steamID.ToString()));

                Player pl = Player.Get(steamID.ToString());

                if (pl == null)
                    player.Reply(GetMsg("Player Has No Info"));
                else
                {
                    string msg = GetMsg("Player info");

                    msg = msg.Replace("{player}", $"{pl.name} ({pl.steamID})");
                    msg = msg.Replace("{groups}", string.Join(", ", (from g in pl.groups select $"{g.@group} until {g.expireDate}").ToArray()));
                    msg = msg.Replace("{permissions}", string.Join(", ", (from p in pl.permissions select $"{p.permission} until {p.expireDate}").ToArray()));
                    
                    player.Reply(msg);
                }
            }
        }

        #endregion

        #region Subject Related

        bool TryGetDateTime(string source, out DateTime date)
        {
            int minutes = 0;
            int hours = 0;
            int days = 0;

            Match m = new Regex(@"(\d+?)m", RegexOptions.IgnoreCase).Match(source);
            Match h = new Regex(@"(\d+?)h", RegexOptions.IgnoreCase).Match(source);
            Match d = new Regex(@"(\d+?)d", RegexOptions.IgnoreCase).Match(source);

            if (m.Success)
                minutes = Convert.ToInt32(m.Groups[1].ToString());

            if (h.Success)
                hours = Convert.ToInt32(h.Groups[1].ToString());

            if (d.Success)
                days = Convert.ToInt32(d.Groups[1].ToString());

            source = source.Replace(minutes.ToString() + "m", string.Empty);
            source = source.Replace(hours.ToString() + "h", string.Empty);
            source = source.Replace(days.ToString() + "d", string.Empty);

            if (!string.IsNullOrEmpty(source) || (!m.Success && !h.Success && !d.Success))
            {
                date = default(DateTime);
                return false;
            }

            date = DateTime.Now + new TimeSpan(days, hours, minutes, 0);
            return true;
        }

        #endregion

        #region General Methods

        ////////////////////////////////////////
        ///     Player Finding
        ////////////////////////////////////////

        IPlayer GetPlayer(string searchedPlayer, IPlayer player)
        {
            foreach (ILivePlayer current in players.GetAllOnlinePlayers())
                if (current.BasePlayer.Name.ToLower() == searchedPlayer.ToLower())
                    return current.BasePlayer;

            List<IPlayer> foundPlayers =
                (from current in players.GetAllOnlinePlayers()
                 where current.BasePlayer.Name.ToLower().Contains(searchedPlayer.ToLower())
                 select current.BasePlayer).ToList();

            switch (foundPlayers.Count)
            {
                case 0:
                    player.Reply("The player can not be found.");
                    break;

                case 1:
                    return foundPlayers[0];

                default:
                    List<string> playerNames = (from current in foundPlayers select current.Name).ToList();
                    string players = ListToString(playerNames, 0, ", ");
                    player.Reply("Multiple matching players found: \n" + players);
                    break;
            }

            return null;
        }

        ////////////////////////////////////////
        ///     Converting
        ////////////////////////////////////////

        string ListToString<T>(List<T> list, int first, string seperator) => string.Join(seperator, (from item in list select item.ToString()).Skip(first).ToArray());

        bool TryConvert<S, C>(S source, out C converted)
        {
            try
            {
                converted = (C) Convert.ChangeType(source, typeof(C));
                return true;
            }
            catch (Exception)
            {
                converted = default(C);
                return false;
            }
        }

        ////////////////////////////////////////
        ///     Config Related
        ////////////////////////////////////////

        void SetConfig(params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList();
            stringArgs.RemoveAt(args.Length - 1);

            if (Config.Get(stringArgs.ToArray()) == null) Config.Set(args);
        }

        T GetConfig<T>(T defaultVal, params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList();
            if (Config.Get(stringArgs.ToArray()) == null)
            {
                PrintError($"The plugin failed to read something from the config: {ListToString(stringArgs, 0, "/")}{Environment.NewLine}Please reload the plugin and see if this message is still showing. If so, please post this into the support thread of this plugin.");
                return defaultVal;
            }

            return (T)Convert.ChangeType(Config.Get(stringArgs.ToArray()), typeof(T));
        }

        ////////////////////////////////////////
        ///     Data Related
        ////////////////////////////////////////

        void LoadData<T>(ref T data, string filename = "TimedPermissions") => data = Interface.Oxide.DataFileSystem.ReadObject<T>(filename);

        static void SaveData<T>(ref T data, string filename = "TimedPermissions") => Interface.Oxide.DataFileSystem.WriteObject(filename, data);

        ////////////////////////////////////////
        ///     Message Related
        ////////////////////////////////////////

        string GetMsg(string key, object userID = null) => lang.GetMessage(key, this, userID == null ? null : userID.ToString());

        ////////////////////////////////////////
        ///     Permission Related
        ////////////////////////////////////////

        void RegisterPerm(params string[] permArray)
        {
            string perm = ListToString(permArray.ToList(), 0, ".");

            permission.RegisterPermission($"{PermissionPrefix}.{perm}", this);
        }

        bool HasPerm(object uid, params string[] permArray)
        {
            string perm = ListToString(permArray.ToList(), 0, ".");

            return permission.UserHasPermission(uid.ToString(), $"{PermissionPrefix}.{perm}");
        }

        string PermissionPrefix
        {
            get
            {
                return this.Title.Replace(" ", "").ToLower();
            }
        }

        ////////////////////////////////////////
        ///     Messaging
        ////////////////////////////////////////

        static void Print(string message) => ConsoleSystem.Run.Server.Normal($"echo {message}");

        #endregion
    }
}


// --- End of file: TimedPermissions.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Fix.cs ---
// --- Original Local Path: Fix.cs ---

﻿using Oxide.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Fix", "playermodel", "1.0.0")]
    public class Fix : RustPlugin
    {
        object OnPlayerViolation(BasePlayer player, AntiHackType type, float amount)
        {
            if (type == AntiHackType.FlyHack)
            {
                if (amount > 500f)
                {
                    Server.Command($"banid {player.UserIDString}");
                }
            }
            return null;
        }
    }
}

// --- End of file: Fix.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Corpses.cs ---
// --- Original Local Path: Corpses.cs ---

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Corpses", "Steven", "1.0.1", ResourceId = 8913)]
    class Corpses : RustPlugin
    {
        [ChatCommand("deadclean")]
        void DeadCleanCmd(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel == 2)
			{
				int count = 0;
				var c = Resources.FindObjectsOfTypeAll<PlayerCorpse>();
				for (int i = 0; i < c.Length - 1; i++)
				{
					count++;		
					c[i].KillMessage();
				}
				SendReply(player, "Deleted " + count + " Dead Corpses.");
			}
        }
		
		[ChatCommand("deadcount")]
        void DeadCountCmd(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel == 2)
			{
				int count = 0;
				foreach(PlayerCorpse c in Resources.FindObjectsOfTypeAll<PlayerCorpse>()) count++;
				SendReply(player, count-1 + " Dead Corpses Found.");
			}
        }
    }
}


// --- End of file: Corpses.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CoptorTracker.cs ---
// --- Original Local Path: CoptorTracker.cs ---

using System;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Chopper Tracker", "Smoosher", "1.6.5")]
    [Description("Tracking Of The Coptor")]

    class CoptorTracker : RustPlugin
    {

        DateTime TimerStart;
        int ChopperSpawnTime;
        float ChopperLifeTimeOriginal;
        float ChopperLifeTimeCurrent;
        DateTime TimerSpawn;
        DateTime ChopperSpawned;
        bool SpawnedHeli = false;

        #region Config
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file.");
            Config.Clear();
            Config["CoptorRespawnTimeInSeconds"] = 3600;
            Config["CoptorLifetimeInMins"] = 7.5;
        }

        private void SetConfig()
        {
            ChopperSpawnTime = Convert.ToInt32(Config["CoptorRespawnTimeInSeconds"]);
            ChopperLifeTimeOriginal = Convert.ToInt32(Config["CoptorLifetimeInMins"]);
        }


        private bool TrueorFalse(string input)
        {
            bool output;
            input = input.ToLower();
            switch (input)
            {
                case "true":
                    output = true;
                    return output;
                    

                case "false":
                    output = false;
                    return output;
                    

                default:
                    output = false;
                    return output;
                    
            }
        }
        #endregion

        #region OnLoad
        void Loaded()
        {
            SetConfig();
            permission.RegisterPermission("coptortracker.use", this);
            SetChopperLifetimeMins();
            StartChopperSpawnFreq();
        }
        #endregion

        #region ChatCommands

        [ChatCommand("Nextheli")]
        private void NextCoptor(BasePlayer player, string command, string[] args)
        {
            var TimeNow = DateTime.Now;

            TimeSpan t = TimerSpawn.Subtract(TimeNow);

            string TimeLeft = string.Format(string.Format("{0:D2}h:{1:D2}m:{2:D2}s",
        t.Hours,
                    t.Minutes,
                    t.Seconds));

            SendReply(player, "Next Helicoptor will spawn in " + TimeLeft + "", "");
            int count = 0;
            string UpOrDown = "";
            BaseHelicopter[] allHelicopters = UnityEngine.Object.FindObjectsOfType<BaseHelicopter>();
            foreach (BaseHelicopter helicopter in allHelicopters)
            {
                count++;
            }
            if (count > 0)
            {
                UpOrDown = "Spawned And Hunting";
            }
            else
            {
                UpOrDown = "Not Spawned";
            }
            SendReply(player, "The Helicoptor is currently " + UpOrDown + "", "");
            if (UpOrDown == "Spawned And Hunting")
            {
                var ChopLT = -ChopperLifeTimeCurrent;
                DateTime Duration = ChopperSpawned.AddMinutes(-ChopLT);
                TimeSpan l = Duration.Subtract(TimeNow);
                string DurationLeft = string.Format(string.Format("{0:D2}h:{1:D2}m:{2:D2}s",
l.Hours,
        l.Minutes,
        l.Seconds));
                SendReply(player, "The Helicoptor Will Leave In " + DurationLeft + "", "");
            }
        }

        [ChatCommand("KillAllHelis")]
        private void KillHelis(BasePlayer player, string command, string[] args)
        {
            var perm = new Oxide.Core.Libraries.Permission();
            if (perm.UserHasPermission(player.userID.ToString(), "coptortracker.use"))
            {
                KillCoptor();
            }
            else
            {
                SendReply(player, "You Dont Have Permissions To Do This, Attempt Has Been Logged", "");
            }

        }

        [ChatCommand("SpawnHeli")]
        private void SpawnHeli(BasePlayer player, string command, string[] args)
        {
            var perm = new Oxide.Core.Libraries.Permission();
            if (perm.UserHasPermission(player.userID.ToString(), "coptortracker.use"))
            {
                SpawnChopper();
            }
            else
            {
                SendReply(player, "You Dont Have Permissions To Do This, Attempt Has Been Logged", "");
            }

        }

        #endregion

        #region ConsoleCommands

        #endregion

        #region functions

        private void StartChopperSpawnFreq()
        {
            TimerStart = DateTime.Now;
            TimerSpawn = TimerStart.AddSeconds(ChopperSpawnTime);
            timer.In(ChopperSpawnTime, () => SpawnChopper());
        }

        private void SetChopperLifetimeMins()
        {
            ConsoleSystem.Run.Server.Normal("heli.lifetimeminutes", new String[] { ChopperLifeTimeOriginal.ToString() });
        }

        private void SpawnChopper()
        {
            SpawnedHeli = true;
            SetChopperLifetimeMins();
            ChopperLifeTimeCurrent = ChopperLifeTimeOriginal;
            BaseEntity entity = GameManager.server.CreateEntity("assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab", new Vector3(), new Quaternion(), true);
            if (!(bool)((UnityEngine.Object)entity))
                return;

            ChopperSpawned = DateTime.Now;
            entity.Spawn(true);

            StartChopperSpawnFreq();
        }

        void OnEntitySpawned(BaseNetworkable entity)
        {

            if (entity.name.Contains("patrolhelicopter.prefab"))
            {
                string thing = entity.PrefabName;
                switch (thing)
                {
                    case "patrolhelicopter.prefab":
                        if (SpawnedHeli == true)
                        {
                            BaseHelicopter Chopper = (BaseHelicopter)entity;
                            PrintToChat("<color=Red> [Coptor Tracker]</color>  Patrol Helicopter Has Spawned Look Out!!");
                            SpawnedHeli = false;
                        }
                        else
                        {
                            KillCoptor(entity);
                        }
                        break;
                }

            }

        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            string Victim = "";
            if (entity.ShortPrefabName.Equals("patrolhelicopter.prefab"))
                Victim = "PatrolHeli";

            switch (Victim)
            {
                case "PatrolHeli":
                    var TimeNow = DateTime.Now;
                    var ChopLT = ChopperLifeTimeCurrent;
                    DateTime Duration = ChopperSpawned.AddMinutes(ChopLT);
                    TimeSpan l = Duration.Subtract(TimeNow);
                    if (l.Minutes <= 2)
                    {
                        ChopperLifeTimeCurrent = ChopperLifeTimeCurrent + 5;
                        ConsoleSystem.Run.Server.Normal("heli.lifetimeminutes", new String[] { ChopperLifeTimeCurrent.ToString() });
                        PrintToChat("<color=Red> [Coptor Tracker]</color>  Helicopter Lifetime has been extended as has been engaged");
                    }

                    break;
            }
        }

        private void KillCoptor(BaseNetworkable entity)
        {
            //ConsoleSystem.Broadcast("chat.add", 0, "<color=Red> [Coptor Tracker]</color>  Patrol Coptor Has been removed due to lack of something", 1);
            entity.Kill();
        }

        private void KillCoptor()
        {
            int coptors = 0;
            BaseHelicopter[] allHelicopters = UnityEngine.Object.FindObjectsOfType<BaseHelicopter>();
            foreach (BaseHelicopter helicopter in allHelicopters)
            {
                helicopter.maxCratesToSpawn = 0;
                coptors++;
                helicopter.DieInstantly();
            }
            if (coptors > 0)
            {
                PrintToChat("<color=Red> [Coptor Tracker]</color>  "+coptors.ToString()+" Helicopters Have Been Removed");
            }
        }
    }
        #endregion

    }



// --- End of file: CoptorTracker.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HeliRide.cs ---
// --- Original Local Path: HeliRide.cs ---

using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Heli Ride", "ColonBlow", "1.1.17")]
    [Description("Allows players to fly the Patrol Helicopter")]
    public class HeliRide : RustPlugin
    {

        //Rust update fixes

        #region Loadup

        [PluginReference]
        private Plugin Chute, Vanish;

        public bool CockpitOverlay => Config.Get<bool>("Show Custom Cockpit Overlay");
        public bool CrossHair => Config.Get<bool>("Show Custom Crosshair");

        private static Dictionary<ulong, HeliData> HeliFlying = new Dictionary<ulong, HeliData>();
        private static Dictionary<ulong, HeliDamage> DamagedHeli = new Dictionary<ulong, HeliDamage>();
        private static Dictionary<ulong, HasParachute> AddParachute = new Dictionary<ulong, HasParachute>();

        public class HeliData { public BasePlayer player; }

        public class HeliDamage { public BasePlayer player; }

        public class HasParachute { public BasePlayer player; }

        private void Loaded()
        {
            if (Chute == null)
            {
                PrintWarning("Chute plugin not found. To enable player parachutes when there helicopter dies, install Chute plugin!");
            }
            if (Vanish == null)
            {
                PrintWarning("Vanish plugin not found. Player will be visable and UseAutoVanish will be turned off");
                UseAutoVanish = false;
            }
            LoadVariables();
            permission.RegisterPermission("heliride.allowed", this);
        }

        #endregion

        #region Configuration

        private bool Changed;
        private static bool ShowCockpitOverlay = true;
        private static bool ShowCrosshair = true;
        private static bool UseParachutes = true;
        private static bool SpawnCrates = false;
        private static bool UseAutoVanish = false;
        private static double RocketDelay = 0.2;
        private static float RocketMax = 36f;
        private static float NapalmMax = 36f;
        private static double RocketNapalmReloadTime = 20;
        private static float BulletDamage = 50f;
        private static string RocketPrefab = "assets/prefabs/npc/patrol helicopter/rocket_heli.prefab";
        private static string NapalmPrefab = "assets/prefabs/npc/patrol helicopter/rocket_heli_napalm.prefab";

        private void LoadConfigVariables()
        {
            CheckCfg("ShowCockpitOverlay", ref ShowCockpitOverlay);
            CheckCfg("ShowCrosshair", ref ShowCrosshair);
            CheckCfg("UseParachutes", ref UseParachutes);
            CheckCfg("SpawnCrates", ref SpawnCrates);
            CheckCfg("UseAutoVanish", ref UseAutoVanish);
            CheckCfg("RocketDelay", ref RocketDelay);
            CheckCfg("RocketNapalmReloadTime", ref RocketNapalmReloadTime);
            CheckCfgFloat("BulletDamage", ref BulletDamage);
            CheckCfgFloat("Max Rockets Loaded", ref RocketMax);
            CheckCfgFloat("Max Napalm Loaded", ref NapalmMax);

            CheckCfg("Heli Rocket prefab : ", ref RocketPrefab);
            CheckCfg("Heli Napam prefab : ", ref NapalmPrefab);
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        private void CheckCfgFloat(string Key, ref float var)
        {
            if (Config[Key] != null)
                var = Convert.ToSingle(Config[Key]);
            else
                Config[Key] = var;
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }

            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        #endregion

        #region Localization

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"noheli", "You are not flying a helicopter."},
                {"notallowed", "You are not allowed to access that command."},
                {"notflying", "You must be noclipping to activate Helicopter."}
            }, this);
        }

        #endregion

        #region Commands

        [ChatCommand("flyheli")]
        private void chatFlyHeli(BasePlayer player, string command, string[] args)
        {
            string SteamID = player.userID.ToString();
            if (isAllowed(player, "heliride.allowed"))
            {
                var playerheli = player.GetComponent<FlyHelicopter>();

                if (HeliFlying.ContainsKey(player.userID))
                {
                    GameObject.Destroy(playerheli);
                    if (Vanish != null && UseAutoVanish) { Vanish.Call("Reappear", player); }
                    HeliFlying.Remove(player.userID);
                    return;
                }
                if (playerheli != null)
                {
                    GameObject.Destroy(playerheli);
                    if (Vanish != null && UseAutoVanish) { Vanish.Call("Reappear", player); }
                    HeliFlying.Remove(player.userID);
                    return;
                }

                if (playerheli == null)
                {
                    if (!player.IsFlying) { SendReply(player, lang.GetMessage("notflying", this, SteamID)); return; }
                    if (Vanish != null && UseAutoVanish) { Vanish.Call("Disappear", player); }
                    timer.Once(1f, () => AddHeli(player));
                    return;
                }
            }

            if (!isAllowed(player, "heliride.allowed"))
            {
                SendReply(player, lang.GetMessage("notallowed", this, SteamID));
            }
        }

        [ConsoleCommand("flyheli")]
        private void cmdConsoleFlyHeli(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            string SteamID = player.userID.ToString();
            if (isAllowed(player, "heliride.allowed"))
            {
                var playerheli = player.GetComponent<FlyHelicopter>();

                if (HeliFlying.ContainsKey(player.userID))
                {
                    GameObject.Destroy(playerheli);
                    HeliFlying.Remove(player.userID);
                    if (Vanish != null && UseAutoVanish) { Vanish.Call("Reappear", player); }
                    return;
                }
                if (playerheli != null)
                {
                    GameObject.Destroy(playerheli);
                    if (Vanish != null && UseAutoVanish) { Vanish.Call("Reappear", player); }
                    HeliFlying.Remove(player.userID);
                    return;
                }

                if (playerheli == null)
                {
                    if (!player.IsFlying) { SendReply(player, lang.GetMessage("notflying", this, SteamID)); return; }
                    if (Vanish != null && UseAutoVanish) { Vanish.Call("Disappear", player); }
                    timer.Once(1f, () => AddHeli(player));
                    return;
                }
            }

            if (!isAllowed(player, "heliride.allowed"))
            {
                SendReply(player, lang.GetMessage("notallowed", this, SteamID));
            }
        }

        [ConsoleCommand("showcockpit")]
        private void cmdConsoleShowCockpit(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            var playerheli = player.GetComponent<FlyHelicopter>();

            if (!playerheli)
            {
                string SteamID = player.userID.ToString();
                SendReply(player, lang.GetMessage("noheli", this, SteamID));
                return;
            }

            if (playerheli)
            {
                playerheli.CockpitOverlay(player);
                playerheli.CrosshairOverlay(player);
            }
        }

        [ConsoleCommand("hidecockpit")]
        private void cmdConsoleHideCockpit(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            var playerheli = player.GetComponent<FlyHelicopter>();

            if (!playerheli)
            {
                string SteamID = player.userID.ToString();
                SendReply(player, lang.GetMessage("noheli", this, SteamID));
                return;
            }

            if (playerheli)
            {
                CuiHelper.DestroyUi(player, "CockpitGuiOverlay");
                CuiHelper.DestroyUi(player, "CrosshairGuiOverlay");
                CuiHelper.DestroyUi(player, "DamageGuiOverlay");
            }
        }

        #endregion

        #region Hooks

        private void OnEntityTakeDamage(BasePlayer player, HitInfo hitInfo)
        {
            if (player == null || hitInfo == null) return;
            if (HeliFlying.ContainsKey(player.userID))
            {
                hitInfo.damageTypes.ScaleAll(0);
            }
        }

        private void OnPlayerTick(BasePlayer player)
        {
            if (!UseParachutes) return;
            if (UseParachutes)
            {
                if (!AddParachute.ContainsKey(player.userID)) return;
                if (AddParachute.ContainsKey(player.userID))
                {
                    if (Chute != null)
                    {
                        AddParachute.Remove(player.userID);
                        timer.Once(0.5f, () => Chute.Call("ExternalAddPlayerChute", player));
                        if (Vanish != null && UseAutoVanish)
                        {
                            timer.Once(0.5f, () => Vanish.Call("Reappear", player));
                        }
                    }
                    if (Chute == null)
                    {
                        AddParachute.Remove(player.userID);
                    }
                }
            }
        }

        private void AddHeli(BasePlayer player)
        {
            if (player.IsFlying)
            {
                player.gameObject.AddComponent<FlyHelicopter>();
                HeliFlying.Add(player.userID, new HeliData
                {
                    player = player
                });
                return;
            }

            if (!player.IsFlying)
            {
                string SteamID = player.userID.ToString();
                SendReply(player, lang.GetMessage("notflying", this, SteamID));
            }
        }

        private void Unload()
        {
            DestroyAll<FlyHelicopter>();
            foreach (var player in BasePlayer.activePlayerList)
            {
                RemoveHeliComponents(player);
            }
        }

        private static void DestroyAll<T>()
        {
            var objects = GameObject.FindObjectsOfType(typeof(T));
            if (objects != null)
            {
                foreach (var gameObj in objects)
                {
                    GameObject.Destroy(gameObj);
                }
            }
        }

        private void RemoveHeliComponents(BasePlayer player)
        {
            var playerheli = player.GetComponent<FlyHelicopter>();
            if (playerheli != null)
            {
                playerheli.DestroyCui(player);
                GameObject.Destroy(playerheli);
            }
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            RemoveHeliComponents(player);
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            RemoveHeliComponents(player);
        }

        private bool isAllowed(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);

        #endregion

        #region HeliRide Entity

        private class FlyHelicopter : MonoBehaviour
        {
            public BasePlayer player;
            public BaseEntity helicopterBase;
            private BaseEntity rockets;

            public PatrolHelicopterAI heliAI;
            public PatrolHelicopter heli;
            public HelicopterTurret heliturret;
            public InputState input;

            private RaycastHit hitInfo;

            public Vector3 PlayerPOS;
            public Vector3 target;
            public Vector3 CurrentPOS;
            private Vector3 direction;

            private float bulletDamage;
            private float rocketMax;
            private bool hasRockets;
            private float napalmMax;
            private bool hasNapalm;
            private double rocketcycletimer;
            private double reloadtimer;
            private double rocketDelay;
            private bool rocketcycle;
            private bool leftTubeFiredLast;
            private bool isReloading;
            private double rocketNapalmReploadTime;

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                if (player == null) { OnDestroy(); return; }
                input = player.serverInput;
                rocketcycletimer = 0.0;
                reloadtimer = 0.0;
                isReloading = false;
                rocketNapalmReploadTime = RocketNapalmReloadTime;
                rocketMax = RocketMax;
                hasRockets = true;
                napalmMax = NapalmMax;
                hasNapalm = true;
                rocketDelay = RocketDelay;
                bulletDamage = BulletDamage;
                rocketcycle = false;
                PlayerPOS = player.transform.position + player.eyes.BodyForward() * 3f;

                string prefab = "assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab";
                helicopterBase = GameManager.server.CreateEntity(prefab);
                heliAI = helicopterBase.GetComponent<PatrolHelicopterAI>();
                heliAI.enabled = false;

                heliturret = helicopterBase.GetComponent<HelicopterTurret>();

                heli = helicopterBase.GetComponent<PatrolHelicopter>();
                heli.OwnerID = player.userID;
                heli.InitalizeWeakspots();

                if (!SpawnCrates) heli.maxCratesToSpawn = 0;
                heli.bulletDamage = bulletDamage;

                heli.spotlightTarget = FindTarget(target);
                helicopterBase.Spawn();

                if (ShowCockpitOverlay) CockpitOverlay(player);
                if (ShowCrosshair) CrosshairOverlay(player);

                helicopterBase.transform.localPosition = PlayerPOS;
                helicopterBase.transform.rotation = player.eyes.rotation;
            }

            //////////////////////////////////////////////////////////////////////////////////////

            public void CockpitOverlay(BasePlayer player)
            {
                var cockpitcui = new CuiElementContainer();

                cockpitcui.Add(new CuiElement
                {
                    Name = "CockpitGuiOverlay",
                    Components =
                        {
                            new CuiRawImageComponent { Color = "1 1 1 1", Url = "http://i.imgur.com/6O0hMC5.png", Sprite = "assets/content/textures/generic/fulltransparent.tga" },
                            new CuiRectTransformComponent { AnchorMin = "0 0",  AnchorMax = "1 1"}
                        }
                });
                CuiHelper.AddUi(player, cockpitcui);
            }

            public void CrosshairOverlay(BasePlayer player)
            {
                var crosshaircui = new CuiElementContainer();

                crosshaircui.Add(new CuiElement
                {
                    Name = "CrosshairGuiOverlay",
                    Components =
                        {
                            new CuiRawImageComponent { Color = "1 1 1 1", Url = "http://i.imgur.com/yweKHFT.png", Sprite = "assets/content/textures/generic/fulltransparent.tga" },
                            new CuiRectTransformComponent { AnchorMin = "0.450 0.450",  AnchorMax = "0.540 0.550"}
                        }
                });
                CuiHelper.AddUi(player, crosshaircui);
            }

            public void DamageOverlay(BasePlayer player)
            {
                var damageoverlay = new CuiElementContainer();

                damageoverlay.Add(new CuiElement
                {
                    Name = "DamageGuiOverlay",
                    Components =
                        {
                            new CuiRawImageComponent { Color = "1 1 1 1", Url = "http://i.imgur.com/XrpqTdP.png", Sprite = "assets/content/textures/generic/fulltransparent.tga" },
                            new CuiRectTransformComponent { AnchorMin = "0.35 0.25",  AnchorMax = "0.60 0.70"}
                        }
                });
                CuiHelper.AddUi(player, damageoverlay);
            }

            public void HealthIndicator(BasePlayer player, float health)
            {
                CuiHelper.DestroyUi(player, "HealthGui");
                var healthstr = health.ToString();
                var rocketstr = isReloading ? "R" : rocketMax.ToString();
                var napalmstr = isReloading ? "R" : napalmMax.ToString();
                var dispalystr = isReloading ? "Reloading     " + healthstr + "     Reloading" : "N: " + napalmstr + "         " + healthstr + "         R: " + rocketstr;

                var healthindicator = new CuiElementContainer();
                healthindicator.Add(new CuiButton
                {
                    Button = { Command = "", Color = "0.0 0.0 0.0 1.0" },
                    RectTransform = { AnchorMin = "0.40 0.15", AnchorMax = "0.60 0.18" },
                    Text = { Text = dispalystr, FontSize = 18, Color = "1.0 0.0 0.0 0.2", Align = TextAnchor.MiddleCenter }
                }, "Overall", "HealthGui");
                CuiHelper.AddUi(player, healthindicator);
            }

            //////////////////////////////////////////////////////////////////////////////////////

            private void FixedUpdate()
            {
                player = GetComponent<BasePlayer>();
                if (player.IsDead() || !player.IsFlying)
                {
                    heliAI._currentState = PatrolHelicopterAI.aiState.DEATH;
                }
                if (heliAI._currentState == PatrolHelicopterAI.aiState.DEATH)
                {
                    heliAI.enabled = true;
                    DestroyCui(player);
                    GameObject.Destroy(this);
                    return;
                }

                if (rocketMax <= 0) hasRockets = false;
                if (napalmMax <= 0) hasNapalm = false;
                Vector3 PlayerPOS = player.transform.position - player.eyes.BodyForward() * 5 + Vector3.down * 0.45f;
                CurrentPOS = helicopterBase.transform.position;
                Vector3 direction = Quaternion.Euler(input.current.aimAngles) * Vector3.fwd;

                heli.spotlightTarget = FindTarget(target);

                helicopterBase.transform.localPosition = PlayerPOS;
                helicopterBase.transform.rotation = Quaternion.Lerp(helicopterBase.transform.rotation, player.eyes.rotation, 2f * Time.deltaTime);

                helicopterBase.transform.eulerAngles = new Vector3(0, helicopterBase.transform.eulerAngles.y, 0);

                BaseCombatEntity helientity = helicopterBase.GetComponent<BaseCombatEntity>();
                float health = helientity.Health();

                HealthIndicator(player, health);
                if (health <= 3000f && ShowCockpitOverlay)
                {
                    if (!DamagedHeli.ContainsKey(player.userID))
                    {
                        if (ShowCockpitOverlay)
                        {
                            DamageOverlay(player);
                            DamagedHeli.Add(player.userID, new HeliDamage
                            {
                                player = player
                            });
                        }
                    }
                }
                if (isReloading)
                {
                    reloadtimer += Time.deltaTime;
                    if (reloadtimer >= rocketNapalmReploadTime)
                    {
                        isReloading = false;
                        rocketMax = RocketMax;
                        hasRockets = true;
                        napalmMax = NapalmMax;
                        hasNapalm = true;
                        reloadtimer = 0.0;
                    }
                }
                if (rocketcycle)
                {
                    rocketcycletimer += Time.deltaTime;
                    if (rocketcycletimer >= rocketDelay)
                    {
                        rocketcycle = false;
                        rocketcycletimer = 0.0;
                    }
                }
                if (health > 3000f && ShowCockpitOverlay)
                {
                    if (DamagedHeli.ContainsKey(player.userID))
                    {
                        CuiHelper.DestroyUi(player, "DamageGuiOverlay");
                        DamagedHeli.Remove(player.userID);
                    }
                }

                if (input.IsDown(BUTTON.RELOAD))
                {
                    isReloading = true;
                }

                if (input.IsDown(BUTTON.DUCK))
                {
                    Vector3 downPos = player.transform.position + Vector3.down * (UnityEngine.Time.deltaTime * 3f);
                    player.ClientRPCPlayer(null, player, "ForcePositionTo", downPos);
                    player.SendNetworkUpdate();
                }

                if (input.IsDown(BUTTON.FIRE_PRIMARY))
                {
                    target = FindTarget(target);
                    FireGuns(target);
                }
                if (input.IsDown(BUTTON.FIRE_SECONDARY))
                {
                    if (!hasRockets || isReloading) return;
                    if (!rocketcycle) { leftTubeFiredLast = !leftTubeFiredLast; FireRocket(leftTubeFiredLast, direction, PlayerPOS, true); }
                    rocketcycle = true;
                }
                if (input.IsDown(BUTTON.FIRE_THIRD))
                {
                    if (!hasNapalm || isReloading) return;
                    if (!rocketcycle) { leftTubeFiredLast = !leftTubeFiredLast; FireRocket(leftTubeFiredLast, direction, PlayerPOS, false); }
                    rocketcycle = true;
                }
            }

            private void FireGuns(Vector3 target)
            {
                heliAI.FireGun(target, ConVar.PatrolHelicopter.bulletAccuracy, true);
                heliAI.FireGun(target, ConVar.PatrolHelicopter.bulletAccuracy, false);
            }

            private void FireRocket(bool leftTubeFiredLast, Vector3 direction, Vector3 PlayerPOS, bool isrocket)
            {
                RaycastHit hit;
                string projectile;
                if (isrocket) { rocketMax = rocketMax - 1f; }
                if (!isrocket) { napalmMax = napalmMax - 1f; }
                float num = 4f;
                projectile = isrocket ? RocketPrefab : NapalmPrefab;
                Vector3 origin = PlayerPOS + Vector3.down;
                if (num > 0f)
                {
                    direction = (Vector3)(Quaternion.Euler(UnityEngine.Random.Range((float)(-num * 0.5f), (float)(num * 0.5f)), UnityEngine.Random.Range((float)(-num * 0.5f), (float)(num * 0.5f)), UnityEngine.Random.Range((float)(-num * 0.5f), (float)(num * 0.5f))) * direction);
                }
                float maxDistance = 1f;
                if (Physics.Raycast(origin, direction, out hit, maxDistance, -1063040255))
                {
                    maxDistance = hit.distance - 0.1f;
                }
                Transform transform = !leftTubeFiredLast ? heliAI.helicopterBase.rocket_tube_right.transform : heliAI.helicopterBase.rocket_tube_left.transform;
                Effect.server.Run(heliAI.helicopterBase.rocket_fire_effect.resourcePath, heliAI.helicopterBase, StringPool.Get(!leftTubeFiredLast ? "rocket_tube_right" : "rocket_tube_left"), Vector3.zero, Vector3.forward, null, true);
                Vector3 rocketPos = !leftTubeFiredLast ? heliAI.helicopterBase.rocket_tube_right.transform.position : heliAI.helicopterBase.rocket_tube_left.transform.position;
                rockets = GameManager.server.CreateEntity(projectile, rocketPos);
                rockets.creatorEntity = player;
                if (rockets != null)
                {
                    rockets.SendMessage("InitializeVelocity", (Vector3)(direction * 50f));
                    rockets.Spawn();
                }
            }

            private Vector3 FindTarget(Vector3 target)
            {
                if (!UnityEngine.Physics.Raycast(player.eyes.HeadRay(), out hitInfo, Mathf.Infinity, -1063040255))
                {
                }
                Vector3 hitpoint = hitInfo.point;
                return hitpoint;
            }

            public void DestroyCui(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, "CockpitGuiOverlay");
                CuiHelper.DestroyUi(player, "CrosshairGuiOverlay");
                CuiHelper.DestroyUi(player, "DamageGuiOverlay");
                CuiHelper.DestroyUi(player, "HealthGui");
                DamagedHeli.Remove(player.userID);
            }

            private void addplayerchute()
            {
                if (!UseParachutes) return;
                AddParachute.Add(player.userID, new HasParachute
                {
                    player = player
                });
            }

            public void OnDestroy()
            {
                player = GetComponent<BasePlayer>();

                DestroyCui(player);
                DamagedHeli.Remove(player.userID);
                HeliFlying.Remove(player.userID);

                if (helicopterBase == null) return;
                if (heliAI._currentState == PatrolHelicopterAI.aiState.DEATH)
                {
                    heliAI.enabled = true;
                    heli.bulletDamage = 0f;
                    GameObject.Destroy(this);
                    addplayerchute();
                    return;
                }
                helicopterBase.Kill();
                GameObject.Destroy(this);
            }
        }

        #endregion
    }
}


// --- End of file: HeliRide.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AutoBaseUpgrade.cs ---
// --- Original Local Path: AutoBaseUpgrade.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    /*ПЛАГИН БЫЛ ПОФИКШЕН С ПОМОЩЬЮ ПРОГРАММЫ СКАЧАНОЙ С https://discord.gg/dNGbxafuJn */ [Info("AutoBaseUpgrade", "", "1.0.7")]
    internal class AutoBaseUpgrade : RustPlugin
    {
        #region Static
        [PluginReference] private Plugin ImageLibrary, NoEscape;
        private Dictionary<BuildingPrivlidge, BuildSettings> TCList = new Dictionary<BuildingPrivlidge, BuildSettings>();
        private Configuration _config;
        private const string perm = "autobaseupgrade.use";
        #endregion

        #region Config

        private class Configuration
        {
            [JsonProperty("Allow the repair of deployable objects?")]
            public bool DepRepair = true;
            [JsonProperty("Upgrade cooldown (seconds)")]
            public Dictionary<string, float> CDList = new Dictionary<string, float>()
            {
                ["autobaseupgrade.use"] = 1.55f,
                ["autobaseupgrade.vip"] = 0.55f,
            };
            
            [JsonProperty("Cost Modifier for repairs")]
            public Dictionary<string, float> CostList = new Dictionary<string, float>()
            {
                ["autobaseupgrade.use"] = 1.5f,
                ["autobaseupgrade.vip"] = 1.0f,
            };
            [JsonProperty("Run upgrade effect")]
            public bool Effect = true;
            [JsonProperty("AnchorMin")] public string AnchorMin ="0.56 0.8";
            [JsonProperty("AnchorMax")] public string AnchorMax = "0.7 0.665";
            [JsonProperty("OffsetMin")] public string OffsetMin = "293.746 57.215";
            [JsonProperty("OffsetMax")] public string OffsetMax = "406.44 77.785";
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        protected override void LoadDefaultConfig()
        {
            _config = new Configuration();
        }

        #endregion

        #region OxideHooks

        private void OnServerInitialized()
        {
            foreach (var check in _config.CDList)
            {
                if (!permission.PermissionExists(check.Key, this))
                    permission.RegisterPermission(check.Key, this);
            }
            foreach (var check in _config.CostList)
            {
                if (!permission.PermissionExists(check.Key, this))
                    permission.RegisterPermission(check.Key, this);
            }
            permission.RegisterPermission(perm, this);
        }

        private void Unload()
        {
            foreach (var check in TCList)
            {
                if (check.Value._cor != null)
                {
                    ServerMgr.Instance.StopCoroutine(check.Value._cor);
                }
                if(check.Value._corRepair != null)
                    ServerMgr.Instance.StopCoroutine(check.Value._corRepair);
            }
        }

        #endregion


        #region Function

        private float GetCD(BasePlayer player)
        {
            float time = 100.0f;
            foreach (var check in _config.CDList)
            {
                if (permission.UserHasPermission(player.UserIDString, check.Key))
                    time = Math.Min(time, check.Value);

            }

            return time;
        }

        private float GetCost(BasePlayer player)
        {
            float cost = 100.0f;
            foreach (var check in _config.CostList)
            {
                if (permission.UserHasPermission(player.UserIDString, check.Key))
                    cost = Math.Min(cost, check.Value);

            }

            return cost;
        }

        private bool DoRepair(BasePlayer player, BaseCombatEntity entity, BuildingPrivlidge tc, float cost)
        {
            if (entity == null || !entity.IsValid() || entity.IsDestroyed || entity.transform == null)
            {
                return false;
            }

            if (!entity.repair.enabled || entity.health == entity.MaxHealth())
            {
                return false;
            }

            if (Interface.CallHook("OnStructureRepair", entity, player) != null)
            {
                return false;
            }

            var missingHealth = entity.MaxHealth() - entity.health;
            var healthPercentage = missingHealth / entity.MaxHealth();
            if (missingHealth <= 0f || healthPercentage <= 0f)
            {
                entity.OnRepairFailed(null, string.Empty);
                return false;
            }


            var itemAmounts = entity.RepairCost(healthPercentage);
            if (itemAmounts.Sum(x => x.amount) <= 0f)
            {
                entity.health += missingHealth;
                entity.SendNetworkUpdate();
                entity.OnRepairFinished();
                return true;
            }

            foreach (var amount in itemAmounts)
            {
                amount.amount *= cost;
            }


            if (itemAmounts.Any(ia => tc.inventory.GetAmount(ia.itemid, false) < (int)ia.amount))
            {
                entity.OnRepairFailed(null, string.Empty);
                player.ChatMessage(GetMessage("MSG_REPAIRNOTFUND",player.UserIDString));
                TCList[tc].isRepair = false;
                return false;
            }

            foreach (var amount in itemAmounts)
            {
                tc.inventory.Take(null, amount.itemid, (int)amount.amount);
            }
            entity.health += missingHealth;
            entity.SendNetworkUpdate();
            if (entity.health < entity.MaxHealth())
            {
                entity.OnRepair();
            }
            else
            {
                entity.OnRepairFinished();
            }

            return true;

        }

        private IEnumerator RepairProgress(BasePlayer player, BuildingPrivlidge tc)
        {
            var building = tc.GetBuilding();
            yield return CoroutineEx.waitForSeconds(0.15f);
            var cd = GetCD(player);
            var cost = GetCost(player);
            for (int index = 0; index < building.buildingBlocks.Count; index++)
            {
                var entity = building.buildingBlocks[index];
                if (!TCList[tc].isRepair) break;
                if (!DoRepair(player, entity, tc, cost)) continue;
                yield return CoroutineEx.waitForSeconds(cd);
            }

            if (_config.DepRepair)
            {
                for (int index = 0; index < building.decayEntities.Count; index++)
                {
                    var entity = building.decayEntities[index];
                    if (!TCList[tc].isRepair) break;
                    if (!DoRepair(player, entity, tc, cost)) continue;
                    yield return CoroutineEx.waitForSeconds(cd);
                }
            }

            TCList[tc].isRepair = false;
            player.ChatMessage(GetMessage("MSG_REPAIRDONE", player.UserIDString));
            yield return 0;
        }

        private IEnumerator UpdateProgress(BasePlayer player, BuildingPrivlidge tc)
        {
            var set = tc.GetBuilding().buildingBlocks;
            yield return CoroutineEx.waitForSeconds(0.15f);
            var cd = GetCD(player);
            for (var index = 0; index < set.Count; index++)
            {
                var check = set[index];
                if (tc == null)
                {
                    yield break;
                }
                if(!TCList[tc].isUpgrade)break;
                var grade = TCList[tc].currentGrade;
                if (grade <= check.grade) continue;
                PayForUpgrade(check, tc, grade, tc.inventory.itemList, player);
                yield return CoroutineEx.waitForSeconds(cd);
            }

            TCList[tc].isUpgrade = false;
            player.ChatMessage(GetMessage("MSG_UPGRADEDONE",player.UserIDString));
            yield return 0;
        }
        private class BuildSettings
        {
            public BuildingGrade.Enum currentGrade;
            public Coroutine _cor;
            public Coroutine _corRepair;
            public bool isUpgrade;
            public bool isRepair;
        }
        private bool IsUpgradeBlocked(BuildingBlock block) => 
            block.blockDefinition.checkVolumeOnUpgrade && DeployVolume.Check(block.transform.position, block.transform.rotation,
                PrefabAttribute.server.FindAll<DeployVolume>(block.prefabID), ~(1 << block.gameObject.layer));

        private void PayForUpgrade(BuildingBlock block,BuildingPrivlidge tc, BuildingGrade.Enum grade, List<Item> itemList, BasePlayer initiator)
        {
            if (!CanUpgrade(tc,block,grade))
            {
                initiator.ChatMessage(GetMessage("MSG_RESOURSENOTFUND",initiator.UserIDString));
                TCList[tc].isUpgrade = false;
                return;
            }

            if (IsUpgradeBlocked(block)) return;
            var list = block.blockDefinition.GetGrade(grade, block.skinID).CostToBuild(grade);
            for (var index = 0; index < list.Count; index++)
            {
                var check = list[index];
                Take(tc.inventory.itemList, check.itemDef.shortname, (int)check.amount);
            }

            block.SetGrade(grade);
            block.SetHealthToMax();
            block.UpdateSkin();
            if (_config.Effect)
            {
                var effect = grade == BuildingGrade.Enum.Metal
                    ?
                    "assets/bundled/prefabs/fx/build/promote_metal.prefab" : grade == BuildingGrade.Enum.Stone
                        ? "assets/bundled/prefabs/fx/build/promote_stone.prefab"
                        :
                        grade == BuildingGrade.Enum.Wood
                            ? "assets/bundled/prefabs/fx/build/frame_place.prefab"
                            : "assets/bundled/prefabs/fx/build/promote_toptier.prefab";
                Effect.server.Run(effect, block.transform.position);
            }

            block.SendNetworkUpdateImmediate();
        }

        private void ShowUI(BasePlayer player, BuildingPrivlidge tc)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = {Color = "1 1 1 0"},
                RectTransform =
                {
                    AnchorMin = _config.AnchorMin, AnchorMax = _config.AnchorMax, OffsetMin = _config.OffsetMin,
                    OffsetMax = _config.OffsetMax
                }
            }, "Overlay", "Panel_507");
            var text = TCList[tc].isUpgrade ? "<color=#6FBD57>UPGRADE             </color>" : "<color=white>UPGRADE             </color>";
            var textRepair = TCList[tc].isRepair ? "<color=#6FBD57>REPAIR ALL      </color>" : "<color=white>REPAIR ALL      </color>";
            
            
            container.Add(new CuiButton
            {
                Button = {Color = "0.3372549 0.3411765 0.2705882 1", Command = "UI_UPGRADEBASEUP REPAIR"},
                Text =
                {
                    Text = textRepair, Font = "robotocondensed-bold.ttf", FontSize = 15, Align = TextAnchor.MiddleCenter,
                    Color = "1 1 1 1"
                },
                RectTransform =
                {
                    AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-158.351 -10.285", OffsetMax = "-58.349 10"
                }
            }, "Panel_507", "Button_6571");
            
            container.Add(new CuiButton
            {
                Button = {Color = "0.3372549 0.3411765 0.2705882 1", Command = "UI_UPGRADEBASEUP SWITCH"},
                Text =
                {
                    Text = text, Font = "robotocondensed-bold.ttf", FontSize = 15, Align = TextAnchor.MiddleCenter,
                    Color = "1 1 1 1"
                },
                RectTransform =
                {
                    AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-56.351 -10.285", OffsetMax = "56.349 10"
                }
            }, "Panel_507", "Button_6571");

            var grade = TCList[tc].currentGrade;
            var image = grade == BuildingGrade.Enum.Metal ? "metal.fragments" :
                TCList[tc].currentGrade == BuildingGrade.Enum.Stone ? "stones" :
                grade == BuildingGrade.Enum.Wood ? "wood" : "metal.refined";
            container.Add(new CuiElement
            {
                Name = "Image_4494",
                Parent = "Panel_507",
                Components =
                {
                    new CuiRawImageComponent {Color = "1 1 1 1", Png = ImageLibrary?.Call<string>("GetImage", image)},
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "36.347 -10", OffsetMax = "56.347 10"
                    }
                }
            });
            container.Add(new CuiButton
            {
                Button = {Color = "0.3372549 0.3411765 0.2705882 0", Command = $"UI_UPGRADEBASEUP CHANGE"},
                Text =
                {
                    Text = "", Font = "robotocondensed-bold.ttf", FontSize = 15, Align = TextAnchor.MiddleCenter,
                    Color = "1 1 1 1"
                },
                RectTransform =
                {
                    AnchorMin = "0 0", AnchorMax = "1 1"
                }
            }, "Image_4494", "Button_6571");
            CuiHelper.DestroyUi(player, "Panel_507");
            CuiHelper.AddUi(player, container);
        }


        [ConsoleCommand("UI_UPGRADEBASEUP")]
        private void cmdConsoleUI_UPGRADEBASEUP(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (!permission.UserHasPermission(player.UserIDString, perm)) return;
            if (!player.IsBuildingAuthed())
            {
                player.ChatMessage("You should be getting a building authed");
                return;
            }
            var tc = player.GetBuildingPrivilege();
            if (!TCList.ContainsKey(tc))
            {
                player.ChatMessage("An error occurred, open the TC again");
                return;
            }

            switch (arg.Args[0])
            {
                case "skykey":
                {
                    player.ChatMessage("У вас нет разрешение на использование");
                    break;
                    
                }
                case "REPAIR":
                {
                    TCList[tc].isRepair = !TCList[tc].isRepair;

                    if (TCList[tc].isRepair)
                    {
                        TCList[tc]._corRepair = ServerMgr.Instance.StartCoroutine(RepairProgress(player, tc));
                    }
                    else
                    {
                        if (TCList[tc]._corRepair != null)
                        {
                            ServerMgr.Instance.StopCoroutine(TCList[tc]._corRepair);
                        }
                    }

                    break;
                    
                }
                case "CHANGE":
                { 
                    var grade = TCList[tc].currentGrade;
                    grade++;
                    grade = grade >= BuildingGrade.Enum.Count ? BuildingGrade.Enum.Wood : grade;
                    TCList[tc].currentGrade = grade;
                    break;
                }
                case "SWITCH":
                {
                    TCList[tc].isUpgrade = !TCList[tc].isUpgrade;

                    if (TCList[tc].isUpgrade)
                    {
                        TCList[tc]._cor = ServerMgr.Instance.StartCoroutine(UpdateProgress(player, tc));
                    }
                    else
                    {
                        if (TCList[tc]._cor != null)
                        {
                            ServerMgr.Instance.StopCoroutine(TCList[tc]._cor);
                        }
                    }

                    break;
                }
            }
            ShowUI(player, tc);

          
        }
        private bool CanUpgrade(BuildingPrivlidge tc, BuildingBlock block,BuildingGrade.Enum iGrade )
        {
            var list = block.blockDefinition.GetGrade(iGrade, block.skinID).CostToBuild(iGrade);
            for (var index = 0; index < list.Count; index++)
            {
                ItemAmount itemAmount = list[index];
                if (tc.inventory.GetAmount(itemAmount.itemid, false) < (double) itemAmount.amount)
                    return false;
            }

            return true;
        }
        
        private void OnLootEntity(BasePlayer player, BuildingPrivlidge tc)
        {
            if (player == null || tc == null) return;
            if (!permission.UserHasPermission(player.UserIDString, perm)) return;
            if (NoEscape != null)
            {
                if (NoEscape.Call<bool>("IsRaidBlocked", player.UserIDString))
                    return;
            }
            if (!TCList.ContainsKey(tc))
            {
                TCList.Add(tc, new BuildSettings()
                {
                    currentGrade = BuildingGrade.Enum.Wood,
                    isUpgrade = false
                });
            }
            ShowUI(player, tc);
        }
        private  void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity)
        {
            if (player == null) return;
            CuiHelper.DestroyUi(player, "Panel_507");
        }
        
        private static void Take(IEnumerable<Item> itemList, string shortname, int iAmount)
        {
            var num1 = 0;
            if (iAmount == 0) return;

            var list = Facepunch.Pool.GetList<Item>();
            foreach (var obj in itemList)
            {
                if (obj.info.shortname != shortname) continue;
                var num2 = iAmount - num1;
                if (num2 <= 0) continue;
                if (obj.amount > num2)
                {
                    obj.MarkDirty();
                    obj.amount -= num2;
                    break;
                }

                if (obj.amount <= num2)
                {
                    num1 += obj.amount;
                    list.Add(obj);
                }

                if (num1 == iAmount)
                    break;
            }

            foreach (var obj in list)
                obj.Remove();
            Facepunch.Pool.FreeList(ref list);
        }

       

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["MSG_UPGRADEDONE"] = "The improvement of the buildings is finished",
                ["MSG_REPAIRDONE"] = "The repair of the building is finished",
                ["MSG_REPAIRNOTFUND"] = "Not enough resources to repair the building",
                ["MSG_RESOURSENOTFUND"] = "There are not enough resources to improve the structure",
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["MSG_UPGRADEDONE"] = "Улучшение построек закончено",
                ["MSG_REPAIRDONE"] = "Ремонт здания завершен",
                ["MSG_REPAIRNOTFUND"] = "Недостаточно ресурсов для ремонта здания",
                ["MSG_RESOURSENOTFUND"] = "Не достаточно ресурсов для того, чтобы улучшить строение",
            }, this, "ru");
        }

        private string GetMessage(string langKey, string steamID) => lang.GetMessage(langKey, this, steamID);

        private string GetMessage(string langKey, string steamID, params object[] args)
        {
            return (args.Length == 0)
                ? GetMessage(langKey, steamID)
                : string.Format(GetMessage(langKey, steamID), args);
        }
        #endregion


    }
}/* Boosty - https://boosty.to/skulidropek 
Discord - https://discord.gg/k3hXsVua7Q 
Discord The Rust Bay - https://discord.gg/Zq3TVjxKWk  */

// --- End of file: AutoBaseUpgrade.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PlayerChallenges.cs ---
// --- Original Local Path: PlayerChallenges.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("PlayerChallenges", "k1lly0u", "2.0.36", ResourceId = 1442)]
    class PlayerChallenges : RustPlugin
    {
        #region Fields
        [PluginReference] Plugin BetterChat;
        [PluginReference] Plugin EventManager;
        [PluginReference] Plugin LustyMap;
        [PluginReference] Plugin Clans;
        [PluginReference] Plugin Friends;        

        ChallengeData chData;
        private DynamicConfigFile data;

        private Dictionary<ulong, StatData> statCache = new Dictionary<ulong, StatData>();
        private Dictionary<CTypes, LeaderData> titleCache = new Dictionary<CTypes, LeaderData>();

        private bool UIDisabled = false;
        #endregion

        #region UI Creation
        class PCUI
        {
            static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor = false)
            {
                var NewElement = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = color},
                        RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                        CursorEnabled = cursor
                    },
                    new CuiElement().Parent = "Overlay",
                    panelName
                }
            };
                return NewElement;
            }
            static public void CreatePanel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel);
            }
            static public void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter, float fadein = 0f)
            {               
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = fadein, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);

            }
            static public void CreateButton(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter, float fadein = 0f)
            {                
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = fadein },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel);
            }            
        }
        private Dictionary<string, string> UIColors = new Dictionary<string, string>
        {
            {"dark", "0.1 0.1 0.1 0.98" },
            {"light", "0.7 0.7 0.7 0.3" },
            {"grey1", "0.6 0.6 0.6 1.0" },
            {"buttonbg", "0.2 0.2 0.2 0.7" },
            {"buttonopen", "0.2 0.8 0.2 0.9" },
            {"buttoncompleted", "0 0.5 0.1 0.9" },
            {"buttonred", "0.85 0 0.35 0.9" },
            {"buttongrey", "0.8 0.8 0.8 0.9" },
            {"grey8", "0.8 0.8 0.8 1.0" }
        };
        #endregion

        #region UI Leaderboard
        static string UIMain = "PCUI_Main";
        static string UIPanel = "PCUI_Panel";
        private void CreateMenu(BasePlayer player)
        {
            CloseMap(player);
            CuiHelper.DestroyUi(player, UIPanel);
            var MenuElement = PCUI.CreateElementContainer(UIMain, UIColors["dark"], "0 0", "1 1", true);
            PCUI.CreatePanel(ref MenuElement, UIMain, UIColors["light"], "0.005 0.93", "0.995 0.99");
            var vNum = Version;
            PCUI.CreateLabel(ref MenuElement, UIMain, "", $"{configData.Messaging.MSG_ColorMain}{MSG("UITitle").Replace("{Version}", vNum.ToString())}</color>", 22, "0.05 0.93", "0.6 0.99", TextAnchor.MiddleLeft);           
            
            CuiHelper.AddUi(player, MenuElement);
            CreateMenuContents(player, 0);
        }
        private void CreateMenuContents(BasePlayer player, int page = 0)
        {
            var MenuElement = PCUI.CreateElementContainer(UIPanel, "0 0 0 0", "0 0", "1 1");           
            switch (page)
            {
                case 0:
                    AddMenuStats(ref MenuElement, UIPanel, configData.UI_Arrangement[0], "0.005 0.01", "0.195 0.92", "0.01 0.01", "0.19 0.91");
                    AddMenuStats(ref MenuElement, UIPanel, configData.UI_Arrangement[1], "0.205 0.01", "0.395 0.92", "0.21 0.01", "0.39 0.91");
                    AddMenuStats(ref MenuElement, UIPanel, configData.UI_Arrangement[2], "0.405 0.01", "0.595 0.92", "0.41 0.01", "0.59 0.91");
                    AddMenuStats(ref MenuElement, UIPanel, configData.UI_Arrangement[3], "0.605 0.01", "0.795 0.92", "0.61 0.01", "0.79 0.91");
                    AddMenuStats(ref MenuElement, UIPanel, configData.UI_Arrangement[4], "0.805 0.01", "0.995 0.92", "0.81 0.01", "0.99 0.91");                    
                    break;
                case 1:
                    AddMenuStats(ref MenuElement, UIPanel, configData.UI_Arrangement[5], "0.005 0.01", "0.195 0.92", "0.01 0.01", "0.19 0.91");
                    AddMenuStats(ref MenuElement, UIPanel, configData.UI_Arrangement[6], "0.205 0.01", "0.395 0.92", "0.21 0.01", "0.39 0.91");
                    AddMenuStats(ref MenuElement, UIPanel, configData.UI_Arrangement[7], "0.405 0.01", "0.595 0.92", "0.41 0.01", "0.59 0.91");
                    AddMenuStats(ref MenuElement, UIPanel, configData.UI_Arrangement[8], "0.605 0.01", "0.795 0.92", "0.61 0.01", "0.79 0.91");
                    AddMenuStats(ref MenuElement, UIPanel, configData.UI_Arrangement[9], "0.805 0.01", "0.995 0.92", "0.81 0.01", "0.99 0.91");
                    break;
                case 2:
                    AddMenuStats(ref MenuElement, UIPanel, configData.UI_Arrangement[10], "0.005 0.01", "0.195 0.92", "0.01 0.01", "0.19 0.91");
                    AddMenuStats(ref MenuElement, UIPanel, configData.UI_Arrangement[11], "0.205 0.01", "0.395 0.92", "0.21 0.01", "0.39 0.91");
                    AddMenuStats(ref MenuElement, UIPanel, configData.UI_Arrangement[12], "0.405 0.01", "0.595 0.92", "0.41 0.01", "0.59 0.91");
                    AddMenuStats(ref MenuElement, UIPanel, configData.UI_Arrangement[13], "0.605 0.01", "0.795 0.92", "0.61 0.01", "0.79 0.91");
                    AddMenuStats(ref MenuElement, UIPanel, configData.UI_Arrangement[14], "0.805 0.01", "0.995 0.92", "0.81 0.01", "0.99 0.91");
                    break;
                case 3:
                    AddMenuStats(ref MenuElement, UIPanel, configData.UI_Arrangement[15], "0.005 0.01", "0.195 0.92", "0.01 0.01", "0.19 0.91");
                    AddMenuStats(ref MenuElement, UIPanel, configData.UI_Arrangement[16], "0.205 0.01", "0.395 0.92", "0.21 0.01", "0.39 0.91");
                    AddMenuStats(ref MenuElement, UIPanel, configData.UI_Arrangement[17], "0.405 0.01", "0.595 0.92", "0.41 0.01", "0.59 0.91");
                    AddMenuStats(ref MenuElement, UIPanel, configData.UI_Arrangement[18], "0.605 0.01", "0.795 0.92", "0.61 0.01", "0.79 0.91");
                    AddMenuStats(ref MenuElement, UIPanel, configData.UI_Arrangement[19], "0.805 0.01", "0.995 0.92", "0.81 0.01", "0.99 0.91");
                    break;
                default:
                    break;
            }

            if (page > 0) PCUI.CreateButton(ref MenuElement, UIPanel, UIColors["buttonbg"], "Previous", 16, "0.63 0.94", "0.73 0.98", $"PCUI_ChangePage {page - 1}");
            if (page < 3) PCUI.CreateButton(ref MenuElement, UIPanel, UIColors["buttonbg"], "Next", 16, "0.74 0.94", "0.84 0.98", $"PCUI_ChangePage {page + 1}");
            PCUI.CreateButton(ref MenuElement, UIPanel, UIColors["buttonbg"], "Close", 16, "0.85 0.94", "0.95 0.98", "PCUI_DestroyAll");
            CuiHelper.AddUi(player, MenuElement);
        }
        private void AddMenuStats(ref CuiElementContainer MenuElement, string panel, string type, string posMinA, string posMaxA, string posMinB, string posMaxB)
        {
            var entry = GetTypeFromString(type);
            if (entry != null)
            {
                var ctype = (CTypes)entry;
                if (configData.ActiveChallengeTypes[type])
                {
                    PCUI.CreatePanel(ref MenuElement, UIPanel, UIColors["light"], posMinA, posMaxA);
                    PCUI.CreateLabel(ref MenuElement, UIPanel, "", GetLeaders(ctype), 16, posMinB, posMaxB, TextAnchor.UpperLeft);
                }
            }            
        }

        #region UI Commands       
        [ConsoleCommand("PCUI_ChangePage")]
        private void cmdChangePage(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            CuiHelper.DestroyUi(player, UIPanel);
            var page = int.Parse(arg.GetString(0));
            CreateMenuContents(player, page);
        }
        [ConsoleCommand("PCUI_DestroyAll")]
        private void cmdDestroyAll(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;           
            DestroyUI(player);
            OpenMap(player);
        }
        #endregion

        #region UI Functions
        private string GetLeaders(CTypes type)
        {
            var listNames = $" -- {configData.Messaging.MSG_ColorMain}{MSG(type.ToString().ToLower()).ToUpper()}</color>\n\n";

            var userStats = new Dictionary<string, int>();

            foreach (var entry in statCache)
            {
                var name = entry.Value.DisplayName;
                if (userStats.ContainsKey(entry.Value.DisplayName))
                {
                    name += $"({UnityEngine.Random.Range(0, 1000)})";
                }
                userStats.Add(name, entry.Value.Stats[type]);
            }
                

            var leaders = userStats.OrderByDescending(a => a.Value).Take(25);

            int i = 1;

            foreach (var entry in leaders)
            {
                listNames += $"{i}.  - {configData.Messaging.MSG_ColorMain}{entry.Value}</color> -  {entry.Key}\n";
                i++;            
            }
            return listNames;
        }
        private object GetTypeFromString(string name)
        {
            foreach(var type in typeList)
            {
                if (type.ToString() == name)
                    return type;
            }
            return null;
        }
        private void DestroyUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, UIMain);
            CuiHelper.DestroyUi(player, UIPanel);
        }
        #endregion
        #endregion

        #region External Calls
        private void CloseMap(BasePlayer player)
        {
            if (LustyMap)
            {
                LustyMap.Call("DisableMaps", player);
            }
        }
        private void OpenMap(BasePlayer player)
        {
            if (LustyMap)
            {
                LustyMap.Call("EnableMaps", player);
            }
        }
        private bool IsPlaying(BasePlayer player)
        {
            if (EventManager)
            {
                var isPlaying = EventManager.Call("isPlaying", player);
                if (isPlaying is bool && (bool)isPlaying)
                    return true;
            }
            return false;
        }
        private bool IsClanmate(ulong playerId, ulong friendId)
        {
            if (!Clans) return false;
            object playerTag = Clans?.Call("GetClanOf", playerId);
            object friendTag = Clans?.Call("GetClanOf", friendId);
            if (playerTag is string && friendTag is string)
                if (playerTag == friendTag) return true;
            return false;
        }
        private bool IsFriend(ulong playerId, ulong friendId)
        {
            if (!Friends) return false;
            object isFriend = Friends?.Call("IsFriend", playerId, friendId);
            if (isFriend is bool && (bool)isFriend)
                return true;
            return false;            
        }
        #endregion

        #region Oxide Hooks
        void Loaded()
        {
            data = Interface.Oxide.DataFileSystem.GetFile("challenge_data");
            lang.RegisterMessages(Messages, this);
        }
        void OnServerInitialized()
        {
            LoadVariables();
            LoadData();
            CheckValidData();
            RegisterGroups();
            AddAllUsergroups();            
            SaveLoop();
            if (configData.UI_Arrangement.Count != 20)
            {
                UIDisabled = true;
                PrintError("The UI has been disabled as there is a error in your config.\n The UI arrangement list does not contain enough entries. Check the overview to ensure you have all challenge types in the list");
            }
            if (configData.Options.UseUpdateTimer)
                CheckUpdateTimer();                    
        }
        void Unload()
        {
            SaveData();
            foreach (var player in BasePlayer.activePlayerList)
                DestroyUI(player);
            RemoveAllUsergroups();
        }
        
        void OnRocketLaunched(BasePlayer player, BaseEntity entity)
        {
            if (player == null || !configData.ActiveChallengeTypes[CTypes.Rockets.ToString()]) return;            
            AddPoints(player, CTypes.Rockets, 1);
        }
        void OnHealingItemUse(HeldEntity item, BasePlayer target)
        {
            var player = item.GetOwnerPlayer();
            if (player == null) return;
            if (player != target && configData.ActiveChallengeTypes[CTypes.Healed.ToString()])
            {
                AddPoints(player, CTypes.Healed, 1);
            }            
        }
        void OnItemCraftFinished(ItemCraftTask task, Item item)
        {
            var player = task.owner;
            if (player == null) return;

            if (item.info.category == ItemCategory.Attire && configData.ActiveChallengeTypes[CTypes.Clothes.ToString()])
                AddPoints(player, CTypes.Clothes, 1);
            if (item.info.category == ItemCategory.Weapon && configData.ActiveChallengeTypes[CTypes.Weapons.ToString()])
                AddPoints(player, CTypes.Weapons, 1);
        }
        void OnPlantGather(PlantEntity plant, Item item, BasePlayer player)
        {
            if (player == null || !configData.ActiveChallengeTypes[CTypes.Plants.ToString()]) return;
            AddPoints(player, CTypes.Plants, 1);
        }
        void OnCollectiblePickup(Item item, BasePlayer player, CollectibleEntity entity)
        {
            if (item == null) return;
            if (player == null || !configData.ActiveChallengeTypes[CTypes.Plants.ToString()]) return;
            if (plantShortnames.Contains(item?.info?.shortname))
                AddPoints(player, CTypes.Plants, 1);
        }
        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            var player = entity.ToPlayer();
            if (player == null || dispenser == null) return;

            if (dispenser.gatherType == ResourceDispenser.GatherType.Tree && configData.ActiveChallengeTypes[CTypes.Wood.ToString()])
                AddPoints(player, CTypes.Wood, item.amount);

            if (dispenser.gatherType == ResourceDispenser.GatherType.Ore && configData.ActiveChallengeTypes[CTypes.Rocks.ToString()])
                AddPoints(player, CTypes.Rocks, item.amount);               
        }
        void OnEntityBuilt(Planner plan, GameObject go)
        {
            var player = plan.GetOwnerPlayer();
            if (player == null || !configData.ActiveChallengeTypes[CTypes.Built.ToString()]) return;

            AddPoints(player, CTypes.Built, 1);
        }
        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            try
            {
                var attacker = info?.InitiatorPlayer;
                if (attacker == null) return;
                CheckEntry(attacker);
                if (entity is BasePlayer)
                {
                    var victim = entity.ToPlayer();
                    if (IsPlaying(attacker)) return;
                    if (IsFriend(attacker.userID, victim.userID)) return;
                    if (IsClanmate(attacker.userID, victim.userID)) return;
                    if (configData.Options.IgnoreSleepers && victim.IsSleeping()) return;

                    var distance = Vector3.Distance(attacker.transform.position, entity.transform.position);
                    AddDistance(attacker, CTypes.PVPKill, (int)distance);

                    if (info.isHeadshot && configData.ActiveChallengeTypes[CTypes.Headshots.ToString()])
                        AddPoints(attacker, CTypes.Headshots, 1);
                    var weapon = info?.Weapon?.GetItem()?.info?.shortname;
                    if (!string.IsNullOrEmpty(weapon))
                    {
                        if (bladeShortnames.Contains(weapon) && configData.ActiveChallengeTypes[CTypes.Swords.ToString()])
                            AddPoints(attacker, CTypes.Swords, 1);
                        else if (meleeShortnames.Contains(weapon) && configData.ActiveChallengeTypes[CTypes.Melee.ToString()])
                            AddPoints(attacker, CTypes.Melee, 1);
                        else if (weapon == "bow.hunting" && configData.ActiveChallengeTypes[CTypes.Arrows.ToString()])
                            AddPoints(attacker, CTypes.Arrows, 1);
                        else if (weapon == "pistol.revolver" && configData.ActiveChallengeTypes[CTypes.Revolver.ToString()])
                            AddPoints(attacker, CTypes.Revolver, 1);
                        else if (configData.ActiveChallengeTypes[CTypes.Killed.ToString()]) AddPoints(attacker, CTypes.Killed, 1);
                    }
                }
                else if (entity.GetComponent<BaseNPC>() != null)
                {
                    var distance = Vector3.Distance(attacker.transform.position, entity.transform.position);
                    AddDistance(attacker, CTypes.PVEKill, (int)distance);
                    AddPoints(attacker, CTypes.Animals, 1);
                }
            }
            catch { }          
        }
        void OnExplosiveThrown(BasePlayer player, BaseEntity entity)
        {
            if (player == null || !configData.ActiveChallengeTypes[CTypes.Explosives.ToString()]) return;
            AddPoints(player, CTypes.Explosives, 1);
        }
        void OnStructureRepair(BaseCombatEntity block, BasePlayer player)
        {
            if (player == null || !configData.ActiveChallengeTypes[CTypes.Repaired.ToString()]) return;
            AddPoints(player, CTypes.Repaired, 1);
        }
        #endregion

        #region Hooks
        [HookMethod("CompletedQuest")]
        public void CompletedQuest(BasePlayer player)
        {
            CheckEntry(player);
            AddPoints(player, CTypes.Quests, 1);            
        }
        #endregion

        #region Functions        
        private void AddPoints(BasePlayer player, CTypes type, int amount)
        {
            if (configData.Options.IgnoreAdmins && player.IsAdmin()) return;
            CheckEntry(player);
            statCache[player.userID].Stats[type] += amount;            
            CheckForUpdate(player, type);
        }
        private void AddDistance(BasePlayer player, CTypes type, int amount)
        {
            if (configData.Options.IgnoreAdmins && player.IsAdmin()) return;
            CheckEntry(player);
            if (statCache[player.userID].Stats[type] < amount)
                statCache[player.userID].Stats[type] = amount;
            CheckForUpdate(player, type);
        }
        private void CheckForUpdate(BasePlayer player, CTypes type)
        {
            if (titleCache[type].UserID == player.userID)
            {
                titleCache[type].Count = statCache[player.userID].Stats[type];
                return;
            }
            if (!configData.Options.UseUpdateTimer)
            {
                if (statCache[player.userID].Stats[type] > titleCache[type].Count)
                {
                    SwitchLeader(player.userID, type);
                }
            }         
        }
        private void SwitchLeader(ulong ID, CTypes type)
        {    
            if (configData.Options.UseBetterChat && BetterChat)
            {
                var name = GetGroupName(type);

                if (UserInGroup(titleCache[type].UserID.ToString(), name))
                    RemoveFromGroup(titleCache[type].UserID.ToString(), name);

                AddToGroup(ID.ToString(), name);
            }

            titleCache[type] = new LeaderData
            {
                Count = statCache[ID].Stats[type],
                DisplayName = statCache[ID].DisplayName,
                UserID = ID
            };

            if (configData.Options.AnnounceNewLeaders)
            {
                string message = MSG("newLeader", ID.ToString())
                    .Replace("{playername}", $"{configData.Messaging.MSG_ColorMain}{statCache[ID].DisplayName}</color>{configData.Messaging.MSG_ColorMsg}")
                    .Replace("{ctype}", $"</color>{configData.Messaging.MSG_ColorMain}{MSG(type.ToString().ToLower(), ID.ToString())}</color>");
                PrintToChat(message);
            }
        }
        private void AddAllUsergroups()
        {
            if (BetterChat && configData.Options.UseBetterChat)
            {
                foreach (var type in titleCache)
                {
                    var name = GetGroupName(type.Key);
                    if (titleCache[type.Key].UserID == 0) continue;
                    if (!UserInGroup(titleCache[type.Key].UserID.ToString(), name))
                        AddToGroup(titleCache[type.Key].UserID.ToString(), name);
                }
            }
        }
        private void RemoveAllUsergroups()
        {
            if (BetterChat && configData.Options.UseBetterChat)
            {
                foreach (var type in titleCache)
                {
                    var name = GetGroupName(type.Key);
                    if (titleCache[type.Key].UserID == 0) continue;
                    if (UserInGroup(titleCache[type.Key].UserID.ToString(), name))
                        RemoveFromGroup(titleCache[type.Key].UserID.ToString(), name);
                }
            }
        }
        private void CheckUpdateTimer()
        {
            if ((GrabCurrentTime() - chData.LastUpdate) > configData.Options.UpdateTimer)
            {
                var Updates = new Dictionary<CTypes, ulong>();

                foreach (var type in titleCache)
                    Updates.Add(type.Key, type.Value.UserID);

                foreach (var entry in statCache)
                {
                    foreach (var stat in entry.Value.Stats)
                    {
                        if (stat.Value > titleCache[stat.Key].Count)
                            Updates[stat.Key] = entry.Key;
                    }
                }

                foreach (var entry in Updates)
                {
                    if (titleCache[entry.Key].UserID != Updates[entry.Key])
                    {
                        SwitchLeader(entry.Value, entry.Key);
                    }
                }
            }
            else
            {
                var timeRemaining = ((configData.Options.UpdateTimer - (GrabCurrentTime() - chData.LastUpdate)) * 60) * 60;
                timer.Once((int)timeRemaining + 10, () => CheckUpdateTimer());
            }
        }

        #endregion

        #region Chat Commands
        [ChatCommand("pc")]
        private void cmdPC(BasePlayer player, string command, string[] args)
        {
            if (!UIDisabled)
                CreateMenu(player);
            else SendReply(player, MSG("UIDisabled", player.UserIDString));
        }
        [ChatCommand("pc_wipe")]
        private void cmdPCWipe(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin()) return;
            RemoveAllUsergroups();
            titleCache = new Dictionary<CTypes, LeaderData>();
            statCache = new Dictionary<ulong, StatData>();            
            CheckValidData();
            SendReply(player, MSG("dataWipe", player.UserIDString));
            SaveData();
        }

        #endregion

        #region Helper Methods
        private void CheckEntry(BasePlayer player)
        {
            if (!statCache.ContainsKey(player.userID))
            {
                statCache.Add(player.userID, new StatData
                {
                    DisplayName = player.displayName,
                    Stats = new Dictionary<CTypes, int>()
                });
                foreach (var type in typeList)
                    statCache[player.userID].Stats.Add(type, 0);
            }
        }
        private string GetGroupName(CTypes type)
        {
            switch (type)
            {
                case CTypes.Animals:
                    return configData.Titles.AnimalsKilled;
                case CTypes.Arrows:
                    return configData.Titles.ArrowKills;
                case CTypes.Clothes:
                    return configData.Titles.ClothesCrafted;
                case CTypes.Headshots:
                    return configData.Titles.Headshots;
                case CTypes.Plants:
                    return configData.Titles.PlantsGathered;
                case CTypes.Healed:
                    return configData.Titles.PlayersHealed;
                case CTypes.Killed:
                    return configData.Titles.PlayersKilled;
                case CTypes.Melee:
                    return configData.Titles.MeleeKills;
                case CTypes.Revolver:
                    return configData.Titles.RevolverKills;
                case CTypes.Rockets:
                    return configData.Titles.RocketsFired;
                case CTypes.Rocks:
                    return configData.Titles.RocksGathered;
                case CTypes.Swords:
                    return configData.Titles.BladeKills;
                case CTypes.Built:
                    return configData.Titles.StructuresBuilt;
                case CTypes.Repaired:
                    return configData.Titles.StructuresRepaired;
                case CTypes.Explosives:
                    return configData.Titles.ThrownExplosives;
                case CTypes.Weapons:
                    return configData.Titles.WeaponsCrafted;
                case CTypes.Wood:
                    return configData.Titles.WoodGathered;
                case CTypes.Quests:
                    return configData.Titles.QuestsCompleted;
                case CTypes.PVPKill:
                    return configData.Titles.PVPKillDistance;
                case CTypes.PVEKill:
                    return configData.Titles.PVEKillDistance;
                default:
                    return null;
            }
        }
        static double GrabCurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).Hours;
        #endregion

        #region BetterChat Intergration
        private void RegisterGroups()
        {
            if (!BetterChat || !configData.Options.UseBetterChat) return;
            if (BetterChat.Version < new VersionNumber(4,0,0))
            {
                PrintError("You are using an old version of BetterChat that is not supported by this plugin");
                return;
            }
            foreach (var type in typeList)
                RegisterGroup(type);
        }
        private void RegisterGroup(CTypes type)
        {
            var name = GetGroupName(type);
            if (!GroupExists(name))
            {
                NewGroup(name);
                SetGroupTitle(name);
                SetGroupColor(name);
            }
        }
        
        private bool GroupExists(string name) => (bool)BetterChat?.Call("API_GroupExists", name);
        private bool NewGroup(string name) => (bool)BetterChat?.Call("API_AddGroup", name);
        private bool UserInGroup(string ID, string name) => (bool)BetterChat?.Call("API_IsUserInGroup", ID, name);
        private bool AddToGroup(string ID, string name) => (bool)BetterChat?.Call("API_AddUserToGroup", ID, name);
        private bool RemoveFromGroup(string ID, string name) => (bool)BetterChat?.Call("API_RemoveUserFromGroup", ID, name);
        private object SetGroupTitle(string name) => BetterChat?.Call("API_SetGroupSetting", name, "title", $"[{name}]");
        private object SetGroupColor(string name) => BetterChat?.Call("API_SetGroupSetting", name, "titlecolor", "orange");
        #endregion

        #region Config        
        private ConfigData configData;
        class ConfigData
        {
            public Titles Titles { get; set; }
            public Dictionary<string, bool> ActiveChallengeTypes { get; set; }
            public Options Options { get; set; } 
            public Messaging Messaging { get; set; }
            public List<string> UI_Arrangement { get; set; }
        }       
        class Titles
        {
            public string ThrownExplosives;
            public string RocketsFired;
            public string ArrowKills;
            public string PlayersKilled;
            public string Headshots;
            public string AnimalsKilled;
            public string StructuresBuilt;
            public string WoodGathered;
            public string RocksGathered;
            public string PlantsGathered;
            public string ClothesCrafted;
            public string WeaponsCrafted;
            public string PlayersHealed;
            public string RevolverKills;
            public string StructuresRepaired;
            public string MeleeKills;
            public string BladeKills;
            public string QuestsCompleted;
            public string PVPKillDistance;
            public string PVEKillDistance;
        }
       
        class Options
        {
            public bool IgnoreSleepers;
            public bool UseBetterChat;
            public bool IgnoreAdmins;
            public bool IgnoreEventKills;
            public bool AnnounceNewLeaders;
            public bool UseUpdateTimer;
            public int UpdateTimer;
            public int SaveTimer;
        }
        class Messaging
        {
            public string MSG_ColorMain;
            public string MSG_ColorMsg;
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                ActiveChallengeTypes = new Dictionary<string, bool>
                {
                    {CTypes.Animals.ToString(), true },
                    {CTypes.Arrows.ToString(), true },
                    {CTypes.Built.ToString(), true },
                    {CTypes.Clothes.ToString(), true },
                    {CTypes.Explosives.ToString(), true },
                    {CTypes.Headshots.ToString(), true },
                    {CTypes.Healed.ToString(), true },
                    {CTypes.Killed.ToString(), true },
                    {CTypes.Melee.ToString(), true },
                    {CTypes.Plants.ToString(), true },
                    {CTypes.PVEKill.ToString(), true },
                    {CTypes.PVPKill.ToString(), true },
                    {CTypes.Quests.ToString(), true },
                    {CTypes.Repaired.ToString(), true },
                    {CTypes.Revolver.ToString(), true },
                    {CTypes.Rockets.ToString(), true },
                    {CTypes.Rocks.ToString(), true },
                    {CTypes.Swords.ToString(), true },
                    {CTypes.Weapons.ToString(), true },
                    {CTypes.Wood.ToString(), true }

                },
                Titles = new Titles
                {
                    AnimalsKilled = "Hunter",
                    ArrowKills = "Archer",
                    BladeKills = "Swordsman",
                    ClothesCrafted = "Tailor",
                    Headshots = "Assassin",
                    MeleeKills = "Fighter",
                    PlantsGathered = "Harvester",
                    PlayersHealed = "Medic",
                    PlayersKilled = "Murderer",
                    RevolverKills = "Gunslinger",
                    RocketsFired = "Rocketeer",
                    RocksGathered = "Miner",
                    StructuresBuilt = "Architect",
                    StructuresRepaired = "Handyman",
                    ThrownExplosives = "Bomb-tech",
                    WeaponsCrafted = "Gunsmith",
                    WoodGathered = "Lumberjack",
                    QuestsCompleted = "Adventurer",
                    PVPKillDistance = "Sniper",
                    PVEKillDistance = "Deadshot"
                },
                Options = new Options
                {
                    AnnounceNewLeaders = false,
                    IgnoreAdmins = true,
                    IgnoreSleepers = true,
                    IgnoreEventKills = true,
                    SaveTimer = 600,
                    UseBetterChat = true,
                    UseUpdateTimer = false,
                    UpdateTimer = 168
                },
                Messaging = new Messaging
                {
                    MSG_ColorMain = "<color=orange>",
                    MSG_ColorMsg = "<color=#939393>",
                }  ,
                UI_Arrangement = new List<string>
                {
                    CTypes.Animals.ToString(),
                    CTypes.Arrows.ToString(),
                    CTypes.Built.ToString(),
                    CTypes.Clothes.ToString(),
                    CTypes.Explosives.ToString(),
                    CTypes.Headshots.ToString(),
                    CTypes.Healed.ToString(),
                    CTypes.Killed.ToString(),
                    CTypes.Melee.ToString(),
                    CTypes.Plants.ToString(),
                    CTypes.PVEKill.ToString(),
                    CTypes.PVPKill.ToString(),
                    CTypes.Quests.ToString(),
                    CTypes.Repaired.ToString(),
                    CTypes.Revolver.ToString(),
                    CTypes.Rockets.ToString(),
                    CTypes.Rocks.ToString(),
                    CTypes.Swords.ToString(),
                    CTypes.Weapons.ToString(),
                    CTypes.Wood.ToString()
                }                            
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Data Management
        void SaveLoop() => timer.Once(configData.Options.SaveTimer, () => { SaveData(); SaveLoop(); });
        void SaveData()
        {
            chData.Stats = statCache;
            chData.Titles = titleCache;
            data.WriteObject(chData);
        }
        void LoadData()
        {
            try
            {
                chData = data.ReadObject<ChallengeData>();
                statCache = chData.Stats;
                titleCache = chData.Titles;
            }
            catch
            {
                chData = new ChallengeData();
            }
        }
        void CheckValidData()
        {
            if (titleCache.Count < typeList.Count)
            {
                foreach (var type in typeList)
                {
                    if (!titleCache.ContainsKey(type))
                        titleCache.Add(type, new LeaderData());
                }
            }
            foreach(var player in statCache)
            {
                foreach(var type in typeList)
                {
                    if (!player.Value.Stats.ContainsKey(type))
                        player.Value.Stats.Add(type, 0);
                }
            }
        }
        class ChallengeData
        {
            public Dictionary<ulong, StatData> Stats = new Dictionary<ulong, StatData>();
            public Dictionary<CTypes, LeaderData> Titles = new Dictionary<CTypes, LeaderData>();
            public double LastUpdate = 0;
        }   
        class StatData
        {
            public string DisplayName = null;
            public Dictionary<CTypes, int> Stats = new Dictionary<CTypes, int>();
        }    
        class LeaderData
        {
            public ulong UserID = 0U;
            public string DisplayName = null;
            public int Count = 0;
        }
        enum CTypes
        {
            Animals, Arrows, Clothes, Headshots, Plants, Healed, Killed, Melee, Revolver, Rockets, Rocks, Swords, Built, Repaired, Explosives, Weapons, Wood, Quests, PVPKill, PVEKill
        }

        #endregion

        #region Lists
        List<CTypes> typeList = new List<CTypes> { CTypes.Animals, CTypes.Arrows, CTypes.Clothes, CTypes.Headshots, CTypes.Plants, CTypes.Healed, CTypes.Killed, CTypes.Melee, CTypes.Revolver, CTypes.Rockets, CTypes.Rocks, CTypes.Swords, CTypes.Built, CTypes.Repaired, CTypes.Explosives, CTypes.Weapons, CTypes.Wood, CTypes.Quests, CTypes.PVEKill, CTypes.PVPKill };
        List<string> meleeShortnames = new List<string> { "bone.club", "hammer.salvaged", "hatchet", "icepick.salvaged", "knife.bone", "mace", "machete", "pickaxe", "rock", "stone.pickaxe", "stonehatchet", "torch" };
        List<string> bladeShortnames = new List<string> { "salvaged.sword", "salvaged.cleaver", "longsword", "axe.salvaged" };
        List<string> plantShortnames = new List<string> { "pumpkin", "cloth", "corn", "mushroom", "seed.hemp", "seed.corn", "seed.pumpkin" };
        #endregion

        #region Messaging
        private string MSG(string key, string id = null) => lang.GetMessage(key, this, id);

        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            {"newLeader", "{playername} has topped the leader board for most {ctype}" },
            {"animals", "animal kills" },
            {"arrows", "kills with arrows" },
            {"clothes", "clothes crafted" },
            {"headshots", "headshots" },
            {"plants", "plants gathered" },
            {"healed", "players healed" },
            {"killed", "players killed" },
            {"melee", "melee kills" },
            {"revolver", "revolver kills" },
            {"rockets", "rockets fired" },
            {"rocks", "ore gathered" },
            {"swords", "blade kills" },
            {"built", "structures built" },
            {"repaired", "structures repaired" },
            {"explosives", "explosives thrown" },
            {"weapons", "weapons crafted" },
            {"wood", "wood gathered" },
            {"pvekill", "longest PVE kill"},
            {"pvpkill", "longest PVP kill" },
            {"quests", "quests completed" },
            {"UITitle", "Player Challenges   v{Version}" },
            {"UIDisabled", "The UI has been disabled as there is a error in the config. Please contact a admin" },
            {"dataWipe", "You have wiped all player stats and titles" }
        };
        #endregion
    }
}


// --- End of file: PlayerChallenges.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ArenaDeathmatch.cs ---
// --- Original Local Path: ArenaDeathmatch.cs ---

// Requires: EventManager
using System.Collections.Generic;
using System;
using UnityEngine;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Arena Deathmatch", "Reneb", "1.1.6", ResourceId = 741)]
    class ArenaDeathmatch : RustPlugin
    {
        ////////////////////////////////////////////////////////////
        // Setting all fields //////////////////////////////////////
        ////////////////////////////////////////////////////////////
        [PluginReference]
        EventManager EventManager;

        [PluginReference]
        Plugin ZoneManager;

        private bool useThisEvent;
        private bool EventStarted;
        private bool Changed;

        public string CurrentKit;
        private List<DeathmatchPlayer> DeathmatchPlayers = new List<DeathmatchPlayer>();

        ////////////////////////////////////////////////////////////
        // DeathmatchPlayer class to store informations ////////////
        ////////////////////////////////////////////////////////////
        class DeathmatchPlayer : MonoBehaviour
        {
            public BasePlayer player;
            public int kills;

            void Awake()
            {
                player = GetComponent<BasePlayer>();
                enabled = false;
                kills = 0;
            }
        }
        class LeaderBoard
        {
            public string Name;
            public int Kills;
        }

        //////////////////////////////////////////////////////////////////////////////////////
        // Oxide Hooks ///////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////
        void Loaded()
        {
            useThisEvent = false;
            EventStarted = false;
        }
        void OnServerInitialized()
        {
            if (EventManager == null)
            {
                Puts("Event plugin doesn't exist");
                return;
            }
            LoadVariables();
            RegisterGame();
        }
        void RegisterGame()
        {
            var success = EventManager.RegisterEventGame(EventName);
            if (success == null)
            {
                Puts("Event plugin doesn't exist");
                return;
            }
        }
        protected override void LoadDefaultConfig()
        {
            Puts("Event Deathmatch: Creating a new config file");
            Config.Clear();
            LoadVariables();
        }
        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList) DestroyUI(player);

            if (useThisEvent && EventStarted)            
                EventManager.EndEvent();

            var objects = UnityEngine.Object.FindObjectsOfType<DeathmatchPlayer>();
            if (objects != null)
                foreach (var gameObj in objects)
                    UnityEngine.Object.Destroy(gameObj);
        }



        //////////////////////////////////////////////////////////////////////////////////////
        // Configurations ////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////

        static string DefaultKit = "deathmatch";
        static string EventName = "Deathmatch";
        static string EventZoneName = "Deathmatch";
        static string EventSpawnFile = "DeathmatchSpawnfile";
        static int EventWinKills = 10;

        static float EventStartHealth = 100;

        static Dictionary<string, object> EventZoneConfig;

        static string EventMessageWon = "{0} WON THE DEATHMATCH";
        static string EventMessageNoMorePlayers = "Arena has no more players, auto-closing.";
        static string EventMessageKill = "{0} killed {3}. ({1}/{2} kills)";
        static string EventMessageOpenBroadcast = "In Deathmatch, it's a free for all, the goal is to kill as many players as possible!";

        static int TokensAddKill = 1;
        static int TokensAddWon = 5;

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        private void LoadConfigVariables()
        {
            CheckCfg("DeathMatch - Kit - Default", ref DefaultKit);
            CheckCfg("DeathMatch - Event - Name", ref EventName);
            CheckCfg("DeathMatch - Event - SpawnFile", ref EventSpawnFile);
            CheckCfg("DeathMatch - Zone - Name", ref EventZoneName);
            CheckCfg("DeathMatch - Win - Kills Needed", ref EventWinKills);
            CheckCfgFloat("DeathMatch - Start - Health", ref EventStartHealth);


            CheckCfg("Messages - Won", ref EventMessageWon);
            CheckCfg("Messages - Empty", ref EventMessageNoMorePlayers);
            CheckCfg("Messages - Kill", ref EventMessageKill);
            CheckCfg("Messages - Open Broadcast", ref EventMessageOpenBroadcast);

            CheckCfg("Tokens - Per Kill", ref TokensAddKill);
            CheckCfg("Tokens - On Win", ref TokensAddWon);

            CurrentKit = DefaultKit;

        }
        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }
        private void CheckCfgFloat(string Key, ref float var)
        {

            if (Config[Key] != null)
                var = Convert.ToSingle(Config[Key]);
            else
                Config[Key] = var;
        }
        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        object GetEventConfig(string configname)
        {
            if (!useThisEvent) return null;
            if (Config[configname] == null) return null;
            return Config[configname];
        }
        #region UI Scoreboard
        private List<DeathmatchPlayer> SortScores() => DeathmatchPlayers.OrderByDescending(pair => pair.kills).ToList();

        private string PlayerMsg(int key, DeathmatchPlayer player) => $"|  <color=#FF8C00>{key}</color>.  <color=#FF8C00>{player.player.displayName}</color> <color=#939393>--</color> <color=#FF8C00>{player.kills}</color>  |";

        private CuiElementContainer CreateScoreboard(BasePlayer player)
        {
            DestroyUI(player);

            string panelName = "DMScoreBoard";
            var element = EventManager.UI.CreateElementContainer(panelName, "0.3 0.3 0.3 0.6", "0.1 0.95", "0.9 1", false);

            var scores = SortScores();
            var index = scores.FindIndex(a => a.player == player);

            var scoreMessage = PlayerMsg(index + 1, scores[index]);
            int amount = 3;
            for (int i = 0; i < amount; i++)
            {
                if (scores.Count >= i + 1)
                {
                    if (scores[i].player == player)
                    {
                        amount++;
                        continue;
                    }
                    scoreMessage = scoreMessage + PlayerMsg(i + 1, scores[i]);
                }
            }
            EventManager.UI.CreateLabel(ref element, panelName, "", scoreMessage, 18, "0 0", "1 1");
            return element;
        }
        private void RefreshUI()
        {
            foreach (var entry in DeathmatchPlayers)
            {
                DestroyUI(entry.player);
                AddUI(entry.player);
            }
        }
        private void AddUI(BasePlayer player) => CuiHelper.AddUi(player, CreateScoreboard(player));
        private void DestroyUI(BasePlayer player) => CuiHelper.DestroyUi(player, "DMScoreBoard");        
        #endregion

        //////////////////////////////////////////////////////////////////////////////////////
        // Beginning Of Event Manager Hooks //////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////
        void OnSelectEventGamePost(string name)
        {
            if (EventName == name)
            {
                useThisEvent = true;
                if (EventSpawnFile != null && EventSpawnFile != "")
                    EventManager.SelectSpawnfile(EventSpawnFile);
            }
            else
                useThisEvent = false;
        }
        void OnEventPlayerSpawn(BasePlayer player)
        {
            if (useThisEvent && EventStarted)
            {                
                player.inventory.Strip();
                EventManager.GivePlayerKit(player, CurrentKit);
                player.health = EventStartHealth;
                AddUI(player);
            }
        }
        object OnSelectSpawnFile(string name)
        {
            if (useThisEvent)
            {
                EventSpawnFile = name;
                return true;
            }
            return null;
        }
        void OnSelectEventZone(MonoBehaviour monoplayer, string radius)
        {
            if (useThisEvent)
            {
                return;
            }
        }
        void OnPostZoneCreate(string name)
        {
            if (name == EventName)
            {
                return;
            }
        }
        object CanEventOpen()
        {
            if (useThisEvent)
            {

            }
            return null;
        }
        object CanEventStart()
        {
            return null;
        }
        object OnEventOpenPost()
        {
            if (useThisEvent)
                EventManager.BroadcastEvent(EventMessageOpenBroadcast);
            return null;
        }
        object OnEventCancel()
        {
            CheckScores(true);
            return null;
        }
        object OnEventClosePost()
        {
            return null;
        }
        object OnEventEndPre()
        {
            return null;
        }
        object OnEventEndPost()
        {
            if (useThisEvent)
            {
                EventStarted = false;
                DeathmatchPlayers.Clear();
            }
            return null;
        }
        object OnEventStartPre()
        {
            if (useThisEvent)
            {
                EventStarted = true;
            }
            return null;
        }
        object OnEventStartPost()
        {
            return null;
        }
        object CanEventJoin()
        {
            return null;
        }
        object OnSelectKit(string kitname)
        {
            if(useThisEvent)
            {
                CurrentKit = kitname;
                return true;
            }
            return null;
        }
        object OnEventJoinPost(BasePlayer player)
        {
            if (useThisEvent)
            {
                if (player.GetComponent<DeathmatchPlayer>())
                    UnityEngine.Object.Destroy(player.GetComponent<DeathmatchPlayer>());
                DeathmatchPlayers.Add(player.gameObject.AddComponent<DeathmatchPlayer>());
                Puts("here");
            }
            return null;
        }
        object OnEventLeavePost(BasePlayer player)
        {
            if (useThisEvent)
            {
                if (player.GetComponent<DeathmatchPlayer>())
                {
                    DeathmatchPlayers.Remove(player.GetComponent<DeathmatchPlayer>());
                    UnityEngine.Object.Destroy(player.GetComponent<DeathmatchPlayer>());
                    Debug.Log("leavehere");
                    CheckScores();
                }
            }
            return null;
        }
        void OnEventPlayerAttack(BasePlayer attacker, HitInfo hitinfo)
        {
            if (useThisEvent)
            {
                if (!(hitinfo.HitEntity is BasePlayer))
                {
                    hitinfo.damageTypes = new DamageTypeList();
                    hitinfo.DoHitEffects = false;
                }
            }
        }

        void OnEventPlayerDeath(BasePlayer victim, HitInfo hitinfo)
        {
            if (useThisEvent)
            {
                DestroyUI(victim);
                if (hitinfo.Initiator != null)
                {
                    BasePlayer attacker = hitinfo.Initiator.ToPlayer();
                    if (attacker != null)
                    {
                        if (attacker != victim)
                        {
                            AddKill(attacker, victim);
                        }
                    }
                }
            }
            return;
        }
        object EventChooseSpawn(BasePlayer player, Vector3 destination)
        {
            return null;
        }
        object OnRequestZoneName()
        {
            if (useThisEvent)
            {
                return EventZoneName;
            }
            return null;
        }
        //////////////////////////////////////////////////////////////////////////////////////
        // End Of Event Manager Hooks ////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////

        void AddKill(BasePlayer player, BasePlayer victim)
        {
            if (!player.GetComponent<DeathmatchPlayer>())
                return;

            player.GetComponent<DeathmatchPlayer>().kills++;
            EventManager.AddTokens(player.userID.ToString(), TokensAddKill);
            EventManager.BroadcastEvent(string.Format(EventMessageKill, player.displayName, player.GetComponent<DeathmatchPlayer>().kills.ToString(), EventWinKills.ToString(), victim.displayName));
            CheckScores();
        }
        void CheckScores(bool timelimitreached = false)
        {
            if (DeathmatchPlayers.Count == 0)
            {
                EventManager.BroadcastEvent(EventMessageNoMorePlayers);
                EventManager.CloseEvent();
                EventManager.EndEvent();
                return;
            }
            BasePlayer winner = null;
            int topscore = 0;

            foreach (DeathmatchPlayer deathmatchplayer in DeathmatchPlayers)
            {
                if (deathmatchplayer == null) continue;
                if (EventManager.EventMode == EventManager.GameMode.Normal)
                {
                    if (deathmatchplayer.kills >= EventWinKills || DeathmatchPlayers.Count == 1)
                    {
                        winner = deathmatchplayer.player;
                        break;
                    }
                }
                if (timelimitreached)
                {
                    if (deathmatchplayer.kills > topscore)
                    {
                        winner = deathmatchplayer.player;
                        topscore = deathmatchplayer.kills;
                    }
                }
            }
            
            if (winner == null) return;
            Winner(winner);
        }
        void Winner(BasePlayer player)
        {
            var winnerobjectmsg = new object[] {  };
            EventManager.AddTokens(player.userID.ToString(), TokensAddWon);
            var emptyobject = new object[] { };
            for (var i = 1; i < 10; i++)
            {
                EventManager.BroadcastEvent(string.Format(EventMessageWon, player.displayName));
            }
            EventManager.CloseEvent();
            EventManager.EndEvent();
        }
    }
}



// --- End of file: ArenaDeathmatch.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PvpMarkers.cs ---
// --- Original Local Path: PvpMarkers.cs ---

﻿/*
 ########### README ####################################################
                                                                             
  !!! DON'T EDIT THIS FILE !!!
                                                                     
 ########### CHANGES ###################################################

 1.0.0
    - Plugin release
 1.0.1
    - Change CanNetworkTo to object

 #######################################################################
*/

using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;
using System;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Pvp Markers", "Paul", "1.0.1")]
    [Description("PvP Markers on the map")]
    class PvpMarkers : RustPlugin
    {
        #region [Fields]

        private const string permAllow = "pvpmarkers.allow";
        private Configuration config;
        private HashSet<MapMarkerGenericRadius> pvpMarkers = new HashSet<MapMarkerGenericRadius>();

        #endregion

        #region [Oxide Hooks]

        private void Init() => permission.RegisterPermission(permAllow, this);

        private void Unload() => ClearMarkers();

        private void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if (info == null)
                return;

            if (player.IsNpc && !config.allowNpc)
                return;

            var attacker = info.InitiatorPlayer;
            if (attacker == null)
                return;

            if (player == attacker)
                return;

            if (IsFar(attacker.ServerPosition))
                CreateMarker(player.ServerPosition);
        }

        private object CanNetworkTo(MapMarkerGenericRadius marker, BasePlayer player)
        {
            if (marker == null || player == null)
                return null;

            if (pvpMarkers.Contains(marker) && !permission.UserHasPermission(player.UserIDString, permAllow))
                return false;

            return null;
        }

        #endregion

        #region [Hooks]   

        private void CreateMarker(Vector3 position)
        {
            MapMarkerGenericRadius marker = GameManager.server.CreateEntity("assets/prefabs/tools/map/genericradiusmarker.prefab", position) as MapMarkerGenericRadius;
            if (marker == null)
                return;

            pvpMarkers.Add(marker);
            marker.alpha = config.markerConfiguration.markerAlpha;
            marker.radius = config.markerConfiguration.markerRadius;
            marker.color1 = ParseColor(config.markerConfiguration.markerColor1);
            marker.color2 = ParseColor(config.markerConfiguration.markerColor2);
            marker.Spawn();
            marker.SendUpdate();

            timer.In(config.markerConfiguration.markerDuration, () =>
            {
                marker.Kill();
                marker.SendUpdate();
                pvpMarkers.Remove(marker);
            });
        }

        private void ClearMarkers()
        {
            foreach (var marker in pvpMarkers)
            {
                if (marker != null)
                {
                    marker.Kill();
                    marker.SendUpdate();
                }
            }

            pvpMarkers.Clear();
        }

        private bool IsFar(Vector3 position)
        {
            bool isFar = true;
            foreach (var marker in pvpMarkers)
            {
                if (GetDistance(marker.ServerPosition, position) < config.markerDistance)
                {
                    isFar = false;
                    break;
                }
            }

            return isFar;
        }

        private double GetDistance(Vector3 pos1, Vector3 pos2)
        {
            return Math.Round(Vector3.Distance(pos1, pos2), 0);
        }

        private Color ParseColor(string hexColor)
        {
            if (!hexColor.StartsWith("#"))
                hexColor = $"#{hexColor}";

            Color color;
            if (ColorUtility.TryParseHtmlString(hexColor, out color))
                return color;

            return Color.white;
        }

        #endregion

        #region [Chat Commands]

        [ChatCommand("pmtest")]
        private void cmdRaidMarker(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin)
            {
                SendReply(player, GetLang("NoPerm", player.UserIDString));
                return;
            }

            CreateMarker(player.ServerPosition);
            SendReply(player, GetLang("TestPvpMarker", player.UserIDString));
        }

        #endregion

        #region [Classes]

        private class Configuration
        {
            [JsonProperty(PropertyName = "Distance when place new marker from another marker")]
            public int markerDistance;

            [JsonProperty(PropertyName = "Allow NPC")]
            public bool allowNpc;

            [JsonProperty(PropertyName = "Marker configuration")]
            public MarkerConfiguration markerConfiguration;

            public VersionNumber version;
        }

        private class MarkerConfiguration
        {
            [JsonProperty(PropertyName = "Alpha")]
            public float markerAlpha;

            [JsonProperty(PropertyName = "Radius")]
            public float markerRadius;

            [JsonProperty(PropertyName = "Color1")]
            public string markerColor1;

            [JsonProperty(PropertyName = "Color2")]
            public string markerColor2;

            [JsonProperty(PropertyName = "Duration")]
            public float markerDuration;
        }

        #endregion

        #region [Config]

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                markerDistance = 20,
                allowNpc = false,
                markerConfiguration = new MarkerConfiguration
                {
                    markerAlpha = 0.6f,
                    markerRadius = 0.35f,
                    markerDuration = 90f,
                    markerColor1 = "#000000",
                    markerColor2 = "#3498db"
                },
                version = Version
            };
        }

        protected override void LoadDefaultConfig()
        {
            config = GetDefaultConfig();
            Puts("Generating new configuration file........");
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<Configuration>();

                if (config == null)
                    LoadDefaultConfig();

                if (config.version < Version)
                    UpdateConfig();
            }
            catch
            {
                PrintError("######### Configuration file is not valid! #########");
                return;
            }

            SaveConfig();
        }

        private void UpdateConfig()
        {
            Puts("Updating configuration values.....");
            config.version = Version;
            Puts("Configuration updated");
        }

        #endregion

        #region [Localization]

        private string GetLang(string key, string playerID) => lang.GetMessage(key, this, playerID);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "NoPerm", "You don't have permissions" },
                { "TestPvpMarker", "Test PvP Marker created on your position" }

            }, this);
        }

        #endregion
    }
}

// --- End of file: PvpMarkers.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/MainMenu.cs ---
// --- Original Local Path: MainMenu.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;
namespace Oxide.Plugins
{
    [Info("MainMenu", "OxideBro", "1.1.11")]
    public class MainMenu : RustPlugin
    {
        private PluginConfig config;
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Благодарим за покупку плагина у разработчика OxideBro. Если вы передадите этот плагин сторонним лицам знайте - это лишает вас гарантированных обновлений!");
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < new VersionNumber(1, 1, 0))
            {
                PrintWarning("Config update detected! Updating config values...");
                PrintWarning("Config update completed!");
            }
            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                timer.In(1f, () => OnPlayerConnected(player));
                return;
            }

            if (config.Main.OpenToConnectionFirst)
            {
                if (!PlayersList.ContainsKey(player.userID))
                {
                    CreateMenu(player);
                    PlayersList.Add(player.userID, true);
                    return;
                }
            }
            if (config.Main.OpenToConnection)
                CreateMenu(player);
        }

        class DefaultButton
        {
            [JsonProperty("Позиция AnchorMin")]
            public string AnchorMin;
            [JsonProperty("Позиция AnchorMax")]
            public string AnchorMax;
            [JsonProperty("Текст")]
            public string Text;

            [JsonProperty("Настройка изображения")]
            public Images ImagesSetting;

            [JsonProperty("Выполняемая команда (Если это чатовая команда, используйте через слэш)")]
            public string Command;

            [JsonProperty("Цвет кнопки")]
            public string Color;
        }

        public class Images
        {
            [JsonProperty("Ссылка на изображение")]
            public string ImageURL;
            [JsonProperty("Позиция AnchorMin")]
            public string AnchorMin;
            [JsonProperty("Позиция AnchorMax")]
            public string AnchorMax;
            [JsonProperty("Цвет изображения")]
            public string Color;
        }

        class UserAvatar
        {
            [JsonProperty("Позиция AnchorMin")]
            public string AnchorMin;
            [JsonProperty("Позиция AnchorMax")]
            public string AnchorMax;
            [JsonProperty("Прозрачность")]
            public string Color;
        }

        class MainSettings
        {
            [JsonProperty("Показывать при подключении")]
            public bool OpenToConnection = false;

            [JsonProperty("Показывать только при первом подключении")]
            public bool OpenToConnectionFirst = true;

            [JsonProperty("Команды для открытия меню")]
            public List<string> Commands = new List<string>();
        }

        class HomeSettings
        {
            [JsonProperty("Заголовок блока домов игрока")]
            public string Title;
            [JsonProperty("Цвет фона блока")]
            public string ColorHeader;
            [JsonProperty("Позиция AnchorMin")]
            public string AnchorMin;
            [JsonProperty("Позиция AnchorMax")]
            public string AnchorMax;


            [JsonProperty("Шапка: Позиция AnchorMin")]
            public string HeaderAnchorMin;
            [JsonProperty("Шапка: Позиция AnchorMax")]
            public string HeaderAnchorMax;


            [JsonProperty("Настройка иконки")]
            public Images Image;
            [JsonProperty("Текст кнопки сохранения новой точки")]
            public string TextSethome;
            [JsonProperty("Максимальное количество точек домов")]
            public int Limit;
            [JsonProperty("Список привилегий по количеству home (Привилегия: количество)")]
            public Dictionary<string, int> TeleportPrivilages = new Dictionary<string, int>();
            [JsonProperty("Цвет кнопок")]
            public string ColorButtons;
        }

        class FriendSettings
        {
            [JsonProperty("Заголовок блока друзей игрока")]
            public string Title;
            [JsonProperty("Цвет фона блока")]
            public string ColorHeader;

            [JsonProperty("Включить индекатор онлайна")]
            public bool EnabledOnline = false;

            [JsonProperty("Позиция AnchorMin")]
            public string AnchorMin;
            [JsonProperty("Позиция AnchorMax")]
            public string AnchorMax;
            [JsonProperty("Шапка: Позиция AnchorMin")]
            public string HeaderAnchorMin;
            [JsonProperty("Шапка: Позиция AnchorMax")]
            public string HeaderAnchorMax;
            [JsonProperty("Настройка иконки")]
            public Images Image;
            [JsonProperty("Текст кнопки пустой ячейки")]
            public string Text;
            [JsonProperty("Цвет кнопок")]
            public string ColorButtons;

            [JsonProperty("Лимит друзей")]
            public int Limit;
        }

        class OtherSettings
        {
            [JsonProperty("Заголовок блока Дополнительных функций")]
            public string Title;
            [JsonProperty("Цвет фона блока")]
            public string ColorHeader;
            [JsonProperty("Позиция AnchorMin")]
            public string AnchorMin;
            [JsonProperty("Позиция AnchorMax")]
            public string AnchorMax;
            [JsonProperty("Шапка: Позиция AnchorMin")]
            public string HeaderAnchorMin;
            [JsonProperty("Шапка: Позиция AnchorMax")]
            public string HeaderAnchorMax;
            [JsonProperty("Цвет кнопок")]
            public string ColorButtons;
        }

        class PluginConfig
        {
            [JsonProperty("Основные настройки")]
            public MainSettings Main;
            [JsonProperty("Заголовок главной страницы")]
            public string Title = "<b>ТИТЛ-ЗАГОЛОВОК</b> <size=20>ИЛИ</size> <b>НАЗВАНИЕ СЕРВЕРА</b>";
            [JsonProperty("Аватар")]
            public UserAvatar UserAvatar;
            [JsonProperty("Точки дома")]
            public HomeSettings Home;
            [JsonProperty("Друзья")]
            public FriendSettings Friends;
            [JsonProperty("Дополнительные")]
            public OtherSettings Other;
            [JsonProperty("Настройка кнопок")]
            public List<DefaultButton> DefaultButtons = new List<DefaultButton>();
            [JsonProperty("Версия конфигурации")]
            public VersionNumber PluginVersion = new VersionNumber();
            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    PluginVersion = new VersionNumber(),
                    Title = "<b>ТИТЛ-ЗАГОЛОВОК</b> <size=20>ИЛИ</size> <b>НАЗВАНИЕ СЕРВЕРА</b>",
                    Main = new MainSettings()
                    {
                        OpenToConnection = true,
                        OpenToConnectionFirst = true,
                        Commands = new List<string>()
                        {
                            "menu",
                            "info"
                        },
                    },
                    Home = new HomeSettings()
                    {
                        AnchorMin = "0.48 0",
                        AnchorMax = "0.73 0.99",
                        ColorButtons = "0 0 0 0.85",
                        ColorHeader = "0 0 0 0.85",
                        HeaderAnchorMin = "0 0.9",
                        HeaderAnchorMax = "1 1",
                        Image = new Images()
                        {
                            AnchorMin = "0.01 0.05",
                            AnchorMax = "0.2 0.9",
                            Color = "1 1 1 1",
                            ImageURL = "https://i.imgur.com/dcbBvDS.png",
                        },
                        TextSethome = "Нажми, чтобы сохранить\n<size=14><b>SETHOME</b></size>",
                        Title = "ВЫБЕРИТЕ СВОЙ ДОМ",
                        TeleportPrivilages = new Dictionary<string, int>()
                        {
                            ["teleportation.vip"] = 3,
                            ["teleportation.elite"] = 5,
                            ["teleportation.promo"] = 7,

                        },
                        Limit = 7
                    },

                    Friends = new FriendSettings()
                    {
                        AnchorMin = "0.74 0.54",
                        AnchorMax = "0.99 0.99",
                        ColorButtons = "0 0 0 0.85",
                        ColorHeader = "0 0 0 0.85",
                        HeaderAnchorMin = "0 0.85",
                        HeaderAnchorMax = "1 1",
                        Image = new Images()
                        {
                            AnchorMin = "0.01 0.15",
                            AnchorMax = "0.16 0.85",
                            Color = "1 1 1 1",
                            ImageURL = "https://i.imgur.com/7heMoLn.png",
                        },
                        Title = "ВЫБЕРИТЕ ДРУГА",
                        Text = "ПУСТО",
                        Limit = 3,
                    },
                    UserAvatar = new UserAvatar()
                    {
                        AnchorMin = "0.001 0.4",
                        AnchorMax = "0.25 0.99",
                        Color = "1 1 1 1"
                    },
                    Other = new OtherSettings()
                    {
                        AnchorMin = "0.74 0.3",
                        AnchorMax = "0.99 0.53",
                        ColorButtons = "0 0 0 0.85",
                        ColorHeader = "0 0 0 0.85",
                        HeaderAnchorMin = "0 0.75",
                        HeaderAnchorMax = "1 1",
                        Title = "Дополнительные функции"
                    },
                    DefaultButtons = new List<DefaultButton>()
                    {
                        new DefaultButton()
                        {
                            AnchorMin = "0.001 0.195",
                            AnchorMax = "0.25 0.38",
                            Command = "/stat",
                            ImagesSetting = new Images(),
                            Color = "0 0 0 0.85",
                            Text = "<size=11>Нажми, чтобы открыть</size>\n<size=30><b>СТАТИСТИКУ</b></size>"
                        },
                        new DefaultButton()
                        {
                            AnchorMin = "0.26 0.8",
                            AnchorMax = "0.47 0.99",
                            Command = "/block",
                            ImagesSetting = new Images(),
                            Color = "0 0 0 0.85",
                            Text = "<size=11>Нажми, чтобы открыть</size>\n<size=27><b>БЛОКИРОВКУ</b></size>"
                        },
                        new DefaultButton()
                        {
                            AnchorMin = "0.26 0.6",
                            AnchorMax = "0.47 0.79",
                            Command = "/kit",
                             ImagesSetting = new Images(),
                            Color = "0 0 0 0.85",
                            Text = "<size=11>Нажми, чтобы открыть</size>\n<size=30><b>НАБОРЫ</b></size>"
                        },
                        new DefaultButton()
                        {
                            AnchorMin = "0.26 0.4",
                            AnchorMax = "0.47 0.59",
                            Command = "/report",
                             ImagesSetting = new Images(),
                            Color = "0 0 0 0.85",
                            Text = "<size=11>Нажми, чтобы отправить</size>\n<size=30><b>ЖАЛОБУ</b></size>"
                        },
                         new DefaultButton()
                         {
                             AnchorMin = "0.26 0.195",
                             AnchorMax = "0.47 0.38",
                             Command = "/cases",
                              ImagesSetting = new Images(),
                             Color = "0 0 0 0.85",
                             Text = "<size=11>Нажми, чтобы открыть</size>\n<size=30><b>КЕЙСЫ</b></size>"
                         },
                         new DefaultButton()
                         {
                             AnchorMin = "0.74 0.1",
                             AnchorMax = "0.82 0.29",
                             Command = "/lot",
                              ImagesSetting = new Images()
                              {
                                  AnchorMin="0.2 0.2", AnchorMax="0.8 0.8",
                                  ImageURL = "https://i.imgur.com/CrPqgAT.png",
                                  Color = "1 1 1 1"
                              },
                             Color = "0 0 0 0.85",
                             Text = ""
                         },


                          new DefaultButton()
                          {
                             AnchorMin = "0.825 0.1",
                             AnchorMax = "0.905 0.29",
                             Command = "/info",
                             ImagesSetting = new Images()
                             {
                                 AnchorMin="0.2 0.2", AnchorMax="0.8 0.8",
                                 ImageURL = "https://i.imgur.com/AAzVQpA.png",
                                 Color = "1 1 1 1"
                             },
                             Color = "0 0 0 0.85",
                             Text = ""
                          },
                           new DefaultButton()
                           {
                              AnchorMin = "0.91 0.1", AnchorMax = "0.99 0.29",
                              Command = "/store",
                              ImagesSetting = new Images()
                              {
                                  AnchorMin="0.2 0.2", AnchorMax="0.8 0.8",
                                  ImageURL = "https://i.imgur.com/YvaDfru.png",
                                  Color = "1 1 1 1"
                              },
                              Color = "0 0 0 0.85",
                              Text = ""
                         },
                    }
                };
            }
        }

        [PluginReference] Plugin ImageLibrary;
        void OnServerInitialized()
        {
            if (!ImageLibrary)
            {
                PrintError("ImageLibrary not found!");
                return;
            }
            LoadData();
            config.Main.Commands.ForEach(c => cmd.AddChatCommand(c, this, cmdOpenMainMenu));
            foreach (var buttons in config.DefaultButtons)
                ImageLibrary?.Call("AddImage", buttons.ImagesSetting.ImageURL, buttons.ImagesSetting.ImageURL);
            ImageLibrary?.Call("AddImage", config.Home.Image.ImageURL, config.Home.Image.ImageURL);
            ImageLibrary?.Call("AddImage", config.Friends.Image.ImageURL, config.Friends.Image.ImageURL);
            BasePlayer.activePlayerList.ToList().ForEach(OnPlayerConnected);
        }

        public Dictionary<ulong, bool> PlayersList = new Dictionary<ulong, bool>();

        void LoadData()
        {
            try
            {
                PlayersList = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, bool>>(Name);
            }
            catch
            {
                PlayersList = new Dictionary<ulong, bool>();
            }
        }

        void SaveData()
        {
            if (PlayersList != null)
                Interface.Oxide.DataFileSystem.WriteObject(Name, PlayersList);
        }

        void Unload()
        {
            BasePlayer.activePlayerList.ToList().ForEach(DestroyUI);
            SaveData();
        }

        int GetFreeHomesCount(BasePlayer player)
        {
            var count = 1;
            foreach (var privilage in config.Home.TeleportPrivilages)
            {
                if (permission.UserHasPermission(player.UserIDString, privilage.Key) && privilage.Value > count)
                    count = privilage.Value;
            }
            return count;
        }

        void DestroyUI(BasePlayer player)
         => CuiHelper.DestroyUi(player, MainLayer);

        private string MainLayer = "MainMenu";

        void CreateMenu(BasePlayer player)
        {
            DestroyUI(player);
            if (!ImageLibrary) return;
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiElement
            {
                Parent = "Hud",
                Name = MainLayer,
                Components =
                {
                    new CuiImageComponent { Color= "1 1 1 0" },
                    new CuiRectTransformComponent { AnchorMin="0 0", AnchorMax="1 1" },
                    new CuiNeedsCursorComponent{ }
                },
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0 0 0 0.5", Close = MainLayer, Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                Text = { Text = "", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 24 },
            }, MainLayer);


            container.Add(new CuiElement
            {
                Parent = MainLayer,
                Name = MainLayer + "_main",
                Components =
                {
                    new CuiImageComponent { Color="0 0 0 0" },
                    new CuiRectTransformComponent { AnchorMin="0.19 0.32", AnchorMax="0.81 0.78" },
                },
            });

            container.Add(new CuiElement
            {
                Parent = MainLayer + "_main",
                Components =
                    {
                        new CuiTextComponent {Text = config.Title,  Color="1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 30  },
                        new CuiRectTransformComponent { AnchorMin="0 1", AnchorMax="1 1.3" },

                    },
            });


            container.Add(new CuiElement
            {
                Parent = MainLayer + "_main",
                Components =
                {
                    new CuiRawImageComponent { Png = (string)ImageLibrary?.Call("GetImage", player.UserIDString), Color= config.UserAvatar.Color},
                    new CuiRectTransformComponent { AnchorMin= config.UserAvatar.AnchorMin, AnchorMax= config.UserAvatar.AnchorMax },
                },
            });

            int parentName = 0;

            foreach (var button in config.DefaultButtons)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = button.AnchorMin, AnchorMax = button.AnchorMax },
                    Button = { Color = button.Color, Command = $"mainmenu_command {button.Command}" },
                    Text = { Text = "", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 24 },
                }, MainLayer + "_main", MainLayer + parentName);


                if (!string.IsNullOrEmpty(button.Text))
                {
                    container.Add(new CuiElement
                    {
                        Parent = MainLayer + parentName,
                        Components =
                         {
                            new CuiTextComponent {Text = button.Text,  Color="1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 11  },
                            new CuiRectTransformComponent { AnchorMin= button.ImagesSetting != null && !string.IsNullOrEmpty(button.ImagesSetting.ImageURL) ? "0.2 0" : "0 0", AnchorMax="1 1" },
                        },
                    });
                }


                if (button.ImagesSetting != null && !string.IsNullOrEmpty(button.ImagesSetting.ImageURL))
                {
                    container.Add(new CuiElement
                    {
                        Parent = MainLayer + parentName,
                        Components =
                        {
                            new CuiRawImageComponent { Png = (string)ImageLibrary?.Call("GetImage", button.ImagesSetting.ImageURL), Color= button.ImagesSetting.Color},
                            new CuiRectTransformComponent { AnchorMin= button.ImagesSetting.AnchorMin, AnchorMax= button.ImagesSetting.AnchorMax},
                        },
                    });
                }
                parentName++;
            }

            container.Add(new CuiElement
            {
                Parent = MainLayer + "_main",
                Name = MainLayer + "_mainHOME",

                Components =
                {
                    new CuiImageComponent { Color= "0 0 0 0" },
                    new CuiRectTransformComponent { AnchorMin = config.Home.AnchorMin, AnchorMax = config.Home.AnchorMax  },
                },
            });

            container.Add(new CuiElement
            {
                Parent = MainLayer + "_mainHOME",
                Name = MainLayer + "_homeTitle",

                Components =
                {
                    new CuiImageComponent { Color= config.Home.ColorHeader },
                    new CuiRectTransformComponent { AnchorMin = config.Home.HeaderAnchorMin, AnchorMax = config.Home.HeaderAnchorMax },
                },
            });
            container.Add(new CuiElement
            {
                Parent = MainLayer + "_homeTitle",
                Components =
                {
                    new CuiTextComponent {Text =  config.Home.Title,  Color="1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 11 },
                    new CuiRectTransformComponent { AnchorMin="0 0", AnchorMax="1 1" },
                },
            });

            container.Add(new CuiElement
            {
                Parent = MainLayer + "_mainHOME",
                Name = MainLayer + "_mainHOMELIST",

                Components =
                {
                    new CuiImageComponent { Color= "0 0 0 0" },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = $"1 {double.Parse(config.Home.HeaderAnchorMin.Split(' ')[1]) - 0.02}" },
                },
            });

            var pos = GetPositions(1, 7, 0.01f, 0.01f);
            int hom = 0;
            var homes = GetHomes(player);
            var max = GetFreeHomesCount(player) < config.Home.Limit ? config.Home.Limit : GetFreeHomesCount(player);


            if (homes != null && homes.Count > 0)
            {
                foreach (var home in homes.Take(config.Home.Limit))
                {
                    container.Add(new CuiElement
                    {
                        Parent = MainLayer + "_mainHOMELIST",
                        Name = MainLayer + "_Home" + home.Key,
                        Components =
                {
                    new CuiImageComponent {Color=config.Home.ColorButtons},
                    new CuiRectTransformComponent { AnchorMin = pos[hom].AnchorMin, AnchorMax = pos[hom].AnchorMax  },

                },
                    });

                    container.Add(new CuiElement
                    {
                        Parent = MainLayer + "_Home" + home.Key,
                        Components =
                {
                    new CuiRawImageComponent { Png = (string)ImageLibrary?.Call("GetImage", config.Home.Image.ImageURL), Color= config.Home.Image.Color},
                    new CuiRectTransformComponent { AnchorMin= config.Home.Image.AnchorMin, AnchorMax= config.Home.Image.AnchorMax },

                },
                    });

                    container.Add(new CuiElement
                    {
                        Parent = MainLayer + "_Home" + home.Key,
                        Components =
                        {
                            new CuiTextComponent {Text = home.Key,  Color="1 1 1 1", Align = TextAnchor.MiddleCenter, FontSize = 25  },
                            new CuiRectTransformComponent { AnchorMin="0 0", AnchorMax="1 1" },

                        },
                    });

                    container.Add(new CuiElement
                    {
                        Parent = MainLayer + "_Home" + home.Key,
                        Components =
                        {
                            new CuiButtonComponent {Color="1 1 1 0", Command = $"mainmenu_command /home {home.Key}" },
                            new CuiRectTransformComponent { AnchorMin="0 0", AnchorMax="1 1" },

                        },
                    });

                    container.Add(new CuiElement
                    {
                        Parent = MainLayer + "_Home" + home.Key,
                        Name = MainLayer + "_Home" + home.Key + "_remove",
                        Components =
                        {
                            new CuiButtonComponent {Color="0.98 0.22 0.37 0", Command = $"mainmenu_removehome {home.Key} {MainLayer + "_Home" + home.Key}" },
                            new CuiRectTransformComponent { AnchorMin="0.8 0", AnchorMax="1 1" },

                        },
                    });

                    container.Add(new CuiElement
                    {
                        Parent = MainLayer + "_Home" + home.Key + "_remove",
                        Components =
                        {
                            new CuiTextComponent {Text = "X",  Color="0.98 0.22 0.37 1", Align = TextAnchor.MiddleCenter, FontSize = 25, Font = "robotocondensed-regular.ttf",  },
                            new CuiRectTransformComponent { AnchorMin="0 0", AnchorMax="1 1" },

                        },
                    });


                    hom++;
                }
            }

            for (int i = hom; i < max; i++)
            {
                container.Add(new CuiElement
                {
                    Parent = MainLayer + "_mainHOMELIST",
                    Name = MainLayer + "_Home_" + i,
                    Components =
                {
                    new CuiImageComponent {Color= config.Home.ColorButtons },
                    new CuiRectTransformComponent { AnchorMin = pos[i].AnchorMin, AnchorMax = pos[i].AnchorMax  },

                },
                });

                container.Add(new CuiElement
                {
                    Parent = MainLayer + "_Home_" + i,
                    Components =
                {
                    new CuiTextComponent {Text = config.Home.TextSethome,  Color="1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 11  },
                    new CuiRectTransformComponent { AnchorMin="0 0", AnchorMax="1 1" },
                },
                });


                var name = GetGridString(player.transform.position);

                if (homes.ContainsKey(name))
                {
                    var count = homes.Where(p => p.Key.Contains(name)).Count();
                    name = name + $"({count})";
                }

                container.Add(new CuiElement
                {
                    Parent = MainLayer + "_Home_" + i,
                    Components =
                {
                    new CuiButtonComponent {Color="1 1 1 0", Command = $"mainmenu_command /home set {name}" },
                    new CuiRectTransformComponent { AnchorMin="0 0", AnchorMax="1 1" },

                },
                });


            }

            container.Add(new CuiElement
            {
                Parent = MainLayer + "_main",
                Name = MainLayer + "_mainHFriends",

                Components =
                {
                    new CuiImageComponent { Color= "0 0 0 0" },
                    new CuiRectTransformComponent { AnchorMin = config.Friends.AnchorMin, AnchorMax = config.Friends.AnchorMax  },
                },
            });
            container.Add(new CuiElement
            {
                Parent = MainLayer + "_mainHFriends",
                Name = MainLayer + "_mainFRIEND",

                Components =
                {
                    new CuiImageComponent { Color= config.Friends.ColorHeader },
                    new CuiRectTransformComponent { AnchorMin = config.Friends.HeaderAnchorMin, AnchorMax = config.Friends.HeaderAnchorMax  },
                },
            });

            container.Add(new CuiElement
            {
                Parent = MainLayer + "_mainFRIEND",
                Components =
                {
                    new CuiTextComponent {Text = config.Friends.Title,  Color="1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 11 },
                    new CuiRectTransformComponent { AnchorMin="0 0", AnchorMax="1 1" },
                },
            });


            container.Add(new CuiElement
            {
                Parent = MainLayer + "_mainHFriends",
                Name = MainLayer + "_mainFRIENDLIST",

                Components =
                {
                    new CuiImageComponent { Color= "0 0 0 0" },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = $"1 {double.Parse(config.Friends.HeaderAnchorMin.Split(' ')[1]) - 0.02}"  },
                },
            });

            var friends = GetFriends(player.userID);
            var posF = GetPositions(1, config.Friends.Limit, 0.01f, 0.02f);
            int fr = 0;
            if (friends != null && friends.Count > 0)
            {
                foreach (var friend in friends.Take(config.Friends.Limit))
                {
                    var covFriend = covalence.Players.FindPlayerById(friend.ToString());
                    if (covFriend == null) continue;
                    container.Add(new CuiElement
                    {
                        Parent = MainLayer + "_mainFRIENDLIST",
                        Name = MainLayer + "_Friend" + friend,
                        Components =
                {
                    new CuiImageComponent {Color= config.Friends.ColorButtons },
                    new CuiRectTransformComponent { AnchorMin = posF[fr].AnchorMin, AnchorMax = posF[fr].AnchorMax  },

                },
                    });

                    container.Add(new CuiElement
                    {
                        Parent = MainLayer + "_Friend" + friend,
                        Components =
                {
                    new CuiRawImageComponent { Png = (string)ImageLibrary?.Call("GetImage", config.Friends.Image.ImageURL), Color= config.Friends.Image.Color },
                    new CuiRectTransformComponent { AnchorMin= config.Friends.Image.AnchorMin, AnchorMax= config.Friends.Image.AnchorMax },

                },
                    });

                    container.Add(new CuiElement
                    {
                        Name = MainLayer + "_Friend" + friend + covFriend.Id,

                        Parent = MainLayer + "_Friend" + friend,
                        Components =
                        {
                            new CuiTextComponent {Text = $"{covFriend.Name}"  ,  Color="1 1 1 1", Align = TextAnchor.MiddleCenter, FontSize = 15  },
                            new CuiRectTransformComponent { AnchorMin="0.1 0", AnchorMax="1 1" },

                        },
                    });
                    container.Add(new CuiElement
                    {
                        Parent = MainLayer + "_Friend" + friend,
                        Components =
                        {
                            new CuiButtonComponent {Color="1 1 1 0", Command = $"mainmenu_command /tpr {covFriend.Id}" },
                            new CuiRectTransformComponent { AnchorMin="0 0", AnchorMax="1 1" },

                        },
                    });

                    if (config.Friends.EnabledOnline)
                        container.Add(new CuiElement
                        {
                            Parent = MainLayer + "_Friend" + friend + covFriend.Id,
                            Components =
                        {
                            new CuiImageComponent {Color= covFriend.IsConnected ?  "0.04 0.93 0.48 1.00" : "0.98 0.22 0.37 1.00" },
                            new CuiRectTransformComponent { AnchorMin = "0.2 0.1", AnchorMax = "0.8 0.15"  },

                        },
                        });

                    fr++;
                }
            }

            for (int i = fr; i < config.Friends.Limit; i++)
            {
                container.Add(new CuiElement
                {
                    Parent = MainLayer + "_mainFRIENDLIST",
                    Name = MainLayer + "_Friend" + i,
                    Components =
                {
                    new CuiImageComponent {Color= config.Friends.ColorButtons },
                    new CuiRectTransformComponent { AnchorMin = posF[i].AnchorMin, AnchorMax = posF[i].AnchorMax  },

                },
                });
                container.Add(new CuiElement
                {
                    Parent = MainLayer + "_Friend" + i,
                    Components =
                    {
                        new CuiTextComponent {Text = "ПУСТО",  Color="1 1 1 1", Align = TextAnchor.MiddleCenter, FontSize = 18  },
                        new CuiRectTransformComponent { AnchorMin="0 0", AnchorMax="1 1" },

                    },
                });
            }
            container.Add(new CuiElement
            {
                Parent = MainLayer + "_main",
                Name = MainLayer + "_mainOther",
                Components =
                {
                    new CuiImageComponent { Color= "0 0 0 0" },
                    new CuiRectTransformComponent { AnchorMin = config.Other.AnchorMin, AnchorMax = config.Other.AnchorMax  },
                },
            });
            container.Add(new CuiElement
            {
                Parent = MainLayer + "_mainOther",
                Name = MainLayer + "_mainOther1",

                Components =
                {
                    new CuiImageComponent { Color= config.Other.ColorHeader },
                    new CuiRectTransformComponent { AnchorMin = config.Other.HeaderAnchorMin, AnchorMax = config.Other.HeaderAnchorMax },
                },
            });
            container.Add(new CuiElement
            {
                Parent = MainLayer + "_mainOther1",
                Components =
                {
                    new CuiTextComponent {Text = config.Other.Title,  Color="1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 11 },
                    new CuiRectTransformComponent { AnchorMin="0 0", AnchorMax="1 1" },
                },
            });
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0.49 0.685" },
                Button = { Color = config.Other.ColorButtons, Command = "mainmenu_command /trade yes" },
                Text = { Text = "", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 24 },
            }, MainLayer + "_mainOther", MainLayer + "_main_Button");


            container.Add(new CuiElement
            {
                Parent = MainLayer + "_main_Button",
                Components =
                {
                    new CuiTextComponent {Text = "Трейд",  Color="1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 11  },
                    new CuiRectTransformComponent { AnchorMin="0 0.65", AnchorMax="1 1" },
                },
            });
            container.Add(new CuiElement
            {
                Parent = MainLayer + "_main_Button",
                Components =
                {
                    new CuiTextComponent {Text = "ПРИНЯТЬ",  Color="1 1 1 1", Align = TextAnchor.MiddleCenter, FontSize = 22  },
                    new CuiRectTransformComponent { AnchorMin="0 0", AnchorMax="1 0.8" },
                },
            });

            if (Trade?.Call("PlayerGetActiveTrade", player) != null && (bool)Trade?.Call("PlayerGetActiveTrade", player))
            {
                container.Add(new CuiElement
                {
                    Parent = MainLayer + "_main_Button",

                    Components =
                {
                    new CuiImageComponent { Color= "0.04 0.93 0.48 1.00" },
                    new CuiRectTransformComponent { AnchorMin = "0.1 0.1", AnchorMax = "0.9 0.17"  },

                },
                });
            }
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.51 0", AnchorMax = "1 0.685" },
                Button = { Color = config.Other.ColorButtons, Command = "mainmenu_command /tpa" },
                Text = { Text = "", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 24 },
            }, MainLayer + "_mainOther", MainLayer + "_main_Button");


            container.Add(new CuiElement
            {
                Parent = MainLayer + "_main_Button",
                Components =
                {
                    new CuiTextComponent {Text = "Телепорт",  Color="1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 11  },
                    new CuiRectTransformComponent { AnchorMin="0 0.65", AnchorMax="1 1" },

                },
            });

            container.Add(new CuiElement
            {
                Parent = MainLayer + "_main_Button",
                Components =
                {
                    new CuiTextComponent {Text = "ПРИНЯТЬ",  Color="1 1 1 1", Align = TextAnchor.MiddleCenter, FontSize = 22  },
                    new CuiRectTransformComponent { AnchorMin="0 0", AnchorMax="1 0.8" },

                },
            });

            if (Teleportation?.Call("IsActiveQueueTP", player) != null && (bool)Teleportation?.Call("IsActiveQueueTP", player))
            {
                container.Add(new CuiElement
                {
                    Parent = MainLayer + "_main_Button",

                    Components =
                {
                    new CuiImageComponent { Color= "0.04 0.93 0.48 1.00" },
                    new CuiRectTransformComponent {  AnchorMin = "0.1 0.1", AnchorMax = "0.9 0.17"  },

                },
                });
            }
            CuiHelper.AddUi(player, container);
        }

        private string GetGridString(Vector3 position)
        {
            Vector2 adjPosition = new Vector2((World.Size / 2) + position.x, (World.Size / 2) - position.z);
            return $"{NumberToString((int)(adjPosition.x / 150))}{(int)(adjPosition.y / 150)}";
        }

        private string NumberToString(int number)
        {
            bool a = number > 26;
            Char c = (Char)(65 + (a ? number - 26 : number));
            return a ? "A" + c : c.ToString();
        }

        [ConsoleCommand("mainmenu_command")]
        void cmdRUnPlayerCommand(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null) return;
            DestroyUI(player);
            if (args.FullString.Contains("/"))
                player.Command("chat.say", args.FullString);
            else
                player.Command(args.FullString);
        }

        [ConsoleCommand("mainmenu_enabledRhome")]
        void cmdEnabledRemoveHome(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null) return;
            player.Command("chat.say", args.FullString);

            timer.Once(0.1f, () => CreateMenu(player));

        }

        [ConsoleCommand("mainmenu_removehome")]
        void cmdMainMenuRemoveHome(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null) return;
            if (!args.HasArgs(2)) return;
            var home = args.Args[0];
            var parent = args.Args[1];
            CreateRemoveHomse(player, home, parent);
        }


        void CreateRemoveHomse(BasePlayer player, string home, string parrent)
        {
            CuiHelper.DestroyUi(player, $"MainMenu_removehome{home}");
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiElement
            {
                Parent = parrent,
                Name = $"MainMenu_removehome{home}",
                Components =
                {

                    new CuiImageComponent { Color= "0.98 0.22 0.37 0.98", FadeIn = 0.3f  },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" },
                },
            });

            container.Add(new CuiElement
            {
                Parent = $"MainMenu_removehome{home}",
                Components =
                        {
                            new CuiTextComponent {Color="1 1 1 1", Text = "УДАЛИТЬ ?", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-regular.ttf", FadeIn = 0.3f },
                            new CuiRectTransformComponent { AnchorMin="0 0", AnchorMax="0.6 0.97" },
                            new CuiOutlineComponent{Color = "0 0 0 1", Distance = "-0.3 0.3"}

                        },
            });

            container.Add(new CuiElement
            {
                Parent = $"MainMenu_removehome{home}",
                Name = $"MainMenu_removehome_accept",

                Components =
                        {
                            new CuiButtonComponent {Color="0.99 0.49 0.59 1.00", Command = $"mainmenu_enabledRhome /removehome {home}", FadeIn = 0.3f },
                            new CuiRectTransformComponent { AnchorMin="0.6 0", AnchorMax="0.8 0.97" },

                        },
            });

            container.Add(new CuiElement
            {
                Parent = $"MainMenu_removehome_accept",
                Components =
                        {
                            new CuiTextComponent {Color="1 1 1 1", Text = "✓", Align = TextAnchor.MiddleCenter, FontSize = 22, Font = "robotocondensed-regular.ttf", FadeIn = 0.3f  },
                            new CuiRectTransformComponent { AnchorMin="0 0", AnchorMax="1 1" },

                        },
            });

            container.Add(new CuiElement
            {
                Parent = $"MainMenu_removehome{home}",
                Name = $"MainMenu_removehome_decline",

                Components =
                        {
                            new CuiButtonComponent {Color="0.82 0.35 0.36 1.00", Close = $"MainMenu_removehome{home}", FadeIn = 0.3f },
                            new CuiRectTransformComponent { AnchorMin="0.8 0", AnchorMax="1 0.97" },

                        },
            });

            container.Add(new CuiElement
            {
                Parent = $"MainMenu_removehome_decline",
                Components =
                        {
                            new CuiTextComponent {Color="1 1 1 1", Text = "X", Align = TextAnchor.MiddleCenter, FontSize = 22, Font = "robotocondensed-regular.ttf", FadeIn = 0.3f  },
                            new CuiRectTransformComponent { AnchorMin="0 0", AnchorMax="1 1" },

                        },
            });


            CuiHelper.AddUi(player, container);

        }


        [PluginReference] Plugin Friends, NTeleportation, Teleport, Teleportation, HomesGUI, Trade, MutualPermission;

        public List<ulong> GetFriends(ulong playerid = 2952192)
        {
            if (MutualPermission)
            {
                var MutualFr = MutualPermission?.Call("GetFriends", playerid) as List<ulong>;
                return MutualFr;
            }
            if (Friends)
            {
                var friends = Friends?.Call("GetFriends", playerid) as ulong[];
                return friends.ToList();
            }

            return new List<ulong>();
        }

        Dictionary<string, Vector3> GetHomes(BasePlayer player)
        {
            var a1 = (Dictionary<string, Vector3>)NTeleportation?.Call("GetHomes", player.userID) ?? new Dictionary<string, Vector3>();
            var a2 = (Dictionary<string, Vector3>)Teleport?.Call("ApiGetHomes", player.userID) ?? new Dictionary<string, Vector3>();
            var a3 = (Dictionary<string, Vector3>)Teleportation?.Call("GetHomes", player.userID) ?? new Dictionary<string, Vector3>();
            var a4 = (Dictionary<string, Vector3>)HomesGUI?.Call("GetPlayerHomes", player.UserIDString) ?? new Dictionary<string, Vector3>();
            return a1.Concat(a2).Concat(a3).Concat(a4).GroupBy(p => p.Key).ToDictionary(p => p.Key, p => p.First().Value);
        }

        void cmdOpenMainMenu(BasePlayer player, string com, string[] args)
        {
            CreateMenu(player);
        }

        class Position
        {
            public float Xmin;
            public float Xmax;
            public float Ymin;
            public float Ymax;

            public string AnchorMin =>
                $"{Math.Round(Xmin, 4).ToString(CultureInfo.InvariantCulture)} {Math.Round(Ymin, 4).ToString(CultureInfo.InvariantCulture)}";
            public string AnchorMax =>
                $"{Math.Round(Xmax, 4).ToString(CultureInfo.InvariantCulture)} {Math.Round(Ymax, 4).ToString(CultureInfo.InvariantCulture)}";

            public override string ToString()
            {
                return "----------\nAmin:{AnchorMin}\nAmax:{AnchorMax}\n----------⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠";
            }
        }


        private static List<Position> GetPositions(int colums, int rows, float colPadding = 0, float rowPadding = 0, bool columsFirst = false)
        {
            if (colums == 0)
                throw new ArgumentException("Can't create positions for gui!⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠", nameof(colums));
            if (rows == 0)
                throw new ArgumentException("Can't create positions for gui!⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠", nameof(rows));

            List<Position> result = new List<Position>();
            result.Clear();
            var colsDiv = 1f / colums;
            var rowsDiv = 1f / rows;
            if (colPadding == 0) colPadding = colsDiv / 2;
            if (rowPadding == 0) rowPadding = rowsDiv / 2;
            if (!columsFirst)
                for (int j = rows; j >= 1; j--)
                {
                    for (int i = 1; i <= colums; i++)
                    {
                        Position pos = new Position
                        {
                            Xmin = (i - 1) * colsDiv + colPadding / 2f,
                            Xmax = i * colsDiv - colPadding / 2f,
                            Ymin = (j - 1) * rowsDiv + rowPadding / 2f,
                            Ymax = j * rowsDiv - rowPadding / 2f
                        };
                        result.Add(pos);
                    }
                }
            else
                for (int i = 1; i <= colums; i++)
                {
                    for (int j = rows; j >= 1; j--)
                    {
                        Position pos = new Position
                        {
                            Xmin = (i - 1) * colsDiv + colPadding / 2f,
                            Xmax = i * colsDiv - colPadding / 2f,
                            Ymin = (j - 1) * rowsDiv + rowPadding / 2f,
                            Ymax = j * rowsDiv - rowPadding / 2f
                        };
                        result.Add(pos);
                    }
                }
            return result;
        }
    }
}


// --- End of file: MainMenu.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AdminMenu.cs ---
// --- Original Local Path: AdminMenu.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("AdminMenu", "k1lly0u", "0.1.30", ResourceId = 0)]
    class AdminMenu : RustPlugin
    {
        #region Fields 
        private StoredData storedData;
        private DynamicConfigFile data;

        private static AdminMenu ins;
        private Dictionary<string, string> uiColors = new Dictionary<string, string>();

        private enum MenuType { Permissions, Groups, Commands }
        private enum SelectType { Player, String }
        private enum PermSub { View, Player, Group }
        private enum CommSub { Chat, Console, Give }        
        private enum GroupSub { View, UserGroups, AddGroup, RemoveGroup }
        private enum ItemType { Weapon, Construction, Items, Resources, Attire, Tool, Medical, Food, Ammunition, Traps, Misc, Component }

        private Dictionary<ItemType, List<KeyValuePair<string, ItemDefinition>>> itemList = new Dictionary<ItemType, List<KeyValuePair<string, ItemDefinition>>>();
        private Dictionary<ulong, SelectionData> selectData = new Dictionary<ulong, SelectionData>();
        private Dictionary<ulong, GroupData> groupCreator = new Dictionary<ulong, GroupData>();
        private Hash<ulong, Timer> popupTimers = new Hash<ulong, Timer>();
        private string[] charFilter = new string[] { "~", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z" };

        private List<KeyValuePair<string, bool>> permissionList = new List<KeyValuePair<string, bool>>();
        #endregion

        #region Classes
        private class SelectionData
        {
            public MenuType menuType;
            public string subType, selectDesc = string.Empty, returnCommand = string.Empty, target1_Name = string.Empty, target1_Id = string.Empty, target2_Name = string.Empty, target2_Id = string.Empty, character = string.Empty;
            public bool requireTarget1, requireTarget2, isOnline, isGroup, forceOnline;
            public int pageNum, listNum;
        }

        private class GroupData { public string name = string.Empty, title = string.Empty, rank = string.Empty; }
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            permission.RegisterPermission("adminmenu.use", this);
            permission.RegisterPermission("adminmenu.permissions", this);
            permission.RegisterPermission("adminmenu.groups", this);
            lang.RegisterMessages(Messages, this);

            data = Interface.Oxide.DataFileSystem.GetFile("AdminMenu/offline_players");
        }

        private void OnServerInitialized()
        {
            ins = this;
            LoadVariables();
            LoadData();

            if (storedData == null || storedData.offlinePlayers == null)
                storedData = new StoredData();
            else storedData.RemoveOldPlayers();

            SetUIColors();

            foreach(var item in ItemManager.itemList)
            {
                ItemType itemType = (ItemType)Enum.Parse(typeof(ItemType), item.category.ToString(), true);
                if (!itemList.ContainsKey(itemType))
                    itemList.Add(itemType, new List<KeyValuePair<string, ItemDefinition>>());

                itemList[itemType].Add(new KeyValuePair<string, ItemDefinition>(item.displayName.english, item));
            }

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                OnPlayerInit(player);
        }

        private void OnPlayerInit(BasePlayer player) => storedData.OnPlayerInit(player.UserIDString);

        private void OnPlayerDisconnected(BasePlayer player)
        {
            DestroyUI(player);
            storedData.AddOfflinePlayer(player.UserIDString);
        }

        private void OnPermissionRegistered(string name, Plugin owner) => UpdatePermissionList();

        private void OnPluginUnloaded(Plugin plugin) => UpdatePermissionList();

        private void OnServerSave() => SaveData();

        private void Unload()
        {      
            foreach (BasePlayer player in BasePlayer.activePlayerList)
                OnPlayerDisconnected(player);

            ins = null;
        }
        #endregion

        #region CUI Helper
        public class UI
        {
            static public CuiElementContainer Container(string panelName, string color, string aMin, string aMax, bool useCursor = false, string parent = "Overlay")
            {
                var NewElement = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color},
                            RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                            CursorEnabled = useCursor
                        },
                        new CuiElement().Parent = parent,
                        panelName
                    }
                };
                return NewElement;
            }

            static public void Panel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel);
            }

            static public void Label(ref CuiElementContainer container, string panel, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { FontSize = size, Align = align, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);

            }   
            
            static public void Button(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 0f },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel);
            }           
           
            static public void Input(ref CuiElementContainer container, string panel, string color, string text, int size, string command, string aMin, string aMax)
            {                
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                    {
                        new CuiInputFieldComponent
                        {
                            Align = TextAnchor.MiddleLeft,
                            CharsLimit = 50,
                            Color = color,
                            Command = command + text,
                            FontSize = size,
                            IsPassword = false,
                            Text = text                           
                        },
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax }
                    }                
                });
            }

            static public string Color(string hexColor, float alpha)
            {
                if (hexColor.StartsWith("#"))
                    hexColor = hexColor.TrimStart('#');
                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} {alpha}";
            }
        }
        #endregion

        #region UI Creation 
        const string UIMain = "AMUI_MenuMain";        
        const string UIElement = "AMUI_MenuElement";
        const string UIPopup = "AMUI_PopupMessage";
              
        private void OpenAdminMenu(BasePlayer player)
        {
            var container = UI.Container(UIMain, uiColors["bg1"], "0.05 0.08", "0.95 0.92", true);
            CuiHelper.AddUi(player, container);

            CreateMenuCommands(player, CommSub.Chat);
        }

        private void CreateMenuButtons(ref CuiElementContainer container, MenuType menuType, string playerId)
        {
            UI.Panel(ref container, UIElement, uiColors["bg3"], "0.005 0.925", "0.995 0.99");
            UI.Label(ref container, UIElement, string.Format(msg("title", playerId), Version), 24, "0.02 0.93", "0.25 0.98", TextAnchor.UpperLeft);
            
            UI.Button(ref container, UIElement, menuType == MenuType.Commands ? uiColors["button3"] : uiColors["button1"], msg(MenuType.Commands.ToString(), playerId), 16, "0.27 0.93", "0.42 0.985", menuType == MenuType.Commands ? "" : "amui.switchelement commands");
            if (HasPermission(playerId, "adminmenu.permissions"))
                UI.Button(ref container, UIElement, menuType == MenuType.Permissions ? uiColors["button3"] : uiColors["button1"], msg(MenuType.Permissions.ToString(), playerId), 16, "0.425 0.93", "0.575 0.985", menuType == MenuType.Permissions ? "" : "amui.switchelement permissions");
            if (HasPermission(playerId, "adminmenu.groups"))
                UI.Button(ref container, UIElement, menuType == MenuType.Groups ? uiColors["button3"] : uiColors["button1"], msg(MenuType.Groups.ToString(), playerId), 16, "0.58 0.93", "0.73 0.985", menuType == MenuType.Groups ? "" : "amui.switchelement groups");
            UI.Button(ref container, UIElement, uiColors["button1"], msg("exit", playerId), 16, "0.855 0.93", "0.985 0.985", "amui.switchelement exit");
        }

        private void CreateSubMenu(ref CuiElementContainer container, MenuType menuType, string playerId, string subType)
        {
            UI.Panel(ref container, UIElement, uiColors["bg3"], "0.005 0.87", "0.995 0.92");
            switch (menuType)
            {
                case MenuType.Permissions:
                    PermSub permSub = ParseType<PermSub>(subType);
                    UI.Button(ref container, UIElement, permSub == PermSub.View ? uiColors["button3"] : uiColors["button1"], msg("view", playerId), 16, "0.27 0.875", "0.42 0.915", permSub == PermSub.View ? "" : "amui.switchelement permissions view");
                    UI.Button(ref container, UIElement, permSub == PermSub.Player ? uiColors["button3"] : uiColors["button1"], msg("player", playerId), 16, "0.425 0.875", "0.575 0.915", permSub == PermSub.Player ? "" : "amui.switchelement permissions player");
                    UI.Button(ref container, UIElement, permSub == PermSub.Group ? uiColors["button3"] : uiColors["button1"], msg("group", playerId), 16, "0.58 0.875", "0.73 0.915", permSub == PermSub.Group ? "" : "amui.switchelement permissions group");
                    return;
                case MenuType.Groups:
                    GroupSub groupSub = ParseType<GroupSub>(subType);
                    UI.Button(ref container, UIElement, groupSub == GroupSub.View ? uiColors["button3"] : uiColors["button1"], msg("view", playerId), 16, "0.2025 0.875", "0.3525 0.915", groupSub == GroupSub.View ? "" : "amui.switchelement groups view");
                    UI.Button(ref container, UIElement, groupSub == GroupSub.AddGroup ? uiColors["button3"] : uiColors["button1"], msg("addgroup", playerId), 16, "0.3575 0.875", "0.4975 0.915", groupSub == GroupSub.AddGroup ? "" : "amui.switchelement groups addgroup");
                    UI.Button(ref container, UIElement, groupSub == GroupSub.RemoveGroup ? uiColors["button3"] : uiColors["button1"], msg("removegroup", playerId), 16, "0.5025 0.875", "0.6525 0.915", groupSub == GroupSub.RemoveGroup ? "" : "amui.switchelement groups removegroup");
                    UI.Button(ref container, UIElement, groupSub == GroupSub.UserGroups ? uiColors["button3"] : uiColors["button1"], msg("usergroups", playerId), 16, "0.6575 0.875", "0.8075 0.915", groupSub == GroupSub.UserGroups ? "" : "amui.switchelement groups usergroups");
                    return;
                case MenuType.Commands:
                    CommSub commSub = ParseType<CommSub>(subType);
                    UI.Button(ref container, UIElement, commSub == CommSub.Chat ? uiColors["button3"] : uiColors["button1"], msg("chat", playerId), 16, "0.27 0.875", "0.42 0.915", commSub == CommSub.Chat ? "" : "amui.switchelement commands chat");
                    UI.Button(ref container, UIElement, commSub == CommSub.Console ? uiColors["button3"] : uiColors["button1"], msg("console", playerId), 16, "0.425 0.875", "0.575 0.915", commSub == CommSub.Console ? "" : "amui.switchelement commands console");
                    UI.Button(ref container, UIElement, commSub == CommSub.Give ? uiColors["button3"] : uiColors["button1"], msg("give", playerId), 16, "0.58 0.875", "0.73 0.915", commSub == CommSub.Give ? "" : "amui.switchelement commands give");
                    return;
            }
        }

        private void CreateMenuPermissions(BasePlayer player, int page = 0, string filter = "")
        {
            var container = UI.Container(UIElement, "0 0 0 0", "0.05 0.08", "0.95 0.92");
            CreateMenuButtons(ref container, MenuType.Permissions, player.UserIDString);
            CreateSubMenu(ref container, MenuType.Permissions, player.UserIDString, "view");
            CreateCharacterFilter(ref container, player.userID, filter, $"amui.switchelement permissions view 0");

            List<KeyValuePair<string, bool>> permList = new List<KeyValuePair<string, bool>>(permissionList);
            if (!string.IsNullOrEmpty(filter) && filter != "~")
                permList = permList.Where(x => x.Key.StartsWith(filter, StringComparison.OrdinalIgnoreCase)).ToList();
            permList.OrderBy(x => x.Key);

            if (page > 0)
                UI.Button(ref container, UIElement, uiColors["button1"], msg("back", player.UserIDString), 16, "0.015 0.875", "0.145 0.915", $"amui.switchelement permissions view {page - 1}");
            if (permList.Count > 72 && permList.Count > (72 * page + 72))
                UI.Button(ref container, UIElement, uiColors["button1"], msg("next", player.UserIDString), 16, "0.855 0.875", "0.985 0.915", $"amui.switchelement permissions view {page + 1}");

            int count = 0;
            for (int i = page * 72; i < permList.Count; i++)
            {
                KeyValuePair<string, bool> perm = permList[i];
                float[] position = CalculateButtonPosVert(count);
                
                if (!perm.Value)
                {
                    UI.Panel(ref container, UIElement, uiColors["button2"], $"{position[0]} {position[1]}", $"{position[2]} {position[3]}");
                    UI.Label(ref container, UIElement, $"{perm.Key}", 12, $"{position[0]} {position[1]}", $"{position[2]} {position[3]}");
                }
                else
                {    
                    UI.Panel(ref container, UIElement, uiColors["button1"], $"{position[0]} {position[1]}", $"{position[2]} {position[3]}");
                    UI.Label(ref container, UIElement, $"{perm.Key}", 10, $"{position[0]} {position[1]}", $"{position[2]} {position[3]}");
                }
                ++count;

                if (count >= 72)
                    break;
            }

            CuiHelper.DestroyUi(player, UIElement);
            CuiHelper.AddUi(player, container);
        }

        private void CreateMenuGroups(BasePlayer player, GroupSub subType, int page = 0, string filter = "")
        {
            var container = UI.Container(UIElement, "0 0 0 0", "0.05 0.08", "0.95 0.92");
            CreateMenuButtons(ref container, MenuType.Groups, player.UserIDString);
            CreateSubMenu(ref container, MenuType.Groups, player.UserIDString, subType.ToString());

            switch (subType)
            {
                case GroupSub.View:
                    List<string> groupList = GetGroups();
                    groupList.Sort();

                    if (page > 0)
                        UI.Button(ref container, UIElement, uiColors["button1"], msg("back", player.UserIDString), 16, "0.015 0.875", "0.145 0.915", $"amui.switchelement groups view {page - 1}");
                    if (groupList.Count > 72 && groupList.Count > (72 * page + 72))
                        UI.Button(ref container, UIElement, uiColors["button1"], msg("next", player.UserIDString), 16, "0.855 0.875", "0.985 0.915", $"amui.switchelement groups view {page + 1}");

                    int count = 0;
                    for (int i = page * 72; i < groupList.Count; i++)
                    {
                        string groupId = groupList[i];
                        float[] position = CalculateButtonPos(count);

                        UI.Panel(ref container, UIElement, uiColors["button1"], $"{position[0]} {position[1]}", $"{position[2]} {position[3]}");
                        UI.Label(ref container, UIElement, $"{groupId}", 10, $"{position[0]} {position[1]}", $"{position[2]} {position[3]}");
                        ++count;

                        if (count >= 72)
                            break;
                    }
                    break;
                case GroupSub.UserGroups:
                    break;                
                case GroupSub.AddGroup:
                    GroupData groupData;
                    if (!groupCreator.TryGetValue(player.userID, out groupData))
                    {
                        groupCreator.Add(player.userID, new GroupData());
                        groupData = groupCreator[player.userID];
                    }

                    UI.Label(ref container, UIElement, msg("inputhelper", player.UserIDString), 18, "0.1 0.75", "0.9 0.85");
                                       
                    UI.Label(ref container, UIElement, msg("groupname", player.UserIDString), 16, "0.1 0.62", "0.3 0.7", TextAnchor.MiddleLeft);
                    UI.Label(ref container, UIElement, msg("uiwarning", player.UserIDString), 8, "0.1 0.15", "0.9 0.2", TextAnchor.MiddleLeft);
                    UI.Panel(ref container, UIElement, uiColors["bg3"], "0.3 0.63", "0.9 0.69");
                    if (string.IsNullOrEmpty(groupData.name))
                        UI.Input(ref container, UIElement, "", groupData.name, 16, "amui.registergroup input name", "0.32 0.63", "0.9 0.69");
                    else UI.Label(ref container, UIElement, groupData.name, 16, "0.32 0.63", "0.9 0.69", TextAnchor.MiddleLeft);

                    UI.Label(ref container, UIElement, msg("grouptitle", player.UserIDString), 16, "0.1 0.54", "0.3 0.62", TextAnchor.MiddleLeft);
                    UI.Panel(ref container, UIElement, uiColors["bg3"], "0.3 0.55", "0.9 0.61");
                    if (string.IsNullOrEmpty(groupData.title))
                        UI.Input(ref container, UIElement, "", groupData.title, 16, "amui.registergroup input title", "0.32 0.55", "0.9 0.61");
                    else UI.Label(ref container, UIElement, groupData.title, 16, "0.32 0.55", "0.9 0.61", TextAnchor.MiddleLeft);

                    UI.Label(ref container, UIElement, msg("grouprank", player.UserIDString), 16, "0.1 0.46", "0.3 0.54", TextAnchor.MiddleLeft);
                    UI.Panel(ref container, UIElement, uiColors["bg3"], "0.3 0.47", "0.9 0.53");
                    if (string.IsNullOrEmpty(groupData.rank))
                        UI.Input(ref container, UIElement, "", groupData.rank, 16, "amui.registergroup input rank", "0.32 0.47", "0.9 0.53");
                    else UI.Label(ref container, UIElement, groupData.rank, 16, "0.32 0.47", "0.9 0.53", TextAnchor.MiddleLeft);

                    UI.Button(ref container, UIElement, uiColors["button2"], msg("reset", player.UserIDString), 16, "0.345 0.38", "0.495 0.44", "amui.registergroup reset");
                    UI.Button(ref container, UIElement, uiColors["button3"], msg("create", player.UserIDString), 16, "0.505 0.38", "0.655 0.44", "amui.registergroup create");
                    break;                             
            }

            CuiHelper.DestroyUi(player, UIElement);
            CuiHelper.AddUi(player, container);
        }

        private void CreateMenuCommands(BasePlayer player, CommSub subType, int page = 0, ItemType itemType = ItemType.Weapon)
        {             
            var container = UI.Container(UIElement, "0 0 0 0", "0.05 0.08", "0.95 0.92");
            CreateMenuButtons(ref container, MenuType.Commands, player.UserIDString);
            CreateSubMenu(ref container, MenuType.Commands, player.UserIDString, subType.ToString());
            if (subType == CommSub.Give)
                CreateGiveMenu(ref container, itemType, page, player.UserIDString);
            else CreateCommandEntry(ref container, subType, page, player.UserIDString);

            CuiHelper.DestroyUi(player, UIElement);
            CuiHelper.AddUi(player, container);
        }
                
        private void CreateCommandEntry(ref CuiElementContainer container, CommSub subType, int page, string playerId)
        {
            UI.Label(ref container, UIElement, msg("command", playerId), 16, "0.02 0.82", "0.15 0.87", TextAnchor.MiddleLeft);
            UI.Label(ref container, UIElement, msg("description", playerId), 16, "0.15 0.82", "0.4 0.87", TextAnchor.MiddleLeft);
            UI.Label(ref container, UIElement, msg("command", playerId), 16, "0.52 0.82", "0.65 0.87", TextAnchor.MiddleLeft);
            UI.Label(ref container, UIElement, msg("description", playerId), 16, "0.65 0.82", "0.9 0.87", TextAnchor.MiddleLeft);
                       
            List<CommandEntry> commands = subType == CommSub.Chat ? configData.ChatCommands : configData.ConsoleCommands;

            if (page > 0)
                UI.Button(ref container, UIElement, uiColors["button1"], msg("back", playerId), 16, "0.015 0.875", "0.145 0.915", $"amui.switchelement commands {subType.ToString()} {page - 1}");
            if (commands.Count > 32 && commands.Count > (32 * page + 32))
                UI.Button(ref container, UIElement, uiColors["button1"], msg("next", playerId), 16, "0.855 0.875", "0.985 0.915", $"amui.switchelement commands {subType.ToString()} {page + 1}");

            int count = 1;
            for (int i = page * 32; i < commands.Count; i++)
            {
                CommandEntry entry = commands[i];
                bool isDivisable =  IsDivisable(i);
                
                UI.Label(ref container, UIElement, entry.Name, 15, $"{(isDivisable ? 0.02f : 0.52f)} {0.82f - (0.05f * count)}", $"{(isDivisable ? 0.15f : 0.65f)} {0.87f - (0.05f * count)}", TextAnchor.MiddleLeft);
                UI.Label(ref container, UIElement, entry.Description, 15, $"{(isDivisable ? 0.15f : 0.65f)} {0.82f - (0.05f * count)}", $"{(isDivisable ? 0.4f : 0.9f)} {0.87f - (0.05f * count)}", TextAnchor.MiddleLeft);
                UI.Button(ref container, UIElement, uiColors["button1"], msg("use", playerId), 15, $"{(isDivisable ? 0.41f : 0.91f)} {(0.82f - (0.05f * count)) + 0.005f}", $"{(isDivisable ? 0.49f : 0.99f)} {(0.87f - (0.05f * count)) - 0.005f}", $"amui.runcommand {subType} {i}");

                if (!isDivisable)
                    ++count;
                if (count > 16)
                    return;
            }
        }

        private void CreateGiveMenu(ref CuiElementContainer container, ItemType itemType, int page, string playerId)
        {
            UI.Panel(ref container, UIElement, uiColors["bg3"], "0.005 0.815", "0.995 0.865");
            int i = 0;
            foreach(var typeName in Enum.GetNames(typeof(ItemType)))
            {
                UI.Button(ref container, UIElement, itemType.ToString() == typeName ? uiColors["button3"] : uiColors["button1"], msg(typeName.ToString(), playerId), 12, $"{0.015f + ((0.97f / 12) * i) + 0.0025f} 0.82", $"{0.015f + ((0.97f / 12) * (i + 1)) - 0.0025f} 0.86", itemType.ToString() == typeName ? "" : $"amui.switchelement give {typeName} 0");
                i++;
            }

            i = 6;
            foreach(var item in itemList[itemType].OrderBy(x => x.Key))
            {
                float[] position = CalculateItemPos(i);
                UI.Label(ref container, UIElement, item.Key, 10, $"{position[0]} {position[1]}", $"{position[2]} {position[3]}");
                UI.Button(ref container, UIElement, uiColors["button3"], "1", 10, $"{position[2]} {position[1]}", $"{position[2] + (0.158f * 0.24f)} {position[3]}", $"amui.giveitem {item.Value.displayName.english.Replace(" ", "<><>")} {item.Value.shortname} 1");
                UI.Button(ref container, UIElement, uiColors["button3"], "10", 10, $"{position[2] + (0.158f * 0.26f)} {position[1]}", $"{position[2] + (0.158f * 0.49f)} {position[3]}", $"amui.giveitem {item.Value.displayName.english.Replace(" ", "<><>")} {item.Value.shortname} 10");
                UI.Button(ref container, UIElement, uiColors["button3"], "100", 10, $"{position[2] + (0.158f * 0.51f)} {position[1]}", $"{position[2] + (0.158f * 0.74f)} {position[3]}", $"amui.giveitem {item.Value.displayName.english.Replace(" ", "<><>")} {item.Value.shortname} 100");
                UI.Button(ref container, UIElement, uiColors["button3"], "1000", 10, $"{position[2] + (0.158f * 0.76f)} {position[1]}", $"{position[2] + 0.158f} {position[3]}", $"amui.giveitem {item.Value.displayName.english.Replace(" ", "<><>")} {item.Value.shortname} 1000");
                i += 2;
            }
        }

        private void OpenSelectionMenu(BasePlayer player, SelectType selectType, object objList, bool sortList = false)
        {
            SelectionData data = selectData[player.userID];            

            var container = UI.Container(UIElement, "0 0 0 0", "0.05 0.08", "0.95 0.92");            
            UI.Panel(ref container, UIElement, uiColors["bg3"], "0.005 0.925", "0.995 0.99");
            UI.Panel(ref container, UIElement, uiColors["bg3"], "0.005 0.87", "0.995 0.92");
            CreateCharacterFilter(ref container, player.userID, data.character, string.Empty);
            UI.Label(ref container, UIElement, data.selectDesc, 24, "0.02 0.93", "0.8 0.985", TextAnchor.MiddleLeft);
            UI.Button(ref container, UIElement, uiColors["button1"], msg("return", player.UserIDString), 16, "0.855 0.93", "0.985 0.985", $"amui.switchelement {(data.menuType == MenuType.Commands ? "commands" : data.menuType == MenuType.Groups ? "groups" : "permissions")} {data.subType}");

            List<IPlayer> playerList = null;
            List<string> stringList = null;

            switch (selectType)
            {
                case SelectType.Player:

                    playerList = (List<IPlayer>)objList;                    

                    if (!string.IsNullOrEmpty(data.character))
                        playerList = playerList.Where(x => x.Name.ToLower().StartsWith(data.character.ToLower())).ToList();

                    if (sortList)
                        playerList = playerList.OrderBy(x => x.Name).ToList();

                    if (!data.forceOnline)
                    {
                        UI.Button(ref container, UIElement, data.isOnline ? uiColors["button3"] : uiColors["button1"], msg("onlineplayers", player.UserIDString), 16, "0.3475 0.875", "0.4975 0.915", data.isOnline ? "" : $"amui.makeselection online");
                        UI.Button(ref container, UIElement, !data.isOnline ? uiColors["button3"] : uiColors["button1"], msg("offlineplayers", player.UserIDString), 16, "0.5025 0.875", "0.6525 0.915", !data.isOnline ? "" : $"amui.makeselection offline");
                    }
                    break;
                
                case SelectType.String:
                    stringList = (List<string>)objList;                   

                    if (!string.IsNullOrEmpty(data.character))
                        stringList = stringList.Where(x => x.StartsWith(data.character)).ToList();

                    if (sortList)
                        stringList.Sort();
                    break;                
            }  
           
            if (data.pageNum > 0)
                UI.Button(ref container, UIElement, uiColors["button1"], msg("back", player.UserIDString), 16, "0.015 0.875", "0.145 0.915", "amui.makeselection pageDown");
            if (selectType == SelectType.Player ? (playerList.Count > 72 && playerList.Count > (72 * data.pageNum + 72)) : stringList.Count > 72 && stringList.Count > (72 * data.pageNum + 72))
                UI.Button(ref container, UIElement, uiColors["button1"], msg("next", player.UserIDString), 16, "0.855 0.875", "0.985 0.915", "amui.makeselection pageUp");

            int count = 0;
            for (int i = data.pageNum * 72; i < (selectType == SelectType.Player ? playerList.Count : stringList.Count); i++)
            {
                float[] position = CalculateButtonPos(count);

                if (selectType == SelectType.Player)
                {
                    IPlayer target = playerList[i];
                    string userName = StripTags(target.Name);
                    UI.Button(ref container, UIElement, uiColors["button1"], $"{userName} <size=8>({target.Id})</size>", 10, $"{position[0]} {position[1]}", $"{position[2]} {position[3]}", $"amui.makeselection target {target.Id} {userName.Replace(" ", "_-!!-_")}");
                }
                else
                {
                    string button = stringList[i];
                    UI.Button(ref container, UIElement, uiColors["button1"], button, 10, $"{position[0]} {position[1]}", $"{position[2]} {position[3]}", $"amui.makeselection target {button.Replace(" ", "_-!!-_")}");
                }
                ++count;
                if (count >= 72)
                    break;
            }

            CuiHelper.DestroyUi(player, UIElement);
            CuiHelper.AddUi(player, container);
        }

        private void OpenPermissionMenu(BasePlayer player, string groupOrUserId, string playerName, string description, int page, string filter)
        {
            var container = UI.Container(UIElement, "0 0 0 0", "0.05 0.08", "0.95 0.92");

            UI.Panel(ref container, UIElement, uiColors["bg3"], "0.005 0.925", "0.995 0.99");
            UI.Panel(ref container, UIElement, uiColors["bg3"], "0.005 0.87", "0.995 0.92");

            UI.Label(ref container, UIElement, description, 24, "0.02 0.93", "0.8 0.985", TextAnchor.MiddleLeft);

            UI.Button(ref container, UIElement, uiColors["button1"], msg("return", player.UserIDString), 16, "0.855 0.93", "0.985 0.985", $"amui.switchelement permissions view");

            CreateCharacterFilter(ref container, player.userID, filter, string.IsNullOrEmpty(playerName) ? $"amui.switchelement permissions group 0 {groupOrUserId.Replace(" ", "_-!!-_")}" : $"amui.switchelement permissions player 0 {groupOrUserId} {playerName.Replace(" ", "_-!!-_")}");

            List<KeyValuePair<string, bool>> permList = new List<KeyValuePair<string, bool>>(permissionList);
            if (!string.IsNullOrEmpty(filter) && filter != "~")
                permList = permList.Where(x => x.Key.StartsWith(filter, StringComparison.OrdinalIgnoreCase)).ToList();
            permList.OrderBy(x => x.Key);

            if (page > 0)
                UI.Button(ref container, UIElement, uiColors["button1"], msg("back", player.UserIDString), 16, "0.015 0.875", "0.145 0.915", string.IsNullOrEmpty(playerName) ? $"amui.switchelement permissions group {page - 1} {groupOrUserId.Replace(" ", "_-!!-_")} {filter}" : $"amui.switchelement permissions player {page - 1} {groupOrUserId} {playerName.Replace(" ", "_-!!-_")} {filter}");
            if (permList.Count > 72 && permList.Count > (72 * page + 72))
                UI.Button(ref container, UIElement, uiColors["button1"], msg("next", player.UserIDString), 16, "0.855 0.875", "0.985 0.915", string.IsNullOrEmpty(playerName) ? $"amui.switchelement permissions group {page + 1} {groupOrUserId.Replace(" ", "_-!!-_")} {filter}" : $"amui.switchelement permissions player {page + 1} {groupOrUserId} {playerName.Replace(" ", "_-!!-_")} {filter}");            

            int count = 0;
            for (int i = page * 72; i < permList.Count; i++)
            {
                KeyValuePair<string, bool> perm = permList[i];
                float[] position = CalculateButtonPosVert(count);
              
                if (!perm.Value)
                {
                    UI.Panel(ref container, UIElement, uiColors["button2"], $"{position[0]} {position[1]}", $"{position[2]} {position[3]}");
                    UI.Label(ref container, UIElement, $"{perm.Key}", 12, $"{position[0]} {position[1]}", $"{position[2]} {position[3]}");                    
                }
                else
                {
                    bool hasPermission = HasPermission(groupOrUserId, perm.Key, string.IsNullOrEmpty(playerName) ? true : false);

                    UI.Button(ref container, UIElement, hasPermission ? uiColors["button3"] : uiColors["button1"], perm.Key, 10, $"{position[0]} {position[1]}", $"{position[2]} {position[3]}", string.IsNullOrEmpty(playerName) ? $"amui.togglepermission group {groupOrUserId.Replace(" ", "_-!!-_")} {page} {perm.Key} {!hasPermission} {filter}" : $"amui.togglepermission player {groupOrUserId} {playerName.Replace(" ", "_-!!-_")} {page} {perm.Key} {!hasPermission} {filter}");
                }               
                ++count;

                if (count >= 72)
                    break;
            }

            CuiHelper.DestroyUi(player, UIElement);
            CuiHelper.AddUi(player, container);
        }

        private void OpenGroupMenu(BasePlayer player, string userId, string userName, string description, int page)
        {
            var container = UI.Container(UIElement, "0 0 0 0", "0.05 0.08", "0.95 0.92");

            UI.Panel(ref container, UIElement, uiColors["bg3"], "0.005 0.925", "0.995 0.99");
            UI.Panel(ref container, UIElement, uiColors["bg3"], "0.005 0.87", "0.995 0.92");

            UI.Label(ref container, UIElement, description, 24, "0.02 0.93", "0.8 0.985", TextAnchor.MiddleLeft);

            UI.Button(ref container, UIElement, uiColors["button1"], msg("return", player.UserIDString), 16, "0.855 0.93", "0.985 0.985", $"amui.switchelement groups view");
            List<string> groupList = GetGroups();
            groupList.Sort();

            if (page > 0)
                UI.Button(ref container, UIElement, uiColors["button1"], msg("back", player.UserIDString), 16, "0.015 0.875", "0.145 0.915", $"amui.switchelement groups usergroups {page - 1} {userId} {userName.Replace(" ", "_-!!-_")}");
            if (groupList.Count > 72 && groupList.Count > (72 * page + 72))
                UI.Button(ref container, UIElement, uiColors["button1"], msg("next", player.UserIDString), 16, "0.855 0.875", "0.985 0.915", $"amui.switchelement groups usergroups {page + 1} {userId} {userName.Replace(" ", "_-!!-_")}");

            int count = 0;
            for (int i = page * 72; i < groupList.Count; i++)
            {
                string groupId = groupList[i];
                float[] position = CalculateButtonPos(count);

                bool hasPermission = HasGroup(userId, groupId);

                UI.Button(ref container, UIElement, hasPermission ? uiColors["button3"] : uiColors["button1"], groupId, 10, $"{position[0]} {position[1]}", $"{position[2]} {position[3]}", $"amui.togglegroup {userId} {userName.Replace(" ", "_-!!-_")} {page} {groupId.Replace(" ", "_-!!-_")} {!hasPermission}");
                ++count;

                if (count >= 72)
                    break;
            }

            CuiHelper.DestroyUi(player, UIElement);
            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region UI Functions
        private void CreateCharacterFilter(ref CuiElementContainer container, ulong playerId, string currentCharacter, string returnCommand)
        {
            float buttonHeight = 1f / 27f;
            int i = 0;
            foreach(var character in charFilter)
            {
                UI.Button(ref container, UIElement, currentCharacter == character ? uiColors["button3"] : uiColors["button1"], character, 10, $"-0.02 {1 - (buttonHeight * i) - buttonHeight + 0.002f}", $"-0.001 {1 - (buttonHeight * i) - 0.002f}", currentCharacter == character ? "" : $"{(string.IsNullOrEmpty(returnCommand) ? "amui.filterchar" : returnCommand)} {character}");
                i++;
            }
        }

        private float[] CalculateButtonPos(int number)
        {
            Vector2 position = new Vector2(0.014f, 0.78f);
            Vector2 dimensions = new Vector2(0.158f, 0.06f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 6)
            {
                offsetX = (0.005f + dimensions.x) * number;
            }
            if (number > 5 && number < 12)
            {
                offsetX = (0.005f + dimensions.x) * (number - 6);
                offsetY = (-0.007f - dimensions.y) * 1;
            }
            if (number > 11 && number < 18)
            {
                offsetX = (0.005f + dimensions.x) * (number - 12);
                offsetY = (-0.007f - dimensions.y) * 2;
            }
            if (number > 17 && number < 24)
            {
                offsetX = (0.005f + dimensions.x) * (number - 18);
                offsetY = (-0.007f - dimensions.y) * 3;
            }
            if (number > 23 && number < 30)
            {
                offsetX = (0.005f + dimensions.x) * (number - 24);
                offsetY = (-0.007f - dimensions.y) * 4;
            }
            if (number > 29 && number < 36)
            {
                offsetX = (0.005f + dimensions.x) * (number - 30);
                offsetY = (-0.007f - dimensions.y) * 5;
            }
            if (number > 35 && number < 42)
            {
                offsetX = (0.005f + dimensions.x) * (number - 36);
                offsetY = (-0.007f - dimensions.y) * 6;
            }
            if (number > 41 && number < 48)
            {
                offsetX = (0.005f + dimensions.x) * (number - 42);
                offsetY = (-0.007f - dimensions.y) * 7;
            }
            if (number > 47 && number < 54)
            {
                offsetX = (0.005f + dimensions.x) * (number - 48);
                offsetY = (-0.007f - dimensions.y) * 8;
            }
            if (number > 53 && number < 60)
            {
                offsetX = (0.005f + dimensions.x) * (number - 54);
                offsetY = (-0.007f - dimensions.y) * 9;
            }
            if (number > 59 && number < 66)
            {
                offsetX = (0.005f + dimensions.x) * (number - 60);
                offsetY = (-0.007f - dimensions.y) * 10;
            }
            if (number > 65 && number < 72)
            {
                offsetX = (0.005f + dimensions.x) * (number - 66);
                offsetY = (-0.007f - dimensions.y) * 11;
            }
            if (number > 71 && number < 78)
            {
                offsetX = (0.005f + dimensions.x) * (number - 72);
                offsetY = (-0.007f - dimensions.y) * 12;
            }

            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private float[] CalculateButtonPosVert(int number)
        {
            Vector2 position = new Vector2(0.014f, 0.78f);
            Vector2 dimensions = new Vector2(0.158f, 0.06f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 12)
            {
                offsetY = (-0.007f - dimensions.y) * number;
            }
            if (number > 11 && number < 24)
            {
                offsetX = (0.005f + dimensions.x) * 1;
                offsetY = (-0.007f - dimensions.y) * (number - 12);
            }
            if (number > 23 && number < 36)
            {
                offsetX = (0.005f + dimensions.x) * 2;
                offsetY = (-0.007f - dimensions.y) * (number - 24);
            }
            if (number > 35 && number < 48)
            {
                offsetX = (0.005f + dimensions.x) * 3;
                offsetY = (-0.007f - dimensions.y) * (number - 36);
            }
            if (number > 47 && number < 60)
            {
                offsetX = (0.005f + dimensions.x) * 4;
                offsetY = (-0.007f - dimensions.y) * (number - 48);
            }
            if (number > 59 && number < 72)
            {
                offsetX = (0.005f + dimensions.x) * 5;
                offsetY = (-0.007f - dimensions.y) * (number - 60);
            }
            
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private float[] CalculateItemPos(int number)
        {
            Vector2 position = new Vector2(0.014f, 0.81f);
            Vector2 dimensions = new Vector2(0.158f, 0.03f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 6)
            {
                offsetX = (0.005f + dimensions.x) * number;
            }
            if (number > 5 && number < 12)
            {
                offsetX = (0.005f + dimensions.x) * (number - 6);
                offsetY = (-0.007f - dimensions.y) * 1;
            }
            if (number > 11 && number < 18)
            {
                offsetX = (0.005f + dimensions.x) * (number - 12);
                offsetY = (-0.007f - dimensions.y) * 2;
            }
            if (number > 17 && number < 24)
            {
                offsetX = (0.005f + dimensions.x) * (number - 18);
                offsetY = (-0.007f - dimensions.y) * 3;
            }
            if (number > 23 && number < 30)
            {
                offsetX = (0.005f + dimensions.x) * (number - 24);
                offsetY = (-0.007f - dimensions.y) * 4;
            }
            if (number > 29 && number < 36)
            {
                offsetX = (0.005f + dimensions.x) * (number - 30);
                offsetY = (-0.007f - dimensions.y) * 5;
            }
            if (number > 35 && number < 42)
            {
                offsetX = (0.005f + dimensions.x) * (number - 36);
                offsetY = (-0.007f - dimensions.y) * 6;
            }
            if (number > 41 && number < 48)
            {
                offsetX = (0.005f + dimensions.x) * (number - 42);
                offsetY = (-0.007f - dimensions.y) * 7;
            }
            if (number > 47 && number < 54)
            {
                offsetX = (0.005f + dimensions.x) * (number - 48);
                offsetY = (-0.007f - dimensions.y) * 8;
            }
            if (number > 53 && number < 60)
            {
                offsetX = (0.005f + dimensions.x) * (number - 54);
                offsetY = (-0.007f - dimensions.y) * 9;
            }
            if (number > 59 && number < 66)
            {
                offsetX = (0.005f + dimensions.x) * (number - 60);
                offsetY = (-0.007f - dimensions.y) * 10;
            }
            if (number > 65 && number < 72)
            {
                offsetX = (0.005f + dimensions.x) * (number - 66);
                offsetY = (-0.007f - dimensions.y) * 11;
            }
            if (number > 71 && number < 78)
            {
                offsetX = (0.005f + dimensions.x) * (number - 72);
                offsetY = (-0.007f - dimensions.y) * 12;
            }
            if (number > 77 && number < 84)
            {
                offsetX = (0.005f + dimensions.x) * (number - 78);
                offsetY = (-0.007f - dimensions.y) * 13;
            }
            if (number > 83 && number < 90)
            {
                offsetX = (0.005f + dimensions.x) * (number - 84);
                offsetY = (-0.007f - dimensions.y) * 14;
            }
            if (number > 89 && number < 96)
            {
                offsetX = (0.005f + dimensions.x) * (number - 90);
                offsetY = (-0.007f - dimensions.y) * 15;
            }
            if (number > 95 && number < 102)
            {
                offsetX = (0.005f + dimensions.x) * (number - 96);
                offsetY = (-0.007f - dimensions.y) * 16;
            }
            if (number > 101 && number < 108)
            {
                offsetX = (0.005f + dimensions.x) * (number - 102);
                offsetY = (-0.007f - dimensions.y) * 17;
            }
            if (number > 107 && number < 114)
            {
                offsetX = (0.005f + dimensions.x) * (number - 108);
                offsetY = (-0.007f - dimensions.y) * 18;
            }
            if (number > 113 && number < 120)
            {
                offsetX = (0.005f + dimensions.x) * (number - 114);
                offsetY = (-0.007f - dimensions.y) * 19;
            }
            if (number > 119 && number < 126)
            {
                offsetX = (0.005f + dimensions.x) * (number - 120);
                offsetY = (-0.007f - dimensions.y) * 20;
            }
            if (number > 125 && number < 132)
            {
                offsetX = (0.005f + dimensions.x) * (number - 126);
                offsetY = (-0.007f - dimensions.y) * 21;
            }
            if (number > 131 && number < 138)
            {
                offsetX = (0.005f + dimensions.x) * (number - 132);
                offsetY = (-0.007f - dimensions.y) * 22;
            }
            if (number > 137 && number < 144)
            {
                offsetX = (0.005f + dimensions.x) * (number - 138);
                offsetY = (-0.007f - dimensions.y) * 23;
            }
            if (number > 143 && number < 150)
            {
                offsetX = (0.005f + dimensions.x) * (number - 144);
                offsetY = (-0.007f - dimensions.y) * 24;
            }
            if (number > 149 && number < 156)
            {
                offsetX = (0.005f + dimensions.x) * (number - 150);
                offsetY = (-0.007f - dimensions.y) * 25;
            }
            if (number > 155 && number < 162)
            {
                offsetX = (0.005f + dimensions.x) * (number - 156);
                offsetY = (-0.007f - dimensions.y) * 26;
            }

            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private string StripTags(string str)
        {
            if (str.StartsWith("[") && str.Contains("]") && str.Length > str.IndexOf("]"))            
                str = str.Substring(str.IndexOf("]") + 1).Trim();
            
            if (str.StartsWith("[") && str.Contains("]") && str.Length > str.IndexOf("]"))
                StripTags(str);

            return str;
        }

        private void PopupMessage(BasePlayer player, string message)
        {
            var container = UI.Container(UIPopup, uiColors["bg2"], "0.05 0.92", "0.95 0.98");
            UI.Label(ref container, UIPopup, message, 17, "0 0", "1 1");

            Timer destroyIn;
            if (popupTimers.TryGetValue(player.userID, out destroyIn))
                destroyIn.Destroy();
            popupTimers[player.userID] = timer.Once(5, () =>
            {
                CuiHelper.DestroyUi(player, UIPopup);
                popupTimers.Remove(player.userID);
            });

            CuiHelper.DestroyUi(player, UIPopup);
            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region UI Commands
        [ConsoleCommand("amui.runcommand")]
        private void ccmdUIRunCommand(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            if (!HasPermission(player.UserIDString, "adminmenu.use")) return;

            CommSub subType = ParseType<CommSub>(arg.Args[0]);
            int listNum = arg.GetInt(1);

            CommandEntry entry = (subType == CommSub.Chat ? configData.ChatCommands : configData.ConsoleCommands)[listNum];

            SelectionData data;
            if (!selectData.TryGetValue(player.userID, out data))
            {
                selectData.Add(player.userID, new SelectionData
                {
                    listNum = arg.GetInt(1),
                    menuType = MenuType.Commands,
                    pageNum = 0,
                    requireTarget1 = entry.Command.Contains("{target1_name}") || entry.Command.Contains("{target1_id}"),
                    requireTarget2 = entry.Command.Contains("{target2_name}") || entry.Command.Contains("{target2_id}"),
                    returnCommand = $"amui.runcommand",
                    selectDesc = string.Empty,
                    subType = arg.Args[0],
                    isOnline = true,
                });
                data = selectData[player.userID];
            }

            data.selectDesc = string.IsNullOrEmpty(data.target1_Id) ? msg("selectplayer", player.UserIDString) : msg("selecttarget", player.UserIDString);

            string command = string.Empty;

            if (data.requireTarget2)
            {
                if (!string.IsNullOrEmpty(data.target1_Id) && !string.IsNullOrEmpty(data.target1_Name) && !string.IsNullOrEmpty(data.target2_Id) && !string.IsNullOrEmpty(data.target2_Name))
                    command = entry.Command
                        .Replace("{target1_name}", $"\"{data.target1_Name}\"")
                        .Replace("{target1_id}", data.target1_Id)
                        .Replace("{target2_name}", $"\"{data.target2_Name}\"")
                        .Replace("{target2_id}", data.target2_Id);                
            }
            else if (data.requireTarget1)
            {
                if (!string.IsNullOrEmpty(data.target1_Id) && !string.IsNullOrEmpty(data.target1_Name))
                    command = entry.Command
                        .Replace("{target1_name}", $"\"{data.target1_Name}\"")
                        .Replace("{target1_id}", data.target1_Id);                
            }
            else command = entry.Command;

            if (!string.IsNullOrEmpty(command))
            {
                if (subType == CommSub.Console)
                    rust.RunServerCommand(command);
                else rust.RunClientCommand(player, "chat.say", command);

                PopupMessage(player, string.Format(msg("commandrun", player.UserIDString), command));

                selectData.Remove(player.userID);
                CreateMenuCommands(player, subType, 0);
            }
            else OpenSelectionMenu(player, SelectType.Player, data.isOnline ? covalence.Players.Connected.ToList() : storedData.GetOfflineList(), true);
        }

        [ConsoleCommand("amui.filterchar")]
        private void ccmdFilterChar(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            if (!HasPermission(player.UserIDString, "adminmenu.use")) return;

            SelectionData data = selectData[player.userID];

            data.character = arg.GetString(0) == "~" ? string.Empty : arg.GetString(0);

            switch (data.returnCommand)
            {
                case "amui.runcommand":
                    rust.RunClientCommand(player, data.returnCommand, data.subType, data.listNum);
                    break;
                case "amui.selectforpermission":
                    rust.RunClientCommand(player, data.returnCommand, data.isGroup);
                    break;
                case "amui.selectremovegroup":
                    rust.RunClientCommand(player, data.returnCommand);
                    break;
                case "amui.selectforgroup":
                    rust.RunClientCommand(player, data.returnCommand);
                    break;
                default:
                    rust.RunClientCommand(player, data.returnCommand);
                    break;
            }
        }

        [ConsoleCommand("amui.registergroup")]
        private void ccmdRegisterGroup(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            if (!HasPermission(player.UserIDString, "adminmenu.use")) return;

            GroupData groupData = groupCreator[player.userID];
            if (!groupCreator.TryGetValue(player.userID, out groupData))
            {
                groupCreator.Add(player.userID, new GroupData());
                groupData = groupCreator[player.userID];
            }

            switch (arg.Args[0])
            {
                case "input":
                    switch (arg.GetString(1))
                    {
                        case "name":
                            groupData.name = string.Join(" ", arg.Args.Skip(2).ToArray());
                            break;
                        case "title":
                            groupData.title = string.Join(" ", arg.Args.Skip(2).ToArray());
                            break;
                        case "rank":
                            groupData.rank = string.Join(" ", arg.Args.Skip(2).ToArray());
                            break;
                    }
                    CreateMenuGroups(player, GroupSub.AddGroup);
                    return;
                case "create":
                    if (string.IsNullOrEmpty(groupData.name))
                    {
                        PopupMessage(player, msg("nogroupname", player.UserIDString));
                        return;
                    }
                    int rank = 0;
                    int.TryParse(groupData.rank, out rank);

                    if (CreateGroup(groupData.name, groupData.title, rank))
                        PopupMessage(player, string.Format(msg("groupcreated", player.UserIDString), groupData.name));

                    CreateMenuGroups(player, GroupSub.View);
                    groupCreator.Remove(player.userID);
                    return;
                case "reset":
                    groupCreator[player.userID] = new GroupData();
                    CreateMenuGroups(player, GroupSub.AddGroup);
                    return;
            }
        }

        [ConsoleCommand("amui.selectforpermission")]
        private void ccmdSelectPermission(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            if (!HasPermission(player.UserIDString, "adminmenu.use")) return;

            bool isGroup = arg.GetBool(0);

            SelectionData data;
            if (!selectData.TryGetValue(player.userID, out data))
            {
                selectData.Add(player.userID, new SelectionData
                {
                    listNum = arg.GetInt(1),
                    menuType = MenuType.Permissions,
                    pageNum = 0,
                    requireTarget1 = true,
                    returnCommand = "amui.selectforpermission",                    
                    isGroup = isGroup,
                    selectDesc = isGroup ? msg("selectgroup", player.UserIDString) : msg("selectplayer", player.UserIDString),
                    subType = "view",
                    isOnline = true,                    
                });
                data = selectData[player.userID];
            }
            if (data.isGroup)
            {
                if (!string.IsNullOrEmpty(data.target1_Id))
                {
                    OpenPermissionMenu(player, data.target1_Id, string.Empty, string.Format(msg("togglepermgroup", player.UserIDString), data.target1_Id), 0, "");
                    selectData.Remove(player.userID);
                    return;
                }
            }
            else
            {
                if (!string.IsNullOrEmpty(data.target1_Id) && !string.IsNullOrEmpty(data.target1_Name))
                {
                    OpenPermissionMenu(player, data.target1_Id, data.target1_Name, string.Format(msg("togglepermplayer", player.UserIDString), data.target1_Name), 0, "");
                    selectData.Remove(player.userID);
                    return;
                }
            }

            object obj;
            if (isGroup)
                obj = GetGroups();
            else obj = data.isOnline ? covalence.Players.Connected.ToList() : storedData.GetOfflineList();

            OpenSelectionMenu(player, isGroup ? SelectType.String : SelectType.Player, obj, true);
        }

        [ConsoleCommand("amui.selectforgroup")]
        private void ccmdSelectGroup(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            if (!HasPermission(player.UserIDString, "adminmenu.use")) return;
                   
            SelectionData data;
            if (!selectData.TryGetValue(player.userID, out data))
            {
                selectData.Add(player.userID, new SelectionData
                {
                    listNum = arg.GetInt(1),
                    menuType = MenuType.Permissions,
                    pageNum = 0,
                    requireTarget1 = true,
                    returnCommand = "amui.selectforgroup",
                    selectDesc = msg("selectplayer", player.UserIDString),
                    subType = "view",
                    isOnline = true,
                });
                data = selectData[player.userID];
            }
            if (!string.IsNullOrEmpty(data.target1_Id) && !string.IsNullOrEmpty(data.target1_Name))
            {
                OpenGroupMenu(player, data.target1_Id, data.target1_Name, string.Format(msg("togglegroupplayer", player.UserIDString), data.target1_Name), 0);
                selectData.Remove(player.userID);
                return;
            }
            
            OpenSelectionMenu(player, SelectType.Player, data.isOnline ? covalence.Players.Connected.ToList() : storedData.GetOfflineList(), true);
        }

        [ConsoleCommand("amui.selectremovegroup")]
        private void ccmdSelectRemoveGroup(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            if (!HasPermission(player.UserIDString, "adminmenu.use")) return;
                 
            SelectionData data;
            if (!selectData.TryGetValue(player.userID, out data))
            {
                selectData.Add(player.userID, new SelectionData
                {
                    listNum = arg.GetInt(1),
                    menuType = MenuType.Groups,
                    pageNum = 0,
                    requireTarget1 = true,
                    returnCommand = "amui.selectremovegroup",
                    selectDesc = msg("selectremovegroup", player.UserIDString),
                    subType = "view",
                    isOnline = true,
                });
                data = selectData[player.userID];
            }
            if (!string.IsNullOrEmpty(data.target1_Id))
            {
                RemoveGroup(data.target1_Id);
                PopupMessage(player, string.Format(msg("groupremoved", player.UserIDString), data.target1_Id));
                selectData.Remove(player.userID);
                CreateMenuGroups(player, GroupSub.View);
                return;
            }
           
            OpenSelectionMenu(player, SelectType.String, GetGroups(), true);
        }

        [ConsoleCommand("amui.togglepermission")]
        private void ccmdTogglePermission(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            if (!HasPermission(player.UserIDString, "adminmenu.permissions")) return;

            switch (arg.Args[0])
            {
                case "player":
                    {
                        string userId = arg.GetString(1);
                        string userName = arg.GetString(2).Replace("_-!!-_", " ");
                        if (arg.GetBool(5))
                            GrantPermission(userId, arg.GetString(4));
                        else RevokePermission(userId, arg.GetString(4));
                        OpenPermissionMenu(player, userId, userName, string.Format(msg("togglepermplayer", player.UserIDString), userName), arg.GetInt(3), arg.Args.Length > 6 ? arg.GetString(6) : "");
                    }
                    break;
                case "group":
                    string groupId = arg.GetString(1).Replace("_-!!-_", " ");
                    if (arg.GetBool(4))
                        GrantPermission(groupId, arg.GetString(3), true);
                    else RevokePermission(groupId, arg.GetString(3), true);
                    OpenPermissionMenu(player, groupId, string.Empty, string.Format(msg("togglepermgroup", player.UserIDString), groupId), arg.GetInt(2), arg.Args.Length > 5 ? arg.GetString(5) : "");
                    break;
                default:
                    break;
            }

        }

        [ConsoleCommand("amui.togglegroup")]
        private void ccmdToggleGroup(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            if (!HasPermission(player.UserIDString, "adminmenu.groups")) return;

            string userId = arg.GetString(0);
            string userName = arg.GetString(1).Replace("_-!!-_", " ");
            if (arg.GetBool(4))
                AddToGroup(userId, arg.GetString(3).Replace("_-!!-_", " "));
            else RemoveFromGroup(userId, arg.GetString(3).Replace("_-!!-_", " "));
            OpenGroupMenu(player, userId, userName, string.Format(msg("togglegroupplayer", player.UserIDString), userName), arg.GetInt(2));               
        }

        [ConsoleCommand("amui.makeselection")]
        private void ccmdMakeSelection(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            if (!HasPermission(player.UserIDString, "adminmenu.use")) return;

            SelectionData data = selectData[player.userID];

            switch (arg.Args[0])
            {
                case "target":
                    if (string.IsNullOrEmpty(data.target1_Id))
                    {
                        data.target1_Id = arg.Args[1].Replace("_-!!-_", " ");                        
                        data.target1_Name = arg.Args.Length == 3 ? arg.Args[2].Replace("_-!!-_", " ") : string.Empty;
                    }
                    else
                    {
                        data.target2_Id = arg.Args[1].Replace("_-!!-_", " ");                        
                        data.target2_Name = arg.Args.Length == 3 ? arg.Args[2].Replace("_-!!-_", " ") : string.Empty;
                    }
                    break;
                case "pageUp":
                    ++data.pageNum;
                    break;
                case "pageDown":
                    --data.pageNum;
                    break;
                case "online":
                    data.isOnline = true;
                    break;
                case "offline":
                    data.isOnline = false;
                    break;                
            }

            if (data.returnCommand.StartsWith("amui.giveitem"))
                rust.RunClientCommand(player, $"{data.returnCommand} {data.target1_Id}");            
            else
            {
                switch (data.returnCommand)
                {
                    case "amui.runcommand":
                        rust.RunClientCommand(player, "amui.runcommand", data.subType, data.listNum);
                        break;
                    case "amui.selectforpermission":
                        rust.RunClientCommand(player, "amui.selectforpermission", data.isGroup);
                        break;
                    case "amui.selectremovegroup":
                        rust.RunClientCommand(player, "amui.selectremovegroup");
                        break;
                    case "amui.selectforgroup":
                        rust.RunClientCommand(player, "amui.selectforgroup");
                        break;
                    default:
                        break;
                }
            }
        }

        [ConsoleCommand("amui.switchelement")]
        private void ccmdUISwitch(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            if (!HasPermission(player.UserIDString, "adminmenu.use")) return;

            if (selectData.ContainsKey(player.userID))
                selectData.Remove(player.userID);

            int page = 0;
            if (arg.Args.Length > 2)
                page = arg.GetInt(2);

            switch (arg.Args[0])
            {
                case "permissions":
                    PermSub permSub = PermSub.View;                    
                    if (arg.Args.Length > 1)
                        permSub = ParseType<PermSub>(arg.Args[1]);

                    switch (permSub)
                    {
                        case PermSub.View:
                            CreateMenuPermissions(player, page, arg.Args.Length > 3 ? arg.GetString(3) : "");
                            return;
                        case PermSub.Player:
                            if (arg.Args.Length >= 5)
                                OpenPermissionMenu(player, arg.GetString(3), arg.GetString(4).Replace("_-!!-_", " "), string.Format(msg("togglepermplayer", player.UserIDString), arg.GetString(4).Replace("_-!!-_", " ")), arg.GetInt(2), arg.Args.Length > 5 ? arg.GetString(5) : "");
                            else rust.RunClientCommand(player, "amui.selectforpermission", false);
                            return;
                        case PermSub.Group:
                            if (arg.Args.Length >= 4)
                                OpenPermissionMenu(player, arg.GetString(3).Replace("_-!!-_", " "), string.Empty, string.Format(msg("togglepermgroup", player.UserIDString), arg.GetString(3).Replace("_-!!-_", " ")), arg.GetInt(2), arg.Args.Length > 4 ? arg.GetString(4) : "");
                            else rust.RunClientCommand(player, "amui.selectforpermission", true);
                            return;                       
                    }
                    return;
                case "groups":
                    GroupSub groupSub = GroupSub.View;
                    if (arg.Args.Length > 1)
                        groupSub = ParseType<GroupSub>(arg.Args[1]);

                    switch (groupSub)
                    {
                        case GroupSub.View:
                            break;
                        case GroupSub.UserGroups:
                            if (arg.Args.Length == 5)
                                OpenGroupMenu(player, arg.GetString(3), arg.GetString(4).Replace("_-!!-_", " "), string.Format(msg("togglegroupplayer", player.UserIDString), arg.GetString(4).Replace("_-!!-_", " ")), arg.GetInt(2));
                            else rust.RunClientCommand(player, "amui.selectforgroup");
                            return;
                        case GroupSub.AddGroup:
                            break;
                        case GroupSub.RemoveGroup:
                            rust.RunClientCommand(player, "amui.selectremovegroup");
                            return;                        
                    }
                    CreateMenuGroups(player, groupSub, page);
                    return;
                case "commands":
                    CommSub commSub = CommSub.Chat;
                    if (arg.Args.Length > 1)
                        commSub = ParseType<CommSub>(arg.Args[1]);

                    CreateMenuCommands(player, commSub, page);
                    return;
                case "give":
                    ItemType itemType = ItemType.Weapon;
                    if (arg.Args.Length > 1)
                        itemType = ParseType<ItemType>(arg.Args[1]);

                    CreateMenuCommands(player, CommSub.Give, page, itemType);
                    return;          
                case "exit":
                    DestroyUI(player);
                    return;              
            }
        }

        [ConsoleCommand("amui.giveitem")]
        private void ccmdGiveItem(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            if (!HasPermission(player.UserIDString, "adminmenu.use")) return;

            string itemName = arg.GetString(0);
            string itemShortName = arg.GetString(1);
            int amount = arg.GetInt(2);

            if (arg.Args.Length <= 3)
            {
                SelectionData data;
                if (!selectData.TryGetValue(player.userID, out data))
                {
                    selectData.Add(player.userID, new SelectionData
                    {
                        listNum = arg.GetInt(1),
                        menuType = MenuType.Commands,
                        pageNum = 0,
                        requireTarget1 = true,
                        returnCommand = $"amui.giveitem {itemName} {itemShortName} {amount}",
                        isGroup = false,
                        selectDesc = string.Format(msg("giveitem", player.UserIDString), amount, itemName.Replace("<><>", " ")),
                        subType = "give",
                        isOnline = true,
                        forceOnline = true
                    });
                    data = selectData[player.userID];
                }

                OpenSelectionMenu(player, SelectType.Player, covalence.Players.Connected.ToList(), true);
            }
            else
            {
                string targetId = arg.GetString(3);

                BasePlayer targetPlayer = BasePlayer.FindByID(ulong.Parse(targetId));
                if (targetPlayer != null && targetPlayer.IsConnected)
                {
                    Item item = ItemManager.CreateByName(itemShortName, amount, 0);
                    targetPlayer.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
                    PopupMessage(player, string.Format(msg("gaveitem", player.UserIDString), amount, itemName.Replace("<><>", " "), targetPlayer.displayName));
                }
                else PopupMessage(player, msg("noplayer", player.UserIDString));

                selectData.Remove(player.userID);
                CreateMenuCommands(player, CommSub.Give);
            }
        }

        #endregion

        #region Helpers
        private void SetUIColors()
        {            
            uiColors.Add("bg1", UI.Color(configData.Colors.Panel1.Color, configData.Colors.Panel1.Alpha));
            uiColors.Add("bg2", UI.Color(configData.Colors.Panel2.Color, configData.Colors.Panel2.Alpha));
            uiColors.Add("bg3", UI.Color(configData.Colors.Panel3.Color, configData.Colors.Panel3.Alpha));
            uiColors.Add("button1", UI.Color(configData.Colors.Button1.Color, configData.Colors.Button1.Alpha));
            uiColors.Add("button2", UI.Color(configData.Colors.Button2.Color, configData.Colors.Button2.Alpha));
            uiColors.Add("button3", UI.Color(configData.Colors.Button3.Color, configData.Colors.Button3.Alpha));
        }        

        private List<string> GetGroups() => permission.GetGroups().ToList();

        private bool CreateGroup(string name, string title, int rank) => permission.CreateGroup(name, title, rank);  
        
        private void RemoveGroup(string name) => permission.RemoveGroup(name);

        private void AddToGroup(string userId, string groupId) => permission.AddUserGroup(userId, groupId);

        private void RemoveFromGroup(string userId, string groupId) => permission.RemoveUserGroup(userId, groupId);

        private bool HasGroup(string userId, string groupId) => permission.UserHasGroup(userId, groupId);

        private List<string> GetPermissions()
        {
            List<string> permissions = permission.GetPermissions().ToList();
            permissions.RemoveAll(x => x.ToLower().StartsWith("oxide."));
            return permissions;
        }

        private void GrantPermission(string groupOrID, string perm, bool isGroup = false)
        {
            if (isGroup)
                permission.GrantGroupPermission(groupOrID, perm, null);
            else permission.GrantUserPermission(groupOrID, perm, null);
        }

        private void RevokePermission(string groupOrID, string perm, bool isGroup = false)
        {
            if (isGroup)
                permission.RevokeGroupPermission(groupOrID, perm);
            else permission.RevokeUserPermission(groupOrID, perm);
        }

        private bool HasPermission(string groupOrID, string perm, bool isGroup = false)
        {
            if (isGroup)
                return permission.GroupHasPermission(groupOrID, perm);
            return permission.UserHasPermission(groupOrID, perm);
        }        

        private void DestroyUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, UIElement);
            CuiHelper.DestroyUi(player, UIMain);
            CuiHelper.DestroyUi(player, UIPopup);
        }
        private T ParseType<T>(string type) => (T)Enum.Parse(typeof(T), type, true);

        private bool IsDivisable(int number) => number % 2 == 0;

        private void UpdatePermissionList()
        {
            permissionList.Clear();
            List<string> permissions = GetPermissions();
            permissions.Sort();

            string lastName = string.Empty;
            foreach(string perm in permissions)
            {
                string name = string.Empty;
                if (perm.Contains("."))
                {
                    string permStart = perm.Substring(0, perm.IndexOf("."));
                    name = plugins.PluginManager.GetPlugins().ToList().Find(x => x?.Name?.ToLower() == permStart)?.Title ?? permStart;
                }
                else name = perm;
                if (lastName != name)
                {
                    permissionList.Add(new KeyValuePair<string, bool>(name, false));
                    lastName = name;
                }

                permissionList.Add(new KeyValuePair<string, bool>(perm, true));
            }

        }
        #endregion

        #region Commands
        [ChatCommand("admin")]
        private void cmdAdmin(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player.UserIDString, "adminmenu.use")) return;
            OpenAdminMenu(player);
        }
        #endregion

        #region Config        
        private ConfigData configData;
        private class Colors
        {          
            [JsonProperty(PropertyName = "Panel - Dark")]
            public UIColor Panel1 { get; set; }
            [JsonProperty(PropertyName = "Panel - Medium")]
            public UIColor Panel2 { get; set; }
            [JsonProperty(PropertyName = "Panel - Light")]
            public UIColor Panel3 { get; set; }
            [JsonProperty(PropertyName = "Button - Primary")]
            public UIColor Button1 { get; set; }
            [JsonProperty(PropertyName = "Button - Secondary")]
            public UIColor Button2 { get; set; }
            [JsonProperty(PropertyName = "Button - Selected")]
            public UIColor Button3 { get; set; }
                        
            public class UIColor
            {
                public string Color { get; set; }
                public float Alpha { get; set; }
            }
        }

        private class CommandEntry
        {
            public string Name { get; set; }
            public string Command { get; set; }
            public string Description { get; set; }
        }

        private class ConfigData
        {
            public Colors Colors { get; set; }
            [JsonProperty(PropertyName = "Chat Command List")]
            public List<CommandEntry> ChatCommands { get; set; }
            [JsonProperty(PropertyName = "Console Command List")]
            public List<CommandEntry> ConsoleCommands { get; set; }
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                Colors = new Colors
                {
                    Panel1 = new Colors.UIColor { Color = "#2a2a2a", Alpha = 0.98f },
                    Panel2 = new Colors.UIColor { Color = "#373737", Alpha = 0.98f },
                    Panel3 = new Colors.UIColor { Color = "#696969", Alpha = 0.3f },
                    Button1 = new Colors.UIColor { Color = "#2a2a2a", Alpha = 0.9f },
                    Button2 = new Colors.UIColor { Color = "#a8a8a8", Alpha = 0.9f },
                    Button3 = new Colors.UIColor { Color = "#00cd00", Alpha = 0.9f }
                },
                ChatCommands = new List<CommandEntry>
                {
                    new CommandEntry
                    {
                        Name = "TP to 0 0 0",
                        Command = "/tp 0 0 0",
                        Description = "Teleport self to 0 0 0"
                    },
                    new CommandEntry
                    {
                        Name = "TP to player",
                        Command = "/tp {target1_name}",
                        Description = "Teleport self to player"
                    },
                    new CommandEntry
                    {
                        Name = "TP P2P",
                        Command = "/tp {target1_name} {target2_name}",
                        Description = "Teleport player to player"
                    },
                    new CommandEntry
                    {
                        Name = "God",
                        Command = "/god",
                        Description = "Toggle god mode"
                    } 
                },
                ConsoleCommands = new List<CommandEntry>
                {
                    new CommandEntry
                    {
                        Name = "Set time to 9",
                        Command = "env.time 9",
                        Description = "Set the time to 9am"
                    },
                    new CommandEntry
                    {
                        Name = "Set to to 22",
                        Command = "env.time 22",
                        Description = "Set the time to 10pm"
                    },
                    new CommandEntry
                    {
                        Name = "TP P2P",
                        Command = "teleport.topos {target1_name} {target2_name}",
                        Description = "Teleport player to player"
                    },
                    new CommandEntry
                    {
                        Name = "Call random strike",
                        Command = "airstrike strike random",
                        Description = "Call a random Airstrike"
                    }
                }
            };
            SaveConfig(config);
        }

        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();

        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Data Management
        private void SaveData() => data.WriteObject(storedData);

        private void LoadData()
        {
            try
            {
                storedData = data.ReadObject<StoredData>();
            }
            catch
            {
                storedData = new StoredData();
            }
        }

        private class StoredData
        {
            public Hash<string, double> offlinePlayers = new Hash<string, double>();

            public void AddOfflinePlayer(string userId) => offlinePlayers[userId] = CurrentTime();

            public void OnPlayerInit(string userId)
            {
                if (offlinePlayers.ContainsKey(userId))
                    offlinePlayers.Remove(userId);                
            }

            public void RemoveOldPlayers()
            {
                double currentTime = CurrentTime();

                for (int i = offlinePlayers.Count - 1; i >= 0; i--)
                {
                    var user = offlinePlayers.ElementAt(i);
                    if (currentTime - user.Value > 604800)
                        offlinePlayers.Remove(user);
                }
            }

            public List<IPlayer> GetOfflineList() => ins.covalence.Players.All.Where(x => offlinePlayers.ContainsKey(x.Id)).ToList();

            public double CurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;            
        }
        #endregion

        #region Localization
        private string msg(string key, string playerId = null) => lang.GetMessage(key, this, playerId);

        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["title"] = "<color=#ce422b>Admin Menu  v{0}</color>",
            ["exit"] = "Exit",
            ["view"] = "View",
            ["player"] = "Player Permissions",
            ["group"] = "Group Permissions",
            ["usergroups"] = "User Groups",
            ["addgroup"] = "Create Group",
            ["removegroup"] = "Remove Group",
            ["chat"] = "Chat Commands",
            ["console"] = "Console Commands",
            ["command"] = "Command",
            ["description"] = "Description",
            ["use"] = "Use",
            ["back"] = "Back",
            ["next"] = "Next",
            ["return"] = "Return",
            ["selectplayer"] = "Select a player",
            ["togglepermplayer"] = "Toggle permissions for player : {0}",
            ["togglepermgroup"] = "Toggle permissions for group : {0}",
            ["togglegroupplayer"] = "Toggle groups for player : {0}",
            ["giveitem"] = "Select a player to give : {0} x {1}",
            ["selectgroup"] = "Select a group",
            ["selectremovegroup"] = "Select a group to remove. <color=#ce422b>WARNING! This can not be undone</color>",
            ["selecttarget"] = "Select a target",
            ["onlineplayers"] = "Online Players",
            ["offlineplayers"] = "Offline Players",
            ["inputhelper"] = "To create a new group type a group name, title, and rank. Press Enter after completing each field. Once you are ready hit the 'Create' button",
            ["create"] = "Create",
            ["groupname"] = "Name:",
            ["grouptitle"] = "Title (optional):",
            ["grouprank"] = "Rank (optional):",
            ["reset"] = "Reset",
            ["nogroupname"] = "You must set a group name",
            ["groupcreated"] = "You have successfully created the group: {0}",
            ["commandrun"] = "You have run the command : {0}",
            ["groupremoved"] = "You have removed the group : {0}",
            ["uiwarning"] = "** Note ** Close any other UI plugins you have running that automatically refresh (LustyMap or InfoPanel for example). Having these open will cause your input boxes to continually refresh!",
            ["give"] = "Give Items",
            ["Weapon"] = "Weapon",
            ["Construction"] = "Construction",
            ["Items"] = "Items",
            ["Resources"] = "Resources",
            ["Attire"] = "Attire",
            ["Tool"] = "Tool",
            ["Medical"] = "Medical",
            ["Food"] = "Food",
            ["Ammunition"] = "Ammunition",
            ["Traps"] = "Traps",
            ["Misc"] = "Misc",
            ["Component"] = "Component",
            ["noplayer"] = "Unable to find the specified player",
            ["gaveitem"] = "You gave {0}x {1} to {2}"
        };
        #endregion
    }
}


// --- End of file: AdminMenu.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AntiWounded.cs ---
// --- Original Local Path: AntiWounded.cs ---

namespace Oxide.Plugins
{
    [Info("Anti-Wounded", "SkinN", "2.0.0", ResourceId = 1045)]
    class AntiWounded : RustPlugin
    {
        private bool CanBeWounded(BasePlayer player, HitInfo info)
        {
            return false;
        }
    }
}

// --- End of file: AntiWounded.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PermanentBPs.cs ---
// --- Original Local Path: PermanentBPs.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Permanent Blueprints", "Skipcast", "1.0.1")]
    [Description("Saves blueprints between BP wipes.")]
    public class PermanentBPs : RustPlugin
    {
        const string PermissionName = "permanentbps.blacklistblueprint";

        static class Translations
        {
            public class Translation
            {
                public static Plugin plugin;
                public static Lang lang;

                public readonly string Key;
                public readonly string DefaultValue;

                public Translation(string key, string defaultValue)
                {
                    Key = key;
                    DefaultValue = defaultValue;
                }

                /// <summary>Returns the translated string.</summary>
                public string Get(BasePlayer player)
                {
                    return lang.GetMessage(Key, plugin, player?.UserIDString);
                }
            }

            public static readonly Translation NoItemWithName = new Translation("NoItemWithName", "There is no item with this name.");
            public static readonly Translation ItemAlreadyBlacklisted = new Translation("ItemAlreadyBlacklisted", "This item is already blacklisted.");
            public static readonly Translation ItemNotBlacklisted = new Translation("ItemNotBlacklisted", "This item is not blacklisted.");
            public static readonly Translation AddedToBlacklist = new Translation("AddedToBlacklist", "Added {item} to the blacklist.");
            public static readonly Translation RemovedFromBlacklist = new Translation("RemovedFromBlacklist", "Removed {item} from the blacklist.");
            public static readonly Translation NoPermission = new Translation("NoPermission", "You don't have permission to use this command.");
            public static readonly Translation BlueprintsLearnedNotice = new Translation("BlueprintsLearnedNotice", "Blueprints were recently wiped. Luckily we saved them and restored {numBlueprints} blueprints!");
            public static readonly Translation BlacklistedBlueprintsNotice = new Translation("BlacklistedBlueprintsNotice", "The following blueprints were not restored because they are blacklisted:");
        }

        class PlayerData
        {
            public List<string> Blueprints = new List<string>();
        }

        class StoredData
        {
            public Dictionary<ulong, PlayerData> PlayerData = new Dictionary<ulong, PlayerData>();
        }

        class PluginConfig
        {
            public List<string> BlacklistedBlueprints = new List<string>();
        }

        private StoredData data;
        private List<string> blacklistedBlueprints;
        
        void Init()
        {
            Translations.Translation.lang = lang;
            Translations.Translation.plugin = this;
        }

        protected override void LoadDefaultConfig()
        {
            Debug.LogWarning("Creating default configuration for Permanent Blueprints.");

            Config.Clear();
            Config["BlacklistedBlueprints"] = new List<string>();
            SaveConfig();
        }

        void LoadDefaultMessages()
        {
            Dictionary<string, string> messages = new Dictionary<string, string>();

            foreach (FieldInfo info in typeof (Translations).GetFields(BindingFlags.Public | BindingFlags.Static))
            {
                if (info.FieldType != typeof (Translations.Translation))
                    continue;

                Translations.Translation translation = (Translations.Translation) info.GetValue(null);
                messages.Add(translation.Key, translation.DefaultValue);
            }
            
            lang.RegisterMessages(messages, this);
        }

        void Loaded()
        {
            data = Interface.Oxide.DataFileSystem.ReadObject<StoredData>("PermanentBPs") ?? new StoredData();
            blacklistedBlueprints = ((List<object>)Config["BlacklistedBlueprints"]).Cast<string>().ToList();
            Config["BlacklistedBlueprints"] = blacklistedBlueprints;

            LoadDefaultMessages();

            if (blacklistedBlueprints == null)
            {
                Debug.LogWarning("Blacklisted blueprints config value was null.");
                blacklistedBlueprints = new List<string>();
                SaveConfig();
            }
        }

        void OnServerInitialized()
        {
            permission.RegisterPermission(PermissionName, this);
            SaveBPs();
        }

        void OnServerSave()
        {
            SaveBPs();
        }

        private void SaveBPs()
        {
            foreach (var player in BasePlayer.activePlayerList.Concat(BasePlayer.sleepingPlayerList).ToList())
            {
                PlayerData playerData;

                if (!data.PlayerData.ContainsKey(player.userID))
                    data.PlayerData[player.userID] = new PlayerData();

                playerData = data.PlayerData[player.userID];

                var persistantPlayer = ServerMgr.Instance.persistance.GetPlayerInfo(player.userID);

                foreach (var itemId in persistantPlayer.blueprints.complete)
                {
                    var item = ItemManager.FindItemDefinition(itemId);

                    if (!playerData.Blueprints.Contains(item.shortname))
                        playerData.Blueprints.Add(item.shortname);
                }
            }

            Interface.Oxide.DataFileSystem.WriteObject("PermanentBPs", data);
        }

        void OnPlayerInit(BasePlayer player)
        {
            RelearnBlueprints(player);
        }

        [ChatCommand("blacklistbp")]
        void ChatCmd_BlacklistBlueprint(BasePlayer player, string command, string[] args)
        {
            if (permission.UserHasPermission(player.UserIDString, PermissionName))
            {
                var itemDef = GetItemDefinitionFromDisplayName(args);

                if (itemDef == null)
                {
                    player.ChatMessage(Translations.NoItemWithName.Get(player));
                    return;
                }

                if (blacklistedBlueprints.Contains(itemDef.shortname))
                {
                    player.ChatMessage(Translations.ItemAlreadyBlacklisted.Get(player));
                    return;
                }

                blacklistedBlueprints.Add(itemDef.shortname);
                SaveConfig();
                player.ChatMessage(Translations.AddedToBlacklist.Get(player).Replace("{item}", itemDef.displayName.english));
            }
            else
            {
                player.ChatMessage(Translations.NoPermission.Get(player));
            }
        }

        [ChatCommand("whitelistbp")]
        void ChatCmd_WhitelistBlueprint(BasePlayer player, string command, string[] args)
        {
            if (permission.UserHasPermission(player.UserIDString, PermissionName))
            {
                var itemDef = GetItemDefinitionFromDisplayName(args);

                if (itemDef == null)
                {
                    player.ChatMessage(Translations.NoItemWithName.Get(player));
                    return;
                }

                if (!blacklistedBlueprints.Contains(itemDef.shortname))
                {
                    player.ChatMessage(Translations.ItemNotBlacklisted.Get(player));
                    return;
                }

                blacklistedBlueprints.Remove(itemDef.shortname);
                SaveConfig();
                player.ChatMessage(Translations.RemovedFromBlacklist.Get(player).Replace("{item}", itemDef.displayName.english));
            }
            else
            {
                player.ChatMessage(Translations.NoPermission.Get(player));
            }
        }
        
        private static ItemDefinition GetItemDefinitionFromDisplayName(string[] args)
        {
            string itemName = string.Join(" ", args);

            var itemDef = ItemManager.itemList.FirstOrDefault(item => item.displayName.english.ToLower() == itemName.ToLower());
            return itemDef;
        }

        private void RelearnBlueprints(BasePlayer player)
        {
            uint relearnedBlueprintCount = 0;
            List<ItemDefinition> blacklistedBps = new List<ItemDefinition>();

            if (data.PlayerData.ContainsKey(player.userID))
            {
                var playerData = data.PlayerData[player.userID];

                foreach (var shortname in playerData.Blueprints)
                {
                    var itemDef = ItemManager.FindItemDefinition(shortname);

                    if (itemDef == null)
                    {
                        Debug.LogError("No item found with the shortname \"" + shortname + "\".");
                        continue;
                    }

                    if (!player.blueprints.AlreadyKnows(itemDef))
                    {
                        ItemBlueprint blueprint = itemDef.GetComponent<ItemBlueprint>();
                        
                        if (blueprint != null && blueprint.userCraftable && blueprint.rarity != Rarity.None)
                        {
                            if (!blacklistedBlueprints.Contains(itemDef.shortname))
                            {
                                player.blueprints.Learn(itemDef);
                                ++relearnedBlueprintCount;
                            }
                            else
                            {
                                blacklistedBps.Add(itemDef);
                            }
                        }
                    }
                }
            }

            if (relearnedBlueprintCount > 0)
            {
                player.ChatMessage(Translations.BlueprintsLearnedNotice.Get(player).Replace("{numBlueprints}", relearnedBlueprintCount.ToString())
                                    + (blacklistedBps.Count > 0
                                                            ? ("\n\n" + Translations.BlacklistedBlueprintsNotice.Get(player) + "\n- " + String.Join("\n- ", blacklistedBps.Select(itemDef => itemDef.displayName.english).ToArray()))
                                                            : ""));
            }
        }
    }
}


// --- End of file: PermanentBPs.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/DeadPlayersList.cs ---
// --- Original Local Path: DeadPlayersList.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Dead Players List", "Mughisi", "2.0.5", ResourceId = 696)]
    class DeadPlayersList : RustPlugin
    {

        class LocationInfo
        {
            public string x;
            public string y;
            public string z;
            Vector3 position;

            public LocationInfo(Vector3 position)
            {
                x = position.x.ToString();
                y = position.y.ToString();
                z = position.z.ToString();
                this.position = position;
            }

            public Vector3 GetPosition()
            {
                if (position == Vector3.zero)
                    position = new Vector3(float.Parse(x), float.Parse(y), float.Parse(z));
                return position;
            }
        }

        class DeadPlayerInfo
        {
            public string UserId;
            public string Name;
            public string Reason;
            public LocationInfo Position;

            public DeadPlayerInfo()
            {
            }

            public DeadPlayerInfo(BasePlayer victim, HitInfo info)
            {
                UserId = victim.userID.ToString();
                Name = victim.displayName;
                Reason = victim.lastDamage.ToString();
                if (info != null)
                {
                    var attacker = info.Initiator as BasePlayer;
                    if (info.Initiator)
                    {
                        Reason = info.Initiator.LookupPrefabName();
                        if (attacker && attacker != victim) Reason = attacker.displayName;
                    }
                }
                Position = new LocationInfo(victim.transform.position);
            }

            public ulong GetUserId()
            {
                ulong user_id;
                if (!ulong.TryParse(UserId, out user_id)) return 0;
                return user_id;
            }
        }

        class StoredData
        {
            public HashSet<DeadPlayerInfo> DeadPlayers = new HashSet<DeadPlayerInfo>();

            public StoredData()
            {
            }
        }

        StoredData storedData;

        Hash<ulong, DeadPlayerInfo> deadPlayers = new Hash<ulong, DeadPlayerInfo>();

        bool dataChanged;

        void Loaded() => LoadData();

        void Unloaded() => SaveData();

        void LoadData()
        {
            deadPlayers.Clear();
            try
            {
                storedData = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("DeadPlayersList");
            }
            catch
            {
                storedData = new StoredData();
            }
            foreach (var dead_player in storedData.DeadPlayers)
                deadPlayers[dead_player.GetUserId()] = dead_player;
        }

        void SaveData() => Interface.GetMod().DataFileSystem.WriteObject("DeadPlayersList", storedData);

        void OnPlayerInit(BasePlayer player)
        {
            if (deadPlayers.Remove(player.userID) && storedData.DeadPlayers.RemoveWhere(info => info.GetUserId() == player.userID) > 0)
                dataChanged = true;
        }

        void OnPlayerRespawned(BasePlayer player)
        {
            if (deadPlayers.Remove(player.userID) && storedData.DeadPlayers.RemoveWhere(info => info.GetUserId() == player.userID) > 0)
                dataChanged = true;
        }

        void OnEntityDeath(BaseEntity entity, HitInfo info)
        {
            var player = entity as BasePlayer;
            if (!player) return;

            var dead_player = deadPlayers[player.userID];
            if (dead_player != null) storedData.DeadPlayers.Remove(dead_player);
            dead_player = new DeadPlayerInfo(player, info);
            deadPlayers[player.userID] = dead_player;
            storedData.DeadPlayers.Add(dead_player);

            dataChanged = true;
        }

        void OnServerSave()
        {
            if (!dataChanged) return;
            SaveData();
            dataChanged = false;
        }

        Dictionary<string, string> GetPlayerList()
        {
            Dictionary<string, string> deadPlayerList = new Dictionary<string, string>();
            foreach (var deadPlayer in deadPlayers)
                deadPlayerList.Add(deadPlayer.Key.ToString(), deadPlayer.Value.Name);

            return deadPlayerList;
        }

        string GetPlayerName(object userID) => deadPlayers[Convert.ToUInt64(userID)]?.Name;

        string GetPlayerDeathReason(object userID) => deadPlayers[Convert.ToUInt64(userID)]?.Reason;

        Vector3 GetPlayerDeathPosition(object userID) => deadPlayers[Convert.ToUInt64(userID)]?.Position.GetPosition() ?? Vector3.zero;
    }
}

// --- End of file: DeadPlayersList.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CustomTurret.cs ---
// --- Original Local Path: CustomTurret.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("CustomTurret", "BadMandarin", "1.0.0")]
    [Description("CustomTurret")]
    class CustomTurret : RustPlugin
    {
        #region Classes
        private class PluginConfig
        {
            [JsonProperty("Сколько берёт патронов за спрей")]
            public int TakeAmmo = 10;
            [JsonProperty("Дистанция наводки")]
            public float Distance = 100f;
            [JsonProperty("Здоровье турели (стандарт 1000)")]
            public float Health = 1000f;
            [JsonProperty("Прицеливание (стандарт 4 обычная турель) чем меньше тем лучше")]
            public float AimCone = 4f;
            [JsonProperty("Множитель урона (стандарт 1f)")]
            public float DamageScale = 1f;
            [JsonProperty("Ресурсы чтобы скрафтить")]
            public Dictionary<string, int> ResourcesToCraft;
        }
        #endregion

        #region Variables
        ulong skinid = 1587601905;
        int ammoid = -1211166256;
        string turretPrefab = "assets/content/props/sentry_scientists/sentry.scientist.static.prefab";
        
        private PluginConfig config;
        private static CustomTurret plugin;

        string permSet = "";
        string permCraft = "";

        [PluginReference]
        Plugin ImageLibrary;
        string sentryimage;

        private List<uint> customTurrets;
        #endregion

        #region Oxide
        private void Init()
        {
            config = Config.ReadObject<PluginConfig>();
        }

        private void OnServerInitialized()
        {
            PrintWarning("Start plugin. Author: BadMandarin.");
            CheckSentry();

            permSet = "customturret.set";
            if (!permission.PermissionExists(permSet))
                permission.RegisterPermission(permSet, this);
            permCraft = "customturret.craft";
            if (!permission.PermissionExists(permCraft))
                permission.RegisterPermission(permCraft, this);

            sentryimage  = "https://i.imgur.com/LVfBuXF.png";
            string name = GetNameByURL(sentryimage);
            if (!(bool)ImageLibrary?.Call("HasImage", name))
            {
                ImageLibrary?.Call("AddImage", sentryimage, name);
            }
        }

        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if(info.Initiator is NPCAutoTurret && entity.OwnerID != 0)
            {
                info.damageTypes.ScaleAll(config.DamageScale);
            }
            return null;
        }

        object OnHammerHit(BasePlayer player, HitInfo info)
        {
            NPCAutoTurret turret = info.HitEntity as NPCAutoTurret;
            if (turret != null)
            {
                if (!turret.IsOffline())
                {
                    turret.InitiateShutdown();
                }
                else
                {
                    turret.InitiateStartup();
                }
                if (turret.health < turret._maxHealth)
                    TurretRepair(player, turret);
            }
            return null;
        }

        private void TurretRepair(BasePlayer player, NPCAutoTurret turret)
        {
            int repairCost = (int)((turret._maxHealth - turret.health) * 0.1);
            if (repairCost == 0) return;
            Item itemRepair = ItemManager.CreateByName("metal.refined", repairCost);
            int itemamount = player.inventory.GetAmount(itemRepair.info.itemid);
            if (itemamount == 0)
            {
                SendReply(player, "Недостаточно ресурсов для починки!");
            }
            else if(itemamount < repairCost)
            {
                List<Item> itemList = player.inventory.containerMain.itemList.FindAll(x => x.info.shortname == itemRepair.info.shortname);
                player.inventory.Take(itemList, itemRepair.info.itemid, itemamount);
                turret.health += itemamount*10;
                turret.SendNetworkUpdate();
                SendReply(player, "Вы успешно починили турель!");
            }
            else
            {
                List<Item> itemList = player.inventory.containerMain.itemList.FindAll(x => x.info.shortname == itemRepair.info.shortname);
                player.inventory.Take(itemList, itemRepair.info.itemid, repairCost);
                turret.health = turret._maxHealth;
                turret.SendNetworkUpdate();
                SendReply(player, "Вы успешно починили турель!");
            }
        }

        void OnEntityBuilt(Planner planner, GameObject gameobject)
        {
            BaseEntity entity = gameobject.ToBaseEntity();
            BasePlayer player = planner.GetOwnerPlayer();
            if (player == null || entity == null) return;

            if (entity.skinID != skinid) return;

            entity.Kill();
            
            Vector3 ePos = entity.transform.position;

            BaseEntity Turret = GameManager.server.CreateEntity(turretPrefab, ePos, entity.transform.rotation, true);
            
            RaycastHit rHit;

            if (Physics.Raycast(new Vector3(ePos.x, ePos.y + 1, ePos.z), Vector3.down, out rHit, 2f, LayerMask.GetMask(new string[] { "Construction" })) && rHit.GetEntity() == null)
            {
                SendReply(player, "Турель может быть установлена только на фундамент!");
                GiveSentry(player);
                Turret.Kill();
                return;
            }
            
            if (!permission.UserHasPermission(player.UserIDString, permSet))
            {
                SendReply(player, "Вы не можете устанавливать продвинутую турель!");
                GiveSentry(player);
                Turret.Kill();
                return;
            }

            Turret.OwnerID = player.userID;
            Turret.Spawn();
            var t = Turret as NPCAutoTurret;
            t.InitiateShutdown();
            t.SetPeacekeepermode(false);
            t.aimCone = config.AimCone;
            t.sightRange = config.Distance;
            t.inventory.capacity = 6;
            Turret.gameObject.AddComponent<ExtendedSentryComponent>();
            SetupProtection(t);
            t.SendNetworkUpdate();
            t.SendNetworkUpdateImmediate();
        }

        private void SetupProtection(BaseCombatEntity turret)
        {
            float health = config.Health;
            turret._maxHealth = health;
            turret.health = health;

            turret.baseProtection = ScriptableObject.CreateInstance<ProtectionProperties>();
            turret.baseProtection.amounts = new float[]
            {
                1,1,1,1,1,0.8f,1,1,1,0.9f,0.5f,
                0.5f,1,1,0,0.5f,0,1,1,0,1,0.9f
            };
        }

        object OnTurretTarget(AutoTurret turret, BaseCombatEntity entity)
        {
            if(turret is NPCAutoTurret && turret.OwnerID != 0)
            {
                if (turret.inventory.HasAmmo(Rust.AmmoTypes.RIFLE_556MM))
                {
                    var con = turret.inventory.itemList;
                    Item itm = con.First();
                    //int amount = turret.inventory.GetAmount(ammoid, true);
                    if (itm.amount > config.TakeAmmo) itm.amount -= config.TakeAmmo;
                    else itm.RemoveFromContainer();
                    return null;
                }
                return false;
            }

            return null;
        }

        bool CanPickupEntity(BasePlayer player, BaseCombatEntity entity)
        {
            if(entity is NPCAutoTurret && entity.OwnerID != 0)
            {
                var tur = entity as NPCAutoTurret;
                entity.skinID = skinid;
            }
            return true;
        }

        void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            if(item.info.shortname.Contains("autoturret") && item.skin != 0)
            {
                item.condition = 100;
            }
        }

        object CanStackItem(Item item, Item targetItem)
        {
            if (item.info.shortname.Contains("autoturret"))
                if (item.skin != 0 || targetItem.skin != 0)
                    return false;
            
            return null;
        }

        object CanCombineDroppedItem(DroppedItem item, DroppedItem targetItem)
        {
            if (item.item.info.shortname.Contains("autoturret"))
                if (item.skinID != 0 || targetItem.skinID != 0)
                    return false;

            return null;
        }
        #endregion

        #region Interface
        string UI_Layer = "UI_SentryCraft";
        private void DrawUi(BasePlayer player)
        {
            string name = GetNameByURL(sentryimage);
            string ID = (string)ImageLibrary?.Call("GetImage", name);
            if (ID == "")
                ID = (string)ImageLibrary?.Call("GetImage", name) ?? ID;
            CuiElementContainer container = new CuiElementContainer
            {
                {
                    new CuiPanel
                    {
                        CursorEnabled = true,
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" },

                        Image = { Color = GetColor("#000000", 0.95f) }
                    },
                    "Overlay", UI_Layer
                },
                {
                    new CuiElement
                    {
                        Parent = UI_Layer,
                        Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"ПРОДВИНУТАЯ ТУРЕЛЬ",
                                Align = TextAnchor.MiddleCenter,
                                FontSize = 26,
                                Font = "robotocondensed-bold.ttf",
                                Color = GetColor("#FFFFFF", 1f)
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = $"0 0.6",
                                AnchorMax = $"1 1"
                            },
                            new CuiOutlineComponent { Distance = "0.1 -0.1", Color = GetColor("#000000")}
                        }
                    }
                },
                {
                    new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "14330 14330" },
                        Button = { Color = "0 0 0 0", Close = UI_Layer },
                        Text = { Text = "" }
                    }, UI_Layer
                },
                {
                    new CuiElement
                    {
                        Parent = UI_Layer,
                        Components =
                        {
                            new CuiRawImageComponent
                            {
                                Png = ID
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.5 0.5",
                                AnchorMax = $"0.5 0.5",
                                OffsetMin = "-100 -100",
                                OffsetMax = "100 200"
                            },
                        }
                    }
                },
                new CuiElement
                {
                    Parent = $"{UI_Layer}",
                    Name = $"{UI_Layer}.Craft",
                    Components =
                    {
                        new CuiImageComponent {
                            Color = GetColor("#6E6E6E"), Material = "assets/content/ui/uibackgroundblur.mat"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.15",
                            AnchorMax = "0.5 0.15",
                            OffsetMin = "-100 -25",
                            OffsetMax = "100 25"
                        }
                    }
                },
                {
                    new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                        Button = { Color = "0 0 0 0", Command = $"sentry.craft" },
                        Text = { Text = "СКРАФТИТЬ", Align = TextAnchor.MiddleCenter, FontSize = 26 }
                    }, $"{UI_Layer}.Craft"
                },
            };

            int counter = 0;
            float max = config.ResourcesToCraft.Count;
            foreach (var item in config.ResourcesToCraft)
            {
                ItemDefinition def = ItemManager.FindItemDefinition(item.Key);
                bool hasItem = player.inventory.GetAmount(def.itemid) > item.Value ? true : false;
                container.Add(new CuiElement
                {
                    Parent = UI_Layer,
                    Name = $"{UI_Layer}.ItemNeed.{counter}",
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = GetColor(hasItem ? "#81F781" : "#FA5858", 0.6f)
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = $"{0.5 - max*0.01} 0.3",
                            AnchorMax = $"{0.5 - max*0.01} 0.3",
                            OffsetMin = $"{-25 + counter*55} -25",
                            OffsetMax = $"{25 + counter*55} 25"
                        },
                    }
                });
                ID = (string)ImageLibrary?.Call("GetImage", item.Key);
                if (ID == "")
                    ID = (string)ImageLibrary?.Call("GetImage", item.Key) ?? ID;
                container.Add(new CuiElement
                {
                    Parent = $"{UI_Layer}.ItemNeed.{counter}",
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Png = ID
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = $"0 0",
                            AnchorMax = $"1 1"
                        },
                    }
                });
                container.Add(new CuiElement
                {
                    Parent = $"{UI_Layer}.ItemNeed.{counter}",
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = $"x{item.Value}", Align = TextAnchor.LowerCenter, FontSize = 12
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = $"0 0",
                            AnchorMax = $"1 1"
                        },
                    }
                });
                counter++;
            }



            CuiHelper.DestroyUi(player, UI_Layer);
            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region Commands
        [ChatCommand("sentry")]
        void Chat_ShowTop(BasePlayer player, string command, string[] args)
        {
            if (permission.UserHasPermission(player.UserIDString, permCraft))
                DrawUi(player);
            else SendReply(player, "В доступе отказано!");
        }

        [ConsoleCommand("sentry.craft")]
        private void SentryCraft(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            CuiHelper.DestroyUi(player, UI_Layer);
            var n = player.inventory.containerMain.itemList;
            foreach (var r in config.ResourcesToCraft)
            {
                var def = ItemManager.FindItemDefinition(r.Key);
                if (player.inventory.GetAmount(def.itemid) < r.Value)
                {
                    SendReply(player, "Недостаточно ресурсов");
                    return;
                }
            }

            foreach (var r in config.ResourcesToCraft)
            {
                var g = n.FindAll(x => x.info.shortname == r.Key);
                player.inventory.containerMain.Take(g, g[0].info.itemid, r.Value);
            }

            GiveSentry(player);
            SendReply(player, "Вы успешно скрафтили продвинутую турель!");
        }

        [ConsoleCommand("sentry.add")]
        private void AddSentry(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin)
            {
                SendError(arg, "[Ошибка] У вас нет доступа к этой команде!");
                return;
            }

            if (!arg.HasArgs())
            {
                PrintError(":\n[Ошибка] Введите sentry.add steamid/nickname\n[Пример] sentry.add Имя\n[Пример] sentry.add 76561198311240000");
                return;
            }

            BasePlayer player = BasePlayer.Find(arg.Args[0]);
            if (player == null)
            {
                PrintError($"[Ошибка] Не удается найти игрока {arg.Args[0]}");
                return;
            }

            GiveSentry(player);
        }
        #endregion

        #region Utils
        private string GetNameByURL(string url)
        {
            var splitted = url.Split('/');
            var endUrl = splitted[splitted.Length - 1];
            var name = endUrl.Split('.')[0];
            return name;
        }

        private static string GetColor(string hex, float alpha = 1f)
        {
            var color = ColorTranslator.FromHtml(hex);
            var r = Convert.ToInt16(color.R) / 255f;
            var g = Convert.ToInt16(color.G) / 255f;
            var b = Convert.ToInt16(color.B) / 255f;
            //var a = Convert.ToInt16(color.A) / 4330f;
            return $"{r} {g} {b} {alpha}";
        }

        private void GiveSentry(BasePlayer player)
        {
            Item s = ItemManager.CreateByName("autoturret", 1, skinid);
            s.MoveToContainer(player.inventory.containerMain);
        }

        private void GiveSentry(Vector3 position)
        {
            Item s = ItemManager.CreateByName("autoturret", 1, skinid);
            s.Drop(position, Vector3.down);
        }

        private void CheckSentry()
        {
            foreach (var sentry in UnityEngine.Object.FindObjectsOfType<NPCAutoTurret>())
            {
                if (sentry.OwnerID != 0 && sentry.GetComponent<ExtendedSentryComponent>() == null)
                {
                    sentry.gameObject.AddComponent<ExtendedSentryComponent>();
                    SetupProtection(sentry);
                    sentry.aimCone = config.AimCone;
                    sentry.sightRange = config.Distance;
                    sentry.inventory.capacity = 6;
                    sentry.SendNetworkUpdate();
                    sentry.SendNetworkUpdateImmediate();
                }
            }
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig()
            {
                ResourcesToCraft = new Dictionary<string, int>()
                {
                    ["wood"] = 100,
                    ["metal.refined"] = 50
                }
            };
        }

        private class ExtendedSentryComponent : MonoBehaviour
        {
            private NPCAutoTurret sentry;

            private void Awake()
            {
                sentry = GetComponent<NPCAutoTurret>();
                InvokeRepeating("CheckGround", 5f, 5f);
            }

            private void CheckGround()
            {
                RaycastHit rhit;
                var cast = Physics.Raycast(sentry.transform.position + new Vector3(0, 0.1f, 0), Vector3.down, out rhit, 4f, LayerMask.GetMask("Terrain", "Construction"));
                var distance = cast ? rhit.distance : 3f;

                if (distance > 0.2f)
                {
                    GroundMissing();
                }
            }

            private void GroundMissing()
            {
                if (sentry == null)
                {
                    DoDestroy(); return;
                }
                sentry.Kill();
                plugin.GiveSentry(sentry.transform.position);
            }

            public void DoDestroy()
            {
                Destroy(this);
            }
        }
        #endregion
    }
}


// --- End of file: CustomTurret.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AdminPanel.cs ---
// --- Original Local Path: AdminPanel.cs ---

using System.Collections.Generic;
using System;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using UnityEngine;
using Oxide.Core;
using System.IO;
using System.Net;
using System.Collections;
using System.Linq;
using Rust;

namespace Oxide.Plugins
{
    [Info("AdminPanel", "austinv900", "1.2.2", ResourceId = 2034)]
    class AdminPanel : RustPlugin
    {

        [PluginReference]
        Plugin Vanish;

        [PluginReference]
        Plugin Godmode;

        [PluginReference]
        Plugin AdminRadar;

        [PluginReference]
        Plugin NTeleportation;

        [PluginReference]
        Plugin EnhancedBanSystem;

        const string permAP = "adminpanel.allowed";

        void Init()
        {
            LoadDefaultConfig();
            LoadDefaultMessages();
            permission.RegisterPermission(permAP, this);
            cacheImage();
        }

        #region Configuration

        string serverBanner;
        string adminZoneCords;
        string PanelPosMin;
        string PanelPosMax;
        string btnInactColor;
        string btnActColor;
        bool ToggleMode;

        protected override void LoadDefaultConfig()
        {
            Config["ServerBannerImage"] = serverBanner = GetConfig("ServerBannerImage", "banner.png");
            Config["AdminZoneCoordinates"] = adminZoneCords = GetConfig("AdminZoneCoordinates", "-392 22.9 -312.3");
            Config["AdminPanelPosMin"] = PanelPosMin = GetConfig("AdminPanelPosMin", "0.838 0.14");
            Config["AdminPanelPosMax"] = PanelPosMax = GetConfig("AdminPanelPosMax", "0.986 0.36");
            Config["PanelButtonInactiveColor"] = btnInactColor = GetConfig("PanelButtonInactiveColor", "2.55 0 0 0.3");
            Config["PanelButtonActiveColor"] = btnActColor = GetConfig("PanelButtonActiveColor", "0 2.55 0 0.3");
            Config["AdminPanelToggleMode"] = ToggleMode = GetConfig("AdminPanelToggleMode", false);
            SaveConfig();
        }
        #endregion

        #region Localization
        void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Title"] = "Admin Controller",
                ["Vanish"] = "Vanish",
                ["GodMode"] = "God",
                ["Radar"] = "Radar",
                ["AdminTP"] = "AdminTP"
            }, this, "en");

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Title"] = "Controlador",
                ["Vanish"] = "Desaparecer",
                ["GodMode"] = "Dios",
                ["Radar"] = "Radar",
                ["AdminTP"] = "AdminTP"
            }, this, "es");
        }
        #endregion

        #region Hooks

        void OnPlayerSleepEnded(BasePlayer player)
        {
            if (ToggleMode == false)
            {
                if (IsAllowed(player.UserIDString, permAP))
                {
                 CuiHelper.DestroyUi(player, "GUIBackground");
                 AdminGui(player);
            }
            }
        }

        void OnPlayerInit(BasePlayer player)
        {
            if (ToggleMode == true)
            {
                if (IsAllowed(player.UserIDString, permAP))
                {
                    player.SendConsoleCommand("bind backquote +adminpanel toggle");
                }
            }
        }

        #endregion

        #region Command Structure
        [ConsoleCommand("adminpanel")]
        void ccmdAdminPanel(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            var args = arg?.Args ?? null;
            if (IsAllowed(player.UserIDString, permAP))
            {
                switch (args[0])
                {
                    case "action":
                        if (args[1] == "vanish")
                        {
                            if (Vanish) { Vanish?.Call("VanishChatCmd", player); AdminGui(player); };
                        }
                        else if (args[1] == "admintp")
                        {
                            rust.RunServerCommand("teleport.topos " + player.UserIDString + " " + adminZoneCords);
                        }
                        else if (args[1] == "radar")
                        {
                            if (AdminRadar) { AdminRadar?.Call("ToggleRadar", player); AdminGui(player); }
                        }
                        else if (args[1] == "god")
                        {
                            if (Godmode) { if (Godmode.Call<bool>("IsGod", player.UserIDString)) { Godmode.Call("DisableGodmode", player); } else { Godmode.Call("EnableGodmode", player); } AdminGui(player); };
                        }
                        break;

                    case "toggle":
                        if (IsAllowed(player.UserIDString, permAP))
                        {
                            if (args[1] == "True" && (ToggleMode == true))
                            {
                                AdminGui(player);
                            }
                            else if (args[1] == "False" && (ToggleMode == true))
                            {
                                CuiHelper.DestroyUi(player, "GUIBackground");
                            }
                        }
                        break;

                    default:
                        SendReply(player, $"[<color=#6275a4>{Name}</color>]: Invalid Syntax");
                        return;
                }
            }
            else { Reply(player, null); }
        }

        [ChatCommand("adminpanel")]
        void cmdAdminPanel(BasePlayer player, string command, string[] args)
        {
            if(!IsAllowed(player.UserIDString, permAP))
            {
                SendReply(player, $"Unknown command: {command}");
                return;
            }

            if (args.Length == 0)
            {
                SendReply(player, $"/{command} Show/Hide");
                return;
            }

            switch(args[0])
            {
                case "hide":
                    CuiHelper.DestroyUi(player, "GUIBackground");
                        Reply(player, "Admin Panel Hidden");
                    break;

                case "show":
                    AdminGui(player);
                        Reply(player, "Admin Panel Refreshed/Shown");
                        break;

               default:
                   SendReply(player, $"[<color=#6275a4>{Name}</color>]: Invalid Syntax /{command} {args[0]}");
                       return;
                }
        }
        #endregion

        #region ImageSaving
        ImageCache ImageAssets;
        GameObject AdminPanelObject;
        private void cacheImage()
        {
            AdminPanelObject = new GameObject();
            ImageAssets = AdminPanelObject.AddComponent<ImageCache>();
            ImageAssets.imageFiles.Clear();
            string dataDirectory = "file://" + Interface.Oxide.DataDirectory + Path.DirectorySeparatorChar + "AdminPanel" + Path.DirectorySeparatorChar + "img" + Path.DirectorySeparatorChar;

            ImageAssets.getImage("AdminPanalImage", dataDirectory + serverBanner);
            download();
        }

        public class ImageCache : MonoBehaviour
        {
            public Dictionary<string, string> imageFiles = new Dictionary<string, string>();

            public List<Queue> queued = new List<Queue>();

            public class Queue
            {
                public string url { get; set; }
                public string name { get; set; }
            }

            private void OnDestroy()
            {
                foreach (var value in imageFiles.Values)
                {
                    FileStorage.server.RemoveEntityNum(uint.MaxValue, Convert.ToUInt32(value));
                }
            }

            public void getImage(string name, string url)
            {
                queued.Add(new Queue
                {
                    url = url,
                    name = name
                });
            }

            IEnumerator WaitForRequest(Queue queue)
            {
                using (var www = new WWW(queue.url))
                {
                    yield return www;

                    if (string.IsNullOrEmpty(www.error))
                    {
                        var stream = new MemoryStream();
                        stream.Write(www.bytes, 0, www.bytes.Length);
                        imageFiles.Add(queue.name, FileStorage.server.Store(stream, FileStorage.Type.png, uint.MaxValue).ToString());
                    }
                    else
                    {
                        Debug.Log("Error downloading banner.png . It must be in your oxide/data/");
                        ConsoleSystem.Run.Server.Normal("oxide.unload AdminPanel");
                    }
                }
            }

            public void process()
            {
                StartCoroutine(WaitForRequest(queued[0]));
            }
        }

        void download()
        {
            ImageAssets.process();
        }

        public string fetchImage(string name)
        {
            string result;
            if (ImageAssets.imageFiles.TryGetValue(name, out result))
                return result;
            return string.Empty;
        }
        #endregion

        #region GUI Panel

        void AdminGui(BasePlayer player)
        {
            // Destroy existing UI
            CuiHelper.DestroyUi(player, "GUIBackground");

            var BTNColorVanish = btnInactColor;
            var BTNColorGod = btnInactColor;
            var BTNColorRadar = btnInactColor;

            if (Godmode) { if (Godmode.Call<bool>("IsGod", player.UserIDString)) { BTNColorGod = btnActColor; }; };
            if (Vanish) { if (Vanish.Call<bool>("IsInvisible", player)) { BTNColorVanish = btnActColor; }; };
            if (AdminRadar) { if (AdminRadar.Call<bool>("IsRadar", player.UserIDString)) { BTNColorRadar = btnActColor; }; };



            var GUIElement = new CuiElementContainer();

                var GUIBackground = GUIElement.Add(new CuiPanel
                {
                    Image =
                {
                    Color = "1 1 1 0.02"
                },
                    RectTransform =
                {
                    AnchorMin = PanelPosMin,
                    AnchorMax = PanelPosMax
                },
                    CursorEnabled = ToggleMode
                }, "Hud", "GUIBackground");
                GUIElement.Add(new CuiLabel
                {
                    Text =
                {
                    Text = Lang("Title", player.UserIDString),
                    FontSize = 10,
                    Align = TextAnchor.MiddleCenter,
                    Color = "1.0 1.0 1.0 1.0"
                },
                    RectTransform =
                {
                    AnchorMin = "0.00 0.36",
                    AnchorMax = "1.00 0.51"
                }
                }, GUIBackground);
                if (AdminRadar && permission.UserHasPermission(player.UserIDString, "adminradar.allowed"))
                {
                    GUIElement.Add(new CuiButton
                    {
                        Button =
                    {
                        Command = "adminpanel action radar",
                        Color = BTNColorRadar
                    },
                        Text =
                {
                    Text = Lang("Radar", player.UserIDString),
                    FontSize = 8,
                    Align = TextAnchor.MiddleCenter,
                    Color = "1.0 1.0 1.0 1.0"
                },
                        RectTransform =
                {
                    AnchorMin = "0.05 0.21",
                    AnchorMax = "0.48 0.37"
                }
                    }, GUIBackground);
                }
                    GUIElement.Add(new CuiButton
                    {
                        Button =
                    {
                        Command = "adminpanel action admintp",
                        Color = "1.28 0 1.28 0.3"
                    },
                        Text =
                {
                    Text = Lang("AdminTP", player.UserIDString),
                    FontSize = 8,
                    Align = TextAnchor.MiddleCenter,
                    Color = "1.0 1.0 1.0 1.0"
                },
                        RectTransform =
                {
                    AnchorMin = "0.52 0.21",
                    AnchorMax = "0.95 0.37"
                }
                    }, GUIBackground);
                if (Vanish && permission.UserHasPermission(player.UserIDString, "vanish.allowed"))
                {
                    GUIElement.Add(new CuiButton
                    {
                        Button =
                    {
                        Command = "adminpanel action vanish",
                        Color = BTNColorVanish
                    },
                        Text =
                {
                    Text = Lang("Vanish", player.UserIDString),
                    FontSize = 8,
                    Align = TextAnchor.MiddleCenter,
                    Color = "1.0 1.0 1.0 1.0"
                },
                        RectTransform =
                {
                    AnchorMin = "0.05 0.02",
                    AnchorMax = "0.48 0.19"
                }
                    }, GUIBackground);
                }
                if (Godmode && permission.UserHasPermission(player.UserIDString, "godmode.allowed"))
                {
                    GUIElement.Add(new CuiButton
                    {
                        Button =
                    {
                        Command = "adminpanel action god",
                        Color = BTNColorGod
                    },
                        Text =
                {
                    Text = Lang("GodMode", player.UserIDString),
                    FontSize = 8,
                    Align = TextAnchor.MiddleCenter,
                    Color = "1.0 1.0 1.0 1.0"
                },
                        RectTransform =
                {
                    AnchorMin = "0.52 0.02",
                    AnchorMax = "0.95 0.19"
                }
                    }, GUIBackground);
                }

                GUIElement.Add(new CuiElement
                {
                    Name = "Logo",
                    Parent = "GUIBackground",
                    Components =
                    {
                        new CuiRawImageComponent { Color = "1.00 1.00 1.00 1", Png = fetchImage("AdminPanalImage"), FadeIn = 0 },
                        new CuiRectTransformComponent { AnchorMin = "0.03 0.49",  AnchorMax = "0.97 0.99" }
                    }
                });

                CuiHelper.AddUi(player, GUIElement);
        }

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, "GUIBackground");
            }
        }
        #endregion

        #region Helpers
        T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null) return defaultValue;
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

        bool IsAdmin(string id) => permission.UserHasGroup(id, "admin");

        bool IsAllowed(string id, string perm) => permission.UserHasPermission(id, perm) || IsAdmin(id);

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        void Reply(BasePlayer player, string Getmessage) { rust.SendChatMessage(player, "[<color=red>AdminPanel</color>]", Getmessage); } 
        #endregion
    }
}


// --- End of file: AdminPanel.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeautyRestart.cs ---
// --- Original Local Path: BeautyRestart.cs ---

using Oxide.Core;
using System;
using System.Reflection;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using ConVar;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("BeautyRestart", "Reynostrum", "1.0.0")]
    [Description("Restart the server with a cooldown GUI timer.")]
    class BeautyRestart : RustPlugin
    {
        #region Init/config
        int TimerSeconds;
        int Minutes;
        int Hours;
        int Seconds;
        string HoursF;
        string MinutesF;
        string SecondsF;
        string TimerMessage;
        bool IsTiming;
        static Timer TimerRefresh;
        string GUIAnchorMin => GetConfig("GUIAnchorMin", "0.401 0.85");
        string GUIAnchorMax => GetConfig("GUIAnchorMax", "0.587 0.90");
        string GUITextColor => GetConfig("GUITextColor", "255 0 0");
        string GUIBackgroundColor => GetConfig("GUIBackgroundColor", "0 0 0 0.90");
        protected override void LoadDefaultConfig()
        {
            Config["GUIAnchorMin"] = GUIAnchorMin;
            Config["GUIAnchorMax"] = GUIAnchorMax;
            Config["GUITextColor"] = GUITextColor;
            Config["GUIBackgroundColor"] = GUIBackgroundColor;
            SaveConfig();
        }
        #endregion

        #region Commands
        [ConsoleCommand("brestart")]
        void CMDConsoleRestart(ConsoleSystem.Arg arg)
        {
            if (arg.connection == null)
            {
                if (arg.Args == null || arg.Args.Length != 2)
                {
                    SendReply(arg, Lang("Error"));
                    return;
                }
                else Checkcommand(arg, null, arg.Args[0], arg.Args[1], true);
            }
            else SendReply(arg, Lang("NotAllowed"));
        }
        [ChatCommand("brestart")]
        void CMDCommandRestart(BasePlayer player, string cmd, string[] args)
        {
            if (HasPermission(player, "BeautyRestart.Restart") || player.IsAdmin())
            {
                if (args == null || args.Length != 2)
                {
                    SendReply(player, Lang("Error"));
                    return;
                }
                else Checkcommand(null, player, args[0], args[1], false);
            }
            else SendReply(player, Lang("NotAllowed", player.UserIDString));
        }
        [ConsoleCommand("bcancelrestart")]
        void CMDConsoleCancelRestart(ConsoleSystem.Arg arg)
        {
            if (arg.connection == null)
            {
                Abort();
                SendReply(arg, Lang("CancelRestart"));
            }
            else SendReply(arg, Lang("NotAllowed"));
        }
        [ChatCommand("bcancelrestart")]
        void CMDCommandCancelRestart(BasePlayer player, string cmd, string[] args)
        {
            if (HasPermission(player, "BeautyRestart.Restart") || player.IsAdmin())
            {
                Abort();
                SendReply(player, Lang("CancelRestart", player.UserIDString));
            }
            else SendReply(player, Lang("NotAllowed", player.UserIDString));
        }
        #endregion

        #region Basic hooks
        void Loaded()
        {
            lang.RegisterMessages(Messages, this);
            permission.RegisterPermission("BeautyRestart.Restart", this);
            LoadDefaultConfig();
        }
        void Unload()
        {
            Abort();
            if (TimerRefresh != null) { TimerRefresh.Destroy(); }
        }
        #endregion

        #region Functions
        void Checkcommand(ConsoleSystem.Arg arg, BasePlayer player, string minutes, string name, bool console)
        {
            int Num;
            bool isNum = int.TryParse(minutes, out Num);
            if (isNum && name != "")
            {
                CreatingTimer(Num, name);
                if (console) SendReply(arg, Lang("TimerSet", null, StyleSeconds(Num * 60)));
            }
            else
            {
                if (console) SendReply(arg, Lang("Error"));
                else SendReply(player, Lang("Error", player.UserIDString));
            }
        }
        void Abort()
        {
            if (TimerRefresh != null) TimerRefresh.Destroy();
            foreach (BasePlayer player in BasePlayer.activePlayerList) FULLGUIHandler(player, "Unload");
            timer.Once(1f, () =>
            {
                foreach (BasePlayer player in BasePlayer.activePlayerList) FULLGUIHandler(player, "Unload");
            });
            Hours = 0;
            Minutes = 0;
            Seconds = 0;
            IsTiming = false;
            PrintToChat(Lang("GlobalCanceled"));
        }
        string StyleSeconds(int SecondsT)
        {
            string Format;
            Hours = SecondsT / 3600;
            Minutes = (SecondsT - Hours * 3600) / 60;
            Seconds = SecondsT - (Hours * 3600 + Minutes * 60);
            if (Seconds <= 9) SecondsF = "0" + Seconds;
            else SecondsF = Seconds.ToString();
            if (Minutes <= 9) MinutesF = "0" + Minutes;
            else MinutesF = Minutes.ToString();
            if (Hours <= 9) HoursF = "0" + Hours;
            else HoursF = Hours.ToString();
            if (Hours == 0) Format = MinutesF + "m " + SecondsF + "s";
            else Format = HoursF + "h " + MinutesF + "m " + SecondsF + "s";
            return Format;
        }
        void DoRestart()
        {
            BasePlayer[] array = BasePlayer.activePlayerList.ToArray();
            for (int i = 0; i < (int)array.Length; i++)
            {
                BasePlayer basePlayer = array[i];
                basePlayer.Kick(TimerMessage);
            }
            timer.Once(2, () => ConsoleSystem.Run.Server.Normal("quit"));
        }
        void TimeIn()
        {
            PrintToChat(Lang("TimerSet", null, StyleSeconds(TimerSeconds)));
            TimerRefresh = timer.Repeat(1f, TimerSeconds, () =>
            {
                TimerSeconds--;
                
                if (Seconds == 1 && Minutes == 0 && Hours == 0)
                {
                    Puts("Restarting...");
                    DoRestart();
                    return;
                }
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    CuiHelper.DestroyUi(player, "GUITexto");
                    GUITexto(player);
                }
                NextFrame(() =>
                {
                    if (Seconds == 0)
                    {
                        Puts(Lang("TimerSet", null, StyleSeconds(TimerSeconds)));
                        PrintToChat(Lang("TimerSet", null, StyleSeconds(TimerSeconds)));
                    }
                });
            });
        }     
        void CreatingTimer(int CreatingTimerMinutes, string TimerName)
        {
            if (IsTiming) return;
            IsTiming = true;
            TimerMessage = TimerName;
            TimerSeconds = CreatingTimerMinutes * 60;
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                FULLGUIHandler(player, "Unload");
                FULLGUIHandler(player, "Load");
            };
            TimeIn();
        }      
        void FULLGUIHandler(BasePlayer player, string Command)
        {
            if (Command == "Unload")
            {
                CuiHelper.DestroyUi(player, "GUITexto");
                CuiHelper.DestroyUi(player, "GUIBackground");
            }
            else if (Command == "Load")
            {
                if (!IsTiming) return;
                GUIBackground(player);
                GUITexto(player);
            }
        }
        #endregion
        
        #region GUI
        void GUITexto(BasePlayer player)
        {
            var GUIElementn = new CuiElementContainer();
            var GUIBackgroundn = GUIElementn.Add(new CuiLabel
            {
                Text =
                    {
                        Text = StyleSeconds(TimerSeconds),
                        FontSize = 12,
                        Align = TextAnchor.LowerCenter,
                        Color = GUITextColor
                    },
                RectTransform =
                    {
                        AnchorMin = GUIAnchorMin + "5",
                        AnchorMax = GUIAnchorMax
                    }
            }, "Hud", "GUITexto");
            CuiHelper.AddUi(player, GUIElementn);
        }
        void GUIBackground(BasePlayer player)
        {
            var GUIElementn = new CuiElementContainer();
            var GUIBackgroundn = GUIElementn.Add(new CuiPanel
            {
                Image =
                    {
                        Color = GUIBackgroundColor
                    },
                RectTransform =
                    {
                        AnchorMin = GUIAnchorMin,
                        AnchorMax = GUIAnchorMax
                    },
                CursorEnabled = false
            }, "Hud", "GUIBackground");
            GUIElementn.Add(new CuiLabel
            {
                Text =
                    {
                        Text = TimerMessage.ToUpper(),
                        FontSize = 14,
                        Align = TextAnchor.UpperCenter,
                        Color = GUITextColor
                    },
                RectTransform =
                    {
                        AnchorMin = "0.00 0.1",
                        AnchorMax = "1 0.9"
                    }
            }, GUIBackgroundn);
            CuiHelper.AddUi(player, GUIElementn);
        }
        #endregion

        #region Oxide hooks
        void OnPlayerInit(BasePlayer player)
        {
            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.Once(1, () => OnPlayerInit(player));
                return;
            }
            FULLGUIHandler(player, "Unload");
            FULLGUIHandler(player, "Load");
        }
        #endregion

        #region Helpers
        T GetConfig<T>(string name, T defaultValue) => Config[name] == null ? defaultValue : (T)Convert.ChangeType(Config[name], typeof(T));
        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);
        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            {"NotAllowed", "You are not allowed to use this command." },
            {"CancelRestart", "You have canceled the restart." },
            {"TimerSet", "The server will restart in {0}." },
            {"Error", "Use: brestart (minutes) (message)" },
            {"GlobalCanceled", "Server restart has been canceled." }
        };
        #endregion
    }
}

// --- End of file: BeautyRestart.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KitsUI.cs ---
// --- Original Local Path: KitsUI.cs ---

﻿//==================================================================\\
//В Китах с Oxide в любое удобно место (Только не ломайте структуру)
//==================================================================\\
//   [HookMethod("GetPlayerKitList")]
//    private List<object[]> GetPlayerKitList(BasePlayer player)
//    {
//        List<object[]> kitsInfo = new List<object[]>();
//        string reason = string.Empty;
//
//       foreach (var pair in storedData.Kits)
//        {
//            var kitData = GetKitData(player.userID, pair.Key);
//            var cansee = CanSeeKit(player, pair.Key, false, out reason);
//           var time = CanSeeKit(player, pair.Key, false, out reason);
//            if (!cansee && string.IsNullOrEmpty(reason)) continue;
//            object[] kitInfo = new object[7];
//            kitInfo[0] = cansee;
//            kitInfo[1] = pair.Value.name;
//            kitInfo[2] = pair.Value.description;
//            kitInfo[3] = reason;
//            kitInfo[4] = pair.Value.max < 0 ? "0" : (pair.Value.max - kitData.max).ToString();
//            kitInfo[5] = pair.Value.cooldown <= 0 ? string.Empty : CurrentTime() > kitData.cooldown ? "0" : Math.Abs(Math.Ceiling(CurrentTime() - kitData.cooldown)).ToString();
//            kitInfo[6] = pair.Value.max;
//            kitsInfo.Add(kitInfo);
//        }
//        return kitsInfo;
//    }
//
//   [HookMethod("AvailabilityKit")]
//    private void AvailabilityKit(BasePlayer player, string kitname)
//    {
//        TryGiveKit(player, kitname);
//    }
//==================================================================\\

using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins 
{
	[Info("KitsUI", "OxideBro / RustPlugin.ru", "0.1.0")]
	[Description("UI оболочка для китов с Oxide - https://oxidemod.org/plugins/kits.668/")]
	class KitsUI : RustPlugin
	{
		[PluginReference]         
		private Plugin Kits;
		
		private Dictionary<BasePlayer, int> openUI = new Dictionary<BasePlayer, int>();
		private void OnServerInitialized()
		{
			if (Kits == null)
			{
				PrintError("Плагин 'Kits' не найден, работа плагина не возможна"); 
			}

			LoadDefaultConfig();
			timer.Every(1f, TimerHandle);
		}

		void TimerHandle() 
		{
			foreach (var player in openUI)
			{
				DrawKitsUI(player.Key, player.Value);
			}
		}

		public string BackroungPanelColor = "0 0 0 0.3";
		protected override void LoadDefaultConfig()
		{
			GetVeriables("UI", "Цвет фона китов GUI", ref BackroungPanelColor);
			SaveConfig();
		}
		
		[ChatCommand("kits")]         
		void cmdChatKitsUI(BasePlayer player)
		{
			if (player == null) return;
			if (openUI.ContainsKey(player))
			{
				openUI[player] = 0;
			}
			DrawKitsUI(player, 0);
		}
		
		[ConsoleCommand("kitsgui_show")]
		void cmdShowKitsUI(ConsoleSystem.Arg arg)
		{
			var player = arg.Connection.player as BasePlayer;
			if (player == null) return;
			if (openUI.ContainsKey(player))
			{
				openUI[player] = 0; 
			}
			DrawKitsUI(player, 0);
		}
		
		[ConsoleCommand("destroykitsui")]
		void cmdDestroyKitsUI(ConsoleSystem.Arg arg)
		{
			var player = arg.Connection.player as BasePlayer;
			if (player == null) return;
			DestroyKitsUI(player);
			openUI.Remove(player);
		}

		void Unload()
		{
			foreach (var player in BasePlayer.activePlayerList) 
			DestroyKitsUI(player);
		}
		
		[ConsoleCommand("trytogetkit")]
		void cmdTryToGetKit(ConsoleSystem.Arg arg)
		{
			var player = arg.Connection.player as BasePlayer;
			if (arg.Args.Length > 0)
			{
				Kits?.Call("AvailabilityKit", player, arg.Args[0]);
				if (openUI.ContainsKey(player))
				{
					DestroyKitsUI(player);
					DrawKitsUI(player, openUI[player]);
				}
			}
		}
		
		[ConsoleCommand("trytogetkit_nextpage")]
		void cmdTryToGetKitNextPage(ConsoleSystem.Arg arg)
		{
			var player = arg.Connection.player as BasePlayer;
			if (arg.Args.Length > 0)
			{
				openUI[player] = int.Parse(arg.Args[0]);
				DrawKitsUI(player, int.Parse(arg.Args[0]));
			} 
		}

		private void DestroyKitsUI(BasePlayer player)
		{
			CuiHelper.DestroyUi(player, "KitsUIHUD");
			CuiHelper.DestroyUi(player, "ButtonBG");
		}

		string Button = "[{\"name\":\"Report.Player5\",\"parent\":\"KitsUIHUD\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"{color}\"},{\"type\":\"RectTransform\",\"anchormin\":\"{amin}\",\"anchormax\":\"{amax}\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"CuiElement\",\"parent\":\"Report.Player5\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{text}\",\"fontSize\":16,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.2784314\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"CuiElement\",\"parent\":\"Report.Player5\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"{command}\",\"color\":\"1 1 1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]}]"; 
		string GUI = "[{\"name\":\"KitsUIHUD\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"color\":\"{color}\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\"},{\"type\":\"NeedsCursor\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.45\",\"anchormax\":\"1 0.6\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"CuiElement\",\"parent\":\"KitsUIHUD\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{text}\",\"fontSize\":16,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.2784314\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"CuiElement\",\"parent\":\"KitsUIHUD\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"{command}\",\"color\":\"1 1 1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]}]"; 
		string ButtonBG = "[{\"name\":\"ButtonBG\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"color\":\"{color}\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\"},{\"type\":\"NeedsCursor\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.35 0.38\",\"anchormax\":\"0.65 0.44\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"CuiElement\",\"parent\":\"ButtonBG\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{text}\",\"fontSize\":16,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.2784314\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"CuiElement\",\"parent\":\"ButtonBG\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"{command}\",\"color\":\"1 1 1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]}]"; string Page = "[{\"name\":\"Report.Player5\",\"parent\":\"ButtonBG\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"{color}\"},{\"type\":\"RectTransform\",\"anchormin\":\"{amin}\",\"anchormax\":\"{amax}\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"CuiElement\",\"parent\":\"Report.Player5\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{text}\",\"fontSize\":16,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.2784314\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"CuiElement\",\"parent\":\"Report.Player5\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"{command}\",\"color\":\"1 1 1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]}]"; 
		
		private void DrawKitsUI(BasePlayer player, int page)
		{
			DestroyKitsUI(player);
			var kitsList = Kits?.Call("GetPlayerKitList", player) as List<object[]>;
			var lols = new CuiElementContainer();
			if (kitsList != null && kitsList.Count > 0)
			{
				if (!openUI.ContainsKey(player)) openUI.Add(player, page);
				var reply = 309;
				if (reply == 0) { } 
				int i = 0;
				float gap = 0.01f;
				float width = 0.15f;
				float height = 0.6f;
				float startxBox = 0.015f;
				float startyBox = 0.8f - height;
				float xmin = startxBox;
				float ymin = startyBox;
				if (kitsList.Count > 6)
				{
					CuiHelper.AddUi(player, ButtonBG.Replace("{text}", $"Страница: {page + 1}")
					                                .Replace("{color}", BackroungPanelColor)
							                        .Replace("{command}", ""));
				}

				CuiHelper.AddUi(player, GUI.Replace("{text}", "")
				                           .Replace("{color}", BackroungPanelColor)
										   .Replace("{command}", ""));
	            
				CuiHelper.AddUi(player, Button.Replace("{amin}", "0.97 0.8")
				                              .Replace("{amax}", "0.999 0.998")
											  .Replace("{text}", "X")
											  .Replace("{color}", "0.93 0.35 0.36 1.00")
											  .Replace("{command}", "destroykitsui"));

			    foreach (var kit in kitsList.Skip(6 * page))
				{
					var color = (bool)kit[0] ? "0.41 0.48 0.31 1.00" : "0.74 0.25 0.20 1.00";
					var amin = xmin + " " + ymin;
					var amax = (xmin + width) + " " + (ymin + height * 1);
					var text = Convert.ToUInt32(kit[6]) > 0 ? kit[1] + "\n" + $"Доступно: {kit[4]}" : kit[1];
					if (kit[5].ToString() != "")
					{
						if (Convert.ToUInt32(kit[5]) > 0) text = text + "\n" + $"<size=12>Осталось: {FormatTime(TimeSpan.FromSeconds(Convert.ToUInt32(kit[5])))}</size>";
					}
					var command = "TryToGetKit " + ((string)kitsList[6 * page + i][1]).ToLower();
					DrawKitsInfo(player, amin, amax, color, command, text.ToString());
					xmin += width + gap;
					if (xmin + width >= 1)
					{
						xmin = startxBox; ymin -= height + gap;
					} i++;
					if (i >= 6)
					{
						CuiHelper.AddUi(player, Page.Replace("{amin}", "0.6954611 0.1553825")
						                            .Replace("{amax}", "0.9807224 0.826389")
													.Replace("{text}", "Следующая >")
													.Replace("{color}", "0.41 0.48 0.31 1.00")
													.Replace("{command}", $"trytogetkit_nextpage {page + 1}"));
						break;
					}
				}

				if (page != 0)
				{
					CuiHelper.AddUi(player, Page.Replace("{amin}", "0.01464129 0.1553825")
					                            .Replace("{amax}", "0.2999026 0.826389")
												.Replace("{text}", "< Предыдущая")
												.Replace("{color}", "0.41 0.48 0.31 1.00")
												.Replace("{command}", $"trytogetkit_nextpage {page - 1}"));
				}
			}
			else
			{
				CuiHelper.AddUi(player, GUI.Replace("{text}", "<size=18><b>Извините, но для Вас пока нету доступных китов</b></size>")
				                           .Replace("{color}", BackroungPanelColor)
										   .Replace("{command}", ""));
				
				CuiHelper.AddUi(player, Button.Replace("{amin}", "0.97 0.8")
				                              .Replace("{amax}", "0.999 0.998")
											  .Replace("{text}", "X")
											  .Replace("{color}", "0.93 0.35 0.36 1.00")
											  .Replace("{command}", "destroykitsui"));
			}
		}

		void DrawKitsInfo(BasePlayer player, string amin, string amax, string color, string command, string text)
		{
			CuiHelper.AddUi(player, Button.Replace("{amin}", amin)
			                              .Replace("{amax}", amax)
										  .Replace("{text}", text.ToString())
										  .Replace("{color}", color)
										  .Replace("{command}", command));
		}

		public static string FormatTime(TimeSpan time)
		{
			string result = string.Empty;
			if (time.Days != 0) result += $"{Format(time.Days, "дней", "дня", "день")} ";
			if (time.Hours != 0) result += $"{Format(time.Hours, "часов", "часа", "час")} ";
			if (time.Minutes != 0) result += $"{Format(time.Minutes, "минут", "минуты", "минута")} ";
			if (time.Seconds != 0) result += $"{Format(time.Seconds, "секунд", "секунды", "секунда")} ";
			return result;
		}

		private static string Format(int units, string form1, string form2, string form3)
		{
			var tmp = units % 10;
			if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9) 
				return $"{units} {form1}";
			
			if (tmp >= 2 && tmp <= 4) return $"{units} {form2}";
			    return $"{units} {form3}";
		}

		private void GetVeriables<T>(string menu, string Key, ref T var)
		{
			if (Config[menu, Key] != null)
			{
				var = (T)Convert.ChangeType(Config[menu, Key], typeof(T));
			}
			Config[menu, Key] = var;
		}
	}
}

// --- End of file: KitsUI.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Prod.cs ---
// --- Original Local Path: Prod.cs ---

// Reference: RustBuild
using System.Collections.Generic;
using System;
using System.Reflection;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Libraries.Covalence;


namespace Oxide.Plugins
{
    [Info("Prod", "Reneb", "2.2.5", ResourceId = 683)]
    class Prod : RustPlugin
    { 

        private int prodAuth;
        private string helpProd;
        private string noAccess;
        private string noTargetfound;
        private string noCupboardPlayers;
        private string Toolcupboard;
        private string noBlockOwnerfound;
        private string noCodeAccess;
        private string codeLockList;
        private string boxNeedsCode;
        private string boxCode;

        private FieldInfo serverinput;
        private FieldInfo codelockwhitelist; 
        private FieldInfo codenum;
        private FieldInfo npcnextTick;
        private FieldInfo meshinstances;


        private Vector3 eyesAdjust;
        private bool Changed;

        [PluginReference]
        Plugin BuildingOwners;

        [PluginReference]
        Plugin DeadPlayersList;

        [PluginReference]
        Plugin PlayerDatabase;

        void Loaded()
        {
            LoadVariables();
            eyesAdjust = new Vector3(0f, 1.5f, 0f);
            serverinput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            codelockwhitelist = typeof(CodeLock).GetField("whitelistPlayers", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            codenum = typeof(CodeLock).GetField("code", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            npcnextTick = typeof(NPCAI).GetField("nextTick", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            meshinstances = typeof(MeshColliderBatch).GetField("instances", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        private bool isPluginDev;
        private bool dumpAll;
        private void LoadVariables()
        {
            prodAuth = Convert.ToInt32(GetConfig("Prod", "authLevel", 1));
            isPluginDev = Convert.ToBoolean(GetConfig("Plugin Dev", "Are you are plugin dev?", false));
            dumpAll = Convert.ToBoolean(GetConfig("Plugin Dev", "Dump all components of all entities that you are looking at? (false will do only the closest one)", false));
            helpProd = Convert.ToString(GetConfig("Messages", "helpProd", "/prod on a building or tool cupboard to know who owns it."));
            noAccess = Convert.ToString(GetConfig("Messages", "noAccess", "You don't have access to this command"));
            noTargetfound = Convert.ToString(GetConfig("Messages", "noTargetfound", "You must look at a tool cupboard or building"));
            noCupboardPlayers = Convert.ToString(GetConfig("Messages", "noCupboardPlayers", "No players has access to this cupboard"));
            Toolcupboard = Convert.ToString(GetConfig("Messages", "Toolcupboard", "Tool Cupboard"));
            noBlockOwnerfound = Convert.ToString(GetConfig("Messages", "noBlockOwnerfound", "No owner found for this building block"));
            noCodeAccess = Convert.ToString(GetConfig("Messages", "noCodeAccess", "No players has access to this Lock"));
            codeLockList = Convert.ToString(GetConfig("Messages", "codeLockList", "CodeLock whitelist:"));
            boxNeedsCode = Convert.ToString(GetConfig("Messages", "boxNeedsCode", "Can't find owners of an item without a Code Lock"));
            boxCode = Convert.ToString(GetConfig("Messages", "Code", "Code is: {0}"));
            
            if (Changed)
            {
                SaveConfig();
                Changed = false;
            }
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Prod: Creating a new config file");
            Config.Clear();
            LoadVariables();
        }

        private bool hasAccess(BasePlayer player)
        {
            if (player.net.connection.authLevel < prodAuth)
                return false;
            return true;
        }
        [ChatCommand("prod")]
        void cmdChatProd(BasePlayer player, string command, string[] args)
        {
            if (!(hasAccess(player)))
            {
                SendReply(player, noAccess);
                return;
            }
            var input = serverinput.GetValue(player) as InputState;
            var currentRot = Quaternion.Euler(input.current.aimAngles) * Vector3.forward;
            var target = DoRay(player.transform.position + eyesAdjust, currentRot);
            if (target == null)
            {
                SendReply(player, noTargetfound);
                return;
            }

            if (isPluginDev && !dumpAll)
            {
                Dump(target);
            }

            if(target.OwnerID != 0L)
            {
                SendReply(player, string.Format("Entity Owner (Builder): {0} {1}", FindPlayerName(target.OwnerID), target.OwnerID.ToString()));
            }

            var block = target.GetComponentInParent<BuildingBlock>();
            if (block)
            {
                GetBuildingblockOwner(player, block);
                return;
            }

            var priv = target.GetComponentInParent<BuildingPrivlidge>();
            if (priv)
            {
                GetToolCupboardUsers(player, priv);
                return;
            }
            
            var bag = target.GetComponentInParent<SleepingBag>();
            if (bag)
            {
                GetDeployedItemOwner(player, bag);
                return;
            }

            {
                GetDeployableCode(player, target);
            }
            
        }
        private void GetDeployableCode(BasePlayer player, BaseEntity block)
        {
            if (block.HasSlot(BaseEntity.Slot.Lock))
            {
                BaseEntity slotent = block.GetSlot(BaseEntity.Slot.Lock);
                if (slotent != null)
                {
                    CodeLock codelock = slotent.GetComponent<CodeLock>();
                    if (codelock != null)
                    {
                        List<ulong> whitelisted = codelockwhitelist.GetValue(codelock) as List<ulong>;
                        string codevalue = codenum.GetValue(codelock) as string;
                        SendReply(player, string.Format(boxCode, codevalue));
                        SendReply(player, codeLockList);
                        if (whitelisted.Count == 0)
                        {
                            SendReply(player, noCodeAccess);
                            return;
                        }
                        foreach (ulong userid in whitelisted)
                        {
                            SendBasePlayerFind(player, userid);
                        }
                    }
                }
            }
        }
        private void GetDeployedItemOwner(BasePlayer player, SleepingBag ditem)
        {
            SendReply(player, string.Format("Sleeping Bag '{0}': {1} - {2}", ditem.niceName.ToString(), FindPlayerName(ditem.deployerUserID), ditem.deployerUserID.ToString()));
        }
        private object FindOwnerBlock(BuildingBlock block)
        {
            object returnhook = BuildingOwners?.Call("FindBlockData", block);

            if (returnhook != null)
            {
                if (!(returnhook is bool))
                {
                    ulong ownerid = Convert.ToUInt64(returnhook);
                    return ownerid;
                }
            }
            Puts("Prod: To be able to obtain the owner of a building you need to install the BuildingOwner plugin.");
            return false;
        }

        private string FindPlayerName(ulong userId)
        {
            BasePlayer player = BasePlayer.FindByID(userId);
            if (player)
                return player.displayName + " (Online)";

            player = BasePlayer.FindSleeping(userId);
            if (player)
                return player.displayName + " (Sleeping)";

            var iplayer = covalence.Players.FindPlayer(userId.ToString());
            if (iplayer != null)
                return iplayer.Name + " (Dead)";

            string name = DeadPlayersList?.Call("GetPlayerName", userId) as string;
            if (name != null)
                return name + " (Dead)";

            var name2 = PlayerDatabase?.Call("GetPlayerData", userId.ToString(), "default");
            if(name2 is Dictionary<string, object>)
                return ((name2 as Dictionary <string, object>)["name"] as string) + " (Dead)";

            return "Unknown player";
        }
        private void SendBasePlayerFind(BasePlayer player, ulong ownerid)
        {
            SendReply(player, string.Format("{0} {1}", FindPlayerName(ownerid), ownerid.ToString()));
        }
        private void GetBuildingblockOwner(BasePlayer player, BuildingBlock block)
        {
            if(block.GetComponent<Door>() != null)
            {
                if(block.HasSlot(BaseEntity.Slot.Lock))
                {
                    BaseEntity slotent = block.GetSlot(BaseEntity.Slot.Lock);
                    if(slotent != null)
                    {
                        CodeLock codelock = slotent.GetComponent<CodeLock>();
                        if(codelock != null)
                        {
                            List<ulong> whitelisted = codelockwhitelist.GetValue(codelock) as List<ulong>;
                            string codevalue = codenum.GetValue(codelock) as string;
                            SendReply(player, string.Format(boxCode, codevalue));
                            SendReply(player, codeLockList);
                            if (whitelisted.Count == 0)
                            {
                                SendReply(player, noCodeAccess);
                                return;
                            }
                            foreach (ulong userid in whitelisted)
                            {
                                SendReply(player, string.Format("{0} {1}", FindPlayerName(userid), userid.ToString()));
                            }
                        }
                    }
                }
            }

            object findownerblock = FindOwnerBlock(block);
            if (findownerblock is bool)
            {
                SendReply(player, noBlockOwnerfound);
                return;
            }
            ulong ownerid = (UInt64)findownerblock;
            SendReply(player, string.Format("Building Owner: {0} {1}", FindPlayerName(ownerid), ownerid.ToString()));
            SendBasePlayerFind(player, ownerid);
        }
        private void GetToolCupboardUsers(BasePlayer player, BuildingPrivlidge cupboard)
        {
            SendReply(player, string.Format("{0} - {1} {2} {3}", Toolcupboard, Math.Round(cupboard.transform.position.x).ToString(), Math.Round(cupboard.transform.position.y).ToString(), Math.Round(cupboard.transform.position.z).ToString()));
            if (cupboard.authorizedPlayers.Count == 0)
            {
                SendReply(player, noCupboardPlayers);
                return;
            }
            foreach (ProtoBuf.PlayerNameID pnid in cupboard.authorizedPlayers)
            {
                SendReply(player, string.Format("{0} - {1}", pnid.username.ToString(), pnid.userid.ToString()));
            }
        }
        private void Dump(BaseEntity col)
        {
            Debug.Log(col.GetComponent<StabilityEntity>().ToString());
            Debug.Log("==================================================");
            Debug.Log(col.ToString() + " " + LayerMask.LayerToName(col.gameObject.layer).ToString());
            Debug.Log("========= NORMAL ===========");
            foreach(UnityEngine.Component com in col.GetComponents(typeof(UnityEngine.Component)) )
            {
                Debug.Log(com.GetType().ToString() + " " + com.ToString());
            }
            Debug.Log("========= PARENT ===========");
            foreach (UnityEngine.Component com in col.GetComponentsInParent(typeof(UnityEngine.Component)))
            {
                Debug.Log(com.GetType().ToString() + " " + com.ToString());
            }
            Debug.Log("========= CHILDREN ===========");
            foreach (UnityEngine.Component com in col.GetComponentsInChildren(typeof(UnityEngine.Component)))
            {
                Debug.Log(com.GetType().ToString() + " " + com.ToString());
            }
        }
        private BaseEntity DoRay(Vector3 Pos, Vector3 Aim)
        {
            var hits = UnityEngine.Physics.RaycastAll(Pos, Aim);
            float distance = 100000f;
            BaseEntity target = null;
            foreach (var hit in hits)
            {
                if (hit.collider != null && isPluginDev && dumpAll)
                    Dump(hit.GetEntity());
                if (hit.distance < distance)
                {
                    distance = hit.distance;
                    target = hit.GetEntity();
                }
            }
            return target;
        }

        void SendHelpText(BasePlayer player)
        {
            if (hasAccess(player))
                SendReply(player, helpProd);
        }
    }
}

// --- End of file: Prod.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AutoSaver.cs ---
// --- Original Local Path: AutoSaver.cs ---

using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("AutoSaver", "walkinrey", "1.0.0")]
    [Description("Сохраняет сервер прежде чем он выключится :)")]
    class AutoSaver : RustPlugin
    {
        void OnServerShutdown() => covalence.Server.Command("save");
    }
}

// --- End of file: AutoSaver.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TwigsDecay.cs ---
// --- Original Local Path: TwigsDecay.cs ---

using System;
using System.Collections.Generic;
using System.Reflection;
using System.Text;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("TwigsDecay", "Wulf/lukespragg/Nogrod", "2.0.1", ResourceId = 857)]
    class TwigsDecay : RustPlugin
    {
        private readonly FieldInfo entityListField = typeof(BaseNetworkable.EntityRealm).GetField("entityList", BindingFlags.Instance | BindingFlags.NonPublic);
        private readonly FieldInfo decayTimer = typeof(DecayEntity).GetField("decayTimer", BindingFlags.Instance | BindingFlags.NonPublic);
        private readonly FieldInfo decayDelayTime = typeof(DecayEntity).GetField("decayDelayTime", BindingFlags.Instance | BindingFlags.NonPublic);
        private readonly Dictionary<string, float> damage = new Dictionary<string, float>();
        private readonly Dictionary<BuildingGrade.Enum, float> damageGrade = new Dictionary<BuildingGrade.Enum, float>();
        int timespan;
        bool ignoreAlivePlayers;
        bool ignoreDecayTimer;
        private readonly HashSet<string> blocks = new HashSet<string>();
        private readonly HashSet<ulong> activePlayers = new HashSet<ulong>();

        // A list of all translateable texts
        private readonly List<string> texts = new List<string>()
        {
            "Gate",
            "Twigs",
            "Wood",
            "Stone",
            "Metal",
            "TopTier",
            "Barricade",
            "Ladder",
            "%GRADE% buildings decay by %DAMAGE% HP per %TIMESPAN% minutes.",
            "%GRADE% buildings do not decay."
        };

        private readonly Dictionary<string, string> messages = new Dictionary<string, string>();

        protected override void LoadDefaultConfig()
        {
            var damage = new Dictionary<string, object>() {
                {"Gate"     , 0}, // health: 2000
                {"Wall"     , 0}, // health: 2000
                {"Twigs"    , 1}, // health: 5
                {"Wood"     , 0}, // health: 250
                {"Stone"    , 0}, // health: 500
                {"Metal"    , 0}, // health: 200
                {"TopTier"  , 0}, // health: 1000
                {"Barricade", 0}, // health: 350, 400, 500
                {"Ladder"   , 0}  // health: 50
            };
            Config["ignoreAlivePlayers"] = true;
            Config["ignoreDecayTimer"] = false;
            Config["damage"] = damage;
            Config["timespan"] = 288;
            var blocks = new List<object>
            {
                //"block.halfheight",
                //"block.halfheight.slanted",
                "block.stair.lshape",
                "block.stair.ushape",
                "floor",
                "floor.triangle",
                "foundation",
                "foundation.steps",
                "foundation.triangle",
                "pillar",
                "roof",
                "wall",
                "wall.doorway",
                //"door.hinged",
                "wall.external.high.wood",
                "wall.external.high.stone",
                "wall.low",
                "wall.window",
                "wall.window.bars"
            };
            Config["blocks"] = blocks;
            var messages = new Dictionary<string, object>();
            foreach (var text in texts)
            {
                if (messages.ContainsKey(text))
                    Puts("{0}: {1}", Title, "Duplicate translation string: " + text);
                else
                    messages.Add(text, text);
            }
            Config["messages"] = messages;
        }

        void Init()
        {
            if (ConVar.Decay.scale > 0f)
            {
                ConVar.Decay.scale = 0f;
                Puts("{0}: {1}", Title, "Default decay has been disabled");
            }
        }

        void OnServerInitialized()
        {
            LoadConfig();
            try
            {
                var damageConfig = (Dictionary<string, object>)Config["damage"];
                foreach (var cfg in damageConfig)
                {
                    float val = (val = Convert.ToSingle(cfg.Value)) >= 0 ? val : 0;
                    try
                    {
                        var grade = (BuildingGrade.Enum)Enum.Parse(typeof (BuildingGrade.Enum), cfg.Key, false);
                        damageGrade.Add(grade, val);
                    }
                    catch (Exception)
                    {
                        damage.Add(cfg.Key, val);
                    }
                }
                timespan = Convert.ToInt32(Config["timespan"]);
                if (timespan < 0)
                    timespan = 15;
                ignoreAlivePlayers = Convert.ToBoolean(Config["ignoreAlivePlayers"]);
                ignoreDecayTimer = Convert.ToBoolean(Config["ignoreDecayTimer"]);
                var blocksConfig = (List<object>)Config["blocks"];
                foreach (var cfg in blocksConfig)
                    blocks.Add(Convert.ToString(cfg));
                var customMessages = (Dictionary<string, object>)Config["messages"];
                if (customMessages != null)
                    foreach (var pair in customMessages)
                        messages[pair.Key] = Convert.ToString(pair.Value);
                timer.Every(timespan*60, OnTimer);
            }
            catch (Exception ex)
            {
                PrintError("{0}: {1}", Title, "Failed to load configuration file: " + ex.Message);
            }
        }

        void OnTimer()
        {
            var started = Interface.Oxide.Now;
            int blocksDecayed = 0;
            int blocksDestroyed = 0;
            int barricadesDecayed = 0;
            int barricadesDestroyed = 0;
            int laddersDecayed = 0;
            int laddersDestroyed = 0;
            int gatesDecayed = 0;
            int gatesDestroyed = 0;
            int wallDecayed = 0;
            int wallDestroyed = 0;

            float barricadeAmount;
            damage.TryGetValue("Barricade", out barricadeAmount);
            float ladderAmount;
            damage.TryGetValue("Ladder", out ladderAmount);
            float gateAmount;
            damage.TryGetValue("Gate", out gateAmount);
            float wallAmount;
            damage.TryGetValue("Wall", out wallAmount);

            if (ignoreAlivePlayers)
            {
                activePlayers.Clear();
                foreach (var player in BasePlayer.activePlayerList)
                    activePlayers.Add(player.userID);
                foreach (var player in BasePlayer.sleepingPlayerList)
                    activePlayers.Add(player.userID);
            }

            var entities = ((ListDictionary<uint, BaseNetworkable>)entityListField.GetValue(BaseNetworkable.serverEntities)).Values;
            var kill = new List<BaseNetworkable>();
            foreach (var entity in entities)
            {
                if (entity.isDestroyed) continue;
                if (entity is BuildingBlock)
                {
                    var block = (BuildingBlock) entity;
                    if (!blocks.Contains(Utility.GetFileNameWithoutExtension(block.PrefabName)))
                        continue;
                    float amount;
                    if (!damageGrade.TryGetValue(block.grade, out amount) || amount <= 0) continue;
                    ++blocksDecayed;
                    if (!decay(block, amount))
                    {
                        kill.Add(entity);
                        ++blocksDestroyed;
                    }
                } else if (entity is Barricade)
                {
                    if (barricadeAmount <= 0) continue;
                    ++barricadesDecayed;
                    if (!decay((Barricade) entity, barricadeAmount))
                    {
                        kill.Add(entity);
                        ++barricadesDestroyed;
                    }
                }
                else if (entity is BaseCombatEntity)
                {
                    var combat = (BaseCombatEntity)entity;
                    var prefab = Utility.GetFileNameWithoutExtension(combat.PrefabName);
                    if (ladderAmount > 0 && prefab.StartsWith("ladder"))
                    {
                        ++laddersDecayed;
                        if (!decay(combat, ladderAmount))
                        {
                            kill.Add(entity);
                            ++laddersDestroyed;
                        }
                    }
                    else if (gateAmount > 0 && prefab.StartsWith("gates.external"))
                    {
                        ++gatesDecayed;
                        if (!decay(combat, gateAmount))
                        {
                            kill.Add(entity);
                            ++gatesDestroyed;
                        }
                    }
                    else if (wallAmount > 0 && prefab.StartsWith("wall.external"))
                    {
                        ++wallDecayed;
                        if (!decay(combat, wallAmount))
                        {
                            kill.Add(entity);
                            ++wallDestroyed;
                        }
                    }
                }
            }
            foreach (var networkable in kill)
                networkable.KillMessage();

            Puts($"Decayed {blocksDecayed} blocks ({blocksDestroyed} destroyed), {barricadesDecayed} barricades ({barricadesDestroyed} destroyed) and {gatesDecayed} gates ({gatesDestroyed} destroyed) and {wallDecayed} walls ({wallDestroyed} destroyed) and {laddersDecayed} ladders ({laddersDestroyed} destroyed)");
            Puts("Took: {0}", Interface.Oxide.Now - started);
        }

        void SendHelpText(BasePlayer player)
        {
            var sb = new StringBuilder();
            foreach (var dmg in damage)
            {
                if (dmg.Value > 0)
                    sb.Append("  ").Append(_("%GRADE% buildings decay by %DAMAGE% HP per %TIMESPAN% minutes.", new Dictionary<string, string> {
                        { "GRADE", _(dmg.Key) },
                        { "DAMAGE", dmg.Value.ToString() },
                        { "TIMESPAN", timespan.ToString() }
                    })).Append("\n");
                else
                    sb.Append("  ").Append(_("%GRADE% buildings do not decay.", new Dictionary<string, string>() {
                        { "GRADE", _(dmg.Key) }
                    })).Append("\n");
            }
            player.ChatMessage(sb.ToString().TrimEnd());
        }

        // Translates a string
        string _(string text, Dictionary<string, string> replacements = null)
        {
            if (messages.ContainsKey(text) && messages[text] != null)
                text = messages[text];
            if (replacements != null)
                foreach (var replacement in replacements)
                    text = text.Replace("%" + replacement.Key + "%", replacement.Value);
            return text;
        }

        // Decays an entity, returns false if destroyed
        private bool decay(BaseCombatEntity entity, float amount)
        {
            var decay = entity as DecayEntity;
            if (!ignoreDecayTimer && decay != null && (float)decayTimer.GetValue(decay) < (float)decayDelayTime.GetValue(decay)) return true;
            if (entity.OwnerID == 0 || ignoreAlivePlayers && activePlayers.Contains(entity.OwnerID)) return true;
            //if (decay != null && !decay.enabled) return true;
            entity.health -= amount;
            if (entity.health <= 0f)
                return false;
            entity.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            return true;
        }
    }
}


// --- End of file: TwigsDecay.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PumpkinBombs.cs ---
// --- Original Local Path: PumpkinBombs.cs ---

using System.Collections.Generic;
using UnityEngine;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("PumpkinBombs", "k1lly0u", "0.1.1", ResourceId = 2070)]
    class PumpkinBombs : RustPlugin
    {
        #region Fields
        private const string Jack1 = "jackolantern.angry";
        private const string Jack2 = "jackolantern.happy";
        private Dictionary<string, ItemDefinition> ItemDefs;
        private List<ulong> craftedBombs;
        #endregion

        #region Oxide Hooks
        void Loaded()
        {
            permission.RegisterPermission("pumpkinbombs.use", this);
            permission.RegisterPermission("pumpkinbombs.free", this);
            lang.RegisterMessages(Messages, this);
            craftedBombs = new List<ulong>();
        }
        void OnServerInitialized()
        {
            LoadVariables();
            ItemDefs = ItemManager.itemList.ToDictionary(i => i.shortname);
        }
        void OnPlayerDisconnected(BasePlayer player)
        {
            if (craftedBombs.Contains(player.userID))
            {
                if (player != null)
                {
                    foreach (var item in configData.CraftingCosts)
                        player.inventory.GiveItem(ItemManager.CreateByItemID(item.itemid, item.amount));
                }
                craftedBombs.Remove(player.userID);
            }
        }
        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity is BaseOven)
            {
                if (entity.ShortPrefabName == "jackolantern.happy" || entity.ShortPrefabName == "jackolantern.angry")
                {
                    var jack = entity.GetComponent<BaseOven>();
                    if (craftedBombs.Contains(jack.OwnerID))
                    {
                        jack.gameObject.AddComponent<BombLight>();
                        var expEnt = GameManager.server.CreateEntity("assets/prefabs/tools/c4/explosive.timed.deployed.prefab", jack.transform.position, new Quaternion(), true);
                        TimedExplosive explosive = expEnt.GetComponent<TimedExplosive>();
                        explosive.timerAmountMax = configData.ExplosiveSettings.DetonationTimer;
                        explosive.timerAmountMin = configData.ExplosiveSettings.DetonationTimer;
                        explosive.explosionRadius = configData.ExplosiveSettings.ExplosionRadius;
                        explosive.damageTypes = new List<Rust.DamageTypeEntry>
                        {
                            new Rust.DamageTypeEntry {amount = configData.ExplosiveSettings.DamageAmount, type = Rust.DamageType.Explosion }
                        };
                        explosive.Spawn();
                        craftedBombs.Remove(jack.OwnerID);
                    }
                }
            }
        }
        #endregion

        #region Helpers
        bool CanUse(BasePlayer player) => permission.UserHasPermission(player.UserIDString, "pumpkinbombs.use") || player.IsAdmin();
        bool IsFree(BasePlayer player) => permission.UserHasPermission(player.UserIDString, "pumpkinbombs.free");
        private bool HasEnoughRes(BasePlayer player, int itemid, int amount) => player.inventory.GetAmount(itemid) >= amount;
        private void TakeResources(BasePlayer player, int itemid, int amount) => player.inventory.Take(null, itemid, amount);
        #endregion

        #region Classes
        class BombLight : MonoBehaviour
        {
            bool isOn;
            public void Awake()
            {
                isOn = false;
                InvokeRepeating("StartLight", 0.5f, 0.5f);
            }

            public void OnDestroy()
            {
                CancelInvoke("StartLight");
                Destroy(gameObject);
            }

            private void StartLight()
            {
                if (isOn)
                {
                    GetComponent<BaseOven>().SetFlag(BaseEntity.Flags.On, false);
                    isOn = false;
                }
                else
                {
                    GetComponent<BaseOven>().SetFlag(BaseEntity.Flags.On, true);
                    isOn = true;
                }
            }            
        }
        #endregion

        #region Chat Commands
        [ChatCommand("pb")]
        void cmdPB(BasePlayer player, string command, string[] args)
        {
            if (!CanUse(player)) return;
            if (craftedBombs.Contains(player.userID))
            {
                if (!HasEnoughRes(player, -1284735799, 1))
                {
                    SendReply(player, $"{configData.Messaging.Main}{msg("lostBomb", player.UserIDString)}</color>");
                    craftedBombs.Remove(player.userID);
                    return;
                }
                SendReply(player, $"{configData.Messaging.Main}{msg("alreadyhave", player.UserIDString)}</color>");
                return;
            }
            if (!IsFree(player))
            {
                bool canCraft = true;
                foreach (var item in configData.CraftingCosts)
                {
                    if (!HasEnoughRes(player, item.itemid, item.amount)) { canCraft = false; break; }
                }
                if (canCraft)
                {
                    foreach (var item in configData.CraftingCosts)
                        TakeResources(player, item.itemid, item.amount);
                }
                else
                {
                    SendReply(player, $"{configData.Messaging.Main}{msg("noRes", player.UserIDString)}</color>");
                    foreach (var item in configData.CraftingCosts)
                        SendReply(player, $"{configData.Messaging.Main}{item.amount}x {ItemDefs[item.shortname].displayName.english}</color>");
                    return;
                }
            }
            craftedBombs.Add(player.userID);
            player.inventory.GiveItem(ItemManager.CreateByItemID(-1284735799, 1));
            SendReply(player, $"{configData.Messaging.Main}{msg("readyMsg", player.UserIDString)}</color>");
        }
        #endregion

        #region Config 
        class CraftCost
        {
            public string shortname;
            public int itemid;
            public int amount;
        }
        class Explosive
        {
            public int DetonationTimer { get; set; }
            public float ExplosionRadius { get; set; }
            public float DamageAmount { get; set; }
        }
        class Messaging
        {
            public string Main { get; set; }
        }
        private ConfigData configData;
        class ConfigData
        {
            public Explosive ExplosiveSettings { get; set; }
            public List<CraftCost> CraftingCosts { get; set; }
            public Messaging Messaging { get; set; }
            
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                CraftingCosts = new List<CraftCost>
                {
                    new CraftCost
                    {
                        amount = 1,
                        itemid = 498591726,
                        shortname = "explosive.timed"
                    },
                    new CraftCost
                    {
                        amount = 1,
                        itemid = -225085592,
                        shortname = "pumpkin"
                    }
                },
                ExplosiveSettings = new Explosive
                {
                    DetonationTimer = 10,
                    ExplosionRadius = 10,
                    DamageAmount = 550
                },                
                Messaging = new Messaging
                {
                    Main = "<color=orange>"
                }
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Messaging
        string msg(string key, string id = null) => lang.GetMessage(key, this, id);
        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            {"readyMsg","Your pumpkin bomb is ready. Simply place the Jack'O'Lantern you just received on the floor to activate it" },
            { "noRes","You do not have enough resources to create a pumpkin bomb. You will need the following;"},
            {"alreadyhave", "You already have a pumpkin bomb ready for deployment" },
            {"lostBomb", "It seems you have lost your bomb. Now you must create a new one..." }
        };
        #endregion
    }
}


// --- End of file: PumpkinBombs.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ComponentBlocker.cs ---
// --- Original Local Path: ComponentBlocker.cs ---

using System;
using System.Text;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("ComponentBlocker", "Calytic", "0.1.2", ResourceId = 1382)]
    class ComponentBlocker : RustPlugin
    {
        List<string> blockList = new List<string>();
        List<string> blockCache = new List<string>();

        bool enabled = false;
        bool craftRefund = true;
        private bool sendMessages = true;

        private Dictionary<string, string> messages = new Dictionary<string, string>();

        private List<string> texts = new List<string>() {
            "You are not allowed to use this command",
            "You may not research this (restricted), blueprints refunded!",
            "You may not research this (restricted)",
            "You may not craft this (restricted)",
            "You may not deploy this (restricted)",
            "You may not pick that up (restricted)"
        };

        void OnServerInitialized()
        {
            blockList = GetConfig<List<string>>("blockList", new List<string>());
            sendMessages = GetConfig<bool>("sendMessages", true);
            craftRefund = GetConfig<bool>("craftRefund", true);
            Config["blockList"] = blockList;

            Dictionary<string, object> customMessages = GetConfig<Dictionary<string, object>>("messages", null);
            if (customMessages != null)
            {
                foreach (KeyValuePair<string, object> kvp in customMessages)
                {
                    messages[kvp.Key] = kvp.Value.ToString();
                }
            }

            LoadData();

            timer.Once(1f, delegate()
            {
                enabled = true;
            });
        }

        void LoadData()
        {
            if (this.Config["VERSION"] == null)
            {
                // FOR COMPATIBILITY WITH INITIAL VERSIONS WITHOUT VERSIONED CONFIG
                ReloadConfig();
            }
            else if (this.GetConfig<string>("VERSION", this.Version.ToString()) != this.Version.ToString())
            {
                // ADDS NEW, IF ANY, CONFIGURATION OPTIONS
                ReloadConfig();
            }
        }

        void LoadDefaultConfig() 
        {
            Dictionary<string, object> messages = new Dictionary<string, object>();

            foreach (string text in texts)
            {
                if (messages.ContainsKey(text))
                {
                    PrintWarning("Duplicate translation string: " + text);
                }
                else
                {
                    messages.Add(text, text);
                }
            }

            Config["messages"] = messages;
            Config["sendMessages"] = true;
            Config["craftRefund"] = true;
            Config["blockList"] = new List<string>();
            Config["VERSION"] = this.Version.ToString();
        }

        protected void ReloadConfig()
        {
            Dictionary<string, object> messages = new Dictionary<string, object>();

            foreach (string text in texts)
            {
                if (!messages.ContainsKey(text))
                {
                    messages.Add(text, text);
                }
            }

            Config["messages"] = messages;
            Config["VERSION"] = this.Version.ToString();

            // NEW CONFIGURATION OPTIONS HERE
            Config["craftRefund"] = true;
            // END NEW CONFIGURATION OPTIONS

            PrintWarning("Upgrading Configuration File");
            SaveConfig();
        }

        private void SendHelpText(BasePlayer player)
        {
            if (player.net.connection.authLevel < 1)
            {
                return;
            }

            var sb = new StringBuilder()
               .Append("ComponentBlocker by <color=#ce422b>http://rustservers.io</color>\n")
               .Append("  ").Append("<color=\"#ffd479\">/blocker \"name\"</color> - Adds or removes item/entity to/from blocklist").Append("\n");
            player.ChatMessage(sb.ToString());
        }

        [ChatCommand("listinv")]
        private void cmdListInv(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel < 1)
            {
                return;
            }

            List<string> prefabs = new List<string>();

            foreach (Item item in player.inventory.containerMain.itemList)
            {
                if (item.info.itemMods.Length > 0)
                {
                    foreach (ItemMod itemMod in item.info.itemMods)
                    {
                        prefabs.Add(itemMod.name);
                    }
                }
            }

            player.ConsoleMessage("Inventory item prefabs:");
            player.ConsoleMessage(string.Join("\n", prefabs.ToArray()));
            SendReply(player, "Press F1 and open console");
        }

        [ChatCommand("clearblocklist")]
        private void cmdClearBlockList(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel < 1)
            {
                return;
            }

            blockList.Clear();
            blockCache.Clear();
            SaveConfig();
            SendReply(player, "Blocklist cleared");
        }

        [ChatCommand("blocklist")]
        private void cmdBlockList(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel < 1)
            {
                return;
            }

            string[] list = blockList.ToArray();
            player.ConsoleMessage("CURRENT BLOCKLIST:");
            player.ConsoleMessage(string.Join(", ", list));
            SendReply(player, "Press F1 and open console");
        }

        [ChatCommand("blocker")]
        private void cmdBlock(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel < 1)
            {
                return;
            }

            if (args.Length == 1)
            {
                string name = args[0];
                if (blockList.Contains(name))
                {
                    blockList.Remove(name);
                    blockCache.Remove(name);
                    SaveConfig();
                    player.ChatMessage(name + " removed from block list");
                }
                else
                {
                    blockList.Add(name);
                    SaveConfig();
                    player.ChatMessage(name + " added to block list");
                }
            }
            else
            {
                player.ChatMessage("Invalid Syntax.  /blocker \"name\"");
            }
        }

        [ConsoleCommand("blocker")]
        void ccBlock(ConsoleSystem.Arg arg)
        {
            if (arg.connection != null && arg.connection.authLevel < 1)
            {
                return;
            }

            if (arg.Args.Length == 1)
            {
                string name = arg.Args[0];
                if (blockList.Contains(name))
                {
                    blockList.Remove(name);
                    SaveConfig();
                    SendReply(arg, name + " removed from block list");
                }
                else
                {
                    blockList.Add(name);
                    SaveConfig();
                    SendReply(arg, name + " added to block list");
                }
            }
            else
            {
                SendReply(arg, "Invalid Syntax.  blocker \"name\"");
            }
        }

        void AddBlock(string name)
        {
            if (!blockList.Contains(name))
            {
                blockList.Add(name);
            }
        }

        void RemoveBlock(string name)
        {
            if (blockList.Contains(name))
            {
                blockList.Remove(name);
            }
        }

        bool IsBlocking(string name)
        {
            return blockList.Contains(name);
        }

        T GetConfig<T>(string key, T defaultValue)
        {
            try
            {
                var val = Config[key];
                if (val == null)
                    return defaultValue;
                if (val is List<object>)
                {
                    var t = typeof(T).GetGenericArguments()[0];
                    if (t == typeof(String))
                    {
                        var cval = new List<string>();
                        foreach (var v in val as List<object>)
                            cval.Add((string)v);
                        val = cval;
                    }
                    else if (t == typeof(int))
                    {
                        var cval = new List<int>();
                        foreach (var v in val as List<object>)
                            cval.Add(Convert.ToInt32(v));
                        val = cval;
                    }
                }
                else if (val is Dictionary<string, object>)
                {
                    var t = typeof(T).GetGenericArguments()[1];
                    if (t == typeof(int))
                    {
                        var cval = new Dictionary<string, int>();
                        foreach (var v in val as Dictionary<string, object>)
                            cval.Add(Convert.ToString(v.Key), Convert.ToInt32(v.Value));
                        val = cval;
                    }
                    else if (t == typeof(List<object>) || t == typeof(List<string>))
                    {
                        var cval = new Dictionary<string, List<string>>();
                        foreach(var v in val as Dictionary<string, object>) {
                            if (v.Value is List<object>)
                            {
                                var clist = new List<string>();
                                foreach (object str in (List<object>)v.Value)
                                {
                                    clist.Add(str.ToString());
                                }
                                cval.Add(v.Key.ToString(), clist);
                            }
                        }
                        val = cval;
                    }
                }
                return (T)Convert.ChangeType(val, typeof(T));
            }
            catch (Exception ex)
            {
                return defaultValue;
            }
        }

        void OnPlayerInit(BasePlayer player)
        {
            if (!enabled) return;
            //this.CheckBlueprints(player);
        }

        object OnItemCraft(ItemCraftTask task)
        {
            if (!enabled) return null;
            ItemDefinition def = task.blueprint.targetItem;

            if (isBlocked(def.displayName.english, def.shortname))
            {
                task.cancelled = true;
                if (craftRefund)
                {
                    RefundIngredients(task.blueprint, task.owner, task.amount);
                }
                if (sendMessages)
                    SendReply(task.owner, messages["You may not craft this (restricted)"]);

                return false;
            }

            return null;
        }

        private void RefundIngredients(ItemBlueprint bp, BasePlayer player, int amount = 1)
        {
            using (List<ItemAmount>.Enumerator enumerator = bp.ingredients.GetEnumerator())
            {
                while (enumerator.MoveNext())
                {
                    ItemAmount current = enumerator.Current;

                    Item i = ItemManager.CreateByItemID(current.itemid, Convert.ToInt32(current.amount) * amount);
                    if (!i.MoveToContainer(player.inventory.containerMain))
                    {
                        i.Drop(player.eyes.position, player.eyes.BodyForward() * 2f);
                    }
                }
            }
        }

        void OnEntitySpawned(BaseNetworkable networkable)
        {
            if (!enabled) return;
            if (!CheckNetworkable(networkable))
            {
                var container = networkable as LootContainer;
                if (container == null)
                    return;
                if (container.inventory == null || container.inventory.itemList == null)
                {
                    return;
                }

                foreach (Item item in container.inventory.itemList)
                {
                    CheckItem(item);
                }
            }
        }

        void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            if (!enabled) return;
            CheckItem(item);
        }

        void OnItemDeployed(Deployer deployer, BaseEntity entity)
        {
            if (!enabled) return;
            if (CheckNetworkable(entity))
            {
                if(sendMessages)
                    SendReply(deployer.GetOwnerPlayer(), messages["You may not deploy this (restricted)"]);
            }
        }

        void OnCollectiblePickup(Item item, BasePlayer player)
        {
            if (!enabled) return;
            if (CheckItem(item))
            {
                if(sendMessages)
                    SendReply(player, messages["You may not pick that up (restricted)"]);
            }
        }

        //void OnBlueprintReveal(Item item, Item revealed, BasePlayer player)
        //{
            
        //    if (!enabled) return;
        //    ItemMod[] mods = item.info.itemMods;
        //    //if (CheckItem(revealed))
        //    //{
        //        // REFUND BLUEPRINT FRAGMENT/PAGE/BOOK/LIBRARY
        //        timer.Once(0.1f, delegate()
        //        {
        //            if (item.info.itemid == 1351589500)
        //            {
        //                player.inventory.GiveItem(ItemManager.Create(item.info.itemid, 20));
        //            }
        //            else
        //            {
        //                player.inventory.GiveItem(ItemManager.Create(item.info.itemid, 1));
        //            }
        //        });
                
        //        if(sendMessages)
        //            SendReply(player, messages["You may not research this (restricted), blueprints refunded!"]);
        //    //}
        //}

        void OnPlantGather(PlantEntity plant, Item item, BasePlayer player)
        {
            if (!enabled) return;
            if (CheckItem(item))
            {
                if(sendMessages)
                    SendReply(player, messages["You may not pick that up (restricted)"]);
            }
        }

        void OnQuarryGather(MiningQuarry quarry, Item item)
        {
            if (!enabled) return;
            CheckItem(item);
        }

        //private void CheckBlueprints(BasePlayer player)
        //{
        //    if (player.net == null)
        //    {
        //        return;
        //    }

        //    if (player.net.connection == null)
        //    {
        //        return;
        //    }

        //    if (SingletonComponent<ServerMgr>.Instance == null)
        //    {
        //        return;
        //    }

        //    if (SingletonComponent<ServerMgr>.Instance.persistance == null)
        //    {
        //        return;
        //    }

        //    bool removed = false;
        //    ProtoBuf.PersistantPlayer persistentPlayer = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerInfo(player.userID);

        //    if (persistentPlayer is ProtoBuf.PersistantPlayer)
        //    {
        //        foreach (string blocked in this.blockList)
        //        {
        //            ItemDefinition item = ItemManager.FindItemDefinition(blocked);
        //            if (item is ItemDefinition && persistentPlayer.blueprints is ProtoBuf.BlueprintList && persistentPlayer.blueprints.complete is List<int> && persistentPlayer.blueprints.complete.Contains(item.itemid))
        //            {
        //                persistentPlayer.blueprints.complete.Remove(item.itemid);
        //                removed = true;
        //            }
        //        }

        //        if (removed)
        //        {
        //            PlayerBlueprints.InitializePersistance(persistentPlayer);
        //            SingletonComponent<ServerMgr>.Instance.persistance.SetPlayerInfo(player.userID, persistentPlayer);
        //            player.SendFullSnapshot();
        //        }
        //    }
        //}

        private bool CheckItem(Item item)
        {
            List<string> properties = new List<string>();

            if (item.info != null)
            {
                if (item.info.shortname != null)
                {
                    properties.Add(item.info.shortname);
                }

                if (item.info.displayName is Translate.Phrase && item.info.displayName.english != null)
                {
                    properties.Add(item.info.displayName.english);
                }

                properties.Add(item.info.itemid.ToString());

                if (item.info.itemMods.Length > 0)
                {
                    foreach (ItemMod itemMod in item.info.itemMods)
                    {
                        if (!properties.Contains(itemMod.name))
                        {
                            properties.Add(itemMod.name);
                            break;
                        }
                    }
                }
            }

            if (properties.Count > 0 && isBlocked(properties.ToArray()))
            {
                item.Remove(0f);
                item.RemoveFromContainer();
                return true;
            }

            return false;
        }

        private bool CheckNetworkable(BaseNetworkable networkable)
        {
            if (isBlocked(networkable.name, networkable.PrefabName, networkable.ShortPrefabName))
            {
                networkable.Kill();
                return true;
            }

            return false;
        }

        object OnStructureUpgrade(BuildingBlock block, BasePlayer player, BuildingGrade.Enum grade)
        {
            if (grade == BuildingGrade.Enum.Wood && isBlocked("structure.wood"))
            {
                if (sendMessages)
                    SendReply(player, messages["You may not deploy this (restricted)"]);

                return true;
            }
            else if (grade == BuildingGrade.Enum.Stone && isBlocked("structure.stone"))
            {
                if (sendMessages)
                    SendReply(player, messages["You may not deploy this (restricted)"]);

                return true;
            }
            else if (grade == BuildingGrade.Enum.Metal && isBlocked("structure.metal"))
            {
                if (sendMessages)
                    SendReply(player, messages["You may not deploy this (restricted)"]);

                return true;
            }
            else if (grade == BuildingGrade.Enum.TopTier && isBlocked("structure.armored"))
            {
                if (sendMessages)
                    SendReply(player, messages["You may not deploy this (restricted)"]);

                return true;
            }

            return null;
        }

        private bool isBlocked(params string[] names) 
        {
            foreach (string name in names)
            {
                if (blockCache.Contains(name))
                {
                    return true;
                }
            }

            foreach (string blocked in blockList)
            {
                foreach (string name in names)
                {
                    if (name.Contains(blocked))
                    {
                        blockCache.Add(name);
                        return true;
                    }
                }
            }

            return false;
        }
    }
}


// --- End of file: ComponentBlocker.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HitMarker.cs ---
// --- Original Local Path: HitMarker.cs ---

﻿// Reference: System.Drawing
using Facepunch;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using System;
using System.Collections.Generic;
using UnityEngine;
using Random = System.Random;
using Time = UnityEngine.Time;

namespace Oxide.Plugins
{
    [Info("HitMarker", "Rust-Plugin.ru", "1.0.2")]
    class HitMarker : RustPlugin
    {
        #region CONFIGURATION

        private bool Changed;
        private bool enablesound;
        private string soundeffect;
        private string headshotsoundeffect;
        private float damageTimeout;
		
        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }        

        protected override void LoadDefaultConfig()
        {
            enablesound = Convert.ToBoolean( GetConfig( "Sound", "EnableSoundEffect", true ) );
            soundeffect =
                Convert.ToString( GetConfig( "Sound", "Sound Effect", "assets/bundled/prefabs/fx/takedamage_hit.prefab" ) );
            headshotsoundeffect =
                Convert.ToString( GetConfig( "Sound", "HeadshotSoundEffect", "assets/bundled/prefabs/fx/headshot.prefab" ) );
            GetVariable(Config, "Через сколько будет пропадать урон", out damageTimeout, 0.5f );
            SaveConfig();
        }
        public static void GetVariable<T>( DynamicConfigFile config, string name, out T value, T defaultValue )
        {
            config[ name ] = value = config[ name ] == null ? defaultValue : (T) Convert.ChangeType( config[ name ], typeof( T ) );
        }
        #endregion
        
        #region FIELDS

        [PluginReference] private Plugin Clans;
        
		Random rnd = new Random();
		
        List<BasePlayer> hitmarkeron = new List<BasePlayer>();

        Dictionary<BasePlayer, List<KeyValuePair<float, HitNfo>>> damageHistory = new Dictionary<BasePlayer, List<KeyValuePair<float, HitNfo>>>();

		class HitNfo
		{
			public int damage;
			public bool isHead;
			public bool isFriend;
			public double xs;
			public double ys;
			public double xe;
			public double ye;
			public int num;
		}
		
        Dictionary<BasePlayer, Oxide.Plugins.Timer> destTimers = new Dictionary<BasePlayer, Oxide.Plugins.Timer>();
        #endregion

        #region COMMANDS

        [ChatCommand("hitmarker")]
        void cmdHitMarker(BasePlayer player, string cmd, string[] args)
        {
            if (!hitmarkeron.Contains(player))
            {
                hitmarkeron.Add(player);
                SendReply(player,
                    "<color=cyan>HitMarker</color>:" + " " + "<color=orange>Вы включили показ урона.</color>");
            }
            else
            {
                hitmarkeron.Remove(player);
                SendReply(player,
                    "<color=cyan>HitMarker</color>:" + " " + "<color=orange>Вы отключили показ урона.</color>");
            }
        }

        #endregion

        #region OXIDE HOOKS

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                hitmarkeron.Remove(player);
                damageHistory.Remove(player);
            }
        }

        void OnServerInitialized()
        {            
            LoadDefaultConfig();
            foreach (BasePlayer current in BasePlayer.activePlayerList)
            {
                hitmarkeron.Add(current);
            }            
            timer.Every(0.1f, OnDamageTimer);
        }        

        void OnPlayerInit(BasePlayer player)
        {
            hitmarkeron.Add(player);
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            hitmarkeron.Remove(player);
            damageHistory.Remove(player);
        }
        void OnPlayerAttack(BasePlayer attacker, HitInfo hitinfo)
        {
            var victim = hitinfo.HitEntity as BasePlayer;
            if (victim && hitmarkeron.Contains(attacker))
            {                
                if (hitinfo.isHeadshot)
                {
                    if (enablesound == true)
                    {
                        Effect.server.Run(headshotsoundeffect, attacker.transform.position, Vector3.zero,
                            attacker.net.connection);
                    }
                }
                else
                {
                    if (enablesound)
                    {
                        Effect.server.Run(soundeffect, attacker.transform.position, Vector3.zero,
                            attacker.net.connection);
                    }
                }
            }
        }

        string DamageGUI = "[{\"name\":\"hitmarkerDamage{0}\",\"parent\":\"Hud\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{1}\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 1\",\"distance\":\"0.3 -0.3\"},{\"type\":\"RectTransform\",\"anchormin\":\"{2} {3}\",\"anchormax\":\"{4} {5}\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]}]" ;
		string ActionGUI = "[{\"name\":\"hitmarkerAction{0}\",\"parent\":\"Hud\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{1}\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 1\",\"distance\":\"0.3 -0.3\"},{\"type\":\"RectTransform\",\"anchormin\":\"{2} {3}\",\"anchormax\":\"{4} {5}\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]}]" ;        
		
        string HandleArgs( string json, params object[] args )
        {
            for (int i = 0; i < args.Length; i++)
                json = json.Replace( "{" + i + "}", args[ i ].ToString() );
            return json;
        }
        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            var victim = entity as BasePlayer;
            if (victim == null || hitInfo == null) return;
            DamageType type = hitInfo.damageTypes.GetMajorityDamageType();
            var attacker = hitInfo.InitiatorPlayer;
            if (attacker == null) return;
			
			var isHead = hitInfo.isHeadshot;
			bool isFriend = (Clans?.Call("HasFriend", attacker.userID, (victim as BasePlayer).userID) as bool?) ?? false;
            NextTick(() =>
            {
                var damage =
                    System.Convert.ToInt32(Math.Round(hitInfo.damageTypes.Total(), 0, MidpointRounding.AwayFromZero));
                DamageNotifier(attacker, damage, isHead, isFriend);
            });
        }

        void OnPlayerWound( BasePlayer player )
        {
            var attacker = player?.lastAttacker as BasePlayer;
            if (attacker == null) return;

            DestroyLastCui( attacker );

			var deltaX = GetRandomX();
			var deltaY = GetRandomY();
			
			var rn = rnd.Next(0, 10000);
			
            CuiHelper.AddUi( attacker,
                HandleArgs( ActionGUI, rn, GetDamageText("wound"), 0.4919792+deltaX, 0.4531481+deltaY, 0.675+deltaX, 0.5587038+deltaY ) );
            destTimers[ attacker ] = timer.Once(damageTimeout, () =>
            {
                CuiHelper.DestroyUi( attacker, "hitmarkerAction" +rn.ToString() );
            } );
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            var player = entity as BasePlayer;
            if (player == null) return;
            var attacker = info?.Initiator as BasePlayer;
            if (attacker == null) return;

            DestroyLastCui(attacker);

			var deltaX = GetRandomX();
			var deltaY = GetRandomY();
			
			var rn = rnd.Next(0, 10000);
			
            CuiHelper.AddUi( attacker,
                HandleArgs( ActionGUI, rn, GetDamageText("kill"), 0.4919792+deltaX, 0.4531481+deltaY, 0.675+deltaX, 0.5587038+deltaY ) );
            destTimers[ attacker ] = timer.Once(damageTimeout, () =>
            {
                CuiHelper.DestroyUi( attacker, "hitmarkerAction" +rn.ToString() );
            } );
        }
        #endregion

        #region Core

        void OnDamageTimer()
        {            
            var toRemove = Pool.GetList<BasePlayer>(); 
            foreach (var dmgHistoryKVP in damageHistory)
            {				
                DrawDamageNotifier( dmgHistoryKVP.Key );
                if (dmgHistoryKVP.Value.Count == 0)
                    toRemove.Add(dmgHistoryKVP.Key);
            }
            toRemove.ForEach(p=>damageHistory.Remove(p));
            Pool.FreeList(ref toRemove);
        }

        void DamageNotifier(BasePlayer player, int damage, bool isHead, bool isFriend)
        {
            List<KeyValuePair<float, HitNfo>> damages;
            if (!damageHistory.TryGetValue(player, out damages))
                damageHistory[player] = damages = new List<KeyValuePair<float, HitNfo>>();
			
			var deltaX = GetRandomX();
			var deltaY = GetRandomY();
			
            damages.Insert(0,new KeyValuePair<float, HitNfo>(Time.time+ damageTimeout, new HitNfo() { damage = damage, isHead = isHead, isFriend = isFriend, xs=0.4919792+deltaX, ys=0.4531481+deltaY, xe=0.675+deltaX, ye=0.5587038+deltaY, num=rnd.Next(0,10000) }) );
           
            DrawDamageNotifier(player);
        }        
		
		string GetDamageText(string action)
		{
			switch (action)
			{
				case "wound": return "<color=#FF7979>УПАЛ!</color>";							  
				case "kill":  return "<color=red>УБИТ!</color>";							  
			}
			
			return "<color=white>ПОПАЛ!</color>";
		}

        void DestroyLastCui(BasePlayer player)
        {
            Oxide.Plugins.Timer tmr;
            if (destTimers.TryGetValue(player, out tmr))
            {
                tmr?.Callback?.Invoke();
                if (tmr != null && !tmr.Destroyed)
                    timer.Destroy(ref tmr);
            }
        }
        
        #endregion

        #region UI
		
		float GetRandomX()
		{
			return (rnd.Next(0,101)-50)/2000f;
		}
		
		float GetRandomY()
		{
			return -0.1f-rnd.Next(0,101)/2000f;
		}

        void DrawDamageNotifier(BasePlayer player)
        {						
			List<KeyValuePair<float, HitNfo>> damages;
            if (!damageHistory.TryGetValue(player, out damages)) return;
			
			float time = Time.time;			
            for (var i = damages.Count-1; i >= 0; i--)
            {
				var item = damages[i];	
                CuiHelper.DestroyUi(player, "hitmarkerDamage"+item.Value.num.ToString());										
				if (item.Key < time)
					damages.RemoveAt(i);
				else
					CuiHelper.AddUi( player, HandleArgs( DamageGUI, item.Value.num, $"<color={item.Value.isFriend ? "green" : (item.Value.isHead ? "red" : "white")}>-{item.Value.damage}</color>", item.Value.xs, item.Value.ys, item.Value.xe, item.Value.ye ) );
                destTimers[player] = timer.Once(damageTimeout, () =>
                {
                    CuiHelper.DestroyUi(player, "hitmarkerDamage" + item.Value.num.ToString());
                });
            }			            
        }        

        #endregion
        
    }
}





// --- End of file: HitMarker.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SpawnHeli.cs ---
// --- Original Local Path: SpawnHeli.cs ---

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using Facepunch;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Spawn Heli", "SpooksAU", "3.0.0")]
    [Description("Allows players to spawn helicopters")]
    internal class SpawnHeli : CovalencePlugin
    {
        #region Fields

        private const string LegacyPluginName = "SpawnMini";
        private const string LegacyPermissionPrefix = "spawnmini.";

        private const string PermissionMinicopter = "minicopter";
        private const string PermissionScrapHeli = "scraptransport";
        private const string PermissionAttackHeli = "attackhelicopter";

        private const int SpawnPointLayerMask = Rust.Layers.Solid | Rust.Layers.Mask.Water;
        private const int SpaceCheckLayerMask = Rust.Layers.Solid;

        private const float VerticalSpawnOffset = 1;

        private SaveData _data;
        private Configuration _config;
        private readonly VehicleInfoManager _vehicleInfoManager;

        private readonly object True = true;
        private readonly object False = false;

        public SpawnHeli()
        {
            _vehicleInfoManager = new VehicleInfoManager(this);
        }

        #endregion

        #region Hooks

        private void Init()
        {
            _data = SaveData.Load();
            _config.Init();
            _vehicleInfoManager.Init();

            if (!_vehicleInfoManager.AnyOwnerOnly)
            {
                Unsubscribe(nameof(CanMountEntity));
            }

            if (!_vehicleInfoManager.AnyDespawnOnDisconnect)
            {
                Unsubscribe(nameof(OnPlayerDisconnected));
                Unsubscribe(nameof(OnEntityDismounted));
            }
        }

        private void OnServerInitialized()
        {
            if (plugins.PluginManager.GetPlugin(LegacyPluginName) != null)
            {
                LogWarning($"Detected conflicting plugin {LegacyPluginName}. Please remove that plugin to avoid issues.");
            }

            _vehicleInfoManager.OnServerInitialized();

            foreach (var networkable in BaseNetworkable.serverEntities)
            {
                var heli = networkable as PlayerHelicopter;
                if (heli == null)
                    continue;

                var vehicleInfo = _vehicleInfoManager.GetVehicleInfo(heli);
                if (vehicleInfo == null || !vehicleInfo.Data.HasVehicle(heli))
                    continue;

                if (heli.OwnerID != 0 && permission.UserHasPermission(heli.OwnerID.ToString(), vehicleInfo.Permissions.UnlimitedFuel))
                {
                    EnableUnlimitedFuel(heli);
                }
            }

            _data.Clean();
        }

        private void Unload()
        {
            _data.SaveIfChanged();
        }

        private void OnServerSave()
        {
            _data.SaveIfChanged();
        }

        private void OnNewSave()
        {
            _data.Reset();
            _data.SaveIfChanged();
        }

        private void OnEntityKill(PlayerHelicopter heli)
        {
            var vehicleInfo = _vehicleInfoManager.GetVehicleInfo(heli);
            if (vehicleInfo == null)
                return;

            var ownerIdString = heli.OwnerID.ToString();
            var playerVehicle = vehicleInfo.Data.GetVehicle(ownerIdString);
            if (playerVehicle == null || playerVehicle != heli)
                return;

            _data.UnregisterVehicle(vehicleInfo, ownerIdString);

            var basePlayer = BasePlayer.FindByID(heli.OwnerID);
            if (basePlayer != null)
            {
                basePlayer.ChatMessage(GetMessage(basePlayer.UserIDString, vehicleInfo.Messages.Destroyed));
            }
        }

        private object OnEntityTakeDamage(PlayerHelicopter heli, HitInfo info)
        {
            if (heli == null || info == null || heli.OwnerID == 0)
                return null;

            VehicleInfo vehicleInfo;
            if (!IsPlayerVehicle(heli, out vehicleInfo))
                return null;

            if (info.damageTypes.Has(Rust.DamageType.Decay)
                && permission.UserHasPermission(heli.OwnerID.ToString(), vehicleInfo.Permissions.NoDecay))
                return True;

            return null;
        }

        private object CanMountEntity(BasePlayer player, BaseVehicleMountPoint mountPoint)
        {
            if (player == null || mountPoint == null)
                return null;

            VehicleInfo vehicleInfo;
            var heli = mountPoint.GetParentEntity() as PlayerHelicopter;
            if (heli == null || heli.OwnerID == 0 || !IsPlayerVehicle(heli, out vehicleInfo))
                return null;

            // Vehicle owner is allowed to mount.
            if (heli.OwnerID == player.userID)
                return null;

            // Team members are allowed to mount.
            if (player.Team != null && player.Team.members.Contains(heli.OwnerID))
                return null;

            player.ChatMessage(GetMessage(player.UserIDString, LangEntry.ErrorCannotMount));
            return False;
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            if (player == null)
                return;

            if (_config.Minicopter.DespawnOnDisconnect)
            {
                var heli = _data.Minicopter.GetVehicle(player.UserIDString);
                if (heli != null)
                {
                    ScheduleDespawnVehicleIfUnmounted(heli);
                }
            }

            if (_config.ScrapTransportHelicopter.DespawnOnDisconnect)
            {
                var heli = _data.ScrapTransportHelicopter.GetVehicle(player.UserIDString);
                if (heli != null)
                {
                    ScheduleDespawnVehicleIfUnmounted(heli);
                }
            }

            if (_config.AttackHelicopter.DespawnOnDisconnect)
            {
                var heli = _data.AttackHelicopter.GetVehicle(player.UserIDString);
                if (heli != null)
                {
                    ScheduleDespawnVehicleIfUnmounted(heli);
                }
            }
        }

        private void ScheduleDespawnVehicleIfUnmounted(PlayerHelicopter heli)
        {
            NextTick(() =>
            {
                // Despawn vehicle when the owner disconnects.
                // If mounted, we will despawn it later when all players dismount.
                if (heli == null || heli.AnyMounted())
                    return;

                heli.Kill();
            });
        }

        private void OnEntityDismounted(BaseVehicleSeat seat)
        {
            if (seat == null)
                return;

            VehicleInfo vehicleInfo;
            var heli = seat.GetParentEntity() as PlayerHelicopter;
            if (heli == null
                || !heli.AnyMounted()
                || !IsPlayerVehicle(heli, out vehicleInfo)
                || !vehicleInfo.Config.DespawnOnDisconnect)
                return;

            // Despawn minicopter when fully dismounted, if the owner player has disconnected.
            var ownerPlayer = BasePlayer.FindByID(heli.OwnerID);
            if (ownerPlayer != null && ownerPlayer.IsConnected)
                return;

            heli.Kill();
        }

        private void CanLootEntity(BasePlayer player, StorageContainer container)
        {
            if (container == null || !container.IsLocked())
                return;

            VehicleInfo vehicleInfo;
            var heli = container.GetParentEntity() as PlayerHelicopter;
            if (heli == null || !IsPlayerVehicle(heli, out vehicleInfo))
                return;

            if (!permission.UserHasPermission(heli.OwnerID.ToString(), vehicleInfo.Permissions.UnlimitedFuel))
                return;

            player.ChatMessage(GetMessage(player.UserIDString, LangEntry.ErrorUnlimitedFuel));
        }

        #endregion

        #region Commands

        private void CommandSpawnMinicopter(IPlayer player, string cmd, string[] args) =>
            SpawnCommandInternal(_vehicleInfoManager.Minicopter, player, cmd, args);

        private void CommandSpawnScrapTransportHelicopter(IPlayer player, string cmd, string[] args) =>
            SpawnCommandInternal(_vehicleInfoManager.ScrapTransportHelicopter, player, cmd, args);

        private void CommandSpawnAttackHelicopter(IPlayer player, string cmd, string[] args) =>
            SpawnCommandInternal(_vehicleInfoManager.AttackHelicopter, player, cmd, args);

        private void SpawnCommandInternal(VehicleInfo vehicleInfo, IPlayer player, string command, string[] args)
        {
            BasePlayer basePlayer;
            if (vehicleInfo == null
                || !VerifyPlayer(player, out basePlayer)
                || !VerifyPermission(player, vehicleInfo.Permissions.Spawn))
                return;

            var heli = FindPlayerVehicle(vehicleInfo, basePlayer);
            if (heli != null)
            {
                if (vehicleInfo.Config.AutoFetch && permission.UserHasPermission(player.Id, vehicleInfo.Permissions.Fetch))
                {
                    FetchVehicle(vehicleInfo, player, basePlayer, heli);
                }
                else
                {
                    player.Reply(GetMessage(player.Id, vehicleInfo.Messages.AlreadySpawned));
                }

                return;
            }

            if (_config.LimitPlayersToOneHelicopterType)
            {
                foreach (var otherVehicleInfo in _vehicleInfoManager.AllVehicles)
                {
                    if (otherVehicleInfo == vehicleInfo)
                        continue;

                    var otherVehicle = otherVehicleInfo.Data.GetVehicle(player.Id);
                    if (otherVehicle == null || otherVehicle.IsDestroyed)
                        continue;

                    if (!TryDespawnHeli(otherVehicleInfo, otherVehicle, basePlayer))
                    {
                        player.Reply(GetMessage(player.Id, LangEntry.ErrorConflictingHeli));
                        return;
                    }

                    otherVehicle.Kill();
                }
            }

            Vector3 position;
            Quaternion rotation;
            if (!VerifyOffCooldown(vehicleInfo, basePlayer, vehicleInfo.Config.SpawnCooldowns, vehicleInfo.Data.SpawnCooldowns)
                || !vehicleInfo.Config.CanSpawnBuildingBlocked && !VerifyNotBuildingBlocked(player, basePlayer)
                || SpawnWasBlocked(vehicleInfo, basePlayer)
                || !VerifyValidSpawnOrFetchPosition(vehicleInfo, basePlayer, out position, out rotation))
                return;

            heli = SpawnVehicle(vehicleInfo, basePlayer, position, rotation);
            if (heli == null)
                return;

            if (!permission.UserHasPermission(basePlayer.UserIDString, vehicleInfo.Permissions.NoCooldown))
            {
                _data.StartSpawnCooldown(vehicleInfo, basePlayer);
            }
        }

        private void CommandFetchMinicopter(IPlayer player, string cmd, string[] args) =>
            FetchCommandInternal(_vehicleInfoManager.Minicopter, player, cmd, args);

        private void CommandFetchScrapTransportHelicopter(IPlayer player, string cmd, string[] args) =>
            FetchCommandInternal(_vehicleInfoManager.ScrapTransportHelicopter, player, cmd, args);

        private void CommandFetchAttackHelicopter(IPlayer player, string cmd, string[] args) =>
            FetchCommandInternal(_vehicleInfoManager.AttackHelicopter, player, cmd, args);

        private void FetchCommandInternal(VehicleInfo vehicleInfo, IPlayer player, string command, string[] args)
        {
            BasePlayer basePlayer;
            PlayerHelicopter heli;
            if (vehicleInfo == null
                || !VerifyPlayer(player, out basePlayer)
                || !VerifyPermission(player, vehicleInfo.Permissions.Fetch)
                || !VerifyVehicleExists(player, basePlayer, vehicleInfo, out heli))
                return;

            FetchVehicle(vehicleInfo, player, basePlayer, heli);
        }

        private void CommandDespawnMinicopter(IPlayer player, string cmd, string[] args) =>
            DespawnCommandInternal(_vehicleInfoManager.Minicopter, player, cmd, args);

        private void CommandDespawnScrapTransportHelicopter(IPlayer player, string cmd, string[] args) =>
            DespawnCommandInternal(_vehicleInfoManager.ScrapTransportHelicopter, player, cmd, args);

        private void CommandDespawnAttackHelicopter(IPlayer player, string cmd, string[] args) =>
            DespawnCommandInternal(_vehicleInfoManager.AttackHelicopter, player, cmd, args);

        private void DespawnCommandInternal(VehicleInfo vehicleInfo, IPlayer player, string command, string[] args)
        {
            BasePlayer basePlayer;
            PlayerHelicopter heli;
            if (vehicleInfo == null
                || !VerifyPlayer(player, out basePlayer)
                || !VerifyPermission(player, vehicleInfo.Permissions.Despawn)
                || !VerifyVehicleExists(player, basePlayer, vehicleInfo, out heli))
                return;

            if (!vehicleInfo.Config.CanDespawnWhileOccupied && IsHeliOccupied(heli))
            {
                player.Reply(GetMessage(player.Id, LangEntry.ErrorHeliOccupied));
                return;
            }

            if (!VerifyVehicleWithinDistance(player, basePlayer, heli, vehicleInfo.Config.MaxDespawnDistance)
                || DespawnWasBlocked(vehicleInfo, basePlayer, heli))
                return;

            heli.Kill();
        }

        // Old command for backwards compatibility.
        [Command("spawnmini.give")]
        private void CommandGiveMinicopter(IPlayer player, string cmd, string[] args) =>
            GiveCommandInternal(_vehicleInfoManager.Minicopter, player, cmd, args);

        private void CommandGiveScrapTransportHelicopter(IPlayer player, string cmd, string[] args) =>
            GiveCommandInternal(_vehicleInfoManager.ScrapTransportHelicopter, player, cmd, args);

        private void CommandGiveAttackHelicopter(IPlayer player, string cmd, string[] args) =>
            GiveCommandInternal(_vehicleInfoManager.AttackHelicopter, player, cmd, args);

        private void GiveCommandInternal(VehicleInfo vehicleInfo, IPlayer player, string cmd, string[] args)
        {
            if (!player.IsServer)
                return;

            if (args.Length < 1)
            {
                PrintError($"Syntax: {cmd} <name or steamid>");
                return;
            }

            var recipientPlayer = BasePlayer.Find(args[0]);
            if (recipientPlayer == null)
            {
                PrintError($"{cmd}: No player found matching '{args[0]}'");
                return;
            }

            if (args.Length > 1)
            {
                float x, y, z;
                if (args.Length < 4 ||
                    !float.TryParse(args[1], out x) ||
                    !float.TryParse(args[2], out y) ||
                    !float.TryParse(args[3], out z))
                {
                    Puts($"Syntax: {cmd} <name or steamid> <x> <y> <z>");
                    return;
                }

                GiveVehicle(vehicleInfo, recipientPlayer, new Vector3(x, y, z));
                return;
            }

            GiveVehicle(vehicleInfo, recipientPlayer);
        }

        #endregion

        #region Helpers/Functions

        private static class StringUtils
        {
            public static string StripPrefix(string subject, string prefix)
            {
                return subject.StartsWith(prefix) ? subject.Substring(prefix.Length) : subject;
            }

            public static string StripPrefixes(string subject, params string[] prefixes)
            {
                foreach (var prefix in prefixes)
                {
                    subject = StripPrefix(subject, prefix);
                }

                return subject;
            }
        }

        public static void LogWarning(string message) => Interface.Oxide.LogWarning($"[Spawn Heli] {message}");
        public static void LogError(string message) => Interface.Oxide.LogError($"[Spawn Heli] {message}");

        private static bool VerifyPlayer(IPlayer player, out BasePlayer basePlayer)
        {
            if (player.IsServer)
            {
                basePlayer = null;
                return false;
            }

            basePlayer = player.Object as BasePlayer;
            return true;
        }

        private bool VerifyPermission(IPlayer player, string perm)
        {
            if (permission.UserHasPermission(player.Id, perm))
                return true;

            player.Reply(GetMessage(player.Id, LangEntry.ErrorNoPermission));
            return false;
        }

        private bool VerifyVehicleExists(IPlayer player, BasePlayer basePlayer, VehicleInfo vehicleInfo, out PlayerHelicopter heli)
        {
            heli = FindPlayerVehicle(vehicleInfo, basePlayer);
            if (heli != null)
                return true;

            player.Reply(GetMessage(player.Id, vehicleInfo.Messages.NotFound));
            return false;
        }

        private bool VerifyVehicleWithinDistance(IPlayer player, BasePlayer basePlayer, PlayerHelicopter heli, float maxDistance)
        {
            if (maxDistance < 0 || Vector3.Distance(basePlayer.transform.position, heli.transform.position) < maxDistance)
                return true;

            player.Reply(GetMessage(player.Id, LangEntry.ErrorHeliDistance));
            return false;
        }

        private bool VerifyValidSpawnOrFetchPosition(VehicleInfo vehicleInfo, BasePlayer player, out Vector3 position, out Quaternion rotation)
        {
            position = Vector3.zero;
            rotation = Quaternion.identity;

            if (vehicleInfo.Config.FixedSpawnDistanceConfig.Enabled)
            {
                position = GetFixedPositionForPlayer(vehicleInfo, player);
                rotation = GetFixedRotationForPlayer(vehicleInfo, player);
            }
            else
            {
                RaycastHit hit;
                if (!Physics.Raycast(player.eyes.HeadRay(), out hit, Mathf.Infinity, SpawnPointLayerMask))
                {
                    player.ChatMessage(GetMessage(player.UserIDString, LangEntry.ErrorNoSpawnLocationFound));
                    return false;
                }

                if (hit.distance > vehicleInfo.Config.MaxSpawnDistance)
                {
                    player.ChatMessage(GetMessage(player.UserIDString, LangEntry.ErrorSpawnDistance));
                    return false;
                }

                position = hit.point + Vector3.up * VerticalSpawnOffset;
            }

            var extents = vehicleInfo.Bounds.extents;
            var boundsCenter = position + rotation * vehicleInfo.Bounds.center;

            if (Physics.CheckBox(boundsCenter, extents, rotation, SpaceCheckLayerMask, QueryTriggerInteraction.Ignore)
                || Physics.CheckBox(position + Vector3.down * VerticalSpawnOffset / 2f, extents.WithY(VerticalSpawnOffset / 2f), rotation, Rust.Layers.Mask.Player_Server, QueryTriggerInteraction.Ignore))
            {
                player.ChatMessage(GetMessage(player.UserIDString, LangEntry.InsufficientSpace));
                return false;
            }

            return true;
        }

        private bool VerifyOffCooldown(VehicleInfo vehicleInfo, BasePlayer player, CooldownConfig cooldownConfig, Dictionary<string, DateTime> cooldownMap)
        {
            DateTime cooldownStart;
            if (!cooldownMap.TryGetValue(player.UserIDString, out cooldownStart)
                || permission.UserHasPermission(player.UserIDString, vehicleInfo.Permissions.NoCooldown))
                return true;

            var timeRemaining = CeilingTimeSpan(cooldownStart.AddSeconds(GetPlayerCooldownSeconds(cooldownConfig, player)) - DateTime.Now);
            if (timeRemaining.TotalSeconds <= 0)
            {
                _data.RemoveCooldown(cooldownMap, player);
                return true;
            }

            player.ChatMessage(GetMessage(player.UserIDString, LangEntry.ErrorOnCooldown, timeRemaining.ToString("g")));
            return false;
        }

        private bool VerifyNotBuildingBlocked(IPlayer player, BasePlayer basePlayer)
        {
            if (!basePlayer.IsBuildingBlocked())
                return true;

            player.Reply(GetMessage(basePlayer.UserIDString, LangEntry.ErrorBuildingBlocked));
            return false;
        }

        private static bool SpawnWasBlocked(VehicleInfo vehicleInfo, BasePlayer player)
        {
            var hookResult = Interface.CallHook(vehicleInfo.Hooks.Spawn, player);
            return hookResult is bool && !(bool)hookResult;
        }

        private static bool FetchWasBlocked(VehicleInfo vehicleInfo, BasePlayer player, PlayerHelicopter heli)
        {
            var hookResult = Interface.CallHook(vehicleInfo.Hooks.Fetch, player, heli);
            return hookResult is bool && !(bool)hookResult;
        }

        private static bool DespawnWasBlocked(VehicleInfo vehicleInfo, BasePlayer player, PlayerHelicopter heli)
        {
            var hookResult = Interface.CallHook(vehicleInfo.Hooks.Despawn, player, heli);
            return hookResult is bool && !(bool)hookResult;
        }

        private static TimeSpan CeilingTimeSpan(TimeSpan timeSpan)
        {
            return new TimeSpan((long)Math.Ceiling(1.0 * timeSpan.Ticks / 10000000) * 10000000);
        }

        private static Vector3 GetFixedPositionForPlayer(VehicleInfo vehicleInfo, BasePlayer player)
        {
            var forward = player.GetNetworkRotation() * Vector3.forward;
            forward.y = 0;
            return player.transform.position + forward.normalized * vehicleInfo.Config.FixedSpawnDistanceConfig.Distance + Vector3.up * VerticalSpawnOffset;
        }

        private static Quaternion GetFixedRotationForPlayer(VehicleInfo vehicleInfo, BasePlayer player)
        {
            return Quaternion.Euler(0, player.GetNetworkRotation().eulerAngles.y - vehicleInfo.Config.FixedSpawnDistanceConfig.RotationAngle, 0);
        }

        private static void EnableUnlimitedFuel(PlayerHelicopter heli)
        {
            var fuelSystem = heli.GetFuelSystem();
            fuelSystem.cachedHasFuel = true;
            fuelSystem.nextFuelCheckTime = float.MaxValue;
            fuelSystem.GetFuelContainer().SetFlag(BaseEntity.Flags.Locked, true);
        }

        private static bool AnyParentedPlayers(PlayerHelicopter heli)
        {
            foreach (var entity in heli.children)
            {
                if (entity is BasePlayer)
                    return true;
            }

            return false;
        }

        private static bool IsHeliOccupied(PlayerHelicopter heli)
        {
            return heli.AnyMounted() || AnyParentedPlayers(heli);
        }

        private static void UnparentPlayers(PlayerHelicopter heli)
        {
            var tempList = Pool.GetList<BasePlayer>();

            try
            {
                foreach (var entity in heli.children)
                {
                    var player = entity as BasePlayer;
                    if (player == null)
                        continue;

                    tempList.Add(player);
                }

                foreach (var player in tempList)
                {
                    player.SetParent(null, worldPositionStays: true);
                }
            }
            finally
            {
                Pool.FreeList(ref tempList);
            }
        }

        private bool IsPlayerVehicle(PlayerHelicopter heli, out VehicleInfo vehicleInfo)
        {
            vehicleInfo = _vehicleInfoManager.GetVehicleInfo(heli);
            return vehicleInfo != null && vehicleInfo.Data.HasVehicle(heli);
        }

        private PlayerHelicopter FindPlayerVehicle(VehicleInfo vehicleInfo, BasePlayer player)
        {
            ulong heliNetId;
            if (!vehicleInfo.Data.Vehicles.TryGetValue(player.UserIDString, out heliNetId))
                return null;

            var heli = BaseNetworkable.serverEntities.Find(new NetworkableId(heliNetId)) as PlayerHelicopter;
            if (heli == null)
            {
                _data.UnregisterVehicle(vehicleInfo, player.UserIDString);
            }

            return heli;
        }

        private void FetchVehicle(VehicleInfo vehicleInfo, IPlayer player, BasePlayer basePlayer, PlayerHelicopter heli)
        {
            var isOccupied = IsHeliOccupied(heli);
            if (isOccupied && (!vehicleInfo.Config.CanFetchWhileOccupied
                               || basePlayer.GetMountedVehicle() == heli
                               || basePlayer.GetParentEntity() == heli))
            {
                basePlayer.ChatMessage(GetMessage(basePlayer.UserIDString, LangEntry.ErrorHeliOccupied));
                return;
            }

            Vector3 position;
            Quaternion rotation;
            if (!VerifyVehicleWithinDistance(player, basePlayer, heli, vehicleInfo.Config.MaxFetchDistance)
                || !VerifyOffCooldown(vehicleInfo, basePlayer, vehicleInfo.Config.FetchCooldowns, vehicleInfo.Data.FetchCooldowns)
                || !vehicleInfo.Config.CanFetchBuildingBlocked && !VerifyNotBuildingBlocked(player, basePlayer)
                || FetchWasBlocked(vehicleInfo, basePlayer, heli)
                || !VerifyValidSpawnOrFetchPosition(vehicleInfo, basePlayer, out position, out rotation))
                return;

            if (isOccupied)
            {
                foreach (var mountPoint in heli.mountPoints)
                {
                    mountPoint.mountable?.DismountAllPlayers();
                }
            }

            if (AnyParentedPlayers(heli))
            {
                UnparentPlayers(heli);
            }

            if (vehicleInfo.Config.RepairOnFetch && vehicleInfo.Config.SpawnHealth > 0)
            {
                heli.SetHealth(Math.Max(heli.Health(), vehicleInfo.Config.SpawnHealth));
            }

            heli.rigidBody.velocity = Vector3.zero;
            heli.transform.SetPositionAndRotation(position, rotation);
            heli.UpdateNetworkGroup();
            heli.SendNetworkUpdateImmediate();

            if (!permission.UserHasPermission(basePlayer.UserIDString, vehicleInfo.Permissions.NoCooldown))
            {
                _data.StartFetchCooldown(vehicleInfo, basePlayer);
            }
        }

        private PlayerHelicopter SpawnVehicle(VehicleInfo vehicleInfo, BasePlayer player, Vector3 position, Quaternion rotation)
        {
            var heli = GameManager.server.CreateEntity(vehicleInfo.PrefabPath, position, rotation) as PlayerHelicopter;
            if (heli == null)
                return null;

            heli.OwnerID = player.userID;
            if (vehicleInfo.Config.SpawnHealth > 0)
            {
                heli.startHealth = vehicleInfo.Config.SpawnHealth;
            }

            heli.Spawn();

            if (permission.UserHasPermission(player.UserIDString, vehicleInfo.Permissions.UnlimitedFuel))
            {
                EnableUnlimitedFuel(heli);
            }
            else
            {
                AddInitialFuel(vehicleInfo, heli, player);
            }

            _data.RegisterVehicle(vehicleInfo, player.UserIDString, heli);
            return heli;
        }

        private void GiveVehicle(VehicleInfo vehicleInfo, BasePlayer player, Vector3? customPosition = null)
        {
            // Note: The give command does not auto fetch, but that could be changed in the future.
            if (FindPlayerVehicle(vehicleInfo, player) != null)
            {
                player.ChatMessage(GetMessage(player.UserIDString, vehicleInfo.Messages.AlreadySpawned));
                return;
            }

            var position = customPosition ?? GetFixedPositionForPlayer(vehicleInfo, player);
            var rotation = customPosition.HasValue ? Quaternion.identity : GetFixedRotationForPlayer(vehicleInfo, player);
            SpawnVehicle(vehicleInfo, player, position, rotation);
        }

        private bool TryDespawnHeli(VehicleInfo vehicleInfo, PlayerHelicopter heli, BasePlayer basePlayer)
        {
            if (!_config.AutoDespawnOtherHelicopterTypes)
                return false;

            if (!vehicleInfo.Config.CanDespawnWhileOccupied && IsHeliOccupied(heli))
                return false;

            if (DespawnWasBlocked(vehicleInfo, basePlayer, heli))
                return false;

            return true;
        }

        private float GetPlayerCooldownSeconds(CooldownConfig cooldownConfig, BasePlayer player)
        {
            var profileList = cooldownConfig.CooldownProfiles;
            if (profileList != null)
            {
                for (var i = profileList.Length - 1; i >= 0; i--)
                {
                    var profile = profileList[i];
                    if (profile.Permission != null
                        && permission.UserHasPermission(player.UserIDString, profile.Permission))
                        return profile.CooldownSeconds;
                }
            }

            return cooldownConfig.DefaultCooldown;
        }

        private int GetPlayerAllowedFuel(VehicleInfo vehicleInfo, BasePlayer player)
        {
            var fuelConfig = vehicleInfo.Config.FuelConfig;
            var profileList = fuelConfig.FuelProfiles;
            if (profileList != null)
            {
                for (var i = profileList.Length - 1; i >= 0; i--)
                {
                    var profile = profileList[i];
                    if (profile.Permission != null
                        && permission.UserHasPermission(player.UserIDString, profile.Permission))
                        return profile.FuelAmount;
                }
            }

            return fuelConfig.DefaultFuelAmount;
        }

        private void AddInitialFuel(VehicleInfo vehicleInfo, PlayerHelicopter heli, BasePlayer player)
        {
            var fuelAmount = GetPlayerAllowedFuel(vehicleInfo, player);
            if (fuelAmount == 0)
                return;

            var fuelContainer = heli.GetFuelSystem().GetFuelContainer();
            if (fuelAmount < 0)
            {
                // Value of -1 is documented to represent max stack size.
                fuelAmount = fuelContainer.allowedItem.stackable;
            }

            fuelContainer.inventory.AddItem(fuelContainer.allowedItem, fuelAmount);
        }

        #endregion

        #region Vehicle Info

        private class VehicleInfo
        {
            public class PermissionSet
            {
                public string Spawn;
                public string Fetch;
                public string Despawn;
                public string UnlimitedFuel;
                public string NoDecay;
                public string NoCooldown;
            }

            public class HookSet
            {
                public string Spawn;
                public string Fetch;
                public string Despawn;
            }

            public class MessageSet
            {
                public LangEntry Destroyed;
                public LangEntry AlreadySpawned;
                public LangEntry NotFound;
            }

            public string VehicleName { private get; set; }
            public string PrefabPath;
            public Bounds Bounds;
            public string GiveCommand  { get; private set; }
            public VehicleConfig Config;
            public VehicleData Data;
            public uint PrefabId { get; private set; }
            public PermissionSet Permissions;
            public HookSet Hooks;
            public MessageSet Messages;

            public void Init(SpawnHeli plugin)
            {
                GiveCommand = $"{nameof(SpawnHeli)}.{VehicleName}.give".ToLower();

                Permissions = new PermissionSet
                {
                    Spawn = $"{nameof(SpawnHeli)}.{VehicleName}.spawn".ToLower(),
                    Fetch = $"{nameof(SpawnHeli)}.{VehicleName}.fetch".ToLower(),
                    Despawn = $"{nameof(SpawnHeli)}.{VehicleName}.despawn".ToLower(),
                    UnlimitedFuel = $"{nameof(SpawnHeli)}.{VehicleName}.unlimitedfuel".ToLower(),
                    NoDecay = $"{nameof(SpawnHeli)}.{VehicleName}.nodecay".ToLower(),
                    NoCooldown = $"{nameof(SpawnHeli)}.{VehicleName}.nocooldown".ToLower(),
                };

                plugin.permission.RegisterPermission(Permissions.Spawn, plugin);
                plugin.permission.RegisterPermission(Permissions.Fetch, plugin);
                plugin.permission.RegisterPermission(Permissions.Despawn, plugin);
                plugin.permission.RegisterPermission(Permissions.UnlimitedFuel, plugin);
                plugin.permission.RegisterPermission(Permissions.NoDecay, plugin);
                plugin.permission.RegisterPermission(Permissions.NoCooldown, plugin);

                if (Config.FuelConfig.FuelProfiles != null)
                {
                    foreach (var profile in Config.FuelConfig.FuelProfiles)
                    {
                        if (profile.Permission != null)
                        {
                            plugin.permission.RegisterPermission(profile.Permission, plugin);
                        }
                    }
                }

                if (Config.SpawnCooldowns.CooldownProfiles != null)
                {
                    foreach (var profile in Config.SpawnCooldowns.CooldownProfiles)
                    {
                        if (profile.Permission != null)
                        {
                            plugin.permission.RegisterPermission(profile.Permission, plugin);
                        }
                    }
                }

                if (Config.FetchCooldowns.CooldownProfiles != null)
                {
                    foreach (var profile in Config.FetchCooldowns.CooldownProfiles)
                    {
                        if (profile.Permission != null)
                        {
                            plugin.permission.RegisterPermission(profile.Permission, plugin);
                        }
                    }
                }
            }

            public void OnServerInitialized()
            {
                PrefabId = GameManager.server.FindPrefab(PrefabPath)?.GetComponent<BaseEntity>()?.prefabID ?? 0;
            }
        }

        private class VehicleInfoManager
        {
            public VehicleInfo Minicopter { get; private set; }
            public VehicleInfo ScrapTransportHelicopter { get; private set; }
            public VehicleInfo AttackHelicopter { get; private set; }
            public VehicleInfo[] AllVehicles { get; private set; }

            private readonly SpawnHeli _plugin;
            private readonly Dictionary<uint, VehicleInfo> _prefabIdToVehicleInfo = new Dictionary<uint, VehicleInfo>();

            public bool AnyOwnerOnly => AllVehicles.Any(vehicleInfo => vehicleInfo.Config.OnlyOwnerAndTeamCanMount);
            public bool AnyDespawnOnDisconnect => AllVehicles.Any(vehicleInfo => vehicleInfo.Config.DespawnOnDisconnect);

            private Configuration _config => _plugin._config;
            private SaveData _data => _plugin._data;

            public VehicleInfoManager(SpawnHeli plugin)
            {
                _plugin = plugin;
            }

            public void Init()
            {
                AllVehicles = new[]
                {
                    Minicopter = new VehicleInfo
                    {
                        VehicleName = PermissionMinicopter,
                        PrefabPath = "assets/content/vehicles/minicopter/minicopter.entity.prefab",
                        Config = _config.Minicopter,
                        Data = _data.Minicopter,
                        Hooks = new VehicleInfo.HookSet
                        {
                            Spawn = "OnMyMiniSpawn",
                            Fetch = "OnMyMiniFetch",
                            Despawn = "OnMyMiniDespawn",
                        },
                        Messages = new VehicleInfo.MessageSet
                        {
                            Destroyed = LangEntry.MiniDestroyed,
                            AlreadySpawned = LangEntry.ErrorMiniExists,
                            NotFound = LangEntry.ErrorMiniNotFound,
                        },
                        Bounds = new Bounds
                        {
                            center = new Vector3(-0.001f, 1.114f, -0.36f),
                            extents = new Vector3(1.32f, 0.87f, 2.16f),
                        },
                    },
                    ScrapTransportHelicopter = new VehicleInfo
                    {
                        VehicleName = PermissionScrapHeli,
                        PrefabPath = "assets/content/vehicles/scrap heli carrier/scraptransporthelicopter.prefab",
                        Config = _config.ScrapTransportHelicopter,
                        Data = _data.ScrapTransportHelicopter,
                        Hooks = new VehicleInfo.HookSet
                        {
                            Spawn = "OnMyScrapHeliSpawn",
                            Fetch = "OnMyScrapHeliFetch",
                            Despawn = "OnMyScrapHeliDespawn",
                        },
                        Messages = new VehicleInfo.MessageSet
                        {
                            Destroyed = LangEntry.ScrapHeliDestroyed,
                            AlreadySpawned = LangEntry.ErrorScrapHeliExist,
                            NotFound = LangEntry.ErrorScrapHeliNotFound,
                        },
                        Bounds = new Bounds
                        {
                            center = new Vector3(0, 2.25f, -1.25f),
                            extents = new Vector3(2.2f, 2.25f, 6f),
                        },
                    },
                    AttackHelicopter = new VehicleInfo
                    {
                        VehicleName = PermissionAttackHeli,
                        PrefabPath = "assets/content/vehicles/attackhelicopter/attackhelicopter.entity.prefab",
                        Config = _config.AttackHelicopter,
                        Data = _data.AttackHelicopter,
                        Hooks = new VehicleInfo.HookSet
                        {
                            Spawn = "OnMyAttackHeliSpawn",
                            Fetch = "OnMyAttackHeliFetch",
                            Despawn = "OnMyAttackHeliDespawn",
                        },
                        Messages = new VehicleInfo.MessageSet
                        {
                            Destroyed = LangEntry.AttackHeliDestroyed,
                            AlreadySpawned = LangEntry.ErrorAttackHeliExists,
                            NotFound = LangEntry.ErrorAttackHeliNotFound,
                        },
                        Bounds = new Bounds
                        {
                            center = new Vector3(0, 1.678f, -1.676f),
                            extents = new Vector3(1.303f, 1.678f, 5.495f),
                        },
                    },
                };

                foreach (var vehicleInfo in AllVehicles)
                {
                    vehicleInfo.Init(_plugin);
                }

                _plugin.AddCovalenceCommand(Minicopter.Config.SpawnCommands, nameof(CommandSpawnMinicopter));
                _plugin.AddCovalenceCommand(Minicopter.Config.FetchCommands, nameof(CommandFetchMinicopter));
                _plugin.AddCovalenceCommand(Minicopter.Config.DespawnCommands, nameof(CommandDespawnMinicopter));
                _plugin.AddCovalenceCommand(Minicopter.GiveCommand, nameof(CommandGiveMinicopter));

                _plugin.AddCovalenceCommand(ScrapTransportHelicopter.Config.SpawnCommands, nameof(CommandSpawnScrapTransportHelicopter));
                _plugin.AddCovalenceCommand(ScrapTransportHelicopter.Config.FetchCommands, nameof(CommandFetchScrapTransportHelicopter));
                _plugin.AddCovalenceCommand(ScrapTransportHelicopter.Config.DespawnCommands, nameof(CommandDespawnScrapTransportHelicopter));
                _plugin.AddCovalenceCommand(ScrapTransportHelicopter.GiveCommand, nameof(CommandGiveScrapTransportHelicopter));

                _plugin.AddCovalenceCommand(AttackHelicopter.Config.SpawnCommands, nameof(CommandSpawnAttackHelicopter));
                _plugin.AddCovalenceCommand(AttackHelicopter.Config.FetchCommands, nameof(CommandFetchAttackHelicopter));
                _plugin.AddCovalenceCommand(AttackHelicopter.Config.DespawnCommands, nameof(CommandDespawnAttackHelicopter));
                _plugin.AddCovalenceCommand(AttackHelicopter.GiveCommand, nameof(CommandGiveAttackHelicopter));
            }

            public void OnServerInitialized()
            {
                foreach (var vehicleInfo in AllVehicles)
                {
                    vehicleInfo.OnServerInitialized();

                    if (vehicleInfo.PrefabId != 0)
                    {
                        _prefabIdToVehicleInfo[vehicleInfo.PrefabId] = vehicleInfo;
                    }
                    else
                    {
                        LogError($"Unable to determine Prefab ID for prefab: {vehicleInfo.PrefabPath}");
                    }
                }
            }

            public VehicleInfo GetVehicleInfo(BaseEntity entity)
            {
                VehicleInfo vehicleInfo;
                return _prefabIdToVehicleInfo.TryGetValue(entity.prefabID, out vehicleInfo)
                    ? vehicleInfo
                    : null;
            }
        }

        #endregion

        #region Data

        [JsonObject(MemberSerialization.OptIn)]
        private class LegacySaveData
        {
            private const string Filename = LegacyPluginName;

            public static LegacySaveData LoadIfExists()
            {
                return Interface.Oxide.DataFileSystem.ExistsDatafile(Filename)
                    ? Interface.Oxide.DataFileSystem.ReadObject<LegacySaveData>(Filename)
                    : null;
            }

            [JsonProperty("playerMini")]
            public Dictionary<string, ulong> playerMini = new Dictionary<string, ulong>();

            [JsonProperty("spawnCooldowns")]
            public Dictionary<string, DateTime> spawnCooldowns = new Dictionary<string, DateTime>();

            [JsonProperty("cooldown")]
            private Dictionary<string, DateTime> deprecatedCooldown
            {
                set { spawnCooldowns = value; }
            }

            [JsonProperty("fetchCooldowns")]
            public Dictionary<string, DateTime> fetchCooldowns = new Dictionary<string, DateTime>();

            public void Delete()
            {
                Interface.Oxide.DataFileSystem.DeleteDataFile(Filename);
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class VehicleData
        {
            [JsonProperty("Vehicles")]
            public Dictionary<string, ulong> Vehicles = new Dictionary<string, ulong>();

            [JsonProperty("SpawnCooldowns")]
            public Dictionary<string, DateTime> SpawnCooldowns = new Dictionary<string, DateTime>();

            [JsonProperty("FetchCooldowns")]
            public Dictionary<string, DateTime> FetchCooldowns = new Dictionary<string, DateTime>();

            public PlayerHelicopter GetVehicle(string playerId)
            {
                ulong netId;
                return Vehicles.TryGetValue(playerId, out netId)
                    ? BaseNetworkable.serverEntities.Find(new NetworkableId(netId)) as PlayerHelicopter
                    : null;
            }

            public bool HasVehicle(BaseEntity vehicle)
            {
                return Vehicles.ContainsValue(vehicle.net.ID.Value);
            }

            public bool RegisterVehicle(string playerId, ulong netId)
            {
                return Vehicles.TryAdd(playerId, netId);
            }

            public bool UnregisterVehicle(string playerId)
            {
                return Vehicles.Remove(playerId);
            }

            public void SetSpawnCooldown(string playerId, DateTime dateTime)
            {
                SpawnCooldowns[playerId] = dateTime;
            }

            public void SetFetchCooldown(string playerId, DateTime dateTime)
            {
                FetchCooldowns[playerId] = dateTime;
            }

            public bool Clean()
            {
                if (Vehicles.Count == 0)
                    return false;

                var changed = false;

                foreach (var entry in Vehicles.ToList())
                {
                    var entity = BaseNetworkable.serverEntities.Find(new NetworkableId(entry.Value)) as PlayerHelicopter;
                    if (entity != null)
                        continue;

                    Vehicles.Remove(entry.Key);
                    changed = true;
                }

                return changed;
            }

            public bool Reset()
            {
                var result = Vehicles.Count > 0 || SpawnCooldowns.Count > 0 || FetchCooldowns.Count > 0;
                Vehicles.Clear();
                SpawnCooldowns.Clear();
                FetchCooldowns.Clear();
                return result;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class SaveData
        {
            private const string Filename = nameof(SpawnHeli);

            public static SaveData Load()
            {
                var exists = Interface.Oxide.DataFileSystem.ExistsDatafile(Filename);
                var data = Interface.Oxide.DataFileSystem.ReadObject<SaveData>(Filename) ?? new SaveData();
                if (!exists)
                {
                    var legacyData = LegacySaveData.LoadIfExists();
                    if (legacyData != null)
                    {
                        data.Minicopter.Vehicles = legacyData.playerMini;
                        data.Minicopter.SpawnCooldowns = legacyData.spawnCooldowns;
                        data.Minicopter.FetchCooldowns = legacyData.fetchCooldowns;
                        data.SaveIfChanged();
                        legacyData.Delete();
                    }
                }

                return data;
            }

            private bool _dirty;

            [JsonProperty("Minicopter")]
            public VehicleData Minicopter = new VehicleData();

            [JsonProperty("ScrapTransportHelicopter")]
            public VehicleData ScrapTransportHelicopter = new VehicleData();

            [JsonProperty("AttackHelicopter")]
            public VehicleData AttackHelicopter = new VehicleData();

            public void Clean()
            {
                _dirty |= Minicopter.Clean();
                _dirty |= ScrapTransportHelicopter.Clean();
                _dirty |= AttackHelicopter.Clean();
            }

            public void Reset()
            {
                _dirty |= Minicopter.Reset();
                _dirty |= ScrapTransportHelicopter.Reset();
                _dirty |= AttackHelicopter.Reset();
            }

            public void SaveIfChanged()
            {
                if (!_dirty)
                    return;

                Interface.Oxide.DataFileSystem.WriteObject(Filename, this);
                _dirty = false;
            }

            public void StartSpawnCooldown(VehicleInfo vehicleInfo, BasePlayer player)
            {
                vehicleInfo.Data.SetSpawnCooldown(player.UserIDString, DateTime.Now);
                _dirty = true;
            }

            public void StartFetchCooldown(VehicleInfo vehicleInfo, BasePlayer player)
            {
                vehicleInfo.Data.SetFetchCooldown(player.UserIDString, DateTime.Now);
                _dirty = true;
            }

            public void RegisterVehicle(VehicleInfo vehicleInfo, string playerId, PlayerHelicopter heli)
            {
                vehicleInfo.Data.RegisterVehicle(playerId, heli.net.ID.Value);
                _dirty = true;
            }

            public void UnregisterVehicle(VehicleInfo vehicleInfo, string playerId)
            {
                vehicleInfo.Data.UnregisterVehicle(playerId);
                _dirty = true;
            }

            public void RemoveCooldown(Dictionary<string, DateTime> cooldownMap, BasePlayer player)
            {
                cooldownMap.Remove(player.UserIDString);
                _dirty = true;
            }
        }

        #endregion

        #region Configuration

        [JsonObject(MemberSerialization.OptIn)]
        private class BasePermissionAmount
        {
            [JsonProperty("Permission suffix")]
            protected string PermissionSuffix;

            [JsonIgnore]
            public string Permission { get; protected set; }

            public void Init(string permissionInfix)
            {
                if (!string.IsNullOrWhiteSpace(PermissionSuffix))
                {
                    Permission = $"{nameof(SpawnHeli)}.{permissionInfix}.{PermissionSuffix}".ToLower();
                }
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class FuelProfile : BasePermissionAmount
        {
            [JsonProperty("Fuel amount")]
            public int FuelAmount;

            // Default constructor for JSON, necessary because there's another constructor.
            public FuelProfile() { }

            public FuelProfile(string permissionSuffix, int fuelAmount)
            {
                PermissionSuffix = permissionSuffix;
                FuelAmount = fuelAmount;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class FuelConfig
        {
            [JsonProperty("Default fuel amount")]
            public int DefaultFuelAmount;

            [JsonProperty("Fuel profiles requiring permission")]
            public FuelProfile[] FuelProfiles =
            {
                new FuelProfile("100", 100),
                new FuelProfile("500", 500),
                new FuelProfile("1000", 1000),
            };

            public void Init(string vehicleName)
            {
                if (FuelProfiles != null)
                {
                    foreach (var profile in FuelProfiles)
                    {
                        profile.Init($"{vehicleName}.fuel");
                    }
                }
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class CooldownProfile : BasePermissionAmount
        {
            [JsonProperty("Cooldown (seconds)")]
            public float CooldownSeconds;

            // Default constructor for JSON, necessary because there's another constructor.
            public CooldownProfile() { }

            public CooldownProfile(string permissionSuffix, float cooldownSeconds)
            {
                PermissionSuffix = permissionSuffix;
                CooldownSeconds = cooldownSeconds;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class CooldownConfig
        {
            [JsonProperty("Default cooldown (seconds)")]
            public float DefaultCooldown;

            [JsonProperty("Cooldown profiles requiring permission")]
            public CooldownProfile[] CooldownProfiles;

            public void Init(string vehicleName, string cooldownType)
            {
                if (CooldownProfiles != null)
                {
                    foreach (var profile in CooldownProfiles)
                    {
                        profile.Init($"{vehicleName}.cooldown.{cooldownType}");
                    }
                }
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class FixedSpawnDistanceConfig
        {
            [JsonProperty("Enabled")]
            public bool Enabled = true;

            [JsonProperty("Distance from player")]
            public float Distance = 3;

            [JsonProperty("Helicopter rotation angle")]
            public float RotationAngle = 90;
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class VehicleConfig
        {
            [JsonProperty("Spawn commands")]
            public string[] SpawnCommands;

            [JsonProperty("Fetch commands")]
            public string[] FetchCommands;

            [JsonProperty("Despawn commands")]
            public string[] DespawnCommands;

            [JsonProperty("Can despawn while occupied")]
            public bool CanDespawnWhileOccupied;

            [JsonProperty("Can fetch while occupied")]
            public bool CanFetchWhileOccupied;

            [JsonProperty("Can spawn while building blocked")]
            public bool CanSpawnBuildingBlocked;

            [JsonProperty("Can fetch while building blocked")]
            public bool CanFetchBuildingBlocked;

            [JsonProperty("Auto fetch")]
            public bool AutoFetch;

            [JsonProperty("Repair on fetch")]
            public bool RepairOnFetch;

            [JsonProperty("Max spawn distance")]
            public float MaxSpawnDistance = 5f;

            [JsonProperty("Max fetch distance")]
            public float MaxFetchDistance = -1;

            [JsonProperty("Max despawn distance")]
            public float MaxDespawnDistance = -1;

            [JsonProperty("Fixed spawn distance")]
            public FixedSpawnDistanceConfig FixedSpawnDistanceConfig = new FixedSpawnDistanceConfig();

            [JsonProperty("Only owner and team can mount")]
            public bool OnlyOwnerAndTeamCanMount;

            [JsonProperty("Spawn health")]
            public float SpawnHealth;

            [JsonProperty("Destroy on disconnect")]
            public bool DespawnOnDisconnect;

            [JsonProperty("Fuel")]
            public FuelConfig FuelConfig = new FuelConfig();

            [JsonProperty("Spawn cooldowns")]
            public CooldownConfig SpawnCooldowns = new CooldownConfig
            {
                DefaultCooldown = 3600f,
                CooldownProfiles = new[]
                {
                    new CooldownProfile("1hr", 3600),
                    new CooldownProfile("10m", 600),
                    new CooldownProfile("1s", 1),
                },
            };

            [JsonProperty("Fetch cooldowns")]
            public CooldownConfig FetchCooldowns = new CooldownConfig
            {
                DefaultCooldown = 10f,
                CooldownProfiles = new[]
                {
                    new CooldownProfile("1hr", 3600),
                    new CooldownProfile("10m", 600),
                    new CooldownProfile("1s", 1),
                },
            };

            public void Init(string vehicleName)
            {
                FuelConfig?.Init(vehicleName);
                SpawnCooldowns?.Init(vehicleName, "spawn");
                FetchCooldowns?.Init(vehicleName, "fetch");
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class Configuration : SerializableConfiguration
        {
            [JsonProperty("Limit players to one helicopter type at a time")]
            public bool LimitPlayersToOneHelicopterType;

            [JsonProperty("Try to auto despawn other helicopter types")]
            public bool AutoDespawnOtherHelicopterTypes;

            [JsonProperty("Minicopter")]
            public VehicleConfig Minicopter = new VehicleConfig
            {
                SpawnCommands = new[] { "mymini" },
                FetchCommands = new[] { "fmini" },
                DespawnCommands = new[] { "nomini" },
                SpawnHealth = 750,
            };

            [JsonProperty("ScrapTransportHelicopter")]
            public VehicleConfig ScrapTransportHelicopter = new VehicleConfig
            {
                SpawnCommands = new[] { "myheli" },
                FetchCommands = new[] { "fheli" },
                DespawnCommands = new[] { "noheli" },
                SpawnHealth = 1000,
            };

            [JsonProperty("AttackHelicopter")]
            public VehicleConfig AttackHelicopter = new VehicleConfig
            {
                SpawnCommands = new[] { "myattack" },
                FetchCommands = new[] { "fattack" },
                DespawnCommands = new[] { "noattack" },
                SpawnHealth = 850,
            };

            public bool Migrate()
            {
                var changed = false;

                if (DeprecatedCanDespawnWhileOccupied)
                {
                    Minicopter.CanDespawnWhileOccupied = DeprecatedCanDespawnWhileOccupied;
                    DeprecatedCanDespawnWhileOccupied = false;
                    changed = true;
                }

                if (DeprecatedCanFetchWhileOccupied)
                {
                    Minicopter.CanFetchWhileOccupied = DeprecatedCanFetchWhileOccupied;
                    DeprecatedCanFetchWhileOccupied = false;
                    changed = true;
                }

                if (DeprecatedCanSpawnBuildingBlocked)
                {
                    Minicopter.CanSpawnBuildingBlocked = DeprecatedCanSpawnBuildingBlocked;
                    DeprecatedCanSpawnBuildingBlocked = DeprecatedCanFetchWhileOccupied;
                    changed = true;
                }

                if (!DeprecatedCanFetchBuildingBlocked)
                {
                    Minicopter.CanFetchBuildingBlocked = DeprecatedCanFetchBuildingBlocked;
                    DeprecatedCanFetchBuildingBlocked = true;
                    changed = true;
                }

                if (DeprecatedAutoFetch)
                {
                    Minicopter.AutoFetch = DeprecatedAutoFetch;
                    DeprecatedAutoFetch = false;
                    changed = true;
                }

                if (DeprecatedRepairOnFetch)
                {
                    Minicopter.RepairOnFetch = DeprecatedRepairOnFetch;
                    DeprecatedRepairOnFetch = false;
                    changed = true;
                }

                if (DeprecatedFuelAmount != 0)
                {
                    Minicopter.FuelConfig.DefaultFuelAmount = DeprecatedFuelAmount;
                    DeprecatedFuelAmount = 0;
                    changed = true;
                }

                if (DeprecatedFuelAmountsRequiringPermission != null)
                {
                    Minicopter.FuelConfig.FuelProfiles = DeprecatedFuelAmountsRequiringPermission
                        .Select(amount => new FuelProfile(amount.ToString(), amount))
                        .ToArray();

                    DeprecatedFuelAmountsRequiringPermission = null;
                    changed = true;
                }

                if (DeprecatedNoMiniDistance != 0)
                {
                    Minicopter.MaxDespawnDistance = DeprecatedNoMiniDistance;
                    Minicopter.MaxFetchDistance = DeprecatedNoMiniDistance;
                    DeprecatedNoMiniDistance = 0;
                    changed = true;
                }

                if (DeprecatedMaxSpawnDistance != 0)
                {
                    Minicopter.MaxSpawnDistance = DeprecatedMaxSpawnDistance;
                    DeprecatedMaxSpawnDistance = 0;
                    changed = true;
                }

                if (!DeprecatedUseFixedSpawnDistance)
                {
                    Minicopter.FixedSpawnDistanceConfig.Enabled = false;
                    DeprecatedUseFixedSpawnDistance = true;
                    changed = true;
                }

                if (DeprecatedFixedSpawnDistance != 0)
                {
                    Minicopter.FixedSpawnDistanceConfig.Distance = DeprecatedFixedSpawnDistance;
                    DeprecatedFixedSpawnDistance = 0;
                    changed = true;
                }

                if (DeprecatedFixedSpawnRotationAngle != 0)
                {
                    Minicopter.FixedSpawnDistanceConfig.RotationAngle = DeprecatedFixedSpawnRotationAngle;
                    DeprecatedFixedSpawnRotationAngle = 0;
                    changed = true;
                }

                if (DeprecatedOwnerOnly)
                {
                    Minicopter.OnlyOwnerAndTeamCanMount = DeprecatedOwnerOnly;
                    DeprecatedOwnerOnly = false;
                    changed = true;
                }

                if (DeprecatedDefaultSpawnCooldown != 0)
                {
                    Minicopter.SpawnCooldowns.DefaultCooldown = DeprecatedDefaultSpawnCooldown;
                    DeprecatedDefaultSpawnCooldown = 0;
                    changed = true;
                }

                if (DeprecatedSpawnPermissionCooldowns != null)
                {
                    Minicopter.SpawnCooldowns.CooldownProfiles = DeprecatedSpawnPermissionCooldowns
                        .Select(entry => new CooldownProfile(StringUtils.StripPrefixes(entry.Key, LegacyPermissionPrefix), entry.Value))
                        .ToArray();

                    DeprecatedSpawnPermissionCooldowns = null;
                    changed = true;
                }

                if (DeprecatedDefaultFetchCooldown != 0)
                {
                    Minicopter.FetchCooldowns.DefaultCooldown = DeprecatedDefaultFetchCooldown;
                    DeprecatedDefaultFetchCooldown = 0;
                    changed = true;
                }

                if (DeprecatedFetchPermissionCooldowns != null)
                {
                    Minicopter.FetchCooldowns.CooldownProfiles = DeprecatedFetchPermissionCooldowns
                        .Select(entry => new CooldownProfile(StringUtils.StripPrefixes(entry.Key, LegacyPermissionPrefix, "fetch."), entry.Value))
                        .ToArray();

                    DeprecatedFetchPermissionCooldowns = null;
                    changed = true;
                }

                if (DeprecatedSpawnHealth != 0)
                {
                    Minicopter.SpawnHealth = DeprecatedSpawnHealth;
                    DeprecatedSpawnHealth = 0;
                    changed = true;
                }

                if (DeprecatedDespawnOnDisconnect)
                {
                    Minicopter.DespawnOnDisconnect = DeprecatedDespawnOnDisconnect;
                    DeprecatedDespawnOnDisconnect = false;
                    changed = true;
                }

                return changed;
            }

            [JsonProperty("CanDespawnWhileOccupied", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private bool DeprecatedCanDespawnWhileOccupied;

            [JsonProperty("CanFetchWhileOccupied", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private bool DeprecatedCanFetchWhileOccupied;

            [JsonProperty("CanSpawnBuildingBlocked", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private bool DeprecatedCanSpawnBuildingBlocked;

            [JsonProperty("CanFetchBuildingBlocked", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [DefaultValue(true)]
            private bool DeprecatedCanFetchBuildingBlocked = true;

            [JsonProperty("AutoFetch", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private bool DeprecatedAutoFetch;

            [JsonProperty("RepairOnFetch", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private bool DeprecatedRepairOnFetch;

            [JsonProperty("FuelAmount", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private int DeprecatedFuelAmount;

            [JsonProperty("FuelAmountsRequiringPermission", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private int[] DeprecatedFuelAmountsRequiringPermission;

            [JsonProperty("MaxNoMiniDistance", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private float DeprecatedNoMiniDistance;

            [JsonProperty("MaxSpawnDistance", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private float DeprecatedMaxSpawnDistance;

            [JsonProperty("UseFixedSpawnDistance", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [DefaultValue(true)]
            private bool DeprecatedUseFixedSpawnDistance = true;

            [JsonProperty("FixedSpawnDistance", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private float DeprecatedFixedSpawnDistance;

            [JsonProperty("FixedSpawnRotationAngle", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private float DeprecatedFixedSpawnRotationAngle;

            [JsonProperty("OwnerAndTeamCanMount", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private bool DeprecatedOwnerOnly;

            [JsonProperty("DefaultSpawnCooldown", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private float DeprecatedDefaultSpawnCooldown;

            [JsonProperty("PermissionSpawnCooldowns", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private Dictionary<string, float> DeprecatedSpawnPermissionCooldowns;

            [JsonProperty("DefaultFetchCooldown", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private float DeprecatedDefaultFetchCooldown;

            [JsonProperty("PermissionFetchCooldowns", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private Dictionary<string, float> DeprecatedFetchPermissionCooldowns;

            [JsonProperty("SpawnHealth", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private float DeprecatedSpawnHealth;

            [JsonProperty("DestroyOnDisconnect", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private bool DeprecatedDespawnOnDisconnect;

            public void Init()
            {
                Minicopter.Init(PermissionMinicopter);
                ScrapTransportHelicopter.Init(PermissionScrapHeli);
                AttackHelicopter.Init(PermissionAttackHeli);
            }
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #region Configuration Helpers

        internal class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        internal static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        // Don't update nested keys since the cooldown tiers might be customized
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                    throw new JsonException();

                if (MaybeUpdateConfig(_config) | _config.Migrate())
                {
                    PrintWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                PrintError(e.Message);
                PrintWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Puts($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #endregion

        #region Localization

        private class LangEntry
        {
            public enum Lang
            {
                en,
            }

            public static readonly List<LangEntry> AllLangEntries = new List<LangEntry>();

            public static readonly LangEntry ErrorNoPermission = new LangEntry("error_no_permission", new Dictionary<Lang, string>
            {
                [Lang.en] = "You do not have permission to use this command.",
            });
            public static readonly LangEntry ErrorBuildingBlocked = new LangEntry("error_building_blocked", new Dictionary<Lang, string>
            {
                [Lang.en] = "Cannot do that while building blocked.",
            });
            public static readonly LangEntry ErrorOnCooldown = new LangEntry("error_on_cooldown", new Dictionary<Lang, string>
            {
                [Lang.en] = "You have <color=red>{0}</color> until your cooldown ends.",
            });
            public static readonly LangEntry InsufficientSpace = new LangEntry("error_insufficient_space", new Dictionary<Lang, string>
            {
                [Lang.en] = "Not enough space.",
            });
            public static readonly LangEntry ErrorConflictingHeli = new LangEntry("error_conflicting_heli", new Dictionary<Lang, string>
            {
                [Lang.en] = "You must first destroy your other helicopter(s) before you can spawn a new one.",
            });

            public static readonly LangEntry ErrorSpawnDistance = new LangEntry("error_spawn_distance", new Dictionary<Lang, string>
            {
                [Lang.en] = "You cannot spawn the helicopter that far away.",
            });
            public static readonly LangEntry ErrorNoSpawnLocationFound = new LangEntry("error_spawn_location", new Dictionary<Lang, string>
            {
                [Lang.en] = "No suitable spawn location found.",
            });
            public static readonly LangEntry ErrorHeliOccupied = new LangEntry("error_heli_occupied", new Dictionary<Lang, string>
            {
                [Lang.en] = "The helicopter is currently occupied.",
            });
            public static readonly LangEntry ErrorHeliDistance = new LangEntry("error_heli_distance", new Dictionary<Lang, string>
            {
                [Lang.en] = "The helicopter is too far away.",
            });
            public static readonly LangEntry ErrorCannotMount = new LangEntry("error_cannot_mount", new Dictionary<Lang, string>
            {
                [Lang.en] = "You are not the owner of this helicopter or in the owner's team.",
            });
            public static readonly LangEntry ErrorUnlimitedFuel = new LangEntry("error_unlimited_fuel", new Dictionary<Lang, string>
            {
                [Lang.en] = "That helicopter doesn't need fuel.",
            });

            public static readonly LangEntry MiniDestroyed = new LangEntry("info_mini_destroyed", new Dictionary<Lang, string>
            {
                [Lang.en] = "Your Minicopter has been destroyed.",
            });
            public static readonly LangEntry ScrapHeliDestroyed = new LangEntry("info_scrap_heli_destroyed", new Dictionary<Lang, string>
            {
                [Lang.en] = "Your Scrap Heli has been destroyed.",
            });
            public static readonly LangEntry AttackHeliDestroyed = new LangEntry("info_attack_heli_destroyed", new Dictionary<Lang, string>
            {
                [Lang.en] = "Your Attack Heli has been destroyed.",
            });

            public static readonly LangEntry ErrorMiniExists = new LangEntry("error_mini_exists", new Dictionary<Lang, string>
            {
                [Lang.en] = "You already have a Minicopter.",
            });
            public static readonly LangEntry ErrorScrapHeliExist = new LangEntry("error_scrap_heli_exists", new Dictionary<Lang, string>
            {
                [Lang.en] = "You already have a Scrap Heli.",
            });
            public static readonly LangEntry ErrorAttackHeliExists = new LangEntry("error_attack_heli_exists", new Dictionary<Lang, string>
            {
                [Lang.en] = "You already have an Attack Heli.",
            });

            public static readonly LangEntry ErrorMiniNotFound = new LangEntry("error_mini_not_found", new Dictionary<Lang, string>
            {
                [Lang.en] = "You do not have a Minicopter.",
            });
            public static readonly LangEntry ErrorScrapHeliNotFound = new LangEntry("error_scrap_heli_not_found", new Dictionary<Lang, string>
            {
                [Lang.en] = "You do not have a Scrap Heli.",
            });
            public static readonly LangEntry ErrorAttackHeliNotFound = new LangEntry("error_attack_heli_not_found", new Dictionary<Lang, string>
            {
                [Lang.en] = "You do not have an Attack Heli.",
            });

            public readonly string Name;
            public readonly Dictionary<Lang, string> PhrasesByLanguage;

            private LangEntry(string name, Dictionary<Lang, string> phrasesByLanguage)
            {
                Name = name;
                PhrasesByLanguage = phrasesByLanguage;

                AllLangEntries.Add(this);
            }
        }

        private string GetMessage(string playerId, LangEntry langEntry) =>
            lang.GetMessage(langEntry.Name, this, playerId);

        private string GetMessage(string playerId, LangEntry langEntry, object arg1) =>
            string.Format(GetMessage(playerId, langEntry), arg1);

        protected override void LoadDefaultMessages()
        {
            var langKeysByLanguage = new Dictionary<string, Dictionary<string, string>>();

            foreach (var langEntry in LangEntry.AllLangEntries)
            {
                foreach (var phraseEntry in langEntry.PhrasesByLanguage)
                {
                    var langName = phraseEntry.Key.ToString();
                    Dictionary<string, string> langKeys;
                    if (!langKeysByLanguage.TryGetValue(langName, out langKeys))
                    {
                        langKeys = new Dictionary<string, string>();
                        langKeysByLanguage[langName] = langKeys;
                    }

                    langKeys[langEntry.Name] = phraseEntry.Value;
                }
            }

            foreach (var langKeysEntry in langKeysByLanguage)
            {
                lang.RegisterMessages(langKeysEntry.Value, this, langKeysEntry.Key);
            }
        }

        #endregion
    }
}

// --- End of file: SpawnHeli.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/WaterDisconnect.cs ---
// --- Original Local Path: WaterDisconnect.cs ---

using System;
using System.Collections.Generic;
using System.Reflection;

namespace Oxide.Plugins
{
    [Info("WaterDisconnect", "Wulf/lukespragg", "2.2.0", ResourceId = 2122)]
    [Description("Hurts or kills players that log out underwater")]

    class WaterDisconnect : CovalencePlugin
    {
        #region Initialization

        const string permExclude = "waterdisconnect.exclude";

        bool hurtOnLogout;
        bool hurtOverTime;
        bool killOnLogout;

        int damageAmount;
        int damageEvery;
        int waterPercent;

        protected override void LoadDefaultConfig()
        {
            // Options
            Config["Hurt On Logout (true/false)"] = hurtOnLogout = GetConfig("Hurt On Logout (true/false)", true);
            Config["Hurt Over Time (true/false)"] = hurtOverTime = GetConfig("Hurt Over Time (true/false)", true);
            Config["Kill On Logout (true/false)"] = killOnLogout = GetConfig("Kill On Logout (true/false)", false);

            // Settings
            Config["Damage Amount (1 - 500)"] = damageAmount = GetConfig("Damage Amount (1 - 500)", 10);
            Config["Damage Every (Seconds)"] = damageEvery = GetConfig("Damage Every (Seconds)", 10);
            Config["Underwater Percent (1 - 100)"] = waterPercent = GetConfig("Underwater Percent (1 - 100)", 75);

            SaveConfig();
        }

        void Init()
        {
            LoadDefaultConfig();
            permission.RegisterPermission(permExclude, this);
        }

        #endregion

        #region Disconnect Handling

        readonly FieldInfo modelStateInfo = typeof(BasePlayer).GetField("modelState", BindingFlags.Instance | BindingFlags.NonPublic);
        readonly Dictionary<ulong, Timer> timers = new Dictionary<ulong, Timer>();

        void HandleDisconnect(BasePlayer player)
        {
            var modelState = modelStateInfo.GetValue(player) as ModelState;
            if (!(modelState != null && modelState.waterLevel > (waterPercent / 100f))) return;
            if (permission.UserHasPermission(player.UserIDString, permExclude)) return;

            if (hurtOnLogout)
            {
                if (hurtOverTime)
                {
                    timers[player.userID] = timer.Every(damageEvery, () =>
                    {
                        if (player.IsDead() && timers.ContainsKey(player.userID))
                            timers[player.userID].Destroy();
                        else
                            player.Hurt(damageAmount);
                    });
                    return;
                }

                player.Hurt(damageAmount);
            }
            else if (killOnLogout) player.Kill();
        }

        #endregion

        #region Game Hooks

        void OnServerInitialized()
        {
            foreach (var sleeper in BasePlayer.sleepingPlayerList) HandleDisconnect(sleeper);
        }

        void OnPlayerDisconnected(BasePlayer player) => HandleDisconnect(player);

        #endregion

        #region Helpers

        T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion
    }
}


// --- End of file: WaterDisconnect.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XSkinMenu.cs ---
// --- Original Local Path: XSkinMenu.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json; 
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;    
using System.Linq;   
  
namespace Oxide.Plugins 
{ 
    [Info("XSkinMenu", "Я", "1.0.502")]
    class XSkinMenu : RustPlugin  
    { 
		#region Reference 
		
		[PluginReference] private Plugin ImageLibrary;
		
		#endregion
		 
		#region Config
		
		private SkinConfig config;

        private class SkinConfig  
        {		
			internal class GeneralSetting 
			{
				[JsonProperty("Сгенерировать/Проверять и добавлять новые скины принятые разработчиками или сделаные для твич дропсов")] public bool UpdateSkins;
				[JsonProperty("Сгенерировать/Проверять и добавлять новые скины добавленные разработчиками [ К примеру скин на хазмат ]")] public bool UpdateSkinsFacepunch;
				[JsonProperty("Отображать кнопку для удаления всех скинов")] public bool ButtonClear;
				[JsonProperty("Черный список скинов которые нельзя изменить. [ Например: огненные перчатки, огненный топор ]]")] public List<ulong> Blacklist = new List<ulong>();
			}			 
			     
			internal class MenuSSetting 
			{ 
				[JsonProperty("Иконка включенного параметра")] public string TButtonIcon = "";
				[JsonProperty("Иконка вылюченного параметра")] public string FButtonIcon = "";				
				[JsonProperty("Цвет включенного параметра")] public string CTButton = "";
				[JsonProperty("Цвет вылюченного параметра")] public string CFButton = "";
			}			
			
			[JsonProperty("Общие настройки")]
			public GeneralSetting Setting = new GeneralSetting();			
			[JsonProperty("Меню настроект")]
			public MenuSSetting MenuS = new MenuSSetting();
			[JsonProperty("Настройка категорий")] 
            public Dictionary<string, List<string>> Category = new Dictionary<string, List<string>>();								
			
			public static SkinConfig GetNewConfiguration()
            {
                return new SkinConfig
                {
					Setting = new GeneralSetting
					{
						UpdateSkins = true,
						UpdateSkinsFacepunch = false,
						ButtonClear = true,
						Blacklist = new List<ulong>
						{
							1742796979,
							841106268
						}
					},
					MenuS = new MenuSSetting
					{
						TButtonIcon = "assets/icons/check.png",
						FButtonIcon = "assets/icons/close.png",
						CTButton = "0.53 0.77 0.35 0.8",
						CFButton = "1 0.4 0.35 0.8"
					},
					Category = new Dictionary<string, List<string>>
					{
						["weapon"] = new List<string> { "gun.water", "pistol.revolver", "pistol.semiauto", "pistol.python", "pistol.eoka", "shotgun.waterpipe", "shotgun.double", "shotgun.pump", "bow.hunting", "crossbow", "grenade.f1", "smg.2", "smg.thompson", "smg.mp5", "rifle.ak", "rifle.lr300", "lmg.m249", "rocket.launcher", "rifle.semiauto", "rifle.m39", "rifle.bolt", "rifle.l96", "longsword", "salvaged.sword", "knife.combat", "bone.club", "knife.bone" },
						["construction"] = new List<string> { "wall.frame.garagedoor", "door.double.hinged.toptier", "door.double.hinged.metal", "door.double.hinged.wood", "door.hinged.toptier", "door.hinged.metal", "door.hinged.wood", "barricade.concrete", "barricade.sandbags" },
						["item"] = new List<string> { "locker", "vending.machine", "fridge", "furnace", "table", "chair", "box.wooden.large", "box.wooden", "rug.bear", "rug", "sleepingbag", "water.purifier", "target.reactive", "sled", "discofloor", "paddlingpool", "innertube", "boogieboard", "beachtowel", "beachparasol", "beachchair", "skull.trophy", "skullspikes" },
						["attire"] = new List<string> { "metal.facemask", "coffeecan.helmet", "riot.helmet", "bucket.helmet", "deer.skull.mask", "twitch.headset", "sunglasses", "mask.balaclava", "burlap.headwrap", "hat.miner", "hat.beenie", "hat.boonie", "hat.cap", "mask.bandana", "metal.plate.torso", "roadsign.jacket", "roadsign.kilt", "roadsign.gloves", "burlap.gloves", "attire.hide.poncho", "jacket.snow", "jacket", "tshirt.long", "hazmatsuit", "hoodie", "shirt.collared", "tshirt", "burlap.shirt", "attire.hide.vest", "shirt.tanktop", "attire.hide.helterneck", "pants", "burlap.trousers", "pants.shorts", "attire.hide.pants", "attire.hide.skirt", "shoes.boots", "burlap.shoes", "attire.hide.boots" },
						["tool"] = new List<string> { "fun.guitar", "jackhammer", "icepick.salvaged", "pickaxe", "stone.pickaxe", "rock", "hatchet", "stonehatchet", "explosive.satchel", "hammer" }
					}
				};
			}
        }
		 
		protected override void LoadConfig()
        {
            base.LoadConfig(); 
			 
			try
			{
				config = Config.ReadObject<SkinConfig>();
			}
			catch  
			{
				PrintWarning("Ошибка чтения конфигурации! Создание дефолтной конфигурации!");
				LoadDefaultConfig();
			}
			
			SaveConfig();
        }
		protected override void LoadDefaultConfig() => config = SkinConfig.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);
		
		#endregion		
		
		#region Data
		
	    internal class Data 
		{
			[JsonProperty("Смена скинов в инвентаре")] public bool ChangeSI = true;
			[JsonProperty("Смена скинов на предметах")] public bool ChangeSE = true;
			[JsonProperty("Смена скинов при крафте")] public bool ChangeSC = true;
			[JsonProperty("Смена скинов в инвентаре после удаления")] public bool ChangeSCL = true;
			[JsonProperty("Смена скинов при попадании в инвентарь")] public bool ChangeSG;
			[JsonProperty("Скины")] public Dictionary<string, ulong> Skins = new Dictionary<string, ulong>();
		}
		
		private Dictionary<ulong, Data> StoredData = new Dictionary<ulong, Data>();
		private Dictionary<ulong, bool> StoredDataFriends = new Dictionary<ulong, bool>();
		public Dictionary<string, List<ulong>> StoredDataSkins = new Dictionary<string, List<ulong>>();
		
		private void LoadData(BasePlayer player)
		{ 
            var Data = Interface.Oxide.DataFileSystem.ReadObject<Data>($"XSkinMenu/UserSettings/{player.userID}");
             
            if (!StoredData.ContainsKey(player.userID)) 
                StoredData.Add(player.userID, new Data());            
			if (!StoredDataFriends.ContainsKey(player.userID)) 
                StoredDataFriends.Add(player.userID, false);
  
            StoredData[player.userID] = Data ?? new Data();  
			
			if (StoredData[player.userID].Skins.Count == 0)
			    foreach(var skin in StoredDataSkins) 
					StoredData[player.userID].Skins.Add(skin.Key, 0);
		}  
		
		private void SaveData(BasePlayer player) => Interface.Oxide.DataFileSystem.WriteObject($"XSkinMenu/UserSettings/{player.userID}", StoredData[player.userID]);
		
	    private void Unload()
		{
			foreach (BasePlayer player in BasePlayer.activePlayerList)
			{
				SaveData(player);
				CuiHelper.DestroyUi(player, ".GUIS");
			}
			
			Interface.Oxide.DataFileSystem.WriteObject("XSkinMenu/Friends", StoredDataFriends);
		}
		
		#endregion		
		
		private Dictionary<BasePlayer, DateTime> Cooldowns = new Dictionary<BasePlayer, DateTime>();
		
		#region Commands
		
		[ChatCommand("skin")]
		private void cmdOpenGUI(BasePlayer player) 
		{
			if(!permission.UserHasPermission(player.UserIDString, "xskinmenu.use"))
				SendReply(player, lang.GetMessage("NOPERM", this, player.UserIDString));
			else
			    GUI(player);		
		}
		
		[ChatCommand("skinentity")]
		private void cmdSetSkinEntity(BasePlayer player)
		{
			if(!permission.UserHasPermission(player.UserIDString, "xskinmenu.entity"))
			{
				SendReply(player, lang.GetMessage("NOPERM", this, player.UserIDString));
				return;
			}
			
			if(StoredData[player.userID].ChangeSE)
			{
			    RaycastHit rhit;
 
			    if (!Physics.Raycast(player.eyes.HeadRay(), out rhit, 3f, LayerMask.GetMask("Deployed", "Construction"))) return;
			    var entity = rhit.GetEntity();
			
                if (entity != null && (entity.OwnerID == player.userID || player.currentTeam != 0 && player.Team.members.Contains(entity.OwnerID) && StoredDataFriends.ContainsKey(entity.OwnerID) && StoredDataFriends[entity.OwnerID]))
			    {
				    if(shortnamesEntity.ContainsKey(entity.ShortPrefabName))
				    {
				        var shortname = shortnamesEntity[entity.ShortPrefabName];
				        if(!StoredData[player.userID].Skins.ContainsKey(shortname)) return;
					
				        SetSkinEntity(player, entity, shortname);
				    }
			    }
			}
		}
		
		[ConsoleCommand("skin_c")]
		private void ccmdCategoryS(ConsoleSystem.Arg args)
		{
			BasePlayer player = args.Player();
			
			if(!permission.UserHasPermission(player.UserIDString, "xskinmenu.use")) 
			{
				SendReply(player, lang.GetMessage("NOPERM", this, player.UserIDString));
				return;
			}
			
			if (Cooldowns.ContainsKey(player))
                if (Cooldowns[player].Subtract(DateTime.Now).TotalSeconds >= 0) return;
			
			Effect x = new Effect("assets/bundled/prefabs/fx/notice/loot.drag.grab.fx.prefab", player, 0, new Vector3(), new Vector3());
			Effect z = new Effect("assets/bundled/prefabs/fx/weapons/survey_charge/survey_charge_stick.prefab", player, 0, new Vector3(), new Vector3());
			
			switch(args.Args[0])
			{
				case "category":
				{
					CategoryGUI(player, int.Parse(args.Args[2]));
					ItemGUI(player, args.Args[1]);
					EffectNetwork.Send(x, player.Connection);
					break;
				}				
				case "skin":
				{ 
					SkinGUI(player, args.Args[1]);
					EffectNetwork.Send(x, player.Connection);
					break; 
				}				
				case "setskin":
				{ 
					string item = args.Args[1];
					ulong skin = ulong.Parse(args.Args[2]);
					
					if(!StoredData[player.userID].Skins.ContainsKey(item)) return;
					
					Effect y = new Effect("assets/prefabs/deployable/repair bench/effects/skinchange_spraypaint.prefab", player, 0, new Vector3(), new Vector3());
					StoredData[player.userID].Skins[item] = skin;
					
					if(!permission.UserHasPermission(player.UserIDString, "xskinmenu.inventory"))
						SendReply(player, lang.GetMessage("NOPERM", this, player.UserIDString));
					else
					    if(StoredData[player.userID].ChangeSI) SetSkinItem(player, item, skin);
					
					EffectNetwork.Send(y, player.Connection);
					break;
				}				
				case "clear":
				{
					string item = args.Args[1];
					StoredData[player.userID].Skins[item] = 0;
					
					CuiHelper.DestroyUi(player, $".I + {args.Args[2]}");
					if(StoredData[player.userID].ChangeSCL) SetSkinItem(player, item, 0);
					
					EffectNetwork.Send(z, player.Connection);
					break;
				}				
				case "clearall":
				{
					StoredData[player.userID].Skins.Clear();
					
					foreach(var skin in StoredDataSkins) 
						StoredData[player.userID].Skins.Add(skin.Key, 0);
					
					GUI(player);
					EffectNetwork.Send(z, player.Connection);
					break;
				}
			}
			
			Cooldowns[player] = DateTime.Now.AddSeconds(0.5f); 
		}
		
		[ConsoleCommand("skin_s")]
		private void ccmdSetting(ConsoleSystem.Arg args)
		{
			BasePlayer player = args.Player();
			
			if(!permission.UserHasPermission(player.UserIDString, "xskinmenu.setting")) 
			{
				SendReply(player, lang.GetMessage("NOPERM", this, player.UserIDString));
				return;
			}
			
			if (Cooldowns.ContainsKey(player))
                if (Cooldowns[player].Subtract(DateTime.Now).TotalSeconds >= 0) return;
			
			Effect x = new Effect("assets/bundled/prefabs/fx/notice/loot.drag.grab.fx.prefab", player, 0, new Vector3(), new Vector3());
			
			switch(args.Args[0])
			{
				case "open":
				{
					SettingGUI(player);
					break;
				}				
				case "inventory":
				{
					StoredData[player.userID].ChangeSI = !StoredData[player.userID].ChangeSI;
					SettingGUI(player);
					break;
				}				
				case "entity":
				{
					StoredData[player.userID].ChangeSE = !StoredData[player.userID].ChangeSE;
					SettingGUI(player);
					break;
				}				
				case "craft":
				{
					StoredData[player.userID].ChangeSC = !StoredData[player.userID].ChangeSC;
					SettingGUI(player);
					break;
				}				
				case "clear":
				{
					StoredData[player.userID].ChangeSCL = !StoredData[player.userID].ChangeSCL;
					SettingGUI(player);
					break;
				}				
				case "give":
				{
					StoredData[player.userID].ChangeSG = !StoredData[player.userID].ChangeSG;
					SettingGUI(player);
					break;
				}				
				case "friends":
				{
					StoredDataFriends[player.userID] = !StoredDataFriends[player.userID];
					SettingGUI(player);
					break;
				}
			}
			
			EffectNetwork.Send(x, player.Connection);
			Cooldowns[player] = DateTime.Now.AddSeconds(0.5f);
		}
		
		[ConsoleCommand("page.xskinmenu")]
		private void ccmdPage(ConsoleSystem.Arg args)
		{
			BasePlayer player = args.Player();
			Effect x = new Effect("assets/bundled/prefabs/fx/notice/loot.drag.grab.fx.prefab", player, 0, new Vector3(), new Vector3());
			
			string item = args.Args[2];
			int Page = int.Parse(args.Args[3]);
			
			switch (args.Args[0])
			{
				case "item":
				{
					switch(args.Args[1])
					{
				        case "next":
				        {
				        	ItemGUI(player, item, Page + 1);	
				        	break;
				        }						
				        case "back":
				        {
				        	ItemGUI(player, item, Page - 1);
				        	break;
				        }
					}
					break;
				}				
				case "skin":
				{
					switch(args.Args[1])
					{
				        case "next":
				        {
				        	SkinGUI(player, item, Page + 1);	
				        	break;
				        }						
				        case "back":
				        {
				    	    SkinGUI(player, item, Page - 1);
				    	    break;
				        }
					}
					break;
				}
			}
			
			EffectNetwork.Send(x, player.Connection);
		}
		
		[ConsoleCommand("xskin")]
		private void ccmdAdmin(ConsoleSystem.Arg args)
		{
			if (args.Player() == null || args.Player().IsAdmin)
			{
				string item = args.Args[1];
				
				if(!StoredDataSkins.ContainsKey(item))
				{
					PrintWarning($"Не найдено предмета <{item}> в списке!");
					return;
				}
				
				switch(args.Args[0])
				{
					case "add": 
					{
						ulong skinID = ulong.Parse(args.Args[2]);
							
						if(StoredDataSkins[item].Contains(skinID))
							PrintWarning($"Скин <{skinID}> уже есть в списке скинов предмета <{item}>!");
						else
						{
							StoredDataSkins[item].Add(skinID);
							PrintWarning($"Скин <{skinID}> успешно добавлен в список скинов предмета <{item}>!");
						}
						
						break;
					}					
					case "remove":
					{
						ulong skinID = ulong.Parse(args.Args[2]);
						
						if(StoredDataSkins[item].Contains(skinID))
						{
							StoredDataSkins[item].Remove(skinID);
							PrintWarning($"Скин <{skinID}> успешно удален из списка скинов предмета <{item}>!");
						}
						else
							PrintWarning($"Скин <{skinID}> не найден в списке скинов предмета <{item}>!");
						
						break;
					}					
					case "list": 
					{
						if(StoredDataSkins[item].Count == 0)
						{
							PrintWarning($"Список скинов предмета <{item}> пуст!");
							return;
						}
						
						string skinslist = $"Список скинов предмета <{item}>:\n";
						
						foreach(ulong skinID in StoredDataSkins[item])
						    skinslist += $"\n{skinID}";
						
						PrintWarning(skinslist);
						
						break;
					}					
					case "clearlist":
					{
						if(StoredDataSkins[item].Count == 0)
						{
							PrintWarning($"Список скинов предмета <{item}> уже пуст!");
							return;
						}
						else
						{
							StoredDataSkins[item].Clear();
							PrintWarning($"Список скинов предмета <{item}> успешно очищен!");
						} 
						
						break;  
					}					  
				}
				
				Interface.Oxide.DataFileSystem.WriteObject("XSkinMenu/Skins", StoredDataSkins);
			}
		}
		 
		#endregion		 
		
		private readonly Dictionary<string, string> shortnamesEntity = new Dictionary<string, string>();
		
		#region Hooks 
		 
	    private void OnServerInitialized()
		{
			PrintWarning("\n-----------------------------\n" +
			"     Author - TopPlugin.ru\n" +
			"     VK - vk.com/rustnastroika\n" + 
			"     Discord - PsiX#2920\n" +
			"     Config - v.3192\n" + 
			"-----------------------------"); 

			if (Interface.Oxide.DataFileSystem.ExistsDatafile("XSkinMenu/Friends"))
                StoredDataFriends = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, bool>>("XSkinMenu/Friends");			
			if (Interface.Oxide.DataFileSystem.ExistsDatafile("XSkinMenu/Skins"))
                StoredDataSkins = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, List<ulong>>>("XSkinMenu/Skins");			
			
			foreach (var category in config.Category)
			    foreach (var item in category.Value)
					if (!ImageLibrary.Call<bool>("HasImage", item + 150))
				        ImageLibrary.Call("AddImage", $"http://api.skyplugins.ru/api/getimage/{item}/{150}", item + 150);
					
			foreach(var item in StoredDataSkins)
			    foreach(var skin in item.Value)
			        if (!ImageLibrary.Call<bool>("HasImage", $"{skin}" + 152) && !errorskins.ContainsKey(skin) && !facepunchskins.ContainsKey(skin))
					    ImageLibrary.Call("AddImage", $"http://api.skyplugins.ru/api/getskin/{skin}/{150}", $"{skin}" + 152);
					else if(errorskins.ContainsKey(skin))
						ImageLibrary.Call("AddImage", $"http://api.skyplugins.ru/api/getimage/{errorskins[skin]}/{150}", errorskins[skin] + 150);					
					else if(facepunchskins.ContainsKey(skin))
						ImageLibrary.Call("AddImage", $"http://api.skyplugins.ru/api/getimage/{facepunchskins[skin]}/{150}", facepunchskins[skin] + 150);
				
			foreach (var item in ItemManager.GetItemDefinitions())
			{
				var prefab = item.GetComponent<ItemModDeployable>()?.entityPrefab?.resourcePath;
				if (string.IsNullOrEmpty(prefab)) continue;
				 
				var shortPrefabName = Utility.GetFileNameWithoutExtension(prefab);
				if (!string.IsNullOrEmpty(shortPrefabName) && !shortnamesEntity.ContainsKey(shortPrefabName))
				    shortnamesEntity.Add(shortPrefabName, item.shortname);
			}
			  
			GenerateItems();
				
			BasePlayer.activePlayerList.ToList().ForEach(OnPlayerConnected);
			timer.Every(180, () => BasePlayer.activePlayerList.ToList().ForEach(SaveData));
			timer.Every(200, () => Interface.Oxide.DataFileSystem.WriteObject("XSkinMenu/Friends", StoredDataFriends));
			
			InitializeLang();
			permission.RegisterPermission("xskinmenu.use", this);
			permission.RegisterPermission("xskinmenu.setting", this);
			permission.RegisterPermission("xskinmenu.craft", this);
			permission.RegisterPermission("xskinmenu.entity", this);
			permission.RegisterPermission("xskinmenu.inventory", this);   
			permission.RegisterPermission("xskinmenu.give", this);   
		}
		
		private void GenerateItems()
		{
			if(config.Setting.UpdateSkins)
				foreach (var pair in Rust.Workshop.Approved.All)
				{
					if (pair.Value == null || pair.Value.Skinnable == null) continue;
				
					ulong skinID = pair.Value.WorkshopdId; 
				
					string item = pair.Value.Skinnable.ItemName;
					if (item.Contains("lr300")) item = "rifle.lr300";
				
					if(!StoredDataSkins.ContainsKey(item))
						StoredDataSkins.Add(item, new List<ulong>());
				
					if(!StoredDataSkins[item].Contains(skinID))
						StoredDataSkins[item].Add(skinID);
				}
			
			if(config.Setting.UpdateSkinsFacepunch)
				foreach (ItemDefinition item in ItemManager.GetItemDefinitions())
				{
					foreach(var skinID in ItemSkinDirectory.ForItem(item).Select(skin => Convert.ToUInt64(skin.id)))
					{
						if(!StoredDataSkins.ContainsKey(item.shortname))
						StoredDataSkins.Add(item.shortname, new List<ulong>());
				
						if(!StoredDataSkins[item.shortname].Contains(skinID))
						StoredDataSkins[item.shortname].Add(skinID);
					}
				}	
			
			Interface.Oxide.DataFileSystem.WriteObject("XSkinMenu/Skins", StoredDataSkins);
		}
		
		private void OnPlayerConnected(BasePlayer player)
		{
			if (player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerConnected(player));
                return;
            }		
			
			LoadData(player);
		}  
		
	    private void OnPlayerDisconnected(BasePlayer player)
		{
			if (StoredData.ContainsKey(player.userID)) 
			{   
				SaveData(player);
				StoredData.Remove(player.userID);
			}			
			  
			if (Cooldowns.ContainsKey(player)) 
				Cooldowns.Remove(player);  
		}
		
		public Dictionary<ulong, string> errorskins = new Dictionary<ulong, string>
		{
			[10180] = "hazmatsuit.spacesuit",
			[10201] = "hazmatsuit.nomadsuit",
			[10189] = "door.hinged.industrial.a",
			[13050] = "skullspikes.candles",
			[13051] = "skullspikes.pumpkin",
			[13052] = "skull.trophy.jar",
			[13053] = "skull.trophy.jar2",
			[13054] = "skull.trophy.table",
			[13056] = "sled.xmas", 
			[13057] = "discofloor.largetiles",
			[10198] = "factorydoor", 
			//[] = "sofa.pattern" 
		};		
		
		public Dictionary<ulong, string> facepunchskins = new Dictionary<ulong, string>
		{
			[10026] = "hat.cap.grey", [10027] = "hat.cap.forestcamo", [10028] = "hat.cap.red", [10029] = "hat.cap.blue", [10030] = "hat.cap.green", [10045] = "hat.cap.skin.cap.rescuecap", [10055] = "hat.cap.skin.cap.friendlycap",
			[10122] = "box.wooden.large.skin.woodstorage.christmasstorage", [10123] = "box.wooden.large.skin.woodstorage.firstaidgreen", [10124] = "box.wooden.large.skin.woodstorage.ammowoodenbox", [10141] = "box.wooden.large.skin.woodstorage.gunbox", [10135] = "rifle.ak.skin.ak47.digitalcamoak47", [10137] = "rifle.ak.skin.ak47.militarycamoak47", [10138] = "rifle.ak.skin.ak47.temperedak47",
			[10037] = "sleepingbag.skin.blueplaid", [10076] = "sleepingbag.skin.woodcamo", [10077] = "sleepingbag.skin.tigercrown", [10107] = "sleepingbag.skin.horrorbag", [10119] = "sleepingbag.skin.christmasbag", [10121] = "sleepingbag.skin.astonchristmas",
			[10052] = "hoodie.skin.bloody", [10086] = "hoodie.skin.skeleton", [10129] = "hoodie.skin.safetycrew", [10132] = "hoodie.skin.rhinocrunch", [10133] = "hoodie.skin.cuda87", [10142] = "hoodie.skin.bchillz", [14072] = "hoodie.green", [14178] = "hoodie.blue", [14179] = "hoodie.black",
			[10001] = "pants.jeans", [10019] = "pants.forestcamo", [10020] = "pants.urbancamo", [10021] = "pants.snowcamo", [10048] = "pants.skin.punkrock", [10049] = "pants.skin.bluetrackv.2", [10078] = "pants.skin.oldprisoner",
			[10114] = "pistol.revolver.skin.revolver.revolveroutback",
			[10022] = "shoes.boots.tan", [10023] = "shoes.boots.black",  [10034] = "shoes.boots.skin.boots.punkboots",
			[10044] = "shoes.boots.skin.boots.scavengedsneakers", [10080] = "shoes.boots.skin.boots.armyboots", [10088] = "shoes.boots.skin.boots.bloodyboots",
			[10074] = "shotgun.pump.skin.pumpshotgunchieftain", [10140] = "shotgun.pump.skin.pumpshotgun.theswampmaster",
			[10115] = "rifle.bolt.skin.boltrifle.ghostboltrifle", [10116] = "rifle.bolt.skin.boltrifle.tundraboltrifle", [10117] = "rifle.bolt.skin.boltrifle.dreamcatcher",
			[10059] = "mask.bandana.green.skin", [10060] = "mask.bandana.blue.skin", [10061] = "mask.bandana.black.skin", [10062] = "mask.bandana.camo.snow.skin", [10063] = "mask.bandana.camo.forest.skin", [10064] = "mask.bandana.skull.black.skin", [10065] = "mask.bandana.skull.red.skin", [10066] = "mask.bandana.camo.desert.skin", [10067] = "mask.bandana.checkered.black.skin", [10079] = "mask.bandana.skin.bandana.wizardbandana", [10104] = "mask.bandana.skin.bandana.creepyclownbandana",
			[10058] = "hat.boonie.skin.boonie.farmerhat",
			[10136] = "burlap.shirt.skin.burlapshirt.piratevest&shirt",
			[10143] = "shotgun.waterpipe.skin.pipeshotgun.thepeacepipe",
			[10197] = "rock.skull.skin",
			[10127] = "bucket.helmet.skin.buckethat.medichelmet",
			[10112] = "jacket.snow.woodland", [10113] = "jacket.snow.black", 
			[10008] = "jacket.snowcamo", [10009] = "jacket.green", [10010] = "jacket.red", [10011] = "jacket.blue", [10012] = "jacket.desertcamo", [10013] = "jacket.multicam", [10014] = "jacket.urbancamo", [10015] = "jacket.hunter", [10072] = "jacket.skin.provocateur",
			[10073] = "pistol.semiauto.skin.semiautopistol.redshine", [10081] = "pistol.semiauto.skin.semiautopistol.reapernotepistol", [10087] = "pistol.semiauto.skin.semiautopistol.contaminationpistol", [10108] = "pistol.semiauto.skin.semiautopistol.halloweenbat",
			[10128] = "burlap.gloves.skin.burlapgloves.boxer'sbandages",
			[10004] = "tshirt.long.black", [10005] = "tshirt.long.grey", [10006] = "tshirt.long.orange", [10007] = "tshirt.long.yellow", [10032] = "tshirt.long.shirtgreen", [10036] = "tshirt.long.skin.longtshirt.signpainter'slongtshirt", [10042] = "tshirt.long.skin.longtshirt.varsityjacket", [10047] = "tshirt.long.skin.longtshirt.azteclongt-shirt", [10050] = "tshirt.long.skin.longtshirt.frankensteinssweater", [10051] = "tshirt.long.skin.longtshirt.nightmaresweater", [10106] = "tshirt.long.skin.longtshirt.creepyjack", [10118] = "tshirt.long.skin.longtshirt.merryreindeer",
			[101] = "tshirt.red", [10002] = "tshirt.gmod", [10003] = "tshirt.black", [10024] = "tshirt.flag.germany", [10025] = "tshirt.flag.russia", [10033] = "tshirt.skin.baseball", [10035] = "tshirt.skin.hackervalleyveteran", [10038] = "tshirt.skin.murderer", [10039] = "tshirt.skin.targetpractice", [10041] = "tshirt.skin.blackskull&bones", [10043] = "tshirt.skin.vyshyvanka", [10046] = "tshirt.skin.missingtexturesfull", [10053] = "tshirt.skin.smilet-shirt", [10130] = "tshirt.skin.argylescavenger", [10134] = "tshirt.skin.serwinter", [14177] = "tshirt.blue", [14181] = "tshirt.forestcamo", [584379] = "tshirt.urbancamo",
			[10054] = "mask.balaclava.skin.balaclava.rorschachskull", [10057] = "mask.balaclava.skin.balaclava.muricabalaclava", [10068] = "mask.balaclava.camo.forest.skin", [10069] = "mask.balaclava.camo.desert.skin", [10070] = "mask.balaclava.check.red.skin", [10071] = "mask.balaclava.stripe.yellow.skin", [10075] = "mask.balaclava.skin.balaclava.nightmarebalaclava", [10084] = "mask.balaclava.skin.balaclava.therustknight", [10090] = "mask.balaclava.skin.balaclava.skinbalaclava", [10111] = "mask.balaclava.skin.balaclava.zipperface", [10139] = "mask.balaclava.skin.balaclava.valentinebalaclava",
			[10016] = "hat.beenie.red", [10017] = "hat.beenie.green", [10018] = "hat.beenie.blue", [10040] = "hat.beenie.skin.beenie.rastabeenie", [10085] = "hat.beenie.skin.beenie.winterdeers", [14180] = "hat.beenie.black",
			[13000] = "beachchair.camo", [13001] = "beachchair.flamingo", [13002] = "beachchair.leaves", [13003] = "beachchair.pizza", [13004] = "beachchair.target", [13005] = "beachchair.tarp", [13006] = "beachchair.zenlabs", 
			[13007] = "beachparasol.camo", [13008] = "beachparasol.flamingo", [13009] = "beachparasol.leaves", [13010] = "beachparasol.pizza", [13011] = "beachparasol.target", [13012] = "beachparasol.tarp", [13013] = "beachparasol.zenlabs",
			[13014] = "beachtowel.brownstripes", [13015] = "beachtowel.cobalt", [13016] = "beachtowel.dye", [13017] = "beachtowel.fish", [13018] = "beachtowel.shell", [13019] = "beachtowel.stripes", [13020] = "beachtowel.waves", 
			[13021] = "boogieboard.corrugated", [13022] = "boogieboard.crashtest", [13023] = "boogieboard.flames", [13024] = "boogieboard.marbled", [13025] = "boogieboard.shark", [13026] = "boogieboard.stars",
			[13027] = "innertube.camo", [13028] = "innertube.donut", [13029] = "innertube.horse", [13030] = "innertube.tire", [13031] = "innertube.unicorn", [13032] = "innertube.watermelon", [13033] = "innertube.zebra",
			[13034] = "paddlingpool.hottub", [13035] = "paddlingpool.rainbow", [13036] = "paddlingpool.seascape", [13037] = "paddlingpool.spawnpool",
			[13038] = "sunglasses.01.chalk", [13039] = "sunglasses.01.tortoise", [13040] = "sunglasses.02.black", [13041] = "sunglasses.02.camo", [13042] = "sunglasses.02.red", [13043] = "sunglasses.03.black", [13044] = "sunglasses.03.chrome", [13045] = "sunglasses.03.gold",
			[13046] = "gun.water.watergun.green", [13047] = "gun.water.watergun.grey", [13048] = "gun.water.watergun.orange", [13049] = "gun.water.watergun.yellow",
			[13055] = "twitch.headset.hat.cap_headset.twitch"
		};
		
		private void OnItemCraftFinished(ItemCraftTask task, Item item)
		{
			if(task.skinID == 0)
			{
				BasePlayer player = task.owner;
				
				if(!StoredData[player.userID].Skins.ContainsKey(item.info.shortname) || !permission.UserHasPermission(player.UserIDString, "xskinmenu.craft")) return;
				if(!StoredData[player.userID].ChangeSG && StoredData[player.userID].ChangeSC) 
					SetSkinCraftGive(player, item);
			}
		} 
		
		private void SetSkinItem(BasePlayer player, string item, ulong skin) 
		{
			foreach (var i in player.inventory.FindItemIDs(ItemManager.FindItemDefinition(item).itemid))
			{
				if (i.skin == skin || config.Setting.Blacklist.Contains(i.skin)) continue;
				
				if(errorskins.ContainsKey(skin))
				{
					var erroritem = errorskins[skin];
					
					i.UseItem();
					Item newitem = ItemManager.CreateByName(erroritem);
					newitem.condition = i.condition;
					newitem.maxCondition = i.maxCondition;
					
					player.GiveItem(newitem); 
				}
				else
				{
                    i.skin = skin;
                    i.MarkDirty();

                    BaseEntity entity = i.GetHeldEntity();
                    if (entity != null)
                    {
                        entity.skinID = skin;
                        entity.SendNetworkUpdate();
                    }
				}
			}
		}
		
		private void SetSkinCraftGive(BasePlayer player, Item item)
		{
			string shortname = item.info.shortname;
			ulong skin = StoredData[player.userID].Skins[shortname];
			
			if (item.skin == skin || config.Setting.Blacklist.Contains(item.skin)) return;
			
			if(errorskins.ContainsKey(skin))
			{
				var erroritem = errorskins[skin];
					
				item.UseItem();
				Item newitem = ItemManager.CreateByName(erroritem);
					
				player.GiveItem(newitem);
			}
			else
		    {
                item.skin = skin; 
                item.MarkDirty();

                BaseEntity entity = item.GetHeldEntity(); 
                if (entity != null)
                {
                    entity.skinID = skin;
                    entity.SendNetworkUpdate();
				}
			}
		}		
		
		private void SetSkinEntity(BasePlayer player, BaseEntity entity, string shortname)
		{
			ulong skin = StoredData[player.userID].Skins[shortname];
			
			if(skin == entity.skinID || skin == 0) return;
			if(errorskins.ContainsKey(skin))
			{
				SendInfo(player, lang.GetMessage("ERRORSKIN", this, player.UserIDString));
				return;
			}
			
			entity.skinID = skin;
            entity.SendNetworkUpdate();
			Effect.server.Run("assets/prefabs/deployable/repair bench/effects/skinchange_spraypaint.prefab", entity.transform.localPosition);
		}
		
		private void OnItemAddedToContainer(ItemContainer container, Item item)
		{
			if(container == null || item == null) return;
			if(container.playerOwner != null)
			{
				BasePlayer player = container.playerOwner;
			
				if(player == null || player.IsNpc || !player.userID.IsSteamId() || player.IsSleeping()) return;
				if(!permission.UserHasPermission(player.UserIDString, "xskinmenu.give") || !StoredData.ContainsKey(player.userID) || !StoredData[player.userID].Skins.ContainsKey(item.info.shortname)) return;
				if(StoredData[player.userID].ChangeSG) 
					SetSkinCraftGive(player, item);
			}
		} 
		
		#endregion		
		
		#region GUI
		
		private void GUI(BasePlayer player)
		{
			CuiHelper.DestroyUi(player, ".GUIS");
            CuiElementContainer container = new CuiElementContainer(); 
			
			container.Add(new CuiPanel
            {
				CursorEnabled = true,
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-507.5 -260", OffsetMax = "507.5 290" },
                Image = { Color = "0.51703192 0.521 0.509 0.95", Material = "assets/icons/greyout.mat" }
            }, "Overlay", ".GUIS");
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                Image = { Color = "0.217 0.221 0.209 0.95" }
            }, ".GUIS", ".SGUI");
			
			container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "470 237.5", OffsetMax = "497.5 265" },
                Button = { Color = "1 1 1 0.75", Sprite = "assets/icons/close.png", Close = ".GUIS" },
                Text = { Text = "" }
            }, ".SGUI");			
			
			container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-497.5 237.5", OffsetMax = "-470 265" },
                Button = { Color = "1 1 1 0.75", Sprite = "assets/icons/gear.png", Command = "skin_s open" },
                Text = { Text = "" }
            }, ".SGUI");
			
			container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-455 237.5", OffsetMax = "455 265" },
                Text = { Text = lang.GetMessage("TITLE", this, player.UserIDString), Align = TextAnchor.MiddleCenter, FontSize = 18, Color = "1 1 1 0.75" }
            }, ".SGUI");
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-507.5 227.5", OffsetMax = "507.5 232.5" },
                Image = { Color = "0.51703192 0.521 0.509 0.95", Material = "assets/content/ui/uibackgroundblur.mat" }
            }, ".SGUI");				
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-507.5 177.5", OffsetMax = "507.5 182.5" },
                Image = { Color = "0.51703192 0.521 0.509 0.95", Material = "assets/content/ui/uibackgroundblur.mat" }
            }, ".SGUI");			
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "460 227.5", OffsetMax = "465 275" },
                Image = { Color = "0.51703192 0.521 0.509 0.95", Material = "assets/content/ui/uibackgroundblur.mat" }
            }, ".SGUI");			
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-465 227.5", OffsetMax = "-460 275" },
                Image = { Color = "0.51703192 0.521 0.509 0.95", Material = "assets/content/ui/uibackgroundblur.mat" }
            }, ".SGUI");   
			
			CuiHelper.AddUi(player, container);
			
			CategoryGUI(player);
			if(config.Category.Count != 0) ItemGUI(player, config.Category.ElementAt(0).Key);
		}
		
		private void CategoryGUI(BasePlayer player, int page = 0)
		{
			CuiHelper.DestroyUi(player, ".SkinBUTTON");
            CuiElementContainer container = new CuiElementContainer();
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-497.5 187.5", OffsetMax = "497.5 222.5" },
                Image = { Color = "0 0 0 0" }
            }, ".SGUI", ".SkinBUTTON");
			
			int x = 0, count = config.Category.Count; 
			
			foreach(var category in config.Category)
			{
				string color = page == x ? "0.53 0.77 0.35 0.8" : "0 0 0 0";
				double offset = -(81 * count--) + -(2.5 * count--);

				container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{offset} -17.5", OffsetMax = $"{offset + 162} 17.5" },
                    Button = { Color = "0.51703192 0.521 0.509 0.5", Material = "assets/icons/greyout.mat", Command = $"skin_c category {category.Key} {x}" },
                    Text = { Text = lang.GetMessage(category.Key, this, player.UserIDString), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 18, Color = "0.75 0.75 0.75 1" }
                }, ".SkinBUTTON", ".BUTTON");
 
			    container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMax = "0 1.5" },
                    Image = { Color = color, Material = "assets/icons/greyout.mat" }
                }, ".BUTTON");
				
				x++;
			}
			
			CuiHelper.AddUi(player, container);
		}
		
		private void ItemGUI(BasePlayer player, string category, int Page = 0)
		{
			CuiHelper.DestroyUi(player, ".SettingGUI");
			CuiHelper.DestroyUi(player, ".SkinGUI");
			CuiHelper.DestroyUi(player, ".ItemGUI");
            CuiElementContainer container = new CuiElementContainer(); 
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-502.5 -270", OffsetMax = "502.5 177.5" },
                Image = { Color = "0 0 0 0" }
            }, ".SGUI", ".ItemGUI");
			
			int x = 0, y = 0, z = 0;
			
			foreach(var item in config.Category[category].Skip(Page * 40))
			{		
			    container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{-497.5 + (x * 100)} {123.25 - (y * 100)}", OffsetMax = $"{-402.5 + (x * 100)} {218.25 - (y * 100)}" },
                    Image = { Color = "0.51703192 0.521 0.509 0.5", Material = "assets/icons/greyout.mat" }
                }, ".ItemGUI", ".Item");
				
				container.Add(new CuiElement 
                {
                    Parent = ".Item",
                    Components =
                    {
					    new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", item + 150) },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" }
                    }
                });
				
				if(StoredDataSkins.ContainsKey(item) && StoredDataSkins[item].Count != 0 && StoredData[player.userID].Skins.ContainsKey(item))
				{
				    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                        Button = { Color = "0 0 0 0", Command = $"skin_c skin {item}" },
                        Text = { Text = "" }
                    }, ".Item");				    
				
				    if(StoredData[player.userID].Skins[item] != 0)
				        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-20 5", OffsetMax = "-5 20" },
                            Button = { Color = "1 1 1 0.75", Sprite = "assets/icons/clear.png", Command = $"skin_c clear {item} {z}" },
                            Text = { Text = "" }
                        }, ".Item", $".I + {z}");
				}
				
				x++;
				z++;
				
				if(x == 10)
				{
					x = 0;
					y++;
					
					if(y == 4)
						break;
				}
			}
			
			bool back = Page != 0;
			bool next = config.Category[category].Count > ((Page + 1) * 40);

			container.Add(new CuiButton 
            {    
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-190 5", OffsetMax = "-100 31.75" },
                Button = { Color = back ? "0.65 0.29 0.24 1" : "0.65 0.29 0.24 0.4", Command = back ? $"page.xskinmenu item back {category} {Page}" : "" },
                Text = { Text = lang.GetMessage("BACK", this, player.UserIDString), Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "robotocondensed-regular.ttf", Color = back ? "0.92 0.79 0.76 1" : "0.92 0.79 0.76 0.4" }
            }, ".ItemGUI");				 			
			
			container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-95 5", OffsetMax = "-5 31.75" },
                Button = { Color = next ? "0.35 0.45 0.25 1" : "0.35 0.45 0.25 0.4", Command = next ? $"page.xskinmenu item next {category} {Page}" : "" },
                Text = { Text = lang.GetMessage("NEXT", this, player.UserIDString), Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "robotocondensed-regular.ttf", Color = next ? "0.75 0.95 0.41 1" : "0.75 0.95 0.41 0.4" }
            }, ".ItemGUI");
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 36.75", OffsetMax = "0 41.75" },
                Image = { Color = "0.51703192 0.521 0.509 0.95", Material = "assets/icons/greyout.mat" }
            }, ".ItemGUI");			
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-200 0", OffsetMax = "-195 36.75" },
                Image = { Color = "0.51703192 0.521 0.509 0.95", Material = "assets/icons/greyout.mat" }
            }, ".ItemGUI");
			
			if(config.Setting.ButtonClear)
			{
				container.Add(new CuiButton
				{
					RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "5 5", OffsetMax = "190 31.75" },
					Button = { Color = "0.35 0.45 0.25 1", Command = "skin_c clearall" },
					Text = { Text = lang.GetMessage("CLEARALL", this, player.UserIDString), Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-regular.ttf", Color = "0.75 0.95 0.41 1" }
				}, ".ItemGUI");
			
				container.Add(new CuiPanel
				{
					RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "195 0", OffsetMax = "200 36.75" },
					Image = { Color = "0.51703192 0.521 0.509 0.95", Material = "assets/icons/greyout.mat" }
				}, ".ItemGUI");
			}
			
			CuiHelper.AddUi(player, container);
		}		
		
		private void SkinGUI(BasePlayer player, string item, int Page = 0)
		{
			CuiHelper.DestroyUi(player, ".SkinGUI");
            CuiElementContainer container = new CuiElementContainer(); 
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-502.5 -270", OffsetMax = "502.5 177.5" },
                Image = { Color = "0.217 0.221 0.209 1" }
            }, ".SGUI", ".SkinGUI");
			
			int x = 0, y = 0;
			ulong s = StoredData[player.userID].Skins[item];
			
			foreach(var skin in StoredDataSkins[item].Skip(Page * 40))
			{		
			    container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{-497.5 + (x * 100)} {123.25 - (y * 100)}", OffsetMax = $"{-402.5 + (x * 100)} {218.25 - (y * 100)}" },
                    Image = { Color = s == skin ? "0.53 0.77 0.35 0.8" : "0.51703192 0.521 0.509 0.5", Material = "assets/icons/greyout.mat" }
                }, ".SkinGUI", ".Skin");
				
				container.Add(new CuiElement
                {
                    Parent = ".Skin",
                    Components =
                    {
					    new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", errorskins.ContainsKey(skin) ? errorskins[skin] + 150 : facepunchskins.ContainsKey(skin) ? facepunchskins[skin] + 150 : $"{skin}152") },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" }
                    }
                });
				
				container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0", Command = $"skin_c setskin {item} {skin}" },
                    Text = { Text = "" }
                }, ".Skin");				
				
				x++;
				
				if(x == 10)
				{
					x = 0;
					y++;
					
					if(y == 4)
						break;
				}
			}
			
			bool back = Page != 0;
			bool next = StoredDataSkins[item].Count > ((Page + 1) * 40);
			
			container.Add(new CuiButton 
            {    
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-190 5", OffsetMax = "-100 31.75" },
                Button = { Color = back ? "0.65 0.29 0.24 1" : "0.65 0.29 0.24 0.4", Command = back ? $"page.xskinmenu skin back {item} {Page}" : "" },
                Text = { Text = lang.GetMessage("BACK", this, player.UserIDString), Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "robotocondensed-regular.ttf", Color = back ? "0.92 0.79 0.76 1" : "0.92 0.79 0.76 0.4" }
            }, ".SkinGUI");				 			
			
			container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-95 5", OffsetMax = "-5 31.75" },
                Button = { Color = next ? "0.35 0.45 0.25 1" : "0.35 0.45 0.25 0.4", Command = next ? $"page.xskinmenu skin next {item} {Page}" : "" },
                Text = { Text = lang.GetMessage("NEXT", this, player.UserIDString), Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "robotocondensed-regular.ttf", Color = next ? "0.75 0.95 0.41 1" : "0.75 0.95 0.41 0.4" }
            }, ".SkinGUI");
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 36.75", OffsetMax = "0 41.75" },
                Image = { Color = "0.51703192 0.521 0.509 0.95", Material = "assets/icons/greyout.mat" }
            }, ".SkinGUI");			
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-200 0", OffsetMax = "-195 36.75" },
                Image = { Color = "0.51703192 0.521 0.509 0.95", Material = "assets/icons/greyout.mat" }
            }, ".SkinGUI");
			
			CuiHelper.AddUi(player, container);
		}
		
		private void SettingGUI(BasePlayer player)
		{
			CuiHelper.DestroyUi(player, ".SettingGUI");
            CuiElementContainer container = new CuiElementContainer();
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-502.5 -270", OffsetMax = "502.5 177.5" },
                Image = { Color = "0.217 0.221 0.209 1" }
            }, ".SGUI", ".SettingGUI");
			
			container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-300 -105", OffsetMax = "300 -80" },
                Text = { Text = lang.GetMessage("SETINFO", this, player.UserIDString), Align = TextAnchor.LowerCenter, Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "0.75 0.75 0.75 0.4" }
            }, ".SettingGUI");
			
			container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Close = ".SettingGUI" },
                Text = { Text = "" }
            }, ".SettingGUI");
			
			container.Add(new CuiPanel
            { 
				CursorEnabled = true,
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-400 -75", OffsetMax = "400 75" },
                Image = { Color = "0.51703192 0.521 0.509 0.95", Material = "assets/icons/greyout.mat" }
            }, ".SettingGUI", ".SGUIM");
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                Image = { Color = "0.217 0.221 0.209 0.95" }
            }, ".SGUIM", ".SGUIMM");
			
			Dictionary<string, bool> setting = new Dictionary<string, bool>
			{
				["inventory"] = StoredData[player.userID].ChangeSI,
				["entity"] = StoredData[player.userID].ChangeSE,
				["craft"] = StoredData[player.userID].ChangeSC,
				["clear"] = StoredData[player.userID].ChangeSCL,
				["give"] = StoredData[player.userID].ChangeSG,
				["friends"] = StoredDataFriends[player.userID]
			};
			
			int x = 0, y = 0;
			
			foreach(var s in setting) 
			{		
			    container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{-390 + (x * 392.5)} {25 - (y * 45)}", OffsetMax = $"{-2.5 + (x * 392.5)} {65 - (y * 45)}" },
                    Image = { Color = "0.51703192 0.521 0.509 0.5", Material = "assets/icons/greyout.mat" }
                }, ".SGUIMM", ".SM");
				
				container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-190 -15", OffsetMax = "-160 15" },
                    Button = { Color = s.Value ? config.MenuS.CTButton : config.MenuS.CFButton, Sprite = s.Value ? config.MenuS.TButtonIcon : config.MenuS.FButtonIcon, Command = $"skin_s {s.Key}" },
                    Text = { Text = "" }
                }, ".SM");				
				
			    container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-155 -15", OffsetMax = "190 15" },
                    Text = { Text = lang.GetMessage(s.Key, this, player.UserIDString), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 15, Color = "0.75 0.75 0.75 1" }
                }, ".SM");
				
				x++;
				
				if(x == 2)
				{
					x = 0;
					y++;
				}
			}
			
			CuiHelper.AddUi(player, container);
		}  
		
		#endregion
		
		#region Message
		
		private void SendInfo(BasePlayer player, string message)
        {
            player.SendConsoleCommand("gametip.showgametip", message);
            timer.Once(5f, () => player.SendConsoleCommand("gametip.hidegametip"));
        }
		
		#endregion
		
		#region Lang
 
        private void InitializeLang()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TITLE"] = "COOL SERVER SKINS MENU",
				["SETINFO"] = "YOU CAN CUSTOMIZE THE MENU DEPENDING ON THE SITUATION!",
				["ERRORSKIN"] = "THE SKIN YOU CHOSE CAN BE CHANGED ONLY IN THE INVENTORY OR WHEN CRAFTING!",
				["CLEARALL"] = "UPDATE MY SKIN LIST",
				["NOPERM"] = "No permissions!",
				["NEXT"] = "NEXT",
				["BACK"] = "BACK",
                ["weapon"] = "WEAPON",
                ["construction"] = "CONSTRUCTION",
                ["item"] = "ITEM",
                ["attire"] = "ATTIRE",
                ["tool"] = "TOOL",
                ["inventory"] = "CHANGE SKIN IN INVENTORY",
                ["entity"] = "CHANGE SKIN ON OBJECTS", 
                ["craft"] = "CHANGE SKIN WHEN CRAFTING",
                ["clear"] = "CHANGE SKIN WHEN DELETING",
                ["give"] = "SKIN CHANGE WHEN DROP IN INVENTORY",
				["friends"] = "ALLOW FRIENDS TO CHANGE YOUR SKINS"
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TITLE"] = "МЕНЮ СКИНОВ КРУТОГО СЕРВЕРА",
                ["SETINFO"] = "ВЫ МОЖЕТЕ КАСТОМНО НАСТРАИВАТЬ МЕНЮ В ЗАВИСИМОСТИ ОТ СИТУАЦИИ!",
                ["ERRORSKIN"] = "ВЫБРАННЫЙ ВАМИ СКИН МОЖНО ИЗМЕНИТЬ ТОЛЬКО В ИНВЕНТАРЕ ИЛИ ПРИ КРАФТЕ!",
                ["CLEARALL"] = "ОБНОВИТЬ МОЙ СПИСОК СКИНОВ",
				["NOPERM"] = "Недостаточно прав!",
				["NEXT"] = "ДАЛЕЕ",
				["BACK"] = "НАЗАД",
                ["weapon"] = "ОРУЖИЕ",
                ["construction"] = "СТРОИТЕЛЬСТВО",
                ["item"] = "ПРЕДМЕТЫ",
                ["attire"] = "ОДЕЖДА",
                ["tool"] = "ИНСТРУМЕНТЫ",
                ["inventory"] = "ПОМЕНЯТЬ СКИН В ИНВЕНТАРЕ",
                ["entity"] = "ПОМЕНЯТЬ СКИН НА ПРЕДМЕТАХ",
                ["craft"] = "ПОМЕНЯТЬ СКИН ПРИ КРАФТЕ",
                ["clear"] = "ПОМЕНЯТЬ СКИН ПРИ УДАЛЕНИИ",
                ["give"] = "ПОМЕНЯТЬ СКИН ПРИ ПОПАДАНИИ В ИНВЕНТАРЬ",
                ["friends"] = "РАЗРЕШИТЬ ДРУЗЬЯМ ИЗМЕНЯТЬ ВАШИ СКИНЫ"
            }, this, "ru");
        }

        #endregion
	}
}

// --- End of file: XSkinMenu.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/MonumentProtection.cs ---
// --- Original Local Path: MonumentProtection.cs ---

﻿using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using UnityEngine;
using static Oxide.Plugins.MonumentProtectionEx.MonumentProtectionEx;
using System.Linq;

namespace Oxide.Plugins
{
    [Info( "Monument Protection", "Waggy", "1.0.4", ResourceId = 154 )]
    [Description( "" )]

    public class MonumentProtection : RustPlugin
    {
        private static MonumentProtection PluginInstance;
        private List<SamSite> SamSites = new List<SamSite>();

        public Dictionary<Vector3, MonumentInfo> SamPositions = new Dictionary<Vector3, MonumentInfo>();

        private Timer RespawnTimer;

        //[ChatCommand( "localpos" )]
        //void LocalPosition( BasePlayer player, string command, string[] args )
        //{
        //    var samSite = RaycastLookDirection<SamSite>( player );
        //    if ( samSite != null )
        //    {
        //        float lowestDist = float.MaxValue;
        //        MonumentInfo closest = null;
        //        foreach ( var monument in UnityEngine.Object.FindObjectsOfType<MonumentInfo>()/*.Where(x => x.GetMonumentName() == MonumentName.LaunchSite) */)
        //        {
        //            float dist = Vector3.Distance( player.transform.position, monument.transform.position );
        //            if ( dist < lowestDist )
        //            {
        //                lowestDist = dist;
        //                closest = monument;
        //            }
        //        }

        //        var localPos = closest.transform.InverseTransformPoint( samSite.transform.position );
        //        var rotation = samSite.transform.rotation;
        //        PrintToChat( $"Pos: {localPos.ToString( "F4" )} Rotation: {rotation.ToString( "F4" )}" );
        //    }
        //}

        #region Entity Raycast

        int layer = LayerMask.GetMask( "AI", "Construction", "Deployed", "Default", "Debris", "Ragdoll", "Tree", "Vehicle Movement" );

        private T RaycastLookDirection<T>( BasePlayer player, string prefabName = "" ) where T : BaseEntity
        {
            RaycastHit hit;
            if ( !Physics.Raycast( player.eyes.BodyRay(), out hit, 5f, layer ) )
            {
                return null;
            }
            T entity = hit.GetEntity() as T;
            return entity;
        }

        #endregion

        public void SpawnSAMSites()
        {
            foreach ( var monument in UnityEngine.Object.FindObjectsOfType<MonumentInfo>() )
            {
                bool canSpawn = false;
                var monumentName = monument.GetMonumentName();
                if ( !config.MonumentWithSAMs.TryGetValue( monumentName, out canSpawn ) || !canSpawn )
                    continue;

                switch ( monumentName )
                {
                    default: continue;
                    case MonumentName.LaunchSite:
                        {
                            SamPositions.Add( new Vector3( 222.5791f, 20.7363f, 24.2286f ), monument );
                            SamPositions.Add( new Vector3( 226.3754f, 20.7363f, -23.9451f ), monument );
                            SamPositions.Add( new Vector3( 117.1534f, 12.0363f, 31.9013f ), monument );

                            break;
                        }
                    case MonumentName.Trainyard:
                        {
                            SamPositions.Add( new Vector3( 58.4138f, 30.2905f, 12.3804f ), monument );
                            SamPositions.Add( new Vector3( 49.1168f, 30.2773f, 18.5964f ), monument );
                                                                                        
                            break;                                                      
                        }                                                               
                    case MonumentName.Dome:                                             
                        {                                                               
                            SamPositions.Add( new Vector3( 35.9377f, 18.0663f, 41.2695f ), monument );
                            SamPositions.Add( new Vector3( 19.5758f, 59.4494f, -7.3288f ), monument );
                            SamPositions.Add( new Vector3( -24.5651f, 59.4994f, -8.7703f ), monument );
                            SamPositions.Add( new Vector3( -19.7446f, 3.1654f, -34.9776f ), monument );
                            SamPositions.Add( new Vector3( 20.3374f, 3.4097f, 50.4880f ), monument );
                                                                                         
                            break;                                                       
                        }                                                                
                    case MonumentName.Powerplant:                                   