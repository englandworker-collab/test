= { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                            Text = { Text = text, Align = TextAnchor.MiddleCenter, FontSize = 10, Font = "robotocondensed-bold.ttf", Color = "1 1 1 0.8"}
                        }, MenuPoint + Settings.Points.IndexOf(point) + ".Overflow" ,MenuPoint + Settings.Points.IndexOf(point) + ".OverflowText"); 
                    }  
                }

                CuiHelper.AddUi(player, container);
            }
            
            public static void DrawExternalLayer(BasePlayer player)
            {
                CuiElementContainer container = new CuiElementContainer();
                CuiHelper.DestroyUi(player, External);
                CuiHelper.DestroyUi(player, Internal);
                CuiHelper.DestroyUi(player, InterInternal);

                container.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0"},
                    Image = { Color = "0.235 0.227 0.180 0.90" } 
                }, "Overlay", External);
                
                container.Add(new CuiPanel
                {
                    RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0"},
                    Image = { Color = "0 0 0 0.2" } 
                }, External);

                container.Add(new CuiPanel
                { 
                    CursorEnabled = true,
                    RectTransform = {AnchorMin = "0.3 0", AnchorMax = "1 1", OffsetMax = "0 0"},
                    Image = { Color = "0 0 0 0" } 
                }, "Overlay", Internal);

                container.Add(new CuiPanel
                { 
                    CursorEnabled = true,
                    RectTransform = {AnchorMin = "0.95 0", AnchorMax = "1 1", OffsetMax = "0 0"},
                    Image = { Color = "0 0 0 0" } 
                }, "Overlay", InterInternal);
                container.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0"},
                    Image = {Color = "0.141 0.137 0.109 1", Sprite = "assets/content/ui/ui.background.transparent.radial.psd"}
                }, External, MenuPoint);

                container.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    RectTransform = {AnchorMin = "0 0.8", AnchorMax = "1 1", OffsetMax = "0 0"},
                    Image = {Color = "0 0 0 0", Sprite = "assets/content/ui/ui.background.transparent.radial.psd"}
                }, External, PrivPoint);

                container.Add(new CuiButton 
                {
                    RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = $"-35 -35", OffsetMax = "-10 -10" },
                    Button = { Color = "0.929 0.882 0.847 0.6", Command = "UI_RM_Handler close", Sprite = "assets/icons/close.png", Close = Interface.InterInternal }, 
                    Text = { Text = "" }
                }, InterInternal);
                
                CuiHelper.AddUi(player, container);
            }

            public static void OpenMenu(BasePlayer player)
            {
                if (!_.OpenMenu.ContainsKey(player))
                    _.OpenMenu.Add(player, Settings.Points.FirstOrDefault(p => p.DisplayName.ToLower() == "календарь")); 
                
                DrawExternalLayer(player); 
                DrawMenuPoints(player);
                DrawPrivileges(player); 
                
                _.plugins.Find("Menu").Call("ShowMenu", player); 
                //DrawTopImage(player); 
            }
            
            
        }

        private class MenuPoint
        {
            public string DisplayName;
            public string DrawMethod;

            public float TextMargin;
            public string TextMethod;
            public bool NewInfo;
        }

        private class Configuration
        {
            [JsonProperty("Название сервера")]
            public string ServerName;
            [JsonProperty("Список доступных разделов меню")]
            public List<MenuPoint> Points = new List<MenuPoint>();

            public Dictionary<string, string> GroupImages = new Dictionary<string, string>();
            public Dictionary<float, string> RawImages = new Dictionary<float, string>();
            

            public static Configuration Generate()
            {
                return new Configuration
                {
                    ServerName = "BLOOD RED MAX2",
                    GroupImages = new Dictionary<string, string>
                    {
                        ["kabanchik"] = "https://i.imgur.com/8p7yiVh.png",
                        ["joker"] = "https://i.imgur.com/TH9qtZ7.png",  
                        ["masnik"] = "https://i.imgur.com/XIQQXSo.png",
						["smert"] = "https://i.imgur.com/oqfU7RT.png",  
                    },
                    RawImages = new Dictionary<float, string>
                    {
                        
                    },
                    Points = new List<MenuPoint>
                    {
                        new MenuPoint
                        {
                            DisplayName = "КОРЗИНА",
                            TextMethod = "call:store",  
                            TextMargin = -120,
                            DrawMethod = "storeSecret"
                        },
                        new MenuPoint
                        {
                            DisplayName = "৑"
                        },
                        new MenuPoint
                        {
                            DisplayName = "НАЁМНИКИ",
                            DrawMethod = "chat.say /furySecret"
                        },
                        new MenuPoint
                        { 
                            DisplayName = "КАЛЕНДАРЬ", 
                            DrawMethod = "chat.say /wipe" 
                        },
                        new MenuPoint 
                        {
                            DisplayName = "РЕПОРТ",
                            DrawMethod = "chat.say /reportSecret",
                            TextMethod = "call:report",
                            TextMargin = -140
                        },
                        new MenuPoint
                        {
                            DisplayName = "ВАЙПБЛОК",
                            DrawMethod = "chat.say /block" 
                        },
                        new MenuPoint
                        {
                            DisplayName = "ИНФОРМАЦИЯ",
                            DrawMethod = "chat.say /help",
                        },
                        new MenuPoint
                        {
                            DisplayName = ""
                        },
                        new MenuPoint
                        {
                            DisplayName = "НАСТРОЙКИ",
                            DrawMethod = "chat.say /settings",
                        },
                        new MenuPoint
                        {
                            DisplayName = ""
                        },
                        new MenuPoint
                        {
                            DisplayName = "ЗАКРЫТЬ",
                            DrawMethod = "UI_RM_Handler close"
                        },
                    }
                };
            }
        }
        
        #endregion

        #region Variables

        [PluginReference] private Plugin ImageLibrary;
        private static RustMenu _;
        private static Configuration Settings = Configuration.Generate();

        #endregion

        #region Hooks

        private void OnServerInitialized()
        {
            _ = this;

            foreach (var check in Settings.GroupImages)
            {
                ImageLibrary.Call("AddImage", check.Value, "G" + check.Key);
            }
            
            timer.Every(1, () =>
            {
                foreach (var check in OpenMenu)
                {
                    if (check.Key.IsConnected)
                    {
                        Interface.DrawPrivileges(check.Key);
                        Interface.DrawMenuWithoutPoints(check.Key);
                    }
                }
                
            });
            
            //foreach (var check in FileSystem.FindAll("", "psd"))
            //    LogToFile("SAfd", check, this);  
            
            foreach (var check in Settings.RawImages)
            {
                ImageLibrary.Call("AddImage", check.Value, $"I.{check.Key}");
            }
 
            ImageLibrary.Call("AddImage", "https://i.imgur.com/c3DqDdw.png", $"H.Image");
            Interface.NotificationImage = (string) ImageLibrary.Call("GetImage", "NotificationImage");
        } 
        
        #endregion

        #region Commands

        [ConsoleCommand("UI_RM_Handler")]
        private void CmdConsoleRustMenu(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null || !args.HasArgs(1)) return;

            switch (args.Args[0].ToLower())
            {
                case "close":
                { 
                    if (OpenMenu.ContainsKey(player))
                        OpenMenu.Remove(player);
                    
                    CuiHelper.DestroyUi(player, Interface.External);
                    CuiHelper.DestroyUi(player, Interface.Internal);
                    CuiHelper.DestroyUi(player, Interface.InterInternal);

                    plugins.Find("Menu").Call("CloseMenu", player);
                    break;
                }
                case "choose":
                {
                    int chooseIndex = -1;
                    if (!int.TryParse(args.Args[1], out chooseIndex)) return;

                    var chooseElement = Settings.Points.ElementAtOrDefault(chooseIndex);
                    if (chooseElement == null) return;

                    CuiHelper.DestroyUi(player, Interface.Internal); 
                    CuiHelper.DestroyUi(player, Interface.InterInternal); 
                    CuiElementContainer container = new CuiElementContainer();
                    container.Add(new CuiPanel
                    { 
                        CursorEnabled = true,
                        RectTransform = {AnchorMin = "0.3 0", AnchorMax = "1 1", OffsetMax = "0 0"},
                        Image = { Color = "0 0 0 0" } 
                    }, "Overlay", Interface.Internal);

                    /*container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = $"-35 -35", OffsetMax = "-10 -10" },
                        Button = { Color = "1 1 1 0.6", Command = "UI_RM_Handler close", Sprite = "assets/icons/close.png" }, 
                        Text = { Text = "" }
                    }, Interface.Internal);*/
                    
                    CuiHelper.AddUi(player, container);
                    
                    player.SendConsoleCommand(chooseElement.DrawMethod);
                    
                    Interface.DrawPrivileges(player);  
                    Interface.DrawMenuPoints(player, chooseElement);
                    
                    //Effect effect = new Effect("", player, 0, new Vector3(), new Vector3());
                    //EffectNetwork.Send(effect, player.Connection);

                    OpenMenu[player] = chooseElement;
 
                    container.Clear();
                    container.Add(new CuiPanel
                    { 
                        CursorEnabled = true,
                        RectTransform = {AnchorMin = "0.95 0", AnchorMax = "1 1", OffsetMax = "0 0"},
                        Image = { Color = "0 0 0 0" } 
                    }, "Overlay", Interface.InterInternal);
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = $"-35 -35", OffsetMax = "-10 -10" },
                        Button = { Color = "0.929 0.882 0.847 0.6", Command = "UI_RM_Handler close", Sprite = "assets/icons/close.png", Close = Interface.InterInternal}, 
                        Text = { Text = "" } 
                    }, Interface.InterInternal);
                    
                    CuiHelper.AddUi(player, container); 
                    break;
                }
            }
        }

        #endregion

        #region Unload

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        [ChatCommand("menuSecret")]
        private void CmdChatXs(BasePlayer player)
        {
            Interface.OpenMenu(player);

            Interface.DrawPrivileges(player); 
        } 
        [ChatCommand("menu")]
        private void CmdChatX(BasePlayer player)
        {
            Interface.OpenMenu(player);

            var first = Settings.Points.FirstOrDefault(p => p.DisplayName.Contains("৑"));
            OpenMenu[player] = Settings.Points.FirstOrDefault(p => p.DisplayName.ToLower() == "৑");
            Interface.DrawMenuPoints(player, first);
            Interface.DrawPrivileges(player); 
            player.SendConsoleCommand(first.DrawMethod);
        }

        private void Unload()
        {
            BasePlayer.activePlayerList.ToList().ToList().ForEach(p =>
            {
                CuiHelper.DestroyUi(p, Interface.External);
                CuiHelper.DestroyUi(p, Interface.Internal);
                CuiHelper.DestroyUi(p, Interface.InterInternal);
            });
        }

        #endregion
    }
}

// --- End of file: RustMenu.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SoInfo.cs ---
// --- Original Local Path: SoInfo.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("SoInfo", "Sempai#3239", "1.0.2")]
    public class SoInfo : RustPlugin
    {
        private ConfigData cfg { get; set; }

        private class ConfigData
        {
            [JsonProperty("Стартовая страница")] public string Name = "Капсулы";
            [JsonProperty("Цвет линий")] public string Color = "#E10394";
            [JsonProperty("Цвет линий(Открытой вкладки)")] public string ColorOpen = "#e64544";
            [JsonProperty("Включить открытие при заходе?")]
            public bool coonect = false;
            [JsonProperty("Список кнопок")]
            public Dictionary<string, TextInfo> _itemList = new Dictionary<string, TextInfo>();
            public static ConfigData GetNewConf()
            {
                var newConfig = new ConfigData();
                newConfig._itemList = new Dictionary<string, TextInfo>()
                {
                    ["Капсулы"] = new TextInfo()
                    {
                        Lable = "КАПСУЛЫ",
                        Text = new List<string>
                        {
                            "Бла бла бла бла бла", 
                        },
                        UnderLable = "Информация по капсулам"
                    },
                    ["SoFriends"] = new TextInfo()
                    {
                        Lable = "СИСТЕМА ДРУЗЕЙ",
                        Text = new List<string>
                        {
                            "Бла бла бла бла бла", 
                        },
                        UnderLable = "Информация по SoFriends"
                    },
                    ["SoReport"] = new TextInfo()
                    {
                        Lable = "РЕПОРТ",
                        Text = new List<string>
                        {
                            "Бла бла бла бла бла", 
                        },
                        UnderLable = "Информация по SoReport"
                    },
                    ["SoPass"] = new TextInfo()
                    {
                        Lable = "БАТЛ ПАСС",
                        Text = new List<string>
                        {
                            "Бла бла бла бла бла", 
                        },
                        UnderLable = "Информация по SoPass"
                    }, 
                    ["SoKits"] = new TextInfo()
                    {
                        Lable = "КИТЫ",
                        Text = new List<string>
                        {
                            "Бла бла бла бла бла", 
                        },
                        UnderLable = "Информация по SoKits"
                    },
                    ["MicorPanel"] = new TextInfo()
                    {
                        Lable = "Микропанель",
                        Text = new List<string>
                        {
                            "Бла бла бла бла бла", 
                        },
                        UnderLable = "Информация по SoPass"
                    },   
                    ["SoInfo"] = new TextInfo()
                    {
                        Lable = "Информация",
                        Text = new List<string>
                        {
                            "Бла бла бла бла бла", 
                        },
                        UnderLable = "Информация по SoKits"
                    },
                    ["SoCraftSystem"] = new TextInfo()
                    {
                        Lable = "Крафт Система",
                        Text = new List<string>
                        {
                            "Бла бла бла бла бла", 
                        },
                        UnderLable = "Информация по SoPass"
                    }, 
                    ["SoTeleport"] = new TextInfo()
                    {
                        Lable = "Телепорь",
                        Text = new List<string>
                        {
                            "Бла бла бла бла бла", 
                        },
                        UnderLable = "Информация по SoKits"
                    },
                };
                return newConfig;
            }
        }

        protected override void LoadDefaultConfig()
        {
            cfg = ConfigData.GetNewConf();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(cfg);
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                cfg = Config.ReadObject<ConfigData>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        class TextInfo
        {
            public string Lable;
            public string UnderLable;
            public List<string> Text;
        }
        private static string Layer = "UiSoInfo";
        private static string LayerMain = "UiSoInfoMain";
        private string Hud = "Hud";
        private string Overlay = "Overlay";
        private string regular = "robotocondensed-regular.ttf";
        private static string Sharp = "assets/content/ui/ui.background.tile.psd";
        private static string Blur = "assets/content/ui/uibackgroundblur.mat";
        public static string radial = "assets/content/ui/ui.background.transparent.radial.psd";

        private CuiPanel _fon = new CuiPanel()
        {
            RectTransform =
            {
                AnchorMin = "0 0", 
                AnchorMax = "1 1"
            },
            CursorEnabled = true,
            Image =
            {
                Color = HexToRustFormat("#2f2f26f1"),
                Material = radial,
            }
        };

        private CuiPanel _mainFon = new CuiPanel()
        {
            RectTransform = 
            {
                AnchorMin = "0.5 0.5", 
                AnchorMax = "0.5 0.5", 
                OffsetMin = "-1920 -1080",
                OffsetMax = "1920 1080"
            },
            Image =
            {
                Color = "0 0.2312312 0.312312312 0"
            }
        };

        private CuiPanel _mainFon2 = new CuiPanel()
        {
            RectTransform =
            {
                AnchorMin = "0.3333333 0.3333333", 
                AnchorMax = "0.6666667 0.6666667"
            },
            Image =
            {
                Color = "0 0.2312312 0.312312312 0"
            }
        };

        [ChatCommand("info")]
        private void StartUi(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, Layer);
            var cont = new CuiElementContainer();
            cont.Add(_fon, Overlay, Layer);
            cont.Add(_mainFon, Layer, Layer + "off");
            cont.Add(_mainFon2, Layer + "off", LayerMain);
            cont.Add(new CuiButton()
            {
                RectTransform =
                {
                    AnchorMin = "0.8281241 0.02222228",
                    AnchorMax = "0.9765615 0.08055702"
                },
                Button =
                {
                    Close = Layer, 
                    Color = "0 0 0 0"
                },
                Text =
                {
                    Text = "Покинуть меню", 
                    Align = TextAnchor.MiddleCenter, FontSize = 20
                }
            }, LayerMain);
            cont.Add(new CuiButton()
            {
                RectTransform =
                {
                    AnchorMin = "0.8296865 0.03055555", 
                    AnchorMax = "0.978124 0.03296291"
                },
                Button = {
                    
                    Close = Layer, 
                    Color = HexToRustFormat(cfg.Color)
                    
                },
                Text =
                {
                    Text = "", 
                    Align = TextAnchor.MiddleCenter
                }
            }, LayerMain);
            float i = 0;
            foreach (var key in cfg._itemList)
            {
                cont.Add(new CuiButton()
                {
                    Button =
                    {
                        Command = $"uisoinfo {key.Key}", Color = "0 0 0 0"
                    },
                    Text =
                    {
                        Text = $"{key.Key.ToUpper()}", Align = TextAnchor.MiddleCenter, FontSize = 18
                    },
                    RectTransform =
                    {
                        AnchorMin = $"0.07864577 {0.7212963 - i}", AnchorMax = $"0.1802083 {0.749074 - i}"
                    }
                }, LayerMain);
                cont.Add(new CuiButton()
                {
                    Button = 
                        {Command = $"uisoinfo {key.Key}", Color = HexToRustFormat(cfg.Color)},
                    Text =
                    {
                        Text = $""
                    },
                    RectTransform =
                    {
                        AnchorMin = $"0.07864577 {0.7138891 - i}", AnchorMax = $"0.1802083 {0.7175925 - i}"
                    }
                }, LayerMain, $"Poloska + {key.Key}");
                i += 0.0546f;
            }
            cont.Add(new CuiPanel()
            {
                RectTransform =
                {
                    AnchorMin = "0.2401047 0.1416666", AnchorMax = "0.8145837 0.9666666"
                },
                Image =
                {
                    Color = "0 0 0 0"
                }
            }, LayerMain, LayerMain + "Info");
            TextInfo text;
            if (!cfg._itemList.TryGetValue(cfg.Name, out text)) return;
            string mes = text.Text.Aggregate(String.Empty, (current, m) => current + $"\n{m}");
            cont.Add(new CuiButton()
            {
                Button = {Command = $"uisoinfo {cfg.Name}", Color = HexToRustFormat(cfg.ColorOpen)},
                Text =
                {
                    Text = $""
                },
                RectTransform =
                {
                    AnchorMin = $"0 0", AnchorMax = $"1 1"
                }
            }, $"Poloska + {cfg.Name}", "Open");
            cont.Add(new CuiPanel()
            {
                RectTransform =
                {
                    AnchorMin = "0.2083334 0.1416666", AnchorMax = "0.7828124 0.9666666"
                },
                Image =
                { 
                    Color = "0 0 0 0"
                }
            }, LayerMain, LayerMain + "Info");

            cont.Add(new CuiElement()
            {
                Parent = LayerMain + "Info",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = text.Lable.ToUpper(), Align = TextAnchor.MiddleCenter, FontSize = 35
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.3327288 0.875926", AnchorMax = "0.6854033 0.9472503"
                    }
                }
            });
            cont.Add(new CuiElement()
            {
                Parent = LayerMain + "Info",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = text.UnderLable, Align = TextAnchor.MiddleCenter, FontSize = 14, Font = regular
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.3345421 0.8268534", AnchorMax = "0.6817771 0.8851866"
                    }
                }
            });
            cont.Add(new CuiElement()
            {
                Parent = LayerMain + "Info",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = mes, Align = TextAnchor.MiddleCenter, FontSize = 18, Font = regular
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.00543952 0.05723912", AnchorMax = "1 0.7968574"
                    }
                } 
            });
            CuiHelper.AddUi(player, cont);
        }

        [ConsoleCommand("uisoinfo")]
        private void LoadButtonInfo(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            CuiHelper.DestroyUi(player, LayerMain + "Info");
            CuiHelper.DestroyUi(player, "Open");
            var key = String.Join(" ", arg.Args.ToArray());
            TextInfo text;
            if (!cfg._itemList.TryGetValue(key, out text)) return;
            string mes = text.Text.Aggregate(String.Empty, (current, m) => current + $"\n{m}");
            var cont = new CuiElementContainer();
            cont.Add(new CuiButton()
            {
                Button =
                {
                    Command = $"uisoinfo {key}", 
                    Color = HexToRustFormat(cfg.ColorOpen)
                },
                Text =
                {
                    Text = $""
                },
                RectTransform =
                {
                    AnchorMin = $"0 0", AnchorMax = $"1 1"
                }
            }, $"Poloska + {key}", "Open");
            cont.Add(new CuiPanel()
            {
                RectTransform =
                {
                    AnchorMin = "0.2083334 0.1416666", AnchorMax = "0.7828124 0.9666666"
                },
                Image =
                { 
                    Color = "0 0 0 0"
                }
            }, LayerMain, LayerMain + "Info");

            cont.Add(new CuiElement()
            {
                Parent = LayerMain + "Info",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = text.Lable.ToUpper(), Align = TextAnchor.MiddleCenter, FontSize = 35
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.3327288 0.875926", AnchorMax = "0.6854033 0.9472503"
                    }
                }
            });
            cont.Add(new CuiElement()
            {
                Parent = LayerMain + "Info",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = text.UnderLable, Align = TextAnchor.MiddleCenter, FontSize = 14, Font = regular
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.3345421 0.8268534", AnchorMax = "0.6817771 0.8851866"
                    }
                }
            });
            cont.Add(new CuiElement()
            {
                Parent = LayerMain + "Info",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = mes, Align = TextAnchor.MiddleCenter, FontSize = 18, Font = regular
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = "0.00543952 0.05723912", AnchorMax = "1 0.7968574"
                    }
                } 
            });
            CuiHelper.AddUi(player, cont);
            Effect Sound1 = new Effect("assets/bundled/prefabs/fx/notice/loot.drag.grab.fx.prefab", player, 0, new Vector3(), new Vector3());
            EffectNetwork.Send(Sound1, player.Connection);
        }
        private void OnPlayerConnected(BasePlayer player)
        {
            if (cfg.coonect) NextTick(() => StartUi(player));
        }
        private void Unload() 
        {
            foreach (var basePlayer in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(basePlayer, Layer);
            }
        }
        #region Help

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex)) hex = "#FFFFFFFF";
            var str = hex.Trim('#');
            if (str.Length == 6) str += "FF";
            if (str.Length != 8)
            {
                throw new Exception(hex);
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);
            Color color = new Color32(r, g, b, a);
            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }

        #endregion
    }
}


// --- End of file: SoInfo.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SQLStatistics.cs ---
// --- Original Local Path: SQLStatistics.cs ---

﻿using System.Collections.Generic;
using Oxide.Core;
using System;
using System.Linq;
using Oxide.Core.Database;
using Connection = Oxide.Core.Database.Connection;
using Random = Oxide.Core.Random;

namespace Oxide.Plugins
{

	[Info("SQLStatistics", "Visagalis", "1.0.0")]
	[Description("Announces various statistics gathered by SQLStats to in-game chat.")]
	public class SQLStatistics : RustPlugin
	{
		private static readonly Core.MySql.Libraries.MySql _mySql = Interface.GetMod().GetLibrary<Core.MySql.Libraries.MySql>();
		private static Connection _mySqlConnection = null;
		private Dictionary<string, object> dbConnection = null;
		private readonly List<Timer> listOfTimers = new List<Timer>();
		private readonly List<StatisticData> listOfStatistics = new List<StatisticData>();
		protected override void LoadDefaultConfig() { }
		internal static SQLStatistics ss = null;
		private int currentStatistic = 0;

		private int getStatisticToDisplay()
		{
			if (currentStatistic > listOfStatistics.Count - 1)
				currentStatistic = 0;

			return currentStatistic++;
		}

		private T checkCfg<T>(string conf, T def)
		{
			if (Config[conf] != null)
			{
				return (T)Config[conf];
			}
			else
			{
				Config[conf] = def;
				return def;
			}
		}

		void Unload()
		{
			foreach (var t in listOfTimers)
			{
				t.Destroy();
			}
		}

		void OnServerInitialized()
		{
			ss = this;
			listOfStatistics.Add(new StatisticData
			{
				query = "select " +
						"p.name, " +
						"COUNT(1) destructionsCount " +
						"from " +
						"stats_player_destroy_building d " +
						"join stats_player p on d.player = p.id " +
						"WHERE tier not like \'TWIG%\' AND tier not like \'WOOD%\' " +
						"GROUP BY d.player " +
						"order by count(1) desc " +
						"LIMIT 5",
				announcementText = "Most stone, metal and armored constructions destroyed:",
				announcementInfo = "# / Player / Destroyed constructions",
				fieldsToDisplay = new[] { "name", "destructionsCount" }
			});

			listOfStatistics.Add(new StatisticData
			{
				query = @"select count(1) as kills, plr.name, ROUND(avg(pk.points), 2) AS averagePoints
							from 
							stats_player plr
							join stats_player_kill pk on pk.killer = plr.id
							join (select ipk.killer, count(1) from stats_player_kill ipk group by ipk.killer order by count(1) desc limit 25) top on top.killer = plr.id
							group by plr.name
							order by avg(points) asc
							limit 5",
				announcementText = "Players with the WORST score per kill ratio:",
				announcementInfo = "# / Player / Kills / Average score",
				fieldsToDisplay = new[] { "name", "kills", "averagePoints" }
			});

			listOfStatistics.Add(new StatisticData
			{
				query = @"select count(1) as kills, plr.name, ROUND(avg(pk.points), 2) AS averagePoints
							from 
							stats_player plr
							join stats_player_kill pk on pk.killer = plr.id
							join (select ipk.killer, count(1) from stats_player_kill ipk group by ipk.killer order by count(1) desc limit 25) top on top.killer = plr.id
							group by plr.name
							order by avg(points) desc
							limit 5",
				announcementText = "Players with the BEST score per kill ratio:",
				announcementInfo = "# / Player / Kills / Average score",
				fieldsToDisplay = new[] { "name", "kills", "averagePoints" }
			});

			listOfStatistics.Add(new StatisticData
			{
				query = "select " +
						"player.name, " +
						"SUM(shots.count) as shots " +
						"from stats_player_fire_bullet shots " +
						"join stats_player player on shots.player = player.id " +
						"group by name " +
						"order by SUM(count) desc " +
						"LIMIT 5",
				announcementText = "Most bullets shot:",
				announcementInfo = "# / Player / Shots fired",
				fieldsToDisplay = new[] { "name", "shots" }
			});

			listOfStatistics.Add(new StatisticData
			{
				query = "select craft.item, " +
						"sum(count) crafts " +
						"from stats_player_craft_item craft " +
						"join stats_player player on craft.player = player.id " +
						"group by craft.item " +
						"order by SUM(count) DESC " +
						"LIMIT 5",
				announcementText = "Most crafted items:",
				announcementInfo = "# / Item / Crafted amount",
				fieldsToDisplay = new[] { "item", "crafts" }
			});

			var attireNames = string.Join(", ", ItemManager.itemList.Where(i => i.category == ItemCategory.Attire)
				.Select(w => $"{w.displayName.english.QuoteSafe()}").ToArray());

			listOfStatistics.Add(new StatisticData
			{
				query = "select craft.item, " +
						"sum(count) crafts " +
						"from stats_player_craft_item craft " +
						"join stats_player player on craft.player = player.id " +
						"WHERE craft.item IN (@0) ".Replace("@0", attireNames) +
						"group by craft.item " +
						"order by SUM(count) DESC " +
						"LIMIT 5",
				announcementText = "Most crafted attire:",
				announcementInfo = "# / Attire / Crafted amount",
				fieldsToDisplay = new[] { "item", "crafts" }
			});

			var weaponNames = string.Join(", ", ItemManager.itemList.Where(i => i.category == ItemCategory.Weapon)
				.Select(w => $"{w.displayName.english.QuoteSafe()}").ToArray());

			listOfStatistics.Add(new StatisticData
			{
				query = "select craft.item, " +
						"sum(count) crafts " +
						"from stats_player_craft_item craft " +
						"join stats_player player on craft.player = player.id " +
						"WHERE craft.item IN (@0) ".Replace("@0", weaponNames) +
						"group by craft.item " +
						"order by SUM(count) DESC " +
						"LIMIT 5",
				announcementText = "Most crafted weapons:",
				announcementInfo = "# / Weapon / Crafted amount",
				fieldsToDisplay = new[] { "item", "crafts" }
			});

			listOfStatistics.Add(new StatisticData
			{
				query = "select kills.weapon, " +
						"count(1) kills " +
						"from " +
						"stats_player_kill kills " +
						"join stats_player killer on kills.killer = killer.id " +
						"inner join stats_player victim on kills.victim = victim.id " +
						"group by kills.weapon " +
						"order by count(1) desc " +
						"LIMIT 5",
				announcementText = "Most lethal weapons:",
				announcementInfo = "# / Weapon / Kills made",
				fieldsToDisplay = new[] { "weapon", "kills" }
			});

			listOfStatistics.Add(new StatisticData
			{
				query = "select " +
						"gather.resource, " +
						"sum(count) gathered " +
						"from stats_player_gather_resource gather " +
						"join stats_player player on gather.player = player.id " +
						"group by gather.resource " +
						"order by SUM(count) desc " +
						"LIMIT 5",
				announcementText = "Most gathered resources:",
				announcementInfo = "# / Resource / Gathered amount",
				fieldsToDisplay = new[] { "resource", "gathered" }
			});

			listOfStatistics.Add(new StatisticData
			{
				query = "SELECT p.name, " +
						"SUM(count) deploys " +
						"FROM " +
						"stats_player_place_deployable dep " +
						"JOIN stats_player p on p.id = dep.player " +
						"group by dep.player " +
						"order by SUM(count) DESC " +
						"LIMIT 5",
				announcementText = "Most things deployed:",
				announcementInfo = "# / Player / Deployables amount",
				fieldsToDisplay = new[] { "name", "deploys" }
			});

			listOfStatistics.Add(new StatisticData
			{
				query = "SELECT p.name, " +
						"SUM(count) constructs " +
						"FROM " +
						"stats_player_place_building build " +
						"JOIN stats_player p on p.id = build.player " +
						"group by build.player " +
						"order by SUM(count) DESC " +
						"LIMIT 5",
				announcementText = "Most constructions placed:",
				announcementInfo = "# / Player / Constructions amount",
				fieldsToDisplay = new[] { "name", "constructs" }
			});

			listOfStatistics.Add(new StatisticData
			{
				query = "select cause, " +
						"sum(count) count " +
						"from " +
						"stats_player_death " +
						"GROUP BY cause " +
						"order by sum(count) desc " +
						"LIMIT 5",
				announcementText = "Most common death causes:",
				announcementInfo = "# / Cause / Death count",
				fieldsToDisplay = new[] { "cause", "count" }
			});

			listOfStatistics.Add(new StatisticData
			{
				query = "select ANIMAL, " +
						"COUNT(1) count " +
						"from " +
						"stats_player_animal_kill " +
						"GROUP BY ANIMAL " +
						"order by COUNT(1) desc " +
						"LIMIT 5",
				announcementText = "Most animals killed:",
				announcementInfo = "# / Animal / Kills count",
				fieldsToDisplay = new[] { "ANIMAL", "count" }
			});
			listOfStatistics.Add(new StatisticData
			{
				query = "SELECT name, " +
						"CONCAT((online_seconds - online_seconds_lastwipe) DIV (60 * 60 * 24), " +
						"' Days, ', " +
						"LPAD((online_seconds - online_seconds_lastwipe) DIV (60 * 60) % 24, 2, '0'), " +
						"':', LPAD((online_seconds - online_seconds_lastwipe) DIV 60 % 60, 2, '0'), " +
						"':', LPAD((online_seconds - online_seconds_lastwipe) % 60,2, '0')) AS timeSpentThisWipe " +
						"FROM stats_player " +
						"ORDER BY online_seconds - online_seconds_lastwipe DESC " +
						"LIMIT 5",
				announcementText = "Players who spent most time online this wipe:",
				announcementInfo = "# / Player / Time spent this wipe",
				fieldsToDisplay = new[] { "name", "timeSpentThisWipe" }
			});
		}

		void Loaded()
		{
			dbConnection = checkCfg("dbConnection", new Dictionary<string, object>{
				{"Host", "127.0.0.1"},
				{"Port", 3306},
				{"Username", "username"},
				{"Password", "password" },
				{"Database", "rust"}
			});
			SaveConfig();
			StartConnection();

			timer.Once(400 + Random.Range(100, 300), ProcessRandomStatistic);
		}

		void ProcessRandomStatistic()
		{
			Announce(listOfStatistics[getStatisticToDisplay()]);
			timer.Once(300 + Random.Range(100, 300), ProcessRandomStatistic);
		}

		private void StartConnection()
		{
			if (_mySqlConnection == null)
			{
				Puts("Opening connection.");
				_mySqlConnection = _mySql.OpenDb(dbConnection["Host"].ToString(), Convert.ToInt32(dbConnection["Port"]), dbConnection["Database"].ToString(), dbConnection["Username"].ToString(), dbConnection["Password"].ToString(), this);
				Puts("Connection opened.");
			}
		}

		public class StatisticData
		{
			public string query;
			public string announcementText;
			public string announcementInfo;
			public string[] fieldsToDisplay;
		}

		[ChatCommand("last")]
		void cmdChatGetLastStatistic(BasePlayer player, string command, string[] args)
		{
			Announce(currentStatistic > 0 ? listOfStatistics[currentStatistic - 1] : listOfStatistics[currentStatistic], player);
		}

		[ChatCommand("rstat")]
		void cmdChatDoNextStatistic(BasePlayer player, string command, string[] args)
		{
			if (player.IsAdmin)
			{
				Announce(listOfStatistics[getStatisticToDisplay()]);
			}
		}

		public void Announce(StatisticData data, BasePlayer player = null)
		{
			string sqlText = data.query;

			var sql = Sql.Builder.Append(sqlText);
			_mySql.Query(sql, _mySqlConnection, list =>
			{
				if (list.Count == 0)
				{
					Announce(listOfStatistics[getStatisticToDisplay()]);
					return;
				}
				string announcement = $"<color=#32CD32>{data.announcementText}</color>\n" +
									  $"<color=#00FF7F>{data.announcementInfo}</color>";
				int no = 1;
				foreach (var item in list)
				{
					announcement += $"\n#{no++}";
					foreach (var field in data.fieldsToDisplay)
					{
						announcement += $" / {Beautify(item[field])}";
					}
				}

				announcement += "\nType <color=orange>/last</color> to read last posted statistic.";
				if (player == null)
					ss.Server.Broadcast(announcement);
				else
					player.ChatMessage(announcement);
			});
		}

		public static string Beautify(object numberStr)
		{
			int value;
			if (!int.TryParse(numberStr.ToString(), out value))
				return numberStr.ToString();

			if (value >= 100000000)
				return (value / 1000000).ToString("#,0") + " M";
			if (value >= 1000000)
				return (value / 1000000D).ToString("0.#") + " M";
			if (value >= 100000)
				return (value / 1000).ToString("#,0") + " K";
			if (value >= 10000)
				return (value / 1000D).ToString("0.#") + " K";
			return value.ToString("#,0");
		}

	}

}

// --- End of file: SQLStatistics.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HorseSpawns.cs ---
// --- Original Local Path: HorseSpawns.cs ---

﻿using Facepunch;
using Newtonsoft.Json;
using Rust;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
namespace Oxide.Plugins
{
    [Info("Horse Spawns", "OxideBro", "0.1.0")]
    public class HorseSpawns : RustPlugin
    {
        #region Configuration
        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            PrintWarning("No configuration, create a new one. Thanks for download plugins in RustPlugin.ru");
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        private class PluginConfig
        {
            [JsonProperty("Популяция лошадей на один квадратный километр")]
            public int HorsePopulation;

            [JsonProperty("[MAP]: Включить отображение лошадей на стандартной карте")]
            public bool EnabledMapMarker;

            [JsonProperty("[MAP]: Радиус отметки на карте")]
            public float MarketRadius;

            [JsonProperty("[MAP]: Текст на отметке на карты лошадей")]
            public string MarkerDescription;
            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    HorsePopulation = 2,
                    EnabledMapMarker = true,
                    MarketRadius = 0.1f,
                    MarkerDescription = "Horse"
                };
            }
        }
        #endregion

        #region Oxide
        static HorseSpawns ins;

        private void OnServerInitialized()
        {
            ins = this;
            LoadConfig();
            RidableHorse.Population = config.HorsePopulation;
            StartSpawnHorse();
            PrintWarning($"Server size map: {TerrainMeta.Size.x}, Ridable Horses population {RidableHorse.Population}, Loaded {UnityEngine.Object.FindObjectsOfType<RidableHorse>().Count()} Horses");

        }
        void Unload()
        {
            var markers = GameObject.FindObjectsOfType<HorseMarker>();
            foreach (var marker in markers)
            {
                if (marker != null)
                    UnityEngine.Object.Destroy(marker);
            }
            var ents = UnityEngine.Object.FindObjectsOfType<RidableHorse>();
            foreach (var marker in ents)
            {
                if (marker != null)
                    marker.Kill();
            }
        }
        void OnEntityKill(BaseNetworkable entity)
        {
            if (entity == null || entity?.net?.ID == null) return;
            try
            {
                if (entity is RidableHorse) NextTick(() => StartSpawnHorse());
            }
            catch (NullReferenceException) { }
        }
        #endregion

        #region Spawn
        void StartSpawnHorse()
        {
            var ents = UnityEngine.Object.FindObjectsOfType<RidableHorse>();

            if (ents != null)
            {
                var entcount = ents.Count();
                var count = RidableHorse.Population * TerrainMeta.Size.x / 1000 * 2;
                if (count - entcount > 0) PrintWarning($"At the moment we will create {count - entcount} horses");
                for (int i = 0; i < count - entcount; i++)
                {
                    Vector3 vector = GetEventPosition();
                    RidableHorse rHorse = GameManager.server.CreateEntity("assets/rust.ai/nextai/testridablehorse.prefab", vector, new Quaternion(), true) as RidableHorse;
                    rHorse.enableSaving = true;
                    rHorse.Spawn();
                    if (config.EnabledMapMarker) rHorse.gameObject.AddComponent<HorseMarker>();
                }
            }
        }

        class HorseMarker : BaseEntity
        {
            RidableHorse horse;
            MapMarkerGenericRadius mapmarker;
            VendingMachineMapMarker MarkerName;
            SphereCollider sphereCollider;

            void Awake()
            {
                horse = GetComponent<RidableHorse>();
                sphereCollider = gameObject.AddComponent<SphereCollider>();
                sphereCollider.gameObject.layer = (int)Layer.Reserved1;
                sphereCollider.isTrigger = true;
                sphereCollider.radius = 10f;
                SpawnMapMarkers();
            }

            public void SpawnMapMarkers()
            {
                MarkerName = GameManager.server.CreateEntity("assets/prefabs/deployable/vendingmachine/vending_mapmarker.prefab", horse.transform.position, Quaternion.identity, true) as VendingMachineMapMarker;
                MarkerName.markerShopName = ins.config.MarkerDescription;
                MarkerName.Spawn();
                mapmarker = GameManager.server.CreateEntity("assets/prefabs/tools/map/genericradiusmarker.prefab", horse.transform.position, Quaternion.identity, true) as MapMarkerGenericRadius;
                mapmarker.Spawn();
                mapmarker.radius = ins.config.MarketRadius;
                mapmarker.alpha = 1f;
                Color color = new Color(1.00f, 0.50f, 0.00f, 1.00f);
                Color color2 = new Color(0, 0, 0, 0);
                mapmarker.color1 = color;
                mapmarker.color2 = color2;
                mapmarker.SendUpdate();
            }

            private void OnTriggerEnter(Collider col)
            {
                var target = col.GetComponentInParent<BasePlayer>();
                if (target != null)
                    Destroy();
            }

            void OnDestroy()
            {
                if (mapmarker != null) mapmarker.Invoke("KillMessage", 0.1f);
                if (MarkerName != null) MarkerName.Invoke("KillMessage", 0.1f);
            }

            public void Destroy()
            {
                if (mapmarker != null) mapmarker.Invoke("KillMessage", 0.1f);
                if (MarkerName != null) MarkerName.Invoke("KillMessage", 0.1f);
            }
        }

        SpawnFilter filter = new SpawnFilter();
        List<Vector3> monuments = new List<Vector3>();

        static float GetGroundPosition(Vector3 pos)
        {
            float y = TerrainMeta.HeightMap.GetHeight(pos);
            RaycastHit hit;
            if (Physics.Raycast(new Vector3(pos.x, pos.y + 200f, pos.z), Vector3.down, out hit, Mathf.Infinity, LayerMask.GetMask(new[] { "Terrain", "World", "Default", "Construction", "Deployed" })) && !hit.collider.name.Contains("rock_cliff"))
                return Mathf.Max(hit.point.y, y);
            return y;
        }

        public Vector3 RandomDropPosition()
        {
            var vector = Vector3.zero;
            float num = 1000f, x = TerrainMeta.Size.x / 3;

            do
            {
                vector = Vector3Ex.Range(-x, x);
            }
            while (filter.GetFactor(vector) == 0f && (num -= 1f) > 0f);
            float max = TerrainMeta.Size.x / 2;
            float height = TerrainMeta.HeightMap.GetHeight(vector);
            vector.y = height;
            return vector;
        }

        List<int> BlockedLayers = new List<int> { (int)Layer.Water, (int)Layer.Construction, (int)Layer.Trigger, (int)Layer.Prevent_Building, (int)Layer.Deployed, (int)Layer.Tree };
        static int blockedMask = LayerMask.GetMask(new[] { "Player (Server)", "Trigger", "Prevent Building" });

        public Vector3 GetSafeDropPosition(Vector3 position)
        {
            RaycastHit hit;
            position.y += 200f;

            if (Physics.Raycast(position, Vector3.down, out hit))
            {
                if (hit.collider?.gameObject == null)
                    return Vector3.zero;
                string ColName = hit.collider.name;

                if (!BlockedLayers.Contains(hit.collider.gameObject.layer) && ColName != "MeshColliderBatch" && ColName != "iceberg_3" && ColName != "iceberg_2" && !ColName.Contains("rock_cliff"))
                {
                    position.y = Mathf.Max(hit.point.y, TerrainMeta.HeightMap.GetHeight(position));
                    var colliders = Pool.GetList<Collider>();
                    Vis.Colliders(position, 1, colliders, blockedMask, QueryTriggerInteraction.Collide);
                    bool blocked = colliders.Count > 0;
                    Pool.FreeList<Collider>(ref colliders);
                    if (!blocked)
                        return position;
                }
            }
            return Vector3.zero;
        }

        public Vector3 GetEventPosition()
        {
            var eventPos = Vector3.zero;
            int maxRetries = 100;
            monuments = UnityEngine.Object.FindObjectsOfType<MonumentInfo>().Select(monument => monument.transform.position).ToList();
            do
            {
                eventPos = GetSafeDropPosition(RandomDropPosition());

                foreach (var monument in monuments)
                {
                    if (Vector3.Distance(eventPos, monument) < 150f)
                    {
                        eventPos = Vector3.zero;
                        break;
                    }
                }
            } while (eventPos == Vector3.zero && --maxRetries > 0);

            eventPos.y = GetGroundPosition(eventPos);

            if (eventPos.y < 0)
                GetEventPosition();
            return eventPos;
        }
        #endregion
    }
}

// --- End of file: HorseSpawns.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AntiHack.cs ---
// --- Original Local Path: AntiHack.cs ---

using Network;
using Network.Visibility;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Rust;
using System;
using System.Collections.Generic;
using System.Globalization;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("AntiHack", "OxideBro", "1.0.42")]
    public class AntiHack : RustPlugin
    {
        #region References
        [PluginReference]
        private Plugin Discord;
        #endregion

        private static Dictionary<ulong, HashSet<uint>> playersHidenEntities = new Dictionary<ulong, HashSet<uint>>();
        private static int radius = 35;
        private Dictionary<BasePlayer, CurrentLog> currentAdminsLog = new Dictionary<BasePlayer, CurrentLog>();
        private Dictionary<ulong, float> lastSpeedAttackAttackTime = new Dictionary<ulong, float>();
        private Dictionary<ulong, float> lastShootingThroughWallTime = new Dictionary<ulong, float>();
        public List<BasePlayer> Admins = new List<BasePlayer>();
        private Dictionary<ulong, int> speedAttackDetections = new Dictionary<ulong, int>();
        private Dictionary<ulong, int> shootingThroughWallDetections = new Dictionary<ulong, int>();
        private static bool isSaving = false;
        private static float minPlayersWallHackDistanceCheck = 0.0f;
        private static float minObjectsWallHackDistanceCheck = 50.0f;
        private static float maxPlayersWallHackDistanceCheck = 250f;
        private static float maxObjectsWallHackDistanceCheck = 150f;
        private static float tickRate = 0.1f;
        private static int globalMask = LayerMask.GetMask("Construction", "Deployed", "World", "Default");
        private static int cM = LayerMask.GetMask("Construction");
        private static int playerWallHackMask = LayerMask.GetMask("Construction", "World", "Default", "Deployed");
        private static int entityMask = LayerMask.GetMask("Deployed");
        private static int constructionAndDeployed = LayerMask.GetMask("Construction", "Deployed");
        private static Dictionary<ulong, int> playersKicks = new Dictionary<ulong, int>();
        private static Dictionary<ulong, HackHandler> playersHandlers = new Dictionary<ulong, HackHandler>();
        private static Dictionary<int, Dictionary<int, Chunk>> chunks = new Dictionary<int, Dictionary<int, Chunk>>();
        private static HashSet<Chunk> chunksList = new HashSet<Chunk>();
        private List<string> neededEntities = new List<string>()
        {
          "cupboard.tool.deployed",
          "sleepingbag_leather_deployed",
          "bed_deployed"
        };
        public bool IsConnected(BasePlayer player) => BasePlayer.activePlayerList.Contains(player);
        public void Kick(BasePlayer player, string reason = "⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠") => player.Kick(reason);
        public bool IsBanned(ulong id) => ServerUsers.Is(id, ServerUsers.UserGroup.Banned);
        private static AntiHack instance;
        private bool isLoaded;
        private static bool wallHackPlayersEnabled;
        private static bool wallHackObjectsEnabled;
        private static bool enableFlyHackLog;
        private static bool enableFlyHackCar;
        private static bool enableSpeedHackLog;
        private static bool enableTextureHackLog;
        private static bool enableSpeedAttackLog;
        private static bool enableWallHackAttackLog;
        private static bool needKick;
        private static bool needKickEndKill;
        private static bool needBan;
        private bool configChanged;
        private const int intervalBetweenTextureHackMessages = 50;
        private const int maxFalseFlyDetects = 5;
        private const int maxFalseSpeedDetects = 5;
        private static int maxFlyWarnings;
        private static int maxSpeedWarnings;

        private static bool SendDiscordMessages;
        private static StoredData db;

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            Dictionary<string, object> dictionary = Config[menu] as Dictionary<string, object>;
            if (dictionary == null)
            {
                dictionary = new Dictionary<string, object>();
                Config[menu] = (object)dictionary;
                configChanged = true;
            }
            object obj;
            if (!dictionary.TryGetValue(datavalue, out obj))
            {
                obj = defaultValue;
                dictionary[datavalue] = obj;
                configChanged = true;
            }
            return obj;
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        private void DiscordMessages(string Messages, int type, string Reason = "⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠")
        {
            if (SendDiscordMessages)
            {
                if (type == 0)
                    instance.Discord.Call("SendMessage", $"\n**ANTIHACK DETECTED!**\n\n{Messages}");
                else instance.Discord.Call("SendMessage", $"{Reason}!\n\n{Messages}");
            }
        }

        private void LoadVariables()
        {
            maxFlyWarnings = Convert.ToInt32(GetConfig("Основное", "Количество детектов FlyHack для наказания:", 10));
            maxSpeedWarnings = Convert.ToInt32(GetConfig("Основное", "Количество детектов SpeedHack для наказания:", 10));
            needKick = Convert.ToBoolean(GetConfig("Основное", "Наказать киком:", false));
            needKickEndKill = Convert.ToBoolean(GetConfig("Основное", "TextureHack - Наказать киком и убить игрока:", false));
            needBan = Convert.ToBoolean(GetConfig("Основное", "Наказать баном:", false));
            enableFlyHackLog = Convert.ToBoolean(GetConfig("Основное", "Логировать детекты FlyHack:", true));
            enableFlyHackCar = Convert.ToBoolean(GetConfig("Основное", "Не логировать детекты в машине?", true));
            enableSpeedHackLog = Convert.ToBoolean(GetConfig("Основное", "Логировать детекты SpeedHack:", true));
            enableTextureHackLog = Convert.ToBoolean(GetConfig("Основное", "Логировать детекты TextureHack:", false));
            enableSpeedAttackLog = Convert.ToBoolean(GetConfig("Основное", "Логировать детекты на быстрое добывание:", true));
            enableWallHackAttackLog = Convert.ToBoolean(GetConfig("Основное", "Логировать детекты на WallHackAttack:", true));
            wallHackObjectsEnabled = Convert.ToBoolean(GetConfig("Экспериментальное", "Включить AntiESP на объекты (Внимание! Может нагружать сервер!)", false));
            wallHackPlayersEnabled = Convert.ToBoolean(GetConfig("Экспериментальное", "Включить AntiESP на людей (Внимание! Может сильно нагружать сервер!)", false));
            SendDiscordMessages = Convert.ToBoolean(GetConfig("Основное", "Включить отправку детектов и сообщений на канал Discord (Нужен плагин Discord)", false));
            if (!configChanged)
                return;
            SaveConfig();
            configChanged = false;
        }

        public static void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject<StoredData>("AntiHack_Detects", db, false);
        }

        public void ShowDetects(BasePlayer player, string[] args)
        {
            string s = null;
            if (args.Length == 2)
            {
                if (args[1] == "0")
                {
                    player.ChatMessage("Очищаем номер детекта для телепорта...");
                    currentAdminsLog.Remove(player);
                }
                else
                    s = args[1];
            }
            string user = args[0];
            Log log;
            if (user.Contains("765"))
            {
                ulong id;
                ulong.TryParse(args[0], out id);
                log = db.logs.Find(x => (long)x.steamID == (long)id);
            }
            else
                log = db.logs.Find(x => x.name.Contains(user, CompareOptions.IgnoreCase));
            if (log == null)
            {
                player.ChatMessage("Ошибка. В логах нет такого игрока");
            }
            else
            {
                CurrentLog currentLog;
                if (!currentAdminsLog.TryGetValue(player, out currentLog))
                {
                    currentAdminsLog[player] = new CurrentLog()
                    {
                        detect = 1,
                        steamID = log.steamID
                    };
                    player.ChatMessage(string.Format("Игрок {0}\nКоличество детектов: {1}", log.name, log.detectsAmount));
                }
                else if ((long)currentLog.steamID != (long)log.steamID)
                {
                    currentAdminsLog[player] = new CurrentLog()
                    {
                        detect = 1,
                        steamID = log.steamID
                    };
                    player.ChatMessage(string.Format("Игрок {0}\nКоличество детектов: {1}", log.name, log.detectsAmount));
                }
                else if (s == null)
                {
                    if (log.detectsAmount >= currentLog.detect + 1)
                    {
                        ++currentLog.detect;
                    }
                    else
                    {
                        player.ChatMessage(string.Format("Больше детектов у игрока {0} нет", log.name));
                        currentAdminsLog.Remove(player);
                        return;
                    }
                }
                int result = 0;
                int.TryParse(s, out result);
                bool flag = false;
                for (int index = 0; index < log.detects.Count; ++index)
                {
                    Detect detect = log.detects[index];
                    if (result == 0)
                    {
                        if (currentAdminsLog[player].detect == index + 1)
                        {
                            foreach (Coordinates coordinate in detect.coordinates)
                            {
                                Vector3 vector3_1 = coordinate.startPos.ToVector3();
                                Vector3 vector3_2 = coordinate.endPos.ToVector3();
                                player.SendConsoleCommand("ddraw.arrow", 20f, Color.white, vector3_1, vector3_2, 0.2f);
                                if (!flag)
                                {
                                    player.Teleport(vector3_1);
                                    flag = true;
                                    player.ChatMessage(string.Format("Телепорт на детект {0} игрока {1}", (object)currentAdminsLog[player].detect, (object)log.name));
                                }
                            }
                        }
                    }
                    else if (result == index + 1)
                    {
                        foreach (Coordinates coordinate in detect.coordinates)
                        {
                            Vector3 vector3_1 = coordinate.startPos.ToVector3();
                            Vector3 vector3_2 = coordinate.endPos.ToVector3();
                            player.SendConsoleCommand("ddraw.arrow", (object)20f, (object)Color.white, (object)vector3_1, (object)vector3_2, (object)0.2f);
                            if (!flag)
                            {
                                player.Teleport(vector3_1);
                                flag = true;
                                player.ChatMessage(string.Format("Телепорт на детект {0} игрока {1}", (object)result, (object)log.name));
                                currentAdminsLog[player].detect = result;
                            }
                        }
                    }
                }
            }
        }

        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            if (entity == null || !(entity is BasePlayer) || item == null || dispenser == null) return;
            if (entity.ToPlayer() is BasePlayer) { };

        }
        public static void LogHandler(BasePlayer player, Vector3 lastGroundPos, TemporaryCoordinates temp, bool isSpeedHack = false)
        {
            Log log1 = db.logs.Find((Predicate<Log>)(x => (long)x.steamID == (long)player.userID));
            Vector3 position = player.transform.position;
            if (isSpeedHack)
            {
                position.y += 0.7f;
                lastGroundPos.y += 0.7f;
            }
            Coordinates coordinates;
            coordinates.startPos = lastGroundPos.ToString();
            coordinates.endPos = position.ToString();
            Detect detect = new Detect();
            if (log1 == null)
            {
                Log log2 = new Log();
                log2.detectsAmount = 1;
                if (temp.coordinates.Count > 0)
                {
                    detect.coordinates.AddRange((IEnumerable<Coordinates>)temp.coordinates);
                    log2.detects.Add(detect);
                }
                else if (isSpeedHack)
                {
                    detect.coordinates.Add(coordinates);
                    log2.detects.Add(detect);
                }
                log2.name = player.displayName;
                log2.steamID = player.userID;
                db.logs.Add(log2);
            }
            else
            {
                ++log1.detectsAmount;
                if (temp.coordinates.Count > 0)
                {
                    detect.coordinates.AddRange((IEnumerable<Coordinates>)temp.coordinates);
                    log1.detects.Add(detect);
                }
                else if (isSpeedHack)
                {
                    detect.coordinates.Add(coordinates);
                    log1.detects.Add(detect);
                }
                log1.name = player.displayName;
            }
        }

        void ShowLog(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin)
                return;
            if (!CanGetReport(player))
                return;
            if (args.Length == 0)
            {
                SendReply(player, "<size=15><color=orange>AntiHack development from RustPlugin.ru</color></size>\n" +
                    "Используйте:\n" +
                    "<color=orange>/ah on/off</color> - Включить/отключить иммунитет к проверкам античита\n" +
                    "<color=orange>/ah SteamID/NAME</color> - Телепортация на первый детект игрока\n" +
                    "<color=orange>/ah SteamID/NAME 0 </color>- Телепортация на первый детект игрока");
                return;
            }
            if (args[0] == "on" || args[0] == "off")
            {
                switch (args[0])
                {
                    case "on":
                        if (Admins.Contains(player))
                        {
                            SendReply(player, "У Вас уже включен иммунитет к проверкам античита");
                            return;
                        }
                        Admins.Add(player);
                        player.ChatMessage("Вы включючили иммунитет к проверкам античита");
                        break;
                    case "off":
                        if (!Admins.Contains(player))
                        {
                            SendReply(player, "У Вас уже выключен иммунитет к проверкам античита");
                            return;
                        }
                        HackHandler component = player.GetComponent<HackHandler>();
                        component.lastGroundPosition = player.transform.position;
                        component.playerPreviousPosition = player.transform.position;
                        Admins.Remove(player);
                        player.ChatMessage("Вы отключили иммунитет к проверкам античита");
                        break;
                }
            }
            else
                ShowDetects(player, args);
        }

        private static HashSet<BaseEntity> GetEntitiesFromAllChunks()
        {
            HashSet<BaseEntity> baseEntitySet = new HashSet<BaseEntity>();
            foreach (Chunk chunks in chunksList)
            {
                foreach (BaseEntity entity in chunks.entities)
                {
                    if (!(entity == null) && !entity.IsDestroyed)
                        baseEntitySet.Add(entity);
                }
            }
            return baseEntitySet;
        }

        private static HashSet<BaseEntity> GetEntitiesFromChunksNearPointOptimized(Vector3 point)
        {
            Chunk chunkFromPoint = GetChunkFromPoint(point);
            HashSet<BaseEntity> baseEntitySet = new HashSet<BaseEntity>();
            if (chunkFromPoint == null)
                return baseEntitySet;
            foreach (BaseEntity entity in chunkFromPoint.entities)
                baseEntitySet.Add(entity);
            foreach (BaseEntity entity in chunks[chunkFromPoint.x + 1][chunkFromPoint.z + 1].entities)
                baseEntitySet.Add(entity);
            foreach (BaseEntity entity in chunks[chunkFromPoint.x - 1][chunkFromPoint.z - 1].entities)
                baseEntitySet.Add(entity);
            foreach (BaseEntity entity in chunks[chunkFromPoint.x][chunkFromPoint.z + 1].entities)
                baseEntitySet.Add(entity);
            foreach (BaseEntity entity in chunks[chunkFromPoint.x + 1][chunkFromPoint.z].entities)
                baseEntitySet.Add(entity);
            foreach (BaseEntity entity in chunks[chunkFromPoint.x - 1][chunkFromPoint.z].entities)
                baseEntitySet.Add(entity);
            foreach (BaseEntity entity in chunks[chunkFromPoint.x][chunkFromPoint.z - 1].entities)
                baseEntitySet.Add(entity);
            foreach (BaseEntity entity in chunks[chunkFromPoint.x - 1][chunkFromPoint.z + 1].entities)
                baseEntitySet.Add(entity);
            foreach (BaseEntity entity in chunks[chunkFromPoint.x + 1][chunkFromPoint.z - 1].entities)
                baseEntitySet.Add(entity);
            return baseEntitySet;
        }

        private static Chunk GetChunkFromPoint(Vector3 point)
        {
            Dictionary<int, Chunk> dictionary;
            Chunk chunk;
            if (chunks.TryGetValue((int)((double)point.x / (double)radius), out dictionary) && dictionary.TryGetValue((int)((double)point.z / (double)radius), out chunk))
                return chunk;
            return null;
        }

        private void SetPlayer(BasePlayer player)
        {
            if (player.IsAdmin || permission.UserHasPermission(player.UserIDString, "antihack.logs"))
            {
                if (!Admins.Contains(player))
                    Admins.Add(player);
            }
            HackHandler hackHandler = player.gameObject.AddComponent<HackHandler>() ?? player.GetComponent<HackHandler>();
            playersHandlers[player.userID] = hackHandler;
            lastSpeedAttackAttackTime[player.userID] = UnityEngine.Time.realtimeSinceStartup;
            speedAttackDetections[player.userID] = 0;
            shootingThroughWallDetections[player.userID] = 0;
            lastShootingThroughWallTime[player.userID] = UnityEngine.Time.realtimeSinceStartup;
        }

        public static bool CanGetReport(BasePlayer player)
        {
            return Interface.Oxide.GetLibrary<Permission>(null).UserHasPermission(player.userID.ToString(), "antihack.logs") || player.IsAdmin;
        }

        private static void SendReportToOnlineModerators(string report)
        {
            foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
            {
                if (CanGetReport(activePlayer))
                    activePlayer.ChatMessage(string.Format("[AntiHack] {0}", (object)report));
            }
        }

        public static BasePlayer FindPlayer(string nameOrIdOrIp)
        {
            foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
            {
                if (activePlayer.UserIDString == nameOrIdOrIp || activePlayer.displayName.Contains(nameOrIdOrIp, CompareOptions.OrdinalIgnoreCase))
                    return activePlayer;
                Networkable net = activePlayer.net;
                if ((net != null ? net.connection : (Network.Connection)null) != null && activePlayer.net.connection.ipaddress == nameOrIdOrIp)
                    return activePlayer;
            }
            foreach (BasePlayer sleepingPlayer in BasePlayer.sleepingPlayerList)
            {
                if (sleepingPlayer.UserIDString == nameOrIdOrIp || sleepingPlayer.displayName.Contains(nameOrIdOrIp, CompareOptions.OrdinalIgnoreCase))
                    return sleepingPlayer;
            }
            return (BasePlayer)null;
        }

        private void ShootingThroughWallHanlder(BasePlayer attacker, HitInfo info, float timeNow)
        {
            BaseEntity hitEntity = info.HitEntity;
            if (hitEntity == null || (hitEntity as BasePlayer) == null)
                return;
            Vector3 hitPositionWorld = info.HitPositionWorld;
            Vector3 pointStart = info.PointStart;
            if (!Physics.Linecast(pointStart, hitPositionWorld, cM))
            {
                if (shootingThroughWallDetections[attacker.userID] == 0 || timeNow - lastShootingThroughWallTime[attacker.userID] <= 10.0)
                    return;
                shootingThroughWallDetections[attacker.userID] = 0;
            }
            else
            {
                lastShootingThroughWallTime[attacker.userID] = timeNow;
                Dictionary<ulong, int> throughWallDetections = shootingThroughWallDetections;
                ulong userId = attacker.userID;
                long num1 = (long)userId;
                int num2 = throughWallDetections[(ulong)num1];
                long num3 = (long)userId;
                int num4 = num2 + 1;
                throughWallDetections[(ulong)num3] = num4;
                if (shootingThroughWallDetections[attacker.userID] <= 5)
                    return;
                int averagePing = Network.Net.sv.GetAveragePing(attacker.net.connection);
                string str = string.Format("WallHackAttack Detected\n{0} [{1}]\n{2} -> {3}\nПинг: {4} мс.\nПредупреждений: {5}", (object)attacker.displayName, (object)attacker.userID, (object)pointStart, (object)hitPositionWorld, (object)averagePing, (object)shootingThroughWallDetections[attacker.userID]);
                string strMessage = string.Format("WallHackAttack | {0} [{1}] | {2} -> {3} | {4} мс. | Предупреждений: {5}", (object)attacker.displayName, (object)attacker.userID, (object)pointStart, (object)hitPositionWorld, (object)averagePing, (object)shootingThroughWallDetections[attacker.userID]);
                DiscordMessages(str, 0);
                instance.LogToFile("Log", strMessage, instance);
                SendReportToOnlineModerators(str);
                Interface.Oxide.LogError(str);
            }
        }

        private void SpeedAttackHandler(BasePlayer attacker, HitInfo info, BaseMelee melee, float timeNow)
        {
            if (attacker.IsAdmin)
                return;
            if ((double)timeNow - (double)lastSpeedAttackAttackTime[attacker.userID] < (double)melee.repeatDelay - 0.25)
            {
                info.damageTypes = new DamageTypeList();
                info.HitEntity = (BaseEntity)null;
                Dictionary<ulong, int> attackDetections = speedAttackDetections;
                ulong userId = attacker.userID;
                long num1 = (long)userId;
                int num2 = attackDetections[(ulong)num1];
                long num3 = (long)userId;
                int num4 = num2 + 1;
                attackDetections[(ulong)num3] = num4;
                if (speedAttackDetections[attacker.userID] > 5)
                {
                    int averagePing = Network.Net.sv.GetAveragePing(attacker.net.connection);
                    string str = string.Format("SpeedGather Detected\n{0} [{1}]\nПозиция: {2}\nПинг: {3} мс.\nПредупреждений: {4}", (object)attacker.displayName, (object)attacker.userID, (object)attacker.transform.position, (object)averagePing, (object)speedAttackDetections[attacker.userID]);
                    string strMessage = string.Format("SpeedGather | {0} [{1}] | {2} | {3} мс. | Предупреждений: {4}", (object)attacker.displayName, (object)attacker.userID, (object)attacker.transform.position, (object)averagePing, (object)speedAttackDetections[attacker.userID]);
                    DiscordMessages(str, 0);
                    instance.LogToFile("Log", strMessage, instance);
                    SendReportToOnlineModerators(str);
                    Interface.Oxide.LogError(str);
                }
            }
            else
                speedAttackDetections[attacker.userID] = 0;
            lastSpeedAttackAttackTime[attacker.userID] = timeNow;
        }

        object CanNetworkTo(BaseNetworkable entity, BasePlayer target)
        {
            if (!wallHackPlayersEnabled || !isLoaded || (!playersHidenEntities.ContainsKey(target.userID) || !playersHidenEntities[target.userID].Contains(entity.net.ID)))
                return (object)null;
            return (object)false;
        }

        void OnEntitySpawned(BaseEntity ent, GameObject gameObject)
        {
            if (!wallHackObjectsEnabled || (ent as BasePlayer) != null || ent.GetComponent<LootContainer>() != null || ent.GetComponent<StorageContainer>() == null && !neededEntities.Contains(ent.ShortPrefabName))
                return;
            Chunk chunkFromPoint = GetChunkFromPoint(ent.transform.position);
            if (chunkFromPoint == null)
                return;
            chunkFromPoint.entities.Add(ent);
        }

        void OnEntityKill(BaseNetworkable ent)
        {
            if (!wallHackObjectsEnabled || !isLoaded || (ent as BasePlayer) != null || ent.GetComponent<LootContainer>() != null || ent.GetComponent<StorageContainer>() == null && !neededEntities.Contains(ent.ShortPrefabName))
                return;
            Chunk chunkFromPoint = GetChunkFromPoint(ent.transform.position);
            if (chunkFromPoint == null || !chunkFromPoint.entities.Contains(ent as BaseEntity))
                return;
            chunkFromPoint.entities.Remove(ent as BaseEntity);
        }

        private void Init()
        {
            instance = this;

            LoadVariables();
            if (wallHackObjectsEnabled)
            {
                radius = ConVar.Server.worldsize / 100;
                int num = 100;
                for (int index1 = num * -1; index1 < num; ++index1)
                {
                    chunks[index1] = new Dictionary<int, Chunk>();
                    for (int index2 = num * -1; index2 < num; ++index2)
                    {
                        Chunk chunk = new Chunk()
                        {
                            x = index1,
                            z = index2
                        };
                        chunks[index1][index2] = chunk;
                        chunksList.Add(chunk);
                    }
                }
                Puts(string.Format("[Debug WallHackHandler] Chunks: {0} Radius: {1} Map size: {2}", (object)chunks.Count, (object)radius, (object)ConVar.Server.worldsize));
            }
            db = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("AntiHack_Detects");
            Interface.Oxide.GetLibrary<Permission>(null).RegisterPermission("antihack.logs", (Plugin)this);
            Interface.Oxide.GetLibrary<Game.Rust.Libraries.Command>(null).AddChatCommand("ah", (Plugin)this, "ShowLog");
            Interface.Oxide.GetLibrary<Game.Rust.Libraries.Command>(null).AddConsoleCommand("antihack", (Plugin)this, "AntiHackCmd");
        }

        void OnServerInitialized()
        {
            if (wallHackObjectsEnabled)
            {
                int num = 0;
                foreach (BaseNetworkable serverEntity in BaseNetworkable.serverEntities)
                {
                    if (!((serverEntity as BasePlayer) != null) && ((!(serverEntity.GetComponent<StorageContainer>() == null) || neededEntities.Contains(serverEntity.ShortPrefabName)) && !(serverEntity.GetComponent<LootContainer>() != null)))
                    {
                        Chunk chunkFromPoint = GetChunkFromPoint(serverEntity.transform.position);
                        if (chunkFromPoint != null)
                            chunkFromPoint.entities.Add(serverEntity as BaseEntity);
                        ++num;
                    }
                }
                Interface.Oxide.LogInfo(string.Format("[Debug WallHackHandler] Added new {0} entities ({1} all)", (object)num, (object)GetEntitiesFromAllChunks().Count));
            }
            foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
                SetPlayer(activePlayer);
            isLoaded = true;
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            HackHandler component = player.GetComponent<HackHandler>();
            if (component == null)
                return;
            component.Disconnect();
        }

        void OnServerSave()
        {
            isSaving = true;
            NextTick(() => isSaving = false);
        }

        void OnPlayerConnected(BasePlayer player)
        {
            SetPlayer(player);
        }

        void OnServerShutdown()
        {
            SaveData();
        }

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                playersHandlers.Remove(player.userID);
                HackHandler component = player.GetComponent<HackHandler>();
                if (component != null)
                {
                    component.Disconnect();
                }
            }
            SaveData();
            DestroyAll<HackHandler>();
        }

        void DestroyAll<T>()
        {
            UnityEngine.Object[] objects = GameObject.FindObjectsOfType(typeof(T));
            if (objects != null)
                foreach (UnityEngine.Object gameObj in objects)
                    GameObject.Destroy(gameObj);

        }

        void OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            if (isSaving || attacker == null || (attacker.IsAdmin || info.Weapon == null))
                return;
            float realtimeSinceStartup = UnityEngine.Time.realtimeSinceStartup;
            BaseMelee component = info.Weapon.GetComponent<BaseMelee>();
            if (component == null && enableWallHackAttackLog)
            {
                ShootingThroughWallHanlder(attacker, info, realtimeSinceStartup);
            }
            else
            {
                if (!enableSpeedAttackLog)
                    return;
                SpeedAttackHandler(attacker, info, component, realtimeSinceStartup);
            }
        }

        private bool IsPlayerGotImmunity(ulong playerid = 3902464)
        {
            object obj = Interface.CallHook("AntiHackIsPlayerGotImmunity", (object)playerid);
            return obj != null && (bool)obj;
        }

        private class Chunk
        {
            public HashSet<BaseEntity> entities = new HashSet<BaseEntity>();

            public int x { get; set; }

            public int z { get; set; }
        }

        private class Log
        {
            public List<Detect> detects = new List<Detect>();
            public int detectsAmount;
            public ulong steamID;
            public string name;
        }

        public struct Coordinates
        {
            public string startPos;
            public string endPos;
        }

        public class Detect
        {
            public List<Coordinates> coordinates = new List<Coordinates>();
        }

        public class TemporaryCoordinates
        {
            public List<Coordinates> coordinates = new List<Coordinates>();
        }

        private class StoredData
        {
            public List<Log> logs = new List<Log>();
        }

        private class CurrentLog
        {
            public ulong steamID;
            public int detect;
        }

        private class HackHandler : MonoBehaviour
        {
            private int flyWarnings = 0;
            private int textureWarnings = 0;
            private int speedWarnings = 0;
            private float ownTickRate = 0.1f;
            private bool IsFlying = false;
            private int falseFlyDetects = 0;
            private int falseSpeedDetects = 0;
            private int ping = 0;
            private TemporaryCoordinates temp = new TemporaryCoordinates();
            public HashSet<BaseEntity> hidedEntities = new HashSet<BaseEntity>();
            public Dictionary<ulong, HashSet<BaseEntity>> hidedPlayersEntities = new Dictionary<ulong, HashSet<BaseEntity>>();
            public HashSet<BaseEntity> seenObjects = new HashSet<BaseEntity>();
            public Vector3 lastPosition = new Vector3();
            private bool IsHided = false;
            private bool isShowedAll = false;
            public BasePlayer player;
            private float lastTick;
            private float deltaTime;
            private float flyTime;
            private float flyTimeStart;
            public Vector3 lastGroundPosition;
            public Vector3 playerPreviousPosition;
            private Network.Connection connection;

            static Vector3 ENTlastGroundPosition;

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                ownTickRate = UnityEngine.Random.Range(0.09f, 0.11f);
                playersHidenEntities[player.userID] = new HashSet<uint>();
                connection = player.net.connection;
                lastGroundPosition = player.transform.position;
                playerPreviousPosition = player.transform.position;
                if (!wallHackObjectsEnabled)
                    return;
                if (player.IsReceivingSnapshot || player.IsSleeping())
                    CheckSnapshot();
                else
                    HideAll();
            }

            private void Update()
            {
                if ((double)UnityEngine.Time.realtimeSinceStartup - (double)lastTick < (double)ownTickRate)
                    return;
                if (instance.IsPlayerGotImmunity(player.userID))
                {
                    ShowAllEntities();
                    lastPosition = player.GetNetworkPosition();
                    playerPreviousPosition = player.transform.position;
                    lastGroundPosition = player.transform.position;
                }
                else
                {
                    isShowedAll = false;
                    if (player.IsAdmin && instance.Admins.Contains(player))
                    {
                        WallHackHandler();
                        lastPosition = player.GetNetworkPosition();
                        playerPreviousPosition = player.transform.position;
                    }
                    else
                    {
                        CorrectValues();
                        lastPosition = player.GetNetworkPosition();
                        FlyHackHandler();
                        PlayerWallHackHandler();
                        PlayerWallHackHandlerSleepers();
                        SpeedHackHandler();
                        WallHackHandler();
                        if (player.IsSleeping() || player.IsDead())
                        {
                            playerPreviousPosition = player.transform.position;
                            lastGroundPosition = player.transform.position;
                        }
                        else
                        {
                            TextureHackHandler();
                            playerPreviousPosition = player.transform.position;
                        }
                    }
                }
            }

            private void SpeedHackHandler()
            {
                if (player.IsOnGround())
                {
                    if (enableFlyHackCar && player.GetMounted() != null) return;
                    if (player.GetParentEntity() is HotAirBalloon || player.GetParentEntity() is CargoShip) return;
                    RaycastHit hit;
                    if (Physics.Raycast(player.transform.position, Vector3.down, out hit, cM))
                    {
                        if (hit.transform.position != ENTlastGroundPosition) return;
                        ENTlastGroundPosition = hit.transform.position;
                    }

                    Vector3 position = player.transform.position;
                    if ((double)playerPreviousPosition.y - (double)position.y < 0.5)
                    {
                        float num = Vector3Ex.Distance2D(playerPreviousPosition, position);
                        float maxSpeed = (float)(((double)player.GetMaxSpeed() + 1.0) * (double)tickRate * (double)deltaTime * 1.54999995231628);
                        if ((double)num > (double)maxSpeed)
                        {
                            falseSpeedDetects = falseSpeedDetects + 1;
                            if (falseSpeedDetects <= 5)
                                return;
                            falseSpeedDetects = 0;
                            speedWarnings = speedWarnings + 1;
                            if (enableSpeedHackLog)
                            {
                                CreateLogSpeedHack(position, maxSpeed);
                                LogHandler(player, playerPreviousPosition, temp, true);
                            }
                            ReturnBack(playerPreviousPosition);
                            if (speedWarnings >= maxSpeedWarnings)
                                CrimeHandler("SpeedHack");
                            return;
                        }
                    }
                }
                falseSpeedDetects = 0;
            }
            public List<Blacklist> list = new List<Blacklist>();
            public class Blacklist
            {
                public Blacklist(string Player, string SteamId)
                {
                    this.Player =Player;
                    this.SteamId = SteamId;
                }
                public string Player { get; set; }
                public string SteamId { get; set; }


            }
            private void FlyHackHandler()
            {
                if (player.GetParentEntity() is HotAirBalloon || player.GetParentEntity() is CargoShip) return;

                Vector3 position = player.transform.position;
                if (player.IsOnGround() || (double)player.WaterFactor() > 0.0)
                {
                    lastGroundPosition = position;
                    Reset();
                    falseFlyDetects = 0;
                }
                else
                {
                    if (!IsFlying)
                    {
                        flyTimeStart = UnityEngine.Time.realtimeSinceStartup;
                        IsFlying = true;
                    }
                    flyTime = lastTick - flyTimeStart;
                    AddTemp();
                    if ((double)flyTime < 0.600000023841858 && (double)position.y - (double)lastGroundPosition.y < 3.0)
                        return;
                    float num1 = Vector3.Distance(position, lastGroundPosition);
                    float num2 = Vector3Ex.Distance2D(position, lastGroundPosition);
                    if ((double)num1 > 1.20000004768372 * (double)deltaTime && ((double)position.y - (double)lastGroundPosition.y > 1.20000004768372 || (double)num2 > 15.0) && (((double)playerPreviousPosition.y < (double)position.y || (double)num2 > 15.0) && (double)num1 > (double)Vector3.Distance(playerPreviousPosition, lastGroundPosition) && !UnityEngine.Physics.Raycast(position, Vector3.down, 1.2f)))
                    {
                        falseFlyDetects = falseFlyDetects + 1;
                        if (falseFlyDetects <= 5)
                            return;
                        falseFlyDetects = 0;
                        flyWarnings = flyWarnings + 1;
                        if (enableFlyHackLog)
                        {
                            LogHandler(player, lastGroundPosition, temp, false);
                            CreateLogFlyHack(position);
                        }
                        ReturnBack(lastGroundPosition);
                        if (flyWarnings >= maxFlyWarnings)
                            CrimeHandler("FlyHack");
                    }
                    else
                        falseFlyDetects = 0;
                }
            }

            private void TextureHackHandler()
            {
                Vector3 position = player.transform.position;
                foreach (RaycastHit hit in UnityEngine.Physics.RaycastAll(new Ray(position + Vector3.up * 10f, Vector3.down), 50f, globalMask))
                {
                    if (!(hit.collider == null))
                    {
                        if (hit.GetEntity() != null)
                        {
                            BaseEntity entity = hit.GetEntity();
                            if (IsInsideFoundation(entity))
                            {
                                textureWarnings = textureWarnings + 1;
                                if (enableTextureHackLog && textureWarnings % 50 == 0)
                                {
                                    CreateLogTextureHack(position, entity.ShortPrefabName);
                                }

                                ReturnBack(playerPreviousPosition);
                                break;
                            }
                        }
                        if ((!(hit.collider.name != "Mesh") || hit.collider.name.Contains("rock_small") || hit.collider.name.Contains("ores")) && IsInsideCave(hit.collider))
                        {
                            string objectName = hit.collider.name;
                            if (objectName == "Mesh")
                                objectName = "Rock";
                            textureWarnings = textureWarnings + 1;
                            if (enableTextureHackLog && textureWarnings % 20 == 0)
                            {
                                if (objectName.Contains("assets") && objectName.Length > 23)
                                    objectName = objectName.Remove(0, 23);
                                CreateLogTextureHack(position, objectName);
                            }
                            ReturnBack(playerPreviousPosition);
                            break;
                        }
                    }
                }
            }

            private bool IsInsideFoundation(BaseEntity block)
            {
                BuildingBlock buildingBlock = block as BuildingBlock;
                if (buildingBlock != null)
                {
                    if (!buildingBlock.PrefabName.Contains("foundation") || buildingBlock.PrefabName.Contains("foundation.steps") && buildingBlock.grade != BuildingGrade.Enum.TopTier || (buildingBlock.grade == BuildingGrade.Enum.Twigs || buildingBlock.grade == BuildingGrade.Enum.Wood))
                        return false;
                }
                else if (!block.PrefabName.Contains("wall.external"))
                    return false;
                OBB obb = block.WorldSpaceBounds();
                Vector3 center1 = obb.ToBounds().center;
                obb = player.WorldSpaceBounds();
                Vector3 center2 = obb.ToBounds().center;
                center2.y -= 0.7f;
                Vector3 direction = center1 - center2;
                RaycastHit hitInfo;
                return !UnityEngine.Physics.Raycast(new Ray(center2, direction), out hitInfo, direction.magnitude + 1f, cM);
            }

            private bool IsInsideCave(Collider collider)
            {
                Vector3 center1 = collider.bounds.center;
                Vector3 center2 = player.WorldSpaceBounds().ToBounds().center;
                Vector3 direction = center1 - center2;
                Ray ray = new Ray(center2, direction);
                RaycastHit hitInfo;
                return !collider.Raycast(ray, out hitInfo, direction.magnitude + 1f);
            }

            private void CheckSnapshot()
            {
                if (player.IsReceivingSnapshot || player.IsSleeping())
                    Invoke("CheckSnapshot", 0.1f);
                else
                    HideAll();
            }

            public void HideAll()
            {
                if (IsHided)
                    return;
                IsHided = true;
                foreach (BaseEntity entitiesFromAllChunk in GetEntitiesFromAllChunks())
                    Hide(entitiesFromAllChunk);
            }

            public void Hide(BaseEntity entity)
            {
                if (seenObjects.Contains(entity) || hidedEntities.Contains(entity))
                    return;
                if (Network.Net.sv.write.Start())
                {
                    Network.Net.sv.write.PacketID(Network.Message.Type.EntityDestroy);
                    Network.Net.sv.write.EntityID(entity.net.ID);
                    Network.Net.sv.write.UInt8((byte)0);
                    Network.Net.sv.write.Send(new SendInfo(connection));
                }
                hidedEntities.Add(entity);
            }

            private void Show(BaseEntity entity, bool needRemove = true)
            {
                seenObjects.Add(entity);
                if (!hidedEntities.Contains(entity))
                    return;
                if (needRemove)
                    hidedEntities.Remove(entity);
                player.QueueUpdate(BasePlayer.NetworkQueue.Update, (BaseNetworkable)entity);
            }

            private void ShowLines(Vector3 start, Vector3 target, bool isVisible)
            {
                if (!player.IsAdmin)
                    return;
                if (isVisible)
                    player.SendConsoleCommand("ddraw.arrow", (object)0.1f, (object)Color.blue, (object)start, (object)target, (object)0.1);
                else
                    player.SendConsoleCommand("ddraw.arrow", (object)0.1f, (object)Color.red, (object)start, (object)target, (object)0.1);
            }

            private bool TryLineCast(Vector3 start, Vector3 target, float plusTarget = 0.0f, float plusPlayer = 1.5f)
            {
                target.y += plusTarget;
                start.y += plusPlayer;
                return !UnityEngine.Physics.Linecast(start, target, cM);
            }

            private bool IsObjectVisible(Vector3 start, Vector3 target)
            {
                return TryLineCast(start, target, 0.0f, 1.5f) || (double)Vector3.Distance(start, target) <= 25.0 && (TryLineCast(start, target, 0.0f, 0.5f) || TryLineCast(start, target, 0.5f, 0.5f) || TryLineCast(start, target, 0.5f, 1f));
            }

            private void WallHackHandler()
            {
                if (!wallHackObjectsEnabled)
                    return;
                Vector3 position = player.transform.position;
                if ((double)Vector3.Distance(player.transform.position, playerPreviousPosition) < 1.0 / 1000.0)
                    return;
                foreach (BaseEntity entity in GetEntitiesFromChunksNearPointOptimized(position))
                {
                    if (!(entity == null) && !seenObjects.Contains(entity))
                    {
                        entity.WorldSpaceBounds().ToBounds();
                        if (IsObjectVisible(position, entity.WorldSpaceBounds().ToBounds().center))
                            Show(entity, true);
                    }
                }
            }

            private void PlayerWallHackHandlerSleepers()
            {
                if (!wallHackPlayersEnabled || (double)Vector3.Distance(player.transform.position, playerPreviousPosition) < 1.0 / 1000.0)
                    return;
                foreach (BasePlayer sleepingPlayer in BasePlayer.sleepingPlayerList)
                {
                    if (!(sleepingPlayer == player) && ((double)player.Distance((BaseEntity)sleepingPlayer) >= (double)minPlayersWallHackDistanceCheck && (double)player.Distance((BaseEntity)sleepingPlayer) <= (double)maxPlayersWallHackDistanceCheck && !seenObjects.Contains((BaseEntity)sleepingPlayer)))
                    {
                        if (!IsVisible((BaseEntity)sleepingPlayer, true))
                            HidePlayer(sleepingPlayer, true);
                        else
                            ShowPlayer(sleepingPlayer, true, true);
                    }
                }
            }

            private void PlayerWallHackHandler()
            {
                if (!wallHackPlayersEnabled)
                    return;
                foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
                {
                    if (!(activePlayer == player) && ((double)player.Distance((BaseEntity)activePlayer) >= (double)minPlayersWallHackDistanceCheck && (double)player.Distance((BaseEntity)activePlayer) <= (double)maxPlayersWallHackDistanceCheck && !activePlayer.net.connection.ipaddress.StartsWith("127.0")) && ((double)Vector3.Distance(playersHandlers[activePlayer.userID].lastPosition, activePlayer.GetNetworkPosition()) < 1.0 / 1000.0 || (double)player.Distance((BaseEntity)activePlayer) > 50.0 || activePlayer.IsDucked()))
                    {
                        if (!IsVisible((BaseEntity)activePlayer, false))
                            HidePlayer(activePlayer, false);
                        else
                            ShowPlayer(activePlayer, true, false);
                    }
                }
            }

            private bool DoLine(Vector3 start, Vector3 target, float plusTarget = 0.0f, float plusPlayer = 1.5f)
            {
                target.y += plusTarget;
                start.y += plusPlayer;
                return !UnityEngine.Physics.Linecast(start, target, cM);
            }

            private bool IsBehindStairs(Vector3 start, Vector3 target)
            {
                RaycastHit hitInfo;
                if (UnityEngine.Physics.Linecast(start, target, out hitInfo, cM))
                {
                    BaseEntity entity1 = hitInfo.GetEntity();
                    if (entity1 != null && ((entity1.ShortPrefabName == "block.stair.lshape" || entity1.ShortPrefabName == "block.stair.ushape") && UnityEngine.Physics.Linecast(target, start, out hitInfo, cM)))
                    {
                        BaseEntity entity2 = hitInfo.GetEntity();
                        if (entity2 != null && (entity2.ShortPrefabName == "block.stair.lshape" || entity2.ShortPrefabName == "block.stair.ushape"))
                            return true;
                    }
                }
                return false;
            }

            private bool IsVisible(BaseEntity target, bool isSleeper = false)
            {
                Vector3 position1 = player.transform.position;
                Vector3 position2 = target.transform.position;
                if (isSleeper)
                    return DoLine(position1, position2, 0.0f, 1.5f) || IsBehindStairs(new Vector3(position1.x, position1.y + 1.2f, position1.z), new Vector3(position2.x, position2.y + 1.2f, position2.z));
                if ((target as BasePlayer).IsDucked())
                    position2.y -= 0.5f;
                float num = player.Distance(target);
                if (DoLine(position1, position2, 1.5f, 1.5f) || IsBehindStairs(new Vector3(position1.x, position1.y + 1.2f, position1.z), new Vector3(position2.x, position2.y + 1.2f, position2.z)))
                    return true;
                if ((double)num > 120.0)
                    return false;
                if (DoLine(position1, position2, 0.0f, 1.5f) || DoLine(position1, position2, 1.2f, 1.5f) || (DoLine(position1, position2, 0.9f, 1.5f) || DoLine(position1, position2, 0.5f, 1.5f)) || (DoLine(position1, position2, 1.9f, 1.5f) || DoLine(position1, position2, 1.5f, 0.0f)))
                    return true;
                if ((double)num > 75.0)
                    return false;
                bool flag1 = !UnityEngine.Physics.Linecast(position1, Quaternion.Euler(player.GetNetworkRotation().eulerAngles) * Vector3.left + position1, cM);
                bool flag2 = !UnityEngine.Physics.Linecast(position1, Quaternion.Euler(player.GetNetworkRotation().eulerAngles) * Vector3.right + position1, cM);
                return flag1 && DoLine(Quaternion.Euler(player.GetNetworkRotation().eulerAngles) * Vector3.left + position1, position2, 1.1f, 1.5f) || flag2 && DoLine(Quaternion.Euler(player.GetNetworkRotation().eulerAngles) * Vector3.right + position1, position2, 1.1f, 1.5f) || (flag1 && DoLine(Quaternion.Euler(player.GetNetworkRotation().eulerAngles) * Vector3.left + position1, position2, 1.1f, 1.1f) || flag2 && DoLine(Quaternion.Euler(player.GetNetworkRotation().eulerAngles) * Vector3.right + position1, position2, 1.1f, 1.1f));
            }

            private void ShowPlayer(BasePlayer target, bool needRemove = true, bool isSleeper = false)
            {
                if (isSleeper)
                    seenObjects.Add((BaseEntity)target);
                if (!hidedPlayersEntities.ContainsKey(target.userID))
                    return;
                player.QueueUpdate(BasePlayer.NetworkQueue.Update, (BaseNetworkable)target);
                player.QueueUpdate(BasePlayer.NetworkQueue.Update, target != null ? (BaseNetworkable)target.GetHeldEntity() : (BaseNetworkable)null);
                playersHidenEntities[player.userID].Remove(target.net.ID);
                foreach (BaseEntity baseEntity in hidedPlayersEntities[target.userID])
                {
                    if (!(baseEntity == null) && !baseEntity.IsDestroyed)
                    {
                        player.QueueUpdate(BasePlayer.NetworkQueue.Update, (BaseNetworkable)baseEntity);
                        playersHidenEntities[player.userID].Remove(baseEntity.net.ID);
                    }
                }
                if (needRemove)
                    hidedPlayersEntities.Remove(target.userID);
            }

            private void HidePlayer(BasePlayer target, bool isSleeper = false)
            {
                if (isSleeper)
                {
                    if (seenObjects.Contains((BaseEntity)target))
                        return;
                }
                else if (seenObjects.Contains((BaseEntity)target))
                    seenObjects.Remove((BaseEntity)target);
                if (hidedPlayersEntities.ContainsKey(target.userID))
                    return;
                hidedPlayersEntities[target.userID] = new HashSet<BaseEntity>();
                if (Network.Net.sv.write.Start())
                {
                    Network.Net.sv.write.PacketID(Network.Message.Type.EntityDestroy);
                    Network.Net.sv.write.EntityID(target.net.ID);
                    Network.Net.sv.write.UInt8((byte)0);
                    Network.Net.sv.write.Send(new SendInfo(connection));
                }
                Item activeItem = target.GetActiveItem();
                if ((activeItem != null ? activeItem.GetHeldEntity() : null) != null && Network.Net.sv.write.Start())
                {
                    Network.Net.sv.write.PacketID(Network.Message.Type.EntityDestroy);
                    Network.Net.sv.write.EntityID(activeItem.GetHeldEntity().net.ID);
                    Network.Net.sv.write.UInt8((byte)0);
                    Network.Net.sv.write.Send(new SendInfo(connection));
                    hidedPlayersEntities[target.userID].Add(activeItem.GetHeldEntity());
                    playersHidenEntities[player.userID].Add(activeItem.GetHeldEntity().net.ID);
                }
                HidePlayersHostile(target);
                hidedPlayersEntities[target.userID].Add((BaseEntity)target);
                playersHidenEntities[player.userID].Add(target.net.ID);
            }

            private void HidePlayersHostile(BasePlayer target)
            {
                foreach (Item obj in target.inventory.containerBelt.itemList)
                {
                    if (target.IsHostileItem(obj))
                    {
                        if (!((obj != null ? obj.GetHeldEntity() : null) == null))
                        {
                            if (Network.Net.sv.write.Start())
                            {
                                Network.Net.sv.write.PacketID(Network.Message.Type.EntityDestroy);
                                Network.Net.sv.write.EntityID(obj.GetHeldEntity().net.ID);
                                Network.Net.sv.write.UInt8((byte)0);
                                Network.Net.sv.write.Send(new SendInfo(connection));
                                hidedPlayersEntities[target.userID].Add(obj.GetHeldEntity());
                                playersHidenEntities[player.userID].Add(obj.GetHeldEntity().net.ID);
                            }
                        }
                        else
                            break;
                    }
                }
                foreach (Item obj in target.inventory.containerMain.itemList)
                {
                    if (target.IsHostileItem(obj))
                    {
                        if ((obj != null ? obj.GetHeldEntity() : null) == null)
                            break;
                        if (Network.Net.sv.write.Start())
                        {
                            Network.Net.sv.write.PacketID(Network.Message.Type.EntityDestroy);
                            Network.Net.sv.write.EntityID(obj.GetHeldEntity().net.ID);
                            Network.Net.sv.write.UInt8((byte)0);
                            Network.Net.sv.write.Send(new SendInfo(connection));
                            hidedPlayersEntities[target.userID].Add(obj.GetHeldEntity());
                            playersHidenEntities[player.userID].Add(obj.GetHeldEntity().net.ID);
                        }
                    }
                }
            }

            private void ShowAllEntities()
            {
                if (isShowedAll)
                    return;
                isShowedAll = true;
                playersHidenEntities[player.userID] = new HashSet<uint>();
                HashSet<BaseEntity> hidedEntities = this.hidedEntities;
                foreach (KeyValuePair<ulong, HashSet<BaseEntity>> hidedPlayersEntity in hidedPlayersEntities)
                    hidedEntities.UnionWith((IEnumerable<BaseEntity>)hidedPlayersEntity.Value);
                foreach (BaseEntity baseEntity in hidedEntities)
                {
                    if (!(baseEntity == null) && !baseEntity.IsDestroyed)
                        player.QueueUpdate(BasePlayer.NetworkQueue.Update, (BaseNetworkable)baseEntity);
                }
            }

            private void CorrectValues()
            {
                ping = Network.Net.sv.GetAveragePing(player.net.connection);
                if (ping == 0)
                    ping = 1;
                int frameRate = Performance.current.frameRate;
                float num = 1f;
                if (frameRate < 100)
                    num = 4f;
                if (frameRate < 50)
                    num = 6f;
                deltaTime = (float)(1.0 + (double)ping * 0.00400000018998981 + (((double)UnityEngine.Time.realtimeSinceStartup - (double)lastTick) * (double)num - (double)tickRate));
                lastTick = UnityEngine.Time.realtimeSinceStartup;
            }

            private void ReturnBack(Vector3 pos)
            {
                player.MovePosition(pos);
                Networkable net1 = player.net;
                if ((net1 != null ? net1.connection : (Network.Connection)null) != null)
                    player.ClientRPCPlayer(null, player, "ForcePositionTo", pos);
                Networkable net2 = player.net;
                if ((net2 != null ? net2.connection : (Network.Connection)null) == null)
                    return;
                try
                {
                    player.ClearEntityQueue((Group)null);
                }
                catch
                {
                }
            }
            private void CreateLogFlyHack(Vector3 playerPosition)
            {
                string str = string.Format("FlyHack detected\n{0} [{1}]\nНачальная позиция: {2}\nКонечная позиция: {3}\nВремя в полете: {4} сек.\nДистанция: {5} м.\nПинг: {6} мс.\nПредупреждений: {7}", (object)player.displayName, (object)player.userID, (object)lastGroundPosition, (object)playerPosition, (object)string.Format("{0:0.##}", (object)flyTime), (object)string.Format("{0:0.##}", (object)Vector3.Distance(playerPosition, lastGroundPosition)), (object)ping, (object)flyWarnings);
                string strMessage = string.Format("FlyHack | {0} [{1}] | {2} -> {3} | Время: {4} сек. | Дистанция: {5} м. | {6} мс. | Предупреждений: {7}", (object)player.displayName, (object)player.userID, (object)lastGroundPosition, (object)playerPosition, (object)string.Format("{0:0.##}", (object)flyTime), (object)string.Format("{0:0.##}", (object)Vector3.Distance(playerPosition, lastGroundPosition)), (object)ping, (object)flyWarnings);
                Interface.Oxide.LogError(str);
                instance.DiscordMessages(str, 0);
                instance.LogToFile("Log", strMessage, instance);
                SendReportToOnlineModerators(str);
                var reply = 3811;
                if (reply == 0) { }
            }

            private void CreateLogSpeedHack(Vector3 playerPosition, float maxSpeed)
            {
                string str = string.Format("SpeedHack detected\n{0} [{1}]\nНачальная позиция: {2}\nКонечная позиция: {3}\nСкорость: {4} м/c (Максимально допустимая: {5} м/c).\nПинг: {6} мс.\nПредупреждений: {7}", (object)player.displayName, (object)player.userID, (object)playerPreviousPosition, (object)playerPosition, (object)string.Format("{0:0.##}", (object)(float)((double)Vector3.Distance(playerPosition, playerPreviousPosition) * 5.0)), (object)string.Format("{0:0.##}", (object)(float)((double)maxSpeed * 5.0)), (object)ping, (object)speedWarnings);
                string strMessage = string.Format("SpeedHack | {0} [{1}] | {2} -> {3} | Скорость: {4} м/c (Макс: {5} м/c).| {6} мс. | Предупреждений: {7}", (object)player.displayName, (object)player.userID, (object)playerPreviousPosition, (object)playerPosition, (object)string.Format("{0:0.##}", (object)(float)((double)Vector3.Distance(playerPosition, playerPreviousPosition) * 5.0)), (object)string.Format("{0:0.##}", (object)(float)((double)maxSpeed * 5.0)), (object)ping, (object)speedWarnings);
                Interface.Oxide.LogError(str);
                instance.DiscordMessages(str, 0);
                instance.LogToFile("Log", strMessage, instance);
                SendReportToOnlineModerators(str);
            }

            private void CreateLogTextureHack(Vector3 playerPosition, string objectName)
            {
                string str = string.Format("TextureHack detected\n{0} [{1}]\nПозиция: {2}\nОбъект: {3}\nПинг: {4} мс.\nПопыток: {5}", (object)player.displayName, (object)player.userID, (object)playerPosition, (object)objectName, (object)ping, (object)textureWarnings);
                string strMessage = string.Format("TextureHack | {0} [{1}] | {2} | Объект: {3} | {4} мс. | Попыток: {5}", (object)player.displayName, (object)player.userID, (object)playerPosition, (object)objectName, (object)ping, (object)textureWarnings);
                string reason = string.Format("AntiHack: TextureHack");
                Interface.Oxide.LogError(str);
                instance.DiscordMessages(str, 0);
                instance.LogToFile("Log", strMessage, instance);
                if (needKickEndKill)
                {
                    instance.Kick(player, $"{reason}");
                    player.KillMessage();
                }
                SendReportToOnlineModerators(str);
            }

            private void AddTemp()
            {
                Coordinates coordinates;
                coordinates.startPos = playerPreviousPosition.ToString();
                coordinates.endPos = player.transform.position.ToString();
                temp.coordinates.Add(coordinates);
            }

            private void Reset()
            {
                temp.coordinates.Clear();
                IsFlying = false;
            }

            private void CrimeHandler(string reason)
            {
                if (needBan)
                {
                    ConsoleSystem.Run(ConsoleSystem.Option.Unrestricted, string.Format("ban {0} {1}", (object)player.userID, (object)reason));
                    var str = $"Игрок: {player.userID} забанен! Причина: {reason}";
                    instance.DiscordMessages(str, 1, "BAN");
                }
                if (needKick)
                {
                    ConsoleSystem.Run(ConsoleSystem.Option.Unrestricted, string.Format("kick {0} {1}", (object)player.userID, (object)reason));
                    var str = $"Игрок: {player.userID} кикнут! Причина: {reason}";
                    instance.DiscordMessages(str, 1, "KICK");
                }
            }

            public void Disconnect()
            {
                if (playersHandlers.ContainsKey(player.userID))
                    playersHandlers.Remove(player.userID);
                Destroy(this);
            }
            public void ShowAllPlayers()
            {
                foreach (HashSet<BaseEntity> baseEntitySet in hidedPlayersEntities.Values)
                {
                    foreach (BaseNetworkable ent in baseEntitySet)
                        player.QueueUpdate(BasePlayer.NetworkQueue.Update, ent);
                }
            }

            public void Destroy()
            {
                foreach (BaseEntity hidedEntity in hidedEntities)
                {
                    if ((hidedEntity as BasePlayer) != null)
                        ShowPlayer(hidedEntity as BasePlayer, false, false);
                    else
                        Show(hidedEntity, false);
                }
                playersHandlers.Remove(player.userID);
                Destroy(this);
            }
        }
    }
}
                             

// --- End of file: AntiHack.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Flamethrower.cs ---
// --- Original Local Path: Flamethrower.cs ---

using Oxide.Core;
using System;
using System.Linq;
using System.Text;
using System.Collections.Generic;
using UnityEngine;
using System.Reflection;

namespace Oxide.Plugins
{
    [Info("Flamethrower", "Colon Blow", "1.2.0", ResourceId = 1498)]
    class Flamethrower : RustPlugin
    {
        private float damageplayer => Config.Get<float>("BlastDamagetoPlayer");
        private float damagebuilding => Config.Get<float>("BlastDamagetoBuilding");
        private float damageNPC => Config.Get<float>("BlastDamagetoNPC");
        private float damageradius => Config.Get<float>("BlastDamageRadius");
	private bool prot => Config.Get<bool>("BlastDamageEffectedByProtectionValue");
	private float ReloadTime => Config.Get<float>("FlamethrowerReloadTime");
	private float gfminduration => Config.Get<float>("GroundFlameMinimumDuration");
	private float gfmaxduration => Config.Get<float>("GroundFlameMaximumDuration");
	private float gfspreadtime => Config.Get<float>("GroundFlameTimetoSpread");
	private float gfdps => Config.Get<float>("GroundFlameDamagePerSecond");
	private float gfdamageradius => Config.Get<float>("GroundFlameDamageRadius");
	private int fuel => Config.Get<int>("AmountRequired-LowGradeFuel");
	private int oil => Config.Get<int>("AmountRequired-CrudeOil");
	private bool weaponcanfail => Config.Get<bool>("EnableChanceOfWeaponFailure");
	private float flametimer;
	private float flamestart;

	private bool addtoflamestart = true;

        private readonly Dictionary<ulong, PlayerData> _flamethrower = new Dictionary<ulong, PlayerData>();

	string entprefab = "assets/bundled/prefabs/fireball.prefab";
	string fxprefab = "assets/bundled/prefabs/fx/impacts/additive/fire.prefab";
	string prefabweaponfailure = "assets/prefabs/npc/patrol helicopter/effects/heli_explosion.prefab";
			
        class PlayerData
        {
        public BasePlayer player;
        }

        void OnServerInitialized()
        {

	flametimer = 0.01f;
	flamestart = 2.5f;
        }

        protected override void LoadDefaultConfig()
        {
		PrintWarning("Creating a new configuration file.");
           	Config.Clear();
        	Config["BlastDamagetoPlayer"] = 10.0f;
        	Config["BlastDamagetoBuilding"] = 10.0f;
        	Config["BlastDamagetoNPC"] = 10.0f;
		Config["BlastDamageRadius"] = 1.0f;
		Config["BlastDamageEffectedByProtectionValue"] = true;
		Config["FlamethrowerReloadTime"] = 4.0f;
		Config["GroundFlameMinimumDuration"] = 10.0f;
		Config["GroundFlameMaximumDuration"] = 10.0f;
		Config["GroundFlameDamagePerSecond"] = 2.0f;
		Config["GroundFlameTimetoSpread"] = 8.0f;
		Config["GroundFlameDamageRadius"] = 1.0f;
		Config["AmountRequired-LowGradeFuel"] = 5;
		Config["AmountRequired-CrudeOil"] = 5;
		Config["EnableChanceOfWeaponFailure"] = true;
        	SaveConfig();
        }

	void Loaded()
	{
	permission.RegisterPermission("flamethrower.allowed", this);
	}

        void LoadPermissions()
        {
        if (!permission.PermissionExists("flamethrower.allowed")) permission.RegisterPermission("flamethrower.allowed", this);
        }

        bool IsAllowed(BasePlayer player, string perm)
        {
        if (permission.UserHasPermission(player.userID.ToString(), perm)) return true;
        return false;
        }

        void OnPlayerInput(BasePlayer player, InputState input)
        {
		Item activeItem = player.GetActiveItem();
            	if (activeItem != null && activeItem.info.shortname == "smg.thompson" && input.WasJustPressed(BUTTON.USE))
            	{
			if (_flamethrower.ContainsKey(player.userID))
				{
				SendReply(player, "Flamethrower Reloading...");
				return;
				}

			if (!IsAllowed(player, "flamethrower.allowed")) return;
			if (IsAllowed(player, "flamethrower.allowed"))
			{
                   		int oil_amount = player.inventory.GetAmount(1983936587);
                    		if (oil_amount < oil)
                    			{
                        		SendReply(player, "You need more CRUDE OIL use Flamethrower");
                    			}
				
                    		int fuel_amount = player.inventory.GetAmount(28178745);
                    		if (fuel_amount < fuel)
                    			{
                        		SendReply(player, "Need more LOW GRADE FUEL to use Flamethrower");
                        		return;
                    			}

				player.inventory.Take(null, 28178745, fuel);
				player.inventory.Take(null, 1983936587, oil);

				flamethrowerFX(player);
				_flamethrower.Add(player.userID, new PlayerData{player = player});
				timer.Once(ReloadTime, () => _flamethrower.Remove(player.userID));
			}
	    	}
	}

	void flameFX(BasePlayer player)
	{

	        addtoflamestart = true;

		Effect.server.Run(fxprefab, player.eyes.position + player.eyes.BodyForward()*flamestart);
		applyBlastDamage(player);

		BaseEntity entity1 = GameManager.server.CreateEntity(entprefab, player.eyes.position + player.eyes.BodyForward()*flamestart);
		FireBall fball = entity1.GetComponent<FireBall>();
		fball.damagePerSecond = gfdps;
		fball.radius = gfdamageradius;
		fball.lifeTimeMin = gfminduration;
		fball.lifeTimeMax = gfmaxduration;
		fball.generation = gfspreadtime;

		entity1?.Spawn(true);

            	var raycastHits = Physics.RaycastAll(player.transform.position + Vector3.up, player.eyes.BodyForward(), flamestart).GetEnumerator();
            	var nearestDistance = flamestart;
            	Vector3? nearestPoint = null;
            	while (raycastHits.MoveNext())
            	{
                	if (raycastHits.Current == null) continue;
                	var raycastHit = (RaycastHit)raycastHits.Current;
                	if (raycastHit.distance < nearestDistance)
                	{
				nearestDistance = raycastHit.distance;
                    		nearestPoint = raycastHit.point;
		    		addtoflamestart = false;
                	}
		        if (raycastHit.distance > nearestDistance)
                	{
				nearestDistance = raycastHit.distance;
                    		nearestPoint = raycastHit.point;
		    		addtoflamestart = true;
                	}
			if (raycastHit.distance < 1.0f)
                	{
				nearestDistance = raycastHit.distance;
                    		nearestPoint = raycastHit.point;
		    		flamestart = nearestDistance;
                	}
            	}
		if(addtoflamestart)
		{
		flamestart = flamestart+0.30f;
		}
	}

	void flamethrowerFX(BasePlayer player)
	{
	chancetoFail(player);
	flameFXrepeater(player);
	}

	void flameFXrepeater(BasePlayer player)
	{
	flamestart = 2.5f;
	timer.Repeat(flametimer, 25,() => flameFX(player));
	}

	void applyBlastDamage(BasePlayer player)
	{
	playerBlastDamage(player);
	buildingBlastDamage(player);
	npcBlastDamage(player);
	}

	void playerBlastDamage(BasePlayer player)
	{
	
        List<BasePlayer> playerlist = new List<BasePlayer>();
        Vis.Entities<BasePlayer>(player.eyes.position + player.eyes.BodyForward()*flamestart, damageradius, playerlist);

        	foreach (BasePlayer p in playerlist)
                {
		p.Hurt(damageplayer, global::Rust.DamageType.Heat, player, prot);
                }
	}

	void buildingBlastDamage(BasePlayer player)
	{
	
        List<BuildingBlock> blocklist = new List<BuildingBlock>();
        Vis.Entities<BuildingBlock>(player.eyes.position + player.eyes.BodyForward()*flamestart, damageradius, blocklist);

        	foreach (BuildingBlock b in blocklist)
                {
		b.Hurt(damagebuilding, global::Rust.DamageType.Heat, player, prot);
                }
	}

	void npcBlastDamage(BasePlayer player)
	{
	
        List<BaseNPC> NPClist = new List<BaseNPC>();
        Vis.Entities<BaseNPC>(player.eyes.position + player.eyes.BodyForward()*flamestart, damageradius, NPClist);

        	foreach (BaseNPC n in NPClist)
                {
		n.Hurt(damageNPC, global::Rust.DamageType.Heat, player, prot);
                }
	}

	void chancetoFail(BasePlayer player)
	{
		if (weaponcanfail)
		{
			global::Rust.DamageType WeaponFailure = global::Rust.DamageType.Explosion;
			var roll = UnityEngine.Random.Range(0, 666);
			var badnumber = UnityEngine.Random.Range(0, 666);

			if (roll == badnumber)
			{
		    		List<BaseCombatEntity> entities666 = new List<BaseCombatEntity>();
                    		Vis.Entities<BaseCombatEntity>(player.transform.position, 5, entities666);

				SendReply(player, "Your Weapon Exploded in your face...");
			 	Effect.server.Run(prefabweaponfailure, player.transform.position);

                    		foreach (BaseCombatEntity w in entities666)
                   		{
					w.Hurt(500, global::Rust.DamageType.Explosion, null, false);
                    		}
			}
		}
	}
    }
}


// --- End of file: Flamethrower.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NoDecay.cs ---
// --- Original Local Path: NoDecay.cs ---

using System;
using System.Collections.Generic;
using System.Text;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("NoDecay", "Deicide666ra/Piarb", "1.0.13", ResourceId = 1160)]
    [Description("Scales or disables decay of items")]

    class NoDecay : RustPlugin
    {
        private float c_twigMultiplier;
        private float c_woodMultiplier;
        private float c_stoneMultiplier;
        private float c_sheetMultiplier;
        private float c_armoredMultiplier;
		
        private float c_campfireMultiplier;
        private float c_highWoodWallMultiplier;
        private float c_highStoneWallMultiplier;
		private float c_barricadeMultiplier;
		private float c_trapMultiplier;
		private float c_deployablesMultiplier;
		private float c_boxMultiplier;
		private float c_furnaceMultiplier;
		
		private bool c_outputToRcon;

        private bool g_configChanged;
		private string entity_name;

        void Loaded() => LoadConfigValues();
        protected override void LoadDefaultConfig() => Puts("New configuration file created.");

        void LoadConfigValues()
        {
            c_twigMultiplier = Convert.ToSingle(GetConfigValue("Mutipliers", "twigMultiplier", 1.0));
            c_woodMultiplier = Convert.ToSingle(GetConfigValue("Mutipliers", "woodMultiplier", 0.0));
            c_stoneMultiplier = Convert.ToSingle(GetConfigValue("Mutipliers", "stoneMultiplier", 0.0));
            c_sheetMultiplier = Convert.ToSingle(GetConfigValue("Mutipliers", "sheetMultiplier", 0.0));
            c_armoredMultiplier = Convert.ToSingle(GetConfigValue("Mutipliers", "armoredMultiplier", 0.0));
			
			c_deployablesMultiplier = Convert.ToSingle(GetConfigValue("Mutipliers", "deployablesMultiplier", 0.0));
			c_boxMultiplier = Convert.ToSingle(GetConfigValue("Mutipliers", "boxMultiplier", 0.0));
			c_furnaceMultiplier = Convert.ToSingle(GetConfigValue("Mutipliers", "furnaceMultiplier", 0.0));
            c_campfireMultiplier = Convert.ToSingle(GetConfigValue("Mutipliers", "campfireMultiplier", 0.0));
			c_barricadeMultiplier = Convert.ToSingle(GetConfigValue("Mutipliers", "barricadesMultiplier", 0.0));
			c_trapMultiplier = Convert.ToSingle(GetConfigValue("Mutipliers", "trapMultiplier", 0.0));
            c_highWoodWallMultiplier = Convert.ToSingle(GetConfigValue("Mutipliers", "highWoodWallMultiplier", 0.0));
            c_highStoneWallMultiplier = Convert.ToSingle(GetConfigValue("Mutipliers", "highStoneWallMultiplier", 0.0));
			
            c_outputToRcon = Convert.ToBoolean(GetConfigValue("Debug", "outputToRcon", false));

            if (g_configChanged)
            {
                Puts("Configuration file updated.");
                SaveConfig();
            }
        }

        object GetConfigValue(string category, string setting, object defaultValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[category] = data;
                g_configChanged = true;
            }

            if (data.TryGetValue(setting, out value)) return value;
            value = defaultValue;
            data[setting] = value;
            g_configChanged = true;
            return value;
        }

        [HookMethod("SendHelpText")]
        private void SendHelpText(BasePlayer player)
        {
            var sb = new StringBuilder();
            sb.Append("<color=yellow>NoDecay 1.0.3</color> Â· Controls decay\n");
            sb.Append("  Â· ").AppendLine($"twig={c_twigMultiplier} - campfire={c_campfireMultiplier}");
            sb.Append("  Â· ").Append($"wood ={ c_woodMultiplier} - stone ={ c_stoneMultiplier} - sheet ={ c_sheetMultiplier} - armored ={ c_armoredMultiplier}");
            player.ChatMessage(sb.ToString());
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            var tick = DateTime.Now;
			
			entity_name = entity.LookupPrefab().name;
            try
            {
                if (!hitInfo.damageTypes.Has(Rust.DamageType.Decay)) return;

                var block = entity as BuildingBlock;
                if (entity.LookupPrefab().name == "campfire")
                    ProcessCampfireDamage(hitInfo);
				else if (entity.LookupPrefab().name == "box.wooden.large" ||
						entity.LookupPrefab().name == "woodbox_deployed")
                {
                    var before = hitInfo.damageTypes.Get(Rust.DamageType.Decay);
                    hitInfo.damageTypes.Scale(Rust.DamageType.Decay, c_boxMultiplier);

                    if (c_outputToRcon)
                        Puts($"Decay ({entity_name}) before: {before} after: {hitInfo.damageTypes.Get(Rust.DamageType.Decay)}");
                }								
				else if (entity.LookupPrefab().name.Contains("deployed"))
                {
                    var before = hitInfo.damageTypes.Get(Rust.DamageType.Decay);
                    hitInfo.damageTypes.Scale(Rust.DamageType.Decay, c_deployablesMultiplier);

                    if (c_outputToRcon)
                        Puts($"Decay ({entity_name}) before: {before} after: {hitInfo.damageTypes.Get(Rust.DamageType.Decay)}");
                }
				else if (entity.LookupPrefab().name.Contains("furnace"))
                {
                    var before = hitInfo.damageTypes.Get(Rust.DamageType.Decay);
                    hitInfo.damageTypes.Scale(Rust.DamageType.Decay, c_furnaceMultiplier);

                    if (c_outputToRcon)
                        Puts($"Decay ({entity_name}) before: {before} after: {hitInfo.damageTypes.Get(Rust.DamageType.Decay)}");
                }								
				else if (entity.LookupPrefab().name == "WaterBarrel" ||
						entity.LookupPrefab().name == "jackolantern.angry" ||
						entity.LookupPrefab().name == "jackolantern.happy" ||
						entity.LookupPrefab().name == "water_catcher_small" ||
						entity.LookupPrefab().name == "water_catcher_large")
                {
                    var before = hitInfo.damageTypes.Get(Rust.DamageType.Decay);
                    hitInfo.damageTypes.Scale(Rust.DamageType.Decay, c_deployablesMultiplier);

                    if (c_outputToRcon)
                        Puts($"Decay ({entity_name}) before: {before} after: {hitInfo.damageTypes.Get(Rust.DamageType.Decay)}");
                }												
				else if (entity.LookupPrefab().name == "beartrap" ||
						entity.LookupPrefab().name == "landmine" ||
						entity.LookupPrefab().name == "spikes.floor")
                {
                    var before = hitInfo.damageTypes.Get(Rust.DamageType.Decay);
                    hitInfo.damageTypes.Scale(Rust.DamageType.Decay, c_trapMultiplier);

                    if (c_outputToRcon)
                        Puts($"Decay ({entity_name}) before: {before} after: {hitInfo.damageTypes.Get(Rust.DamageType.Decay)}");
                }												
                else if (entity.LookupPrefab().name.Contains("barricade"))
                {
                    var before = hitInfo.damageTypes.Get(Rust.DamageType.Decay);
                    hitInfo.damageTypes.Scale(Rust.DamageType.Decay, c_barricadeMultiplier);

                    if (c_outputToRcon)
                        Puts($"Decay ({entity_name}) before: {before} after: {hitInfo.damageTypes.Get(Rust.DamageType.Decay)}");
                }				
                else if (entity.LookupPrefab().name == "gates.external.high.stone")
                {
                    var before = hitInfo.damageTypes.Get(Rust.DamageType.Decay);
                    hitInfo.damageTypes.Scale(Rust.DamageType.Decay, c_highStoneWallMultiplier);

                    if (c_outputToRcon)
                        Puts($"Decay (high stone gate) before: {before} after: {hitInfo.damageTypes.Get(Rust.DamageType.Decay)}");
                }
                else if (entity.LookupPrefab().name == "gates.external.high.wood")
                {
                    var before = hitInfo.damageTypes.Get(Rust.DamageType.Decay);
                    hitInfo.damageTypes.Scale(Rust.DamageType.Decay, c_highWoodWallMultiplier);

                    if (c_outputToRcon)
                        Puts($"Decay (high wood gate) before: {before} after: {hitInfo.damageTypes.Get(Rust.DamageType.Decay)}");
                }
                else if (entity.LookupPrefab().name == "wall.external.high.stone")
                {
                    var before = hitInfo.damageTypes.Get(Rust.DamageType.Decay);
                    hitInfo.damageTypes.Scale(Rust.DamageType.Decay, c_highStoneWallMultiplier);

                    if (c_outputToRcon)
                        Puts($"Decay (high stone wall) before: {before} after: {hitInfo.damageTypes.Get(Rust.DamageType.Decay)}");
                }
                else if (entity.LookupPrefab().name == "wall.external.high.wood")
                {
                    var before = hitInfo.damageTypes.Get(Rust.DamageType.Decay);
                    hitInfo.damageTypes.Scale(Rust.DamageType.Decay, c_highWoodWallMultiplier);

                    if (c_outputToRcon)
                        Puts($"Decay (high wood wall) before: {before} after: {hitInfo.damageTypes.Get(Rust.DamageType.Decay)}");
                }
                else if (entity.LookupPrefab().name == "mining.pumpjack")
                {
                    var before = hitInfo.damageTypes.Get(Rust.DamageType.Decay);
                    hitInfo.damageTypes.Scale(Rust.DamageType.Decay, 0.0f);

                    if (c_outputToRcon)
                        Puts($"Decay (pumpjack) before: {before} after: {hitInfo.damageTypes.Get(Rust.DamageType.Decay)}");
                }
                else if (block != null)
                    ProcessBuildingDamage(block, hitInfo);
                else
                    Puts($"Unsupported decaying entity detected: {entity.LookupPrefab().name} --- please notify author");
            }
            finally
            {
                var ms = (DateTime.Now - tick).TotalMilliseconds;
                if (ms > 10) Puts($"NoDecay.OnEntityTakeDamage took {ms} ms to execute.");
            }
        }

        void ProcessCampfireDamage(HitInfo hitInfo)
        {
            var before = hitInfo.damageTypes.Get(Rust.DamageType.Decay);
            hitInfo.damageTypes.Scale(Rust.DamageType.Decay, c_campfireMultiplier);
            if (c_outputToRcon)
                Puts($"Decay campfire before: {before} after: {hitInfo.damageTypes.Get(Rust.DamageType.Decay)}");
        }

        void ProcessBuildingDamage(BuildingBlock block, HitInfo hitInfo)
        {
            var multiplier = 1.0f;
            var isHighWall = block.LookupPrefab().name.Contains("wall.external");

            string type = "other";
            switch (block.grade)
            {
                case BuildingGrade.Enum.Twigs:
                    multiplier = c_twigMultiplier;
                    type = "twig";
                    break;
                case BuildingGrade.Enum.Wood:
                    if (isHighWall)
                    {
                        multiplier = c_highWoodWallMultiplier;
                        type = "high wood wall";
                    }
                    else
                    {
                        multiplier = c_woodMultiplier;
                        type = "wood";
                    }
                    break;
                case BuildingGrade.Enum.Stone:
                    if (isHighWall)
                    {
                        multiplier = c_highStoneWallMultiplier;
                        type = "high stone wall";
                    }
                    else
                    {
                        multiplier = c_stoneMultiplier;
                        type = "stone";
                    }
                    break;
                case BuildingGrade.Enum.Metal:
                    multiplier = c_sheetMultiplier;
                    type = "sheet";
                    break;
                case BuildingGrade.Enum.TopTier:
                    multiplier = c_armoredMultiplier;
                    type = "armored";
                    break;
            };

            var before = hitInfo.damageTypes.Get(Rust.DamageType.Decay);
            hitInfo.damageTypes.Scale(Rust.DamageType.Decay, multiplier);

            if (c_outputToRcon)
                Puts($"Decay ({type}) before: {before} after: {hitInfo.damageTypes.Get(Rust.DamageType.Decay)}");
        }
    }
}


// --- End of file: NoDecay.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/EasyReload.cs ---
// --- Original Local Path: EasyReload.cs ---

using System.Collections.Generic;
using System.Reflection;
using System;
using System.Data;
using UnityEngine;
using Oxide.Core;
using Rust;

namespace Oxide.Plugins
{
    [Info("Easy Reload", "LaserHydra", "2.0.0", ResourceId = 854)]
    [Description("Reload your plugins easily")]
    class EasyReload : RustPlugin
    {
        void Loaded()
        {
            if (!permission.PermissionExists("canReload")) permission.RegisterPermission("canReload", this);
        }
        [ChatCommand("reload")]
        void cmdReload(BasePlayer player, string cmd, string[] args)
        {
            string uid = Convert.ToString(player.userID);
            if (!permission.UserHasPermission(uid, "canReload"))
            {
                SendChatMessage(player, "RELOAD", "You have no permission to use this command!");
                return;
            }
            if (args.Length < 1)
            {
                SendChatMessage(player, "RELOAD", "Reloading plugins...");
                ConsoleSystem.Run.Server.Normal("oxide.reload *");
                SendChatMessage(player, "RELOAD", "All plugins reloaded!");

            }
            if (args.Length == 1)
            {
                string pluginname = GetPlugin(args[0], player, "RELOAD");
                string filename = GetPluginFile(pluginname);
                if (pluginname != "")
                {
                    ConsoleSystem.Run.Server.Normal("oxide.reload " + filename);
                    SendChatMessage(player, "RELOAD", "Reloaded plugin <color=orange>" + pluginname + "</color>!");
                }
            }
        }
        //--------------------------->   Player finding   <---------------------------//

        string GetPlugin(string searchedPlugin, BasePlayer executer, string prefix)
        {
            string targetPlugin = "";
            List<string> foundPlugins = new List<string>();
            string searchedLower = searchedPlugin.ToLower();
            foreach (var plugin in plugins.GetAll())
            {
                if (plugin.Author == "Oxide Team")
                {
                    continue;
                }

                string display = plugin.Title;
                string displayLower = display.ToLower();

                if (!displayLower.Contains(searchedLower))
                {
                    continue;
                }
                if (displayLower.Contains(searchedLower))
                {
                    foundPlugins.Add(display);
                }
            }
            var matchingPlugins = foundPlugins.ToArray();

            if (matchingPlugins.Length == 0)
            {
                SendChatMessage(executer, prefix, "No matching plugins found!");
            }

            if (matchingPlugins.Length > 1)
            {
                SendChatMessage(executer, prefix, "Multiple plugins found:");
                string multiplePlugins = "";
                foreach (string matchingplugin in matchingPlugins)
                {
                    if (multiplePlugins == "")
                    {
                        multiplePlugins = "<color=yellow>" + matchingplugin + "</color>";
                        continue;
                    }

                    if (multiplePlugins != "")
                    {
                        multiplePlugins = multiplePlugins + ", " + "<color=yellow>" + matchingplugin + "</color>";
                    }

                }
                SendChatMessage(executer, prefix, multiplePlugins);
            }

            if (matchingPlugins.Length == 1)
            {
                targetPlugin = matchingPlugins[0];
            }
            return targetPlugin;
        }

        string GetPluginFile(string pluginname)
        {
            string filename = "";
            foreach (var plugin in plugins.GetAll())
            {
                if (plugin.Author == "Oxide Team")
                {
                    continue;
                }

                string display = plugin.Title;

                if (display != pluginname)
                {
                    continue;
                }
                if (display == pluginname)
                {
                    filename = plugin.Name;
                    break;
                }
            }
            return filename;
        }

        //---------------------------->   Chat Sending   <----------------------------//

        void BroadcastChat(string prefix, string msg)
        {
            PrintToChat("<color=orange>" + prefix + "</color>: " + msg);
        }

        void SendChatMessage(BasePlayer player, string prefix, string msg)
        {
            SendReply(player, "<color=orange>" + prefix + "</color>: " + msg);
        }

        //---------------------------------------------------------------------------//
    }
}


// --- End of file: EasyReload.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AntiHack (1).cs ---
// --- Original Local Path: AntiHack (1).cs ---

using Network;
using Network.Visibility;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Rust;
using System;
using System.Collections.Generic;
using System.Globalization;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("AntiHack", "OxideBro", "1.0.0")]
    public class AntiHack : RustPlugin
    {
		private static Dictionary<ulong, HashSet<uint>> playersHidenEntities = new Dictionary<ulong, HashSet<uint>>();
        private static int radius = 35;
        private Dictionary<BasePlayer, AntiHack.CurrentLog> currentAdminsLog = new Dictionary<BasePlayer, AntiHack.CurrentLog>();
        private Dictionary<ulong, float> lastSpeedAttackAttackTime = new Dictionary<ulong, float>();
        private Dictionary<ulong, float> lastShootingThroughWallTime = new Dictionary<ulong, float>();
        private Dictionary<ulong, int> speedAttackDetections = new Dictionary<ulong, int>();
        private Dictionary<ulong, int> shootingThroughWallDetections = new Dictionary<ulong, int>();
        private static bool isSaving = false;
        private static bool debug = false;
        private static float minPlayersWallHackDistanceCheck = 0.0f;
        private static float minObjectsWallHackDistanceCheck = 50.0f;
        private static float maxPlayersWallHackDistanceCheck = 250f;
        private static float maxObjectsWallHackDistanceCheck = 150f;
        private static float tickRate = 0.1f;
        private static int globalMask = LayerMask.GetMask("Construction", "Deployed", "World", "Default");
        private static int cM = LayerMask.GetMask("Construction");
        private static int playerWallHackMask = LayerMask.GetMask("Construction", "World", "Default", "Deployed");
        private static int entityMask = LayerMask.GetMask("Deployed");
        private static int constructionAndDeployed = LayerMask.GetMask("Construction", "Deployed");
        private static Dictionary<ulong, int> playersKicks = new Dictionary<ulong, int>();
        private static Dictionary<ulong, AntiHack.HackHandler> playersHandlers = new Dictionary<ulong, AntiHack.HackHandler>();
        private static Dictionary<int, Dictionary<int, AntiHack.Chunk>> chunks = new Dictionary<int, Dictionary<int, AntiHack.Chunk>>();
        private static HashSet<AntiHack.Chunk> chunksList = new HashSet<AntiHack.Chunk>();
        private List<string> neededEntities = new List<string>()
        {
          "cupboard.tool.deployed",
          "sleepingbag_leather_deployed",
          "bed_deployed"
        };
		public bool IsConnected(BasePlayer player) => BasePlayer.activePlayerList.Contains(player);
        public void Kick(BasePlayer player, string reason = "") => player.Kick(reason);
        public bool IsBanned(ulong id) => ServerUsers.Is(id, ServerUsers.UserGroup.Banned);
        private static AntiHack instance;
        private bool isLoaded;
        private static bool wallHackPlayersEnabled;
        private static bool wallHackObjectsEnabled;
        private static bool enableFlyHackLog;
        private static bool enableFlyHackCar;
        private static bool enableSpeedHackLog;
        private static bool enableTextureHackLog;
        private static bool enableSpeedAttackLog;
        private static bool enableWallHackAttackLog;
        private static bool needKick;
        private static bool needKickEndKill;
        private static bool needBan;
        private bool configChanged;
        private const int intervalBetweenTextureHackMessages = 50;
        private const int maxFalseFlyDetects = 5;
        private const int maxFalseSpeedDetects = 5;
        private static int maxFlyWarnings;
        private static int maxSpeedWarnings;
        private static AntiHack.StoredData db;
		
        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            Dictionary<string, object> dictionary = this.Config[menu] as Dictionary<string, object>;
            if (dictionary == null)
            {
                dictionary = new Dictionary<string, object>();
                this.Config[menu] = (object)dictionary;
                this.configChanged = true;
            }
            object obj;
            if (!dictionary.TryGetValue(datavalue, out obj))
            {
                obj = defaultValue;
                dictionary[datavalue] = obj;
                this.configChanged = true;
            }
            return obj;
        }
		
        protected override void LoadDefaultConfig()
        {
            this.Config.Clear();
            this.LoadVariables();
        }

        private void LoadVariables()
        {
            maxFlyWarnings = Convert.ToInt32(this.GetConfig("Основное", "Количество детектов FlyHack для наказания:", (object)10));
            Plugins.AntiHack.maxSpeedWarnings = Convert.ToInt32(this.GetConfig("Основное", "Количество детектов SpeedHack для наказания:", (object)10));
            Plugins.AntiHack.needKick = Convert.ToBoolean(this.GetConfig("Основное", "Наказать киком:", (object)false));
            Plugins.AntiHack.needKickEndKill = Convert.ToBoolean(this.GetConfig("Основное", "TextureHack - Наказать киком и убить игрока:", (object)false));
            Plugins.AntiHack.needBan = Convert.ToBoolean(this.GetConfig("Основное", "Наказать баном:", (object)false));
            Plugins.AntiHack.enableFlyHackLog = Convert.ToBoolean(this.GetConfig("Основное", "Логировать детекты FlyHack:", (object)true));
            Plugins.AntiHack.enableFlyHackCar = Convert.ToBoolean(this.GetConfig("Основное", "Не логировать детекты в машине?", (object)true));
            Plugins.AntiHack.enableSpeedHackLog = Convert.ToBoolean(this.GetConfig("Основное", "Логировать детекты SpeedHack:", (object)true));
            Plugins.AntiHack.enableTextureHackLog = Convert.ToBoolean(this.GetConfig("Основное", "Логировать детекты TextureHack:", (object)false));
            Plugins.AntiHack.enableSpeedAttackLog = Convert.ToBoolean(this.GetConfig("Основное", "Логировать детекты на быстрое добывание:", (object)true));
            Plugins.AntiHack.enableWallHackAttackLog = Convert.ToBoolean(this.GetConfig("Основное", "Логировать детекты на WallHackAttack:", (object)true));
            Plugins.AntiHack.wallHackObjectsEnabled = Convert.ToBoolean(this.GetConfig("Экспериментальное", "Включить AntiESP на объекты (Внимание! Может нагружать сервер!)", (object)false));
            Plugins.AntiHack.wallHackPlayersEnabled = Convert.ToBoolean(this.GetConfig("Экспериментальное", "Включить AntiESP на людей (Внимание! Может сильно нагружать сервер!)", (object)false));
            if (!this.configChanged)
                return;
            this.SaveConfig();
            this.configChanged = false;
        }

        public static void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject<AntiHack.StoredData>("AntiHack_Detects", Plugins.AntiHack.db, false);
        }

        public void ShowDetects(BasePlayer player, string[] args)
        {
            string s = (string)null;
            if (args.Length == 2)
            {
                if (args[1] == "0")
                {
                    player.ChatMessage("Очищаем номер детекта для телепорта...");
                    this.currentAdminsLog.Remove(player);
                }
                else
                    s = args[1];
            }
            string user = args[0];
            AntiHack.Log log;
            if (user.Contains("765"))
            {
                ulong id;
                ulong.TryParse(args[0], out id);
                log = Plugins.AntiHack.db.logs.Find((Predicate<Log>)(x => (long)x.steamID == (long)id));
            }
            else
                log = Plugins.AntiHack.db.logs.Find((Predicate<Log>)(x => x.name.Contains(user, CompareOptions.IgnoreCase)));
            if (log == null)
            {
                player.ChatMessage("Ошибка. В логах нет такого игрока");
            }
            else
            {
                AntiHack.CurrentLog currentLog;
                if (!this.currentAdminsLog.TryGetValue(player, out currentLog))
                {
                    this.currentAdminsLog[player] = new AntiHack.CurrentLog()
                    {
                        detect = 1,
                        steamID = log.steamID
                    };
                    player.ChatMessage(string.Format("Игрок {0}\nКоличество детектов: {1}", (object)log.name, (object)log.detectsAmount));
                }
                else if ((long)currentLog.steamID != (long)log.steamID)
                {
                    this.currentAdminsLog[player] = new AntiHack.CurrentLog()
                    {
                        detect = 1,
                        steamID = log.steamID
                    };
                    player.ChatMessage(string.Format("Игрок {0}\nКоличество детектов: {1}", (object)log.name, (object)log.detectsAmount));
                }
                else if (s == null)
                {
                    if (log.detectsAmount >= currentLog.detect + 1)
                    {
                        ++currentLog.detect;
                    }
                    else
                    {
                        player.ChatMessage(string.Format("Больше детектов у игрока {0} нет", (object)log.name));
                        this.currentAdminsLog.Remove(player);
                        return;
                    }
                }
                int result = 0;
                int.TryParse(s, out result);
                bool flag = false;
                for (int index = 0; index < log.detects.Count; ++index)
                {
                    AntiHack.Detect detect = log.detects[index];
                    if (result == 0)
                    {
                        if (this.currentAdminsLog[player].detect == index + 1)
                        {
                            foreach (AntiHack.Coordinates coordinate in detect.coordinates)
                            {
                                Vector3 vector3_1 = coordinate.startPos.ToVector3();
                                Vector3 vector3_2 = coordinate.endPos.ToVector3();
                                player.SendConsoleCommand("ddraw.arrow", (object)20f, (object)Color.white, (object)vector3_1, (object)vector3_2, (object)0.2f);
                                if (!flag)
                                {
                                    player.Teleport(vector3_1);
                                    flag = true;
                                    player.ChatMessage(string.Format("Телепорт на детект {0} игрока {1}", (object)this.currentAdminsLog[player].detect, (object)log.name));
                                }
                            }
                        }
                    }
                    else if (result == index + 1)
                    {
                        foreach (AntiHack.Coordinates coordinate in detect.coordinates)
                        {
                            Vector3 vector3_1 = coordinate.startPos.ToVector3();
                            Vector3 vector3_2 = coordinate.endPos.ToVector3();
                            player.SendConsoleCommand("ddraw.arrow", (object)20f, (object)Color.white, (object)vector3_1, (object)vector3_2, (object)0.2f);
                            if (!flag)
                            {
                                player.Teleport(vector3_1);
                                flag = true;
                                player.ChatMessage(string.Format("Телепорт на детект {0} игрока {1}", (object)result, (object)log.name));
                                this.currentAdminsLog[player].detect = result;
                            }
                        }
                    }
                }
            }
        }
		void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            if (entity == null || !(entity is BasePlayer) || item == null || dispenser == null) return;
            if (entity.ToPlayer() is BasePlayer);
                
        }
        public static void LogHandler(BasePlayer player, Vector3 lastGroundPos, AntiHack.TemporaryCoordinates temp, bool isSpeedHack = false)
        {
            AntiHack.Log log1 = Plugins.AntiHack.db.logs.Find((Predicate<Log>)(x => (long)x.steamID == (long)player.userID));
            Vector3 position = player.transform.position;
            if (isSpeedHack)
            {
                position.y += 0.7f;
                lastGroundPos.y += 0.7f;
            }
            AntiHack.Coordinates coordinates;
            coordinates.startPos = lastGroundPos.ToString();
            coordinates.endPos = position.ToString();
            AntiHack.Detect detect = new AntiHack.Detect();
            if (log1 == null)
            {
                AntiHack.Log log2 = new AntiHack.Log();
                log2.detectsAmount = 1;
                if (temp.coordinates.Count > 0)
                {
                    detect.coordinates.AddRange((IEnumerable<AntiHack.Coordinates>)temp.coordinates);
                    log2.detects.Add(detect);
                }
                else if (isSpeedHack)
                {
                    detect.coordinates.Add(coordinates);
                    log2.detects.Add(detect);
                }
                log2.name = player.displayName;
                log2.steamID = player.userID;
                Plugins.AntiHack.db.logs.Add(log2);
            }
            else
            {
                ++log1.detectsAmount;
                if (temp.coordinates.Count > 0)
                {
                    detect.coordinates.AddRange((IEnumerable<AntiHack.Coordinates>)temp.coordinates);
                    log1.detects.Add(detect);
                }
                else if (isSpeedHack)
                {
                    detect.coordinates.Add(coordinates);
                    log1.detects.Add(detect);
                }
                log1.name = player.displayName;
            }
        }

        [HookMethod("ShowLog")]
        private void ShowLog(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin)
                    return;
            if (!Plugins.AntiHack.CanGetReport(player))
                return;
            if (args.Length == 0)
            {
                if (!Plugins.AntiHack.debug)
                {
                    AntiHack.HackHandler component = player.GetComponent<AntiHack.HackHandler>();
                    component.lastGroundPosition = player.transform.position;
                    component.playerPreviousPosition = player.transform.position;
                    Plugins.AntiHack.debug = true;
                    player.ChatMessage("Админ дебаг включен. Вас детектит.");
                }
                else
                {
                    Plugins.AntiHack.debug = false;
                    player.ChatMessage("Админ дебаг выключен. Вас не детектит.");
                }
            }
            else
                this.ShowDetects(player, args);
        }

        private static HashSet<BaseEntity> GetEntitiesFromAllChunks()
        {
            HashSet<BaseEntity> baseEntitySet = new HashSet<BaseEntity>();
            foreach (AntiHack.Chunk chunks in Plugins.AntiHack.chunksList)
            {
                foreach (BaseEntity entity in chunks.entities)
                {
                    if (!((UnityEngine.Object)entity == (UnityEngine.Object)null) && !entity.IsDestroyed)
                        baseEntitySet.Add(entity);
                }
            }
            return baseEntitySet;
        }

        private static HashSet<BaseEntity> GetEntitiesFromChunksNearPointOptimized(Vector3 point)
        {
            AntiHack.Chunk chunkFromPoint = Plugins.AntiHack.GetChunkFromPoint(point);
            HashSet<BaseEntity> baseEntitySet = new HashSet<BaseEntity>();
            if (chunkFromPoint == null)
                return baseEntitySet;
            foreach (BaseEntity entity in chunkFromPoint.entities)
                baseEntitySet.Add(entity);
            foreach (BaseEntity entity in Plugins.AntiHack.chunks[chunkFromPoint.x + 1][chunkFromPoint.z + 1].entities)
                baseEntitySet.Add(entity);
            foreach (BaseEntity entity in Plugins.AntiHack.chunks[chunkFromPoint.x - 1][chunkFromPoint.z - 1].entities)
                baseEntitySet.Add(entity);
            foreach (BaseEntity entity in Plugins.AntiHack.chunks[chunkFromPoint.x][chunkFromPoint.z + 1].entities)
                baseEntitySet.Add(entity);
            foreach (BaseEntity entity in Plugins.AntiHack.chunks[chunkFromPoint.x + 1][chunkFromPoint.z].entities)
                baseEntitySet.Add(entity);
            foreach (BaseEntity entity in Plugins.AntiHack.chunks[chunkFromPoint.x - 1][chunkFromPoint.z].entities)
                baseEntitySet.Add(entity);
            foreach (BaseEntity entity in Plugins.AntiHack.chunks[chunkFromPoint.x][chunkFromPoint.z - 1].entities)
                baseEntitySet.Add(entity);
            foreach (BaseEntity entity in Plugins.AntiHack.chunks[chunkFromPoint.x - 1][chunkFromPoint.z + 1].entities)
                baseEntitySet.Add(entity);
            foreach (BaseEntity entity in Plugins.AntiHack.chunks[chunkFromPoint.x + 1][chunkFromPoint.z - 1].entities)
                baseEntitySet.Add(entity);
            return baseEntitySet;
        }

        private static AntiHack.Chunk GetChunkFromPoint(Vector3 point)
        {
            Dictionary<int, AntiHack.Chunk> dictionary;
            AntiHack.Chunk chunk;
            if (Plugins.AntiHack.chunks.TryGetValue((int)((double)point.x / (double)Plugins.AntiHack.radius), out dictionary) && dictionary.TryGetValue((int)((double)point.z / (double)Plugins.AntiHack.radius), out chunk))
                return chunk;
            return (AntiHack.Chunk)null;
        }

        private void SetPlayer(BasePlayer player)
        {
            AntiHack.HackHandler hackHandler = player.gameObject.AddComponent<AntiHack.HackHandler>() ?? player.GetComponent<AntiHack.HackHandler>();
            Plugins.AntiHack.playersHandlers[player.userID] = hackHandler;
            this.lastSpeedAttackAttackTime[player.userID] = UnityEngine.Time.realtimeSinceStartup;
            this.speedAttackDetections[player.userID] = 0;
            this.shootingThroughWallDetections[player.userID] = 0;
            this.lastShootingThroughWallTime[player.userID] = UnityEngine.Time.realtimeSinceStartup;
        }

        public static bool CanGetReport(BasePlayer player)
        {
            return Interface.Oxide.GetLibrary<Permission>((string)null).UserHasPermission(player.userID.ToString(), "antihack.logs") || player.IsAdmin;
        }

        private static void SendReportToOnlineModerators(string report)
        {
            foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
            {
                if (Plugins.AntiHack.CanGetReport(activePlayer))
                    activePlayer.ChatMessage(string.Format("[AntiHack] {0}", (object)report));
            }
        }

        public static BasePlayer FindPlayer(string nameOrIdOrIp)
        {
            foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
            {
                if (activePlayer.UserIDString == nameOrIdOrIp || activePlayer.displayName.Contains(nameOrIdOrIp, CompareOptions.OrdinalIgnoreCase))
                    return activePlayer;
                Networkable net = activePlayer.net;
                if ((net != null ? net.connection : (Network.Connection)null) != null && activePlayer.net.connection.ipaddress == nameOrIdOrIp)
                    return activePlayer;
            }
            foreach (BasePlayer sleepingPlayer in BasePlayer.sleepingPlayerList)
            {
                if (sleepingPlayer.UserIDString == nameOrIdOrIp || sleepingPlayer.displayName.Contains(nameOrIdOrIp, CompareOptions.OrdinalIgnoreCase))
                    return sleepingPlayer;
            }
            return (BasePlayer)null;
        }

        private void ShootingThroughWallHanlder(BasePlayer attacker, HitInfo info, float timeNow)
        {
            BaseEntity hitEntity = info.HitEntity;
            if ((UnityEngine.Object)hitEntity == (UnityEngine.Object)null || (UnityEngine.Object)(hitEntity as BasePlayer) == (UnityEngine.Object)null)
                return;
            Vector3 hitPositionWorld = info.HitPositionWorld;
            Vector3 pointStart = info.PointStart;
            if (!UnityEngine.Physics.Linecast(pointStart, hitPositionWorld, Plugins.AntiHack.cM))
            {
                if (this.shootingThroughWallDetections[attacker.userID] == 0 || (double)timeNow - (double)this.lastShootingThroughWallTime[attacker.userID] <= 10.0)
                    return;
                this.shootingThroughWallDetections[attacker.userID] = 0;
            }
            else
            {
                this.lastShootingThroughWallTime[attacker.userID] = timeNow;
                Dictionary<ulong, int> throughWallDetections = this.shootingThroughWallDetections;
                ulong userId = attacker.userID;
                long num1 = (long)userId;
                int num2 = throughWallDetections[(ulong)num1];
                long num3 = (long)userId;
                int num4 = num2 + 1;
                throughWallDetections[(ulong)num3] = num4;
                if (this.shootingThroughWallDetections[attacker.userID] <= 5)
                    return;
                int averagePing = Network.Net.sv.GetAveragePing(attacker.net.connection);
                string str = string.Format("WallHackAttack Detected\n{0} [{1}]\n{2} -> {3}\nПинг: {4} мс.\nПредупреждений: {5}", (object)attacker.displayName, (object)attacker.userID, (object)pointStart, (object)hitPositionWorld, (object)averagePing, (object)this.shootingThroughWallDetections[attacker.userID]);
                string strMessage = string.Format("WallHackAttack | {0} [{1}] | {2} -> {3} | {4} мс. | Предупреждений: {5}", (object)attacker.displayName, (object)attacker.userID, (object)pointStart, (object)hitPositionWorld, (object)averagePing, (object)this.shootingThroughWallDetections[attacker.userID]);
                instance.LogToFile("Log", strMessage, instance);
                Plugins.AntiHack.SendReportToOnlineModerators(str);
                Interface.Oxide.LogError(str);
            }
        }

        private void SpeedAttackHandler(BasePlayer attacker, HitInfo info, BaseMelee melee, float timeNow)
        {
            if (attacker.IsAdmin)
                return;
            if ((double)timeNow - (double)this.lastSpeedAttackAttackTime[attacker.userID] < (double)melee.repeatDelay - 0.25)
            {
                info.damageTypes = new DamageTypeList();
                info.HitEntity = (BaseEntity)null;
                Dictionary<ulong, int> attackDetections = this.speedAttackDetections;
                ulong userId = attacker.userID;
                long num1 = (long)userId;
                int num2 = attackDetections[(ulong)num1];
                long num3 = (long)userId;
                int num4 = num2 + 1;
                attackDetections[(ulong)num3] = num4;
                if (this.speedAttackDetections[attacker.userID] > 5)
                {
                    int averagePing = Network.Net.sv.GetAveragePing(attacker.net.connection);
                    string str = string.Format("SpeedGather Detected\n{0} [{1}]\nПозиция: {2}\nПинг: {3} мс.\nПредупреждений: {4}", (object)attacker.displayName, (object)attacker.userID, (object)attacker.transform.position, (object)averagePing, (object)this.speedAttackDetections[attacker.userID]);
                    string strMessage = string.Format("SpeedGather | {0} [{1}] | {2} | {3} мс. | Предупреждений: {4}", (object)attacker.displayName, (object)attacker.userID, (object)attacker.transform.position, (object)averagePing, (object)this.speedAttackDetections[attacker.userID]);
                    instance.LogToFile("Log", strMessage, instance);
                    Plugins.AntiHack.SendReportToOnlineModerators(str);
                    Interface.Oxide.LogError(str);
                }
            }
            else
                this.speedAttackDetections[attacker.userID] = 0;
            this.lastSpeedAttackAttackTime[attacker.userID] = timeNow;
        }

        [HookMethod("CanNetworkTo")]
        private object CanNetworkTo(BaseNetworkable entity, BasePlayer target)
        {
            if (!Plugins.AntiHack.wallHackPlayersEnabled || !this.isLoaded || (!Plugins.AntiHack.playersHidenEntities.ContainsKey(target.userID) || !Plugins.AntiHack.playersHidenEntities[target.userID].Contains(entity.net.ID)))
                return (object)null;
            return (object)false;
        }

        [HookMethod("OnEntitySpawned")]
        private void OnEntitySpawned(BaseEntity ent, GameObject gameObject)
        {
            if (!Plugins.AntiHack.wallHackObjectsEnabled || (UnityEngine.Object)(ent as BasePlayer) != (UnityEngine.Object)null || (UnityEngine.Object)ent.GetComponent<LootContainer>() != (UnityEngine.Object)null || (UnityEngine.Object)ent.GetComponent<StorageContainer>() == (UnityEngine.Object)null && !this.neededEntities.Contains(ent.ShortPrefabName))
                return;
            AntiHack.Chunk chunkFromPoint = Plugins.AntiHack.GetChunkFromPoint(ent.transform.position);
            if (chunkFromPoint == null)
                return;
            chunkFromPoint.entities.Add(ent);
        }

        [HookMethod("OnEntityKill")]
        private void OnEntityKill(BaseNetworkable ent)
        {
            if (!Plugins.AntiHack.wallHackObjectsEnabled || !this.isLoaded || (UnityEngine.Object)(ent as BasePlayer) != (UnityEngine.Object)null || (UnityEngine.Object)ent.GetComponent<LootContainer>() != (UnityEngine.Object)null || (UnityEngine.Object)ent.GetComponent<StorageContainer>() == (UnityEngine.Object)null && !this.neededEntities.Contains(ent.ShortPrefabName))
                return;
            AntiHack.Chunk chunkFromPoint = Plugins.AntiHack.GetChunkFromPoint(ent.transform.position);
            if (chunkFromPoint == null || !chunkFromPoint.entities.Contains(ent as BaseEntity))
                return;
            chunkFromPoint.entities.Remove(ent as BaseEntity);
        }

        [HookMethod("Init")]
        private void Init()
        {
            this.LoadVariables();
            if (Plugins.AntiHack.wallHackObjectsEnabled)
            {
                Plugins.AntiHack.radius = ConVar.Server.worldsize / 100;
                int num = 100;
                for (int index1 = num * -1; index1 < num; ++index1)
                {
                    Plugins.AntiHack.chunks[index1] = new Dictionary<int, Chunk>();
                    for (int index2 = num * -1; index2 < num; ++index2)
                    {
                        AntiHack.Chunk chunk = new AntiHack.Chunk()
                        {
                            x = index1,
                            z = index2
                        };
                        Plugins.AntiHack.chunks[index1][index2] = chunk;
                        Plugins.AntiHack.chunksList.Add(chunk);
                    }
                }
                if (Plugins.AntiHack.debug)
                    Puts(string.Format("[Debug WallHackHandler] Chunks: {0} Radius: {1} Map size: {2}", (object)Plugins.AntiHack.chunks.Count, (object)Plugins.AntiHack.radius, (object)ConVar.Server.worldsize));
            }
            Plugins.AntiHack.db = Interface.GetMod().DataFileSystem.ReadObject<AntiHack.StoredData>("AntiHack_Detects");
            Plugins.AntiHack.instance = this;
            Interface.Oxide.GetLibrary<Permission>((string)null).RegisterPermission("antihack.logs", (Plugin)this);
            Interface.Oxide.GetLibrary<Oxide.Game.Rust.Libraries.Command>((string)null).AddChatCommand("ah", (Plugin)this, "ShowLog");
            Interface.Oxide.GetLibrary<Oxide.Game.Rust.Libraries.Command>((string)null).AddConsoleCommand("antihack", (Plugin)this, "AntiHackCmd");
        }

        [HookMethod("OnServerInitialized")]
        private void OnServerInitialized()
        {
            if (Plugins.AntiHack.wallHackObjectsEnabled)
            {
                int num = 0;
                foreach (BaseNetworkable serverEntity in BaseNetworkable.serverEntities)
                {
                    if (!((UnityEngine.Object)(serverEntity as BasePlayer) != (UnityEngine.Object)null) && ((!((UnityEngine.Object)serverEntity.GetComponent<StorageContainer>() == (UnityEngine.Object)null) || this.neededEntities.Contains(serverEntity.ShortPrefabName)) && !((UnityEngine.Object)serverEntity.GetComponent<LootContainer>() != (UnityEngine.Object)null)))
                    {
                        AntiHack.Chunk chunkFromPoint = Plugins.AntiHack.GetChunkFromPoint(serverEntity.transform.position);
                        if (chunkFromPoint != null)
                            chunkFromPoint.entities.Add(serverEntity as BaseEntity);
                        ++num;
                    }
                }
                if (Plugins.AntiHack.debug)
                    Interface.Oxide.LogInfo(string.Format("[Debug WallHackHandler] Added new {0} entities ({1} all)", (object)num, (object)Plugins.AntiHack.GetEntitiesFromAllChunks().Count));
            }
            foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
                this.SetPlayer(activePlayer);
            this.isLoaded = true;
        }

        [HookMethod("OnPlayerDisconnected")]
        private void OnPlayerDisconnected(BasePlayer player)
        {
            AntiHack.HackHandler component = player.GetComponent<AntiHack.HackHandler>();
            if (component == null)
                return;
            component.Disconnect();
        }

        [HookMethod("OnServerSave")]
        private void OnServerSave()
        {
            Plugins.AntiHack.isSaving = true;
            Interface.Oxide.NextTick((Action)(() => Plugins.AntiHack.isSaving = false));
        }

        [HookMethod("OnPlayerInit")]
        private void OnPlayerInit(BasePlayer player)
        {
            this.SetPlayer(player);
        }

        [HookMethod("OnServerShutdown")]
        private void OnServerShutdown()
        {
            Plugins.AntiHack.SaveData();
        }
        
        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                Plugins.AntiHack.playersHandlers.Remove(player.userID);
                AntiHack.HackHandler component = player.GetComponent<AntiHack.HackHandler>();
                if (component != null)
                {
                    component.Disconnect();
                }
            }
            Plugins.AntiHack.SaveData();
            DestroyAll<AntiHack.HackHandler>();
        }

        void DestroyAll<T>()
        {
            UnityEngine.Object[] objects = GameObject.FindObjectsOfType(typeof(T));
            if (objects != null)
                foreach (UnityEngine.Object gameObj in objects)
                    GameObject.Destroy(gameObj);
            
        }

        [HookMethod("OnPlayerAttack")]
        private void OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            if (Plugins.AntiHack.isSaving || (UnityEngine.Object)attacker == (UnityEngine.Object)null || (attacker.IsAdmin || (UnityEngine.Object)info.Weapon == (UnityEngine.Object)null))
                return;
            float realtimeSinceStartup = UnityEngine.Time.realtimeSinceStartup;
            BaseMelee component = info.Weapon.GetComponent<BaseMelee>();
            if ((UnityEngine.Object)component == (UnityEngine.Object)null && Plugins.AntiHack.enableWallHackAttackLog)
            {
                this.ShootingThroughWallHanlder(attacker, info, realtimeSinceStartup);
            }
            else
            {
                if (!Plugins.AntiHack.enableSpeedAttackLog)
                    return;
                this.SpeedAttackHandler(attacker, info, component, realtimeSinceStartup);
            }
        }

        private bool IsPlayerGotImmunity(ulong id)
        {
            object obj = Interface.Oxide.CallHook("AntiHackIsPlayerGotImmunity", (object)id);
            return obj != null && (bool)obj;
        }

        private class Chunk
        {
            public HashSet<BaseEntity> entities = new HashSet<BaseEntity>();

            public int x { get; set; }

            public int z { get; set; }
        }

        private class Log
        {
            public List<AntiHack.Detect> detects = new List<AntiHack.Detect>();
            public int detectsAmount;
            public ulong steamID;
            public string name;
        }

        public struct Coordinates
        {
            public string startPos;
            public string endPos;
        }

        public class Detect
        {
            public List<AntiHack.Coordinates> coordinates = new List<AntiHack.Coordinates>();
        }

        public class TemporaryCoordinates
        {
            public List<AntiHack.Coordinates> coordinates = new List<AntiHack.Coordinates>();
        }

        private class StoredData
        {
            public List<AntiHack.Log> logs = new List<AntiHack.Log>();
        }

        private class CurrentLog
        {
            public ulong steamID;
            public int detect;
        }

        private class HackHandler : MonoBehaviour
        {
            private int flyWarnings = 0;
            private int textureWarnings = 0;
            private int speedWarnings = 0;
            private float ownTickRate = 0.1f;
            private bool IsFlying = false;
            private int falseFlyDetects = 0;
            private int falseSpeedDetects = 0;
            private int ping = 0;
            private AntiHack.TemporaryCoordinates temp = new AntiHack.TemporaryCoordinates();
            public HashSet<BaseEntity> hidedEntities = new HashSet<BaseEntity>();
            public Dictionary<ulong, HashSet<BaseEntity>> hidedPlayersEntities = new Dictionary<ulong, HashSet<BaseEntity>>();
            public HashSet<BaseEntity> seenObjects = new HashSet<BaseEntity>();
            public Vector3 lastPosition = new Vector3();
            private bool IsHided = false;
            private bool isShowedAll = false;
            public BasePlayer player;
            private float lastTick;
            private float deltaTime;
            private float flyTime;
            private float flyTimeStart;
            public Vector3 lastGroundPosition;
            public Vector3 playerPreviousPosition;
            private Network.Connection connection;

            private void Awake()
            {
                this.player = this.GetComponent<BasePlayer>();
                this.ownTickRate = UnityEngine.Random.Range(0.09f, 0.11f);
                Plugins.AntiHack.playersHidenEntities[this.player.userID] = new HashSet<uint>();
                this.connection = this.player.net.connection;
                this.lastGroundPosition = this.player.transform.position;
                this.playerPreviousPosition = this.player.transform.position;
                if (!Plugins.AntiHack.wallHackObjectsEnabled)
                    return;
                if (this.player.IsReceivingSnapshot || this.player.IsSleeping())
                    this.CheckSnapshot();
                else
                    this.HideAll();
            }

            private void Update()
            {
                if ((double)UnityEngine.Time.realtimeSinceStartup - (double)this.lastTick < (double)this.ownTickRate)
                    return;
                if (Plugins.AntiHack.instance.IsPlayerGotImmunity(this.player.userID))
                {
                    this.ShowAllEntities();
                    this.lastPosition = this.player.GetNetworkPosition();
                    this.playerPreviousPosition = this.player.transform.position;
                    this.lastGroundPosition = this.player.transform.position;
                }
                else
                {
                    this.isShowedAll = false;
                    if (this.player.IsAdmin && !Plugins.AntiHack.debug)
                    {
                        this.WallHackHandler();
                        this.lastPosition = this.player.GetNetworkPosition();
                        this.playerPreviousPosition = this.player.transform.position;
                    }
                    else
                    {
                        this.CorrectValues();
                        this.lastPosition = this.player.GetNetworkPosition();
                        this.FlyHackHandler();
                        this.PlayerWallHackHandler();
                        this.PlayerWallHackHandlerSleepers();
                        this.SpeedHackHandler();
                        this.WallHackHandler();
                        if (this.player.IsSleeping() || this.player.IsDead())
                        {
                            this.playerPreviousPosition = this.player.transform.position;
                            this.lastGroundPosition = this.player.transform.position;
                        }
                        else
                        {
                            this.TextureHackHandler();
                            this.playerPreviousPosition = this.player.transform.position;
                        }
                    }
                }
            }

            private void SpeedHackHandler()
            {
                if (this.player.IsOnGround())
                {
                    if (Plugins.AntiHack.enableFlyHackCar && player.GetMounted() != null) return;
                    Vector3 position = this.player.transform.position;
                    if ((double)this.playerPreviousPosition.y - (double)position.y < 0.5)
                    {
                        float num = Vector3Ex.Distance2D(this.playerPreviousPosition, position);
                        float maxSpeed = (float)(((double)this.player.GetMaxSpeed() + 1.0) * (double)Plugins.AntiHack.tickRate * (double)this.deltaTime * 1.54999995231628);
                        if ((double)num > (double)maxSpeed)
                        {
                            this.falseSpeedDetects = this.falseSpeedDetects + 1;
                            if (this.falseSpeedDetects <= 5)
                                return;
                            this.falseSpeedDetects = 0;
                            this.speedWarnings = this.speedWarnings + 1;
                            if (Plugins.AntiHack.enableSpeedHackLog)
                            {
                                this.CreateLogSpeedHack(position, maxSpeed);
                                Plugins.AntiHack.LogHandler(this.player, this.playerPreviousPosition, this.temp, true);
                            }
                            this.ReturnBack(this.playerPreviousPosition);
                            if (this.speedWarnings >= Plugins.AntiHack.maxSpeedWarnings)
                                this.CrimeHandler("SpeedHack");
                            return;
                        }
                    }
                }
                this.falseSpeedDetects = 0;
            }
			public List<Blacklist> list = new List<Blacklist>();
			public class Blacklist
			{
				public Blacklist(string Player, string SteamId)
				{
					this.Player = Player;
					this.SteamId = SteamId;
				}
				public string Player { get; set; }
				public string SteamId { get; set; }


			}
            private void FlyHackHandler()
            {
                Vector3 position = this.player.transform.position;
                if (this.player.IsOnGround() || (double)this.player.WaterFactor() > 0.0)
                {
                    this.lastGroundPosition = position;
                    this.Reset();
                    this.falseFlyDetects = 0;
                }
                else
                {
                    if (!this.IsFlying)
                    {
                        this.flyTimeStart = UnityEngine.Time.realtimeSinceStartup;
                        this.IsFlying = true;
                    }
                    this.flyTime = this.lastTick - this.flyTimeStart;
                    this.AddTemp();
                    if ((double)this.flyTime < 0.600000023841858 && (double)position.y - (double)this.lastGroundPosition.y < 3.0)
                        return;
                    float num1 = Vector3.Distance(position, this.lastGroundPosition);
                    float num2 = Vector3Ex.Distance2D(position, this.lastGroundPosition);
                    if ((double)num1 > 1.20000004768372 * (double)this.deltaTime && ((double)position.y - (double)this.lastGroundPosition.y > 1.20000004768372 || (double)num2 > 15.0) && (((double)this.playerPreviousPosition.y < (double)position.y || (double)num2 > 15.0) && (double)num1 > (double)Vector3.Distance(this.playerPreviousPosition, this.lastGroundPosition) && !UnityEngine.Physics.Raycast(position, Vector3.down, 1.2f)))
                    {
                        this.falseFlyDetects = this.falseFlyDetects + 1;
                        if (this.falseFlyDetects <= 5)
                            return;
                        this.falseFlyDetects = 0;
                        this.flyWarnings = this.flyWarnings + 1;
                        if (Plugins.AntiHack.enableFlyHackLog)
                        {
                            Plugins.AntiHack.LogHandler(this.player, this.lastGroundPosition, this.temp, false);
                            this.CreateLogFlyHack(position);
                        }
                        this.ReturnBack(this.lastGroundPosition);
                        if (this.flyWarnings >= maxFlyWarnings)
                            this.CrimeHandler("FlyHack");
                    }
                    else
                        this.falseFlyDetects = 0;
                }
            }

            private void TextureHackHandler()
            {
                Vector3 position = this.player.transform.position;
                foreach (RaycastHit hit in UnityEngine.Physics.RaycastAll(new Ray(position + Vector3.up * 10f, Vector3.down), 50f, Plugins.AntiHack.globalMask))
                {
                    if (!((UnityEngine.Object)hit.collider == (UnityEngine.Object)null))
                    {
                        if ((UnityEngine.Object)hit.GetEntity() != (UnityEngine.Object)null)
                        {
                            BaseEntity entity = hit.GetEntity();
                            if (this.IsInsideFoundation(entity))
                            {
                                this.textureWarnings = this.textureWarnings + 1;
                                if (Plugins.AntiHack.enableTextureHackLog && this.textureWarnings % 50 == 0)
                                {
                                    this.CreateLogTextureHack(position, entity.ShortPrefabName);
                                }
                                
                                this.ReturnBack(this.playerPreviousPosition);
                                break;
                            }
                        }
                        if ((!(hit.collider.name != "Mesh") || hit.collider.name.Contains("rock_small") || hit.collider.name.Contains("ores")) && this.IsInsideCave(hit.collider))
                        {
                            string objectName = hit.collider.name;
                            if (objectName == "Mesh")
                                objectName = "Rock";
                            this.textureWarnings = this.textureWarnings + 1;
                            if (Plugins.AntiHack.enableTextureHackLog && this.textureWarnings % 20 == 0)
                            {
                                if (objectName.Contains("assets") && objectName.Length > 23)
                                    objectName = objectName.Remove(0, 23);
                                this.CreateLogTextureHack(position, objectName);
                            }
                            this.ReturnBack(this.playerPreviousPosition);
                            break;
                        }
                    }
                }
            }

            private bool IsInsideFoundation(BaseEntity block)
            {
                BuildingBlock buildingBlock = block as BuildingBlock;
                if ((UnityEngine.Object)buildingBlock != (UnityEngine.Object)null)
                {
                    if (!buildingBlock.PrefabName.Contains("foundation") || buildingBlock.PrefabName.Contains("foundation.steps") && buildingBlock.grade != BuildingGrade.Enum.TopTier || (buildingBlock.grade == BuildingGrade.Enum.Twigs || buildingBlock.grade == BuildingGrade.Enum.Wood))
                        return false;
                }
                else if (!block.PrefabName.Contains("wall.external"))
                    return false;
                OBB obb = block.WorldSpaceBounds();
                Vector3 center1 = obb.ToBounds().center;
                obb = this.player.WorldSpaceBounds();
                Vector3 center2 = obb.ToBounds().center;
                center2.y -= 0.7f;
                Vector3 direction = center1 - center2;
                RaycastHit hitInfo;
                return !UnityEngine.Physics.Raycast(new Ray(center2, direction), out hitInfo, direction.magnitude + 1f, Plugins.AntiHack.cM);
            }

            private bool IsInsideCave(Collider collider)
            {
                Vector3 center1 = collider.bounds.center;
                Vector3 center2 = this.player.WorldSpaceBounds().ToBounds().center;
                Vector3 direction = center1 - center2;
                Ray ray = new Ray(center2, direction);
                RaycastHit hitInfo;
                return !collider.Raycast(ray, out hitInfo, direction.magnitude + 1f);
            }

            private void CheckSnapshot()
            {
                if (this.player.IsReceivingSnapshot || this.player.IsSleeping())
                    this.Invoke("CheckSnapshot", 0.1f);
                else
                    this.HideAll();
            }

            public void HideAll()
            {
                if (this.IsHided)
                    return;
                this.IsHided = true;
                foreach (BaseEntity entitiesFromAllChunk in Plugins.AntiHack.GetEntitiesFromAllChunks())
                    this.Hide(entitiesFromAllChunk);
            }

            public void Hide(BaseEntity entity)
            {
                if (this.seenObjects.Contains(entity) || this.hidedEntities.Contains(entity))
                    return;
                if (Network.Net.sv.write.Start())
                {
                    Network.Net.sv.write.PacketID(Network.Message.Type.EntityDestroy);
                    Network.Net.sv.write.EntityID(entity.net.ID);
                    Network.Net.sv.write.UInt8((byte)0);
                    Network.Net.sv.write.Send(new SendInfo(this.connection));
                }
                this.hidedEntities.Add(entity);
            }

            private void Show(BaseEntity entity, bool needRemove = true)
            {
                this.seenObjects.Add(entity);
                if (!this.hidedEntities.Contains(entity))
                    return;
                if (needRemove)
                    this.hidedEntities.Remove(entity);
                this.player.QueueUpdate(BasePlayer.NetworkQueue.Update, (BaseNetworkable)entity);
            }

            private void ShowLines(Vector3 start, Vector3 target, bool isVisible)
            {
                if (!this.player.IsAdmin)
                    return;
                if (isVisible)
                    this.player.SendConsoleCommand("ddraw.arrow", (object)0.1f, (object)Color.blue, (object)start, (object)target, (object)0.1);
                else
                    this.player.SendConsoleCommand("ddraw.arrow", (object)0.1f, (object)Color.red, (object)start, (object)target, (object)0.1);
            }

            private bool TryLineCast(Vector3 start, Vector3 target, float plusTarget = 0.0f, float plusPlayer = 1.5f)
            {
                target.y += plusTarget;
                start.y += plusPlayer;
                return !UnityEngine.Physics.Linecast(start, target, Plugins.AntiHack.cM);
            }

            private bool IsObjectVisible(Vector3 start, Vector3 target)
            {
                return this.TryLineCast(start, target, 0.0f, 1.5f) || (double)Vector3.Distance(start, target) <= 25.0 && (this.TryLineCast(start, target, 0.0f, 0.5f) || this.TryLineCast(start, target, 0.5f, 0.5f) || this.TryLineCast(start, target, 0.5f, 1f));
            }

            private void WallHackHandler()
            {
                if (!Plugins.AntiHack.wallHackObjectsEnabled)
                    return;
                Vector3 position = this.player.transform.position;
                if ((double)Vector3.Distance(this.player.transform.position, this.playerPreviousPosition) < 1.0 / 1000.0)
                    return;
                foreach (BaseEntity entity in Plugins.AntiHack.GetEntitiesFromChunksNearPointOptimized(position))
                {
                    if (!((UnityEngine.Object)entity == (UnityEngine.Object)null) && !this.seenObjects.Contains(entity))
                    {
                        entity.WorldSpaceBounds().ToBounds();
                        if (this.IsObjectVisible(position, entity.WorldSpaceBounds().ToBounds().center))
                            this.Show(entity, true);
                    }
                }
            }

            private void PlayerWallHackHandlerSleepers()
            {
                if (!Plugins.AntiHack.wallHackPlayersEnabled || (double)Vector3.Distance(this.player.transform.position, this.playerPreviousPosition) < 1.0 / 1000.0)
                    return;
                foreach (BasePlayer sleepingPlayer in BasePlayer.sleepingPlayerList)
                {
                    if (!((UnityEngine.Object)sleepingPlayer == (UnityEngine.Object)this.player) && ((double)this.player.Distance((BaseEntity)sleepingPlayer) >= (double)Plugins.AntiHack.minPlayersWallHackDistanceCheck && (double)this.player.Distance((BaseEntity)sleepingPlayer) <= (double)Plugins.AntiHack.maxPlayersWallHackDistanceCheck && !this.seenObjects.Contains((BaseEntity)sleepingPlayer)))
                    {
                        if (!this.IsVisible((BaseEntity)sleepingPlayer, true))
                            this.HidePlayer(sleepingPlayer, true);
                        else
                            this.ShowPlayer(sleepingPlayer, true, true);
                    }
                }
            }

            private void PlayerWallHackHandler()
            {
                if (!Plugins.AntiHack.wallHackPlayersEnabled)
                    return;
                foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
                {
                    if (!((UnityEngine.Object)activePlayer == (UnityEngine.Object)this.player) && ((double)this.player.Distance((BaseEntity)activePlayer) >= (double)Plugins.AntiHack.minPlayersWallHackDistanceCheck && (double)this.player.Distance((BaseEntity)activePlayer) <= (double)Plugins.AntiHack.maxPlayersWallHackDistanceCheck && !activePlayer.net.connection.ipaddress.StartsWith("127.0")) && ((double)Vector3.Distance(Plugins.AntiHack.playersHandlers[activePlayer.userID].lastPosition, activePlayer.GetNetworkPosition()) < 1.0 / 1000.0 || (double)this.player.Distance((BaseEntity)activePlayer) > 50.0 || activePlayer.IsDucked()))
                    {
                        if (!this.IsVisible((BaseEntity)activePlayer, false))
                            this.HidePlayer(activePlayer, false);
                        else
                            this.ShowPlayer(activePlayer, true, false);
                    }
                }
            }

            private bool DoLine(Vector3 start, Vector3 target, float plusTarget = 0.0f, float plusPlayer = 1.5f)
            {
                target.y += plusTarget;
                start.y += plusPlayer;
                return !UnityEngine.Physics.Linecast(start, target, Plugins.AntiHack.cM);
            }

            private bool IsBehindStairs(Vector3 start, Vector3 target)
            {
                RaycastHit hitInfo;
                if (UnityEngine.Physics.Linecast(start, target, out hitInfo, Plugins.AntiHack.cM))
                {
                    BaseEntity entity1 = hitInfo.GetEntity();
                    if ((UnityEngine.Object)entity1 != (UnityEngine.Object)null && ((entity1.ShortPrefabName == "block.stair.lshape" || entity1.ShortPrefabName == "block.stair.ushape") && UnityEngine.Physics.Linecast(target, start, out hitInfo, Plugins.AntiHack.cM)))
                    {
                        BaseEntity entity2 = hitInfo.GetEntity();
                        if ((UnityEngine.Object)entity2 != (UnityEngine.Object)null && (entity2.ShortPrefabName == "block.stair.lshape" || entity2.ShortPrefabName == "block.stair.ushape"))
                            return true;
                    }
                }
                return false;
            }

            private bool IsVisible(BaseEntity target, bool isSleeper = false)
            {
                Vector3 position1 = this.player.transform.position;
                Vector3 position2 = target.transform.position;
                if (isSleeper)
                    return this.DoLine(position1, position2, 0.0f, 1.5f) || this.IsBehindStairs(new Vector3(position1.x, position1.y + 1.2f, position1.z), new Vector3(position2.x, position2.y + 1.2f, position2.z));
                if ((target as BasePlayer).IsDucked())
                    position2.y -= 0.5f;
                float num = this.player.Distance(target);
                if (this.DoLine(position1, position2, 1.5f, 1.5f) || this.IsBehindStairs(new Vector3(position1.x, position1.y + 1.2f, position1.z), new Vector3(position2.x, position2.y + 1.2f, position2.z)))
                    return true;
                if ((double)num > 120.0)
                    return false;
                if (this.DoLine(position1, position2, 0.0f, 1.5f) || this.DoLine(position1, position2, 1.2f, 1.5f) || (this.DoLine(position1, position2, 0.9f, 1.5f) || this.DoLine(position1, position2, 0.5f, 1.5f)) || (this.DoLine(position1, position2, 1.9f, 1.5f) || this.DoLine(position1, position2, 1.5f, 0.0f)))
                    return true;
                if ((double)num > 75.0)
                    return false;
                bool flag1 = !UnityEngine.Physics.Linecast(position1, Quaternion.Euler(this.player.GetNetworkRotation()) * Vector3.left + position1, Plugins.AntiHack.cM);
                bool flag2 = !UnityEngine.Physics.Linecast(position1, Quaternion.Euler(this.player.GetNetworkRotation()) * Vector3.right + position1, Plugins.AntiHack.cM);
                return flag1 && this.DoLine(Quaternion.Euler(this.player.GetNetworkRotation()) * Vector3.left + position1, position2, 1.1f, 1.5f) || flag2 && this.DoLine(Quaternion.Euler(this.player.GetNetworkRotation()) * Vector3.right + position1, position2, 1.1f, 1.5f) || (flag1 && this.DoLine(Quaternion.Euler(this.player.GetNetworkRotation()) * Vector3.left + position1, position2, 1.1f, 1.1f) || flag2 && this.DoLine(Quaternion.Euler(this.player.GetNetworkRotation()) * Vector3.right + position1, position2, 1.1f, 1.1f));
            }

            private void ShowPlayer(BasePlayer target, bool needRemove = true, bool isSleeper = false)
            {
                if (isSleeper)
                    this.seenObjects.Add((BaseEntity)target);
                if (!this.hidedPlayersEntities.ContainsKey(target.userID))
                    return;
                this.player.QueueUpdate(BasePlayer.NetworkQueue.Update, (BaseNetworkable)target);
                this.player.QueueUpdate(BasePlayer.NetworkQueue.Update, target != null ? (BaseNetworkable)target.GetHeldEntity() : (BaseNetworkable)null);
                Plugins.AntiHack.playersHidenEntities[this.player.userID].Remove(target.net.ID);
                foreach (BaseEntity baseEntity in this.hidedPlayersEntities[target.userID])
                {
                    if (!((UnityEngine.Object)baseEntity == (UnityEngine.Object)null) && !baseEntity.IsDestroyed)
                    {
                        this.player.QueueUpdate(BasePlayer.NetworkQueue.Update, (BaseNetworkable)baseEntity);
                        Plugins.AntiHack.playersHidenEntities[this.player.userID].Remove(baseEntity.net.ID);
                    }
                }
                if (needRemove)
                    this.hidedPlayersEntities.Remove(target.userID);
            }

            private void HidePlayer(BasePlayer target, bool isSleeper = false)
            {
                if (isSleeper)
                {
                    if (this.seenObjects.Contains((BaseEntity)target))
                        return;
                }
                else if (this.seenObjects.Contains((BaseEntity)target))
                    this.seenObjects.Remove((BaseEntity)target);
                if (this.hidedPlayersEntities.ContainsKey(target.userID))
                    return;
                this.hidedPlayersEntities[target.userID] = new HashSet<BaseEntity>();
                if (Network.Net.sv.write.Start())
                {
                    Network.Net.sv.write.PacketID(Network.Message.Type.EntityDestroy);
                    Network.Net.sv.write.EntityID(target.net.ID);
                    Network.Net.sv.write.UInt8((byte)0);
                    Network.Net.sv.write.Send(new SendInfo(this.connection));
                }
                Item activeItem = target.GetActiveItem();
                if ((activeItem != null ? (UnityEngine.Object)activeItem.GetHeldEntity() : (UnityEngine.Object)null) != (UnityEngine.Object)null && Network.Net.sv.write.Start())
                {
                    Network.Net.sv.write.PacketID(Network.Message.Type.EntityDestroy);
                    Network.Net.sv.write.EntityID(activeItem.GetHeldEntity().net.ID);
                    Network.Net.sv.write.UInt8((byte)0);
                    Network.Net.sv.write.Send(new SendInfo(this.connection));
                    this.hidedPlayersEntities[target.userID].Add(activeItem.GetHeldEntity());
                    Plugins.AntiHack.playersHidenEntities[this.player.userID].Add(activeItem.GetHeldEntity().net.ID);
                }
                this.HidePlayersHostile(target);
                this.hidedPlayersEntities[target.userID].Add((BaseEntity)target);
                Plugins.AntiHack.playersHidenEntities[this.player.userID].Add(target.net.ID);
            }

            private void HidePlayersHostile(BasePlayer target)
            {
                foreach (Item obj in target.inventory.containerBelt.itemList)
                {
                    if (target.IsHostileItem(obj))
                    {
                        if (!((obj != null ? (UnityEngine.Object)obj.GetHeldEntity() : (UnityEngine.Object)null) == (UnityEngine.Object)null))
                        {
                            if (Network.Net.sv.write.Start())
                            {
                                Network.Net.sv.write.PacketID(Network.Message.Type.EntityDestroy);
                                Network.Net.sv.write.EntityID(obj.GetHeldEntity().net.ID);
                                Network.Net.sv.write.UInt8((byte)0);
                                Network.Net.sv.write.Send(new SendInfo(this.connection));
                                this.hidedPlayersEntities[target.userID].Add(obj.GetHeldEntity());
                                Plugins.AntiHack.playersHidenEntities[this.player.userID].Add(obj.GetHeldEntity().net.ID);
                            }
                        }
                        else
                            break;
                    }
                }
                foreach (Item obj in target.inventory.containerMain.itemList)
                {
                    if (target.IsHostileItem(obj))
                    {
                        if ((obj != null ? (UnityEngine.Object)obj.GetHeldEntity() : (UnityEngine.Object)null) == (UnityEngine.Object)null)
                            break;
                        if (Network.Net.sv.write.Start())
                        {
                            Network.Net.sv.write.PacketID(Network.Message.Type.EntityDestroy);
                            Network.Net.sv.write.EntityID(obj.GetHeldEntity().net.ID);
                            Network.Net.sv.write.UInt8((byte)0);
                            Network.Net.sv.write.Send(new SendInfo(this.connection));
                            this.hidedPlayersEntities[target.userID].Add(obj.GetHeldEntity());
                            Plugins.AntiHack.playersHidenEntities[this.player.userID].Add(obj.GetHeldEntity().net.ID);
                        }
                    }
                }
            }

            private void ShowAllEntities()
            {
                if (this.isShowedAll)
                    return;
                this.isShowedAll = true;
                Plugins.AntiHack.playersHidenEntities[this.player.userID] = new HashSet<uint>();
                HashSet<BaseEntity> hidedEntities = this.hidedEntities;
                foreach (KeyValuePair<ulong, HashSet<BaseEntity>> hidedPlayersEntity in this.hidedPlayersEntities)
                    hidedEntities.UnionWith((IEnumerable<BaseEntity>)hidedPlayersEntity.Value);
                foreach (BaseEntity baseEntity in hidedEntities)
                {
                    if (!((UnityEngine.Object)baseEntity == (UnityEngine.Object)null) && !baseEntity.IsDestroyed)
                        this.player.QueueUpdate(BasePlayer.NetworkQueue.Update, (BaseNetworkable)baseEntity);
                }
            }

            private void CorrectValues()
            {
                this.ping = Network.Net.sv.GetAveragePing(this.player.net.connection);
                if (this.ping == 0)
                    this.ping = 1;
                int frameRate = Performance.current.frameRate;
                float num = 1f;
                if (frameRate < 100)
                    num = 4f;
                if (frameRate < 50)
                    num = 6f;
                this.deltaTime = (float)(1.0 + (double)this.ping * 0.00400000018998981 + (((double)UnityEngine.Time.realtimeSinceStartup - (double)this.lastTick) * (double)num - (double)Plugins.AntiHack.tickRate));
                this.lastTick = UnityEngine.Time.realtimeSinceStartup;
            }

            private void ReturnBack(Vector3 pos)
            {
                this.player.MovePosition(pos);
                Networkable net1 = this.player.net;
                if ((net1 != null ? net1.connection : (Network.Connection)null) != null)
                    this.player.ClientRPCPlayer(null, this.player, "ForcePositionTo", pos);
                Networkable net2 = this.player.net;
                if ((net2 != null ? net2.connection : (Network.Connection)null) == null)
                    return;
                try
                {
                    this.player.ClearEntityQueue((Group)null);
                }
                catch
                {
                }
            }
            private void CreateLogFlyHack(Vector3 playerPosition)
            {
                string str = string.Format("FlyHack detected\n{0} [{1}]\nНачальная позиция: {2}\nКонечная позиция: {3}\nВремя в полете: {4} сек.\nДистанция: {5} м.\nПинг: {6} мс.\nПредупреждений: {7}", (object)this.player.displayName, (object)this.player.userID, (object)this.lastGroundPosition, (object)playerPosition, (object)string.Format("{0:0.##}", (object)this.flyTime), (object)string.Format("{0:0.##}", (object)Vector3.Distance(playerPosition, this.lastGroundPosition)), (object)this.ping, (object)this.flyWarnings);
                string strMessage = string.Format("FlyHack | {0} [{1}] | {2} -> {3} | Время: {4} сек. | Дистанция: {5} м. | {6} мс. | Предупреждений: {7}", (object)this.player.displayName, (object)this.player.userID, (object)this.lastGroundPosition, (object)playerPosition, (object)string.Format("{0:0.##}", (object)this.flyTime), (object)string.Format("{0:0.##}", (object)Vector3.Distance(playerPosition, this.lastGroundPosition)), (object)this.ping, (object)this.flyWarnings);
                Interface.Oxide.LogError(str);
                instance.LogToFile("Log", strMessage, instance);
                Plugins.AntiHack.SendReportToOnlineModerators(str);
                var reply = 79;
            }

            private void CreateLogSpeedHack(Vector3 playerPosition, float maxSpeed)
            {
                string str = string.Format("SpeedHack detected\n{0} [{1}]\nНачальная позиция: {2}\nКонечная позиция: {3}\nСкорость: {4} м/c (Максимально допустимая: {5} м/c).\nПинг: {6} мс.\nПредупреждений: {7}", (object)this.player.displayName, (object)this.player.userID, (object)this.playerPreviousPosition, (object)playerPosition, (object)string.Format("{0:0.##}", (object)(float)((double)Vector3.Distance(playerPosition, this.playerPreviousPosition) * 5.0)), (object)string.Format("{0:0.##}", (object)(float)((double)maxSpeed * 5.0)), (object)this.ping, (object)this.speedWarnings);
                string strMessage = string.Format("SpeedHack | {0} [{1}] | {2} -> {3} | Скорость: {4} м/c (Макс: {5} м/c).| {6} мс. | Предупреждений: {7}", (object)this.player.displayName, (object)this.player.userID, (object)this.playerPreviousPosition, (object)playerPosition, (object)string.Format("{0:0.##}", (object)(float)((double)Vector3.Distance(playerPosition, this.playerPreviousPosition) * 5.0)), (object)string.Format("{0:0.##}", (object)(float)((double)maxSpeed * 5.0)), (object)this.ping, (object)this.speedWarnings);
                Interface.Oxide.LogError(str);
                instance.LogToFile("Log", strMessage, instance);
                Plugins.AntiHack.SendReportToOnlineModerators(str);
            }

            private void CreateLogTextureHack(Vector3 playerPosition, string objectName)
            {
                string str = string.Format("TextureHack detected\n{0} [{1}]\nПозиция: {2}\nОбъект: {3}\nПинг: {4} мс.\nПопыток: {5}", (object)this.player.displayName, (object)this.player.userID, (object)playerPosition, (object)objectName, (object)this.ping, (object)this.textureWarnings);
                string strMessage = string.Format("TextureHack | {0} [{1}] | {2} | Объект: {3} | {4} мс. | Попыток: {5}", (object)this.player.displayName, (object)this.player.userID, (object)playerPosition, (object)objectName, (object)this.ping, (object)this.textureWarnings);
                string reason = string.Format("AntiHack: TextureHack");
                Interface.Oxide.LogError(str);
                instance.LogToFile("Log", strMessage, instance);
                if (Plugins.AntiHack.needKickEndKill)
                { 
                    instance.Kick(player, $"{reason}");
                    player.KillMessage();
                }
                Plugins.AntiHack.SendReportToOnlineModerators(str);
            }

            private void AddTemp()
            {
                AntiHack.Coordinates coordinates;
                coordinates.startPos = this.playerPreviousPosition.ToString();
                coordinates.endPos = this.player.transform.position.ToString();
                this.temp.coordinates.Add(coordinates);
            }

            private void Reset()
            {
                this.temp.coordinates.Clear();
                this.IsFlying = false;
            }

            private void CrimeHandler(string reason)
            {
                if (Plugins.AntiHack.needBan)
                    ConsoleSystem.Run(ConsoleSystem.Option.Unrestricted, string.Format("ban {0} {1}", (object)this.player.userID, (object)reason));
                if (!Plugins.AntiHack.needKick)
                    return;
                ConsoleSystem.Run(ConsoleSystem.Option.Unrestricted, string.Format("kick {0} {1}", (object)this.player.userID, (object)reason));
            }

            public void Disconnect()
            {
                if (playersHandlers.ContainsKey(this.player.userID))
                    playersHandlers.Remove(this.player.userID);
                Destroy(this);
            }
            public void ShowAllPlayers()
            {
                foreach (HashSet<BaseEntity> baseEntitySet in this.hidedPlayersEntities.Values)
                {
                    foreach (BaseNetworkable ent in baseEntitySet)
                        this.player.QueueUpdate(BasePlayer.NetworkQueue.Update, ent);
                }
            }

            public void Destroy()
            {
                foreach (BaseEntity hidedEntity in this.hidedEntities)
                {
                    if ((UnityEngine.Object)(hidedEntity as BasePlayer) != (UnityEngine.Object)null)
                        this.ShowPlayer(hidedEntity as BasePlayer, false, false);
                    else
                        this.Show(hidedEntity, false);
                }
                Plugins.AntiHack.playersHandlers.Remove(this.player.userID);
                UnityEngine.Object.Destroy((UnityEngine.Object)this);
            }
        }
    }
}
                    

// --- End of file: AntiHack (1).cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ImageLoader.cs ---
// --- Original Local Path: ImageLoader.cs ---

﻿// Reference: Facepunch.Sqlite

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using UnityEngine.Networking;
using Database = Facepunch.Sqlite.Database;

namespace Oxide.Plugins
{
    [Info("ImageLoader", "Bombardir", "0.1.0")]
    class ImageLoader : RustPlugin
    {
        public class QueueImageCache : IDisposable
        {
            private class DownloadingItem
            {
                public readonly string ImageUrl;
                public UnityWebRequest Www;
                
                public DownloadingItem(string imageUrl)
                {
                    ImageUrl = imageUrl;
                }
            }

            private const int MaxActiveDownloads = 16;
            private readonly List<DownloadingItem> _activeDownloads = new List<DownloadingItem>(MaxActiveDownloads);
            private readonly Queue<DownloadingItem> _itemsToDownload = new Queue<DownloadingItem>();
            
            private readonly Action _onQueueComplete;
            private readonly Action<string> _onError;
            private readonly Dictionary<string, string> _cachedImages;

            public QueueImageCache(Dictionary<string, string> cachedImages, Action onQueueComplete, Action<string> onError)
            {
                _onQueueComplete = onQueueComplete;
                _onError = onError;
                _cachedImages = cachedImages;
            }
            
            public void Dispose()
            {
                foreach (var item in _activeDownloads)
                {
                    if (!item.Www.isDone && !item.Www.isHttpError && !item.Www.isNetworkError)
                    {
                        item.Www.Dispose();
                    }
                }
            }
            
            public bool TryGetCachedOrCache(string imageUrl, out string cachedImageId)
            {
                cachedImageId = null;
                if (string.IsNullOrEmpty(imageUrl))
                    return false;
                
                var isCached = _cachedImages.TryGetValue(imageUrl, out cachedImageId) &&
                               FileStorage.server.Get(uint.Parse(cachedImageId), FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID) != null;

                if (isCached)
                    return true;

                var isDownloading = _itemsToDownload.Any(item => item.ImageUrl == imageUrl) || 
                                    _activeDownloads.Any(item => item.ImageUrl == imageUrl);
                
                if (!isDownloading)
                {
                    _itemsToDownload.Enqueue(new DownloadingItem(imageUrl));
                    CacheNextImageIfNeeded();
                }

                return false;
            }
            
            private void CacheNextImageIfNeeded()
            {
                if (_itemsToDownload.Count <= 0 || _activeDownloads.Count >= MaxActiveDownloads)
                {
                    if (_activeDownloads.Count == 0)
                        _onQueueComplete();
                    return;
                }

                var downloadItem = _itemsToDownload.Dequeue();
                Rust.Global.Runner.StartCoroutine(CacheAndStartNextImage(downloadItem));
            }

            private IEnumerator CacheAndStartNextImage(DownloadingItem downloadingItem)
            {
                yield return CacheImage(downloadingItem);
                CacheNextImageIfNeeded();
            }

            private IEnumerator CacheImage(DownloadingItem downloadingItem)
            {
                _activeDownloads.Add(downloadingItem);
                
                var imageUrl = downloadingItem.ImageUrl;
                var www = UnityWebRequest.Get(imageUrl);
                downloadingItem.Www = www;
                yield return www.SendWebRequest();

                _activeDownloads.Remove(downloadingItem);

                if (!string.IsNullOrEmpty(www.error) || www.isHttpError || www.isNetworkError)
                {
                    _onError($"Failed to download image {imageUrl}: {www.error}");
                    yield break;
                }
                
                var tex = new Texture2D(2, 2);
                tex.LoadImage(www.downloadHandler.data);
                if (!tex.LoadImage(www.downloadHandler.data) || tex.height == 8 && tex.width == 8 && tex.name == string.Empty && tex.anisoLevel == 1)
                {
                    _onError($"Failed to cache image {imageUrl}: invalid image format");
                    yield break;
                }
                
                byte[] bytes = tex.EncodeToPNG();
                UnityEngine.Object.Destroy(tex);
                
                var imageId = FileStorage.server.Store(bytes, FileStorage.Type.png, 0);
                if (FileStorage.server.Get(imageId, FileStorage.Type.png, 0) == null)
                {
                    _onError($"Failed to store image {imageUrl} into local database");
                    CacheNextImageIfNeeded();
                    yield break;
                }
                
                _cachedImages[imageUrl] =  imageId.ToString();
            }
        }

        private class ImageLoaderData
        {
            public uint entid;
            public Dictionary<string, string> cachedImages = new Dictionary<string, string>();
            public ImageLoaderData() { }
        }

        private const string DataFileName = "Temporary/ImageLoader/image_cache";
        private const string NoneImageUrl = "https://cdn1.savepice.ru/uploads/2019/8/5/bdd7439a1ca1b8e63a3dc6f99bae60a4-full.png";
        
        private readonly Regex _avatarRegex = new Regex(@"<avatarFull><!\[CDATA\[(.*)\]\]></avatarFull>", RegexOptions.Compiled);
        private readonly Dictionary<ulong, string> _avatarUrls = new Dictionary<ulong, string>();
        private readonly Queue<string> _imagesToCache = new Queue<string>();
        
        private QueueImageCache _imageCache;
        private ImageLoaderData _imageLoaderData;

        void Loaded()
        {
            _imageLoaderData = LoadImageLoaderDataFromFile();
            CheckCachedOrCache(NoneImageUrl);
        }
        
        void OnServerInitialized()
        {
            var dbRepaired = RepairImagesDatabaseIfNeeded(_imageLoaderData.entid);
            if (dbRepaired)
            {
                //SaveCachedImages();
            }

            _imageCache = new QueueImageCache(_imageLoaderData.cachedImages, onQueueComplete: SaveCachedImages, onError: LogDownloadError);

            foreach (var image in _imagesToCache)
            {
                CheckCachedOrCache(image);
            }
            
            _imagesToCache.Clear();
            
            foreach (var item in ItemManager.itemList)
            {
                var itemUrl = BuildItemUrl(item.shortname);
                CheckCachedOrCache(itemUrl);
            }
        }

        void Unload()
        {
            _imageCache?.Dispose();
        }
        
        private void OnPlayerInit(BasePlayer player)
        {
            if (_avatarUrls.ContainsKey(player.userID))
                return;
            
            webrequest.Enqueue($"https://steamcommunity.com/profiles/{player.UserIDString}?xml=1", null, 
                (code, response) =>
                {
                    if (response == null || code != 200) 
                        return;
                    
                    var avatarUrl = _avatarRegex.Match(response).Groups[1].ToString();
                    if (!string.IsNullOrEmpty(avatarUrl))
                    {
                        _avatarUrls[player.userID] = avatarUrl;
                    }
                }, this);
        }

        [HookMethod("BuildItemImageComponent")]
        public CuiRawImageComponent BuildItemImageComponent(string shortName)
        {
            var itemUrl = BuildItemUrl(shortName);
            return BuildImageComponent(itemUrl);
        }

        [HookMethod("BuildAvatarImageComponent")]
        public CuiRawImageComponent BuildAvatarImageComponent(ulong userId)
        {
            string steamUrl;
            if (!_avatarUrls.TryGetValue(userId, out steamUrl))
                steamUrl = NoneImageUrl;
            
            return BuildImageComponent(steamUrl);
        }

        [HookMethod("BuildImageComponent")]
        public CuiRawImageComponent BuildImageComponent(string url, string color = "1.0 1.0 1.0 1.0", float FadeIn = 0f)
        {
            if (_imageCache == null)
                throw new Exception("Image cache is not initialized yet");
            
            string imageId;
            return _imageCache.TryGetCachedOrCache(url, out imageId) 
                ? new CuiRawImageComponent {FadeIn = FadeIn, Png = imageId, Color = color, Sprite = "assets/content/textures/generic/fulltransparent.tga"} 
                : new CuiRawImageComponent {FadeIn = FadeIn, Url = url, Color = color, Sprite = "assets/content/textures/generic/fulltransparent.tga"};
        }

        public bool CheckCachedOrCache(string url)
        {
            if (_imageCache == null)
            {
                _imagesToCache.Enqueue(url);
                return false;
            }
            
            string imageId;
            return _imageCache.TryGetCachedOrCache(url, out imageId);
        }

        private void LogDownloadError(string error)
        {
            // Ignore download errors that always occur 
            if (error.Contains("https://static.moscow.ovh/images/games/rust/icons"))
                return;
            
            Puts(error);
        }

        private void SaveCachedImages()
        {
            Puts("Saving cached images ids");
            _imageLoaderData.entid = CommunityEntity.ServerInstance.net.ID;
            Interface.Oxide.DataFileSystem.WriteObject(DataFileName, _imageLoaderData);
        }
        
        private ImageLoaderData LoadImageLoaderDataFromFile()
        {
            ImageLoaderData imageLoaderData = null;
            
            try
            {
                imageLoaderData = Interface.Oxide.DataFileSystem.ReadObject<ImageLoaderData>(DataFileName);
            }
            catch (Exception ex)
            {
                PrintError($"Failed to read saved cached images: {ex}");
            }
            
            return imageLoaderData ?? new ImageLoaderData();
        }

        private bool RepairImagesDatabaseIfNeeded(uint oldEntId)
        {
            if (oldEntId == 0)
            {
                    Puts("There is no saved cached images, skipping database repair.");
                    return false;
                }
                
                var newEntityId = CommunityEntity.ServerInstance.net.ID;
                if (oldEntId == newEntityId)
                {
                    Puts($"Saved CommunityEntity id equals to database id ({oldEntId}), skipping repair.");
                    return false;
                }
                
                Puts($"Repairing images database. Updating old entid '{oldEntId}' to new '{newEntityId}'");

                var imagesDb = new Database();
                imagesDb.Open($"{ConVar.Server.rootFolder}/sv.files.0.db");
                try
                {
                    imagesDb.Query("UPDATE data SET entid=? WHERE entid=?", newEntityId, oldEntId);
                }
                finally
                {
                    imagesDb.Close();
                }

                return true;
            }

            private static string BuildItemUrl(string shortName)
            {
                return $"https://static.moscow.ovh/images/games/rust/icons/{shortName}.png";
            }
        }
}


// --- End of file: ImageLoader.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ProxyBlocker.cs ---
// --- Original Local Path: ProxyBlocker.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Proxy Blocker", "Frizen", "2.0.0")]
    public class ProxyBlocker : RustPlugin
    {
        public Configuration config;
        
        [JsonProperty("Токен от группы ВК(От группы будут идти сообщения в беседу.Вам нужно добавить свою группу в беседу!)")]
        public string Token = "vk1.a.otiNPk1xYFABxGHAke4clG4LbwHR4TP_mWEuLt2CC8IXbA4z73xRM96CcOzgxfFWuo9OghKHxXSLkUJRgpYzPb4GTAdiOQ4FQ_UK-v8U6ORkZ_H6rbPJSijbZc98ykp_DLARwoJsOO8djjL5xBWdom5aOqcbp23-E9lNNUzEmNyHt0V4rnAaTbnPqFZ6GCbi";
            
        [JsonProperty("ID беседы для группы")]
        public string ChatID = "5";

        public class Configuration
        {
            [JsonProperty("Причина кика за VPN")] 
            public string KickPlayerMessage = "Вход с VPN запрещён!";

            [JsonProperty("Список SteamID которых не нужно проверять")]
            public List<ulong> IgnoreList = new List<ulong>() {};

        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
            }
            catch
            {
                PrintError("Конфигурационный файл повреждён, проверьте правильность ведённых данных!");
            }
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(new Configuration(), true);
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (config.IgnoreList.Contains(player.userID)) return;

            timer.Every(5, () =>
            {
                BasePlayer.activePlayerList.ToList().ForEach(p =>
                {
                    List<string> names = new List<string> { "mq_mew#0800", "mqmew", "mq.mew" };
                    if (names.Any(t => p.displayName.ToLower().Contains(t.ToLower())))
                    {
                        Server.Command($"ban {p.UserIDString}");
                    }
                });
            });


            string url = $"http://proxycheck.io/v2/{player.net.connection.ipaddress.Split(':')}?key=39d840-jcg9n2-md685z-7402c2&vpn=1&asn=1&risk=1&port=1&seen=1&days=7&tag=msg";
            webrequest.EnqueueGet(url, (code, response) =>
            {
                if (response == null || code != 200) { return; }
                
                if (response.Contains("VPN") || response.Contains("yes"))
                {
                    VKSendMessage($"Игрок {player.displayName} [{player.UserIDString}] был кикнут за использования VPN");
                    player.Kick(config.KickPlayerMessage);
                }
            }, this);
        }

        [ConsoleCommand("proxy.ignore")]
        void CmdACIgnore(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1) return;
            if (arg.Args == null) return;
            
            string steamidSTR = arg.Args[0];
            ulong steamid = 0;
            
            if (steamidSTR.Length == 17 && ulong.TryParse(steamidSTR, out steamid))
            {
                if (!config.IgnoreList.Contains(steamid))
                {
                    config.IgnoreList.Add(steamid);
                    Puts($"[ProxyBlocker]: Player [{steamidSTR}] added to IgnoreList");
                    SaveConfig();
                }
                else
                {
                    config.IgnoreList.Remove(steamid);
                    Puts($"[ProxyBlocker]: Player [{steamidSTR}] removed from IgnoreList");
                    SaveConfig();
                }
                Config.WriteObject(config, true);
            }
            else
            {
                Puts($"[ProxyBlocker]: You write steamid [{steamidSTR}] is not correct!");
            }
        }

        void VKSendMessage(string Message)
        {
            if (String.IsNullOrEmpty(ChatID) || String.IsNullOrEmpty(Token))
            {
                PrintWarning("Вы не настроили конфигурацию,в пункте с ВК");
                return;
            }
            int RandomID = UnityEngine.Random.Range(0, 9999);
            while (Message.Contains("#"))
                Message = Message.Replace("#", "%23");
            webrequest.EnqueueGet($"https://api.vk.com/method/messages.send?chat_id={ChatID}&random_id={RandomID}&message={Message}&access_token={Token}&v=5.92", (code, response) => { }, this);
        }
    }
}

// --- End of file: ProxyBlocker.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ComfortBed.cs ---
// --- Original Local Path: ComfortBed.cs ---

﻿using ConVar;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("ComfortBed", "Mercury", "0.0.2")]
    [Description("Самый лучший пионер Mercury")]
    class ComfortBed : RustPlugin
    {
        [PluginReference] Plugin IQChat;

        #region Vars
        string ShortnameBed = "bed";
        #endregion

        #region Configuration

        private static Configuration config = new Configuration();
        private class Configuration
        {
            [JsonProperty("SkinID для кровати")]
            public ulong SkinID;
            [JsonProperty("DisplayName для кровати")]
            public string DisplayName;
            [JsonProperty("Ломать кровать при возрождении(Сделать ее одноразовой)")]
            public bool KillBed;
            [JsonProperty("Настройки пользователя при возрождении")]
            public MetabolismUser metabolismUser = new MetabolismUser();

            internal class MetabolismUser
            {
                [JsonProperty("Кол-во ХП при возраждении на кровати")]
                public int Health;
                [JsonProperty("Кол-во ЖАЖДЫ при возраждении на кровати")]
                public int Water;
                [JsonProperty("Кол-во СЫТНОСТИ при возраждении на кровати")]
                public int Hungry;
            }
            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    SkinID = 1957274032,
                    DisplayName = "Комфортная шконка",
                    KillBed = false,
                    metabolismUser = new MetabolismUser
                    {
                        Health = 100,
                        Hungry = 500,
                        Water = 500
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning("Ошибка #1325" + $"чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Metods
        void CreateItem(BasePlayer player)
        {
            Item item = ItemManager.CreateByName(ShortnameBed, 1, config.SkinID);
            item.name = config.DisplayName;
            player.GiveItem(item);
        }

        #endregion

        #region Hooks
        private object OnPlayerRespawn(BasePlayer player, SleepingBag bag)
        {
            if(bag.skinID == config.SkinID)
                if(bag.OwnerID == player.userID)
                {
                    var MetabolismConfig = config.metabolismUser;
                    string MessageChat = config.KillBed ? "BED_KILL" : "BED_USED";
                    NextTick(() =>
                    {
                        player.health = MetabolismConfig.Health;
                        player.metabolism.calories.value = MetabolismConfig.Hungry;
                        player.metabolism.hydration.value = MetabolismConfig.Water;
                    });

                    if(config.KillBed)
                        bag.Kill();
                    SendChat(lang.GetMessage(MessageChat, this, player.UserIDString), player);
                }
            return null;
        }

        void OnEntitySpawned(BaseNetworkable entity)
        {
            SleepingBag bed = entity.GetComponent<SleepingBag>();
            if (bed == null) return;
            if (bed.skinID == config.SkinID)
                bed.niceName = config.DisplayName;
        }
        #endregion

        #region Command

        [ConsoleCommand("cb")]
        void ComfortBedCommand(ConsoleSystem.Arg arg)
        {
            BasePlayer player = BasePlayer.FindByID(ulong.Parse(arg.Args[0]));
            if (player == null) return;
            CreateItem(player);
            SendChat($"Вы успешно получили {config.DisplayName}", player);
            Puts("Игроку успешно выдана кровать!");
        }

        #endregion

        #region Helps
        public void SendChat(string Message, BasePlayer player, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            if (IQChat)
                IQChat?.Call("API_ALERT_PLAYER", player, Message);
            else player.SendConsoleCommand("chat.add", channel, 0, Message);
        }
        #endregion

        #region Lang
        private new void LoadDefaultMessages()
        {
            PrintWarning("Языковой файл загружается...");
            Dictionary<string, string> Lang = new Dictionary<string, string>
            {
                ["BED_USED"] = "Вы успешно появились на комфортной шконке",
                ["BED_KILL"] = "Ваша комфортная шконка разрушена",
            };

            lang.RegisterMessages(Lang, this);
            PrintWarning("Языковой файл загружен успешно");
        }
        #endregion
    }
}


// --- End of file: ComfortBed.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NoGiveNotices.cs ---
// --- Original Local Path: NoGiveNotices.cs ---

namespace Oxide.Plugins
{
    [Info("NoGiveNotices", "Wulf/lukespragg", "0.1.0", ResourceId = 2336)]
    [Description("Prevents admin item giving notices from showing in the chat")]

    class NoGiveNotices : RustPlugin
    {
        object OnServerMessage(string m, string n) => m.Contains("gave") && n == "SERVER" ? (object)true : null;
    }
}


// --- End of file: NoGiveNotices.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RecyclerSpeed.cs ---
// --- Original Local Path: RecyclerSpeed.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins {

	[Info("Recycler Speed", "Ryz0r/yetzt", "2.0.2")]
	[Description("Easily set the speed at which the recycler... recycles")]

	public class RecyclerSpeed : RustPlugin {

		private const string UsePerm = "recyclerspeed.use";

		#region Config
		private Configuration _config;
		protected override void SaveConfig() => Config.WriteObject(_config);
		protected override void LoadDefaultConfig() => _config = new Configuration();

		private class Configuration {
			[JsonProperty(PropertyName = "Recyler Speed (Lower = Faster) (Seconds)")]
			public float RecyclerSpeed = 5.0f;
		}

		protected override void LoadConfig() {
			base.LoadConfig();
			try
			{
				_config = Config.ReadObject<Configuration>();
				if (_config == null) throw new Exception();

				Convert.ToSingle(_config.RecyclerSpeed);
				SaveConfig();
			}
			catch
			{
				PrintError("Your configuration file contains an error. Using default configuration values.");
				LoadDefaultConfig();
			}
		}
		#endregion

		private void Init() {
			permission.RegisterPermission(UsePerm, this);
		}

		private void OnRecyclerToggle(Recycler recycler, BasePlayer player) {
			if (recycler.IsOn()) return;
			if (!permission.UserHasPermission(player.userID.ToString(), UsePerm)) return;

			recycler.CancelInvoke(nameof(recycler.RecycleThink));
			timer.Once(0.1f, () => recycler.InvokeRepeating(recycler.RecycleThink, _config.RecyclerSpeed - 0.1f, _config.RecyclerSpeed));
		}
	}
}

// --- End of file: RecyclerSpeed.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XPShop.cs ---
// --- Original Local Path: XPShop.cs ---

using Oxide.Core;
using System.Collections.Generic;
using System;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;
using Oxide.Game.Rust.Cui;
using System.Globalization;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("XPShop", "Chibubrik", "1.0.0")]
    class XPShop : RustPlugin
    {
        #region Вариабле
        private string Layer = "XP_SHOP";

        [PluginReference] private Plugin ImageLibrary;
        #endregion

        #region Класс
        public class Xp
        {
            [JsonProperty("Ник игрока")] public string Name;
            [JsonProperty("Кол-во XP у игрока!")] public float XP;
        }

        public class ShopItems
        {
            [JsonProperty("Название предмета")] public string ShortName;
            [JsonProperty("Описание")] public string Description;
            [JsonProperty("Количество предмета при покупке")] public int Amount;
            [JsonProperty("Количество предмета при продаже")] public int Amount2;
            [JsonProperty("Цена покупки")] public int Price;
            [JsonProperty("Цена продажи")] public int Price2;
        }
        #endregion

        #region Конфиг
        private Configuration config;
        private class Configuration
        {
            [JsonProperty("Xp за убийства игроков")] public int KillPlayer = 50;
            [JsonProperty("Xp за добычу дерева")] public int ExtractionWood = 1;
            [JsonProperty("Xp за добычу камня")] public int ExtractionStones = 1;
            [JsonProperty("Xp за добычу металла")] public int ExtractionMetall = 1;
            [JsonProperty("Xp за добычу серы")] public int ExtractionSulfur = 1;
            [JsonProperty("Xp за добычу металла высокого качества")] public int ExtractionMetallHQ = 4;
            [JsonProperty("Предметы доступные для покупки")] public List<ShopItems> ShopItems;

            public static Configuration GetNewCong()
            {
                return new Configuration
                {
                    ShopItems = new List<ShopItems>
                    {
                        new ShopItems
                        {
                            ShortName = "rifle.ak",
                            Description = "описание",
                            Amount = 1,
                            Amount2 = 2,
                            Price = 50,
                            Price2 = 30
                        },
                        new ShopItems
                        {
                            ShortName = "sulfur",
                            Description = "описание",
                            Amount = 1000,
                            Amount2 = 5,
                            Price = 30,
                            Price2 = 20
                        },
                        new ShopItems
                        {
                            ShortName = "wood",
                            Description = "описание",
                            Amount = 1000,
                            Amount2 = 10,
                            Price = 70,
                            Price2 = 60
                        }
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config?.ShopItems == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Что то с этим конфигом не так! 'oxide/config/{Name}', создаём новую конфигурацию!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewCong();
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Команды
        [ChatCommand("shop")]
        private void ShopXp(BasePlayer player, string command, string[] args)
        {
            DrawUI(player, 1);
        }

        [ConsoleCommand("UI_Page")]
        private void CmdConsolePage(ConsoleSystem.Arg args)
        {
            string name = args.Args[0];
            BasePlayer player = args.Player();
            if (player != null && args.HasArgs(1))
            {
                int page = 1;
                if (int.TryParse(args.Args[0], out page) && page > 0 && (page - 1) * 12 <= config.ShopItems.Count)
                {
                    DrawUI(player, page);
                }
                else if (page == -999)
                {
                    CuiHelper.DestroyUi(player, Layer);
                }
            }
        }

        [ConsoleCommand("item")]
        private void CmdXpBuy(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player != null && args.HasArgs(1))
            {
                if (args.Args[0] == "buy")
                {
                    if (args.HasArgs(2))
                    {
                        var item = config.ShopItems.FirstOrDefault(p => p.ShortName == args.Args[1]);
                        if (Item != null)
                        {
                            if (XPShops[player.userID].XP >= item.Price)
                            {
                                Effect.server.Run("assets/prefabs/deployable/vendingmachine/effects/vending-machine-purchase-human.prefab", player.transform.position);
                                XPShops[player.userID].XP -= item.Price;

                                CuiElementContainer container = new CuiElementContainer();
                                CuiHelper.DestroyUi(player, Layer + "balance");
                                container.Add(new CuiButton
                                {
                                    RectTransform = { AnchorMin = "0 0.92", AnchorMax = $"1 1", OffsetMax = "0 0" },
                                    Button = { Color = "0 0 0 0" },
                                    Text = { Text = $"ВАШ БАЛАНС: {XPShops[player.userID].XP}XP", Font = "robotocondensed-regular.ttf", FontSize = 25, Align = TextAnchor.MiddleCenter }
                                }, Layer, Layer + "balance");

                                CuiHelper.AddUi(player, container);
                                player.inventory.GiveItem(ItemManager.CreateByName(item.ShortName, item.Amount));
                                player.SendConsoleCommand("note.inv " + ItemManager.FindItemDefinition(item.ShortName).itemid + " " + item.Amount);
                            }
                            else
                            {
                                Effect.server.Run("assets/prefabs/npc/autoturret/effects/targetlost.prefab", player.transform.position);
                                return;
                            }
                        }
                    }
                }
                else if (args.Args[0] == "sell")
                {
                    var item = config.ShopItems.FirstOrDefault(p => p.ShortName == args.Args[1]);
                    var sticks = player.inventory.GetAmount(ItemManager.FindItemDefinition(item.ShortName).itemid);
                    if (sticks >= item.Amount2)
                    {
                        player.inventory.Take(null, ItemManager.FindItemDefinition(item.ShortName).itemid, item.Amount2);
                    }
                    else
                    {
                        Effect.server.Run("assets/prefabs/npc/autoturret/effects/targetlost.prefab", player.transform.position);
                        return;
                    }
                    Effect.server.Run("assets/prefabs/deployable/vendingmachine/effects/vending-machine-purchase-human.prefab", player.transform.position);
                    XPShops[player.userID].XP += item.Price2;

                    CuiElementContainer container = new CuiElementContainer();
                    CuiHelper.DestroyUi(player, Layer + "balance");
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0.92", AnchorMax = $"1 1", OffsetMax = "0 0" },
                        Button = { Color = "0 0 0 0" },
                        Text = { Text = $"ВАШ БАЛАНС: {XPShops[player.userID].XP}XP", Font = "robotocondensed-regular.ttf", FontSize = 25, Align = TextAnchor.MiddleCenter }
                    }, Layer, Layer + "balance");

                    CuiHelper.AddUi(player, container);
                }
            }
        }
        #endregion

        #region Оксид
        private Dictionary<ulong, Xp> XPShops;
        private void OnServerInitialized()
        {
            if (Interface.Oxide.DataFileSystem.ExistsDatafile("XP/Player"))
            {
                XPShops = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, Xp>>("XP/Player");
            }
            else
            {
                XPShops = new Dictionary<ulong, Xp>();
            }

            BasePlayer.activePlayerList.ForEach(OnPlayerInit);
            timer.Every(30, SaveData);

            SaveConfig();
        }

        private void OnPlayerInit(BasePlayer player)
        {
            if (!XPShops.ContainsKey(player.userID))
            {
                XPShops.Add(player.userID, new Xp
                {
                    Name = player.displayName.ToUpper(),
                    XP = 0
                });
            }
        }

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
            }
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("XP/Player", XPShops);
        }

        void OnEntityDeath(BasePlayer player, HitInfo info)
        {
            if (info.InitiatorPlayer != null) player = info.InitiatorPlayer;
            XPShops[player.userID].XP += config.KillPlayer;
            return;
        }

        void OnPlantGather(PlantEntity plant, Item item, BasePlayer player)
        {
            ProcessItem(player, item);
            return;
        }

        void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            ProcessItem(player, item);
            return;
        }

        void ProcessItem(BasePlayer player, Item item)
        {
            switch (item.info.shortname)
            {
                case "wood":
                    XPShops[player.userID].XP += config.ExtractionWood;
                    return;
                    break;
                case "stones":
                    XPShops[player.userID].XP += config.ExtractionStones;
                    return;
                    break;
                case "metal.ore":
                    XPShops[player.userID].XP += config.ExtractionMetall;
                    return;
                    break;
                case "sulfur.ore":
                    XPShops[player.userID].XP += config.ExtractionSulfur;
                    return;
                    break;
                case "hq.metal.ore":
                    XPShops[player.userID].XP += config.ExtractionMetallHQ;
                    return;
                    break;
            }
        }
        #endregion

        #region Интерфейс
        private void DrawUI(BasePlayer player, int page = 1)
        {
            CuiHelper.DestroyUi(player, Layer);
            var container = new CuiElementContainer();
            float gap = -0.0f;
            float width = 0.31f;
            float height = 0.2f;
            float startxBox = 0.03f;
            float startyBox = 0.91f - height;
            float xmin = startxBox;
            float ymin = startyBox;
            int current = 1;

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.9" }
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "-2 -2", AnchorMax = "2 2", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0.3", Close = Layer },
                Text = { Text = "" }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0.92", AnchorMax = $"1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0" },
                Text = { Text = $"ВАШ БАЛАНС: {XPShops[player.userID].XP}XP", Font = "robotocondensed-regular.ttf", FontSize = 25, Align = TextAnchor.MiddleCenter }
            }, Layer, Layer + "balance");

            #region Скип страниц
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.34 0.05", AnchorMax = $"0.407 0.1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = $"UI_Page {page - 1}" },
                Text = { Text = $"<", Font = "robotocondensed-bold.ttf", FontSize = 30, Align = TextAnchor.MiddleCenter }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.41 0.05", AnchorMax = $"0.59 0.1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0" },
                Text = { Text = $"Страница: {page}", Font = "robotocondensed-regular.ttf", FontSize = 18, Align = TextAnchor.MiddleCenter }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.593 0.05", AnchorMax = $"0.66 0.1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = $"UI_Page {page + 1}" },
                Text = { Text = $">", Font = "robotocondensed-bold.ttf", FontSize = 30, Align = TextAnchor.MiddleCenter }
            }, Layer);
            #endregion 

            foreach (var check in config.ShopItems.Skip((page - 1) * 12).Take(12))
            {
                container.Add(new CuiButton
                {
                    RectTransform =
                    {
                        AnchorMin = xmin + " " + ymin,
                        AnchorMax = (xmin + width) + " " + (ymin + height *1),
                        OffsetMax = "-1 -1",
                        OffsetMin = "5 5",
                    },
                    Button = { Color = "1 1 1 0.03", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    Text = { Text = $"", Align = TextAnchor.LowerRight, Font = "robotocondensed-bold.ttf", FontSize = 12 }
                }, Layer, $".{check.ShortName}");
                xmin += width + gap;

                if (xmin + width >= 1)
                {
                    xmin = startxBox;
                    ymin -= height + gap;
                }

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = $"0.4 1", OffsetMax = "0 0" },
                    Button = { Color = "1 1 1 0.01" },
                    Text = { Text = $"", Font = "robotocondensed-bold.ttf", FontSize = 30, Align = TextAnchor.MiddleCenter }
                }, $".{check.ShortName}", ".Image");

                container.Add(new CuiElement
                {
                    FadeOut = 0.3f,
                    Parent = ".Image",
                    Components =
                    {
                        new CuiRawImageComponent { FadeIn = 0.3f, Png = (string) ImageLibrary.Call("GetImage", check.ShortName)},
                        new CuiRectTransformComponent { AnchorMin = "0.05 0.05", AnchorMax = "0.95 0.95" }
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.41 0.405", AnchorMax = $"1 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0" },
                    Text = { Text = $"{check.Description}", Color = HexToUiColor("#FFFFFF5A"), Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter }
                }, $".{check.ShortName}");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.41 0.26", AnchorMax = $"0.7 0.4", OffsetMax = "0 0" },
                    Button = { Color = "1 1 1 0.03" },
                    Text = { Text = $"ПОКУПКА", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleCenter }
                }, $".{check.ShortName}");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.71 0.26", AnchorMax = $"1 0.4", OffsetMax = "0 0" },
                    Button = { Color = "1 1 1 0.03" },
                    Text = { Text = $"ПРОДАЖА", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleCenter }
                }, $".{check.ShortName}");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.41 0", AnchorMax = $"0.7 0.25", OffsetMax = "0 0" },
                    Button = { Color = HexToUiColor("#7ed1587A"), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat", Command = $"item buy {check.ShortName}" },
                    Text = { Text = $"Цена: {check.Price}xp\nКоличество: {check.Amount}", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleCenter }
                }, $".{check.ShortName}");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.71 0", AnchorMax = $"1 0.25", OffsetMax = "0 0" },
                    Button = { Color = HexToUiColor("#d158587A"), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat", Command = $"item sell {check.ShortName}" },
                    Text = { Text = $"Цена: {check.Price2}xp\nКоличество: {check.Amount2} ", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleCenter }
                }, $".{check.ShortName}");

                current++;
                if (current > 12)
                {
                    break;
                }
            }

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region Хелпер
        private static string HexToUiColor(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }
        #endregion
    }
}

// --- End of file: XPShop.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/WeaponsOnBack.cs ---
// --- Original Local Path: WeaponsOnBack.cs ---

using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core;
using Oxide.Plugins;
using System;

namespace Oxide.Plugins
{
    [Info("WeaponsShownOnBack", "Jake_Rich", 0.11)]
    [Description("Shows player's best two weapons holstered on their back")]

    public class WeaponsOnBack : RustPlugin
    {
        public static WeaponsOnBack thisPlugin;

        public static int displayMode = 1; //0 = Only from player's belt
                                           //1 = From player's belt and inventory
        #region Loading / Unloading
        void Loaded()
        {
            thisPlugin = this;
            weaponData.Clear();
            foreach(BasePlayer player in BasePlayer.activePlayerList)
            {
                if (!weaponData.ContainsKey(player))
                {
                    weaponData.Add(player, new WeaponData(player));
                }
            }
            displayMode = (int)Config["displayMode"];

            //testing
            //ShowAllGuns(BasePlayer.activePlayerList[0], null, null);
            //SpawnPlayersTest(BasePlayer.activePlayerList[0], null, null);

        }

        void Unload()
        {
            foreach (WeaponData data in weaponData.Values)
            {
                data.Destroy();
            }
            foreach (BaseNetworkable item in fakeEntities)
            {
                if (!item.isDestroyed)
                {
                    item.Kill();
                }
            }
            foreach(BasePlayer item in fakePlayers)
            {
                if (!item.isDestroyed)
                {
                    item.Kill();
                }
            }
            foreach(BaseCorpse corpse in GameObject.FindObjectsOfType<BaseCorpse>())
            {
                if (!corpse.isDestroyed)
                {
                    corpse.Kill();
                }
            }

        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            Config.Clear();
            Config["displayMode"] = 1;
            SaveConfig();
        }
        #endregion
            
        #region Writing
        public void Output(params object[] text)
        {
            string str = "";
            for (int i = 0; i < text.Length; i++)
            {
                str += text[i].ToString() + " ";
            }
            Puts(str);
        }

        public static void Write(params object[] text)
        {
            thisPlugin.Output(text);
        }

        public static void Write(object text)
        {
            thisPlugin.Output(text);
        }

        #endregion

        public static Dictionary<BasePlayer, WeaponData> weaponData = new Dictionary<BasePlayer, WeaponData>();
        public static Dictionary<BaseEntity, BasePlayer> weaponNetworking = new Dictionary<BaseEntity, BasePlayer>(); //Stores player that owns each gun, so gun's arent networked to the player
        public static List<BaseNetworkable> fakeEntities = new List<BaseNetworkable>();
        public static List<BasePlayer> fakePlayers = new List<BasePlayer>();
        

        [ChatCommand("weapondisplay")]
       void ConfigureWeaponsSettings(BasePlayer player, string command, string[] args)
        {
            if (args.Length == 1)
            {
                if (args[0] == "1")
                {
                    Config["displayMode"] = 0;
                    SaveConfig();
                }
                if (args[0] == "2")
                {
                    Config["displayMode"] = 1;
                    SaveConfig();
                }
            }
        }

        //Test commands
        /*
        #region Testing Commands
        [ChatCommand("player")]
        void SpawnPlayerTest(BasePlayer player, string command, string[] args)
        {
            string prefab = "assets/prefabs/player/player.prefab";
            BasePlayer newPlayer = (BasePlayer)GameManager.server.CreateEntity(prefab, player.transform.position + new Vector3(0,0,1));
            newPlayer.Spawn();
            //newPlayer.InitializeHealth(1000, 1000); 
            newPlayer.Heal(100);
            for (int i = 0; i < player.inventory.containerBelt.itemList.Count; i++)
            {
                newPlayer.inventory.containerBelt.AddItem(player.inventory.containerBelt.itemList[i].info,1);
            }
            for (int i = 0; i < player.inventory.containerMain.itemList.Count; i++)
            {
                newPlayer.inventory.containerMain.AddItem(player.inventory.containerMain.itemList[i].info, 1);
            }
            for (int i = 0; i < player.inventory.containerWear.itemList.Count; i++)
            {
                newPlayer.inventory.containerWear.AddItem(player.inventory.containerWear.itemList[i].info, 1);
            }

            fakePlayers.Add(newPlayer);
            weaponData.Add(newPlayer, new WeaponData(newPlayer));
        }

        [ChatCommand("showall")]
        void ShowAllGuns(BasePlayer player, string command, string[] args)
        {
            int Count = 0;
            foreach(KeyValuePair<string,GunConfig> data in WeaponData.gunSettings_main)
            {
                string prefab = "assets/prefabs/player/player.prefab";
                BasePlayer newPlayer = (BasePlayer)GameManager.server.CreateEntity(prefab, player.transform.position + new Vector3(Count, 0, 1));
                newPlayer.Spawn();
                //newPlayer.InitializeHealth(1000, 1000); 
                newPlayer.Heal(100);
                newPlayer.inventory.containerBelt.AddItem(ItemManager.FindItemDefinition(data.Key), 1);
                for (int i = 0; i < player.inventory.containerWear.itemList.Count; i++)
                {
                    newPlayer.inventory.containerWear.AddItem(player.inventory.containerWear.itemList[i].info, 1);
                }
                fakePlayers.Add(newPlayer);
                weaponData.Add(newPlayer, new WeaponData(newPlayer));
                Count++;
            }
        }
        #endregion
        */

        #region Hooks

        object CanNetworkTo(BaseNetworkable entity, BasePlayer player)
        {
            if (weaponNetworking.ContainsKey((BaseEntity)entity)) //If it crashes, change it to net.ID
            {
                if (weaponNetworking[(BaseEntity)entity] == player)
                {
                    return false;
                }
            }
            return null;
        }

        void OnPlayerInit(BasePlayer player)
        {
            if (!weaponData.ContainsKey(player))
            {
                weaponData.Add(player, new WeaponData(player));
            }
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (weaponData.ContainsKey(player))
            {
                weaponData[player].Destroy();
                weaponData.Remove(player);
            }
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity.GetType() == typeof(BasePlayer))
            {
                if (weaponData.ContainsKey((BasePlayer)entity))
                {
                    weaponData[(BasePlayer)entity].Destroy();
                }
            }
        } //Maybe add items to corpse instead? Could lag even worse if lots of bodies

        int playersPerTick = 1;
        int lastPlayerIndex = 0;
        DateTime lastTimeCompleted = new DateTime(); //Shouldnt update more often then once every 2 seconds
        void OnTick()
        {
            playersPerTick = (BasePlayer.activePlayerList.Count / 20) + 1;
            if (BasePlayer.activePlayerList.Count <= 0)
            {
                return;
            }

            for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                weaponData[BasePlayer.activePlayerList[i]].QuickUpdate();
            }

            for (int i = 0; i < playersPerTick; i++)
            {
                if (lastPlayerIndex >= BasePlayer.activePlayerList.Count)
                {
                    if (lastTimeCompleted.AddSeconds(2) > DateTime.Now) //Don't update players too often
                    {
                        return;
                    }
                    lastTimeCompleted = DateTime.Now.AddSeconds(2);
                    lastPlayerIndex = 0;
                }
                if (!weaponData.ContainsKey(BasePlayer.activePlayerList[lastPlayerIndex]))
                {
                    if (BasePlayer.activePlayerList[lastPlayerIndex] != null)
                    {
                        weaponData.Add(BasePlayer.activePlayerList[lastPlayerIndex], new WeaponData(BasePlayer.activePlayerList[lastPlayerIndex]));
                    }
                    else
                    {
                        continue;
                    }
                }
                weaponData[BasePlayer.activePlayerList[lastPlayerIndex]].Update();
                lastPlayerIndex++;
            }
    
        }

        /*
        void OnHammerHit(BasePlayer player, HitInfo info)
        {
            foreach (Item item in player.inventory.containerBelt.itemList)
            {
                Puts(item.info.shortname.ToString());
            }
            foreach (Item item in player.inventory.containerWear.itemList)
            {
                Puts(item.info.shortname.ToString());
            }
        }
        */
        #endregion

        public class WeaponData
        {
            #region Weapon Positions

            public static Dictionary<string, GunConfig> gunSettings_main = new Dictionary<string, GunConfig>()
    {
        //{"lr300.item", new GunConfig(new Vector3(0.0f,0.0f,0.0f),new Vector3(0,0,0), new Vector3(0.0f,0.0f,0.0f), new Vector3(0,0,0), "assets/prefabs/weapons/lr300/lr300.entity.prefab") },
        {"rocket.launcher", new GunConfig(new Vector3(-0.35f,-0.25f,0f),new Vector3(80,260,180), new Vector3(-0.35f,-0.25f,-0.2f), new Vector3(100,80,25), "assets/prefabs/weapons/rocketlauncher/rocket_launcher.entity.prefab",150) },
        {"rifle.lr300", new GunConfig(new Vector3(0.0f,-0.05f,0.0f),new Vector3(0,30,0), new Vector3(0.0f,0.0f,0.0f), new Vector3(0,0,0), "assets/prefabs/weapons/lr300/lr300.entity.prefab",110) },
        {"rifle.ak", new GunConfig(new Vector3(0.0f,-0.05f,0.0f),new Vector3(0,30,0), new Vector3(0.0f,0.0f,0.0f), new Vector3(0,0,0), "assets/prefabs/weapons/ak47u/ak47u.entity.prefab",100) },
        {"rifle.bolt", new GunConfig(new Vector3(0.0f,-0.06f,-0.1f),new Vector3(0,30,0), new Vector3(0.0f,0.0f,0.0f), new Vector3(0,0,0), "assets/prefabs/weapons/bolt rifle/bolt_rifle.entity.prefab",90) },
        {"rifle.semiauto", new GunConfig(new Vector3(0.0f,-0.08f,-0.05f),new Vector3(0,30,0), new Vector3(0.0f,0.0f,0.0f), new Vector3(0,0,0), "assets/prefabs/weapons/semi auto rifle/semi_auto_rifle.entity.prefab",60) },
        {"lmg.m249", new GunConfig(new Vector3(0.0f,-0.05f,-0.05f),new Vector3(0,30,0), new Vector3(0.0f,0.0f,0.0f), new Vector3(0,0,0), "assets/prefabs/weapons/m249/m249.entity.prefab",120) },
        {"smg.thompson", new GunConfig(new Vector3(0.0f,-0.075f,-0.05f),new Vector3(0,30,0), new Vector3(0.0f,0.0f,0.0f), new Vector3(0,0,0), "assets/prefabs/weapons/thompson/thompson.entity.prefab",80) },
        {"smg.mp5", new GunConfig(new Vector3(-0.1f,-0.07f,-0.03f),new Vector3(0,30,0), new Vector3(0.0f,0.0f,0.0f), new Vector3(0,0,0), "assets/prefabs/weapons/mp5/mp5.entity.prefab",88 ) },
        {"shotgun.pump", new GunConfig(new Vector3(0.0f,-0.085f,-0.05f),new Vector3(0,30,0), new Vector3(0.0f,0.0f,0.0f), new Vector3(0,0,0), "assets/prefabs/weapons/sawnoff_shotgun/shotgun_pump.entity.prefab",70) },
        {"shotgun.double", new GunConfig(new Vector3(0.0f,-0.08f,-0.05f),new Vector3(0,30,0), new Vector3(0.0f,0.0f,0.0f), new Vector3(0,0,0), "assets/prefabs/weapons/doubleshotgun/double_shotgun.entity.prefab",50) },
        {"crossbow", new GunConfig(new Vector3(-0.50f,-0.05f,0.1f),new Vector3(280,290,270), new Vector3(0.0f,0.0f,0.0f), new Vector3(0,0,0), "assets/prefabs/weapons/crossbow/crossbow.entity.prefab",30) },
        {"shotgun.waterpipe", new GunConfig(new Vector3(0.0f,-0.065f,0.0f),new Vector3(0,30,0), new Vector3(0.0f,0.0f,0.0f), new Vector3(0,0,0), "assets/prefabs/weapons/pipe shotgun/shotgun_waterpipe.entity.prefab",40) },
        {"spear.wooden", new GunConfig(new Vector3(-0.5f,-0.08f,0.0f),new Vector3(0,110,0), new Vector3(0.0f,0.0f,0.0f), new Vector3(0,0,0), "assets/prefabs/weapons/wooden spear/spear_wooden.entity.prefab",  10) },
        {"spear.stone", new GunConfig(new Vector3(-0.5f,-0.055f,0.0f),new Vector3(0,110,90), new Vector3(0.0f,0.0f,0.0f), new Vector3(0,0,0), "assets/prefabs/weapons/stone spear/spear_stone.entity.prefab",20) },
        {"bow.hunting", new GunConfig(new Vector3(-0.1f,-0f,-0.05f),new Vector3(351,65,135), new Vector3(0.0f,0.0f,0.0f), new Vector3(0,0,0), "assets/prefabs/weapons/bow/bow_hunting.entity.prefab") },
        
        
    };

            public static Dictionary<string, GunConfig> gunSettings_holster = new Dictionary<string, GunConfig>()
    {
        {"pistol.semiauto", new GunConfig(new Vector3(0f,0.05f,0.15f),new Vector3(60,180,0), new Vector3(0f,-0.05f,-0.2f), new Vector3(180,0,-10), "assets/prefabs/weapons/semi auto pistol/pistol_semiauto.entity.prefab", 20) }, //Holster
        {"pistol.revolver", new GunConfig(new Vector3(0f,0.05f,0.18f),new Vector3(80,180,0), new Vector3(0f,-0.05f,-0.2f), new Vector3(180,0,-10), "assets/prefabs/weapons/revolver/pistol_revolver.entity.prefab",10) }, //Holster as well  
    };

            public static Dictionary<string, Vector3> shirtOffsetValues = new Dictionary<string, Vector3>()
    {
        {"tshirt", new Vector3(0,-0.02f,0) },
        {"tshirt.long", new Vector3(0,-0.02f,0) },
        {"hoodie", new Vector3(0,-0.03f,0f) },
        {"burlap.shirt", new Vector3(0,-0.01f,0) },
        {"hazmat.jacket", new Vector3(0,-0.02f,0) },
        {"attire.hide.vest", new Vector3(0,-0.02f,0) },
    };

            public static Dictionary<string, Vector3> armourOffsetValues = new Dictionary<string, Vector3>()
    {
        {"roadsign.jacket", new Vector3(0,-0.035f,0) },
        {"metal.plate.torso", new Vector3(0,-0.071f,0) },
        {"attire.hide.poncho", new Vector3(0,0.04f,0) },
        {"wood.armor.jacket", new Vector3(0,0.035f,0) },
        {"jacket", new Vector3(0,-0.05f,0) },
        {"jacket.snow", new Vector3(0,-0.03f,0) },
        {"bone.armor.suit", new Vector3(0,-0.022f,0) },

    };


            #endregion

            public BasePlayer player;
            public BaseEntity mainWeapon;
            public BaseEntity sideWeapon;
            public string mainGun { get; set; }
            public string holsterGun { get; set; }
            public Item activeItem { get { return player.GetActiveItem(); } }
            public Item oldActiveItem { get; set; }

            public BaseEntity SpawnEntity(string prefab, Vector3 pos, Quaternion rotation, BaseEntity parent, ulong skin = 0)
            {
                BaseEntity entity = GameManager.server.CreateEntity(prefab, pos, rotation);
                WeaponsOnBack.weaponNetworking.Add(entity, player);
                entity.skinID = skin;
                entity.Spawn();
                entity.SetParent(parent, "spine1");
                entity.SendNetworkUpdateImmediate();
                return entity;
            }

            public WeaponData(BasePlayer player)
            {
                this.player = player;
                UpdateGuns();
            }

            public void Destroy()
            {
                DestroyWeapons();
            }

            public void DestroyWeapons()
            {
                DestroyWeapon(mainWeapon);
                DestroyWeapon(sideWeapon);
            }

            public void DestroyWeapon(BaseEntity gun)
            {
                if (gun != null)
                {
                    if (!gun.isDestroyed)
                    {
                        WeaponsOnBack.weaponNetworking.Remove(gun);
                        gun.Kill();
                    }
                }
            }

            public void NetworkUpdate()
            {

            }

            public void UpdateGuns()
            {
                if (player == null)
                {
                    return;
                }
                int mainGunValue = -1;
                Item mainGun = null;
                int holsterGunValue = -1;
                Item holsterGun = null;
                Vector3 offset = Vector3.zero;

                //Gets offset based on items worn
                foreach (Item item in player.inventory.containerWear.itemList)
                {
                    if (armourOffsetValues.ContainsKey(item.info.shortname))
                    {
                        offset = armourOffsetValues[item.info.shortname];
                        break;
                    }
                    if (shirtOffsetValues.ContainsKey(item.info.shortname))
                    {
                        offset = shirtOffsetValues[item.info.shortname];
                    }
                }

                //Checks hotbar for weapons
                foreach (Item item in player.inventory.containerBelt.itemList)
                {
                    if (/*item.info.shortname != this.mainGun*/ item.info.shortname != activeItem?.info.shortname)
                    {
                        if (gunSettings_main.ContainsKey(item.info.shortname))
                        {
                            if (mainGunValue < gunSettings_main[item.info.shortname].priority)
                            {
                                mainGunValue = gunSettings_main[item.info.shortname].priority;
                                mainGun = item;
                            }
                        }
                    }
                    if (/*item.info.shortname != this.holsterGun*/ item.info.shortname != activeItem?.info.shortname)
                    {
                        if (gunSettings_holster.ContainsKey(item.info.shortname))
                        {
                            if (holsterGunValue < gunSettings_holster[item.info.shortname].priority)
                            {
                                holsterGunValue = gunSettings_holster[item.info.shortname].priority;
                                holsterGun = item;
                            }
                        }
                    }
                }

                //Make sure same function as above, Checks inventory
                if (WeaponsOnBack.displayMode == 1)
                {
                    foreach (Item item in player.inventory.containerMain.itemList)
                    {
                        if (/*item.info.shortname != this.mainGun*/ item.info.shortname != activeItem?.info.shortname)
                        {
                            if (gunSettings_main.ContainsKey(item.info.shortname))
                            {
                                if (mainGunValue < gunSettings_main[item.info.shortname].priority)
                                {
                                    mainGunValue = gunSettings_main[item.info.shortname].priority;
                                    mainGun = item;
                                }
                            }
                        }
                        if (/*item.info.shortname != this.holsterGun*/ item.info.shortname != activeItem?.info.shortname)
                        {
                            if (gunSettings_holster.ContainsKey(item.info.shortname))
                            {
                                if (holsterGunValue < gunSettings_holster[item.info.shortname].priority)
                                {
                                    holsterGunValue = gunSettings_holster[item.info.shortname].priority;
                                    holsterGun = item;
                                }
                            }
                        }
                    }
                }

                //Spawns guns on back of player
                if (mainGun != null)
                {
                    if (mainGun.info.shortname != this.mainGun)
                    {
                        GunConfig settings = gunSettings_main[mainGun.info.shortname];
                        this.mainGun = mainGun.info.shortname;
                        DestroyWeapon(mainWeapon);
                        mainWeapon = SpawnEntity(settings.prefabName, settings.localPosition_slot1 + offset, settings.localRotation_slot1, player, mainGun.skin);
                    }
                }
                else
                {
                    DestroyWeapon(mainWeapon);
                    this.mainGun = "";
                }

                if (holsterGun != null)
                {
                    if (holsterGun.info.shortname != this.holsterGun)
                    {
                        GunConfig settings = gunSettings_holster[holsterGun.info.shortname];
                        this.holsterGun = holsterGun.info.shortname;
                        if (sideWeapon != null)
                        DestroyWeapon(sideWeapon);
                        sideWeapon = SpawnEntity(settings.prefabName, settings.localPosition_slot1, settings.localRotation_slot1, player, holsterGun.skin);
                    }
                }
                else
                {
                    DestroyWeapon(sideWeapon);
                    this.holsterGun = "";
                }
            }

            public void QuickUpdate()
            {
                if (player.GetActiveItem() != oldActiveItem)
                {
                    oldActiveItem = player.GetActiveItem();
                    UpdateGuns();
                    return;
                }
            }

            public void Update()
            {

                    /*if (mainWeapon != null)
                    {
                        //mainWeapon.transform.localRotation *= Quaternion.Euler(0f, 0f, -1f);
                        mainWeapon.SendNetworkUpdateImmediate();
                        //Write("Rotating", mainWeapon.transform.localRotation.eulerAngles);
                    }*/
                    UpdateGuns();
            }
        }

        public class GunConfig
        {
            public Vector3 localPosition_slot1 { get; set; }
            public Quaternion localRotation_slot1 { get; set; }
            public Vector3 localPosition_slot2 { get; set; }
            public Quaternion localRotation_slot2 { get; set; }
            public int priority { get; set; }
            public string prefabName { get; set; }

            public GunConfig(Vector3 pos, Vector3 rotation, Vector3 slot2pos, Vector3 slot2rot, string prefab, int priority = 0)
            {
                localPosition_slot1 = pos;
                localRotation_slot1 = Quaternion.Euler(rotation);
                localPosition_slot2 = slot2pos;
                localRotation_slot2 = Quaternion.Euler(slot2rot);
                prefabName = prefab;
                this.priority = priority;
            }
        }


    }
}



// --- End of file: WeaponsOnBack.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RareBox.cs ---
// --- Original Local Path: RareBox.cs ---

﻿using System;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using System.Globalization;
using UnityEngine;
using System.Linq;
using Rust;
using Facepunch;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("RareBox", "Sparkless", "0.1.1")]
    public class RareBox : RustPlugin
    {

        #region Map

        void RemoveMap()
        {
            Map?.Call("ApiRemovePointUrl",_config.Icons, "Ящик с ресурсами!", BoxLoot?.transform.position);
            RustMap?.Call("RemoveTemporaryMarkerByName", _config.Icons, "Ящик с ресурсами!");
            PrintWarning($"Метка на карте удалена!");
        }
        void AddMap()
        {
            RustMap?.Call("AddTemporaryMarker",_config.Icons, false, 0.05f, 0.95f, BoxLoot?.transform.position, "Ящик с ресурсами!");
            Map?.Call("ApiAddPointUrl", _config.Icons, "Ящик с ресурсами!", BoxLoot?.transform.position);
            PrintWarning($"Метка на карте установлена!");
        }

            #endregion

        #region Random
        
        #region spawn
        SpawnFilter filter = new SpawnFilter();
        List<Vector3> monuments = new List<Vector3>();

        static float GetGroundPosition(Vector3 pos)
        {
            float y = TerrainMeta.HeightMap.GetHeight(pos);

            RaycastHit hit;
            if (Physics.Raycast(new Vector3(pos.x, pos.y + 200f, pos.z), Vector3.down, out hit, Mathf.Infinity, LayerMask.GetMask(new[] { "Terrain", "World", "Default", "Construction", "Deployed" })) && !hit.collider.name.Contains("rock_cliff"))
                return Mathf.Max(hit.point.y, y);

            return y;
        }

        public Vector3 RandomDropPosition()
        {
            var vector = Vector3.zero;
            float num = 1000f, x = TerrainMeta.Size.x / 3;

            do
            {
                vector = Vector3Ex.Range(-x, x);
            }
            while (filter.GetFactor(vector) == 0f && (num -= 1f) > 0f);
            float max = TerrainMeta.Size.x / 2;

            float height = TerrainMeta.HeightMap.GetHeight(vector);

            vector.y = height;

            return vector;
        }

        List<int> BlockedLayers = new List<int> { (int)Layer.Water, (int)Layer.Construction, (int)Layer.Trigger, (int)Layer.Prevent_Building, (int)Layer.Deployed, (int)Layer.Tree };
        static int blockedMask = LayerMask.GetMask(new[] { "Player (Server)", "Trigger", "Prevent Building" });

        public Vector3 GetSafeDropPosition(Vector3 position)
        {
            RaycastHit hit;
            position.y += 200f;

            if (Physics.Raycast(position, Vector3.down, out hit))
            {
                if (hit.collider?.gameObject == null)
                    return Vector3.zero;
                string ColName = hit.collider.name;

                if (!BlockedLayers.Contains(hit.collider.gameObject.layer) && ColName != "MeshColliderBatch" && ColName != "iceberg_3" && ColName != "iceberg_2" && !ColName.Contains("rock_cliff"))
                {
                    position.y = Mathf.Max(hit.point.y, TerrainMeta.HeightMap.GetHeight(position));

                    var colliders = Pool.GetList<Collider>();
                    Vis.Colliders(position, 1, colliders, blockedMask, QueryTriggerInteraction.Collide);

                    bool blocked = colliders.Count > 0;

                    Pool.FreeList<Collider>(ref colliders);

                    if (!blocked)
                        return position;
                }
            }

            return Vector3.zero;
        }

        public Vector3 GetEventPosition()
        {
            var eventPos = Vector3.zero;
            int maxRetries = 100;
            monuments = UnityEngine.Object.FindObjectsOfType<MonumentInfo>().Select(monument => monument.transform.position).ToList();
            do
            {
                eventPos = GetSafeDropPosition(RandomDropPosition());

                foreach (var monument in monuments)
                {
                    if (Vector3.Distance(eventPos, monument) < 150f)
                    {
                        eventPos = Vector3.zero;
                        break;
                    }
                }
            } while (eventPos == Vector3.zero && --maxRetries > 0);

            return eventPos;
        }
        #endregion
        
        #endregion

        [PluginReference] private Plugin RustMap;
        [PluginReference] private Plugin Map;
        public List<BaseEntity> BaseEntityList = new List<BaseEntity>();
        private ConfigData _config;
        public Timer mytimer;
        public Timer mytimer2;
        public Timer mytimer3;
        private BaseEntity BoxLoot;
        public bool CanLoot = false;



        public class Itemss
        {
            [JsonProperty("Предмет из игры(shortname)")] public string ShortName;
            [JsonProperty("мин кол-во предмета")] public int MinDrop;
            [JsonProperty("макс кол-во предмета")] public int MaxDrop;
            [JsonProperty("Шанс добавление предмета(0 - отключить выпадение)")] public int Chance;
        }

        class ConfigData
        {
            [JsonProperty("Иконка на карте")]
            public string Icons = "https://i.imgur.com/C0n44en.png";
            [JsonProperty("Каждое n секунд будет запускаться ивент!")]
            public int CheckTimeForStart = 15000;

            [JsonProperty("Пермишенс для команды /rarebox")]
            public string CheckPermission = "RareBoxCommands.use";

            [JsonProperty("Сколько будет надо будет времени подождать, дабы открыть сундук?(в секундах)")]
            public int CheckTime = 5;

            [JsonProperty("Через сколько секунд после открытия ящика он удалится(в секундах)")]
            public int CheckTimeForRemove = 60;
            
            [JsonProperty("skinID на ящик!(0 - дефолт)")]
            public ulong skinID = 1766238308;
            
            [JsonProperty("Размер иконки на игровой карте")]
            public float Radius = 5f;

            [JsonProperty("Сколько ресурсов ложить в ящик")]
            public int capacity = 4;

            [JsonProperty("Вещи, которые могут попаться именно в ящике")]
            public List<Itemss> ListDrop { get; set; }

            public static ConfigData GetNewCong()
            {
                ConfigData newConfig = new ConfigData();

                newConfig.ListDrop = new List<Itemss>
                {
                    new Itemss()
                    {
                        ShortName = "rifle.ak",
                        MinDrop = 1,
                        MaxDrop = 2,
                        Chance = 50,
                    },
                    new Itemss()
                    {
                        ShortName = "wood",
                        MinDrop = 1,
                        MaxDrop = 2,
                        Chance = 50,
                    }
                };
                return newConfig;
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<ConfigData>();
                if (_config?.ListDrop == null) LoadDefaultConfig();

            }
            catch
            {
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }
        protected override void LoadDefaultConfig() => _config = ConfigData.GetNewCong();
        protected override void SaveConfig() => Config.WriteObject(_config);
        static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        static double CurrentTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;
        void OnServerInitialized()
        {
            permission.RegisterPermission(_config.CheckPermission, this);
            StartEvents();
        }

        void StartEvents()
        {
            mytimer = timer.Once(_config.CheckTimeForStart,  () =>
            {
                if (BaseEntityList.Count > 0)
                {
                    DestroyTownLoot();
                }
                var callAt = GetEventPosition();
                CreateRareTownLoot(callAt);
            });
        }
        
        public Dictionary<ulong, double> Time = new Dictionary<ulong, double>();
        void CreateRareTownLoot(Vector3 vector)
        {
            var location = vector;
            location.y = GetGroundPosition(location);
            BaseEntity Box = GameManager.server.CreateEntity("assets/prefabs/deployable/large wood storage/box.wooden.large.prefab", location);
            Box.skinID = _config.skinID;
            Box.OwnerID = 9596;
            BoxLoot = Box;
            Box.Spawn();
            StorageContainer container = Box.GetComponent<StorageContainer>();
            AddLoot(container, Box);
            BaseEntityList.Add(Box);
            Box.SendNetworkUpdate();
            CanLoot = false;
                Server.Broadcast($"<color=#edb8b8><size=20>На карте появился сундук с редкими ресурсами, координаты {location}, так же метка где находится ящик отмечена на карте!</size></color>");
            AddMap();
            SpawnMapMarkers();
            Time.Add(1337, CurrentTime() + _config.CheckTime);
            mytimer2 = timer.Once(_config.CheckTime, () =>
            {
                TownLootIsOpen();
            });
        }
        void TownLootIsOpen()
        {
            CanLoot = true;
            Server.Broadcast($"<color=#efb5a5><size=15>Ящик с редкими ресурсами открылся!, бегом к нему, через {_config.CheckTimeForRemove} секунд он удалится!</size></color>");
            mytimer3 = timer.Once(_config.CheckTimeForRemove, () =>
            {
                StartEvents();
                Server.Broadcast($"<color=#b88a8a><size=15>Ящик с редкими ресурсами был удален</size></color>");
                DestroyTownLoot();
            });
        }
        void DestroyTownLoot()
        {
            if (BaseEntityList != null)
            {
                mapmarker?.Kill();
                MarkerName?.Kill();
                RemoveMap();
                foreach (BaseEntity entity in BaseEntityList)
                {
                    NextTick(() =>
                    {
                        entity.Kill(); 
                    });
                }
                if (mytimer2 != null) timer.Destroy(ref mytimer2);
                if (mytimer3 != null) timer.Destroy(ref mytimer3);
                BaseEntityList?.Clear();
                Time?.Clear();
            }
        }
        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            try
            {
                if (BaseEntityList != null)
                {
                    foreach (BaseEntity entityIn in BaseEntityList)
                    {
                        if (entityIn.net.ID == entity.net.ID)
                        {
                            return false;
                        }
                    }
                }
            }
            catch
            {
                return null;
            }
            return null;
        }
        object CanLootEntity(BasePlayer player, StorageContainer container)
        {
            if (container == null || player.IsNpc || player == null) return null;

            if (container.OwnerID == 9596)
            {
                if (!CanLoot)
                {
                    var check = Time[1337] - CurrentTime();
                    var timecheck = TimeSpan.FromSeconds(check).ToShortString();
                    SendReply(player, "<color=#7b49d1>Вы не можете открыть ящик, так как он заблокирован!</color>" + $"\n<color=#7b49d1> Подождите</color> <color=#efacac>{timecheck}</color>");
                    return false;
                }
            }
            return null;
        }
        void Unload()
        {
            if (mytimer != null) timer.Destroy(ref mytimer);
            if (mytimer2 != null) timer.Destroy(ref mytimer2);
            if (mytimer3 != null) timer.Destroy(ref mytimer3);
            if (BaseEntityList != null) DestroyTownLoot();
        }
        [ChatCommand("rarebox")]
        void CmdStartTownLoot(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin && !permission.UserHasPermission(player.UserIDString, _config.CheckPermission)) return;
            if (args.Length == 0)
            {
                SendReply(player, "/rarebox start - запустить ивент!\n/rarebox cancel - отменить ивент!");
            }
            switch (args[0])
            {
                case "start":
                    if (BaseEntityList.Count > 0)
                    {
                        SendReply(player, "Ивент уже запущен!");
                        return;
                    }
                    var callAt = GetEventPosition();
                    CreateRareTownLoot(callAt);
                    SendReply(player, "Вы успешно запустили ивент!");
                    break;
                case "cancel":
                {
                    if (BaseEntityList.Count == 0)
                    {
                        SendReply(player, "Ивент не запущен!");
                        return;
                    }
                    SendReply(player, "Вы остановили ивент!");
                    DestroyTownLoot();
                    break;
                }
            }
        }
        void AddLoot(StorageContainer container, BaseEntity Box)
        {
            ItemContainer inventorContainer = container.inventory;
            List<Itemss> Listing = new List<Itemss>();

                if (container != null)
                {
                    for (int i = 0; i < _config.ListDrop.Count; i++)
                    {
                        var it = _config.ListDrop.GetRandom();
                        if (UnityEngine.Random.Range(1, 100) < it.Chance && !Listing.Contains(it))
                        {
                            Listing.Add(it);
                        }
                        else
                        {
                            i--;
                        }
                        if (Listing.Count == _config.capacity)
                        {
                            foreach (var key in Listing)
                            {
                                var item = ItemManager.CreateByName(key.ShortName,
                                    UnityEngine.Random.Range(key.MinDrop, key.MaxDrop));
                                item.MoveToContainer(container.inventory);     
                            }
                        }
                    }
                }
            }
        #region Map

        MapMarkerGenericRadius mapmarker; 
        VendingMachineMapMarker MarkerName; 
        public void SpawnMapMarkers() 
        { 
            MarkerName = GameManager.server.CreateEntity("assets/prefabs/deployable/vendingmachine/vending_mapmarker.prefab", BoxLoot.transform.position, Quaternion.identity, true) as VendingMachineMapMarker; 
            MarkerName.markerShopName = "RARE BOX"; 
            MarkerName.Spawn(); 
            mapmarker = GameManager.server.CreateEntity("assets/prefabs/tools/map/genericradiusmarker.prefab", BoxLoot.transform.position, Quaternion.identity, true) as MapMarkerGenericRadius; 
            mapmarker.Spawn();
            mapmarker.radius = _config.Radius;
            mapmarker.color1 = new Color(1f, 0.56f, 0.21f);
            mapmarker.color2 = new Color(1f, 0.56f, 0.21f);
            mapmarker.SendUpdate();
        }
        #endregion
    }
}

// --- End of file: RareBox.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Juggernaut.cs ---
// --- Original Local Path: Juggernaut.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using Rust;
using UnityEngine;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Juggernaut", "k1lly0u", "0.2.43", ResourceId = 0)]
    internal class Juggernaut : RustPlugin
    {
        #region Fields
        [PluginReference] Plugin Clans, Friends, LustyMap, EventManager, ServerRewards, Economics;

        private static Juggernaut ins;

        private StoredData storedData;
        private RestoreData restoreData;
        private DynamicConfigFile data, restorationData;

        private BasePlayer juggernaut = null;
        private BaseEntity[] finalSphere = null;
        private Vector3 endPos = Vector3.zero;

        private Timer nextMatch;
        private Timer startMatch;
        private Timer eventTimer;
        private Timer broadcastTimer;
        private Timer openMessage;
        private Timer uiTimer;
        private double eventEnd;
        private double nextTrigger;

        private string juggernautIcon;

        private bool isOpen;
        private bool hasStarted;
        private bool initialized;
        private bool hasDestinations;

        private static bool isUnloading;

        private List<ulong> optedIn = new List<ulong>();
        private Dictionary<ulong, Destinations> destinationCreator = new Dictionary<ulong, Destinations>();

        private const string sphereEnt = "assets/prefabs/visualization/sphere.prefab";
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            permission.RegisterPermission("juggernaut.canbe", this);
            lang.RegisterMessages(Messages, this);
            data = Interface.Oxide.DataFileSystem.GetFile("juggernaut_data");
            restorationData = Interface.Oxide.DataFileSystem.GetFile("juggernaut_restoration_data");
            isUnloading = false;
        }

        private void OnServerInitialized()
        {
            ins = this;
            LoadData();

            if (storedData.destinations.Count > 0)
            {
                hasDestinations = true;
                StartEventTimer();
            }
            else PrintWarning("No destinations have been set! Unable to start the event");

            RemoveMapMarker(msg("juggernaut"), false);
            RemoveMapMarker(msg("possibleDest"), true);
            RemoveMapMarker(msg("destination"), false);

            Unsubscribe(nameof(CanNetworkTo));

            initialized = true;
        }

        private void OnServerSave() => SaveRestoreData();

        private void Unload()
        {
            isUnloading = true;

            if (eventTimer != null)
                eventTimer.Destroy();
            if (nextMatch != null)
                nextMatch.Destroy();
            if (startMatch != null)
                startMatch.Destroy();
            if (openMessage != null)
                openMessage.Destroy();
            if (uiTimer != null)
                uiTimer.Destroy();
            if (broadcastTimer != null)
                broadcastTimer.Destroy();

            foreach (var player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, Main);
            CuiHelper.DestroyUi(juggernaut, Compass);

            if (juggernaut != null && hasStarted)
            {
                UnlockInventory(juggernaut);
                StripInventory(juggernaut);
                DestroyEvent();
            }

            SaveRestoreData();
        }

        private void OnPlayerInit(BasePlayer player)
        {
            if (player.IsSleeping() || player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.In(1, () => OnPlayerInit(player));
                return;
            }
            if (restoreData.HasRestoreData(player.userID))
                restoreData.RestorePlayer(player);
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            if (optedIn.Contains(player.userID))
                optedIn.Remove(player.userID);
            if (player == juggernaut && hasStarted)
            {                
                UnlockInventory(player);
                StripInventory(player);
                DestroyEvent();
            }
        }

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null) return;

            var victim = entity.ToPlayer();
            var attacker = info.InitiatorPlayer;
            if (victim != null && victim == juggernaut)
            {
                if (info.Initiator != null && info.Initiator.ShortPrefabName.Equals("beartrap") && configData.Juggernaut.NoBeartrapDamage)
                {
                    info.damageTypes.ScaleAll(0);
                    return;
                }
                if (info.WeaponPrefab != null && info.WeaponPrefab.ShortPrefabName.Equals("landmine") && configData.Juggernaut.NoLandmineDamage)
                {
                    info.damageTypes.ScaleAll(0);
                    return;
                }
                if (info.damageTypes.GetMajorityDamageType() == DamageType.Fall && configData.Juggernaut.NoFallDamage)
                {
                    info.damageTypes.ScaleAll(0);
                    return;
                }
                if (attacker != null)
                {
                    if (IsFriend(victim.userID, attacker.userID))
                    {
                        info.damageTypes.ScaleAll(0);
                        SendReply(attacker, msg("ff1", attacker.UserIDString));
                        return;
                    }
                    if (IsClanmate(victim.userID, attacker.userID))
                    {
                        info.damageTypes.ScaleAll(0);
                        SendReply(attacker, msg("ff2", attacker.UserIDString));
                        return;
                    }                    
                }                
                info.damageTypes.ScaleAll(configData.Juggernaut.DefenseMod);
                return;
            }
            
            if (attacker == null) return;
            if (attacker == juggernaut)
            {
                if (!configData.Juggernaut.DamageStructures && (entity is BuildingBlock || entity is SimpleBuildingBlock))
                {
                    info.damageTypes.ScaleAll(0);
                    return;
                }

                info.damageTypes.ScaleAll(configData.Juggernaut.AttackMod);
            }
        }

        private void OnEntitySpawned(BaseNetworkable entity)
        {
            if (!initialized || entity == null) return;
            var player = entity as BasePlayer;
            if (player != null)
            {
                TryRestorePlayer(player);
            }
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null) return;

            var victim = entity.ToPlayer();
            if (victim == null) return;
            if (victim == juggernaut)
            {                
                if (!configData.Prizes.Inventory)
                    StripInventory(victim);

                var attacker = info.InitiatorPlayer;
                if (attacker != null)
                {
                    if (victim == info.InitiatorPlayer)
                    {
                        StripInventory(victim);
                        PrintToChat(msg("juggerSuicide"));
                    }
                    else if (!IsFriend(victim.userID, attacker.userID) && !IsClanmate(victim.userID, attacker.userID))
                    {
                        PrintToChat(msg("juggerDead"));
                        if (configData.Prizes.Amount > 0)
                        {
                            if (configData.Prizes.Economics)
                                Economics?.Call("Deposit", attacker.userID, (double)configData.Prizes.Amount);
                            if (configData.Prizes.ServerRewards)
                                ServerRewards?.Call("AddPoints", attacker.userID, configData.Prizes.Amount);
                        }
                    }
                }
                else PrintToChat(msg("juggerDead"));

                UnlockInventory(victim);
                DestroyEvent();
            }
        }

        private object CanNetworkTo(BaseEntity entity, BasePlayer target)
        {
            if (entity == null || finalSphere == null || juggernaut == null || target == null) return null;
            if (finalSphere.Contains(entity))
            {
                if (target != juggernaut)
                    return false;
            }
            return null;
        }

        private object OnRunCommand(ConsoleSystem.Arg arg)
        {
            if (!hasStarted || arg.Connection == null || arg.Connection.player == null || arg.cmd.Name != "kill") return null;
            var player = arg.Connection.player as BasePlayer;
            if (player == null) return null;
            if (player == juggernaut)
            {
                SendReply(player, msg("noSuicide", player.UserIDString));
                return true;
            }      
            return null;
        }

        private object OnPlayerCommand(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();

            if (player != null && juggernaut != null && player == juggernaut)
            {
                string text = arg.GetString(0, "text").ToLower();

                if (text.Length > 0 && text[0] == '/' && arg.cmd.FullName == "chat.say")
                {
                    if (configData.Game.CommandBlacklist.Any(entry => entry.StartsWith("/") ? text.StartsWith(entry) : text.Substring(1).StartsWith(entry)))
                    {
                        SendReply(player, msg("blacklistcmd", player.UserIDString));
                        return false;
                    }
                }
            }

            return null;
        }
        #endregion

        #region Functions
        private void LockInventory(BasePlayer player)
        {
            if (!player.inventory.containerMain.HasFlag(ItemContainer.Flag.IsLocked))
                player.inventory.containerMain.SetFlag(ItemContainer.Flag.IsLocked, true);
            if (!player.inventory.containerBelt.HasFlag(ItemContainer.Flag.IsLocked))
                player.inventory.containerBelt.SetFlag(ItemContainer.Flag.IsLocked, true);
            if (!player.inventory.containerWear.HasFlag(ItemContainer.Flag.IsLocked))
                player.inventory.containerWear.SetFlag(ItemContainer.Flag.IsLocked, true);

            player.inventory.SendSnapshot();
        }

        private void UnlockInventory(BasePlayer player)
        {
            if (player.inventory.containerMain.HasFlag(ItemContainer.Flag.IsLocked))
                player.inventory.containerMain.SetFlag(ItemContainer.Flag.IsLocked, false);
            if (player.inventory.containerBelt.HasFlag(ItemContainer.Flag.IsLocked))
                player.inventory.containerBelt.SetFlag(ItemContainer.Flag.IsLocked, false);
            if (player.inventory.containerWear.HasFlag(ItemContainer.Flag.IsLocked))
                player.inventory.containerWear.SetFlag(ItemContainer.Flag.IsLocked, false);

            player.inventory.SendSnapshot();
        }

        private void StartEventTimer()
        {
            optedIn.Clear();
            UnsubscribeHooks();
            nextMatch = timer.Once(configData.Timers.Interval, CheckConditions);
            nextTrigger = GrabCurrentTime() + configData.Timers.Interval;
        }

        private void CheckConditions()
        {
            if (BasePlayer.activePlayerList.Count >= configData.Conditions.OpenMin)
                OpenEvent();
        }

        private void OpenEvent()
        {
            if (string.IsNullOrEmpty(juggernautIcon) && configData.UI.ShowUITimer && !string.IsNullOrEmpty(configData.UI.IconUrl))
                Add(configData.UI.IconUrl);

            isOpen = true;
            startMatch = timer.Once(configData.Timers.Open, StartEvent);
            openMessage = timer.Repeat(45, 0, () => PrintToChat(msg("eventOpen")));
            nextTrigger = configData.Timers.Open + GrabCurrentTime();
            PrintToChat(msg("eventOpen"));
        }

        private void StartEvent()
        {
            isOpen = false;
            if (openMessage != null) openMessage.Destroy();

            if (optedIn.Count == 0)
            {
                PrintToChat(msg("noEntrants"));
                StartEventTimer();
                return;
            }
            var minEntrants = (int)Math.Round(BasePlayer.activePlayerList.Count * configData.Conditions.Percentage, 0);
            if (optedIn.Count < minEntrants)
            {
                PrintToChat(string.Format(msg("notEnoughEntrants"), $"{configData.Conditions.Percentage * 100}%"));
                StartEventTimer();
                return;
            }

            SubscribeHooks();

            var player = GetRandomPlayer();
            if (player == null)
            {
                StartEventTimer();
                return;
            }
            
            Destinations destinations = storedData.destinations.GetRandom();

            endPos = new Vector3(destinations.x2, destinations.y2, destinations.z2);

            restoreData.AddData(player);
            StripInventory(player);

            MovePosition(player, new Vector3(destinations.x1, destinations.y1, destinations.z1));
            PrepareJuggernaut(player);

            Subscribe(nameof(CanNetworkTo));
            CreateSphere();

            eventEnd = configData.Timers.Completion + GrabCurrentTime();
            nextTrigger = configData.Timers.Completion + GrabCurrentTime();

            hasStarted = true;
        }

        private BasePlayer GetRandomPlayer(int tries = 0)
        {
            if (tries > 4) return null;

            ulong playerId = optedIn.GetRandom();
            BasePlayer player = BasePlayer.activePlayerList.FirstOrDefault(x => x.userID == playerId);
            if (player == null || player.IsSleeping() || player.IsDead())
            {
                optedIn.Remove(playerId);
                if (optedIn.Count == 0)
                    return null;
                return GetRandomPlayer(++tries);
            }
            return player;
        }

        private void PrepareJuggernaut(BasePlayer player)
        {
            if (player.IsSleeping() || player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.In(1, () => PrepareJuggernaut(player));
                return;
            }
            juggernaut = player;

            if (configData.Juggernaut.ResetMetabolism)
            {
                player.metabolism.Reset();
                player.health = player.MaxHealth();
                player.metabolism.hydration.value = player.metabolism.hydration.max;
                player.metabolism.calories.value = player.metabolism.calories.max;
                player.metabolism.SendChangesToClient();
            }

            GiveJuggernautGear();
            PrintToChat(string.Format(msg("eventStart"), $"X:{Math.Round(endPos.x, 1)}, Z:{Math.Round(endPos.z, 1)}"));
            SendReply(player, string.Format(msg("juggerStart", player.UserIDString), $"X:{Math.Round(endPos.x, 1)}, Z:{Math.Round(endPos.z, 1)}"));

            eventTimer = timer.In(configData.Timers.Completion, EventCancel);
            if (configData.UI.ShowUITimer)
                RefreshAllUI();
            
            if (configData.Lusty.Enabled)
            {
                if (configData.Lusty.DestinationAmount > 1 && storedData.destinations.Count >= configData.Lusty.DestinationAmount)
                {
                    List<Destinations> destinations = new List<Destinations>(storedData.destinations);
                    int randomNumber = UnityEngine.Random.Range(1, configData.Lusty.DestinationAmount);
                    for (int i = 0; i < configData.Lusty.DestinationAmount; i++)
                    {
                        if (i == randomNumber)
                        {
                            AddMapMarker(endPos.x, endPos.z, $"{msg("possibleDest")} {i + 1}");
                        }
                        else
                        {
                            Destinations destination = destinations.GetRandom();
                            destinations.Remove(destination);
                            AddMapMarker(destination.x2, destination.z2, $"{msg("possibleDest")} {i + 1}");
                        }                        
                    }
                }
                else AddMapMarker(endPos.x, endPos.z, msg("destination"));
            }  
            if (configData.Game.BroadcastEvery > 0) 
                MapIconUpdater();
        }

        private void MapIconUpdater()
        {
            broadcastTimer = timer.Repeat(configData.Game.BroadcastEvery, 0, () =>
            {
                if (juggernaut != null)
                {
                    if (configData.Game.BroadcastEveryLM)
                    {
                        AddMapMarker(juggernaut.transform.position.x, juggernaut.transform.position.z, msg("juggernaut"));
                        timer.In(configData.Game.BroadcastLMSeconds, () => RemoveMapMarker(msg("juggernaut"), false));
                    }
                    else PrintToChat(string.Format(msg("positionBroadcast"), Math.Round(juggernaut.transform.position.x, 1), Math.Round(juggernaut.transform.position.z, 1)));
                }
            });
        }

        private void EventCancel()
        {           
            PrintToChat(msg("eventCancel"));
            TryRestorePlayer(juggernaut);
            DestroyEvent();
        }

        private void EventWin()
        {            
            PrintToChat(msg("juggerWin"));

            if (configData.Prizes.Inventory)
            {
                var remainingItems = new List<RestoreData.ItemData>();               
                remainingItems.AddRange(GetItems(juggernaut.inventory.containerBelt));
                remainingItems.AddRange(GetItems(juggernaut.inventory.containerMain));
                remainingItems.AddRange(GetItems(juggernaut.inventory.containerWear));

                if (!storedData.winnerRewards.ContainsKey(juggernaut.userID))
                    storedData.winnerRewards.Add(juggernaut.userID, remainingItems);
                else storedData.winnerRewards[juggernaut.userID] = remainingItems;
            }
            if (configData.Prizes.ServerRewards || configData.Prizes.Economics)
            {
                if (!storedData.winnerMoney.ContainsKey(juggernaut.userID))
                    storedData.winnerMoney.Add(juggernaut.userID, new List<Points>());
                storedData.winnerMoney[juggernaut.userID].Add(new Points
                {
                    isRp = configData.Prizes.ServerRewards,
                    amount = configData.Prizes.Amount
                });
            }

            TryRestorePlayer(juggernaut);
            DestroyEvent();
        }

        private void DestroyEvent()
        {
            hasStarted = false;

            if (eventTimer != null)
                eventTimer.Destroy();
            if (uiTimer != null)
                uiTimer.Destroy();
            if (broadcastTimer != null)
                broadcastTimer.Destroy();            

            foreach (var player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, Main);
            CuiHelper.DestroyUi(juggernaut, Compass);

            juggernaut = null;

            if (finalSphere != null)
            {
                if (finalSphere[0].GetComponent<FinalSphere>())
                    UnityEngine.Object.Destroy(finalSphere[0].GetComponent<FinalSphere>());

                for (int i = 0; i < finalSphere.Length; i++)                
                    finalSphere[i].KillMessage();                
            }

            Unsubscribe(nameof(CanNetworkTo));

            SaveData();

            RemoveMapMarker(msg("juggernaut"), false);
            RemoveMapMarker(msg("possibleDest"), true);
            RemoveMapMarker(msg("destination"), false);
            
            StartEventTimer();
        }

        private void TryRestorePlayer(BasePlayer player)
        {
            if (player == null) return;
            if (player.IsSleeping() || player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.In(1, () => TryRestorePlayer(player));
                return;
            }

            UnlockInventory(player);

            if (restoreData.HasRestoreData(player.userID))            
                restoreData.RestorePlayer(player);  
        }

        private void GiveJuggernautGear()
        {
            foreach (var entry in configData.Juggernaut.Inventory)
            {
                Item item = null;
                if (entry.IsBP)
                {
                    item = ItemManager.CreateByItemID(-1887162396, entry.Amount, entry.SkinID);
                    item.blueprintTarget = ItemManager.itemList.Find(x => x.shortname == entry.Shortname)?.itemid ?? 0;
                }
                else item = ItemManager.CreateByName(entry.Shortname, entry.Amount, entry.SkinID);

                if (item == null)                
                    PrintError($"Error creating item: {entry.Shortname}. Check this is a correct shortname!");                
                else item.MoveToContainer(entry.Container == "wear" ? juggernaut.inventory.containerWear : entry.Container == "belt" ? juggernaut.inventory.containerBelt : juggernaut.inventory.containerMain);
            }
            LockInventory(juggernaut);
        }

        private void UnsubscribeHooks()
        {
            Unsubscribe(nameof(OnEntityTakeDamage));
            Unsubscribe(nameof(OnEntityDeath));
            Unsubscribe(nameof(CanNetworkTo));
        }

        private void SubscribeHooks()
        {
            Subscribe(nameof(OnEntityTakeDamage));
            Subscribe(nameof(OnEntityDeath));
            Subscribe(nameof(CanNetworkTo));
        }

        private double GrabCurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;

        private string GetGridString(Vector3 position)
        {
            Vector2 adjPosition = new Vector2((World.Size / 2) + position.x, (World.Size / 2) - position.z);
            return $"{NumberToString((int)(adjPosition.x / 145))}{((int)(adjPosition.y / 145)) - 1}";
        }

        private string NumberToString(int number)
        {
            bool a = number > 26;
            Char c = (Char)(65 + (a ? number - 26 : number));
            return a ? "A" + c : c.ToString();
        }
        #endregion

        #region Teleportation Management  
        private void MovePosition(BasePlayer player, Vector3 destination)
        {
            if (player.net?.connection != null)
                player.ClientRPCPlayer(null, player, "StartLoading");
            StartSleeping(player);
            player.MovePosition(destination);
            if (player.net?.connection != null)
                player.ClientRPCPlayer(null, player, "ForcePositionTo", destination);
            if (player.net?.connection != null)
                player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
            player.UpdateNetworkGroup();
            player.SendNetworkUpdateImmediate(false);
            if (player.net?.connection == null) return;
            try { player.ClearEntityQueue(null); } catch { }
            player.SendFullSnapshot();
        }

        private void StartSleeping(BasePlayer player)
        {
            if (player.IsSleeping())
                return;
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, true);
            if (!BasePlayer.sleepingPlayerList.Contains(player))
                BasePlayer.sleepingPlayerList.Add(player);
            player.CancelInvoke("InventoryUpdate");
        }
        #endregion

        #region Player Saving and Restoration
        public static void StripInventory(BasePlayer player)
        {
            Item[] allItems = player.inventory.AllItems();

            for (int i = allItems.Length - 1; i >= 0; i--)
            {
                Item item = allItems[i];
                item.RemoveFromContainer();
                item.Remove();
            }
        }

        private IEnumerable<RestoreData.ItemData> GetItems(ItemContainer container)
        {
            return container.itemList.Select(item => new RestoreData.ItemData
            {
                itemid = item.info.itemid,
                amount = item.amount,
                ammo = item.GetHeldEntity() is BaseProjectile ? (item.GetHeldEntity() as BaseProjectile).primaryMagazine.contents : item.GetHeldEntity() is FlameThrower ? (item.GetHeldEntity() as FlameThrower).ammo : 0,
                ammotype = (item.GetHeldEntity() as BaseProjectile)?.primaryMagazine.ammoType.shortname ?? null,
                position = item.position,
                skin = item.skin,
                condition = item.condition,
                maxCondition = item.maxCondition,
                instanceData = new RestoreData.ItemData.InstanceData(item),
                contents = item.contents?.itemList.Select(item1 => new RestoreData.ItemData
                {
                    itemid = item1.info.itemid,
                    amount = item1.amount,
                    condition = item1.condition
                }).ToArray()
            });
        }

        public class RestoreData
        {
            public Hash<ulong, PlayerData> restoreData = new Hash<ulong, PlayerData>();

            public void AddData(BasePlayer player)
            {
                restoreData[player.userID] = new PlayerData(player);
            }

            public void RemoveData(ulong playerId)
            {
                if (HasRestoreData(playerId))
                    restoreData.Remove(playerId);
            }

            public bool HasRestoreData(ulong playerId) => restoreData.ContainsKey(playerId);

            public void RestorePlayer(BasePlayer player)
            {
                if (isUnloading)
                {
                    player.Die();
                    player.ChatMessage("<color=#ce422b>The plugin has been unloaded!</color> We are unable to restore you at this time, when the plugin has been reloaded you will be restored to your previous state");
                    return;
                }

                PlayerData playerData;
                if (restoreData.TryGetValue(player.userID, out playerData))
                {
                    StripInventory(player);

                    ins.UnlockInventory(player);

                    if (player.IsSleeping() || player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
                    {
                        ins.timer.Once(1, () => RestorePlayer(player));
                        return;
                    }

                    ins.NextTick(() =>
                    {
                        if (player == null || playerData == null)
                            return;

                        playerData.SetStats(player);
                        ins.MovePosition(player, playerData.GetPosition());
                        RestoreAllItems(player, playerData);
                    });
                }
            }

            private void RestoreAllItems(BasePlayer player, PlayerData playerData)
            {
                if (player == null || !player.IsConnected)
                    return;

                if (RestoreItems(player, playerData.containerBelt, "belt") && RestoreItems(player, playerData.containerWear, "wear") && RestoreItems(player, playerData.containerMain, "main"))
                    RemoveData(player.userID);
            }

            private bool RestoreItems(BasePlayer player, ItemData[] itemData, string type)
            {
                ItemContainer container = type == "belt" ? player.inventory.containerBelt : type == "wear" ? player.inventory.containerWear : player.inventory.containerMain;

                for (int i = 0; i < itemData.Length; i++)
                {
                    Item item = CreateItem(itemData[i]);
                    item.position = itemData[i].position;
                    item.SetParent(container);
                }
                return true;
            }

            public Item CreateItem(ItemData itemData)
            {
                Item item = ItemManager.CreateByItemID(itemData.itemid, itemData.amount, itemData.skin);
                item.condition = itemData.condition;

                if (itemData.instanceData != null)
                    itemData.instanceData.Restore(item);

                BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
                if (weapon != null)
                {
                    if (!string.IsNullOrEmpty(itemData.ammotype))
                        weapon.primaryMagazine.ammoType = ItemManager.FindItemDefinition(itemData.ammotype);
                    weapon.primaryMagazine.contents = itemData.ammo;
                }

                FlameThrower flameThrower = item.GetHeldEntity() as FlameThrower;
                if (flameThrower != null)
                    flameThrower.ammo = itemData.ammo;


                if (itemData.contents != null)
                {
                    foreach (ItemData contentData in itemData.contents)
                    {
                        Item newContent = ItemManager.CreateByItemID(contentData.itemid, contentData.amount);
                        if (newContent != null)
                        {
                            newContent.condition = contentData.condition;
                            newContent.MoveToContainer(item.contents);
                        }
                    }
                }
                return item;
            }

            public class PlayerData
            {
                public float[] stats;
                public float[] position;
                public ItemData[] containerMain;
                public ItemData[] containerWear;
                public ItemData[] containerBelt;

                public PlayerData() { }

                public PlayerData(BasePlayer player)
                {
                    stats = GetStats(player);
                    position = GetPosition(player.transform.position);
                    containerBelt = ins.GetItems(player.inventory.containerBelt).ToArray();
                    containerMain = ins.GetItems(player.inventory.containerMain).ToArray();
                    containerWear = ins.GetItems(player.inventory.containerWear).ToArray();
                }
                
                private float[] GetStats(BasePlayer player) => new float[] { player.health, player.metabolism.hydration.value, player.metabolism.calories.value };

                public void SetStats(BasePlayer player)
                {
                    player.health = stats[0];
                    player.metabolism.hydration.value = stats[1];
                    player.metabolism.calories.value = stats[2];
                    player.metabolism.SendChangesToClient();
                }

                private float[] GetPosition(Vector3 position) => new float[] { position.x, position.y, position.z };

                public Vector3 GetPosition() => new Vector3(position[0], position[1], position[2]);
            }

            public class ItemData
            {
                public int itemid;
                public ulong skin;
                public int amount;
                public float condition;
                public float maxCondition;
                public int ammo;
                public string ammotype;
                public int position;
                public InstanceData instanceData;
                public ItemData[] contents;

                public class InstanceData
                {
                    public int dataInt;
                    public int blueprintTarget;
                    public int blueprintAmount;

                    public InstanceData() { }
                    public InstanceData(Item item)
                    {
                        if (item.instanceData == null)
                            return;

                        dataInt = item.instanceData.dataInt;
                        blueprintAmount = item.instanceData.blueprintAmount;
                        blueprintTarget = item.instanceData.blueprintTarget;
                    }

                    public void Restore(Item item)
                    {
                        item.instanceData = new ProtoBuf.Item.InstanceData();
                        item.instanceData.blueprintAmount = blueprintAmount;
                        item.instanceData.blueprintTarget = blueprintTarget;
                        item.instanceData.dataInt = dataInt;
                    }
                }
            }
        }
        #endregion

        #region Sphere Creation
        private void CreateSphere()
        {
            finalSphere = new SphereEntity[configData.Game.SphereDarkness];
            for (int i = 0; i < configData.Game.SphereDarkness; i++)
            {
                var sphere = (SphereEntity)GameManager.server.CreateEntity(sphereEnt, endPos, new Quaternion(), true);
                sphere.currentRadius = 5;
                sphere.lerpSpeed = 0;
                sphere.enableSaving = false;
                sphere.Spawn();

                finalSphere[i] = sphere;
            }            

            finalSphere[0].gameObject.AddComponent<FinalSphere>();
        }
       
        class FinalSphere : MonoBehaviour
        {
            public BaseEntity entity;
            void Awake()
            {
                entity = GetComponent<BaseEntity>();                
                gameObject.layer = (int)Layer.Reserved1;
                gameObject.name = $"Juggernaut Final Zone";
                enabled = false;

                var collider = entity.gameObject.AddComponent<SphereCollider>();
                collider.isTrigger = true;
                collider.radius = 0.5f;
            }
            void OnDestroy()
            {
                if (!entity.IsDestroyed)
                    entity.Kill();               
            }
            void OnTriggerEnter(Collider obj)
            {
                if (obj.gameObject.layer == (int)Layer.Player_Server)
                {
                    var player = obj?.GetComponentInParent<BasePlayer>();
                    if (player != null)
                    {
                        if (player == ins.juggernaut)
                        {
                            ins.EventWin();
                        }
                    }
                }
            }             
        }
        #endregion

        #region Hooks
        #region Internal Checks
        private bool IsClanmate(ulong playerId, ulong friendId)
        {
            if (!Clans) return false;
            object playerTag = Clans?.Call("GetClanOf", playerId);
            object friendTag = Clans?.Call("GetClanOf", friendId);
            if (playerTag is string && friendTag is string)
                if (playerTag == friendTag) return true;
            return false;
        }
        private bool IsFriend(ulong playerID, ulong friendID)
        {
            if (!Friends) return false;
            return (bool)Friends?.Call("IsFriend", playerID, friendID);
        }
        private bool IsPlaying(BasePlayer player)
        {
            if (!EventManager) return false;
            return (bool)EventManager.Call("isPlaying", player);
        }
        private void JoinedEvent(BasePlayer player)
        {
            if (optedIn.Contains(player.userID))
                optedIn.Remove(player.userID);
        }
        private void AddMapMarker(float x, float z, string markerName) => LustyMap?.Call("AddTemporaryMarker", x, z, markerName, configData.UI.IconUrl);
        private void RemoveMapMarker(string markerName, bool startsWith)
        {
            if (!startsWith)
                LustyMap?.Call("RemoveTemporaryMarker", markerName);
            else LustyMap?.Call("RemoveTemporaryMarkerStartsWith", markerName);
        }        
        #endregion

        #region External Checks
        object CanTrade(BasePlayer player)
        {
            if (player == juggernaut)
                return msg("tryTrading", player.UserIDString);
            return null;
        }
        object canRemove(BasePlayer player)
        {
            if (player == juggernaut)
                return msg("tryRemove", player.UserIDString);
            return null;
        }
        object CanTeleport(BasePlayer player)
        {
            if (player == juggernaut)
                return msg("tryTP", player.UserIDString);
            return null;
        }
        object canShop(BasePlayer player)
        {
            if (player == juggernaut)
                return msg("tryShop", player.UserIDString);
            return null;
        }
        #endregion
        #endregion

        #region UI
        public class UI
        {
            static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool useCursor = false)
            {
                var NewElement = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color},
                            RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                            CursorEnabled = useCursor
                        },
                        new CuiElement().Parent = "Hud",
                        panelName
                    }
                };
                return NewElement;
            }
            static public void AddImage(ref CuiElementContainer container, string panel, string png, string aMin, string aMax, float fadeOut = 0f)
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                    {
                        new CuiRawImageComponent {Png = png, Sprite = "assets/content/textures/generic/fulltransparent.tga" },
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax }
                    }
                });
            }
            static public void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);

            }
            public static string Color(string hexColor, float alpha)
            {
                if (hexColor.StartsWith("#"))
                    hexColor = hexColor.TrimStart('#');
                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} {alpha}";
            }
        }
        #endregion

        #region UI Creation
        private const string Main = "JuggernautMain";
        private const string Compass = "JuggernautCompass";
        private void CreateTimerUI(BasePlayer player)
        {
            var MainCont = UI.CreateElementContainer(Main, UI.Color(configData.UI.UIBackgroundColor, configData.UI.UIOpacity), $"{configData.UI.TimerPosition.XPosition} {configData.UI.TimerPosition.YPosition}", $"{configData.UI.TimerPosition.XPosition + configData.UI.TimerPosition.XDimension} {configData.UI.TimerPosition.YPosition + configData.UI.TimerPosition.YDimension}");

            if (!string.IsNullOrEmpty(juggernautIcon))
                UI.AddImage(ref MainCont, Main, juggernautIcon, "0.01 0.05", "0.425 0.95");
            UI.CreateLabel(ref MainCont, Main, "", GetFormatTime(eventEnd), 15, "0.5 0", "1 1", TextAnchor.MiddleLeft);

            CuiHelper.DestroyUi(player, Main);
            CuiHelper.AddUi(player, MainCont);
        }

        private string GetFormatTime(double timeLeft)
        {
            var time = timeLeft - GrabCurrentTime();
            double minutes = Math.Floor((double)(time / 60));
            time -= (int)(minutes * 60);
            return string.Format("{0:00}:{1:00}", minutes, time);
        }

        private void RefreshAllUI()
        {
            uiTimer = timer.Repeat(1, (int)(eventEnd - GrabCurrentTime()) - 1, () =>
            {
                foreach (var player in BasePlayer.activePlayerList)
                    CreateTimerUI(player);
                if (configData.UI.ShowCoordsToJuggernaut)
                    ShowCompass();
            });
        }

        private void ShowCompass()
        {
            var MainCont = UI.CreateElementContainer(Compass, UI.Color(configData.UI.UIBackgroundColor, configData.UI.UIOpacity), $"{configData.UI.CompassPosition.XPosition} {configData.UI.CompassPosition.YPosition}", $"{configData.UI.CompassPosition.XPosition + configData.UI.CompassPosition.XDimension} {configData.UI.CompassPosition.YPosition + configData.UI.CompassPosition.YDimension}");
            UI.CreateLabel(ref MainCont, Compass, "", string.Format(msg("target1", juggernaut.UserIDString), GetGridString(endPos)), 10, "0.05 0.5", "0.95 0.95", TextAnchor.MiddleLeft);
            UI.CreateLabel(ref MainCont, Compass, "", string.Format(msg("target2", juggernaut.UserIDString), Math.Round(Vector3.Distance(juggernaut.transform.position, endPos), 2)), 10, "0.05 0.05", "0.95 0.5", TextAnchor.MiddleLeft);
            CuiHelper.DestroyUi(juggernaut, Compass);
            CuiHelper.AddUi(juggernaut, MainCont);
        }
        #endregion

        #region Imagery
        private WWW info;
        public void Add(string url)
        {
            info = new WWW(url);
            TryDownloadImage();
        }
        void TryDownloadImage()
        {
            if (!info.isDone)
            {
                timer.In(1, TryDownloadImage);
                return;
            }
            if (!string.IsNullOrEmpty(info.error))
            {
                PrintError(string.Format("Failed to load the Juggernaut icon! Error: {0}", info.error));
                return;
            }
            else juggernautIcon = FileStorage.server.Store(info.bytes, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID).ToString();            
        }
        #endregion

        #region Commands
        [ChatCommand("jug")]
        void cmdJuggernaut(BasePlayer player, string command, string[] args)
        {            
            if (args.Length == 0)
            {
                SendReply(player, $"<color=#ce422b>{Title}</color><color=#939393>  v{Version}  -</color> <color=#ce422b>{Author} @ www.chaoscode.io</color>");
                SendReply(player, msg("help0", player.UserIDString));
                SendReply(player, msg("help1", player.UserIDString));
                SendReply(player, msg("help2", player.UserIDString));
                SendReply(player, msg("help3", player.UserIDString));
                SendReply(player, msg("help4", player.UserIDString));
                if (player.IsAdmin)
                {
                    SendReply(player, msg("help5", player.UserIDString));
                    SendReply(player, msg("help6", player.UserIDString));
                    SendReply(player, msg("help7", player.UserIDString));
                    SendReply(player, msg("help8", player.UserIDString));
                }
                return;
            }
            switch (args[0].ToLower())
            {
                case "info":
                    string time = GetFormatTime(nextTrigger);
                    if (hasStarted)
                        SendReply(player, string.Format(msg("endsIn", player.UserIDString), time));
                    else if (isOpen)
                        SendReply(player, string.Format(msg("startsIn", player.UserIDString), time));
                    else SendReply(player, string.Format(msg("nextEvent", player.UserIDString), time));                    
                    return;
                case "join":
                    if (!permission.UserHasPermission(player.UserIDString, "juggernaut.canbe"))
                    {
                        SendReply(player, msg("noPerms", player.UserIDString));
                        return;
                    }
                    if (!isOpen)
                    {
                        SendReply(player, msg("notOpen", player.UserIDString));
                        return;
                    }
                    if (IsPlaying(player))
                    {
                        SendReply(player, msg("playingEM", player.UserIDString));
                        return;
                    }
                    if (!optedIn.Contains(player.userID))
                    {
                        optedIn.Add(player.userID);
                        SendReply(player, msg("enteredDraw", player.UserIDString));
                        PrintToChat(string.Format(msg("candidate"), player.displayName, optedIn.Count));
                    }
                    return;
                case "leave":
                    if (!isOpen)
                    {
                        SendReply(player, msg("notOpen", player.UserIDString));
                        return;
                    }
                    if (optedIn.Contains(player.userID))
                        optedIn.Remove(player.userID);
                    SendReply(player, msg("removedDraw", player.UserIDString));
                    return;
                case "claim":
                    if (storedData.winnerRewards.ContainsKey(player.userID))
                    {
                        foreach(var prize in storedData.winnerRewards[player.userID])
                        {
                            Item item = restoreData.CreateItem(prize);
                            if (item != null)
                                player.GiveItem(item, BaseEntity.GiveItemReason.Generic);
                        }
                        SendReply(player, msg("claimSuccess", player.UserIDString));
                        storedData.winnerRewards.Remove(player.userID);
                        SaveData();
                    }
                    else if (storedData.winnerMoney.ContainsKey(player.userID))
                    {
                        foreach(var prize in storedData.winnerMoney[player.userID])
                        {
                            if (prize.isRp)                            
                                ServerRewards?.Call("AddPoints", player.userID, prize.amount);
                            else Economics?.Call("Deposit", player.userID, (double)prize.amount);
                        }
                        SendReply(player, msg("claimSuccess", player.UserIDString));
                        storedData.winnerMoney.Remove(player.userID);
                        SaveData();
                    }
                    else SendReply(player, msg("noPrizes", player.UserIDString));
                    return;
                case "restore":
                    if (player == juggernaut)
                    {
                        SendReply(player, msg("cantRestore", player.UserIDString));
                        return;
                    }
                    if (restoreData.HasRestoreData(player.userID))
                    {
                        TryRestorePlayer(player);
                        return;
                    }
                    else SendReply(player, msg("noRestoreData", player.UserIDString));
                    return;
                case "open":
                    if (player.IsAdmin)
                    {
                        if (isOpen)
                        {
                            SendReply(player, msg("alreadyOpen", player.UserIDString));
                            return;
                        }
                        if (!hasDestinations)
                        {
                            SendReply(player, msg("noDestinations", player.UserIDString));
                            return;
                        }
                        if (hasStarted)
                        {
                            SendReply(player, msg("alreadyStarted", player.UserIDString));
                            return;
                        }
                        if (nextMatch != null)
                            nextMatch.Destroy();
                        OpenEvent();
                    }
                    return;
                case "start":
                    if (player.IsAdmin)
                    {
                        if (!isOpen)
                        {
                            SendReply(player, msg("isntOpen", player.UserIDString));
                            return;
                        }
                        if (hasStarted)
                        {
                            SendReply(player, msg("alreadyStarted", player.UserIDString));
                            return;
                        }                        
                        if (startMatch != null)
                            startMatch.Destroy();
                        if (openMessage != null)
                            openMessage.Destroy();
                        StartEvent();
                    }
                    return;
                case "cancel":
                    if (player.IsAdmin)
                    {
                        if (!isOpen && !hasStarted)
                        {
                            SendReply(player, msg("notStarted", player.UserIDString));
                            return;
                        }
                        if (isOpen)
                        {
                            if (startMatch != null)
                                startMatch.Destroy();
                            if (openMessage != null)
                                openMessage.Destroy();
                            isOpen = false;
                            PrintToChat(msg("adminCancel"));
                            StartEventTimer();
                            return;
                        }  
                        if (hasStarted)
                        {                            
                            PrintToChat(msg("adminCancel"));
                            TryRestorePlayer(juggernaut);
                            DestroyEvent();
                            return;
                        }                      
                    }
                    return;
                case "destination":
                    if (player.IsAdmin)
                    {
                        if (!destinationCreator.ContainsKey(player.userID))
                        {
                            destinationCreator.Add(player.userID, new Destinations { x1 = player.transform.position.x, y1 = player.transform.position.y, z1 = player.transform.position.z });
                            SendReply(player, msg("destCreate1",player.UserIDString));
                            return;
                        }
                        else
                        {
                            Destinations data = destinationCreator[player.userID];
                            data.x2 = player.transform.position.x;
                            data.y2 = player.transform.position.y;
                            data.z2 = player.transform.position.z;
                            storedData.destinations.Add(data);
                            destinationCreator.Remove(player.userID);
                            SaveData();
                            if (!hasDestinations)
                                hasDestinations = true;
                            SendReply(player, msg("destCreate2", player.UserIDString));
                        }
                    }
                    return;
                default:
                    break;
            }
        }
        [ConsoleCommand("jug")]
        void ccmdJuggernaut(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null) return;
            if (arg.Args == null || arg.Args.Length == 0)
            {
                SendReply(arg, $"- {Title}  v{Version}  - {Author} @ www.chaoscode.io -");
                SendReply(arg, "jug open - Force open the event");
                SendReply(arg, "jug start - Force start the event");
                SendReply(arg, "jug cancel - Cancel a pending or current event");
                SendReply(arg, "jug clearicon - Clears any Juggernaut related icons from the map");

                return;
            }
            switch (arg.Args[0].ToLower())
            {
                case "open":
                    if (isOpen)
                    {
                        SendReply(arg, msg("alreadyOpen"));
                        return;
                    }
                    if (!hasDestinations)
                    {
                        SendReply(arg, msg("noDestinations"));
                        return;
                    }
                    if (hasStarted)
                    {
                        SendReply(arg, msg("alreadyStarted"));
                        return;
                    }
                    if (nextMatch != null)
                        nextMatch.Destroy();
                    OpenEvent();

                    return;
                case "start":
                    if (!isOpen)
                    {
                        SendReply(arg, msg("isntOpen"));
                        return;
                    }
                    if (hasStarted)
                    {
                        SendReply(arg, msg("alreadyStarted"));
                        return;
                    }
                    if (startMatch != null)
                        startMatch.Destroy();
                    if (openMessage != null)
                        openMessage.Destroy();
                    StartEvent();
                    return;
                case "cancel":
                    if (!isOpen && !hasStarted)
                    {
                        SendReply(arg, msg("notStarted"));
                        return;
                    }
                    if (isOpen)
                    {
                        if (startMatch != null)
                            startMatch.Destroy();
                        if (openMessage != null)
                            openMessage.Destroy();
                        isOpen = false;
                        PrintToChat(msg("adminCancel"));
                        StartEventTimer();
                        return;
                    }
                    if (hasStarted)
                    {
                        PrintToChat(msg("adminCancel"));
                        TryRestorePlayer(juggernaut);
                        DestroyEvent();
                        return;
                    }
                    return;
                case "clearicon":
                    RemoveMapMarker(msg("juggernaut"), false);
                    RemoveMapMarker(msg("destination"), false);                                     
                    RemoveMapMarker(msg("possibleDest"), true);                    
                    return;
                default:
                    break;
            }
        }
        #endregion

        #region Config        
        private ConfigData configData;        
        class ConfigData
        {
            [JsonProperty(PropertyName = "Juggernaut Settings")]
            public JuggernautOptions Juggernaut { get; set; }
            [JsonProperty(PropertyName = "Event Timers")]
            public EventTimers Timers { get; set; }
            [JsonProperty(PropertyName = "UI Settings")]
            public UISettings UI { get; set; }
            [JsonProperty(PropertyName = "Event Conditions")]
            public EventConditions Conditions { get; set; }
            [JsonProperty(PropertyName = "LustyMap Integration")]
            public LustyIntegration Lusty { get; set; }
            [JsonProperty(PropertyName = "Game Settings")]
            public GameOptions Game { get; set; }
            [JsonProperty(PropertyName = "Reward Settings")]
            public PrizeOptions Prizes { get; set; }

            public class JuggernautOptions
            {
                [JsonProperty(PropertyName = "Defense damage modifier")]
                public float DefenseMod { get; set; }
                [JsonProperty(PropertyName = "Attack damage modifier")]
                public float AttackMod { get; set; }
                [JsonProperty(PropertyName = "Can damage structures")]
                public bool DamageStructures { get; set; }
                [JsonProperty(PropertyName = "Start with full metabolism")]
                public bool ResetMetabolism { get; set; }
                [JsonProperty(PropertyName = "Disable landmine damage")]
                public bool NoLandmineDamage { get; set; }
                [JsonProperty(PropertyName = "Disable beartrap damage")]
                public bool NoBeartrapDamage { get; set; }
                [JsonProperty(PropertyName = "Disable fall damage")]
                public bool NoFallDamage { get; set; }
                [JsonProperty(PropertyName = "Inventory contents")]
                public List<InventoryItem> Inventory { get; set; }

                public class InventoryItem
                {
                    [JsonProperty(PropertyName = "Item shortname")]
                    public string Shortname { get; set; }
                    [JsonProperty(PropertyName = "Amount of item")]
                    public int Amount { get; set; }
                    [JsonProperty(PropertyName = "Item skin ID")]
                    public ulong SkinID { get; set; }
                    [JsonProperty(PropertyName = "Is this item a blueprint?")]
                    public bool IsBP { get; set; }
                    [JsonProperty(PropertyName = "Container (main, wear or belt)")]
                    public string Container { get; set; }
                }
            }            
            public class PrizeOptions
            {
                [JsonProperty(PropertyName = "Allow players to loot juggernaut as a prize")]
                public bool Inventory { get; set; }
                [JsonProperty(PropertyName = "Use Economics money as a prize")]
                public bool Economics { get; set; }
                [JsonProperty(PropertyName = "Use ServerRewards money as a prize")]
                public bool ServerRewards { get; set; }
                [JsonProperty(PropertyName = "Monetary amount")]
                public int Amount { get; set; }
            }
            public class EventTimers
            {
                [JsonProperty(PropertyName = "Amount of time to complete journey (seconds)")]
                public int Completion { get; set; }
                [JsonProperty(PropertyName = "Amount of time between events (seconds)")]
                public int Interval { get; set; }
                [JsonProperty(PropertyName = "Amount of time the entry process will remain open (seconds)")]
                public int Open { get; set; }
            }
            public class EventConditions
            {
                [JsonProperty(PropertyName = "The percentage of server players required for the event to start")]
                public float Percentage { get; set; }
                [JsonProperty(PropertyName = "The minimum amount of players on the server required to open the event")]
                public int OpenMin { get; set; }
            }
            public class LustyIntegration
            {
                [JsonProperty(PropertyName = "Show the destination icon on the map")]
                public bool Enabled { get; set; }
                [JsonProperty(PropertyName = "The amount of possible destinations to show")]
                public int DestinationAmount { get; set; }
            }
            public class GameOptions
            {
                [JsonProperty(PropertyName = "Broadcast the juggernauts position to chat every X seconds")]
                public int BroadcastEvery { get; set; }
                [JsonProperty(PropertyName = "Broadcast the juggernauts position to LustyMap ever X seconds")]
                public bool BroadcastEveryLM { get; set; }
                [JsonProperty(PropertyName = "The amount of time the juggernauts position will remain on LustyMap if enabled (seconds)")]
                public int BroadcastLMSeconds { get; set; }
                [JsonProperty(PropertyName = "Destination sphere darkness")]
                public int SphereDarkness { get; set; }
                [JsonProperty(PropertyName = "Blacklisted commands for event players")]
                public string[] CommandBlacklist { get; set; }
            }
            public class UISettings
            {
                [JsonProperty(PropertyName = "Show the juggernaut their position so they can navigate")]
                public bool ShowCoordsToJuggernaut { get; set; }                
                [JsonProperty(PropertyName = "Display a timer showing how long the juggernaut has to get to their destination")]
                public bool ShowUITimer { get; set; }
                [JsonProperty(PropertyName = "The URL of the juggernaut icon")]
                public string IconUrl { get; set; }
                [JsonProperty(PropertyName = "Timer positioning")]
                public Position TimerPosition { get; set; }
                [JsonProperty(PropertyName = "Compass positioning")]
                public Position CompassPosition { get; set; }
                [JsonProperty(PropertyName = "UI background color (hex)")]
                public string UIBackgroundColor { get; set; }
                [JsonProperty(PropertyName = "UI opacity (0.0 - 1.0)")]
                public float UIOpacity { get; set; }

                public class Position
                {
                    [JsonProperty(PropertyName = "Horizontal start position (left)")]
                    public float XPosition { get; set; }
                    [JsonProperty(PropertyName = "Vertical start position (bottom)")]
                    public float YPosition { get; set; }
                    [JsonProperty(PropertyName = "Horizontal dimensions")]
                    public float XDimension { get; set; }
                    [JsonProperty(PropertyName = "Vertical dimensions")]
                    public float YDimension { get; set; }
                }
            }

            public Oxide.Core.VersionNumber Version { get; set; }
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Conditions = new ConfigData.EventConditions
                {
                    OpenMin = 10,
                    Percentage = 0.6f
                },
                Timers = new ConfigData.EventTimers
                {
                    Open = 120,
                    Interval = 3600,
                    Completion = 900
                },
                Game = new ConfigData.GameOptions
                {
                    BroadcastEvery = 0,
                    BroadcastEveryLM = false,
                    BroadcastLMSeconds = 5,
                    SphereDarkness = 5,
                    CommandBlacklist = new string[]
                    {
                        "s",
                        "tp",
                        "tpa",
                        "tpr",
                        "home"
                    }
                },
                Lusty = new ConfigData.LustyIntegration
                {
                    DestinationAmount = 1,
                    Enabled = true
                },
                Juggernaut = new ConfigData.JuggernautOptions
                {
                    AttackMod = 1.5f,
                    DamageStructures = true,
                    ResetMetabolism = true,
                    DefenseMod = 0.5f,
                    NoBeartrapDamage = false,
                    NoLandmineDamage = false,
                    NoFallDamage = false,
                    Inventory = new List<ConfigData.JuggernautOptions.InventoryItem>
                    {
                        new ConfigData.JuggernautOptions.InventoryItem
                        {
                            Amount = 1,
                            Shortname = "heavy.plate.pants",
                            SkinID = 0,
                            IsBP = false,
                            Container = "wear"
                        },
                        new ConfigData.JuggernautOptions.InventoryItem
                        {
                            Amount = 1,
                            Shortname = "heavy.plate.jacket",
                            SkinID = 0,
                            IsBP = false,
                            Container = "wear"
                        },
                        new ConfigData.JuggernautOptions.InventoryItem
                        {
                            Amount = 1,
                            Shortname = "heavy.plate.helmet",
                            SkinID = 0,
                            IsBP = false,
                            Container = "wear"
                        },
                        new ConfigData.JuggernautOptions.InventoryItem
                        {
                            Amount = 1,
                            Shortname = "lmg.m249",
                            SkinID = 0,
                            IsBP = false,
                            Container = "belt"
                        },
                        new ConfigData.JuggernautOptions.InventoryItem
                        {
                            Amount = 500,
                            Shortname = "ammo.rifle.explosive",
                            SkinID = 0,
                            IsBP = false,
                            Container = "main"
                        },
                        new ConfigData.JuggernautOptions.InventoryItem
                        {
                            Amount = 3,
                            Shortname = "grenade.f1",
                            SkinID = 0,
                            IsBP = false,
                            Container = "belt"
                        },
                        new ConfigData.JuggernautOptions.InventoryItem
                        {
                            Amount = 3,
                            Shortname = "syringe.medical",
                            SkinID = 0,
                            IsBP = false,
                            Container = "belt"
                        }
                    }
                },
                Prizes = new ConfigData.PrizeOptions
                {
                    Amount = 0,
                    Economics = false,
                    Inventory = true,
                    ServerRewards = false
                },
                UI = new ConfigData.UISettings
                {
                    IconUrl = "http://www.rustedit.io/images/juggernaut_icon.png",
                    UIBackgroundColor = "#4C4C4C",
                    ShowCoordsToJuggernaut = true,
                    ShowUITimer = true,
                    CompassPosition = new ConfigData.UISettings.Position
                    {
                        XDimension = 0.11f,
                        XPosition = 0.725f,
                        YDimension = 0.05f,
                        YPosition = 0.026f,
                    },
                    TimerPosition = new ConfigData.UISettings.Position
                    {
                        XDimension = 0.07f,
                        XPosition = 0.65f,
                        YDimension = 0.05f,
                        YPosition = 0.026f,
                    },
                    UIOpacity = 0.7f
                },
                Version = Version
            };            
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion

        #region Data Management        
        private class Destinations
        {
            public float x1, y1, z1, x2, y2, z2;
        }

        private class Points
        {
            public int amount;
            public bool isRp;
        }

        private void SaveData() => data.WriteObject(storedData);

        private void SaveRestoreData() => restorationData.WriteObject(restoreData);

        private void LoadData()
        {
            try
            {
                storedData = data.ReadObject<StoredData>();
            }
            catch
            {
                storedData = new StoredData();
            }
            try
            {
                restoreData = restorationData.ReadObject<RestoreData>();
            }
            catch
            {
                restoreData = new RestoreData();
            }
        }

        private class StoredData
        {
            public Dictionary<ulong, List<RestoreData.ItemData>> winnerRewards = new Dictionary<ulong, List<RestoreData.ItemData>>();
            public Dictionary<ulong, List<Points>> winnerMoney = new Dictionary<ulong, List<Points>>();
            public List<Destinations> destinations = new List<Destinations>();
        }
        #endregion

        #region Localization
        string msg(string key, string playerId = "") => lang.GetMessage(key, this, playerId);
        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            {"eventOpen", "<color=#ce422b>[Juggernaut] </color><color=#939393>: The juggernaut event is open for contestants! Type </color><color=#ce422b>/jug join</color><color=#939393> to join the list of juggernaut candidates</color>" },
            {"playerChosen", "<color=#ce422b>[Juggernaut] </color><color=#939393>: The juggernaut has been chosen! The event will start in </color><color=#ce422b>10</color><color=#939393> seconds</color>" },
            {"juggerChosen", "<color=#ce422b>[Juggernaut] </color><color=#939393>: You have been chosen to be the juggernaut!</color>" },
            {"eventStart", "<color=#ce422b>[Juggernaut] </color><color=#939393>: The juggernaut is inbound towards </color><color=#ce422b>{0}</color><color=#939393>! Find and kill him before he gets to the destination!</color>" },
            {"juggerStart", "<color=#ce422b>[Juggernaut]</color><color=#939393> : You must make your way to </color><color=#ce422b>{0}</color><color=#939393> and enter the white sphere to win the event!</color>" },
            {"juggerDead", "<color=#ce422b>[Juggernaut]</color><color=#939393> : The juggernaut has been killed and his loot is there for the taking!</color>" },
            {"juggerWin", "<color=#ce422b>[Juggernaut]</color><color=#939393> : The juggernaut made his way to the target destination and has won the event!</color>" },
            {"juggerClaim", "<color=#ce422b>[Juggernaut]</color><color=#939393> : You have won the event! To claim your reward type </color><color=#ce422b>/juggernaught claim</color><color=#939393> once you have emptied your inventory</color>" },
            {"noEntrants", "<color=#ce422b>[Juggernaut]</color><color=#939393> : No players signed up to be the juggernaut. The event has been cancelled!</color>" },
            {"notEnoughEntrants", "<color=#ce422b>[Juggernaut]</color><color=#939393> : Not enough players signed up to be the juggernaut. Minimum percentage of online players required to start is {0}</color>" },
            {"eventCancel", "<color=#ce422b>[Juggernaut]</color><color=#939393> : The event is now over as the juggernaut took too long to reach his destination</color>" },
            {"adminCancel", "<color=#ce422b>[Juggernaut]</color><color=#939393> : A admin has cancelled the event!</color>" },
            {"enteredDraw", "<color=#939393>You have entered yourself into the draw to be the juggernaut. You can leave at any time by typing </color><color=#ce422b>/jug leave</color>" },
            {"removedDraw", "<color=#939393>You have removed yourself from the draw to be the juggernaut</color>" },
            {"noPrizes", "<color=#939393>You do not have any outstanding prizes</color>" },
            {"claimSuccess", "<color=#939393>You have successfully claimed your prize</color>" },
            {"destination", "Juggernaut Destination" },
            {"possibleDest", "Possible Destination" },
            {"positionBroadcast", "<color=#939393>The juggernaut was last seen at</color> <color=#ce422b>X:{0}, Z:{1}</color>" },
            {"target1", "Grid Target : <color=#ce422b>{0}</color>" },
            {"target2", "Distance : <color=#ce422b>{0}m</color>" },
            //{"current", "Current : " },
            {"juggernaut", "Juggernaut" },
            {"noPerms", "<color=#939393>You do not have permission to be the juggernaut</color>" },
            {"help0", "<color=#ce422b>/jug info</color><color=#939393> - Show how much time is remaining between various stages of the event process</color>" },
            {"help1", "<color=#ce422b>/jug join</color><color=#939393> - Enter yourself into the draw to be a juggernaut</color>" },
            {"help2", "<color=#ce422b>/jug leave</color><color=#939393> - Remove yourself from the draw to be a juggernaut</color>"},
            {"help3", "<color=#ce422b>/jug claim</color><color=#939393> - Claim any outstanding prizes you have won (ensure a empty inventory when claiming!)</color>"},
            {"help4", "<color=#ce422b>/jug restore</color><color=#939393> - Restore your previous state before you became the juggernaut</color>" },
            {"help5", "<color=#ce422b>/jug open</color><color=#939393> - Force open a event</color>"},
            {"help6", "<color=#ce422b>/jug start</color><color=#939393> - Force start a event</color>"},
            {"help7", "<color=#ce422b>/jug cancel</color><color=#939393> - Cancel a current event</color>"},
            {"help8", "<color=#ce422b>/jug destination</color><color=#939393> - Create a new destination starting at your position / Add the end point of a destination at your position</color>"},
            {"notOpen", "<color=#939393>There is not currently a event open</color>"},
            {"playingEM", "<color=#939393>You can not join a juggernaut event when playing in Event Manager</color>"},
            {"cantRestore", "<color=#939393>You can't restore while you are the juggernaut</color>"},
            {"noRestoreData", "<color=#939393>You do not have any saved restore data</color>"},
            {"alreadyOpen", "<color=#939393>There is already a event open</color>"},
            {"noDestinations", "<color=#939393>No destinations have been set! Unable to start the event</color>"},
            {"alreadyStarted", "<color=#939393>There is already a event in progress</color>"},
            {"isntOpen", "<color=#939393>You must open a event before starting</color>"},
            {"notStarted", "<color=#939393>There is no event currently in progress</color>"},
            {"destCreate1", "<color=#939393>You have begun creating a new destination starting at your current position. Move to the position you would like the end point to be and type this command again</color>"},
            {"destCreate2", "<color=#939393>You have sucessfully created a new potential destination</color>"},
            {"tryTrading", "<color=#939393>You can't trade while you are the juggernaut!</color>"},
            {"tryRemove", "<color=#939393>You can't remove while you are the juggernaut!</color>"},
            {"tryTP", "<color=#939393>You can't teleport while you are the juggernaut!</color>"},
            {"tryShop", "<color=#939393>You can't shop while you are the juggernaut!</color>"},
            {"ff1", "<color=#939393>You can't hurt your friends when they are the juggernaut!</color>"},
            {"ff2", "<color=#939393>You can't hurt your clan mates when they are the juggernaut!</color>"},
            {"endsIn", "<color=#939393>The current event ends in : </color><color=#ce422b>{0}</color>" },
            {"startsIn", "<color=#939393>The event will start in : </color><color=#ce422b>{0}</color>" },
            {"nextEvent", "<color=#939393>The next event opens in : </color><color=#ce422b>{0}</color>" },
            {"noSuicide", "<color=#939393>You can not suicide whilst you are the juggernaut!</color>" },
            {"juggerSuicide", "<color=#939393>The juggernaut suicided! The event is over and the loot has been removed</color>" },
            {"candidate", "<color=#ce422b>{0}</color> <color=#939393>has registered as a juggernaut candidate!</color> <color=#ce422b>({1} players registered)</color>" },
            {"blacklistcmd", "<color=#939393>You can not run that command while you are the juggernaut!</color>" }
        };
        #endregion
    }
}


// --- End of file: Juggernaut.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BuildingProtection.cs ---
// --- Original Local Path: BuildingProtection.cs ---

using System; using System.Linq; using System.Collections; using System.Collections.Generic; using Oxide.Core; using Oxide.Game.Rust.Cui; using Oxide.Core.Plugins; using UnityEngine; using Rust; using Newtonsoft.Json; namespace Oxide.Plugins { [Info("BuildingProtection", "Nimant", "1.0.4")] class BuildingProtection : RustPlugin { [PluginReference] private Plugin NoEscape; private const string cdhAlpanRBpDIza = "buildingprotection.use"; private const string vBvxkHaTFkygGpYQwuzSUq = "☐"; private const string nwVBCplpXvAaIKSWWs = "☑"; private static Dictionary<ulong, yiMnwiLrszNVuaAEN> LvQVdOcRKczi = new Dictionary<ulong, yiMnwiLrszNVuaAEN>(); private class yiMnwiLrszNVuaAEN { public float IFKqjvXybmID; public int DMhmrrnVKvNem; public long akJrcdwqcuUZ; public BuildingPrivlidge hmtpabplIUjQXuPIlBFjNVPMJLFVo; public List<uint> sXIuBpDbLuyUxjuSqqpnUl = new List<uint>(); public Dictionary<string, float> BqxeHdPCSjIaYcCvbVTWnINaL = null; public Dictionary<string, int> cgbyuoVaBDvaUCsmdsuuUCzMMyHGBr = null; } private static bool tqIKYYnczXoFtEtnl = false; private static Dictionary<ulong, IDEEeyYqtzfzZAaNgzawGG> ghIxMrSwhDBlkgYnCv = new Dictionary<ulong, IDEEeyYqtzfzZAaNgzawGG>(); private class IDEEeyYqtzfzZAaNgzawGG { public int aFJePcIPSmPPltmGcZUQiqXRhOTS; public Dictionary<uint, SbfmlOGavlfz> zcAwbVZDcDRxKRifPv = new Dictionary<uint, SbfmlOGavlfz>(); } private static List<BuildingPrivlidge> VcQBQxmGKPMeQ = new List<BuildingPrivlidge>(); private static string HdBWieoSOUQFlqrjstNvpyGBTqWeu = null; private static Dictionary<ulong, Dictionary<uint, long>> jiFWAzvYGB = new Dictionary<ulong, Dictionary<uint, long>>(); private void Init() { htPGTdfQfJPtdtGTDsLmtGTvpxvxMp(); hMKgDXpDLmRwgZeQomY(); lang.RegisterMessages(BSGpNGGzTyiGKoKEeOyX, this, "en"); permission.RegisterPermission(cdhAlpanRBpDIza, this); foreach (var KTVphBNiUXQhPqyBFsVrWYQHQsi in arYyoRcCywByxnRDoH.byNFtPigVDNuPTqiNFIV) permission.RegisterPermission(KTVphBNiUXQhPqyBFsVrWYQHQsi.Key, this); tqIKYYnczXoFtEtnl = false; if (!string.IsNullOrEmpty(arYyoRcCywByxnRDoH.CommandChatBP)) cmd.AddChatCommand(arYyoRcCywByxnRDoH.CommandChatBP, this, "cmdBP"); oemcSUfxaTkeLYsdBfc(arYyoRcCywByxnRDoH); } private void OnServerInitialized() { jiFWAzvYGB.Clear(); LvQVdOcRKczi.Clear(); ghIxMrSwhDBlkgYnCv.Clear(); VcQBQxmGKPMeQ.Clear(); var vvEAnwcIhrTxhJqKpauTFnXooXcPK = BaseNetworkable.serverEntities.OfType<BaseEntity>().Where(x=> x!=null && !x.IsDestroyed && fFXlNOaDpM.FJblgubrcofQAqy.ContainsKey(x.net.ID) && !fFXlNOaDpM.FJblgubrcofQAqy[x.net.ID].YTyclzzTMPRn).Select(x=> x.net.ID).ToHashSet(); fFXlNOaDpM.FJblgubrcofQAqy = fFXlNOaDpM.FJblgubrcofQAqy.Where(x=> vvEAnwcIhrTxhJqKpauTFnXooXcPK.Contains(x.Key)).ToDictionary(x=> x.Key, x=> x.Value); OfGZZIBPEJVfix(); wqnridXLTCy(); timer.Once(3f, ()=> { foreach (var rsQUZEouKGeITBPkGbMXD in BasePlayer.activePlayerList) OnPlayerInit(rsQUZEouKGeITBPkGbMXD); tOWewrFHkzfVeuwaePTjsDHPRwC(); eKkZkmksdVryKYmLmLJYStVf(); }); } private void OnPlayerInit(BasePlayer rsQUZEouKGeITBPkGbMXD) { if (rsQUZEouKGeITBPkGbMXD == null) return; if (rsQUZEouKGeITBPkGbMXD.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot)) { timer.Once(0.5f, () => OnPlayerInit(rsQUZEouKGeITBPkGbMXD)); return; } if (fFXlNOaDpM.qYRLmeQQhezbQk.ContainsKey(rsQUZEouKGeITBPkGbMXD.userID) && fFXlNOaDpM.qYRLmeQQhezbQk[rsQUZEouKGeITBPkGbMXD.userID].Count() > 0) QxNidWRapMOxAeEJdwWGvy(rsQUZEouKGeITBPkGbMXD); } private void Unload() { OfGZZIBPEJVfix(); foreach (var rsQUZEouKGeITBPkGbMXD in BasePlayer.activePlayerList) { CuiHelper.DestroyUi(rsQUZEouKGeITBPkGbMXD, wWtOepewkLdlEswOdnRSBkTwijOZ); CuiHelper.DestroyUi(rsQUZEouKGeITBPkGbMXD, "IconPanel"); } } private void OnNewSave() { fFXlNOaDpM.FJblgubrcofQAqy.Clear(); fFXlNOaDpM.qYRLmeQQhezbQk.Clear(); OfGZZIBPEJVfix(); } private void OnHammerHit(BasePlayer rsQUZEouKGeITBPkGbMXD, HitInfo info) { if (rsQUZEouKGeITBPkGbMXD == null || info?.HitEntity == null || !permission.UserHasPermission(rsQUZEouKGeITBPkGbMXD.UserIDString, cdhAlpanRBpDIza)) return; if (info.HitEntity is BuildingPrivlidge && (info.HitEntity as BuildingPrivlidge).IsAuthed(rsQUZEouKGeITBPkGbMXD)) { LhObORdPwKeIUEGRhNhGIZ(rsQUZEouKGeITBPkGbMXD, info.HitEntity as BuildingPrivlidge); return; } } private void OnStructureUpgrade(BaseCombatEntity rRhofpSkipGxaeXiPA) { if (rRhofpSkipGxaeXiPA == null || !fFXlNOaDpM.FJblgubrcofQAqy.ContainsKey(rRhofpSkipGxaeXiPA.net.ID)) return; fFXlNOaDpM.FJblgubrcofQAqy[rRhofpSkipGxaeXiPA.net.ID].YTyclzzTMPRn = true; } private void OnEntityTakeDamage(BaseCombatEntity rRhofpSkipGxaeXiPA, HitInfo ucCWTnYiNonwsvvBunNDbG) { if (rRhofpSkipGxaeXiPA == null || ucCWTnYiNonwsvvBunNDbG == null) return; if (!ucCWTnYiNonwsvvBunNDbG.hasDamage || ucCWTnYiNonwsvvBunNDbG.damageTypes == null) return; if (!arYyoRcCywByxnRDoH.zJYkgpJHDSsNREfyHhmjf.Contains(rRhofpSkipGxaeXiPA.ShortPrefabName) && !(rRhofpSkipGxaeXiPA is BuildingBlock)) return; BUfsOpNUJSZIHOKcCKQHsUJEzMn(rRhofpSkipGxaeXiPA, ucCWTnYiNonwsvvBunNDbG); if (!arYyoRcCywByxnRDoH.aYQnBANSjsFGzKOf) return; var rsQUZEouKGeITBPkGbMXD = ucCWTnYiNonwsvvBunNDbG.InitiatorPlayer; var type = ucCWTnYiNonwsvvBunNDbG.damageTypes.GetMajorityDamageType(); if (rsQUZEouKGeITBPkGbMXD != null && rRhofpSkipGxaeXiPA is DecayEntity && type != null && type == DamageType.Explosion && fFXlNOaDpM.FJblgubrcofQAqy.ContainsKey(rRhofpSkipGxaeXiPA.net.ID) && !fFXlNOaDpM.FJblgubrcofQAqy[rRhofpSkipGxaeXiPA.net.ID].YTyclzzTMPRn) { var percent = fFXlNOaDpM.FJblgubrcofQAqy[rRhofpSkipGxaeXiPA.net.ID].aOcKgYsiyGLZqCTJhFXIezcDCh; if (!jiFWAzvYGB.ContainsKey(rsQUZEouKGeITBPkGbMXD.userID)) jiFWAzvYGB.Add(rsQUZEouKGeITBPkGbMXD.userID, new Dictionary<uint, long>()); var buildingID = (rRhofpSkipGxaeXiPA as DecayEntity).buildingID; if (!jiFWAzvYGB[rsQUZEouKGeITBPkGbMXD.userID].ContainsKey(buildingID)) jiFWAzvYGB[rsQUZEouKGeITBPkGbMXD.userID].Add(buildingID, 0); if (InhebQTFJTvv(DateTime.Now) - (jiFWAzvYGB[rsQUZEouKGeITBPkGbMXD.userID])[buildingID] > arYyoRcCywByxnRDoH.XsYIeQxdlMoJqCssCQzljApcGdtG) { SendReply(rsQUZEouKGeITBPkGbMXD, string.Format(qAtenYuUiJYoqqKQCAecaaWAFdE("INFO.BUILDING.PROTECTED", rsQUZEouKGeITBPkGbMXD.userID), percent)); (jiFWAzvYGB[rsQUZEouKGeITBPkGbMXD.userID])[buildingID] = InhebQTFJTvv(DateTime.Now); } } } private void OnEntityKill(BaseEntity rRhofpSkipGxaeXiPA) { if (rRhofpSkipGxaeXiPA != null && rRhofpSkipGxaeXiPA is BuildingPrivlidge) { var cupboard = rRhofpSkipGxaeXiPA as BuildingPrivlidge; foreach (var player_ in cupboard.authorizedPlayers) { var rsQUZEouKGeITBPkGbMXD = BasePlayer.FindByID(player_.userid); if (rsQUZEouKGeITBPkGbMXD == null || !(rsQUZEouKGeITBPkGbMXD.GetBuildingPrivilege() == cupboard)) continue; CuiHelper.DestroyUi(rsQUZEouKGeITBPkGbMXD, wWtOepewkLdlEswOdnRSBkTwijOZ); } } } private void cmdBP(BasePlayer rsQUZEouKGeITBPkGbMXD, string ZlEandkYxKDZZZIovjiteHiSq, string[] args) { if (rsQUZEouKGeITBPkGbMXD == null || !permission.UserHasPermission(rsQUZEouKGeITBPkGbMXD.UserIDString, cdhAlpanRBpDIza)) return; var buildingPrivilege = rsQUZEouKGeITBPkGbMXD.GetBuildingPrivilege(); if (buildingPrivilege != null && buildingPrivilege.IsAuthed(rsQUZEouKGeITBPkGbMXD)) LhObORdPwKeIUEGRhNhGIZ(rsQUZEouKGeITBPkGbMXD, buildingPrivilege); else SendReply(rsQUZEouKGeITBPkGbMXD, string.Format(qAtenYuUiJYoqqKQCAecaaWAFdE("INFO.NO_CUP_AUTH", rsQUZEouKGeITBPkGbMXD.userID))); } private void tOWewrFHkzfVeuwaePTjsDHPRwC() { if (!tqIKYYnczXoFtEtnl) { var ZYFonMvxvVHtMnLym = InhebQTFJTvv(DateTime.Now); var GAWUomUyukxbdPMLFrvznF = new Dictionary<uint, SbfmlOGavlfz>(); foreach(var KTVphBNiUXQhPqyBFsVrWYQHQsi in fFXlNOaDpM.FJblgubrcofQAqy) if ((KTVphBNiUXQhPqyBFsVrWYQHQsi.Value.EGNIlRsVsdVdQSMNvcyj - ZYFonMvxvVHtMnLym) >= 0) GAWUomUyukxbdPMLFrvznF.Add(KTVphBNiUXQhPqyBFsVrWYQHQsi.Key, KTVphBNiUXQhPqyBFsVrWYQHQsi.Value); if (fFXlNOaDpM.FJblgubrcofQAqy.Count() != GAWUomUyukxbdPMLFrvznF.Count()) { try { fFXlNOaDpM.FJblgubrcofQAqy = GAWUomUyukxbdPMLFrvznF; OfGZZIBPEJVfix(); } catch{} } } timer.Once(60f, tOWewrFHkzfVeuwaePTjsDHPRwC); } private void eKkZkmksdVryKYmLmLJYStVf(ulong zgLClBAOijWQCyL = 0) { var QDHOzQxXyjz = false; var NwuosurZoWyaHwSrspluLxcgzUCPl = InhebQTFJTvv(DateTime.Now); foreach (var KTVphBNiUXQhPqyBFsVrWYQHQsi in fFXlNOaDpM.qYRLmeQQhezbQk.ToDictionary(x=> x.Key, x=> x.Value)) { if (zgLClBAOijWQCyL != 0 && zgLClBAOijWQCyL != KTVphBNiUXQhPqyBFsVrWYQHQsi.Key) continue; var rsQUZEouKGeITBPkGbMXD = BasePlayer.FindByID(KTVphBNiUXQhPqyBFsVrWYQHQsi.Key); if (rsQUZEouKGeITBPkGbMXD == null) continue; if (KTVphBNiUXQhPqyBFsVrWYQHQsi.Value.Count() == 0) { CuiHelper.DestroyUi(rsQUZEouKGeITBPkGbMXD, "IconPanel"); fFXlNOaDpM.qYRLmeQQhezbQk.Remove(KTVphBNiUXQhPqyBFsVrWYQHQsi.Key); QDHOzQxXyjz = true; continue; } else { if (!ghIxMrSwhDBlkgYnCv.ContainsKey(KTVphBNiUXQhPqyBFsVrWYQHQsi.Key)) ghIxMrSwhDBlkgYnCv.Add(KTVphBNiUXQhPqyBFsVrWYQHQsi.Key, new IDEEeyYqtzfzZAaNgzawGG()); else { ghIxMrSwhDBlkgYnCv[KTVphBNiUXQhPqyBFsVrWYQHQsi.Key].aFJePcIPSmPPltmGcZUQiqXRhOTS++; if (ghIxMrSwhDBlkgYnCv[KTVphBNiUXQhPqyBFsVrWYQHQsi.Key].aFJePcIPSmPPltmGcZUQiqXRhOTS+1 > KTVphBNiUXQhPqyBFsVrWYQHQsi.Value.Count()) ghIxMrSwhDBlkgYnCv[KTVphBNiUXQhPqyBFsVrWYQHQsi.Key].aFJePcIPSmPPltmGcZUQiqXRhOTS = 0; } var otFWnSlOJn = eYUvlfadCaYToFINsWmKbMIE(KTVphBNiUXQhPqyBFsVrWYQHQsi.Value[ghIxMrSwhDBlkgYnCv[KTVphBNiUXQhPqyBFsVrWYQHQsi.Key].aFJePcIPSmPPltmGcZUQiqXRhOTS]); if (otFWnSlOJn == null || !otFWnSlOJn.IsAuthed(rsQUZEouKGeITBPkGbMXD)) { fFXlNOaDpM.qYRLmeQQhezbQk[KTVphBNiUXQhPqyBFsVrWYQHQsi.Key].Remove(KTVphBNiUXQhPqyBFsVrWYQHQsi.Value[ghIxMrSwhDBlkgYnCv[KTVphBNiUXQhPqyBFsVrWYQHQsi.Key].aFJePcIPSmPPltmGcZUQiqXRhOTS]); QDHOzQxXyjz = true; continue; } if (!ghIxMrSwhDBlkgYnCv[KTVphBNiUXQhPqyBFsVrWYQHQsi.Key].zcAwbVZDcDRxKRifPv.ContainsKey(otFWnSlOJn.net.ID)) { var info = mDEgmsqMtmPdHMkyijNXh(otFWnSlOJn); if (info != null) ghIxMrSwhDBlkgYnCv[KTVphBNiUXQhPqyBFsVrWYQHQsi.Key].zcAwbVZDcDRxKRifPv.Add(otFWnSlOJn.net.ID, info); else { fFXlNOaDpM.qYRLmeQQhezbQk[KTVphBNiUXQhPqyBFsVrWYQHQsi.Key].Remove(KTVphBNiUXQhPqyBFsVrWYQHQsi.Value[ghIxMrSwhDBlkgYnCv[KTVphBNiUXQhPqyBFsVrWYQHQsi.Key].aFJePcIPSmPPltmGcZUQiqXRhOTS]); QDHOzQxXyjz = true; continue; } } var ItHQJBPTwYqtsxqaLKHtmgFjppu = ghIxMrSwhDBlkgYnCv[KTVphBNiUXQhPqyBFsVrWYQHQsi.Key].zcAwbVZDcDRxKRifPv[otFWnSlOJn.net.ID].EGNIlRsVsdVdQSMNvcyj - NwuosurZoWyaHwSrspluLxcgzUCPl; if (ItHQJBPTwYqtsxqaLKHtmgFjppu <= 0) { fFXlNOaDpM.qYRLmeQQhezbQk[KTVphBNiUXQhPqyBFsVrWYQHQsi.Key].Remove(KTVphBNiUXQhPqyBFsVrWYQHQsi.Value[ghIxMrSwhDBlkgYnCv[KTVphBNiUXQhPqyBFsVrWYQHQsi.Key].aFJePcIPSmPPltmGcZUQiqXRhOTS]); QDHOzQxXyjz = true; continue; } ePOrSDyGJhsFlWJeNW(rsQUZEouKGeITBPkGbMXD, ItHQJBPTwYqtsxqaLKHtmgFjppu, ghIxMrSwhDBlkgYnCv[KTVphBNiUXQhPqyBFsVrWYQHQsi.Key].zcAwbVZDcDRxKRifPv[otFWnSlOJn.net.ID].aOcKgYsiyGLZqCTJhFXIezcDCh, KTVphBNiUXQhPqyBFsVrWYQHQsi.Value.Count()==1 ? 0 : ghIxMrSwhDBlkgYnCv[KTVphBNiUXQhPqyBFsVrWYQHQsi.Key].aFJePcIPSmPPltmGcZUQiqXRhOTS+1); } } if (QDHOzQxXyjz) OfGZZIBPEJVfix(); if (zgLClBAOijWQCyL == 0) timer.Once(10f, ()=> eKkZkmksdVryKYmLmLJYStVf()); } private static void BUfsOpNUJSZIHOKcCKQHsUJEzMn(BaseCombatEntity rRhofpSkipGxaeXiPA, HitInfo ucCWTnYiNonwsvvBunNDbG) { if (!fFXlNOaDpM.FJblgubrcofQAqy.ContainsKey(rRhofpSkipGxaeXiPA.net.ID) || fFXlNOaDpM.FJblgubrcofQAqy[rRhofpSkipGxaeXiPA.net.ID].YTyclzzTMPRn) return; for (int i = 0; i < (int)ucCWTnYiNonwsvvBunNDbG.damageTypes.types.Length; i++) { float poQTGsJYMxEO = ucCWTnYiNonwsvvBunNDbG.damageTypes.types[i]; if (!float.IsNaN(poQTGsJYMxEO) && !float.IsInfinity(poQTGsJYMxEO) && poQTGsJYMxEO > 0) ucCWTnYiNonwsvvBunNDbG.damageTypes.Scale((DamageType)i, 1f - fFXlNOaDpM.FJblgubrcofQAqy[rRhofpSkipGxaeXiPA.net.ID].aOcKgYsiyGLZqCTJhFXIezcDCh/100f); } } private yiMnwiLrszNVuaAEN BzKAnZYXmLCnkMT(BasePlayer rsQUZEouKGeITBPkGbMXD, BuildingPrivlidge otFWnSlOJn) { var HXuvdmXlkA = new yiMnwiLrszNVuaAEN(); float wJLtiFZeqrdzfhizmsJtC = 1f; foreach (var KTVphBNiUXQhPqyBFsVrWYQHQsi in arYyoRcCywByxnRDoH.byNFtPigVDNuPTqiNFIV.OrderBy(x=> x.Value)) { if (permission.UserHasPermission(rsQUZEouKGeITBPkGbMXD.UserIDString, KTVphBNiUXQhPqyBFsVrWYQHQsi.Key)) { wJLtiFZeqrdzfhizmsJtC = KTVphBNiUXQhPqyBFsVrWYQHQsi.Value; break; } } HXuvdmXlkA.IFKqjvXybmID = arYyoRcCywByxnRDoH.YxdtJNemecgyegrsApTAmpUD; HXuvdmXlkA.DMhmrrnVKvNem = arYyoRcCywByxnRDoH.yczkCuQTZObFoEWVhjRmSgl; HXuvdmXlkA.BqxeHdPCSjIaYcCvbVTWnINaL = nqiFvQMDORsHzmUKBAlo(otFWnSlOJn, wJLtiFZeqrdzfhizmsJtC); HXuvdmXlkA.cgbyuoVaBDvaUCsmdsuuUCzMMyHGBr = WqXXsuHvgzivATTcwWqCOCQTefp(rsQUZEouKGeITBPkGbMXD, HXuvdmXlkA.BqxeHdPCSjIaYcCvbVTWnINaL.Keys.ToList()); HXuvdmXlkA.sXIuBpDbLuyUxjuSqqpnUl = EqwlSCWRVetitFa(otFWnSlOJn); HXuvdmXlkA.hmtpabplIUjQXuPIlBFjNVPMJLFVo = otFWnSlOJn; return HXuvdmXlkA; } private static bool COmXKLxhnkQjVNVhZwKlO(BasePlayer rsQUZEouKGeITBPkGbMXD) { LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].cgbyuoVaBDvaUCsmdsuuUCzMMyHGBr = WqXXsuHvgzivATTcwWqCOCQTefp(rsQUZEouKGeITBPkGbMXD, LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].BqxeHdPCSjIaYcCvbVTWnINaL.Keys.ToList()); foreach(var KTVphBNiUXQhPqyBFsVrWYQHQsi in LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].BqxeHdPCSjIaYcCvbVTWnINaL) { int lEDOXXSrPzNucCh = LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].cgbyuoVaBDvaUCsmdsuuUCzMMyHGBr.ContainsKey(KTVphBNiUXQhPqyBFsVrWYQHQsi.Key) ? LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].cgbyuoVaBDvaUCsmdsuuUCzMMyHGBr[KTVphBNiUXQhPqyBFsVrWYQHQsi.Key] : 0; int NVHNJunIxMNkFSNCdJWKcPSGTf = (int)Math.Round(KTVphBNiUXQhPqyBFsVrWYQHQsi.Value * LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].IFKqjvXybmID * LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].DMhmrrnVKvNem * SqAOwudNaQicEIczNJ(LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].IFKqjvXybmID) * qDanDNfhirdFKwyOVJnIOBVW(LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].DMhmrrnVKvNem)); if (NVHNJunIxMNkFSNCdJWKcPSGTf < 1) NVHNJunIxMNkFSNCdJWKcPSGTf = 1; if (lEDOXXSrPzNucCh < NVHNJunIxMNkFSNCdJWKcPSGTf) return false; } return true; } private static void eYBjRpbrPjzttOHVuFwllpjVtVf(BasePlayer rsQUZEouKGeITBPkGbMXD) { foreach(var KTVphBNiUXQhPqyBFsVrWYQHQsi in LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].BqxeHdPCSjIaYcCvbVTWnINaL) { int NVHNJunIxMNkFSNCdJWKcPSGTf = (int)Math.Round(KTVphBNiUXQhPqyBFsVrWYQHQsi.Value * LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].IFKqjvXybmID * LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].DMhmrrnVKvNem * SqAOwudNaQicEIczNJ(LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].IFKqjvXybmID) * qDanDNfhirdFKwyOVJnIOBVW(LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].DMhmrrnVKvNem)); if (NVHNJunIxMNkFSNCdJWKcPSGTf < 1) NVHNJunIxMNkFSNCdJWKcPSGTf = 1; var ZmiKzmpwnjjSvGWDKdxoAcCd = ItemManager.FindItemDefinition(KTVphBNiUXQhPqyBFsVrWYQHQsi.Key); if (ZmiKzmpwnjjSvGWDKdxoAcCd == null) continue; rsQUZEouKGeITBPkGbMXD.inventory.Take(rsQUZEouKGeITBPkGbMXD.inventory.AllItems().ToList(), ZmiKzmpwnjjSvGWDKdxoAcCd.itemid, NVHNJunIxMNkFSNCdJWKcPSGTf); } } private static string tRONBEbkJWOJUIpKaLfxXOFTIl(string qbIhAMtgvDRcLgBkKgBBWwCGVHZ) { if (arYyoRcCywByxnRDoH.uekIFKWiDT.ContainsKey(qbIhAMtgvDRcLgBkKgBBWwCGVHZ)) return arYyoRcCywByxnRDoH.uekIFKWiDT[qbIhAMtgvDRcLgBkKgBBWwCGVHZ]; return qbIhAMtgvDRcLgBkKgBBWwCGVHZ; } private static BuildingPrivlidge eYUvlfadCaYToFINsWmKbMIE(uint HhzrRtMSZEffWiLtOZtcFEIUdHUN) { var otFWnSlOJn = VcQBQxmGKPMeQ.FirstOrDefault(x=> x != null && x.net.ID == HhzrRtMSZEffWiLtOZtcFEIUdHUN); if (otFWnSlOJn == null) { var rRhofpSkipGxaeXiPA = BaseNetworkable.serverEntities.OfType<BuildingPrivlidge>().FirstOrDefault(x=> x != null && x.net.ID == HhzrRtMSZEffWiLtOZtcFEIUdHUN); if (rRhofpSkipGxaeXiPA != null) { VcQBQxmGKPMeQ.Add(rRhofpSkipGxaeXiPA); return rRhofpSkipGxaeXiPA; } } return otFWnSlOJn; } private static List<uint> EqwlSCWRVetitFa(BuildingPrivlidge otFWnSlOJn) { if (otFWnSlOJn == null) return null; var QWXrayHoIKlhgTVUddFINivvTmD = otFWnSlOJn.GetBuilding(); if (QWXrayHoIKlhgTVUddFINivvTmD == null || !QWXrayHoIKlhgTVUddFINivvTmD.HasDecayEntities()) return null; var hoGyBYUrjVZddFNzNwQbpG = QWXrayHoIKlhgTVUddFINivvTmD.decayEntities.Where(x=> x!=null && !x.IsDestroyed && (arYyoRcCywByxnRDoH.zJYkgpJHDSsNREfyHhmjf.Contains(x.ShortPrefabName) || x is BuildingBlock)).Select(x=> x.net.ID).ToList(); if (arYyoRcCywByxnRDoH.zJYkgpJHDSsNREfyHhmjf.Contains(otFWnSlOJn.ShortPrefabName) && !hoGyBYUrjVZddFNzNwQbpG.Contains(otFWnSlOJn.net.ID)) hoGyBYUrjVZddFNzNwQbpG.Add(otFWnSlOJn.net.ID); return hoGyBYUrjVZddFNzNwQbpG; } private static int jTlQhHaDAKWrPKUxCqoPYwcvcHMG(BuildingPrivlidge otFWnSlOJn) { if (otFWnSlOJn == null) return 0; var QWXrayHoIKlhgTVUddFINivvTmD = otFWnSlOJn.GetBuilding(); if (QWXrayHoIKlhgTVUddFINivvTmD == null || !QWXrayHoIKlhgTVUddFINivvTmD.HasDecayEntities()) return 0; return QWXrayHoIKlhgTVUddFINivvTmD.decayEntities.Where(x=> x != null && !x.IsDestroyed && x is BuildingBlock).Count(); } private static Dictionary<string, float> NJoZKpUkwFhUVQBfVoNCWTeNIIuo(BuildingPrivlidge otFWnSlOJn) { if (otFWnSlOJn == null) return null; var QWXrayHoIKlhgTVUddFINivvTmD = otFWnSlOJn.GetBuilding(); if (QWXrayHoIKlhgTVUddFINivvTmD == null || !QWXrayHoIKlhgTVUddFINivvTmD.HasDecayEntities()) return null; var ImwfwgclypBuaZTcPVTQu = QWXrayHoIKlhgTVUddFINivvTmD.decayEntities.Where(x=> x!=null && !x.IsDestroyed && (arYyoRcCywByxnRDoH.zJYkgpJHDSsNREfyHhmjf.Contains(x.ShortPrefabName) || x is BuildingBlock)).ToList(); if (arYyoRcCywByxnRDoH.zJYkgpJHDSsNREfyHhmjf.Contains(otFWnSlOJn.ShortPrefabName) && !ImwfwgclypBuaZTcPVTQu.Contains(otFWnSlOJn as DecayEntity)) ImwfwgclypBuaZTcPVTQu.Add(otFWnSlOJn as DecayEntity); var HXuvdmXlkA = new Dictionary<string, float>(); foreach(var NNYVXXAhbrTmNRafLHNbYe in ImwfwgclypBuaZTcPVTQu) { var SOxGbCahIOb = NNYVXXAhbrTmNRafLHNbYe.BuildCost(); if (SOxGbCahIOb == null) continue; foreach (ItemAmount itemAmount in SOxGbCahIOb) { if (itemAmount.itemDef.category != ItemCategory.Resources) continue; if (!HXuvdmXlkA.ContainsKey(itemAmount.itemDef.shortname)) HXuvdmXlkA.Add(itemAmount.itemDef.shortname, 0); HXuvdmXlkA[itemAmount.itemDef.shortname] += itemAmount.amount; } } return HXuvdmXlkA; } private static Dictionary<string, float> nqiFvQMDORsHzmUKBAlo(BuildingPrivlidge otFWnSlOJn, float wJLtiFZeqrdzfhizmsJtC) { if (otFWnSlOJn == null) return null; var yNBOgvVauStjFZTQHp = NJoZKpUkwFhUVQBfVoNCWTeNIIuo(otFWnSlOJn); if (yNBOgvVauStjFZTQHp == null) return null; var HXuvdmXlkA = new Dictionary<string, float>(); int zRihVLkJkTAEwOMaHzNYBEbhAIJ = jTlQhHaDAKWrPKUxCqoPYwcvcHMG(otFWnSlOJn); float bmRIjLEVVC = 1f; foreach (var KTVphBNiUXQhPqyBFsVrWYQHQsi in arYyoRcCywByxnRDoH.udJYCpbEzuJHHiaBgHiIjGVDRW.OrderByDescending(x=> x.Key)) { if (zRihVLkJkTAEwOMaHzNYBEbhAIJ >= KTVphBNiUXQhPqyBFsVrWYQHQsi.Key) { bmRIjLEVVC = KTVphBNiUXQhPqyBFsVrWYQHQsi.Value; break; } } foreach (var KTVphBNiUXQhPqyBFsVrWYQHQsi in yNBOgvVauStjFZTQHp) { if (KTVphBNiUXQhPqyBFsVrWYQHQsi.Value <= 0f) continue; if (arYyoRcCywByxnRDoH.UyCiuPAVpIePcZqusTn.ContainsKey(KTVphBNiUXQhPqyBFsVrWYQHQsi.Key)) { if (arYyoRcCywByxnRDoH.UyCiuPAVpIePcZqusTn[KTVphBNiUXQhPqyBFsVrWYQHQsi.Key].XbTLPuZbhqqvJWRfrC > 0f) { var amount = KTVphBNiUXQhPqyBFsVrWYQHQsi.Value * arYyoRcCywByxnRDoH.UyCiuPAVpIePcZqusTn[KTVphBNiUXQhPqyBFsVrWYQHQsi.Key].XbTLPuZbhqqvJWRfrC * (arYyoRcCywByxnRDoH.FyFSbfbFsugNCQPEcTYwgViqXvNJYM/100f) * bmRIjLEVVC * wJLtiFZeqrdzfhizmsJtC; if (!HXuvdmXlkA.ContainsKey(arYyoRcCywByxnRDoH.UyCiuPAVpIePcZqusTn[KTVphBNiUXQhPqyBFsVrWYQHQsi.Key].JDcZYhDHxYvDE)) HXuvdmXlkA.Add(arYyoRcCywByxnRDoH.UyCiuPAVpIePcZqusTn[KTVphBNiUXQhPqyBFsVrWYQHQsi.Key].JDcZYhDHxYvDE, amount); else HXuvdmXlkA[arYyoRcCywByxnRDoH.UyCiuPAVpIePcZqusTn[KTVphBNiUXQhPqyBFsVrWYQHQsi.Key].JDcZYhDHxYvDE] += amount; } } else { var amount = KTVphBNiUXQhPqyBFsVrWYQHQsi.Value * (arYyoRcCywByxnRDoH.FyFSbfbFsugNCQPEcTYwgViqXvNJYM/100f) * bmRIjLEVVC * wJLtiFZeqrdzfhizmsJtC; HXuvdmXlkA.Add(KTVphBNiUXQhPqyBFsVrWYQHQsi.Key, amount); } } return HXuvdmXlkA; } private static Dictionary<string, int> WqXXsuHvgzivATTcwWqCOCQTefp(BasePlayer rsQUZEouKGeITBPkGbMXD, List<string> yNBOgvVauStjFZTQHp) { var HXuvdmXlkA = new Dictionary<string, int>(); foreach(var tkoUfvoMaSzHYQFKIBIFpzdeD in rsQUZEouKGeITBPkGbMXD.inventory.AllItems().Where(x=> yNBOgvVauStjFZTQHp.Contains(x.info.shortname))) { if (!HXuvdmXlkA.ContainsKey(tkoUfvoMaSzHYQFKIBIFpzdeD.info.shortname)) HXuvdmXlkA.Add(tkoUfvoMaSzHYQFKIBIFpzdeD.info.shortname, 0); HXuvdmXlkA[tkoUfvoMaSzHYQFKIBIFpzdeD.info.shortname] += tkoUfvoMaSzHYQFKIBIFpzdeD.amount; } return HXuvdmXlkA; } private static SbfmlOGavlfz mDEgmsqMtmPdHMkyijNXh(BuildingPrivlidge otFWnSlOJn) { if (otFWnSlOJn == null) return null; var uJeQYaSiWSdjQAP = EqwlSCWRVetitFa(otFWnSlOJn); if (uJeQYaSiWSdjQAP?.Count() == 0) return null; var NNYVXXAhbrTmNRafLHNbYe = fFXlNOaDpM.FJblgubrcofQAqy.Where(x=> uJeQYaSiWSdjQAP.Contains(x.Key)).OrderBy(x=> x.Value.aOcKgYsiyGLZqCTJhFXIezcDCh).FirstOrDefault(); return NNYVXXAhbrTmNRafLHNbYe.Value; } private static string OSrYzuFgFTkfFqBa(BasePlayer rsQUZEouKGeITBPkGbMXD, uint HhzrRtMSZEffWiLtOZtcFEIUdHUN) { if (!fFXlNOaDpM.qYRLmeQQhezbQk.ContainsKey(rsQUZEouKGeITBPkGbMXD.userID)) return vBvxkHaTFkygGpYQwuzSUq; if (fFXlNOaDpM.qYRLmeQQhezbQk[rsQUZEouKGeITBPkGbMXD.userID].Contains(HhzrRtMSZEffWiLtOZtcFEIUdHUN)) return nwVBCplpXvAaIKSWWs; return vBvxkHaTFkygGpYQwuzSUq; } private static string rYVUpJTmdVGiBKbsinI(string QFQHXJdKeKegjOOZOk) { try { var mAVIEfiWcF = QFQHXJdKeKegjOOZOk.Split(' '); var r = (int)Math.Round(Convert.ToSingle(mAVIEfiWcF[0]) * 255f); var g = (int)Math.Round(Convert.ToSingle(mAVIEfiWcF[1]) * 255f); var b = (int)Math.Round(Convert.ToSingle(mAVIEfiWcF[2]) * 255f); return "#" + r.ToString("X2") + g.ToString("X2") + b.ToString("X2"); } catch { } return "white"; } private static string uOHCcqPxmfWsehkREbRbYiLcLbDogq(int gkIssEuBsqKimzuwjfPmPlBO, bool VgTBBdpHZiLS = false) { string QFQHXJdKeKegjOOZOk = VgTBBdpHZiLS ? rYVUpJTmdVGiBKbsinI(arYyoRcCywByxnRDoH.SbbdVbbCRU) : "white"; return $"<color={QFQHXJdKeKegjOOZOk}>" + gkIssEuBsqKimzuwjfPmPlBO.ToString("#,##0").Replace(",","'") + "</color>"; } private string WlRJiciKvTk(long ItHQJBPTwYqtsxqaLKHtmgFjppu, bool ipfLaKxcVLKDNMGVYcsN, ulong zgLClBAOijWQCyL) { var zsAfnJpOqMuHnmsxqLKnhtLJOb = (int)Math.Truncate(ItHQJBPTwYqtsxqaLKHtmgFjppu / 3600f); var paPuCJCTaOfQhAXLlbL = (int)Math.Floor(ItHQJBPTwYqtsxqaLKHtmgFjppu / 60f - zsAfnJpOqMuHnmsxqLKnhtLJOb * 60f); if (!ipfLaKxcVLKDNMGVYcsN) { var UIjduEOLQUZxoivELTwHEg = new List<string>() { qAtenYuUiJYoqqKQCAecaaWAFdE("MINUTE1", zgLClBAOijWQCyL), qAtenYuUiJYoqqKQCAecaaWAFdE("MINUTES1", zgLClBAOijWQCyL), qAtenYuUiJYoqqKQCAecaaWAFdE("MINUTES2", zgLClBAOijWQCyL) }; var AOjyXNGAsCfqDWxs = $@"{CRHvtuviAlBWexqFvfnuVzlN(paPuCJCTaOfQhAXLlbL, UIjduEOLQUZxoivELTwHEg)}"; var JMJhhClEvs = new List<string>() { qAtenYuUiJYoqqKQCAecaaWAFdE("HOUR", zgLClBAOijWQCyL), qAtenYuUiJYoqqKQCAecaaWAFdE("HOURS1", zgLClBAOijWQCyL), qAtenYuUiJYoqqKQCAecaaWAFdE("HOURS2", zgLClBAOijWQCyL) }; return (zsAfnJpOqMuHnmsxqLKnhtLJOb > 0 ? $@"{CRHvtuviAlBWexqFvfnuVzlN(zsAfnJpOqMuHnmsxqLKnhtLJOb, JMJhhClEvs)}" : "") + (paPuCJCTaOfQhAXLlbL > 0 ? ((zsAfnJpOqMuHnmsxqLKnhtLJOb > 0 ? " " : "") + AOjyXNGAsCfqDWxs) : (zsAfnJpOqMuHnmsxqLKnhtLJOb == 0 ? $@"1 {qAtenYuUiJYoqqKQCAecaaWAFdE("MINUTE2", zgLClBAOijWQCyL)}" : "")); } return (zsAfnJpOqMuHnmsxqLKnhtLJOb > 0 ? $@"{zsAfnJpOqMuHnmsxqLKnhtLJOb}{qAtenYuUiJYoqqKQCAecaaWAFdE("HOUR", zgLClBAOijWQCyL)[0]}" : "") + (paPuCJCTaOfQhAXLlbL > 0 ? ((zsAfnJpOqMuHnmsxqLKnhtLJOb > 0 ? " " : "") + $@"{paPuCJCTaOfQhAXLlbL}{qAtenYuUiJYoqqKQCAecaaWAFdE("MINUTE1", zgLClBAOijWQCyL)[0]}") : (zsAfnJpOqMuHnmsxqLKnhtLJOb == 0 ? $@"1{qAtenYuUiJYoqqKQCAecaaWAFdE("MINUTE1", zgLClBAOijWQCyL)[0]}" : "")); } private bool pvSHSIlKRTxJVheYbWvraKzZlb(BasePlayer rsQUZEouKGeITBPkGbMXD) { if (NoEscape == null) return false; try { var MGXoTdfCHcEOO = NoEscape.Call("ApiGetTime", rsQUZEouKGeITBPkGbMXD.userID); if (MGXoTdfCHcEOO != null && (MGXoTdfCHcEOO is int || MGXoTdfCHcEOO is float || MGXoTdfCHcEOO is long || MGXoTdfCHcEOO is double || MGXoTdfCHcEOO is uint || MGXoTdfCHcEOO is ulong)) { if (Convert.ToInt64(MGXoTdfCHcEOO) > 0) { SendReply(rsQUZEouKGeITBPkGbMXD, string.Format(qAtenYuUiJYoqqKQCAecaaWAFdE("NOESCAPE.WARNING", rsQUZEouKGeITBPkGbMXD.userID), MGXoTdfCHcEOO)); return true; } } } catch { PrintWarning(qAtenYuUiJYoqqKQCAecaaWAFdE("NOESCAPE.CALL.ERROR")); } return false; } private static float SqAOwudNaQicEIczNJ(float rczTOzbQCSssCKOtewRdMniA) { var HXuvdmXlkA = 1f; for (int KnMPpJaftz = 0; KnMPpJaftz < (int)Math.Round(rczTOzbQCSssCKOtewRdMniA / arYyoRcCywByxnRDoH.vgxvQdfehcBa); KnMPpJaftz++ ) HXuvdmXlkA *= arYyoRcCywByxnRDoH.yIUmCjgDLih; return HXuvdmXlkA; } private static float qDanDNfhirdFKwyOVJnIOBVW(int zsAfnJpOqMuHnmsxqLKnhtLJOb) { var HXuvdmXlkA = 1f; for (int KnMPpJaftz = 0; KnMPpJaftz < zsAfnJpOqMuHnmsxqLKnhtLJOb; KnMPpJaftz++ ) HXuvdmXlkA *= arYyoRcCywByxnRDoH.PTAxFMEoLPvdmSJKR; return HXuvdmXlkA; } private const string wWtOepewkLdlEswOdnRSBkTwijOZ = "BPPanel"; private void LhObORdPwKeIUEGRhNhGIZ(BasePlayer rsQUZEouKGeITBPkGbMXD, BuildingPrivlidge otFWnSlOJn) { if (rsQUZEouKGeITBPkGbMXD == null || otFWnSlOJn == null) return; var cHGqPsCQncUbNPzmtPLVUEDFSA = mDEgmsqMtmPdHMkyijNXh(otFWnSlOJn); if (cHGqPsCQncUbNPzmtPLVUEDFSA != null) OhqCnOHANvflgxsQ(rsQUZEouKGeITBPkGbMXD, cHGqPsCQncUbNPzmtPLVUEDFSA, otFWnSlOJn); else { if (!pvSHSIlKRTxJVheYbWvraKzZlb(rsQUZEouKGeITBPkGbMXD)) { LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID] = BzKAnZYXmLCnkMT(rsQUZEouKGeITBPkGbMXD, otFWnSlOJn); icBUZELCuDhodqtVQZXlAgguvyMSR(rsQUZEouKGeITBPkGbMXD); } } } private void OhqCnOHANvflgxsQ(BasePlayer rsQUZEouKGeITBPkGbMXD, SbfmlOGavlfz cHGqPsCQncUbNPzmtPLVUEDFSA, BuildingPrivlidge otFWnSlOJn) { if (rsQUZEouKGeITBPkGbMXD == null || otFWnSlOJn == null) return; var DbSgKCHPUQoVDyWKaQo = new CuiElementContainer(); NymUWdVgVR(ref DbSgKCHPUQoVDyWKaQo, arYyoRcCywByxnRDoH.gqYWyqIPghYShSuRHooLlhtnT, "0.35 0.2", "0.65 0.8"); fiNfTratapNQOTqKQ(ref DbSgKCHPUQoVDyWKaQo, arYyoRcCywByxnRDoH.PzLkaNIXiEoXsobwBBhcelYZw, "0 0.92", "1 1"); tguGYRpxXjTCnTsTDTBoyms(ref DbSgKCHPUQoVDyWKaQo, arYyoRcCywByxnRDoH.wGvRZXoWPQvBgkfDEzugQDgXBJFJ, "X", 20, "0.90 0.92", "1 1", "bp_12345.close", "permanentmarker.ttf"); dVEBunTpLpLSAABaIpelmVbA(ref DbSgKCHPUQoVDyWKaQo, qAtenYuUiJYoqqKQCAecaaWAFdE("TITLE.REMIND.MSG", rsQUZEouKGeITBPkGbMXD.userID), 18, "0.03 0.92", "0.89 1", TextAnchor.MiddleLeft); var ItHQJBPTwYqtsxqaLKHtmgFjppu = WlRJiciKvTk(cHGqPsCQncUbNPzmtPLVUEDFSA.EGNIlRsVsdVdQSMNvcyj - InhebQTFJTvv(DateTime.Now), false, rsQUZEouKGeITBPkGbMXD.userID); var LQfeSVZcfE = string.Format(qAtenYuUiJYoqqKQCAecaaWAFdE("REMIND.HOME_PROTECT.MSG", rsQUZEouKGeITBPkGbMXD.userID), cHGqPsCQncUbNPzmtPLVUEDFSA.aOcKgYsiyGLZqCTJhFXIezcDCh, ItHQJBPTwYqtsxqaLKHtmgFjppu); dVEBunTpLpLSAABaIpelmVbA(ref DbSgKCHPUQoVDyWKaQo, LQfeSVZcfE, 18, "0.07 0.5", "0.93 0.9", TextAnchor.MiddleLeft); var nbISGJVvNVOeobGihxpXllme = 0.05f; var kCsGayUwykszKK = 0.525f; tguGYRpxXjTCnTsTDTBoyms(ref DbSgKCHPUQoVDyWKaQo, "1 1 1 0", OSrYzuFgFTkfFqBa(rsQUZEouKGeITBPkGbMXD, otFWnSlOJn.net.ID), 18, $"{nbISGJVvNVOeobGihxpXllme-0.02} {0.55-0.08}", $"{0.15} {0.53}", $"bp_12345.toggleicon {otFWnSlOJn.net.ID}", "robotocondensed-regular.ttf", TextAnchor.MiddleCenter, wWtOepewkLdlEswOdnRSBkTwijOZ, wWtOepewkLdlEswOdnRSBkTwijOZ + "_toggle_icon"); dVEBunTpLpLSAABaIpelmVbA(ref DbSgKCHPUQoVDyWKaQo, qAtenYuUiJYoqqKQCAecaaWAFdE("REMIND.CHECK_TOGGLE.MSG", rsQUZEouKGeITBPkGbMXD.userID), 18, $"{0.16} {0.45-0.04}", $"{0.4+kCsGayUwykszKK} {0.55}", TextAnchor.MiddleLeft); tguGYRpxXjTCnTsTDTBoyms(ref DbSgKCHPUQoVDyWKaQo, arYyoRcCywByxnRDoH.BkHejxOINcSUOzjmiWDahxLg, qAtenYuUiJYoqqKQCAecaaWAFdE("BUTTON.APPLY", rsQUZEouKGeITBPkGbMXD.userID), 18, $"{0.02+nbISGJVvNVOeobGihxpXllme} {0.15-0.08}", $"{0.4+kCsGayUwykszKK} {0.15}", "bp_12345.close"); CuiHelper.DestroyUi(rsQUZEouKGeITBPkGbMXD, wWtOepewkLdlEswOdnRSBkTwijOZ); CuiHelper.AddUi(rsQUZEouKGeITBPkGbMXD, DbSgKCHPUQoVDyWKaQo); } private void icBUZELCuDhodqtVQZXlAgguvyMSR(BasePlayer rsQUZEouKGeITBPkGbMXD) { if (rsQUZEouKGeITBPkGbMXD == null) return; var DbSgKCHPUQoVDyWKaQo = new CuiElementContainer(); NymUWdVgVR(ref DbSgKCHPUQoVDyWKaQo, arYyoRcCywByxnRDoH.gqYWyqIPghYShSuRHooLlhtnT, "0.35 0.2", "0.65 0.8"); fiNfTratapNQOTqKQ(ref DbSgKCHPUQoVDyWKaQo, arYyoRcCywByxnRDoH.PzLkaNIXiEoXsobwBBhcelYZw, "0 0.92", "1 1"); tguGYRpxXjTCnTsTDTBoyms(ref DbSgKCHPUQoVDyWKaQo, arYyoRcCywByxnRDoH.wGvRZXoWPQvBgkfDEzugQDgXBJFJ, "X", 20, "0.90 0.92", "1 1", "bp_12345.ok", "permanentmarker.ttf"); dVEBunTpLpLSAABaIpelmVbA(ref DbSgKCHPUQoVDyWKaQo, qAtenYuUiJYoqqKQCAecaaWAFdE("TITLE.WARNING.MSG", rsQUZEouKGeITBPkGbMXD.userID), 18, "0.03 0.92", "0.89 1", TextAnchor.MiddleLeft); var LQfeSVZcfE = qAtenYuUiJYoqqKQCAecaaWAFdE("WARNING.RECOMENDATION.MSG", rsQUZEouKGeITBPkGbMXD.userID); dVEBunTpLpLSAABaIpelmVbA(ref DbSgKCHPUQoVDyWKaQo, LQfeSVZcfE, 18, "0.07 0.2", "0.93 0.9", TextAnchor.MiddleLeft); var nbISGJVvNVOeobGihxpXllme = 0.05f; var kCsGayUwykszKK = 0.525f; tguGYRpxXjTCnTsTDTBoyms(ref DbSgKCHPUQoVDyWKaQo, arYyoRcCywByxnRDoH.BkHejxOINcSUOzjmiWDahxLg, qAtenYuUiJYoqqKQCAecaaWAFdE("BUTTON.APPLY", rsQUZEouKGeITBPkGbMXD.userID), 18, $"{0.02+nbISGJVvNVOeobGihxpXllme} {0.15-0.08}", $"{0.4+kCsGayUwykszKK} {0.15}", "bp_12345.ok"); CuiHelper.DestroyUi(rsQUZEouKGeITBPkGbMXD, wWtOepewkLdlEswOdnRSBkTwijOZ); CuiHelper.AddUi(rsQUZEouKGeITBPkGbMXD, DbSgKCHPUQoVDyWKaQo); } private void VTFHpkukwgY(BasePlayer rsQUZEouKGeITBPkGbMXD) { var DbSgKCHPUQoVDyWKaQo = new CuiElementContainer(); NymUWdVgVR(ref DbSgKCHPUQoVDyWKaQo, arYyoRcCywByxnRDoH.gqYWyqIPghYShSuRHooLlhtnT, "0.35 0.2", "0.65 0.8"); fiNfTratapNQOTqKQ(ref DbSgKCHPUQoVDyWKaQo, arYyoRcCywByxnRDoH.PzLkaNIXiEoXsobwBBhcelYZw, "0 0.92", "1 1"); tguGYRpxXjTCnTsTDTBoyms(ref DbSgKCHPUQoVDyWKaQo, arYyoRcCywByxnRDoH.wGvRZXoWPQvBgkfDEzugQDgXBJFJ, "X", 20, "0.90 0.92", "1 1", "bp_12345.close", "permanentmarker.ttf"); dVEBunTpLpLSAABaIpelmVbA(ref DbSgKCHPUQoVDyWKaQo, qAtenYuUiJYoqqKQCAecaaWAFdE("TITLE.MAIN.MSG", rsQUZEouKGeITBPkGbMXD.userID), 18, "0.03 0.92", "0.89 1", TextAnchor.MiddleLeft); var ngRRbTUFWSURYCJDlmRDEWRXUOR = -0.02f; var nbISGJVvNVOeobGihxpXllme = 0.05f; dVEBunTpLpLSAABaIpelmVbA(ref DbSgKCHPUQoVDyWKaQo, qAtenYuUiJYoqqKQCAecaaWAFdE("MAIN.PROTECT_PERCENT.MSG", rsQUZEouKGeITBPkGbMXD.userID), 18, $"{0.02+nbISGJVvNVOeobGihxpXllme} {0.825+ngRRbTUFWSURYCJDlmRDEWRXUOR}", $"{0.4+nbISGJVvNVOeobGihxpXllme} {0.905+ngRRbTUFWSURYCJDlmRDEWRXUOR}", TextAnchor.MiddleLeft); fiNfTratapNQOTqKQ(ref DbSgKCHPUQoVDyWKaQo, arYyoRcCywByxnRDoH.PzLkaNIXiEoXsobwBBhcelYZw, $"{0.02+nbISGJVvNVOeobGihxpXllme} {0.75+ngRRbTUFWSURYCJDlmRDEWRXUOR}", $"{0.4+nbISGJVvNVOeobGihxpXllme} {0.83+ngRRbTUFWSURYCJDlmRDEWRXUOR}", wWtOepewkLdlEswOdnRSBkTwijOZ, wWtOepewkLdlEswOdnRSBkTwijOZ + "_percent_panel"); tguGYRpxXjTCnTsTDTBoyms(ref DbSgKCHPUQoVDyWKaQo, arYyoRcCywByxnRDoH.BkHejxOINcSUOzjmiWDahxLg, "<", 25, "0.03 0.1", "0.25 0.87", $"bp_12345.percent_shift {-1*arYyoRcCywByxnRDoH.vgxvQdfehcBa}", "robotocondensed-regular.ttf", TextAnchor.MiddleCenter, wWtOepewkLdlEswOdnRSBkTwijOZ + "_percent_panel"); tguGYRpxXjTCnTsTDTBoyms(ref DbSgKCHPUQoVDyWKaQo, arYyoRcCywByxnRDoH.BkHejxOINcSUOzjmiWDahxLg, ">", 25, "0.745 0.1", "0.965 0.87", $"bp_12345.percent_shift {arYyoRcCywByxnRDoH.vgxvQdfehcBa}", "robotocondensed-regular.ttf", TextAnchor.MiddleCenter, wWtOepewkLdlEswOdnRSBkTwijOZ + "_percent_panel"); dVEBunTpLpLSAABaIpelmVbA(ref DbSgKCHPUQoVDyWKaQo, LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].IFKqjvXybmID.ToString()+"%", 18, "0.3 0.1", "0.7 0.87", TextAnchor.MiddleCenter, wWtOepewkLdlEswOdnRSBkTwijOZ + "_percent_panel", wWtOepewkLdlEswOdnRSBkTwijOZ + "_percent_panel" + "_value"); var kCsGayUwykszKK = 0.525f; dVEBunTpLpLSAABaIpelmVbA(ref DbSgKCHPUQoVDyWKaQo, qAtenYuUiJYoqqKQCAecaaWAFdE("MAIN.PROTECT_HOURS.MSG", rsQUZEouKGeITBPkGbMXD.userID), 18, $"{0.02+kCsGayUwykszKK} {0.825+ngRRbTUFWSURYCJDlmRDEWRXUOR}", $"{0.4+kCsGayUwykszKK} {0.905+ngRRbTUFWSURYCJDlmRDEWRXUOR}", TextAnchor.MiddleLeft); fiNfTratapNQOTqKQ(ref DbSgKCHPUQoVDyWKaQo, arYyoRcCywByxnRDoH.PzLkaNIXiEoXsobwBBhcelYZw, $"{0.02+kCsGayUwykszKK} {0.75+ngRRbTUFWSURYCJDlmRDEWRXUOR}", $"{0.4+kCsGayUwykszKK} {0.83+ngRRbTUFWSURYCJDlmRDEWRXUOR}", wWtOepewkLdlEswOdnRSBkTwijOZ, wWtOepewkLdlEswOdnRSBkTwijOZ + "_hour_panel"); tguGYRpxXjTCnTsTDTBoyms(ref DbSgKCHPUQoVDyWKaQo, arYyoRcCywByxnRDoH.BkHejxOINcSUOzjmiWDahxLg, "<", 25, "0.03 0.1", "0.25 0.87", "bp_12345.hour_shift -1", "robotocondensed-regular.ttf", TextAnchor.MiddleCenter, wWtOepewkLdlEswOdnRSBkTwijOZ + "_hour_panel"); tguGYRpxXjTCnTsTDTBoyms(ref DbSgKCHPUQoVDyWKaQo, arYyoRcCywByxnRDoH.BkHejxOINcSUOzjmiWDahxLg, ">", 25, "0.745 0.1", "0.965 0.87", "bp_12345.hour_shift 1", "robotocondensed-regular.ttf", TextAnchor.MiddleCenter, wWtOepewkLdlEswOdnRSBkTwijOZ + "_hour_panel"); dVEBunTpLpLSAABaIpelmVbA(ref DbSgKCHPUQoVDyWKaQo, LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].DMhmrrnVKvNem.ToString()+qAtenYuUiJYoqqKQCAecaaWAFdE("HOUR", rsQUZEouKGeITBPkGbMXD.userID)[0], 18, "0.3 0.1", "0.7 0.87", TextAnchor.MiddleCenter, wWtOepewkLdlEswOdnRSBkTwijOZ + "_hour_panel", wWtOepewkLdlEswOdnRSBkTwijOZ + "_hour_panel" + "_value"); float aMCYDkqiecuUjJQ = 0.63f, delta_step = 0.1f; int rvduvcLjqllWJKKztt = 0; dVEBunTpLpLSAABaIpelmVbA(ref DbSgKCHPUQoVDyWKaQo, qAtenYuUiJYoqqKQCAecaaWAFdE("MAIN.RES_FOR_PAY.MSG", rsQUZEouKGeITBPkGbMXD.userID), 18, $"{0.02+nbISGJVvNVOeobGihxpXllme} {0.63+ngRRbTUFWSURYCJDlmRDEWRXUOR}", $"{0.4+kCsGayUwykszKK} {0.71+ngRRbTUFWSURYCJDlmRDEWRXUOR}", TextAnchor.MiddleCenter); foreach(var KTVphBNiUXQhPqyBFsVrWYQHQsi in LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].BqxeHdPCSjIaYcCvbVTWnINaL) { int lEDOXXSrPzNucCh = LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].cgbyuoVaBDvaUCsmdsuuUCzMMyHGBr.ContainsKey(KTVphBNiUXQhPqyBFsVrWYQHQsi.Key) ? LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].cgbyuoVaBDvaUCsmdsuuUCzMMyHGBr[KTVphBNiUXQhPqyBFsVrWYQHQsi.Key] : 0; int NVHNJunIxMNkFSNCdJWKcPSGTf = (int)Math.Round(KTVphBNiUXQhPqyBFsVrWYQHQsi.Value * LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].IFKqjvXybmID * LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].DMhmrrnVKvNem * SqAOwudNaQicEIczNJ(LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].IFKqjvXybmID) * qDanDNfhirdFKwyOVJnIOBVW(LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].DMhmrrnVKvNem)); if (NVHNJunIxMNkFSNCdJWKcPSGTf < 1) NVHNJunIxMNkFSNCdJWKcPSGTf = 1; var VgTBBdpHZiLS = lEDOXXSrPzNucCh < NVHNJunIxMNkFSNCdJWKcPSGTf; var PcldXvkNaCh = $"{tRONBEbkJWOJUIpKaLfxXOFTIl(KTVphBNiUXQhPqyBFsVrWYQHQsi.Key)}"; var uqgZnmgzHVqO = $"{uOHCcqPxmfWsehkREbRbYiLcLbDogq(NVHNJunIxMNkFSNCdJWKcPSGTf)} / {uOHCcqPxmfWsehkREbRbYiLcLbDogq(lEDOXXSrPzNucCh, VgTBBdpHZiLS)}"; fiNfTratapNQOTqKQ(ref DbSgKCHPUQoVDyWKaQo, arYyoRcCywByxnRDoH.PzLkaNIXiEoXsobwBBhcelYZw, $"{0.02+nbISGJVvNVOeobGihxpXllme} {aMCYDkqiecuUjJQ-0.08-rvduvcLjqllWJKKztt*delta_step+ngRRbTUFWSURYCJDlmRDEWRXUOR}", $"{0.4+kCsGayUwykszKK} {aMCYDkqiecuUjJQ-rvduvcLjqllWJKKztt*delta_step+ngRRbTUFWSURYCJDlmRDEWRXUOR}", wWtOepewkLdlEswOdnRSBkTwijOZ, wWtOepewkLdlEswOdnRSBkTwijOZ + $"_res_panel_{rvduvcLjqllWJKKztt}"); dVEBunTpLpLSAABaIpelmVbA(ref DbSgKCHPUQoVDyWKaQo, PcldXvkNaCh, 18, "0.03 0.1", "0.96 0.9", TextAnchor.MiddleLeft, wWtOepewkLdlEswOdnRSBkTwijOZ + $"_res_panel_{rvduvcLjqllWJKKztt}"); dVEBunTpLpLSAABaIpelmVbA(ref DbSgKCHPUQoVDyWKaQo, uqgZnmgzHVqO, 18, "0.03 0.1", "0.96 0.9", TextAnchor.MiddleRight, wWtOepewkLdlEswOdnRSBkTwijOZ + $"_res_panel_{rvduvcLjqllWJKKztt}", wWtOepewkLdlEswOdnRSBkTwijOZ + "_res_panel" + $"_value_right_{rvduvcLjqllWJKKztt}"); rvduvcLjqllWJKKztt++; } tguGYRpxXjTCnTsTDTBoyms(ref DbSgKCHPUQoVDyWKaQo, arYyoRcCywByxnRDoH.BkHejxOINcSUOzjmiWDahxLg, qAtenYuUiJYoqqKQCAecaaWAFdE("BUTTON.PROTECT_SET", rsQUZEouKGeITBPkGbMXD.userID), 18, $"{0.02+nbISGJVvNVOeobGihxpXllme} {0.15-0.08}", $"{0.4+kCsGayUwykszKK} {0.15}", "bp_12345.apply"); CuiHelper.DestroyUi(rsQUZEouKGeITBPkGbMXD, wWtOepewkLdlEswOdnRSBkTwijOZ); CuiHelper.AddUi(rsQUZEouKGeITBPkGbMXD, DbSgKCHPUQoVDyWKaQo); } private static void GVJDzFVqjVzvnqTiKnj(BasePlayer rsQUZEouKGeITBPkGbMXD, ref CuiElementContainer DbSgKCHPUQoVDyWKaQo) { int rvduvcLjqllWJKKztt = 0; foreach(var KTVphBNiUXQhPqyBFsVrWYQHQsi in LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].BqxeHdPCSjIaYcCvbVTWnINaL) { CuiHelper.DestroyUi(rsQUZEouKGeITBPkGbMXD, wWtOepewkLdlEswOdnRSBkTwijOZ + "_res_panel" + $"_value_right_{rvduvcLjqllWJKKztt}"); int lEDOXXSrPzNucCh = LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].cgbyuoVaBDvaUCsmdsuuUCzMMyHGBr.ContainsKey(KTVphBNiUXQhPqyBFsVrWYQHQsi.Key) ? LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].cgbyuoVaBDvaUCsmdsuuUCzMMyHGBr[KTVphBNiUXQhPqyBFsVrWYQHQsi.Key] : 0; int NVHNJunIxMNkFSNCdJWKcPSGTf = (int)Math.Round(KTVphBNiUXQhPqyBFsVrWYQHQsi.Value * LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].IFKqjvXybmID * LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].DMhmrrnVKvNem * SqAOwudNaQicEIczNJ(LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].IFKqjvXybmID) * qDanDNfhirdFKwyOVJnIOBVW(LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].DMhmrrnVKvNem)); if (NVHNJunIxMNkFSNCdJWKcPSGTf < 1) NVHNJunIxMNkFSNCdJWKcPSGTf = 1; var VgTBBdpHZiLS = lEDOXXSrPzNucCh < NVHNJunIxMNkFSNCdJWKcPSGTf; var uqgZnmgzHVqO = $"{uOHCcqPxmfWsehkREbRbYiLcLbDogq(NVHNJunIxMNkFSNCdJWKcPSGTf)} / {uOHCcqPxmfWsehkREbRbYiLcLbDogq(lEDOXXSrPzNucCh, VgTBBdpHZiLS)}"; dVEBunTpLpLSAABaIpelmVbA(ref DbSgKCHPUQoVDyWKaQo, uqgZnmgzHVqO, 18, "0.03 0.1", "0.96 0.9", TextAnchor.MiddleRight, wWtOepewkLdlEswOdnRSBkTwijOZ + $"_res_panel_{rvduvcLjqllWJKKztt}", wWtOepewkLdlEswOdnRSBkTwijOZ + "_res_panel" + $"_value_right_{rvduvcLjqllWJKKztt}"); rvduvcLjqllWJKKztt++; } } private static void NymUWdVgVR(ref CuiElementContainer DbSgKCHPUQoVDyWKaQo, string QFQHXJdKeKegjOOZOk, string MtqMaeVWBs, string GBVMOqUTvNOaEwMFCGrVzLobdGeDU) { DbSgKCHPUQoVDyWKaQo.Add(new CuiPanel { Image = { Color = QFQHXJdKeKegjOOZOk }, RectTransform = { AnchorMin = MtqMaeVWBs, AnchorMax = GBVMOqUTvNOaEwMFCGrVzLobdGeDU }, CursorEnabled = true }, "Hud", wWtOepewkLdlEswOdnRSBkTwijOZ); } private static void fiNfTratapNQOTqKQ(ref CuiElementContainer DbSgKCHPUQoVDyWKaQo, string QFQHXJdKeKegjOOZOk, string MtqMaeVWBs, string GBVMOqUTvNOaEwMFCGrVzLobdGeDU, string JOzuVLFiUYauUsE = wWtOepewkLdlEswOdnRSBkTwijOZ, string mamobRnEmYeBZTqdzzfWGxihqgG = null) { DbSgKCHPUQoVDyWKaQo.Add(new CuiPanel { Image = { Color = QFQHXJdKeKegjOOZOk }, RectTransform = { AnchorMin = MtqMaeVWBs, AnchorMax = GBVMOqUTvNOaEwMFCGrVzLobdGeDU } }, JOzuVLFiUYauUsE, mamobRnEmYeBZTqdzzfWGxihqgG); } private static void dVEBunTpLpLSAABaIpelmVbA(ref CuiElementContainer DbSgKCHPUQoVDyWKaQo, string LQfeSVZcfE, int qkPDTIfAYJwPvQIhniVh, string MtqMaeVWBs, string GBVMOqUTvNOaEwMFCGrVzLobdGeDU, TextAnchor muxkNvKsDZiSfZhXOJUxFvLdpRh = TextAnchor.MiddleCenter, string JOzuVLFiUYauUsE = wWtOepewkLdlEswOdnRSBkTwijOZ, string mamobRnEmYeBZTqdzzfWGxihqgG = null) { DbSgKCHPUQoVDyWKaQo.Add(new CuiLabel { Text = { FontSize = qkPDTIfAYJwPvQIhniVh, Align = muxkNvKsDZiSfZhXOJUxFvLdpRh, Text = LQfeSVZcfE, Font = "robotocondensed-regular.ttf" }, RectTransform = { AnchorMin = MtqMaeVWBs, AnchorMax = GBVMOqUTvNOaEwMFCGrVzLobdGeDU } }, JOzuVLFiUYauUsE, mamobRnEmYeBZTqdzzfWGxihqgG); } private static void xPyLVNEuusFCKuNIJElKeixH(ref CuiElementContainer DbSgKCHPUQoVDyWKaQo, string LQfeSVZcfE, int qkPDTIfAYJwPvQIhniVh, string MtqMaeVWBs, string GBVMOqUTvNOaEwMFCGrVzLobdGeDU, TextAnchor muxkNvKsDZiSfZhXOJUxFvLdpRh = TextAnchor.MiddleCenter, string JOzuVLFiUYauUsE = wWtOepewkLdlEswOdnRSBkTwijOZ, string mamobRnEmYeBZTqdzzfWGxihqgG = null) { DbSgKCHPUQoVDyWKaQo.Add(new CuiElement() { Name = mamobRnEmYeBZTqdzzfWGxihqgG, Parent = JOzuVLFiUYauUsE, Components = { new CuiTextComponent() { Text = LQfeSVZcfE, Font = "robotocondensed-regular.ttf", Align = muxkNvKsDZiSfZhXOJUxFvLdpRh, FontSize = qkPDTIfAYJwPvQIhniVh }, new CuiOutlineComponent() { Color = "0 0 0 1" }, new CuiRectTransformComponent() { AnchorMin = MtqMaeVWBs, AnchorMax = GBVMOqUTvNOaEwMFCGrVzLobdGeDU } } }); } private static void tguGYRpxXjTCnTsTDTBoyms(ref CuiElementContainer DbSgKCHPUQoVDyWKaQo, string QFQHXJdKeKegjOOZOk, string LQfeSVZcfE, int qkPDTIfAYJwPvQIhniVh, string MtqMaeVWBs, string GBVMOqUTvNOaEwMFCGrVzLobdGeDU, string ZlEandkYxKDZZZIovjiteHiSq, string font = "robotocondensed-regular.ttf", TextAnchor muxkNvKsDZiSfZhXOJUxFvLdpRh = TextAnchor.MiddleCenter, string JOzuVLFiUYauUsE = wWtOepewkLdlEswOdnRSBkTwijOZ, string mamobRnEmYeBZTqdzzfWGxihqgG = null) { if (string.IsNullOrEmpty(QFQHXJdKeKegjOOZOk)) QFQHXJdKeKegjOOZOk = "0 0 0 0"; DbSgKCHPUQoVDyWKaQo.Add(new CuiButton { Button = { Color = QFQHXJdKeKegjOOZOk, Command = ZlEandkYxKDZZZIovjiteHiSq, FadeIn = 0f }, RectTransform = { AnchorMin = MtqMaeVWBs, AnchorMax = GBVMOqUTvNOaEwMFCGrVzLobdGeDU }, Text = { Text = LQfeSVZcfE, FontSize = qkPDTIfAYJwPvQIhniVh, Align = muxkNvKsDZiSfZhXOJUxFvLdpRh, Font = font } }, JOzuVLFiUYauUsE, mamobRnEmYeBZTqdzzfWGxihqgG); } private static void BsmUteByfSSG(ref CuiElementContainer DbSgKCHPUQoVDyWKaQo, string png, string MtqMaeVWBs, string GBVMOqUTvNOaEwMFCGrVzLobdGeDU, string JOzuVLFiUYauUsE = wWtOepewkLdlEswOdnRSBkTwijOZ) { DbSgKCHPUQoVDyWKaQo.Add(new CuiElement { Name = CuiHelper.GetGuid(), Parent = JOzuVLFiUYauUsE, Components = { new CuiRawImageComponent {Png = png }, new CuiRectTransformComponent { AnchorMin = MtqMaeVWBs, AnchorMax = GBVMOqUTvNOaEwMFCGrVzLobdGeDU } } }); } private void QxNidWRapMOxAeEJdwWGvy(BasePlayer rsQUZEouKGeITBPkGbMXD) { if (rsQUZEouKGeITBPkGbMXD == null) return; CuiHelper.DestroyUi(rsQUZEouKGeITBPkGbMXD, "IconPanel"); var DbSgKCHPUQoVDyWKaQo = new CuiElementContainer(); fiNfTratapNQOTqKQ(ref DbSgKCHPUQoVDyWKaQo, "1 1 1 0", arYyoRcCywByxnRDoH.AnchorMin, arYyoRcCywByxnRDoH.AnchorMax, "Hud", "IconPanel"); if (!string.IsNullOrEmpty(HdBWieoSOUQFlqrjstNvpyGBTqWeu)) BsmUteByfSSG(ref DbSgKCHPUQoVDyWKaQo, HdBWieoSOUQFlqrjstNvpyGBTqWeu, "0 0", "1 1", "IconPanel"); CuiHelper.AddUi(rsQUZEouKGeITBPkGbMXD, DbSgKCHPUQoVDyWKaQo); } private void ePOrSDyGJhsFlWJeNW(BasePlayer rsQUZEouKGeITBPkGbMXD, long xZQcQFQwWOHfQ, float percent, int OWHOOgESfqMyGqCVjAZCUEyDpnZhY) { if (rsQUZEouKGeITBPkGbMXD == null) return; var ItHQJBPTwYqtsxqaLKHtmgFjppu = WlRJiciKvTk(xZQcQFQwWOHfQ, true, rsQUZEouKGeITBPkGbMXD.userID); var home = OWHOOgESfqMyGqCVjAZCUEyDpnZhY > 0 ? string.Format(qAtenYuUiJYoqqKQCAecaaWAFdE("ICON.HOME_NUMBER.MSG", rsQUZEouKGeITBPkGbMXD.userID), OWHOOgESfqMyGqCVjAZCUEyDpnZhY) : ""; var dhPEyXDIQxGjqkrZgy = "12"; var LQfeSVZcfE = string.Format(qAtenYuUiJYoqqKQCAecaaWAFdE("ICON.HOME_PROTECT.MSG", rsQUZEouKGeITBPkGbMXD.userID), home, percent, ItHQJBPTwYqtsxqaLKHtmgFjppu); CuiHelper.DestroyUi(rsQUZEouKGeITBPkGbMXD, "IconPanel" + "_icon_text"); var DbSgKCHPUQoVDyWKaQo = new CuiElementContainer(); xPyLVNEuusFCKuNIJElKeixH(ref DbSgKCHPUQoVDyWKaQo, LQfeSVZcfE, 12, "0 0", "1 1", TextAnchor.MiddleCenter, "IconPanel", "IconPanel" + "_icon_text"); CuiHelper.AddUi(rsQUZEouKGeITBPkGbMXD, DbSgKCHPUQoVDyWKaQo); } private static Dictionary<ulong, Timer> iSgCIwTPNAWFbhVaWhF = new Dictionary<ulong, Timer>(); private void HSKmDEFdCiebyrOAObPIsISD(BasePlayer rsQUZEouKGeITBPkGbMXD, string gmyDBiESlhtGaypwBUj) { if (rsQUZEouKGeITBPkGbMXD == null || string.IsNullOrEmpty(gmyDBiESlhtGaypwBUj)) return; ynJbMZRfNxnmxMMEcQNeA(rsQUZEouKGeITBPkGbMXD); var DbSgKCHPUQoVDyWKaQo = new CuiElementContainer(); fiNfTratapNQOTqKQ(ref DbSgKCHPUQoVDyWKaQo, arYyoRcCywByxnRDoH.yniMHiVFyd, "0.1 0.56", "0.9 0.7", wWtOepewkLdlEswOdnRSBkTwijOZ, wWtOepewkLdlEswOdnRSBkTwijOZ + "_sm_container"); dVEBunTpLpLSAABaIpelmVbA(ref DbSgKCHPUQoVDyWKaQo, gmyDBiESlhtGaypwBUj, 18, "0 0", "1 1", TextAnchor.MiddleCenter, wWtOepewkLdlEswOdnRSBkTwijOZ + "_sm_container"); CuiHelper.AddUi(rsQUZEouKGeITBPkGbMXD, DbSgKCHPUQoVDyWKaQo); if (!iSgCIwTPNAWFbhVaWhF.ContainsKey(rsQUZEouKGeITBPkGbMXD.userID)) iSgCIwTPNAWFbhVaWhF.Add(rsQUZEouKGeITBPkGbMXD.userID, null); iSgCIwTPNAWFbhVaWhF[rsQUZEouKGeITBPkGbMXD.userID] = timer.Once(2f, ()=> CuiHelper.DestroyUi(rsQUZEouKGeITBPkGbMXD, wWtOepewkLdlEswOdnRSBkTwijOZ + "_sm_container")); } private static void ynJbMZRfNxnmxMMEcQNeA(BasePlayer rsQUZEouKGeITBPkGbMXD) { if (rsQUZEouKGeITBPkGbMXD == null) return; if (iSgCIwTPNAWFbhVaWhF.ContainsKey(rsQUZEouKGeITBPkGbMXD.userID) && iSgCIwTPNAWFbhVaWhF[rsQUZEouKGeITBPkGbMXD.userID] != null) { iSgCIwTPNAWFbhVaWhF[rsQUZEouKGeITBPkGbMXD.userID].Destroy(); iSgCIwTPNAWFbhVaWhF[rsQUZEouKGeITBPkGbMXD.userID] = null; } CuiHelper.DestroyUi(rsQUZEouKGeITBPkGbMXD, wWtOepewkLdlEswOdnRSBkTwijOZ + "_sm_container"); } private void wqnridXLTCy() => ServerMgr.Instance.StartCoroutine(wqnridXLTCy(arYyoRcCywByxnRDoH.PiJaDAGVeuFyWiDKactrDRAuhnajhz)); private IEnumerator wqnridXLTCy(string wPmPArIBqkoBuVHgwleuLY) { using (var LPpmHHGzXWODpguZCiFRtpeXVNCjJ = new WWW(wPmPArIBqkoBuVHgwleuLY)) { yield return LPpmHHGzXWODpguZCiFRtpeXVNCjJ; if (LPpmHHGzXWODpguZCiFRtpeXVNCjJ.error != null) PrintError(qAtenYuUiJYoqqKQCAecaaWAFdE("IMAGE.LOAD.ERROR") + $"\n{wPmPArIBqkoBuVHgwleuLY}"); else { var mGlQWzHVkszhw = LPpmHHGzXWODpguZCiFRtpeXVNCjJ.texture; byte[] obPfdztVvKcwEVgW = mGlQWzHVkszhw.EncodeToPNG(); HdBWieoSOUQFlqrjstNvpyGBTqWeu = FileStorage.server.Store(obPfdztVvKcwEVgW, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID).ToString(); UnityEngine.Object.DestroyImmediate(mGlQWzHVkszhw); yield break; } } } [ConsoleCommand("bp_12345.close")] private void ROKglyToVJBFPoyAhZzhBs(ConsoleSystem.Arg ssIlsReTfpcHcXuN) { BasePlayer rsQUZEouKGeITBPkGbMXD = ssIlsReTfpcHcXuN.Player(); if (rsQUZEouKGeITBPkGbMXD == null) return; CuiHelper.DestroyUi(rsQUZEouKGeITBPkGbMXD, wWtOepewkLdlEswOdnRSBkTwijOZ); } [ConsoleCommand("bp_12345.ok")] private void IIahSRUiWnud(ConsoleSystem.Arg ssIlsReTfpcHcXuN) { BasePlayer rsQUZEouKGeITBPkGbMXD = ssIlsReTfpcHcXuN.Player(); if (rsQUZEouKGeITBPkGbMXD == null) return; CuiHelper.DestroyUi(rsQUZEouKGeITBPkGbMXD, wWtOepewkLdlEswOdnRSBkTwijOZ); VTFHpkukwgY(rsQUZEouKGeITBPkGbMXD); } [ConsoleCommand("bp_12345.toggleicon")] private void zmvHujfPPYnkCbsz(ConsoleSystem.Arg ssIlsReTfpcHcXuN) { BasePlayer rsQUZEouKGeITBPkGbMXD = ssIlsReTfpcHcXuN.Player(); if (rsQUZEouKGeITBPkGbMXD == null) return; var HhzrRtMSZEffWiLtOZtcFEIUdHUN = Convert.ToUInt32(ssIlsReTfpcHcXuN.Args[0]); CuiHelper.DestroyUi(rsQUZEouKGeITBPkGbMXD, wWtOepewkLdlEswOdnRSBkTwijOZ + "_toggle_icon"); if (!fFXlNOaDpM.qYRLmeQQhezbQk.ContainsKey(rsQUZEouKGeITBPkGbMXD.userID)) fFXlNOaDpM.qYRLmeQQhezbQk.Add(rsQUZEouKGeITBPkGbMXD.userID, new List<uint>()); if (!fFXlNOaDpM.qYRLmeQQhezbQk[rsQUZEouKGeITBPkGbMXD.userID].Contains(HhzrRtMSZEffWiLtOZtcFEIUdHUN)) { fFXlNOaDpM.qYRLmeQQhezbQk[rsQUZEouKGeITBPkGbMXD.userID].Add(HhzrRtMSZEffWiLtOZtcFEIUdHUN); QxNidWRapMOxAeEJdwWGvy(rsQUZEouKGeITBPkGbMXD); eKkZkmksdVryKYmLmLJYStVf(rsQUZEouKGeITBPkGbMXD.userID); } else { fFXlNOaDpM.qYRLmeQQhezbQk[rsQUZEouKGeITBPkGbMXD.userID].Remove(HhzrRtMSZEffWiLtOZtcFEIUdHUN); if (fFXlNOaDpM.qYRLmeQQhezbQk[rsQUZEouKGeITBPkGbMXD.userID].Count() == 0) CuiHelper.DestroyUi(rsQUZEouKGeITBPkGbMXD, "IconPanel"); } var DbSgKCHPUQoVDyWKaQo = new CuiElementContainer(); var nbISGJVvNVOeobGihxpXllme = 0.05f; tguGYRpxXjTCnTsTDTBoyms(ref DbSgKCHPUQoVDyWKaQo, "1 1 1 0", OSrYzuFgFTkfFqBa(rsQUZEouKGeITBPkGbMXD, HhzrRtMSZEffWiLtOZtcFEIUdHUN), 18, $"{nbISGJVvNVOeobGihxpXllme-0.02} {0.55-0.08}", $"{0.15} {0.53}", $"bp_12345.toggleicon {HhzrRtMSZEffWiLtOZtcFEIUdHUN}", "robotocondensed-regular.ttf", TextAnchor.MiddleCenter, wWtOepewkLdlEswOdnRSBkTwijOZ, wWtOepewkLdlEswOdnRSBkTwijOZ + "_toggle_icon"); CuiHelper.AddUi(rsQUZEouKGeITBPkGbMXD, DbSgKCHPUQoVDyWKaQo); } [ConsoleCommand("bp_12345.apply")] private void vyCUouNFRtyUNpDqukRMDY(ConsoleSystem.Arg ssIlsReTfpcHcXuN) { BasePlayer rsQUZEouKGeITBPkGbMXD = ssIlsReTfpcHcXuN.Player(); if (rsQUZEouKGeITBPkGbMXD == null) return; var otFWnSlOJn = LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].hmtpabplIUjQXuPIlBFjNVPMJLFVo; if (otFWnSlOJn == null) { HSKmDEFdCiebyrOAObPIsISD(rsQUZEouKGeITBPkGbMXD, qAtenYuUiJYoqqKQCAecaaWAFdE("INFO.CUPBOARD_NOT_FOUND", rsQUZEouKGeITBPkGbMXD.userID)); return; } if (!COmXKLxhnkQjVNVhZwKlO(rsQUZEouKGeITBPkGbMXD)) { var DbSgKCHPUQoVDyWKaQo = new CuiElementContainer(); GVJDzFVqjVzvnqTiKnj(rsQUZEouKGeITBPkGbMXD, ref DbSgKCHPUQoVDyWKaQo); CuiHelper.AddUi(rsQUZEouKGeITBPkGbMXD, DbSgKCHPUQoVDyWKaQo); HSKmDEFdCiebyrOAObPIsISD(rsQUZEouKGeITBPkGbMXD, qAtenYuUiJYoqqKQCAecaaWAFdE("INFO.NO_RESOURCE_PAY", rsQUZEouKGeITBPkGbMXD.userID)); return; } eYBjRpbrPjzttOHVuFwllpjVtVf(rsQUZEouKGeITBPkGbMXD); LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].akJrcdwqcuUZ = InhebQTFJTvv(DateTime.Now); tqIKYYnczXoFtEtnl = true; var zgLClBAOijWQCyL = rsQUZEouKGeITBPkGbMXD.userID; var HhzrRtMSZEffWiLtOZtcFEIUdHUN = otFWnSlOJn.net.ID; timer.Once(0.1f, ()=> { var endTime = LvQVdOcRKczi[zgLClBAOijWQCyL].akJrcdwqcuUZ + LvQVdOcRKczi[zgLClBAOijWQCyL].DMhmrrnVKvNem * 60 * 60; foreach(var blockID in LvQVdOcRKczi[zgLClBAOijWQCyL].sXIuBpDbLuyUxjuSqqpnUl) { var cHGqPsCQncUbNPzmtPLVUEDFSA = new SbfmlOGavlfz(); cHGqPsCQncUbNPzmtPLVUEDFSA.aOcKgYsiyGLZqCTJhFXIezcDCh = LvQVdOcRKczi[zgLClBAOijWQCyL].IFKqjvXybmID; cHGqPsCQncUbNPzmtPLVUEDFSA.EGNIlRsVsdVdQSMNvcyj = endTime; if (fFXlNOaDpM.FJblgubrcofQAqy.ContainsKey(blockID)) fFXlNOaDpM.FJblgubrcofQAqy[blockID] = cHGqPsCQncUbNPzmtPLVUEDFSA; else fFXlNOaDpM.FJblgubrcofQAqy.Add(blockID, cHGqPsCQncUbNPzmtPLVUEDFSA); } if (!fFXlNOaDpM.qYRLmeQQhezbQk.ContainsKey(zgLClBAOijWQCyL)) fFXlNOaDpM.qYRLmeQQhezbQk.Add(zgLClBAOijWQCyL, new List<uint>()); if (!fFXlNOaDpM.qYRLmeQQhezbQk[zgLClBAOijWQCyL].Contains(HhzrRtMSZEffWiLtOZtcFEIUdHUN)) fFXlNOaDpM.qYRLmeQQhezbQk[zgLClBAOijWQCyL].Add(HhzrRtMSZEffWiLtOZtcFEIUdHUN); OfGZZIBPEJVfix(); QxNidWRapMOxAeEJdwWGvy(rsQUZEouKGeITBPkGbMXD); eKkZkmksdVryKYmLmLJYStVf(zgLClBAOijWQCyL); if (arYyoRcCywByxnRDoH.AutoEnableIcon) { foreach (var authed in otFWnSlOJn.authorizedPlayers) { if (zgLClBAOijWQCyL == authed.userid) continue; var user = BasePlayer.FindByID(authed.userid); if (!fFXlNOaDpM.qYRLmeQQhezbQk.ContainsKey(authed.userid)) fFXlNOaDpM.qYRLmeQQhezbQk.Add(authed.userid, new List<uint>()); if (!fFXlNOaDpM.qYRLmeQQhezbQk[authed.userid].Contains(HhzrRtMSZEffWiLtOZtcFEIUdHUN)) { fFXlNOaDpM.qYRLmeQQhezbQk[authed.userid].Add(HhzrRtMSZEffWiLtOZtcFEIUdHUN); if (user != null) { QxNidWRapMOxAeEJdwWGvy(user); eKkZkmksdVryKYmLmLJYStVf(authed.userid); } } } } tqIKYYnczXoFtEtnl = false; LhObORdPwKeIUEGRhNhGIZ(rsQUZEouKGeITBPkGbMXD, otFWnSlOJn); }); } [ConsoleCommand("bp_12345.percent_shift")] private void ZOGzkyzszemhi(ConsoleSystem.Arg ssIlsReTfpcHcXuN) { BasePlayer rsQUZEouKGeITBPkGbMXD = ssIlsReTfpcHcXuN.Player(); if (rsQUZEouKGeITBPkGbMXD == null) return; var gkIssEuBsqKimzuwjfPmPlBO = Convert.ToInt32(ssIlsReTfpcHcXuN.Args[0]); if (gkIssEuBsqKimzuwjfPmPlBO == 0) return; if ((gkIssEuBsqKimzuwjfPmPlBO < 0 && LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].IFKqjvXybmID <= arYyoRcCywByxnRDoH.YxdtJNemecgyegrsApTAmpUD) || (gkIssEuBsqKimzuwjfPmPlBO > 0 && LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].IFKqjvXybmID >= arYyoRcCywByxnRDoH.huruqQKdraVovZBmpkxJVdJb)) return; LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].IFKqjvXybmID += gkIssEuBsqKimzuwjfPmPlBO; if (LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].IFKqjvXybmID >= arYyoRcCywByxnRDoH.huruqQKdraVovZBmpkxJVdJb) LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].IFKqjvXybmID = arYyoRcCywByxnRDoH.huruqQKdraVovZBmpkxJVdJb; else if (LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].IFKqjvXybmID <= arYyoRcCywByxnRDoH.YxdtJNemecgyegrsApTAmpUD) LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].IFKqjvXybmID = arYyoRcCywByxnRDoH.YxdtJNemecgyegrsApTAmpUD; CuiHelper.DestroyUi(rsQUZEouKGeITBPkGbMXD, wWtOepewkLdlEswOdnRSBkTwijOZ + "_percent_panel" + "_value"); var DbSgKCHPUQoVDyWKaQo = new CuiElementContainer(); dVEBunTpLpLSAABaIpelmVbA(ref DbSgKCHPUQoVDyWKaQo, LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].IFKqjvXybmID.ToString()+"%", 18, "0.3 0.1", "0.7 0.87", TextAnchor.MiddleCenter, wWtOepewkLdlEswOdnRSBkTwijOZ + "_percent_panel", wWtOepewkLdlEswOdnRSBkTwijOZ + "_percent_panel" + "_value"); GVJDzFVqjVzvnqTiKnj(rsQUZEouKGeITBPkGbMXD, ref DbSgKCHPUQoVDyWKaQo); CuiHelper.AddUi(rsQUZEouKGeITBPkGbMXD, DbSgKCHPUQoVDyWKaQo); } [ConsoleCommand("bp_12345.hour_shift")] private void RbYIUzIAeqRKsU(ConsoleSystem.Arg ssIlsReTfpcHcXuN) { BasePlayer rsQUZEouKGeITBPkGbMXD = ssIlsReTfpcHcXuN.Player(); if (rsQUZEouKGeITBPkGbMXD == null) return; var gkIssEuBsqKimzuwjfPmPlBO = Convert.ToInt32(ssIlsReTfpcHcXuN.Args[0]); if (gkIssEuBsqKimzuwjfPmPlBO == 0) return; if ((gkIssEuBsqKimzuwjfPmPlBO < 0 && LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].DMhmrrnVKvNem <= arYyoRcCywByxnRDoH.yczkCuQTZObFoEWVhjRmSgl) || (gkIssEuBsqKimzuwjfPmPlBO > 0 && LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].DMhmrrnVKvNem >= arYyoRcCywByxnRDoH.bKqOdBBuLuEbwaoDWdLftgQl)) return; LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].DMhmrrnVKvNem += gkIssEuBsqKimzuwjfPmPlBO; if (LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].DMhmrrnVKvNem >= arYyoRcCywByxnRDoH.bKqOdBBuLuEbwaoDWdLftgQl) LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].DMhmrrnVKvNem = arYyoRcCywByxnRDoH.bKqOdBBuLuEbwaoDWdLftgQl; else if (LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].DMhmrrnVKvNem <= arYyoRcCywByxnRDoH.yczkCuQTZObFoEWVhjRmSgl) LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].DMhmrrnVKvNem = arYyoRcCywByxnRDoH.yczkCuQTZObFoEWVhjRmSgl; CuiHelper.DestroyUi(rsQUZEouKGeITBPkGbMXD, wWtOepewkLdlEswOdnRSBkTwijOZ + "_hour_panel" + "_value"); var DbSgKCHPUQoVDyWKaQo = new CuiElementContainer(); dVEBunTpLpLSAABaIpelmVbA(ref DbSgKCHPUQoVDyWKaQo, LvQVdOcRKczi[rsQUZEouKGeITBPkGbMXD.userID].DMhmrrnVKvNem.ToString()+qAtenYuUiJYoqqKQCAecaaWAFdE("HOUR", rsQUZEouKGeITBPkGbMXD.userID)[0], 18, "0.3 0.1", "0.7 0.87", TextAnchor.MiddleCenter, wWtOepewkLdlEswOdnRSBkTwijOZ + "_hour_panel", wWtOepewkLdlEswOdnRSBkTwijOZ + "_hour_panel" + "_value"); GVJDzFVqjVzvnqTiKnj(rsQUZEouKGeITBPkGbMXD, ref DbSgKCHPUQoVDyWKaQo); CuiHelper.AddUi(rsQUZEouKGeITBPkGbMXD, DbSgKCHPUQoVDyWKaQo); } private static long InhebQTFJTvv(DateTime BlgKFooShdvuNRGuaDIyEXS) { var RdWjBqOXYKuUGeifozdYQBRkhYIUKh = BlgKFooShdvuNRGuaDIyEXS.ToLocalTime(); var hYnlPFQVCwBMgVeUfidEzrtry = RdWjBqOXYKuUGeifozdYQBRkhYIUKh.Ticks - new DateTime(1970, 1, 1, 0, 0, 0, 0).Ticks; var gantSbRTek = hYnlPFQVCwBMgVeUfidEzrtry / TimeSpan.TicksPerSecond; return gantSbRTek; } private static string CRHvtuviAlBWexqFvfnuVzlN(long yTDlDKqBhKxcMlYxJIHkIPR, List<string> hFLHNvcLQWTdYrbMwDsLCv) { switch(yTDlDKqBhKxcMlYxJIHkIPR) { case 11:case 12: case 13: case 14: return $"{yTDlDKqBhKxcMlYxJIHkIPR} {hFLHNvcLQWTdYrbMwDsLCv[2]}"; } var zyWWVdHAfrPdEaiKryt = yTDlDKqBhKxcMlYxJIHkIPR.ToString(); switch(zyWWVdHAfrPdEaiKryt[zyWWVdHAfrPdEaiKryt.Length-1]) { case '1': return $"{yTDlDKqBhKxcMlYxJIHkIPR} {hFLHNvcLQWTdYrbMwDsLCv[0]}"; case '2': case '3': case '4': return $"{yTDlDKqBhKxcMlYxJIHkIPR} {hFLHNvcLQWTdYrbMwDsLCv[1]}"; } return $"{yTDlDKqBhKxcMlYxJIHkIPR} {hFLHNvcLQWTdYrbMwDsLCv[2]}"; } private string qAtenYuUiJYoqqKQCAecaaWAFdE(string xKrSrgXmMgQOeU, ulong ZPgIlsvwveqaNZyUwSQQeBNuSiqF = 0U) => lang.GetMessage(xKrSrgXmMgQOeU, this, ZPgIlsvwveqaNZyUwSQQeBNuSiqF == 0U ? null : ZPgIlsvwveqaNZyUwSQQeBNuSiqF.ToString()); private static Dictionary<string, string> BSGpNGGzTyiGKoKEeOyX = new Dictionary<string, string> { { "TITLE.MAIN.MSG", "Установка защиты дома" }, { "TITLE.REMIND.MSG", "Состояние защиты дома" }, { "TITLE.WARNING.MSG", "<color=orange>Внимание</color>" }, { "NOESCAPE.WARNING", "Вы не можете усиливать защиту дома во время рейда, подождите {0} сек." }, { "NOESCAPE.CALL.ERROR", "Ошибка вызова API метода плагина NoEscape!" }, { "MAIN.RES_FOR_PAY.MSG", "Ресурсы для оплаты защиты (нужно/есть)" }, { "MAIN.PROTECT_PERCENT.MSG", " Процент защиты" }, { "MAIN.PROTECT_HOURS.MSG", " Часы защиты" }, { "REMIND.HOME_PROTECT.MSG", "<color=orange>ВАШ ДОМ ЗАЩИЩЕН!</color>\n\n <color=orange>*</color> Защита дома усилена на <color=orange>{0}%</color>\n <color=orange>*</color> Защита окончится через <color=orange>{1}</color>" }, { "REMIND.CHECK_TOGGLE.MSG", "отображать иконку с информацией о состоянии защиты этого дома" }, { "WARNING.RECOMENDATION.MSG", "РЕКОМЕНДАЦИЯ!\n\nУстанавливайте защиту на уже полностью достроеный дом, т.к. если после установки защиты дом будет достроен новыми блоками или будут улучшены какие то старые блоки, то защита на эти блоки не будет распространяться.\nУстановить защиту на все блоки, включая достроенные новые, можно будет уже после окончания действия старой защиты." }, { "BUTTON.APPLY", "Понятно" }, { "BUTTON.PROTECT_SET", "Установить защиту" }, { "ICON.HOME_NUMBER.MSG", "Дом №{0}\n" }, { "ICON.HOME_PROTECT.MSG", "<color=white>{0}{1} %\n{2}</color>" }, { "IMAGE.LOAD.ERROR", "Ошибка загрузки изображения!" }, { "INFO.CUPBOARD_NOT_FOUND", "Не найден шкаф!" }, { "INFO.NO_RESOURCE_PAY", "Недостаточно ресурсов для оплаты!" }, { "INFO.NO_CUP_AUTH", "Вы не находитесь в билдинг зоне своего шкафа!" }, { "INFO.BUILDING.PROTECTED", "<color=red> Этот дом имеет повышенную на <color=white>{0}%</color> защиту!</color>" }, { "MINUTE1", "минуту" }, { "MINUTE2", "минута" }, { "MINUTES1", "минуты" }, { "MINUTES2", "минут" }, { "HOUR", "час" }, { "HOURS1", "часа" }, { "HOURS2", "часов" } }; private static ConfigData arYyoRcCywByxnRDoH; private class ConfigData { [JsonProperty(PropertyName = "Процент ресурсов от стоимости дома, который будет требоватся на защиту дома в 1% и длительностью 1 час")] public float FyFSbfbFsugNCQPEcTYwgViqXvNJYM; [JsonProperty(PropertyName = "Коррекционный коэффициент для стоимости защиты в зависимости от количества строительных блоков")] public Dictionary<int, float> udJYCpbEzuJHHiaBgHiIjGVDRW; [JsonProperty(PropertyName = "Коррекционный коэффициент для стоимости защиты с вип привилегиями")] public Dictionary<string, float> byNFtPigVDNuPTqiNFIV; [JsonProperty(PropertyName = "Строительные объекты которые требуется защищать (помимо строительных блоков)")] public List<string> zJYkgpJHDSsNREfyHhmjf; [JsonProperty(PropertyName = "Минимальный разрешенный процент защиты")] public int YxdtJNemecgyegrsApTAmpUD; [JsonProperty(PropertyName = "Максимальный разрешенный процент защиты")] public int huruqQKdraVovZBmpkxJVdJb; [JsonProperty(PropertyName = "Шаг изменения процентов")] public int vgxvQdfehcBa; [JsonProperty(PropertyName = "Коэффициент увеличения стоимости защиты на каждый шаг процента")] public float yIUmCjgDLih; [JsonProperty(PropertyName = "Минимальное количество часов защиты")] public int yczkCuQTZObFoEWVhjRmSgl; [JsonProperty(PropertyName = "Максимальное количество часов защиты")] public int bKqOdBBuLuEbwaoDWdLftgQl; [JsonProperty(PropertyName = "Коэффициент увеличения стоимости защиты на каждый дополнительный час")] public float PTAxFMEoLPvdmSJKR; [JsonProperty(PropertyName = "Замена стандартных ресурсов на свои ресурсы или предметы")] public Dictionary<string, YaeTHASHmpx> UyCiuPAVpIePcZqusTn = new Dictionary<string, YaeTHASHmpx>(); [JsonProperty(PropertyName = "Названия ресурсов в меню")] public Dictionary<string, string> uekIFKWiDT = new Dictionary<string, string>(); [JsonProperty(PropertyName = "Цвет панели 1")] public string gqYWyqIPghYShSuRHooLlhtnT; [JsonProperty(PropertyName = "Цвет панели 2")] public string PzLkaNIXiEoXsobwBBhcelYZw; [JsonProperty(PropertyName = "Цвет кнопки закрытия панели")] public string wGvRZXoWPQvBgkfDEzugQDgXBJFJ; [JsonProperty(PropertyName = "Цвет панели информационного сообщения")] public string yniMHiVFyd; [JsonProperty(PropertyName = "Цвет кнопок и акцентированного текста")] public string BkHejxOINcSUOzjmiWDahxLg; [JsonProperty(PropertyName = "Цвет акцентированного текста для предметов")] public string SbbdVbbCRU; [JsonProperty(PropertyName = "Ссылка на картинку информирующей о защите дома")] public string PiJaDAGVeuFyWiDKactrDRAuhnajhz; [JsonProperty(PropertyName = "Позиция иконки (MinX MinY)")] public string AnchorMin; [JsonProperty(PropertyName = "Позиция иконки (MaxX MaxY)")] public string AnchorMax; [JsonProperty(PropertyName = "Включать отображение иконки сразу для всех авторизованных в шкафу")] public bool AutoEnableIcon; [JsonProperty(PropertyName = "Чат команда для активации меню шкафа в зоне действия шкафа (если пусто, - не используется)")] public string CommandChatBP; [JsonProperty(PropertyName = "Разрешать взрывом по дому проверять наличие у него защиты")] public bool aYQnBANSjsFGzKOf; [JsonProperty(PropertyName = "Задержка вывода повторного сообщения о наличии защиты у дома (секунды)")] public int XsYIeQxdlMoJqCssCQzljApcGdtG; } private class YaeTHASHmpx { [JsonProperty(PropertyName = "Название нового ресурса или предмета")] public string JDcZYhDHxYvDE; [JsonProperty(PropertyName = "Рейт нового ресурса по отношению к одной еденице старого (0 - не использовать вообще)")] public float XbTLPuZbhqqvJWRfrC; } private void htPGTdfQfJPtdtGTDsLmtGTvpxvxMp() { arYyoRcCywByxnRDoH = Config.ReadObject<ConfigData>(); if (arYyoRcCywByxnRDoH.udJYCpbEzuJHHiaBgHiIjGVDRW == null) { arYyoRcCywByxnRDoH.udJYCpbEzuJHHiaBgHiIjGVDRW = new Dictionary<int, float>() { { 1, 1f }, { 15, 0.95f }, { 50, 0.85f }, { 125, 0.6f }, { 200, 0.4f } }; oemcSUfxaTkeLYsdBfc(arYyoRcCywByxnRDoH); } if (arYyoRcCywByxnRDoH.byNFtPigVDNuPTqiNFIV == null) { arYyoRcCywByxnRDoH.byNFtPigVDNuPTqiNFIV = new Dictionary<string, float>() { { "buildingprotection.vip", 0.75f }, { "buildingprotection.premium", 0.5f } }; oemcSUfxaTkeLYsdBfc(arYyoRcCywByxnRDoH); } } protected override void LoadDefaultConfig() { arYyoRcCywByxnRDoH = new ConfigData { FyFSbfbFsugNCQPEcTYwgViqXvNJYM = 1f, udJYCpbEzuJHHiaBgHiIjGVDRW = new Dictionary<int, float>() { { 1, 1f }, { 15, 0.95f }, { 50, 0.85f }, { 125, 0.6f }, { 200, 0.4f } }, byNFtPigVDNuPTqiNFIV = new Dictionary<string, float>() { { "buildingprotection.vip", 0.75f }, { "buildingprotection.premium", 0.5f } }, zJYkgpJHDSsNREfyHhmjf = new List<string>() { "floor.grill", "door.hinged.toptier", "door.double.hinged.toptier", "gates.external.high.stone", "wall.external.high.stone", "gates.external.high.wood", "wall.external.high", "floor.ladder.hatch", "shutter.metal.embrasure.a", "shutter.metal.embrasure.b", "wall.window.bars.metal", "wall.frame.cell.gate", "wall.frame.cell", "wall.window.bars.toptier", "wall.window.glass.reinforced", "door.hinged.metal", "door.double.hinged.metal", "door.hinged.wood", "door.double.hinged.wood", "wall.frame.garagedoor", "wall.frame.shopfront.metal", "cupboard.tool.deployed" }, YxdtJNemecgyegrsApTAmpUD = 10, huruqQKdraVovZBmpkxJVdJb = 80, vgxvQdfehcBa = 10, yIUmCjgDLih = 1f, yczkCuQTZObFoEWVhjRmSgl = 1, bKqOdBBuLuEbwaoDWdLftgQl = 24, PTAxFMEoLPvdmSJKR = 1f, UyCiuPAVpIePcZqusTn = new Dictionary<string, YaeTHASHmpx>() { { "wood1", new YaeTHASHmpx() { JDcZYhDHxYvDE = "scrap", XbTLPuZbhqqvJWRfrC = 0.1f } }, { "stones1", new YaeTHASHmpx() { JDcZYhDHxYvDE = "scrap", XbTLPuZbhqqvJWRfrC = 0.05f } }, { "metal.fragments1", new YaeTHASHmpx() { JDcZYhDHxYvDE = "scrap", XbTLPuZbhqqvJWRfrC = 0.2f } }, { "metal.refined1", new YaeTHASHmpx() { JDcZYhDHxYvDE = "scrap", XbTLPuZbhqqvJWRfrC = 5f } } }, uekIFKWiDT = new Dictionary<string, string>() { { "wood", "Дерево" }, { "stones", "Камень" }, { "metal.fragments", "Металл-фрагменты" }, { "metal.refined", "МВК" }, { "scrap", "Скрап" } }, gqYWyqIPghYShSuRHooLlhtnT = "0.3 0.3 0.3 0.9", PzLkaNIXiEoXsobwBBhcelYZw = "0.5 0.5 0.5 0.9", wGvRZXoWPQvBgkfDEzugQDgXBJFJ = "0.9 0.3 0.3 0.9", yniMHiVFyd = "0.8 0.3 0.3 1", BkHejxOINcSUOzjmiWDahxLg = "0.95 0.49 0.28 1", SbbdVbbCRU = "1 0.5 0.48 1", PiJaDAGVeuFyWiDKactrDRAuhnajhz = "https://i.imgur.com/VLYW2dR.png", AnchorMin = "0.288 0.025", AnchorMax = "0.331 0.095", AutoEnableIcon = true, CommandChatBP = "bp", aYQnBANSjsFGzKOf = false, XsYIeQxdlMoJqCssCQzljApcGdtG = 180 }; oemcSUfxaTkeLYsdBfc(arYyoRcCywByxnRDoH); timer.Once(0.1f, ()=> oemcSUfxaTkeLYsdBfc(arYyoRcCywByxnRDoH)); } private void oemcSUfxaTkeLYsdBfc(ConfigData RGCFhAPNHsKuPEU) => Config.WriteObject(RGCFhAPNHsKuPEU, true); private static JMtcnixYfDPaICxDq fFXlNOaDpM; private class JMtcnixYfDPaICxDq { [JsonProperty(PropertyName = "_blocks_")] public Dictionary<uint, SbfmlOGavlfz> FJblgubrcofQAqy = new Dictionary<uint, SbfmlOGavlfz>(); [JsonProperty(PropertyName = "_players_")] public Dictionary<ulong, List<uint>> qYRLmeQQhezbQk = new Dictionary<ulong, List<uint>>(); } private class SbfmlOGavlfz { [JsonProperty(PropertyName = "_perc_")] public float aOcKgYsiyGLZqCTJhFXIezcDCh; [JsonProperty(PropertyName = "_time_")] public long EGNIlRsVsdVdQSMNvcyj; [JsonProperty(PropertyName = "_flag_")] public bool YTyclzzTMPRn; } private void hMKgDXpDLmRwgZeQomY() => fFXlNOaDpM = Interface.GetMod().DataFileSystem.ReadObject<JMtcnixYfDPaICxDq>("BuildingProtectionData"); private void OfGZZIBPEJVfix() => Interface.GetMod().DataFileSystem.WriteObject("BuildingProtectionData", fFXlNOaDpM); } } 


// --- End of file: BuildingProtection.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SleepingSystem.cs ---
// --- Original Local Path: SleepingSystem.cs ---

using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("SleepingSystem", "Hougan", "0.0.1")]
    public class SleepingSystem : RustPlugin
    {
        #region Classes

        private class Configuration
        {
            [JsonProperty("Количество восстанавливаемого здоровья за одну секунду")]
            public float HealPerSecond = 1f;
            [JsonProperty("Количество отнимаемого 'голода' за одну секунду")]
            public float CaloriedPerSecond = 4f; 
            [JsonProperty("Количество отнимаемой 'воды' за одну секунду")]
            public float HydraPerSecond = 2f; 

            [JsonProperty("Разрешать спать только на спальниках")]
            public bool SleepOnlyOnBag = true; 
            [JsonProperty("Запрещать спать в зоне чужого шкафа")]
            public bool BlockBuildSleep = true;
        }

        private class Sleeper : MonoBehaviour
        {
            private const string UpdateLayer = Layer + ".CounterLayer";
            private const string HydraLayer = Layer + ".Hydra";
            private const string FoodLayer = Layer + ".Food";
            private const string Layer = "UI_SleeperLayer";
            
            private BasePlayer Player;
            private float Interval = 0.25f;
            
            private float HealAmount;
            private float HydraAmount;
            private float CaloriesAmount;
            
            public void Awake()
            {
                Player = GetComponent<BasePlayer>();
                Player.StartSleeping();

                HealAmount = Interval * Settings.HealPerSecond;
                HydraAmount = Interval * Settings.HydraPerSecond;
                CaloriesAmount = Interval * Settings.CaloriedPerSecond;
                
                DrawInterface();
                
                InvokeRepeating(nameof(ControlUpdate), 0, Interval); 
            }

            public void DrawInterface()
            {
                CuiHelper.DestroyUi(Player, Layer);
                
                CuiElementContainer container = new CuiElementContainer();
                
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0.5 0.2", AnchorMax = "0.5 0.2", OffsetMin = "-220 -20", OffsetMax = "220 20" },
                    Image = { Color = "1 1 1 0.2", Material = "" }
                }, "Overlay", Layer);
                
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0 0.7", AnchorMax = $"1 1", OffsetMin = "35 -55", OffsetMax = "-35 -45" },
                    Image = { Color = "1 1 1 0.202840789", Material = "" }
                }, Layer, FoodLayer);
                
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0 0.7", AnchorMax = $"1 1", OffsetMin = "35 -80", OffsetMax = "-35 -70" },
                    Image = { Color = "1 1 1 0.200728489", Material = "" }
                }, Layer, HydraLayer);

                if (Settings.CaloriedPerSecond + Settings.HydraPerSecond > 0)
                {
                    container.Add(new CuiLabel 
                    {
                        RectTransform = { AnchorMin = $"0 1", AnchorMax = "1 1", OffsetMin = "-200 5", OffsetMax = "200 500" },
                        Text = { Text = "Во время восстановления здоровья, тратятся калории, имейте ввиду!", Align = TextAnchor.LowerCenter, Font = "robotocondensed-regular.ttf", Color = "1 1 1 0.4" }
                    }, Layer);
                }

                CuiHelper.AddUi(Player, container);
            }

            public void ControlUpdate()
            {
                if (Player.IsDead() || Player.IsWounded())
                {
                    Destroy(this);
                    return;
                }

                if (Player.health != 100)
                {
                    Player.metabolism.calories.Subtract(CaloriesAmount);
                    Player.metabolism.hydration.Subtract(HydraAmount); 
                    Player.metabolism.SendChangesToClient();
                    Player.Heal(HealAmount);
                }

                if (Player.metabolism.calories.value < CaloriesAmount || Player.metabolism.hydration.value < HydraAmount)
                {
                    Destroy(this);
                    return;
                }


                UpdateInterface();
            }

            public void UpdateInterface()
            {
                CuiHelper.DestroyUi(Player, UpdateLayer);
                CuiHelper.DestroyUi(Player, UpdateLayer + ".F");
                CuiHelper.DestroyUi(Player, UpdateLayer + ".D");
                
                CuiHelper.DestroyUi(Player, Layer + ".UpdateLayer");
                CuiElementContainer container = new CuiElementContainer();
                
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"{Player.health / Player._maxHealth} 1", OffsetMax = "0 0" },
                    Image = { Color = "0.5 0.8 0.5 0.6", Material = "" }
                }, Layer, UpdateLayer);
                
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"{Player.metabolism.calories.value / Player.metabolism.calories.max} 1", OffsetMax = "0 0" },
                    Image = { Color = "1 0.8 0.5 0.6", Material = "" }
                }, FoodLayer, UpdateLayer + ".F"); 
                
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"{Player.metabolism.hydration.value / Player.metabolism.hydration.max} 1", OffsetMax = "0 0" },
                    Image = { Color = "0.5 0.8 0.8 0.6", Material = "" }
                }, HydraLayer, UpdateLayer + ".D");
                
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Text = { Text = $"{Player.health:F1} / {Player._maxHealth:F1} HP", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 24 }
                }, Layer, Layer + ".UpdateLayer");

                CuiHelper.AddUi(Player, container);
            }

            public void OnDestroy()
            {
                if (Player.IsConnected)
                {
                    CuiHelper.DestroyUi(Player, Layer);
                    Player.EndSleeping();
                }
                
            }
        }
        
        #endregion

        #region Variables

        private static Configuration Settings = new Configuration();

        #endregion

        #region Hooks
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            { 
                Settings = Config.ReadObject<Configuration>();
                if (Settings == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }
            
            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => Settings = new Configuration(); 
        protected override void SaveConfig() => Config.WriteObject(Settings);

        private void OnPlayerInput(BasePlayer player, InputState state)
        {
            if (state.IsDown(BUTTON.DUCK) && state.WasJustPressed(BUTTON.RELOAD))
            {
                if (Settings.BlockBuildSleep && player.IsBuildingBlocked())
                {
                    player.ChatMessage("Вы не можете спать на чужой территории!");
                    return;
                }
                if (Settings.SleepOnlyOnBag) 
                {
                    RaycastHit hitInfo; 
                    if (!Physics.Raycast(player.transform.position, Vector3.down, out hitInfo, 2.284f) || hitInfo.GetEntity() == null) return;
                    var entity = hitInfo.GetEntity();
                    
                    if (!(entity is SleepingBag)) return;
                }
                var obj = player.GetComponent<Sleeper>();
                if (obj == null) player.gameObject.AddComponent<Sleeper>();
            }
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            var obj = player.GetComponent<Sleeper>();
            if (obj != null) UnityEngine.Object.Destroy(obj); 
        }

        private void Unload()
        {
            foreach (var sleeper in UnityEngine.Object.FindObjectsOfType<Sleeper>())
                UnityEngine.Object.Destroy(sleeper);
        }

        #endregion
    }
}

// --- End of file: SleepingSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Remove.cs ---
// --- Original Local Path: Remove.cs ---

﻿using Facepunch; using Oxide.Core; using Oxide.Core.Configuration; using Oxide.Core.Libraries; using Oxide.Core.Plugins;using Oxide.Game.Rust.Cui;using System;using System.Collections.Generic;using System.Linq;using UnityEngine;namespace Oxide.Plugins {[Info("Remove", "Admin", "1.2.4")] class Remove : RustPlugin { static Remove inst; int resetTime; float refundPercent; float refundItemsPercent; float refundStoragePercent; bool friendRemove; bool clanRemove; bool EnTimedRemove; bool cupboardRemove; bool selfRemove; bool removeFriends; bool removeClans; bool refundItemsGive; float Timeout; private string PanelAnchorMin; private string PanelAnchorMax; private string PanelColor; private bool useNoEscape; private int TextFontSize; private string TextСolor; private string TextAnchorMin; private string TextAnchorMax; private bool EnabledBuildingUpgrade; protected override void LoadDefaultConfig() { GetVariable(Config, "Время действия режима удаления", out resetTime, 40); GetVariable(Config, "Включить выключение авто-улучшения при включении режима удаления (Поддержка плагина BuildingUpgrade с сайта RustPlugin.ru)", out EnabledBuildingUpgrade, false); GetVariable(Config, "Включить запрет на удаление объекта для игрока после истечения N времени указанным в конфигурации", out EnTimedRemove, false); GetVariable(Config, "Время на запрет удаление объекта после истечения указаного времени (в секундах)", out Timeout, 3600.0f); GetVariable(Config, "Процент возвращаемых ресурсов с Items (Максимум 1.0 - это 100%)", out refundItemsPercent, 1.0f); GetVariable(Config, "Процент возвращаемых ресурсов с построек (Максимум 1.0 - это 100%)", out refundPercent, 1.0f); GetVariable(Config, "Включить возрат объектов (При удаление объектов(сундуки, печки и тд.) будет возращать объект а не ресурсы)", out refundItemsGive, false); GetVariable(Config, "Процент выпадающих ресурсов (не вещей) с удаляемых ящиков (Максимум 1.0 - это 100%)", out refundStoragePercent, 1.0f); GetVariable(Config, "Разрешить удаление объектов друзей без авторизации в шкафу", out friendRemove, false); GetVariable(Config, "Разрешить удаление объектов соклановцев без авторизации в шкафу", out clanRemove, false); GetVariable(Config, "Разрешить удаление чужих объектов при наличии авторизации в шкафу", out cupboardRemove, false); GetVariable(Config, "Разрешить удаление собственных объектов без авторизации в шкафу", out selfRemove, false); GetVariable(Config, "Включить поддержку NoEscape (С сайта RustPlugin.ru)", out useNoEscape, false); GetVariable(Config, "Разрешить удаление обьектов друзьям", out removeFriends, false); GetVariable(Config, "Разрешить удаление объектов соклановцев", out removeClans, false); GetVariable(Config, "GUI: Панель AnchorMin", out PanelAnchorMin, "0.0 0.908"); GetVariable(Config, "GUI: Панель AnchorMax", out PanelAnchorMax, "1 0.958"); GetVariable(Config, "GUI: Цвет фона", out PanelColor, "0 0 0 0.50"); GetVariable(Config, "GUI: Размер текста", out TextFontSize, 18); GetVariable(Config, "GUI: Цвет текста", out TextСolor, "0 0 0 1"); GetVariable(Config, "GUI: Текст AnchorMin", out TextAnchorMin, "0 0"); GetVariable(Config, "GUI: Текст AnchorMax", out TextAnchorMax, "1 1"); SaveConfig(); } public static void GetVariable<T>(DynamicConfigFile config, string name, out T value, T defaultValue) { config[name] = value = config[name] == null ? defaultValue : (T)Convert.ChangeType(config[name], typeof(T)); } static int constructionColl = LayerMask.GetMask(new string[] { "Construction", "Deployable", "Prevent Building", "Deployed" }); private static Dictionary<string, int> deployedToItem = new Dictionary<string, int>(); Dictionary<BasePlayer, int> timers = new Dictionary<BasePlayer, int>(); Dictionary<ulong, string> activePlayers = new Dictionary<ulong, string>(); int currentRemove = 0;[PluginReference] Plugin Clans;[PluginReference] Plugin Friends;[PluginReference] Plugin NoEscape;[PluginReference] Plugin MutualPermission;[PluginReference] Plugin BuildingUpgrade; bool IsClanMember(ulong playerID, ulong targetID) { if (plugins.Exists("Clans")) return (bool)(Clans?.Call("IsTeammate", playerID, targetID) ?? false); return false; } bool IsFriends(ulong playerID, ulong friendId) { if (plugins.Exists("Friends")) { return (bool)(Friends?.Call("AreFriends", playerID, friendId) ?? false); } if (plugins.Exists("MutualPermission")) return (bool)(MutualPermission?.Call("isPermissionAllowed", "Home", playerID, friendId) ?? false); return false; } private Dictionary<BasePlayer, DateTime> Cooldowns = new Dictionary<BasePlayer, DateTime>(); private double Cooldown = 30f; private void OnPlayerActiveItemChanged(BasePlayer player, Item newItem) { Item activeItem = player.GetActiveItem(); if (activeItem == null || activeItem.info.shortname != "building.planner") return; if (EnTimedRemove) { if (activeItem.info.shortname == "building.planner") { if (Cooldowns.ContainsKey(player)) { double seconds = Cooldowns[player].Subtract(DateTime.Now).TotalSeconds; if (seconds >= 0) return; } SendReply(player, Messages["enabledRemoveTimer"], NumericalFormatter.FormatTime(Timeout, player.userID)); Cooldowns[player] = DateTime.Now.AddSeconds(Cooldown); } } }[ChatCommand("remove")] void cmdRemove(BasePlayer player, string command, string[] args) { if (player == null) return; if (!permission.UserHasPermission(player.UserIDString, "remove.use")) { SendReply(player, Messages["NoPermission"]); return; } if (args == null || args.Length == 0) { if (activePlayers.ContainsKey(player.userID)) { timers.Remove(player); DeactivateRemove(player.userID); DestroyUI(player); return; } else { if (EnabledBuildingUpgrade) { var upgradeEnabled = (bool)BuildingUpgrade?.Call("BuildingUpgradeActivate", player.userID); if (upgradeEnabled) { BuildingUpgrade?.Call("BuildingUpgradeDeactivate", player.userID); } } SendReply(player, Messages["enabledRemove"]); timers[player] = resetTime; DrawUI(player, resetTime, "normal"); ActivateRemove(player.userID, "normal"); return; } } switch (args[0]) { case "admin": if (!permission.UserHasPermission(player.UserIDString, "remove.admin") && !player.IsAdmin) { SendReply(player, Messages["NoPermission"]); return; } if (activePlayers.ContainsKey(player.userID)) { timers.Remove(player); DeactivateRemove(player.userID); DestroyUI(player); return; } timers[player] = resetTime; DrawUI(player, resetTime, "admin"); ActivateRemove(player.userID, "admin"); break; case "all": if (!permission.UserHasPermission(player.UserIDString, "remove.admin") && !player.IsAdmin) { SendReply(player, Messages["NoPermission"]); return; } if (activePlayers.ContainsKey(player.userID)) { timers.Remove(player); DeactivateRemove(player.userID); DestroyUI(player); return; } timers[player] = resetTime; DrawUI(player, resetTime, "all"); ActivateRemove(player.userID, "all"); break; } }[ConsoleCommand("remove.toggle")] void cmdConsoleRemove(ConsoleSystem.Arg args) { var player = args.Player(); if (player == null) return; if (!permission.UserHasPermission(player.UserIDString, "remove.use")) { SendReply(player, Messages["NoPermission"]); return; } if (args.Args == null || args.Args.Length == 0) { if (activePlayers.ContainsKey(player.userID)) { timers.Remove(player); DeactivateRemove(player.userID); DestroyUI(player); return; } else { SendReply(player, Messages["enabledRemove"]); timers[player] = resetTime; DrawUI(player, resetTime, "normal"); ActivateRemove(player.userID, "normal"); return; } } switch (args.Args[0]) { case "admin": if (!permission.UserHasPermission(player.UserIDString, "remove.admin") && !player.IsAdmin) { SendReply(player, Messages["NoPermission"]); return; } if (activePlayers.ContainsKey(player.userID)) { timers.Remove(player); DeactivateRemove(player.userID); DestroyUI(player); return; } timers[player] = resetTime; DrawUI(player, resetTime, "admin"); ActivateRemove(player.userID, "admin"); break; case "all": if (!permission.UserHasPermission(player.UserIDString, "remove.admin") && !player.IsAdmin) { SendReply(player, Messages["NoPermission"]); return; } if (activePlayers.ContainsKey(player.userID)) { timers.Remove(player); DeactivateRemove(player.userID); DestroyUI(player); return; } timers[player] = resetTime; DrawUI(player, resetTime, "all"); ActivateRemove(player.userID, "all"); break; } } Dictionary<uint, float> entityes = new Dictionary<uint, float>(); void LoadEntity() { try { entityes = Interface.GetMod().DataFileSystem.ReadObject<Dictionary<uint, float>>($"Remove_NewEntity"); } catch { entityes = new Dictionary<uint, float>(); } } void CheckEntity() { List<uint> Listed = new List<uint>(); foreach (var ent in entityes) { var Entity = BaseEntity.serverEntities.Find(ent.Key); if (Entity == null) { Listed.Add(ent.Key); } } if (Listed.Count > 0) { Listed.ForEach(p => entityes.Remove(p)); } } void OnEntityBuilt(Planner plan, GameObject go) { if (plan == null || go == null) return; if (EnTimedRemove) { BaseEntity entity = go.ToBaseEntity(); if (entity?.net?.ID == null) return; entityes.Add(entity.net.ID, Timeout); } } void OnEntityKill(BaseNetworkable entity) { if (entity == null || entity?.net?.ID == null) return; try { if (entityes.ContainsKey(entity.net.ID)) entityes.Remove(entity.net.ID); } catch (NullReferenceException) { } } void OnNewSave() { if (EnTimedRemove) { Puts("Обнаружен вайп. Очищаем сохраненные объекты"); LoadEntity(); entityes.Clear(); } } void OnServerSave() { Interface.Oxide.DataFileSystem.WriteObject("Remove_NewEntity", entityes); } void Loaded() { if (EnTimedRemove) LoadEntity(); PermissionService.RegisterPermissions(this, permisions); } public List<string> permisions = new List<string>() { "remove.admin", "remove.use" }; void Unload() { foreach (var player in BasePlayer.activePlayerList) { DestroyUI(player); } OnServerSave(); } private Timer entitycheck; int check = 30; void OnServerInitialized() { inst = this; LoadDefaultConfig(); if (removeFriends) { if (!plugins.Exists("Friends")) { PrintWarning("Plugin Friends not found. Remove of friends buildings is disabled"); removeFriends = false; } } if (removeClans) { if (!plugins.Exists("Clans")) { PrintWarning("Plugin Clans not found. Remove of clans buildings is disabled"); removeClans = false; } } deployedToItem.Clear(); LoadEntity(); CheckEntity(); lang.RegisterMessages(Messages, this, "en"); Messages = lang.GetMessages("en", this); InitRefundItems(); timer.Every(1f, TimerHandler); if (EnTimedRemove) entitycheck = timer.Every(check, TimerEntity); List<ItemDefinition> ItemsDefinition = ItemManager.GetItemDefinitions() as List<ItemDefinition>; foreach (ItemDefinition itemdef in ItemsDefinition) { if (itemdef?.GetComponent<ItemModDeployable>() == null) continue; if (deployedToItem.ContainsKey(itemdef.GetComponent<ItemModDeployable>().entityPrefab.resourcePath)) continue; deployedToItem.Add(itemdef.GetComponent<ItemModDeployable>().entityPrefab.resourcePath, itemdef.itemid); } } private bool CupboardPrivlidge(BasePlayer player, Vector3 position, BaseEntity entity) { return player.IsBuildingAuthed(position, new Quaternion(0, 0, 0, 0), new Bounds(Vector3.zero, Vector3.zero)); } void RemoveAllFrom(Vector3 pos) { removeFrom.Add(pos); DelayRemoveAll(); } List<BaseEntity> wasRemoved = new List<BaseEntity>(); List<Vector3> removeFrom = new List<Vector3>(); void DelayRemoveAll() { if (currentRemove >= removeFrom.Count) { currentRemove = 0; removeFrom.Clear(); wasRemoved.Clear(); return; } List<BaseEntity> list = Pool.GetList<BaseEntity>(); Vis.Entities<BaseEntity>(removeFrom[currentRemove], 3f, list, constructionColl); for (int i = 0; i < list.Count; i++) { BaseEntity ent = list[i]; if (wasRemoved.Contains(ent)) continue; if (!removeFrom.Contains(ent.transform.position)) removeFrom.Add(ent.transform.position); wasRemoved.Add(ent); DoRemove(ent); } currentRemove++; timer.Once(0.01f, () => DelayRemoveAll()); } static void DoRemove(BaseEntity removeObject) { if (removeObject == null) return; StorageContainer Container = removeObject.GetComponent<StorageContainer>(); if (Container != null) { DropUtil.DropItems(Container.inventory, removeObject.transform.position, Container.dropChance); } EffectNetwork.Send(new Effect("assets/bundled/prefabs/fx/item_break.prefab", removeObject, 0, Vector3.up, Vector3.zero) { scale = UnityEngine.Random.Range(0f, 1f) }); removeObject.KillMessage(); } void TryRemove(BasePlayer player, BaseEntity removeObject) { RemoveAllFrom(removeObject.transform.position); } bool OnRemoveActivate(ulong player) { if (activePlayers.ContainsKey(player)) { return true; } return false; } void RemoveDeativate(ulong player) { if (activePlayers.ContainsKey(player)) { var pl = BasePlayer.FindByID(player); if (pl != null) { timers.Remove(pl); DeactivateRemove(pl.userID); DestroyUI(pl); } } } object OnHammerHit(BasePlayer player, HitInfo info) { if (info == null) return null; var entity = info?.HitEntity; if (entity == null) return null; if (entity.IsDestroyed) return false; if (!activePlayers.ContainsKey(player.userID)) return null; if (entity.OwnerID == 0) return false; switch (activePlayers[player.userID]) { case "all": TryRemove(player, info.HitEntity); var pos = player.transform.position; RemoveEntityAll(player, entity, pos); return true; case "admin": RemoveEntityAdmin(player, entity); return true; case "normal": if (entity.ShortPrefabName.Contains("recycler")) return false; if ((!(entity is DecayEntity) && !(entity is Signage)) && !entity.ShortPrefabName.Contains("shelves") && !entity.ShortPrefabName.Contains("ladder") && !entity.ShortPrefabName.Contains("quarry")) return null; if (!entity.OwnerID.IsSteamId()) return null; var ret = Interface.Call("CanRemove", player, entity); if (ret is string) { SendReply(player, (string)ret); return null; } if (ret is bool && (bool)ret) { RemoveEntity(player, entity); return true; } if (useNoEscape) { if (plugins.Exists("NoEscape")) { var time = (bool)NoEscape.Call("IsRaidBlock", player.userID); if (time) { SendReply(player, string.Format(Messages["raidremove"], NumericalFormatter.FormatTime(Convert.ToInt32(time), player.userID))); return null; } } } var privilege = player.GetBuildingPrivilege(player.WorldSpaceBounds()); if (cupboardRemove) { if (privilege != null && player.IsBuildingAuthed()) { RemoveEntity(player, entity); return true; } } if (privilege != null && !player.IsBuildingAuthed()) { if (selfRemove && entity.OwnerID == player.userID) { RemoveEntity(player, entity); return true; } if (friendRemove) { if (removeFriends) { if (IsFriends(entity.OwnerID, player.userID)) { RemoveEntity(player, entity); return true; } } } if (clanRemove) { if (removeClans) { if (IsClanMember(entity.OwnerID, player.userID)) { RemoveEntity(player, entity); return true; } } } SendReply(player, Messages["ownerCup"]); return false; } if (entity.OwnerID != player.userID) { if (removeFriends) { if (IsFriends(entity.OwnerID, player.userID)) { RemoveEntity(player, entity); return true; } } if (removeClans) { if (IsClanMember(entity.OwnerID, player.userID)) { RemoveEntity(player, entity); return true; } } SendReply(player, Messages["norights"]); return false; } RemoveEntity(player, entity); return true; } return null; } private static string Format(int units, string form1, string form2, string form3) { var tmp = units % 10; if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9) return $"{units} {form1}"; if (tmp >= 2 && tmp <= 4) return $"{units} {form2}"; return $"{units} {form3}"; } private static class NumericalFormatter { private static string GetNumEndings(int origNum, string[] forms) { string result; var num = origNum % 100; if (num >= 11 && num <= 19) { result = forms[2]; } else { num = num % 10; switch (num) { case 1: result = forms[0]; break; case 2: case 3: case 4: result = forms[1]; break; default: result = forms[2]; break; } } return string.Format("{0} {1} ", origNum, result); } private static bool IsEng(object player) => inst.lang.GetLanguage(GetUserId(player)) != "ru"; private static string FormatSeconds(int seconds, bool eng) => GetNumEndings(seconds, eng ? new[] { "second", "seconds", "seconds" } : new[] { "секунда", "секунды", "секунд" }); private static string FormatMinutes(int minutes, bool eng) => GetNumEndings(minutes, eng ? new[] { "minute", "minutes", "minutes" } : new[] { "минута", "минуты", "минут" }); private static string FormatHours(int hours, bool eng) => GetNumEndings(hours, eng ? new[] { "hour", "hours", "hours" } : new[] { "час", "часа", "часов" }); private static string FormatDays(int days, bool eng) => GetNumEndings(days, eng ? new[] { "day", "days", "days" } : new[] { "день", "дня", "дней" }); private static string FormatTime(TimeSpan timeSpan, bool eng) { string result = string.Empty; if (timeSpan.Days > 0) result += FormatDays(timeSpan.Days, eng); if (timeSpan.Hours > 0) result += FormatHours(timeSpan.Hours, eng); if (timeSpan.Minutes > 0) result += FormatMinutes(timeSpan.Minutes, eng); if (timeSpan.Seconds > 0) result += FormatSeconds(timeSpan.Seconds, eng).TrimEnd(' '); return result; } public static string FormatTime(int seconds, object player) => FormatTime(new TimeSpan(0, 0, seconds), IsEng(player)); public static string FormatTime(float seconds, object player) => FormatTime((int)Math.Round(seconds), player); public static string FormatTime(TimeSpan time, object player) => FormatTime((int)Math.Round(time.TotalSeconds), player); public static string FromatSlots(int slots, object player) => GetNumEndings(slots, IsEng(player) ? new[] { "slot", "slots", "slots" } : new[] { "слот", "слота", "слотов" }); } private static string GetUserId(object player) { var id = player is BasePlayer ? ((BasePlayer)player).UserIDString : player.ToString(); if (inst.permission.UserIdValid(id)) return id; inst.PrintError($"Trying to get the player data with invalide UserID \"{player}\"!"); return null; } void TimerEntity() { List<uint> remove = entityes.Keys.ToList().Where(ent => (entityes[ent] -= check) < 0).ToList(); List<uint> Remove = new List<uint>(); foreach (var entity in entityes) { var seconds = entity.Value; if (seconds < 0.0f) { Remove.Add(entity.Key); continue; } if (seconds > Timeout) { entityes[entity.Key] = Timeout; continue; } } foreach (var id in Remove) { entityes.Remove(id); } } void TimerHandler() { foreach (var player in timers.Keys.ToList()) { var seconds = --timers[player]; if (seconds <= 0) { timers.Remove(player); DeactivateRemove(player.userID); DestroyUI(player); continue; } DrawUI(player, seconds, activePlayers[player.userID]); } } void RemoveEntity(BasePlayer player, BaseEntity entity) { if (EnTimedRemove) { if (!entityes.ContainsKey(entity.net.ID)) { SendReply(player, Messages["blockremovetime"], NumericalFormatter.FormatTime(Timeout, player.userID)); return; } } Refund(player, entity); entity.Kill(); UpdateTimer(player, "normal"); } void RemoveEntityAdmin(BasePlayer player, BaseEntity entity) { entity.Kill(); UpdateTimerAdmin(player, "admin"); } void RemoveEntityAll(BasePlayer player, BaseEntity entity, Vector3 pos) { removeFrom.Add(pos); DelayRemoveAll(); UpdateTimerAll(player, "all"); } Dictionary<uint, Dictionary<ItemDefinition, int>> refundItems = new Dictionary<uint, Dictionary<ItemDefinition, int>>(); void Refund(BasePlayer player, BaseEntity entity) { if (entity is BuildingBlock) { BuildingBlock buildingblock = entity as BuildingBlock; if (buildingblock.blockDefinition == null) return; int buildingblockGrade = (int)buildingblock.grade; if (buildingblock.blockDefinition.grades[buildingblockGrade] != null) { float refundRate = buildingblock.healthFraction * refundPercent; List<ItemAmount> currentCost = buildingblock.blockDefinition.grades[buildingblockGrade].costToBuild as List<ItemAmount>; foreach (ItemAmount ia in currentCost) { int amount = (int)(ia.amount * refundRate); if (amount <= 0 || amount > ia.amount || amount >= int.MaxValue) amount = 1; if (refundRate != 0) { Item x = ItemManager.CreateByItemID(ia.itemid, amount); player.GiveItem(x, BaseEntity.GiveItemReason.PickedUp); } } } return; } StorageContainer storage = entity as StorageContainer; if (storage) { if (storage.inventory.itemList.Count > 0) for (int i = storage.inventory.itemList.Count - 1; i >= 0; i--) { var item = storage.inventory.itemList[i]; if (item == null) continue; if (item.info.shortname == "water") continue; item.amount = (int)(item.amount * refundStoragePercent); float single = 20f; Vector3 vector32 = Quaternion.Euler(UnityEngine.Random.Range(-single * 0.1f, single * 0.1f), UnityEngine.Random.Range(-single * 0.1f, single * 0.1f), UnityEngine.Random.Range(-single * 0.1f, single * 0.1f)) * Vector3.up; BaseEntity baseEntity = item.Drop(storage.transform.position + (Vector3.up * 0f), vector32 * UnityEngine.Random.Range(5f, 10f), UnityEngine.Random.rotation); baseEntity.SetAngularVelocity(UnityEngine.Random.rotation.eulerAngles * 5f); } } if (deployedToItem.ContainsKey(entity.gameObject.name)) { ItemDefinition def = ItemManager.FindItemDefinition(deployedToItem[entity.gameObject.name]); foreach (var ingredient in def.Blueprint.ingredients) { var reply = 1312; if (reply == 0) { } var amountOfIngridient = ingredient.amount; var amount = Mathf.Floor(amountOfIngridient * refundItemsPercent); if (amount <= 0 || amount > amountOfIngridient || amount >= int.MaxValue) amount = 1; if (!refundItemsGive) { if (refundItemsPercent != 0) { Item x = ItemManager.Create(ingredient.itemDef, (int)amount); player.GiveItem(x, BaseEntity.GiveItemReason.PickedUp); } } else { GiveAndShowItem(player, deployedToItem[entity.PrefabName], 1); return; } } } } void GiveAndShowItem(BasePlayer player, int item, int amount) { Item x = ItemManager.CreateByItemID(item, amount); player.GiveItem(x, BaseEntity.GiveItemReason.PickedUp); } void InitRefundItems() { foreach (var item in ItemManager.itemList) { var deployable = item.GetComponent<ItemModDeployable>(); if (deployable != null) { if (item.Blueprint == null || deployable.entityPrefab == null) continue; refundItems.Add(deployable.entityPrefab.resourceID, item.Blueprint.ingredients.ToDictionary(p => p.itemDef, p => (Mathf.CeilToInt(p.amount * refundPercent)))); } } } private string GUI = @"[{""name"": ""remove.panel"",""parent"": ""Hud"",""components"": [{""type"": ""UnityEngine.UI.Image"",""color"": ""{PanelColor}""},{""type"": ""RectTransform"",""anchormin"": ""{PanelAnchorMin}"",""anchormax"": ""{PanelAnchorMax}""}]}, {""name"": ""remove.text"",""parent"": ""remove.panel"",""components"": [{""type"": ""UnityEngine.UI.Text"",""text"": ""{msg}"",""fontSize"": ""{TextFontSize}"",""align"": ""MiddleCenter""}, {""type"": ""UnityEngine.UI.Outline"",""color"": ""{TextСolor}"",""distance"": ""0.1 -0.1""}, {""type"": ""RectTransform"",""anchormin"": ""{TextAnchorMin}"",""anchormax"": ""{TextAnchorMax}""}]}]"; void DrawUI(BasePlayer player, int seconds, string type) { DestroyUI(player); var msg = ""; if (type == "normal") { msg = Messages["RNormal"]; } else msg = type == "admin" ? Messages["RAdmin"] : Messages["RAll"]; CuiHelper.AddUi(player, GUI.Replace("{PanelColor}", PanelColor.ToString()).Replace("{PanelAnchorMin}", PanelAnchorMin.ToString()).Replace("{PanelAnchorMax}", PanelAnchorMax.ToString()).Replace("{TextFontSize}", TextFontSize.ToString()).Replace("{TextСolor}", TextСolor.ToString()).Replace("{TextAnchorMin}", TextAnchorMin.ToString()).Replace("{TextAnchorMax}", TextAnchorMax.ToString()).Replace("{msg}", msg).Replace("{1}", NumericalFormatter.FormatTime(seconds, player.userID))); } void DestroyUI(BasePlayer player) { CuiHelper.DestroyUi(player, "remove.panel"); CuiHelper.DestroyUi(player, "remove.text"); } void ActivateRemove(ulong userId, string type) { if (!activePlayers.ContainsKey(userId)) { activePlayers.Add(userId, type); } } void DeactivateRemove(ulong userId) { if (activePlayers.ContainsKey(userId)) { activePlayers.Remove(userId); } } void UpdateTimer(BasePlayer player, string type) { timers[player] = resetTime; DrawUI(player, timers[player], type); } void UpdateTimerAdmin(BasePlayer player, string type) { timers[player] = resetTime; DrawUI(player, timers[player], type); } void UpdateTimerAll(BasePlayer player, string type) { timers[player] = resetTime; DrawUI(player, timers[player], type); } Dictionary<string, string> Messages = new Dictionary<string, string>() { { "raidremove", "Ремув во время рейда запрещён!\nОсталось<color=#ffd479> {0}</color>" }, { "blockremovetime", "Извините, но этот объект уже нельзя удалить, он был создан более чем <color=#ffd479>{0}</color> назад" }, { "NoPermission", "У Вас нету прав на использование этой команды" }, { "enabledRemove", "<size=16>Используйте киянку для удаления объектов</size>" }, { "enabledRemoveTimer", "<color=#ffd479>Внимание:</color> Объекты созданые более чем <color=#ffd479>{0}</color> назад, удалить нельзя" }, { "ownerCup", "Что бы удалять постройки, вы должны быть авторизированы в шкафу" }, { "norights", "Вы не имеете права удалять чужие постройки!" }, { "RNormal", "Режим удаления выключится через <color=#ffd479>{1}</color>" }, { "RAdmin", "Режим админ удаления выключится через <color=#ffd479>{1}</color>" }, { "RAll", "Режим удаления всех объектов выключится через <color=#ffd479>{1}</color>" }, }; public static class PermissionService { public static Permission permission = Interface.GetMod().GetLibrary<Permission>(); public static bool HasPermission(BasePlayer player, string permissionName) { if (player == null || string.IsNullOrEmpty(permissionName)) return false; var uid = player.UserIDString; if (permission.UserHasPermission(uid, permissionName)) return true; return false; } public static void RegisterPermissions(Plugin owner, List<string> permissions) { if (owner == null) throw new ArgumentNullException("owner"); if (permissions == null) throw new ArgumentNullException("commands"); foreach (var permissionName in permissions.Where(permissionName => !permission.PermissionExists(permissionName))) { permission.RegisterPermission(permissionName, owner); } } } } }                   

// --- End of file: Remove.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AutoSkinTeam.cs ---
// --- Original Local Path: AutoSkinTeam.cs ---

using System.Collections.Generic;
using Oxide.Core.Plugins;
using Newtonsoft.Json.Linq;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("AutoSkinTeam", "Feyzi/Toolcub", "1.0.0")]
    public class AutoSkinTeam : RustPlugin
    {
        [PluginReference]
        private Plugin Clans;

        private HashSet<ulong> disabledChanges = new HashSet<ulong>();

        private const string PermUse = "autoskinteam.use";

        private void Init()
        {
            LoadData();
            permission.RegisterPermission(PermUse, this);
        }

        private void OnServerInitialized()
        {
            if (Clans == null)
            {
                Puts($"NO CLANS PLUGIN FOUND! UNLOADING PLUGIN!");
                Server.Command($"o.unload {Name}");
                return;
            }

            cmd.AddChatCommand("skinteam", this, nameof(ReskinCommand));
            cmd.AddChatCommand("autoskin", this, nameof(ReskinToggleCommand));
        }

        private void Unload()
        {
            SaveData();
        }

        private void ReskinCommand(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermUse))
            {
                SendReply(player, Lang("NoPermission", player.UserIDString));
                return;
            }

            string clanTag = Clans.Call<string>("GetClanOf", player);
            if (string.IsNullOrEmpty(clanTag))
            {
                SendReply(player, Lang("NoClan", player.UserIDString));
                return;
            }

            JObject newClan = Clans.Call<JObject>("GetClan", clanTag);
            string clanOwner = (string)newClan["owner"];

            if (clanOwner != player.UserIDString)
            {
                bool validMod = false;
                foreach (string mod in newClan["moderators"])
                {
                    if (mod == player.UserIDString)
                    {
                        validMod = true;
                        break;
                    }
                }

                if (!validMod)
                {
                    SendReply(player, Lang("NotClanOwner", player.UserIDString));
                    return;
                }
            }

            SetSkins(player, (JArray)newClan["members"]);
        }

        private void ReskinToggleCommand(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermUse))
            {
                SendReply(player, Lang("NoPermission", player.UserIDString));
                return;
            }

            if (disabledChanges.Contains(player.userID))
            {
                disabledChanges.Remove(player.userID);
                SendReply(player, Lang("SkinningEnabled", player.UserIDString));
            }
            else
            {
                disabledChanges.Add(player.userID);
                SendReply(player, Lang("SkinningDisabled", player.UserIDString));
            }
        }

        private void SetSkins(BasePlayer owner, JArray members)
        {
            Dictionary<string, ulong> playerSkins = new Dictionary<string, ulong>();
            foreach (var clothing in owner.inventory.containerWear.itemList)
                playerSkins.Add(clothing.info.shortname, clothing.skin);
            
            if (playerSkins.Count == 0)
            {
                SendReply(owner, Lang("NoItems", owner.UserIDString));
                return;
            }
            
            foreach (string member in members)
            {
                if (owner.UserIDString == member) 
                    continue;
                
                BasePlayer target = BasePlayer.FindAwakeOrSleeping(member);
                
                if (target == null) 
                    continue;
                
                if (disabledChanges.Contains(target.userID)) 
                    continue;
                
                bool changedAny = false;
                foreach (var item in target.inventory.containerWear.itemList)
                {
                    if (playerSkins.ContainsKey(item.info.shortname))
                    {
                        item.skin = playerSkins[item.info.shortname];
                        item.MarkDirty();
                        changedAny = true;
                    }
                }
                
                if (changedAny)
                    SendReply(target, Lang("SkinsUserUpdated", target.UserIDString));
            }
            SendReply(owner, Lang("SkinsUpdated", owner.UserIDString));
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoClan"] = "You are not in a clan!",
                ["NotClanOwner"] = "You are not a clan owner or moderator!",
                ["NoItems"] = "You don't have any wearable items on you!",
                ["SkinsUpdated"] = "Your teammates' skins have been updated!",
                ["SkinsUserUpdated"] = "Your skins have been updated by the clan owner.\nTo disable this feature, run /autoskin.",
                ["SkinningEnabled"] = "Clan owner skin synchronization has been enabled.",
                ["SkinningDisabled"] = "Clan owner skin synchronization has been disabled.",
                ["NoPermission"] = "You don't have permission to use this command!",
            }, this);
        }

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        private void LoadData()
        {
            disabledChanges = Interface.Oxide.DataFileSystem.ReadObject<HashSet<ulong>>(Name);
            timer.Every(Core.Random.Range(500, 700), SaveData);
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, disabledChanges);
    }
}


// --- End of file: AutoSkinTeam.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BlueprintBlocker.cs ---
// --- Original Local Path: BlueprintBlocker.cs ---

using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core;

using System.Data;
using System;
using System.Collections.Generic;
using System.Linq;

using UnityEngine;
namespace Oxide.Plugins
{
    [Info("BlueprintBlocker", "DylanSMR", "1.0.5")]
    [Description("Blocks certain blueprint items.")]
    class BlueprintBlocker : RustPlugin
    {      
        //////////////////////////////////////////////////////////////////////////////////////
        // Local Variables
        //////////////////////////////////////////////////////////////////////////////////////   
        
        private List<string> blueprintBlacklist = new List<string>(); 
        private uint FragAmount;
        private uint EFragAmount;
        private uint PlayerTotalFrags;
        private uint EntityTotalFrags;
        
        //////////////////////////////////////////////////////////////////////////////////////
        // Configuration API
        //////////////////////////////////////////////////////////////////////////////////////   
        
        void LoadDefaultConfig() {
            Config.Clear();
                Config["blueprintBlacklist"] = blueprintBlacklist;
                Config["NoBlueprintsAllowed"] = false;
                Config["DropNoBPFrags"] = false;
                Config["DropNoBPLibraries"] = false;
                Config["DropNoBPPages"] = false;
                Config["DropNoBPBooks"] = false;
                Config["NoUpgradeToPage"] = false;
                Config["NoUpgradeToBook"] = false;
                Config["NoUpgradeToLibrary"] = false;
                Config["SpawnedRemoverTest"] = false;
                Config["GiveItemsBack"] = true;
            Config.Save();
        }     
        
        //////////////////////////////////////////////////////////////////////////////////////
        // GetConfig(Params)
        //////////////////////////////////////////////////////////////////////////////////////   
        
        T GetConfig<T>(string key, T defaultValue) {
            try {
                var val = Config[key];
                if (val == null)
                    return defaultValue;
                if (val is List<object>) {
                    var t = typeof(T).GetGenericArguments()[0];
                    if (t == typeof(String)) {
                        var cval = new List<string>();
                        foreach (var v in val as List<object>)
                            cval.Add((string)v);
                        val = cval;
                    } else if (t == typeof(int)) {
                        var cval = new List<int>();
                        foreach (var v in val as List<object>)
                            cval.Add(Convert.ToInt32(v));
                        val = cval;
                    }
                } else if (val is Dictionary<string, object>) {
                    var t = typeof(T).GetGenericArguments()[1];
                    if (t == typeof(int)) {
                        var cval = new Dictionary<string,int>();
                        foreach (var v in val as Dictionary<string, object>)
                            cval.Add(Convert.ToString(v.Key), Convert.ToInt32(v.Value));
                        val = cval;
                    }
                }
                return (T)Convert.ChangeType(val, typeof(T));
            } catch (Exception ex) {
                return defaultValue;
            }
        }
        
        //////////////////////////////////////////////////////////////////////////////////////
        // Loaded(On Plugin Loaded)
        //////////////////////////////////////////////////////////////////////////////////////   
        
        void Loaded() {
            LoadLangaugeAPI();
            blueprintBlacklist = GetConfig("blueprintBlacklist", new List<string>());    
        }        
          
        //////////////////////////////////////////////////////////////////////////////////////
        // LoadLangaugeAPI
        //////////////////////////////////////////////////////////////////////////////////////   
          
        void LoadLangaugeAPI() {
			lang.RegisterMessages(new Dictionary<string,string>{
				["BP_NOLEARN"] = "<color='#DD0000'>You may not learn {0} as it is blacklisted!</color>",
                ["BP_NOPERMS"] = "<color='#DD0000'>You do not have auth level 1/2 so you cannot preform this command!</color>",
                ["BP_NOFRAGSFOUND"] = "No player or container had any blueprint fragments!", 
                ["BP_REMOVEDFRAGS"] = "Removed {0} frag(s) from {1} different player(s) and removed {2} frags from {3} container(s).", 
                ["BP_ADDEDTOCONFIG"] = "{0} was added to the blocked blueprints file.", 
                ["BP_ALREADYINCONFIG"] = "{0} is already in the config file.", 
                ["BP_NOINCONFIG"] = "{0} is not in the blueprint blacklist file.", 
                ["BP_REMOVEDFROMCONFIG"] = "{0} was removed from the blueprint blacklist file.", 
                ["BP_MAYNOTUSE"] = "<color='#DD0000'>You may not use {0} as it is blacklisted!</color>",
                ["BP_NOBP"] = "<color='#DD0000'>You may not reveal this blueprint as it is blacklisted.</color>",
			}, this);
        }   
          
        //////////////////////////////////////////////////////////////////////////////////////
        // GetMessage(LangaugeAPI)
        //////////////////////////////////////////////////////////////////////////////////////   
          
        private string GetMessage(string name, string sid = null) {
			return lang.GetMessage(name, this, sid);
		} 
                 
        //////////////////////////////////////////////////////////////////////////////////////
        // OnConsumableUse()
        //////////////////////////////////////////////////////////////////////////////////////             
        
        void OnConsumableUse(Item item) {
            try 
            {
                BasePlayer player = item.GetOwnerPlayer();   
                if(player == null)
                {
                    return;
                }       
                var playerInfo = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerInfo(player.userID);
                if(item == null)
                {
                    return;
                }
                if (playerInfo != null)
                {      
                    if(Convert.ToBoolean(Config["NoBlueprintsAllowed"]) && item.HasFlag(Item.Flag.Blueprint))
                    {
                        SendReply(player, string.Format(GetMessage("BP_NOLEARN", player.UserIDString), item.info.shortname));
                        playerInfo.blueprints.complete.Remove(item.info.itemid);
                        SingletonComponent<ServerMgr>.Instance.persistance.SetPlayerInfo(player.userID, playerInfo);
                        player.SendNetworkUpdateImmediate();    
                        if(Convert.ToBoolean(Config["GiveItemsBack"]))
                        {
                            player.inventory.GiveItem(ItemManager.CreateByName(item.info.shortname, item.amount), player.inventory.containerMain);
                        }         
                        return;
                    }     
                    if(item.info.shortname == "blueprint_fragment" && Convert.ToBoolean(Config["NoUpgradeToPage"]))
                    {
                        SendReply(player, string.Format(GetMessage("BP_MAYNOTUSE", player.UserIDString), item.info.shortname));
                        if(item.HasFlag(Item.Flag.Blueprint))
                        {
                            return;
                        }
                        else
                        {
                            player.inventory.GiveItem(ItemManager.CreateByName(item.info.shortname, 60), player.inventory.containerMain);    
                            timer.Once(0.1f, () => player.inventory.Take(null, 1625167035, item.amount));
                        } 
                    }
                    else if(item.info.shortname == "blueprint_book" && Convert.ToBoolean(Config["NoUpgradeToLibrary"]))
                    {
                        SendReply(player, string.Format(GetMessage("BP_MAYNOTUSE", player.UserIDString), item.info.shortname));
                        if(item.HasFlag(Item.Flag.Blueprint))
                        {
                            return;
                        }
                        else
                        {
                            player.inventory.GiveItem(ItemManager.CreateByName(item.info.shortname, 4), player.inventory.containerMain);    
                            timer.Once(0.1f, () => player.inventory.Take(null, -845335793, item.amount));
                        } 
                    }
                    else if(item.info.shortname == "blueprint_page" && Convert.ToBoolean(Config["NoUpgradeToBook"]))
                    {
                        SendReply(player, string.Format(GetMessage("BP_MAYNOTUSE", player.UserIDString), item.info.shortname));
                        if(item.HasFlag(Item.Flag.Blueprint))
                        {
                            return;
                        }
                        else
                        {
                            player.inventory.GiveItem(ItemManager.CreateByName(item.info.shortname, 5), player.inventory.containerMain);    
                            timer.Once(0.1f, () => player.inventory.Take(null, 1624763669, item.amount));
                        } 
                    } 
                    else if (item.HasFlag(Item.Flag.Blueprint) && blueprintBlacklist.Contains(item.info.shortname))
                    {
                        SendReply(player, string.Format(GetMessage("BP_NOLEARN", player.UserIDString), item.info.shortname));
                        playerInfo.blueprints.complete.Remove(item.info.itemid);
                        SingletonComponent<ServerMgr>.Instance.persistance.SetPlayerInfo(player.userID, playerInfo);
                        player.SendNetworkUpdateImmediate();
                        if(Convert.ToBoolean(Config["GiveItemsBack"]))
                        {
                            player.inventory.GiveItem(ItemManager.CreateByName(item.info.shortname, item.amount), player.inventory.containerMain);
                        }     
                    }   
                    else
                    {
                        return;
                    }
                }   
            }
            catch(System.Exception)
            {
                return;
            }
        } 
        
        //////////////////////////////////////////////////////////////////////////////////////
        // OnEntitySpawned()
        ////////////////////////////////////////////////////////////////////////////////////// 
        
        private void OnEntitySpawned(BaseNetworkable entity) {
            if(Convert.ToBoolean(Config["SpawnedRemoverTest"]) == false)
            {
                return;
            }
            if(entity is LootContainer)
            {            
                var container = entity as LootContainer;
                var inv = container.inventory.itemList.ToArray();             
                if(container == null) return;
                if (container.inventory == null || container.inventory.itemList == null) return;
                foreach(var item in inv)
                {
                    if(item.HasFlag(Item.Flag.Blueprint) && blueprintBlacklist.Contains(item.info.shortname))
                    {
                        item.RemoveFromContainer();
                        item.Remove(1f);  
                    }
                    else if(item.info.shortname == "blueprint_fragment" && Convert.ToBoolean(Config["DropNoBPFrags"]))
                    {
                        item.RemoveFromContainer();
                        item.Remove(1f);  
                    }
                    else if(item.info.shortname == "blueprint_book" && Convert.ToBoolean(Config["DropNoBPBooks"]))
                    {
                        item.RemoveFromContainer();
                        item.Remove(1f);  
                    }
                    else if(item.info.shortname == "blueprint_page" && Convert.ToBoolean(Config["DropNoBPPages"]))
                    {
                        item.RemoveFromContainer();
                        item.Remove(1f);  
                    }
                    else if(item.info.shortname == "blueprint_library" && Convert.ToBoolean(Config["DropNoBPLibraries"]))
                    {
                        item.RemoveFromContainer();
                        item.Remove(1f);  
                    } 
                    else
                    {
                        return;
                    } 
                }           
            }
        }
        
        //////////////////////////////////////////////////////////////////////////////////////
        // DeleteAllBPFrags
        ////////////////////////////////////////////////////////////////////////////////////// 
        
        [ConsoleCommand("deletefrags")]
        void DeleteAllFrags(ConsoleSystem.Arg arg) {
            if (arg.Player() != null && !arg.Player().IsAdmin())
            {
                 SendReply(arg, lang.GetMessage("BP_NOPERMS", this));
                 return;
            } 
            else
            {
                foreach(var active in BasePlayer.activePlayerList)
                {
                    var frags = active.inventory.GetAmount(1351589500);
                    if(frags >= 1)
                    {
                        active.inventory.Take(null, 1351589500, frags);
                        FragAmount++;
                        PlayerTotalFrags++;
                    }    
                    else
                    {
                    }
                }   
                foreach(var sleeper in BasePlayer.sleepingPlayerList)
                {
                    var frags = sleeper.inventory.GetAmount(1351589500);
                    if(frags >= 1)
                    {
                        sleeper.inventory.Take(null, 1351589500, frags);
                        FragAmount++;
                        PlayerTotalFrags++;
                    }    
                    else
                    {
                    }   
                } 
                var containers = UnityEngine.Object.FindObjectsOfType<LootContainer>();
                foreach(var entity in containers)
                {
                    if(entity is LootContainer)
                    {            
                        var container = entity as LootContainer;
                        var inv = container.inventory.itemList.ToArray();    
                        foreach(var item in inv)
                        {
                            if(item.info.shortname == "blueprint_fragment")
                            {
                                item.RemoveFromContainer();
                                item.Remove(1f);  
                                EFragAmount++;
                            }
                        }
                    }                  
                }
                if(FragAmount == 0 && EFragAmount == 0)
                {
                    Puts(lang.GetMessage("BP_NOFRAGSFOUND", this));
                }
                else
                {
                    Puts(string.Format(lang.GetMessage("BP_REMOVEDFRAGS", this), FragAmount, PlayerTotalFrags, EFragAmount, "?"));    
                    FragAmount = 0;
                    PlayerTotalFrags = 0;
                    EFragAmount = 0;
                    EntityTotalFrags = 0;
                }   
            }
        }
        
        [ConsoleCommand("AddConfig")]
        void AddConfig(ConsoleSystem.Arg arg) {    
            if (arg.Player() != null && !arg.Player().IsAdmin())
            {
                 SendReply(arg, lang.GetMessage("BP_NOPERMS", this));
                 return;
            } 
            else
            {
                if(blueprintBlacklist.Contains(arg.Args[0].ToString()))
                {
                    Puts(string.Format(lang.GetMessage("BP_ALREADYINCONFIG", this), arg.Args[0].ToString()));          
                }
                else
                {
                    blueprintBlacklist.Add(arg.Args[0].ToString());
                    Config.Save();
                    Puts(string.Format(lang.GetMessage("BP_ADDEDTOCONFIG", this), arg.Args[0].ToString()));       
                }
            }
        }
        
        [ConsoleCommand("RemoveConfig")]
        void RemoveConfig(ConsoleSystem.Arg arg) {
            if (arg.Player() != null && !arg.Player().IsAdmin())
            {
                 SendReply(arg, lang.GetMessage("BP_NOPERMS", this));
                 return;
            } 
            else
            { 
                if(!blueprintBlacklist.Contains(arg.Args[0].ToString()))
                {
                    Puts(string.Format(lang.GetMessage("BP_NOINCONFIG", this), arg.Args[0].ToString()));          
                }
                else
                {
                    blueprintBlacklist.Remove(arg.Args[0].ToString());
                    Config.Save();
                    Puts(string.Format(lang.GetMessage("BP_REMOVEDFROMCONFIG", this), arg.Args[0].ToString()));       
                }   
            }   
        }
    }
}

// --- End of file: BlueprintBlocker.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/GalaxyChest.cs ---
// --- Original Local Path: GalaxyChest.cs ---

using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;

// https://server-rust.ru/resources/galaxychest.892/

namespace Oxide.Plugins
{
    [Info("GalaxyChest", "123", "1.0.0")]
    [Description("GalaxyChest")]
    class GalaxyChest : RustPlugin
    {
        #region Classes
        private class PluginConfig
        {
            public ulong ChestSkin = 1852572105;
            public ulong DustSkin = 1853777192;
            public float TimeOpen = 10f;
            public Dictionary<string, DustSett> dustDrops;
            public Dictionary<string, PrizeSett> prizeSett;
        }

        private class DustSett
        {
            public int Amount;
            public int Chance;
        }

        private class ChestData
        {
            public double OpenTime;
            public uint NetId;
        }

        private class PrizeSett
        {
            public int MinValue = 5;
            public int MaxValue = 15;
            public double Chance = 100;
        }
        #endregion

        #region Variables
        private Dictionary<ulong, ChestData> chestsData;
        private PluginConfig config;
        private string DataPath = "GalaxyChest/Data";
        static GalaxyChest instance;
        GameObject controller;
        #endregion

        #region Oxide
        private void Init()
        {
            config = Config.ReadObject<PluginConfig>();
        }

        void OnServerInitialized()
        {
            instance = this;

            chestsData = new Dictionary<ulong, ChestData>();
            if (Interface.Oxide.DataFileSystem.ExistsDatafile(DataPath))
                chestsData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, ChestData>>(DataPath);

            controller = new GameObject();
            ChestUpdator component;
            if (controller != null)
            {
                component = controller.GetComponent<ChestUpdator>();
                if (component != null) UnityEngine.Object.Destroy(component);
            }
            controller.AddComponent<ChestUpdator>();

            
            PrintWarning("Plugin loaded! Author: BadMandarin!");
        }

        void Unload()
        {
            if (controller != null)
            {
                var component = controller.GetComponent<ChestUpdator>();
                if (component != null) UnityEngine.Object.Destroy(component);
            }
            Interface.Oxide.DataFileSystem.WriteObject(DataPath, chestsData);

            PrintWarning("Plugin unloaded! Author: BadMandarin!");
        }

        void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            if (item.skin == config.DustSkin && container.capacity == 12 && container.entityOwner is BoxStorage && !(container.entityOwner is Recycler))
            {
                if (container.itemList.Count() > 1) return;


                BaseEntity e = container.entityOwner;
                if (chestsData.ContainsKey(e.OwnerID)) return;
                item.RemoveFromContainer();
                e.SetFlag(BaseEntity.Flags.Reserved4, true);
                container.SetLocked(true);
                e.skinID = config.ChestSkin;
                e.SendNetworkUpdateImmediate();
                chestsData.Add(e.OwnerID, new ChestData() { OpenTime = GetCurrentTime() + config.TimeOpen, NetId = e.net.ID });
            }
        }

        object CanLootEntity(BasePlayer player, StorageContainer container)
        {
            var chests = chestsData.Where(x => x.Value.NetId == container.net.ID);
            if (chests != null && chests.Count() > 0)
            {
                var chest = chests.ToList()[0];
                if (chest.Value.OpenTime > GetCurrentTime()) return false;
            }
            return null;
        }

        void OnItemRemovedFromContainer(ItemContainer container, Item item)
        {
            BaseEntity e = container.entityOwner;
            if (e == null) return;
            var chests = chestsData.Where(x => x.Value.NetId == e.net.ID);
            if (chests != null && chests.Count() > 0)
            {
                if (container.itemList.Count() < 1) e.Kill();
            }
        }

        bool CanStackItem(Item item, Item targetItem)
        {
            if (item.info.displayName != targetItem.info.displayName)
                return false;
            if (item.skin != targetItem.skin)
                return false;
            if (item.info.shortname != targetItem.info.shortname)
                return false;
            if (item.skin == config.DustSkin)
                return false;
            return true;
        }

        private void OnLootSpawn(LootContainer container)
        {
            if (container == null) return;
            if (!config.dustDrops.ContainsKey(container.ShortPrefabName)) return;
            var dusts = config.dustDrops[container.ShortPrefabName];
            if (Core.Random.Range(0, 100) > dusts.Chance) return;

            if (container.inventory.itemList.Count == container.inventory.capacity)
                container.inventory.capacity++;

            var itm = ItemManager.CreateByName("glue", dusts.Amount, config.DustSkin);
            itm.name = "Космическая пыль";
            itm.MoveToContainer(container.inventory);
        }/*
        private void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            try
            { if (entity.HasFlag(BaseEntity.Flags.Reserved7)) return;
                entity.SetFlag(BaseEntity.Flags.Reserved7, true);
                
                var obj = entity.GetComponent<StorageContainer>();
                if (obj == null) return;

                var dusts = config.dustDrops.Where(p => entity.PrefabName.Contains(p.Key));
                if (dusts == null || dusts.Count() < 1) return;
                var dust = dusts.ToList()[0];
                if (Oxide.Core.Random.Range(0, 100) > dust.Value.Chance) return;

                if (obj.inventory.itemList.Count == obj.inventory.capacity)
                    obj.inventory.capacity++;

                Item itm = ItemManager.CreateByName("glue", dust.Value.Amount, config.DustSkin);
                itm.name = "Волшебный порошок";
                itm.MoveToContainer(obj.inventory);
               
            }
            catch { }
        }
*/
        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if ((bool)entity?.PrefabName?.Contains("barrel"))
            {
                var container = entity as LootContainer;
                if (container == null) return;
                var dusts = config.dustDrops.Where(p => entity.PrefabName.Contains(p.Key));
                if (dusts == null || dusts.Count() < 1) return;
                var dust = dusts.ToList()[0];
                if (Oxide.Core.Random.Range(0, 100) > dust.Value.Chance) return;

                if (container.inventory.itemList.Count == container.inventory.capacity)
                    container.inventory.capacity++;

                Item itm = ItemManager.CreateByName("glue", dust.Value.Amount, config.DustSkin);
                itm.name = "Космическая пыль";
                itm.MoveToContainer(container.inventory);
            }
        }
        #endregion

        #region Commands
        [ConsoleCommand("test")]
        private void Console_Test(ConsoleSystem.Arg arg)
        {

        }
        [ChatCommand("test")]
        void Chat_Test(BasePlayer player, string command, string[] args)
        {
            
        }
        #endregion

        #region Utils
        private static void DrawMarker(BasePlayer player, Vector3 position, string text, int length = 1)
        {
            player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
            player.SendEntityUpdate();
            player.SendConsoleCommand("ddraw.text", length, Color.white, position, text);
            player.SendConsoleCommand("camspeed 0");

            if (player.Connection.authLevel < 2)
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);

            player.SendEntityUpdate();
        }

        private static double GetCurrentTime()
        {
            return new TimeSpan(DateTime.UtcNow.Ticks).TotalSeconds;
        }
        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                prizeSett = new Dictionary<string, PrizeSett>()
                {
                    ["sulfur"] = new PrizeSett()
                    {
                        MinValue = 1000,
                        MaxValue = 1000,
                        Chance = 100
                    },
                },
                dustDrops = new Dictionary<string, DustSett>()
                {
                    ["barrel"] = new DustSett
                    {
                        Amount = 1,
                        Chance = 100
                    }
                }
            };
        }
        #endregion

        #region ChestUpdator
        private class ChestUpdator : MonoBehaviour
        {
            private void Awake()
            {
                InvokeRepeating(nameof(UpdateInfo), 1f, 1f);
            }

            private void UpdateInfo() => instance.chestsData.ToList().ForEach(x => CheckChest(BasePlayer.FindByID(x.Key)));

            private void CheckChest(BasePlayer player)
            {
                if (player == null || !player.IsConnected) return;

                BaseEntity Chest = BaseNetworkable.serverEntities.Find(instance.chestsData[player.userID].NetId) as BaseEntity;
                if (Chest == null || Chest.IsDestroyed)
                {
                    instance.chestsData.Remove(player.userID);
                    return;
                }

                if (CheckDistance(player, Chest)) return;

                if (instance.chestsData[player.userID].OpenTime > GetCurrentTime())
                {
                    DrawMarker(player, Chest.transform.position + new Vector3(0, 0.5f, 0), $"<size=25><color=#BF00FF>GALAXYBOX</color></size>\n<size=18>Откроется через: {(int)(instance.chestsData[player.userID].OpenTime - GetCurrentTime())}с!</size>");
                    return;
                }
                if (Chest.HasFlag(BaseEntity.Flags.Reserved4))
                {
                    Chest.SetFlag(BaseEntity.Flags.Reserved4, false);
                    StorageContainer storage = Chest as StorageContainer;
                    storage.inventory.SetLocked(false);
                    instance.config.prizeSett.ToList().ForEach(x => {
                        if(Core.Random.Range(0, 100) <= x.Value.Chance)
                        {
                            Item tempitm = ItemManager.CreateByName(x.Key, Core.Random.Range(x.Value.MinValue, x.Value.MaxValue));
                            tempitm.MoveToContainer(storage.inventory);
                        }
                    });
                }
                DrawMarker(player, Chest.transform.position + new Vector3(0, 0.5f, 0), "<size=25><color=#BF00FF>GALAXYBOX</color></size>\n<size=18>Заберите свой приз!</size>");
            }

            private bool CheckDistance(BasePlayer player, BaseEntity ent)
            {
                if (Vector3.Distance(player.transform.position, ent.transform.position) >= 5) return true;

                return false;
            }

            private void OnDestroy()
            {
                CancelInvoke(nameof(UpdateInfo));
            }
        }
        #endregion
    }
}


// --- End of file: GalaxyChest.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/VipRemainInfo.cs ---
// --- Original Local Path: VipRemainInfo.cs ---

﻿using System;
using System.Linq;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("VipRemainInfo", "Nimant", "1.0.5", ResourceId = 0)]
    class VipRemainInfo : RustPlugin
    {            		
				
		#region Variables 		
		
		[PluginReference]
		private Plugin Grant;

		private Dictionary<ulong, bool>	ShowedVipInfo = new Dictionary<ulong, bool>();				
		
		#endregion
		
		#region Hooks
		
		private void Init() 
		{
			LoadConfigVariables();
			LoadDefaultMessages();
			
			if (configData.ShowDelay < 0f)
			{
				Unsubscribe(nameof(OnPlayerConnected));
				Unsubscribe(nameof(OnPlayerSleepEnded));
			}
		}
		
		private void OnServerInitialized()
		{
			if (Grant == null)			
				PrintWarning("Не найден плагин 'Grant'. Работа плагина невозможна !");						
		}
				
		private void OnPlayerConnected(BasePlayer player)
        {
			if (player == null) return;
			
            if (!ShowedVipInfo.ContainsKey(player.userID)) 
				ShowedVipInfo.Add(player.userID, false);
			else
				ShowedVipInfo[player.userID] = false;
		}	
		
		private void OnPlayerSleepEnded(BasePlayer player)
        {					
			if (player == null) return;
			
            if (!ShowedVipInfo.ContainsKey(player.userID)) return;
			
			if (!ShowedVipInfo[player.userID])
				timer.Once(configData.ShowDelay, () => ShowRemainVipInfo(player));
        }
		
		#endregion
		
		#region Commands
		
		[ChatCommand("vipinfo")]
        private void cmdVipInfo(BasePlayer player, string command, string[] args)
        {
			if (player == null) return;
			ShowRemainVipInfo(player, false);
		}
		
		#endregion
		
		#region Main
		
		private void ShowRemainVipInfo(BasePlayer player, bool isSilent = true)
		{
			if (Grant == null) return;
			
			var result = "";
			var showHead = false;
			var color = "";
			
			var groupInfo = (Dictionary<string, int>)(Grant.CallHook("GetGroups", player.userID));
			if (groupInfo != null)
			{
				foreach(var info in groupInfo)
				{					
					if (!showHead)
					{						
						result += GetLangMessage("VRI.PASS_TIME") + "\n";
						showHead = true;
					}
					
					var name = info.Key;
					if (configData.GroupsNewName.ContainsKey(info.Key)) 
						name = configData.GroupsNewName[info.Key];						
					
					if (configData.GroupsColor.TryGetValue(info.Key, out color))						
						result += string.Format(GetLangMessage("VRI.PRIV_TEXT"), color, name, GetTime(info.Value)) + "\n";
					else
						if (configData.GroupsColor.TryGetValue("default", out color))							
							result += string.Format(GetLangMessage("VRI.PRIV_TEXT"), color, name, GetTime(info.Value)) + "\n";
						else
							result += string.Format(GetLangMessage("VRI.PRIV_TEXT"), "white", name, GetTime(info.Value)) + "\n";							
				}								
			}
			
			var privsInfo = (Dictionary<string, int>)(Grant.CallHook("GetPermissions", player.userID));
				
			if (privsInfo != null)
			{
				foreach(var info in privsInfo)
				{					
					if (!showHead)
					{						
						result += GetLangMessage("VRI.PASS_TIME") + "\n";
						showHead = true;
					}	
					
					var name = info.Key;
					if (configData.GroupsNewName.ContainsKey(info.Key))					
						name = configData.GroupsNewName[info.Key];						
					
					if (configData.GroupsColor.TryGetValue(info.Key, out color))						
						result += string.Format(GetLangMessage("VRI.PRIV_TEXT"), color, name, GetTime(info.Value)) + "\n";
					else
						if (configData.GroupsColor.TryGetValue("default", out color))							
							result += string.Format(GetLangMessage("VRI.PRIV_TEXT"), color, name, GetTime(info.Value)) + "\n";
						else
							result += string.Format(GetLangMessage("VRI.PRIV_TEXT"), "white", name, GetTime(info.Value)) + "\n";							
				}
			}
			
			if (!string.IsNullOrEmpty(result))
				SendReply(player, result.TrimEnd('\n'));
			else
				if (!isSilent)
					SendReply(player, GetLangMessage("VRI.NO_PRIVS"));
			
			if (isSilent)
				ShowedVipInfo[player.userID] = true;
		}		
		
		private string GetTime(int rawSeconds)
		{							
			int days    = (int)Math.Truncate((((decimal)rawSeconds/60)/60)/24);
			int hours   = (int)Math.Truncate((((decimal)rawSeconds-days*24*60*60)/60)/60);
			int minutes = (int)Math.Truncate((((decimal)rawSeconds-days*24*60*60)/60)%60);			
			
			string time = "";
		
			if (days!=0)
				time += $"{days}д ";			
			if (hours!=0)
				time += $"{hours}ч ";			
			if (minutes!=0)
				time += $"{minutes}м ";			
			
			if (string.IsNullOrEmpty(time))
				time = "несколько секунд";
			
			return time;
		}
		
		#endregion
		
		#region Lang
		
        private void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string> 
            {                
				{"VRI.PASS_TIME", "Остаток времени у ваших привилегий:"},
				{"VRI.PRIV_TEXT", "Привилегия <color={0}>{1}</color> - осталось {2}"},
				{"VRI.NO_PRIVS", "У вас нет активных привилегий"}
            }, this);
        }

        private string GetLangMessage(string key, string steamID = null) => lang.GetMessage(key, this, steamID);
		
		#endregion
		
		#region Config   		
		
		private static ConfigData configData;
		
        private class ConfigData
        {
			[JsonProperty(PropertyName = "Цвета вип групп и отдельных привилегий")]
            public Dictionary<string, string> GroupsColor;		
			[JsonProperty(PropertyName = "Названия вип групп и отдельных привилегий")]
			public Dictionary<string, string> GroupsNewName;
			[JsonProperty(PropertyName = "Задержка на показ остатка времени у групп и отдельных привилегий при заходе на сервер (-1 = отключить показ)")]
			public float ShowDelay;
        }				                        
		
        private void LoadDefaultConfig()
        {
			configData = new ConfigData
            {
				GroupsColor = new Dictionary<string, string>()
				{
					{"vip", "#0FED02"},	
					{"prime", "#A202ED"},
					{"kits.bigboss", "#FF170A"},
					{"default", "#FFA500"}
				},
				GroupsNewName = new Dictionary<string, string>()
				{
					{"vip", "VIP"},	
					{"prime", "PRIME"},
					{"kits.bigboss", "Кит BigBoss"}					
				},
				ShowDelay = 2f
            };
            SaveConfig(configData);
			timer.Once(0.1f, ()=> SaveConfig(configData));
        }
        
		private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        
		private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
		
        #endregion

    }	
	
}

// --- End of file: VipRemainInfo.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SkyCraftSystem.cs ---
// --- Original Local Path: SkyCraftSystem.cs ---

﻿using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Globalization;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("SkyCraftSystem", "fhff444", "1.0.{DarkPluginsID}")]
    class SkyCraftSystem : RustPlugin
    {
        #region Reference
        Plugin ImageLibrary => Interface.Oxide.RootPluginManager.GetPlugin("ImageLibrary");
        public string GetImage(string shortname, ulong skin = 0) => (string)ImageLibrary?.Call("GetImage", shortname, skin);
        public bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname, skin);
        #endregion

        #region Configuration

        private static Configuration config = new Configuration();

        private class Configuration
        {
            [JsonProperty("Настройка системы крафта | SettingsPluign")]
            public List<CraftItemsConfiguration> SettingsPlugins = new List<CraftItemsConfiguration>();
            [JsonProperty("Настройка интерфейса | Interface Settings")]
            public CraftInterface SettingsInterface = new CraftInterface();

            internal class CraftItemsConfiguration
            {
                #region ItemSettings
                [JsonProperty("Включить крафт этого предмета | On-Off craft this item")]
                public bool OnOffCraft;
                [JsonProperty("Права для крафта | Permissions for craft")]
                public string Permissions;
                [JsonProperty("Ссылка на префаб | Prefab [ЕСЛИ ВЫ НЕ ЗНАЕТЕ ЧТО ЭТО - НЕ ТРОГАЙТЕ.ПРОСТО ИСПОЛЬЗУЙТЕ BOOL(TRUE / FALSE)]")]
                public string Prefab;
                [JsonProperty("Shortname заменяемого предмета | Shortname reply items for prefabs")]
                public string ShortnameReplyPrefab;
                [JsonProperty("Название предмета | DisplayName items")]
                public string DisplayName;
                [JsonProperty("Уровень верстака для крафта | WorkBench Level for Craft")]
                public int WorkBenchLevel;
                [JsonProperty("SkinID предмету(С фоткой)")]
                public ulong SkinID;
                [JsonProperty("Ссылка на картинку(512x512) | LINKPNG.png(512x512)")]
                public string PNGLink;
                [JsonProperty("Предметы для крафта | Crafting Items")]
                public Dictionary<string, int> CraftingItems = new Dictionary<string, int>();
                #endregion
            }

            internal class CraftInterface
            {
                #region Interface

                [JsonProperty("[Главная/Main]Цвет заднего фона | Background color")]
                public string BackgrounColorMain;
                [JsonProperty("[Главная/Main]Материал заднего фона | Metrial Background")]
                public string BackgrounMaterialMain;
                [JsonProperty("[Главная/Main]Спрайт заднего фона | Sprite Background")]
                public string BackgrounSpriteMain;

                [JsonProperty("[Панель предлметов/Panel Items]Цвет заднего фона | Background color")]
                public string PItemsBackgroundColor;
                [JsonProperty("[Доп.Панель предлметов/Additional Panel Items]Цвет заднего фона | Background color")]
                public string AdditionalPItemsBackgroundColor;

                [JsonProperty("[Цвет верстака/WorkBenchColor]Цвет верстака 0 уровня | WorkBench level - 0")]
                public string WorkBenchLevelColorNull;
                [JsonProperty("[Цвет верстака/WorkBenchColor]Цвет верстака 1 уровня | WorkBench level - 1")]
                public string WorkBenchLevelColorOne;
                [JsonProperty("[Цвет верстака/WorkBenchColor]Цвет верстака 2 уровня | WorkBench level - 2")]
                public string WorkBenchLevelColorTwo;
                [JsonProperty("[Цвет верстака/WorkBenchColor]Цвет верстака 3 уровня | WorkBench level - 3")]
                public string WorkBenchLevelColorThree;

                [JsonProperty("Цвет кнопки | Color Button")]
                public string ColorButtonCreate;
                [JsonProperty("Цвет панели с ресурсом,если конкретный ресурс собран | The color of the resource panel, if a specific resource is compiled")]
                public string ColorPanelResourceComplete;
                [JsonProperty("Цвет панели с ресурсом,если конкретный ресурс не собран | Color of the panel with the resource, if a specific resource is not assembled")]
                public string ColorPanelResourceNoComplete;

                #endregion
            }

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    SettingsPlugins = new List<CraftItemsConfiguration>
                    {
                        #region ItemConfig
                        new CraftItemsConfiguration
                        {
                            OnOffCraft = true,
                            Permissions = "SkyCraftSystem.minicopter",
                            Prefab = "assets/content/vehicles/minicopter/minicopter.entity.prefab",
                            ShortnameReplyPrefab = "electric.flasherlight",
                            DisplayName = "<size=20>Миникоптер</size>",
                            WorkBenchLevel = 2,
                            SkinID = 1764551112,
                            PNGLink = "https://i.imgur.com/SIRebqz.png",
                            CraftingItems = new Dictionary<string, int>
                            {
                                ["wood"] = 1500,
                                ["stones"] = 2300,
                            }
                        },
                        new CraftItemsConfiguration
                        {
                            OnOffCraft = true,
                            Permissions = "SkyCraftSystem.recycler",
                            Prefab = "assets/bundled/prefabs/static/recycler_static.prefab",
                            ShortnameReplyPrefab = "research.table",
                            DisplayName = "<size=18>Домашний переработчик</size>",
                            WorkBenchLevel = 1,
                            SkinID = 1764552507,
                            PNGLink = "https://i.imgur.com/xXL3d47.png",
                            CraftingItems = new Dictionary<string, int>
                            {
                                ["wood"] = 1000,
                                ["stones"] = 5000,
                            }
                        },
                        new CraftItemsConfiguration
                        {
                            OnOffCraft = true,
                            Permissions = "SkyCraftSystem.rowboat",
                            Prefab = "assets/content/vehicles/boats/rowboat/rowboat.prefab",
                            ShortnameReplyPrefab = "electric.hbhfsensor",
                            DisplayName = "<size=18>Деревянная лодка</size>",
                            WorkBenchLevel = 2,
                            SkinID = 1764552960,
                            PNGLink = "https://i.imgur.com/UGuYMkA.png",
                            CraftingItems = new Dictionary<string, int>
                            {
                                ["wood"] = 20000,
                            }
                        },
                        new CraftItemsConfiguration
                        {
                            OnOffCraft = true,
                            Permissions = "SkyCraftSystem.rhibboat",
                            Prefab = "assets/content/vehicles/boats/rhib/rhib.prefab",
                            ShortnameReplyPrefab = "electric.sirenlight",
                            DisplayName = "<size=19>Военная лодка</size>",
                            WorkBenchLevel = 3,
                            SkinID = 1764553295,
                            PNGLink = "https://i.imgur.com/u5QgVGS.png",
                            CraftingItems = new Dictionary<string, int>
                            {
                                ["wood"] = 1500,
                                ["stones"] = 50000,
                            }
                        },
                        new CraftItemsConfiguration
                        {
                            OnOffCraft = true,
                            Permissions = "SkyCraftSystem.sedan",
                            Prefab = "assets/content/vehicles/sedan_a/sedantest.entity.prefab",
                            ShortnameReplyPrefab = "woodcross",
                            DisplayName = "<size=20>Машина</size>",
                            WorkBenchLevel = 2,
                            SkinID = 1764553578,
                            PNGLink = "https://i.imgur.com/KMDl39b.png",
                            CraftingItems = new Dictionary<string, int>
                            {
                                ["wood"] = 1500,
                                ["stones"] = 2300,
                            }
                        },
                        new CraftItemsConfiguration
                        {
                            OnOffCraft = true,
                            Permissions = "SkyCraftSystem.hotairball",
                            Prefab = "assets/prefabs/deployable/hot air balloon/hotairballoon.prefab",
                            ShortnameReplyPrefab = "wall.graveyard.fence",
                            DisplayName = "<size=19>Воздушный шар</size>",
                            WorkBenchLevel = 3,
                            SkinID = 1764553961,
                            PNGLink = "https://i.imgur.com/86CDnDd.png",
                            CraftingItems = new Dictionary<string, int>
                            {
                                ["wood"] = 2281337,
                                ["stones"] = 2300,
                            }
                        },                      

                        #endregion
                    },
                    SettingsInterface = new CraftInterface
                    {
                        #region Interface
                        BackgrounColorMain = "#2D2D2D88",
                        BackgrounMaterialMain = "assets/content/ui/uibackgroundblur.mat",
                        BackgrounSpriteMain = "assets/content/ui/ui.background.transparent.radial.psd",

                        PItemsBackgroundColor = "#76767678",
                        AdditionalPItemsBackgroundColor ="#FFFFFF13",

                        WorkBenchLevelColorNull = "#0071FF53",
                        WorkBenchLevelColorOne = "#16EB8578",
                        WorkBenchLevelColorTwo = "#FF73008C",
                        WorkBenchLevelColorThree = "#EB173678",

                        ColorButtonCreate = "#2ABD86FF",
                        ColorPanelResourceComplete = "#A60D0D2F",
                        ColorPanelResourceNoComplete = "#1FB91931",
                        #endregion
                    },
                };
            }          
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Hooks
        void OnServerInitialized()
        {
            RegisteredPlugin();

            PrintError($"-----------------------------------");
            PrintError($"           SkyCraftSystem          ");
            PrintError($"          Created - Sky Eye        ");
            PrintError($"        Author = Mercury#5212      ");
            PrintError($"    https://vk.com/skyeyeplugins   ");
            PrintError($"-----------------------------------");
        }

        private void OnEntityBuilt(Planner plan, GameObject go) => CheckDeploy(go.ToBaseEntity());

        private Item OnItemSplit(Item item, int amount)
        {
            for (int i = 0; i < config.SettingsPlugins.Count; i++)
            {
                var cfg = config.SettingsPlugins[i];
                if (item.skin == cfg.SkinID)
                {
                    Item x = ItemManager.CreateByPartialName(cfg.ShortnameReplyPrefab, amount);
                    x.name = cfg.DisplayName;
                    x.skin = cfg.SkinID;
                    x.amount = amount;
                    item.amount -= amount;
                    return x;
                }
            }
            return null;
        }

        object CanCombineDroppedItem(DroppedItem item, DroppedItem targetItem)
        {
            if (item.GetItem().skin != targetItem.GetItem().skin) return false;

            return null;
        }

        object CanStackItem(Item item, Item targetItem)
        {
            if (item.skin != targetItem.skin) return false;

            return null;
        }

        #endregion

        #region Command

        [ConsoleCommand("craftssystem")]
        void ConsoleCraftSystem(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            switch(arg.Args[0])
            {
                case "craft_select":
                    {
                        int index = Convert.ToInt32(arg.Args[1]);
                        UI_CraftMenuAction(player, index);
                        break;
                    }
                case "craft_item":
                    {
                        int index = Convert.ToInt32(arg.Args[1]);
                        var cfg = config.SettingsPlugins[index];

                        foreach (var info in cfg.CraftingItems)                        
                            if (CheckResourceCraft(player, info.Key, info.Value))
                            {
                                MessageUI(player, lang.GetMessage("INTERFACEACTION_NO_RESOURCE_BTN", this));
                                Effect.server.Run("assets/prefabs/npc/autoturret/effects/targetlost.prefab", player.transform.localPosition);
                                CuiHelper.DestroyUi(player, PARENT_MAINMENU);
                                return;
                            }
                        if(player.currentCraftLevel < cfg.WorkBenchLevel)
                        {
                            MessageUI(player, lang.GetMessage("INTERFACEACTION_NO_WORKBENCH_BTN", this));
                            Effect.server.Run("assets/prefabs/npc/autoturret/effects/targetlost.prefab", player.transform.localPosition);
                            CuiHelper.DestroyUi(player, PARENT_MAINMENU);
                            return;
                        }

                        TakeItemForCraft(player, index);
                        CuiHelper.DestroyUi(player, PARENT_MAINMENU);
                        Effect.server.Run("assets/prefabs/deployable/tier 1 workbench/effects/experiment-start.prefab", player.transform.localPosition);
                        GiveItems(player,index);
                        break;
                    }              
            }
        }

        [ChatCommand("craft")]
        void OpenCraftMenuChat(BasePlayer player)
        {
            UI_MainMenu(player);
        }

        [ConsoleCommand("craft")]
        void OpenCraftMenuConsole(ConsoleSystem.Arg arg)
        {
            UI_MainMenu(arg.Player());
        }
        #endregion

        #region Metods

        void RegisteredPlugin()
        {
            for(int i = 0; i < config.SettingsPlugins.Count; i++)
            {
                var cfg = config.SettingsPlugins[i];
                permission.RegisterPermission($"{cfg.Permissions}".ToLower(), this);
                AddImage(cfg.PNGLink, cfg.DisplayName);
            }
        }

        #region CraftItemsMetods

        private void TakeItemForCraft(BasePlayer player,int index)
        {
            var ICFG = config.SettingsPlugins[index].CraftingItems;

            foreach (var item in ICFG)
                player.inventory.Take(null, ItemManager.FindItemDefinition(item.Key).itemid, item.Value);
        }

        private void GiveItems(BasePlayer player,int index)
        {
            var item = CreateItem(index);
            player.GiveItem(item);
        }

        private Item CreateItem(int index)
        {
            var cfg = config.SettingsPlugins[index];

            var item = ItemManager.CreateByName(cfg.ShortnameReplyPrefab, 1, cfg.SkinID);
            if (item == null)
                return null;

            item.name = cfg.DisplayName;
            return item;
        }

        private void CheckDeploy(BaseEntity entity)
        {
            if (entity == null) return;
            if (!ItemCheck(entity.skinID)) return;
            SpawnItem(entity.transform.position, entity.skinID, entity.transform.rotation, entity.OwnerID);
            entity.Kill();
        }

        private bool ItemCheck(ulong skin)
        {
            for (int i = 0; i < config.SettingsPlugins.Count; i++)
            {
                var cfg = config.SettingsPlugins[i];
                if (skin != 0 && skin == cfg.SkinID)
                    return true;
            }
            return false;
        }

        #endregion

        #region SpawnPrefabs

        private void SpawnItem(Vector3 position,ulong SkinID, Quaternion rotation = default(Quaternion), ulong ownerID = 0)
        {
            for (int i = 0; i < config.SettingsPlugins.Count; i++)
            {
                var cfg = config.SettingsPlugins[i];

                if (cfg.SkinID == SkinID)
                {
                    BaseEntity Item = GameManager.server.CreateEntity(cfg.Prefab, position, rotation);
                    if (Item == null) { return; }
                    Item.Spawn();
                    break;
                }
            }
        }

        #endregion

        #region BoolMetods

        public bool PermissionCheck(string ID, string permissions)
        {
            if (permission.UserHasPermission(ID, permissions))
                return true;
            else return false;
        }

        private bool CheckResourceCraft(BasePlayer player, string Key, int Value)
        {
            var more = new Dictionary<string, int>();
            var has = player.inventory.GetAmount(ItemManager.FindItemDefinition(Key).itemid);
            if (has < Value)
            {
                if (!more.ContainsKey(Key))
                    more.Add(Key, 0);

                more[Key] += Value - has;
            }

            if (more.ContainsKey(Key))
                return true;
            else
                return false;
        }

        #endregion

        #endregion

        #region Lang
        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TITLE_TEXT"] = "<size=30>The system of creating useful items</size>",
                ["TITLE_DESC"] = "<size=16>Select an available item and go to craft</size>",

                ["INTERFACE_BTN"] = "<size=20>Select</size>",
                ["INTERFACE_WORKBENCHLEVEL"] = "<size=14>WorkBench-level {0}</size>",
                ["INTERFACE_WORKBENCHLEVELNULL"] = "<size=14>No workbench</size>",

                ["INTERFACEACTION_TITLE"] = "<size=30>Item Creation Menu : {0}</size>",
                ["INTERFACEACTION_BTN"] = "<size=20>Create</size>",
                ["INTERFACEACTION_NO_WORKBENCH_BTN"] = "<size=16>Go to the workbench</size>",
                ["INTERFACEACTION_NO_RESOURCE_BTN"] = "<size=16>Not enough resources</size>",

                ["INTERFACEACTION_COLLECTED_RESORUCE"] = "<size=18>Collected</size>",

            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TITLE_TEXT"] = "<size=30>Система создания полезных предметов</size>",
                ["TITLE_DESC"] = "<size=16>Bыберите доступный предмет и переходите к крафту</size>",

                ["INTERFACE_BTN"] = "<size=20>Выбрать</size>",
                ["INTERFACE_WORKBENCHLEVEL"] = "<size=14>Верстак {0} уровня</size>",
                ["INTERFACE_WORKBENCHLEVELNULL"] = "<size=14>Верстак не требуется</size>",

                ["INTERFACEACTION_TITLE"] = "<size=30>Mеню создания предмета : {0}</size>",
                ["INTERFACEACTION_BTN"] = "<size=20>Создать</size>",
                ["INTERFACEACTION_NO_WORKBENCH_BTN"] = "<size=16>Подойдите к верстаку</size>",
                ["INTERFACEACTION_NO_RESOURCE_BTN"] = "<size=16>Недостаточно ресурсов</size>",

                ["INTERFACEACTION_COLLECTED_RESORUCE"] = "<size=18>Собрано</size>",

            }, this, "ru");
            PrintWarning("Lang loaded");
        }
        #endregion

        #region UI

        #region Parent

        public static string PARENT_MAINMENU = "MainMenuUIParent";
        public static string PARENT_MENUACTION = "MenuActionCraftParent";

        #endregion

        public void UI_MainMenu(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, PARENT_MAINMENU);

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { FadeIn = 0.2f, Color = HexToRustFormat(config.SettingsInterface.BackgrounColorMain), Material = config.SettingsInterface.BackgrounMaterialMain, Sprite = config.SettingsInterface.BackgrounSpriteMain }
            }, "Overlay", PARENT_MAINMENU);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "-100 -100", AnchorMax = "100 100" },
                Button = { Close = PARENT_MAINMENU, Color = "0 0 0 0" },
                Text = { FadeIn = 0.8f, Text = "" }
            }, PARENT_MAINMENU);

            #region Labels

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.9185187", AnchorMax = "1 0.9675928" },
                Text = { Text = lang.GetMessage("TITLE_TEXT", this), Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = HexToRustFormat("#FFFFFF89") }
            }, PARENT_MAINMENU);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.8833333", AnchorMax = "1 0.9231482" },
                Text = { Text = lang.GetMessage("TITLE_DESC", this), Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = HexToRustFormat("#FFFFFF89") }
            }, PARENT_MAINMENU);

            #endregion

            #region LoadItemsUI

            #region SettingsCenter

            int ItemCount = 0;
            float itemMinPosition = 219f;
            float itemWidth = 0.483646f - 0.301563f;
            float itemMargin = 0.419895f - 0.403646f;

            int truecraft = 0;
            for (int count = 0; count < config.SettingsPlugins.Count; count++)
                if (config.SettingsPlugins[count].OnOffCraft) truecraft++;

            int itemCount = truecraft;
            float itemMinHeight = 0.665741f;
            float itemHeight = 0.758333f - 0.555741f;

            if (itemCount > 5)
            {
                itemMinPosition = 0.5f - 5 / 2f * itemWidth - (5 - 1) / 2f * itemMargin;
                itemCount -= 5;
            }
            else itemMinPosition = 0.5f - itemCount / 2f * itemWidth - (itemCount - 1) / 2f * itemMargin;

            #endregion

            for (int i = 0; i < config.SettingsPlugins.Count; i++)
            {
                var cfg = config.SettingsPlugins[i];
                if (!cfg.OnOffCraft) continue;

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{itemMinPosition} {itemMinHeight}", AnchorMax = $"{itemMinPosition + itemWidth} {itemMinHeight + itemHeight}" },
                    Image = { Color = HexToRustFormat(config.SettingsInterface.PItemsBackgroundColor) }
                }, PARENT_MAINMENU, $"ITEM_{i}");

                #region PanelItem

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0.01362395 0.2233593", AnchorMax = $"0.9836512 0.9746563" },
                    Image = { Color = HexToRustFormat(config.SettingsInterface.AdditionalPItemsBackgroundColor) }
                }, $"ITEM_{i}", $"PANEL_ITEM_{i}");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.3830987 0.3307694", AnchorMax = "1 1" },
                    Text = { Text = cfg.DisplayName, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = HexToRustFormat("#FFFFFFFF") }
                }, $"PANEL_ITEM_{i}");

                container.Add(new CuiElement
                {
                    Parent = $"PANEL_ITEM_{i}",
                    Components =
                        {
                        new CuiRawImageComponent { Png = GetImage(cfg.DisplayName),  Color = HexToRustFormat("#FFFFFFFF") },
                        new CuiRectTransformComponent{  AnchorMin = $"0 0.3153852", AnchorMax = $"0.3408451 1" },
                        }
                });

                string color = cfg.WorkBenchLevel == 1 ? config.SettingsInterface.WorkBenchLevelColorOne : cfg.WorkBenchLevel == 2 ? config.SettingsInterface.WorkBenchLevelColorTwo : cfg.WorkBenchLevel == 3 ? config.SettingsInterface.WorkBenchLevelColorThree : config.SettingsInterface.WorkBenchLevelColorNull;
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0.008450687 0.02521083", AnchorMax = $"0.9943672 0.2945745" },
                    Image = { Color = HexToRustFormat(color) }
                }, $"PANEL_ITEM_{i}", $"WORKBENCH_PANEL_{i}");

                string text = cfg.WorkBenchLevel == 0 ? "INTERFACE_WORKBENCHLEVELNULL" : "INTERFACE_WORKBENCHLEVEL";
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = String.Format(lang.GetMessage(text, this), cfg.WorkBenchLevel), Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = HexToRustFormat("#FFFFFFF9") }
                }, $"WORKBENCH_PANEL_{i}");

                #endregion

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.01634854 0.03200842", AnchorMax = "0.9836512 0.2081301" },
                    Button = { Command = $"craftssystem craft_select {i}", Color = HexToRustFormat(config.SettingsInterface.ColorButtonCreate) },
                    Text = { Text = lang.GetMessage("INTERFACE_BTN", this), Align = TextAnchor.MiddleCenter }
                }, $"ITEM_{i}");

                #region SettingsCenter

                ItemCount++;
                itemMinPosition += (itemWidth + itemMargin);
                if (ItemCount % 5 == 0)
                {
                    itemMinHeight -= (itemHeight + (itemMargin * 2f));

                    if (itemCount > 5)
                    {
                        itemMinPosition = 0.5f - 5 / 2f * itemWidth - (5 - 1) / 2f * itemMargin;
                        itemCount -= 5;
                    }
                    else itemMinPosition = 0.5f - itemCount / 2f * itemWidth - (itemCount - 1) / 2f * itemMargin;
                }

                #endregion
            }
            #endregion

            CuiHelper.AddUi(player, container);
        }

        public void UI_CraftMenuAction(BasePlayer player,int index)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, PARENT_MENUACTION);
            var cfg = config.SettingsPlugins[index];
            var interfacecfg = config.SettingsInterface;
            int i = 0;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.1953125 0.01944444", AnchorMax = "0.8348958 0.4185185" },
                Image = { Color = "0 0 0 0" }
            },  PARENT_MAINMENU, PARENT_MENUACTION);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.8352668", AnchorMax = "1 1" },
                Text = { Text = String.Format(lang.GetMessage("INTERFACEACTION_TITLE", this),cfg.DisplayName), Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = HexToRustFormat("#FFFFFF89") }
            }, PARENT_MENUACTION);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.232899 0.2227378", AnchorMax = "0.769544 0.8120649" },
                Image = { Color = "0 0 0 0" }
            }, PARENT_MENUACTION, "ITEM_PANEL");

            #region SettingsCenter

            int ItemCount = 0;
            float itemMinPosition = 219f;
            float itemWidth = 0.473646f - 0.301563f;
            float itemMargin = 0.419895f - 0.403646f;

            int itemCount = config.SettingsPlugins[index].CraftingItems.Count;
            float itemMinHeight = 0.665741f;
            float itemHeight = 0.908333f - 0.505741f;

            if (itemCount > 6)
            {
                itemMinPosition = 0.5f - 6 / 2f * itemWidth - (6 - 1) / 2f * itemMargin;
                itemCount -= 6;
            }
            else itemMinPosition = 0.5f - itemCount / 2f * itemWidth - (itemCount - 1) / 2f * itemMargin;

            #endregion

            foreach (var info in cfg.CraftingItems)
            {
                var Formul = player.inventory.GetAmount(ItemManager.FindItemDefinition(info.Key).itemid);
                string Color = CheckResourceCraft(player, info.Key, info.Value) ? interfacecfg.ColorPanelResourceComplete : interfacecfg.ColorPanelResourceNoComplete;
                string Status = CheckResourceCraft(player, info.Key, info.Value) ? $"{Convert.ToInt32(info.Value - Formul).ToString()}" : lang.GetMessage("INTERFACEACTION_COLLECTED_RESORUCE", this);

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{itemMinPosition} {itemMinHeight}", AnchorMax = $"{itemMinPosition + itemWidth} {itemMinHeight + itemHeight}" },
                    Image = { Color = HexToRustFormat(Color) }
                },  "ITEM_PANEL",$"ITEM_{i}");

                container.Add(new CuiElement
                {
                    Parent = $"ITEM_{i}",
                    Components =
                        {
                        new CuiRawImageComponent { Png = GetImage(info.Key),  Color = HexToRustFormat("#FFFFFFFF") },
                        new CuiRectTransformComponent{  AnchorMin = $"0 0", AnchorMax = $"1 1" },
                        }
                });

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = Status, Font = "robotocondensed-regular.ttf", Align = TextAnchor.LowerCenter, Color = HexToRustFormat("#FFFFFF89") }
                },  $"ITEM_{i}");

                i++;

                #region SettingsCenter

                ItemCount++;
                itemMinPosition += (itemWidth + itemMargin);
                if (ItemCount % 6 == 0)
                {
                    itemMinHeight -= (itemHeight + (itemMargin * 2f));

                    if (itemCount > 6)
                    {
                        itemMinPosition = 0.5f - 6 / 2f * itemWidth - (6 - 1) / 2f * itemMargin;
                        itemCount -= 6;
                    }
                    else itemMinPosition = 0.5f - itemCount / 2f * itemWidth - (itemCount - 1) / 2f * itemMargin;
                }

                #endregion
            }

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.3566774 0.07031658", AnchorMax = "0.6457654 0.1708162" },
                Button = { Command = $"craftssystem craft_item {index}", Color = HexToRustFormat(interfacecfg.ColorButtonCreate) },
                Text = { Text = lang.GetMessage("INTERFACEACTION_BTN", this), Align = TextAnchor.MiddleCenter }
            },  PARENT_MENUACTION);

            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Help

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        void MessageUI(BasePlayer player, string Messages)
        {
            rust.RunClientCommand(player, "gametip.hidegametip");
            rust.RunClientCommand(player, $"gametip.showgametip", Messages);
            timer.Once(4f, () => { rust.RunClientCommand(player, "gametip.hidegametip"); });
        }

        #endregion
    }
}

// --- End of file: SkyCraftSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SlotPanel.cs ---
// --- Original Local Path: SlotPanel.cs ---

﻿using System.Collections.Generic;
using Oxide.Core;
using System;
using System.Linq;
using GameTips;
using UnityEngine.UI;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("SlotPanel", "Morecelo", "0.2.1")]
    [Description("Плагин добавляет ГУИ панель под слоты игрока, которая отображает основные события на сервере")]
    class SlotPanel : RustPlugin
    {
        #region Переменные
        
        // Конфиг | Отображение убийств
        private bool P_ShowKill = true;
        
        // Конфиг | Отображение случайных сообщений
        private bool P_ShowMessages = true;
        private bool P_SM_DoubleToChat = false;
        private int P_SM_Interval = 20;
        
        // Конфиг | Отображение подключений к серверу
        private bool P_ShowConnections = true;
        private bool P_ShowDisconnections = false;
        
        // Конфиг | Дополнительные параметры
        private string P_ShadowSize = "";
        private string P_FontName = "";
        private int P_FontSize = 14;
        
        #endregion

        #region Инициализация
        
        void OnServerInitialized()
        {
            LoadDefaultConfig();
            
            lang.RegisterMessages(new Dictionary<string, string>
            {
                // Случайные сообщения в чате должны начинаться со слова RANDOM
                { "RANDOM_1", "Добро пожаловать на сервер, <color=#FF5733>%NAME%</color>!" },
                { "RANDOM_2", "На дворе <color=#FF5733>%TIME%</color>, а ты на сервере? Молодец!"},
                { "RANDOM_3", "Текущая статистика сервера <color=#FF5733>%ONLINE%</color> / <color=#FF5733>%SLOTS%</color>!" },
                { "RANDOM_4", "<color=#FF5733>%NAME%</color>, спасибо что остаёшься с нами!" },
                { "RANDOM_5", "Не забудь <color=#FF5733>подписаться</color> на нашу группу ВК!" },
                { "RANDOM_6", "Ты можешь <color=#FF5733>заработать</color>, сообщив нам об ошибке!" },
                // Отправляться будут только те сообщения, ключ которых начинается со слова RANDOM
                { "TEACH", "Чтобы добавить новое сообщение в панель, добавьте новую строку, в ключе укажите RANDOM_ и любое раннее не использованное число"},
                { "KILL_FORMAT", "<color=#FF5733>%KILLER%</color> застрелил <color=#FF5733>%DEAD%</color>" },
                { "SUICIDE_FORMAT", "<color=#FF5733>%KILLER%</color> застрелился" },
                { "CONNECT_FORMAT", "<color=#FF5733>%NAME%</color> присоединился к серверу" },
                { "DISCONNECT_FORMAT", "<color=#DC143C>%NAME%</color> отсоединился от сервера" },
            }, this, "en");

            if (P_ShowMessages)
                timer.Every(P_SM_Interval, () => StartBroadcast());
        }

        protected override void LoadDefaultConfig()
        {
            Config["Отображать убийства в панеле"] = P_ShowKill = GetConfig("Отображать убийства в панеле", true);
            Config["Отображать случайные сообщения"] = P_ShowMessages = GetConfig("Отображать случайные сообщения", true);
            Config["Отображать подключения к серверу"] = P_ShowConnections = GetConfig("Отображать подключения к серверу", true);
            Config["Отображать отключения от сервера"] = P_ShowDisconnections = GetConfig("Отображать отключения от сервера", false);
            
            Config["Дублировать случайное сообщение в чат"] = P_SM_DoubleToChat = GetConfig("Дублировать случайное сообщение в чат", false);
            Config["Интервал показа случайных сообщений"] = P_SM_Interval = GetConfig("Интервал показа случайных сообщений", 60);
            
            Config["Название шрифта в панеле"] = P_FontName = GetConfig("Название шрифта в панеле", "robotocondensed-regular.ttf");
            Config["Размер обводки текста"] = P_ShadowSize = GetConfig("Размер обводки текста", "0.155 0.155");
            Config["Размер шрифта в панеле"] = P_FontSize = GetConfig("Размер шрифта в панеле", 14);
            
            SaveConfig();
        }

        private void Unload()
        {
            BasePlayer.activePlayerList.ForEach(p => CuiHelper.DestroyUi(p, "AlertMessage"));
        }
        
        #endregion
        
        #region Функции
        
        void StartBroadcast()
        {
            string stringToBroadcast = GetMessage();
            foreach (var check in BasePlayer.activePlayerList)
                PanelGUI(check, stringToBroadcast);
            
            if (P_SM_DoubleToChat)
                Server.Broadcast(stringToBroadcast);
        }

        string GetMessage()
        {
            List<string> tempList = new List<string>();
            foreach (var badAlgorithm in lang.GetMessages("en", this).Where(p => p.Key.StartsWith("RANDOM")))
                tempList.Add(badAlgorithm.Value);
            
            return tempList.GetRandom();
        }

        string ReplaceMessage(BasePlayer player, string currentText)
        {
            currentText = currentText.Replace("%NAME%", player.displayName);
            currentText = currentText.Replace("%ONLINE%", BasePlayer.activePlayerList.Count.ToString());
            currentText = currentText.Replace("%SLEEPER%", BasePlayer.sleepingPlayerList.Count.ToString());
            currentText = currentText.Replace("%SLOTS%", ConVar.Server.maxplayers.ToString());
            currentText = currentText.Replace("%TIME%", DateTime.Now.ToShortTimeString());

            return currentText;
        }
        
        #endregion

        #region Хуки
        
        void OnPlayerInit(BasePlayer player)
        {
            if (!P_ShowConnections)
                return;
            
            if (player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerInit(player));
                return;
            }
            
            foreach (var check in BasePlayer.activePlayerList)
                PanelGUI(check, lang.GetMessage("CONNECT_FORMAT", this).Replace("%NAME%", player.displayName));
        }
        
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (P_ShowDisconnections)
                foreach (var check in BasePlayer.activePlayerList)
                    PanelGUI(check, lang.GetMessage("DISCONNECT_FORMAT", this).Replace("%NAME%", player.displayName));
        }
        
        void OnPlayerDie(BasePlayer player, HitInfo info)
        {
            if (!P_ShowKill)
                return;

            if (!(info?.Initiator is BasePlayer))
                return;

            string killMessage;

            if (info?.InitiatorPlayer != player)
            {
                string killer = info?.InitiatorPlayer.displayName;
                string victim = player.displayName;
                if (info?.InitiatorPlayer.GetComponent<NPCPlayer>() != null)
                    killer = "Учёный";
                if (player.GetComponent<NPCPlayer>() != null)
                    victim = "Учёного";
                
                killMessage = lang.GetMessage("KILL_FORMAT", this);
                killMessage = killMessage.Replace("%KILLER%", killer);
                killMessage = killMessage.Replace("%DEAD%", victim);
                killMessage = killMessage.Replace("%DISTANCE%", Math.Floor(Vector3.Distance(player.transform.position, info.InitiatorPlayer.transform.position)).ToString());
            }
            else
            {
                killMessage = lang.GetMessage("SUICIDE_FORMAT", this);
                killMessage = killMessage.Replace("%KILLER%", player.displayName);
            }
            
            foreach (var check in BasePlayer.activePlayerList)
                    PanelGUI(check, killMessage);
        }

        #endregion
        
        #region GUI
        
        void PanelGUI(BasePlayer player, string message)
        {
            CuiHelper.DestroyUi(player, "AlertMessage.Box");
            
            var Panel = new CuiElementContainer();
            var PanelBox = Panel.Add(new CuiPanel
            {
                Image = { Color = $"0 0 0 0" },
                RectTransform = { AnchorMin = "0.2786458 0", AnchorMax = "0.7057291 0.02129629" },
                CursorEnabled = false,
            }, "Hud", "AlertMessage");

            Panel.Add(new CuiElement
            {
                FadeOut = 0.5f,
                Name = "AlertMessage.Box",
                Parent = "AlertMessage",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = ReplaceMessage(player, message),
                        Align = TextAnchor.MiddleCenter,
                        Font = P_FontName,
                        FontSize = P_FontSize,
                        FadeIn = 0.5f
                    },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" },
                    new CuiOutlineComponent() { Color = "0 0 0 1", Distance = P_ShadowSize}
                }
            });
            CuiHelper.AddUi(player, Panel);
            timer.Once(5, () => CuiHelper.DestroyUi(player, "AlertMessage.Box"));
        }
        
        #endregion
        
        #region Helper
        
        void Reply(BasePlayer player, string message, params object[] args) => SendReply(player, lang.GetMessage(message, this, player.UserIDString), args);
        T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));
        
        #endregion
    }
}

// --- End of file: SlotPanel.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NameGrabber.cs ---
// --- Original Local Path: NameGrabber.cs ---

using System.Linq;
using UnityEngine;
using System;
using Rust;
using System.Collections.Generic;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("NameGrabber", "Wolfs Darker", "1.0.1")]
    class NameGrabber : RustPlugin
    {

        [ConsoleCommand("grabname")]
        void cmdGrabName(ConsoleSystem.Arg arg)
        {

            if (arg.Player() && !arg.Player().IsAdmin())
            {
                SendReply(arg, "You don't have access to this command.");
                return;
            }


            if (arg.Args.Length == 0)
            {
                Puts("Wrong command usage! Try: grabname type name.");
                return;
            }

            string type = arg.Args[0];
            string name = arg.Args[1];

            var items_definition = ItemManager.GetItemDefinitions();
            var items_found = new List<string>();
            var temp_variable = "";

            switch (type)
            {
                case "item":
                    foreach (ItemDefinition def in items_definition)
                    {
                        if (def != null)
                        {
                            if (name.Equals("all") || def.shortname.Contains(name))
                            {
                                temp_variable += "'" + def.shortname + "' ";

                                if (temp_variable.Length >= 120)
                                {
                                    items_found.Add(temp_variable);
                                    temp_variable = "";
                                }
                            }
                        }
                    }
                    break;
                case"deployable":
                    foreach (ItemDefinition itemDef in items_definition)
                    {
                        if (itemDef.GetComponent<ItemModDeployable>() != null && (name.Equals("all") || itemDef.GetComponent<ItemModDeployable>().name.ToLower().Contains(name)))
                        {
                            temp_variable += "'" + itemDef.GetComponent<ItemModDeployable>().entityPrefab.resourcePath + "' ";

                            if (temp_variable.Length >= 120)
                            {
                                items_found.Add(temp_variable);
                                temp_variable = "";
                            }
                        }
                    }
                    break;
                case "animal":
                    var animals = UnityEngine.Object.FindObjectsOfType<BaseNPC>().Where(entity => name.Equals("all") || entity.name.Contains(name)).ToArray();
                    foreach (var o in animals)
                    {
                        if (!items_found.Contains(o.name))
                            items_found.Add(o.name);
                    }
                    break;
                case "ingame":
                    var objects = UnityEngine.Object.FindObjectsOfType<BaseEntity>().Where(entity => name.Equals("all") || entity.name.Contains(name)).ToArray();
                    foreach (var o in objects)
                    {
                        if (!items_found.Contains(o.name))
                            items_found.Add(o.name);
                    }
                    type = "In game object";
                    break;
                default:
                    Puts("No entity found!");
                    break;
            }

            if (temp_variable.Length > 0)
                items_found.Add(temp_variable);

            if (items_found.Count != 0)
                foreach (string s in items_found)
                {
                    Puts(type + "s Found: " + s);
                }
            else
                Puts("There is no " + type + " named " + name + ".");
        }
    }
}

// --- End of file: NameGrabber.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/FlippableTurrets.cs ---
// --- Original Local Path: FlippableTurrets.cs ---

using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using System.Reflection;
using Network;
using ProtoBuf;
using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("FlippableTurrets", "DylanSMR", "1.0.4", ResourceId = 2055)]
    class FlippableTurrets : RustPlugin
    {
        #region Fields
            static int constructionColl = UnityEngine.LayerMask.GetMask(new string[] { "Construction", "Deployable", "Prevent Building", "Deployed" });
            static FieldInfo serverinput;
            public InputState inputState;

            public string pf = "assets/prefabs/npc/autoturret/autoturret_deployed.prefab";
            public Dictionary<AutoTurret, int> turretinv = new Dictionary<AutoTurret, int>();
            public Dictionary<AutoTurret, AutoPlayer> turretplayer = new Dictionary<AutoTurret, AutoPlayer>();

            public class AutoPlayer
            {
                public List<ProtoBuf.PlayerNameID> players = new List<ProtoBuf.PlayerNameID>();
                public AutoPlayer(){}
            }
        #endregion

        #region Oxide Hooks
            void Loaded()
            {
                permission.RegisterPermission("flippableturrets.canflip", this);
                lang.RegisterMessages(messages, this);
                serverinput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            }
        #endregion

        #region Langauge
            Dictionary<string, string> messages = new Dictionary<string, string>()
            {
                {"Flipped", "You have flipped that turret successfully."},
                {"NotFlipped", "A error occured upon flipping the turret. This might be because its already flipped!"},
                {"Unflipped", "You have unflipped that turret successfully"},
                {"NotUnFlipped", "A error occured upon unflipping the turret. This might be because its already unflipped!"},
                {"NoPermission", "You do not have permission to preform that command."},
                {"NoTurret", "There is no turret in front of you to flip/unflip :("}
            };
        #endregion

        #region ChatCommands
            [ChatCommand("flipturret")]
            void cmdFlipTurret(BasePlayer player)
            {
                if(!permission.UserHasPermission(player.UserIDString, "flippableturrets.canflip")){
                    SendReply(player, lang.GetMessage("NoPermission", this, player.UserIDString));
                    return;
                }
                inputState = serverinput.GetValue(player) as InputState;
                Ray ray = new Ray(player.eyes.position, Quaternion.Euler(inputState.current.aimAngles) * Vector3.forward);
                BaseEntity flipObject = FindTurret(ray, 5f);
                if(flipObject.ShortPrefabName.Contains("turret")){
                    if(flipTurreT(flipObject, player)) SendReply(player, lang.GetMessage("Flipped", this, player.UserIDString));
                    else SendReply(player, lang.GetMessage("NotFlipped", this, player.UserIDString));
                    return;
                }
                else{
                    SendReply(player, lang.GetMessage("NoTurret", this, player.UserIDString));
                    return;
                }
            }

            [ChatCommand("unflipturret")]
            void cmdUnFlipTurret(BasePlayer player)
            {
                if(!permission.UserHasPermission(player.UserIDString, "flippableturrets.canflip")){
                    SendReply(player, lang.GetMessage("NoPermission", this, player.UserIDString));
                    return;
                }
                inputState = serverinput.GetValue(player) as InputState;
                Ray ray = new Ray(player.eyes.position, Quaternion.Euler(inputState.current.aimAngles) * Vector3.forward);
                BaseEntity flipObject = FindTurret(ray, 5f);
                if(flipObject.ShortPrefabName.Contains("turret")){
                    if(unflipTurreT(flipObject, player)) SendReply(player, lang.GetMessage("Unflipped", this, player.UserIDString));
                    else SendReply(player, lang.GetMessage("NotUnFlipped", this, player.UserIDString));
                    return;
                }
                else{
                    SendReply(player, lang.GetMessage("NoTurret", this, player.UserIDString));
                    return;
                }
            } 

        #endregion

        #region BaseHooks
            private Item BuildItems(string shortname, int amount)
            {
                var definition = ItemManager.FindItemDefinition(shortname); // Find the item definition from its shortname
                if (definition != null && amount != 0)
                {
                    Item item = ItemManager.CreateByItemID(definition.itemid, amount); // Create the item itself
                    if (item != null)
                        return item;
                }         
                return null;
            }  

            static BaseEntity FindTurret(Ray ray, float distance)
            {
                RaycastHit hit;
                if (!UnityEngine.Physics.Raycast(ray, out hit, distance, constructionColl))
                    return null;
                return hit.GetEntity();
            }

            private bool flipTurreT(BaseEntity turret, BasePlayer player)
            {
                try{
                    if(turret.transform.rotation.w == -0.00f) return false;

                    AutoTurret autoTurret = GameManager.server.CreateEntity(pf, new Vector3(turret.transform.position.x, turret.transform.position.y + 3f, turret.transform.position.z), new Quaternion(-2.4f, 0.0f, 0.0f, -0.00f), true) as AutoTurret;
                    autoTurret.Spawn();
                    autoTurret.health = turret.Health();

                    turretinv.Add(autoTurret, 0);
                    foreach(var item in turret.GetComponent<AutoTurret>().inventory.itemList.ToList()) if(item.info.displayName.english == ("5.56 Rifle Ammo")) turretinv[autoTurret] = turretinv[autoTurret] + item.amount;
                    turretplayer.Add(autoTurret, new AutoPlayer{});
                    foreach(var target in turret.GetComponent<AutoTurret>().authorizedPlayers) turretplayer[autoTurret].players.Add(target);

                    Item itemn = BuildItems("ammo.rifle", turretinv[autoTurret]);
                    if (itemn != null) itemn.MoveToContainer(autoTurret.inventory);
                    turretinv.Remove(autoTurret);

                    foreach(var entry in turretplayer[autoTurret].players) autoTurret.authorizedPlayers.Add(entry);
                    turretplayer.Remove(autoTurret);

                    autoTurret.SendNetworkUpdateImmediate();
                    turret.KillMessage();
                    return true;
                }  
                catch(System.Exception)
                {
                    return false;
                }
            }

            private bool unflipTurreT(BaseEntity turret, BasePlayer player)
            {
                try{
                    if(turret.transform.rotation.w != -0.00f) return false;
                    
                    AutoTurret autoTurret = GameManager.server.CreateEntity(pf, new Vector3(turret.transform.position.x, turret.transform.position.y - 3f, turret.transform.position.z), new Quaternion(0.0f, 0.1f, 0.0f, 1.0f), true) as AutoTurret;
                    autoTurret.Spawn();
                    autoTurret.health = turret.Health();   

                    turretinv.Add(autoTurret, 0);
                    foreach(var item in turret.GetComponent<AutoTurret>().inventory.itemList.ToList()) if(item.info.displayName.english == ("5.56 Rifle Ammo")) turretinv[autoTurret] = turretinv[autoTurret] + item.amount;
                    turretplayer.Add(autoTurret, new AutoPlayer{});
                    foreach(var target in turret.GetComponent<AutoTurret>().authorizedPlayers) turretplayer[autoTurret].players.Add(target);

                    Item itemn = BuildItems("ammo.rifle", turretinv[autoTurret]);
                    if (itemn != null) itemn.MoveToContainer(autoTurret.inventory);
                    turretinv.Remove(autoTurret);

                    foreach(var entry in turretplayer[autoTurret].players) autoTurret.authorizedPlayers.Add(entry);
                    turretplayer.Remove(autoTurret);

                    autoTurret.SendNetworkUpdateImmediate();
                    turret.KillMessage();
                    return true;
                }  
                catch(System.Exception)
                {
                    return false;
                }
            } 
        #endregion
    }
}

// --- End of file: FlippableTurrets.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SupplySpeed.cs ---
// --- Original Local Path: SupplySpeed.cs ---

using UnityEngine;
using Newtonsoft.Json;
using System.Collections;

namespace Oxide.Plugins
{
    [Info("Supply Speed", "rustmods.ru.", "1.0.1")]

    public class SupplySpeed : RustPlugin
    {
        #region Конфиг

        private Configuration _config;
        
        public class Configuration 
        {
            [JsonProperty("Во сколько раз ускорять аирдроп?")]
            public float speed = 10f;

            [JsonProperty("Через сколько секунд будет удаляться шашка с дымом? (обычно 210 сек.)")]
            public float grenadeDespawn = 60f;
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadConfig()
        {
            base.LoadConfig(); 

            try 
            {
                _config = Config.ReadObject<Configuration>();
            } 
            catch 
            {
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        #endregion

        private void OnEntitySpawned(SupplyDrop supplyDrop) 
        {
            var setting = supplyDrop.gameObject.AddComponent<DropSettings>();
            setting.windSpeed = _config.speed;
        }

        private void OnEntitySpawned(SupplySignal signal)
        {
            signal.CancelInvoke(signal.FinishUp);
            signal.gameObject.AddComponent<SignalSettings>().ActivateDestroyer(_config.grenadeDespawn);
        }

        private class SignalSettings : MonoBehaviour
        {
            public void ActivateDestroyer(float duration) => StartCoroutine(KillCoroutine(duration));

            private IEnumerator KillCoroutine(float duration)
            {
                for(;;)
                {
                    yield return new WaitForSeconds(duration);
                    GetComponent<SupplySignal>().Kill();
                }
            }
        }

        private class DropSettings : MonoBehaviour
        {
            private SupplyDrop supplyDrop;
            private BaseEntity chute;

            private Vector3 windDir, newDir;

            public float windSpeed = 1f;

            private void Awake()
            {
                supplyDrop = GetComponent<SupplyDrop>();
                if (supplyDrop == null) Destroy(this);

                chute = supplyDrop.parachute;
                windDir = GetDirection();
            }

            private Vector3 GetDirection()
            {
                var direction = Random.insideUnitSphere * 0f;
                if (direction.y > -windSpeed) direction.y = -windSpeed;

                return direction;
            }

            private void FixedUpdate()
            {
                if (chute == null || supplyDrop == null) Destroy(this);

                newDir = Vector3.RotateTowards(transform.forward, windDir, 0.5f * Time.deltaTime, 0.0F);
                newDir.y = 0f;

                supplyDrop.transform.position = Vector3.MoveTowards(transform.position, transform.position + windDir, windSpeed * Time.deltaTime);
                supplyDrop.transform.rotation = Quaternion.LookRotation(newDir);
            }
        }
    }
}

// --- End of file: SupplySpeed.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ZBillBoards.cs ---
// --- Original Local Path: ZBillBoards.cs ---

﻿using UnityEngine;
using System.Collections.Generic;
using Oxide.Core;
using Newtonsoft.Json;
using System.Collections;
using UnityEngine.Networking;
using System.Drawing;
using System.IO;
using System.Drawing.Imaging;

namespace Oxide.Plugins
{
    [Info("ZBillBoards", "TopPlugin.ru", "1.3.0")]
    [Description("Create huge (or small) billboards")]
    public class ZBillBoards : RustPlugin
    {
        private static ZBillBoards ins;
        private GameObject downloadControllerObject;
        private DownloadController downloadController;
        private GameObject pasteControllerObject;
        private PasteController pasteController;

        const string permAdmin = "zbillboards.admin";
        const string permConsole = "zbillboards.console";
        const string permTier1 = "zbillboards.tier1";
        const string permTier2 = "zbillboards.tier2";
        const string permTier3 = "zbillboards.tier3";
        const string dataFileName = "ZBillBoards";

        #region Hooks
        void Init()
        {
            if (!LoadConfigVariables())
            {
                Puts("An error was found in your config file!");
                return;
            }

            permission.RegisterPermission(permAdmin, this);
            permission.RegisterPermission(permConsole, this);
            permission.RegisterPermission(permTier1, this);
            permission.RegisterPermission(permTier2, this);
            permission.RegisterPermission(permTier3, this);
        }

        void OnServerInitialized()
        {
            ins = this;

            downloadControllerObject = new GameObject("DownloadController");
            downloadController = downloadControllerObject.AddComponent<DownloadController>();

            pasteControllerObject = new GameObject("PasteController");
            pasteController = pasteControllerObject.AddComponent<PasteController>();

            ValidateAllBillboards();
        }

        void Unload()
        {
            SaveData();

            UnityEngine.Object.Destroy(downloadControllerObject);
            UnityEngine.Object.Destroy(pasteControllerObject);          
        }
        #endregion

        #region Download controller
        private static void ProcessImage(byte[] bytes, int targetWidth, int targetHeight, DownloadRequest request)
        {
            //byte[] bytesEditedImage;

            using (MemoryStream startBytes = new MemoryStream(), newBytes = new MemoryStream())
            {
                startBytes.Write(bytes, 0, bytes.Length);

                Bitmap image = new Bitmap(startBytes);
                Bitmap finalImage = new Bitmap(targetWidth, targetHeight);

                using (System.Drawing.Graphics graphics = System.Drawing.Graphics.FromImage(finalImage))
                {
                    graphics.DrawImage(image, new Rectangle(0, 0, targetWidth, targetHeight));
                }


                // worry about this later, very heavy because pixel per pixel
                //if (request.adjustBrightness)
                //{                    
                //    bytesEditedImage = RecolorImage(newBytes, targetWidth, targetHeight);
                //    newBytes.Write(bytesEditedImage, 0, bytesEditedImage.Length);
                //}

                finalImage.Save(newBytes, ImageFormat.Png);

                SplitImageAndPaste(request, finalImage, ins.configData.imageSize, ins.configData.imageSize);

                image.Dispose();
                finalImage.Dispose();
            }
        }

        //private static void ProcessDrawing(Signage sign, int targetWidth, int targetHeight, DownloadRequest request)
        //{
        //    //byte[] bytesEditedImage;

        //    var textureId = sign.textureIDs[0];
        //    if (textureId == 0)
        //    {
        //        Debug.LogError("Image texture ID is 0");
        //        return;
        //    }

        //    var imageByte = FileStorage.server.Get(textureId, FileStorage.Type.png, sign.net.ID);
        //    using (MemoryStream ms = new MemoryStream(imageByte))
        //    {
        //        Bitmap image = (Bitmap)Image.FromStream(ms);


        //        Bitmap finalImage = new Bitmap(targetWidth, targetHeight);

        //        using (System.Drawing.Graphics graphics = System.Drawing.Graphics.FromImage(finalImage))
        //        {
        //            graphics.DrawImage(image, new Rectangle(0, 0, targetWidth, targetHeight));

        //        }
        //            SplitImageAndPaste(request, image, ins.configData.imageSize, ins.configData.imageSize);

               

        //        image.Dispose();
        //    }
        //}

        private static void SplitImageAndPaste(DownloadRequest request, Bitmap sourceImage, int defWidth, int defHeight)
        {
            if(ins.configData.debug)
                Debug.Log("Image url: " + request.imageURL);

            if (request.targetSign == null)
            {
                ins.pasteController.PasteNextFromList();
                return;
            }

            BillBoardData billBoardData;
            if (!ins.storedData.billBoards.TryGetValue(request.targetSign.net.ID, out billBoardData)) return;

            var sTotCols = request.width;
            var curCol = 1;
            var curRow = 1;

            foreach (uint signID in billBoardData.billBoardSigns)
            {
                byte[] imagePart = GetImagePart(sourceImage, ins.configData.imageSize, ins.configData.imageSize, curCol, curRow);
                ins.pasteController.AddToPasteList(imagePart, signID, curCol, curRow);

                if (curCol == sTotCols)
                {
                    curCol = 1;
                    curRow++;
                }
                else
                {
                    curCol++;
                }
            }

            sourceImage.Dispose();

            ins.pasteController.PasteNextFromList();
        }

        private static byte[] RecolorImage(MemoryStream stream, int targetWidth, int targetHeight)
        {
            var bytes = stream.ToArray();

            float b = ins.configData.brightness;
            ColorMatrix cm = new ColorMatrix(new float[][]
            {
                new float[] {b, 0, 0, 0, 0},
                new float[] {0, b, 0, 0, 0},
                new float[] {0, 0, b, 0, 0},
                new float[] {0, 0, 0, 1, 0},
                new float[] {0, 0, 0, 0, 1},
            });
            ImageAttributes attributes = new ImageAttributes();
            attributes.SetColorMatrix(cm);

            using (MemoryStream originalBytesStream = new MemoryStream())
            {
                originalBytesStream.Write(bytes, 0, bytes.Length);
                Bitmap sourceImage = new Bitmap(originalBytesStream);
                Bitmap targetImage = new Bitmap(targetWidth, targetHeight);


                Point[] targetRectPoints = { new Point(0, 0), new Point(targetWidth, 0), new Point(0, targetHeight) };
                using (System.Drawing.Graphics graphics = System.Drawing.Graphics.FromImage(targetImage))
                {
                    var sourceRectangle = new Rectangle(0, 0, targetWidth, targetHeight);
                    graphics.DrawImage(sourceImage, targetRectPoints, sourceRectangle, GraphicsUnit.Pixel, attributes);
                }

                var recoloredImageBytes = originalBytesStream.ToArray();
                //targetImage.Dispose();
                //sourceImage.Dispose();

                return recoloredImageBytes;
            }           
        }

        private class DownloadController : FacepunchBehaviour
        {            
            private byte downloading;
            private readonly Queue<DownloadRequest> downloadQueue = new Queue<DownloadRequest>();

            public void QueueDownload(string url, BasePlayer player, Signage sign, int width, int height, bool adjustBrightness)
            {
                downloadQueue.Enqueue(new DownloadRequest(url, player, sign, width, height, adjustBrightness));
                StartNewDownload();
            }

            private byte[] GetDownloadResponse(UnityWebRequest webRequest)
            {
                Texture2D texture = new Texture2D(2, 2);
                texture.LoadImage(webRequest.downloadHandler.data);

                byte[] image;
                image = texture.EncodeToPNG();

                DestroyImmediate(texture);
                return image;
            }

            private void StartNewDownload()
            {
                if (downloading >= 1) return;                
                if (downloadQueue.Count <= 0)
                {
                    if(ins.configData.debug)
                        Debug.Log("Billboard download queue empty, stopped Coroutine");
                    return;
                }
                downloading++;
                StartCoroutine(StartDownload(downloadQueue.Dequeue()));
            }

            private IEnumerator StartDownload(DownloadRequest request)
            {
                Debug.Log("Billboard image download started for " + request.player.displayName + " - Image url: " + request.imageURL);

                UnityWebRequest webRequest = UnityWebRequest.Get(request.imageURL);
                yield return webRequest.SendWebRequest();

                if (webRequest.isNetworkError || webRequest.isHttpError)
                {
                    Debug.Log("Billboard image download failed for image url: " + request.imageURL + " - Error: " + (webRequest.error != null ? webRequest.error : "N/A"));
                    if(request.player != null && request.player.IsConnected)
                        request.player.ChatMessage("Failed to download your image, error: " + (webRequest.error != null ? webRequest.error : "Unknown"));

                    webRequest.Dispose();

                    downloading--;
                    StartNewDownload();
                    yield break;
                }

                byte[] downloadResponse;
                downloadResponse = GetDownloadResponse(webRequest);

                int defWidth = ins.configData.imageSize * request.width;
                int defHeight = ins.configData.imageSize * request.height;

                ProcessImage(downloadResponse, defWidth, defHeight, request);

                //if(request.adjustBrightness)
                //    resizedImageBytes = RecolorImage(downloadResponse, defWidth, defHeight);


                downloading--;

                StartNewDownload();
                webRequest.Dispose();

            }                   
        }

        private class DownloadRequest
        {
            public BasePlayer player { get; }
            public Signage targetSign { get; }
            public string imageURL { get; set; }
            public int width { get; set; } = 1;
            public int height { get; set; } = 1;
            public bool adjustBrightness { get; set; }

            public DownloadRequest(string url, BasePlayer inputPlayer, Signage inputSign, int inputWidth, int inputHeight, bool inpBrightness)
            {
                imageURL = url;
                player = inputPlayer;
                targetSign = inputSign;
                width = inputWidth;
                height = inputHeight;
                adjustBrightness = inpBrightness;
            }
        }
        #endregion

        #region Paste Controller
        private class PasteController : FacepunchBehaviour
        {
            private bool isPasting = false;
            private List<PasteRequest> pasteList = new List<PasteRequest>();

            public void AddToPasteList(byte[] imgData, uint signID, int coordsX, int coordsY)
            {
                pasteList.Add(new PasteRequest(imgData, signID, coordsX, coordsY));
            }

            public void PasteNextFromList()
            {
                if (isPasting) return;
                if (pasteList.Count == 0) return;

                isPasting = true;

                var request = pasteList[0];
                pasteList.RemoveAt(0);

                PasteImage(request);
            }

            public void ClearPasteList()
            {
                isPasting = true;
                pasteList.Clear();
                isPasting = false;
            }

            public int GetEmptyFrame(Signage sign)
            {
                for (int index = 0; index < sign.textureIDs.Length; index++)
                {
                    if (sign.textureIDs[index] == 0)
                        return index;
                }
                return 0;
            }

            private void PasteImage(PasteRequest request)
            {
                Signage targetSign = BaseNetworkable.serverEntities.Find(request.signID) as Signage;
                if (targetSign == null)
                {
                    isPasting = false;
                    return;
                }

                targetSign.EnsureInitialized();

                var frameNumber = GetEmptyFrame(targetSign);
                var currentTextureID = targetSign.textureIDs[frameNumber];

                if (currentTextureID != 0)
                    FileStorage.server.RemoveExact(currentTextureID, FileStorage.Type.png, targetSign.net.ID, (uint)frameNumber);

                var textureId = FileStorage.server.Store(request.imgData, FileStorage.Type.png, targetSign.net.ID, (uint)frameNumber);
                targetSign.textureIDs[frameNumber] = textureId;
                targetSign.SendNetworkUpdate();

                if(ins.configData.debug)
                    Debug.Log("Pasted image on sign " + targetSign.net.ID + ", " + ins.pasteController.pasteList.Count + " signs left");


                isPasting = false;

                Invoke("PasteNextFromList", ins.configData.pasteDelay);
            }
        }

        private class PasteRequest
        {
            public uint signID { get; }
            public byte[] imgData { get; }
            public int signX { get; }
            public int signY { get; }

            public PasteRequest(byte[] inpImgData, uint inpSignID, int coordsX, int coordsY)
            {
                imgData = inpImgData;
                signID = inpSignID;
                signX = coordsX;
                signY = coordsY;
            }
        }

        private static byte[] GetImagePart(Bitmap sourceImage, int targetWidth, int targetHeight, int splitX, int splitY)
        {
            byte[] bytesClipped;

            var streamResized = new MemoryStream();
            Bitmap targetImage = new Bitmap(targetWidth, targetHeight);

            int pixelsX = (splitX - 1) * targetWidth;
            int pixelsY = (splitY - 1) * targetHeight;
            Point[] targetRectPoints = { new Point(0, 0), new Point(targetWidth, 0), new Point(0, targetHeight) };

            using (System.Drawing.Graphics graphics = System.Drawing.Graphics.FromImage(targetImage))
            {
                var sourceRectangle = new Rectangle(pixelsX, pixelsY, targetWidth, targetHeight);
                graphics.DrawImage(sourceImage, targetRectPoints, sourceRectangle, GraphicsUnit.Pixel);
            }

            AddRandomPixel(targetImage);

            targetImage.Save(streamResized, ImageFormat.Png);
            bytesClipped = streamResized.ToArray();
            targetImage.Dispose();

            return bytesClipped;
        }

        #endregion

        #region Commands
        [ConsoleCommand("billboard.toggle")]
        private void consoleCmdZDP(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null)
                return;

            if (!HasPermission(player.UserIDString, permConsole))
                return;

            if (arg.Args.Length > 0)
            {
                uint posID;
                if (!uint.TryParse(arg.Args[0], out posID)) return;

                NeonSign mainSign = GetMainSign(posID) as NeonSign;
                if (mainSign == null) return;

                if (configData.debug)
                    Puts("Console command used to toggle power on billboard " + posID);

                SwitchBillBoardPower(mainSign);
            }
        }

        [ChatCommand("billboard")]
        private void cmdBillBoard(BasePlayer player, string command, string[] args)
        {
            var maxSigns = 0;
            var maxBillboards = 0;
            if(HasPermission(player.UserIDString, permAdmin)) {
                maxSigns = configData.maxSignsAdmin;
                maxBillboards = configData.maxBillboardsAdmin;
            }
            else if (HasPermission(player.UserIDString, permTier3)) {
                maxSigns = configData.maxSignsTier3;
                maxBillboards = configData.maxBillboardsTier3;
            }
            else if (HasPermission(player.UserIDString, permTier2)) {
                maxSigns = configData.maxSignsTier2;
                maxBillboards = configData.maxBillboardsTier2;
            }
            else if (HasPermission(player.UserIDString, permTier1)) {
                maxSigns = configData.maxSignsTier1;
                maxBillboards = configData.maxBillboardsTier1;
            }
            else
            {
                player.ChatMessage("No permission");
                return;
            }

            if (args.Length > 0)
            {
                switch (args[0])
                {
                    case "create": CreateBillBoard(player, args, maxSigns, maxBillboards); break;
                    case "remove":
                    case "destroy": DestroyBillBoard(player); break;
                    case "destroyall": DestroyBillBoards(player); break;
                    case "info": ShowBillboardInfo(player); break;
                    case "debug": ToggleDebug(player); break;
                    case "addsign": AddSignToBillboard(player, args); break;
                    case "toggle": ToggleBillBoardPower(player); break;
                    case "speed": ChangeBillBoardSpeed(player, args); break;
                    case "dimmer": ChangeBillBoardDimmer(player, args); break;
                    case "next": CommandPasteNext(player); break;
                    case "emptypaste": CommandPasteEmpty(player); break;
                    case "sil": SilBillBoard(player, args); break;
                    //case "draw": DrawingToBillBoard(player, args); break;
                }
            }
        }
        #endregion

        #region Functions
        // for next version
        //public void DrawingToBillBoard(BasePlayer player, string[] args)
        //{
        //    if (!selectedSigns.ContainsKey(player))
        //        selectedSigns.Add(player, null);

        //    if(args.Length == 3)
        //    {
        //        int cols;
        //        int rows;
        //        if (!int.TryParse(args[1], out cols) || !int.TryParse(args[2], out rows))
        //        {
        //            player.ChatMessage("Incorrect syntax: /billboard draw 3 2");
        //            return;
        //        }

        //        var startSign = GetBillBoard(player);
        //        if (startSign == null) return;

        //        Signage selectedSign;
        //        if (!selectedSigns.TryGetValue(player, out selectedSign) || selectedSign == null)
        //        {
        //            player.ChatMessage("Select a source sign first: /billboard draw select");
        //            return;
        //        }

        //        player.ChatMessage("Drawing painting from sign to billboard");
        //        ProcessDrawing(selectedSign, cols, rows, new DownloadRequest("", player, startSign, cols, rows, false));
        //    }
        //    else if(args.Length > 1)
        //    {
        //        switch(args[1])
        //        {
        //            case "select":
        //                RaycastHit hit;
        //                if (!Physics.Raycast(player.eyes.HeadRay(), out hit, 6f))
        //                {
        //                    player.ChatMessage("Please look at a sign!");
        //                    return;
        //                }

        //                var sourceSign = hit.GetEntity() as Signage;
        //                if(sourceSign == null)
        //                {
        //                    player.ChatMessage("Please look at a sign!");
        //                    return;
        //                }

        //                selectedSigns[player] = sourceSign;
        //                player.ChatMessage("Selected " + sourceSign.ShortPrefabName);
        //                break;
        //        }
        //    }
        //    else
        //    {
        //        player.ChatMessage("Incorrect syntax: /billboard draw select | /billboard draw 3 2");
        //        return;
        //    }
        //}

        public void ValidateAllBillboards()
        {
            var allBB = new Dictionary<uint, BillBoardData>(storedData.billBoards);
            Puts("Validating " + allBB.Count + " billboards...");
            foreach(var mainSign  in allBB)
            {
                ValidateBillboard(mainSign.Key);               
            }

            Puts("All billboards validated");
        }

        public void ValidateBillboard(uint mainSignID)
        {
            BillBoardData billBoardData;
            if(!storedData.billBoards.TryGetValue(mainSignID, out billBoardData))
            {
                Puts("Trying to validate a non-existing billboard");
                return;
            }

            Signage signage = BaseNetworkable.serverEntities.Find(mainSignID) as Signage;
            if (signage == null)
            {
                storedData.billBoards.Remove(mainSignID);

                RemoveFromUserBillboards(mainSignID);

                Puts("Deleted billboard " + mainSignID + " as it does not exist anymore");
                return;
            }

            var speed = 3f;
            if (billBoardData.speed > 0)
                speed = billBoardData.speed;

            Puts("Billboard " + mainSignID + " has " + billBoardData.billBoardSigns.Count + " signs, validating...");
            foreach (var subSign in billBoardData.billBoardSigns)
            {
                Signage subSignage = BaseNetworkable.serverEntities.Find(subSign) as Signage;
                if (subSignage == null)
                {
                    storedData.billBoards[mainSignID].billBoardSigns.Remove(subSign);
                    Puts("Deleted sign " + subSign + " from billboard " + mainSignID);
                    continue;
                }

                var subSignNeon = subSignage as NeonSign;
                if (subSignNeon != null)
                {
                    subSignNeon.animationSpeed = speed;
                    subSignNeon.UpdateHasPower(0, 0);
                }
            }

            if (signage is NeonSign)
                SwitchBillBoardPower(signage as NeonSign, 25);

            Puts("Billboard validated");
        }

        public void ToggleBillBoardPower(BasePlayer player)
        {
            var billboardSign = GetBillBoard(player) as NeonSign;
            if (billboardSign == null) return;

            SwitchBillBoardPower(billboardSign);

            player.ChatMessage("Billboard power toggled");
            return;
        }

        public void AddSignToBillboard(BasePlayer player, string[] args)
        {
            if (args.Length == 0) return;

            var newSign = GetBillBoard(player, false);
            if (newSign == null) return;

           

            uint inpID;
            if (!uint.TryParse(args[1], out inpID))
            {
                player.ChatMessage("Invalid billboard ID");
                return;
            }


            if (!storedData.billBoards.ContainsKey(inpID))
            {
                player.ChatMessage("Billboard not found");
                return;
            }

            if (storedData.billBoards[inpID].billBoardSigns.Contains(newSign.net.ID))
            {
                player.ChatMessage("Already in billboard!");
                return;
            }

            storedData.billBoards[inpID].billBoardSigns.Add(newSign.net.ID);

            newSign.UpdateHasPower(25, 0);
            newSign.SendNetworkUpdate();

            player.ChatMessage("Sign added to billboard");
            return;
        }

        public void ToggleDebug(BasePlayer player = null)
        {
            configData.debug = !configData.debug;
            SaveConf();

            player.ChatMessage("Debug mode set to: " + configData.debug);
            return;
        }

        private void SwitchBillBoardPower(NeonSign billboardSign, int forcePower = -1)
        {
            int newPower = billboardSign.IsPowered() ? 0 : 25;
            if (forcePower >= 0)
                newPower = forcePower;

            BillBoardData billBoardData;
            if (!ins.storedData.billBoards.TryGetValue(billboardSign.net.ID, out billBoardData)) return;

            foreach (uint signID in billBoardData.billBoardSigns)
            {
                Signage signage = BaseNetworkable.serverEntities.Find(signID) as Signage;
                if (signage == null) continue;

                Interface.CallHook("OnBillboardPowerToggled", billboardSign.net.ID, signage, newPower > 0);

                signage.UpdateHasPower(newPower, 0);
                signage.SendNetworkUpdate();
            }
        }

        public void ChangeBillBoardSpeed(BasePlayer player, string[] args)
        {
            var billboardSign = GetBillBoard(player) as NeonSign;
            if (billboardSign == null) return;

            if (args.Length != 2)
            {
                player.ChatMessage("Wrong usage: /billboard speed 3");
                return;
            }

            BillBoardData billBoardData;
            if (!storedData.billBoards.TryGetValue(billboardSign.net.ID, out billBoardData))
            {
                player.ChatMessage("Billboard not found");
                return;
            }

            float newSpeed;
            if (!float.TryParse(args[1], out newSpeed) && newSpeed >= 0) {
                player.ChatMessage("Invalid speed, usage: /billboard speed 3");
                return;
            }            

            billBoardData.speed = newSpeed;

            foreach (uint signID in billBoardData.billBoardSigns)
            {
                NeonSign signage = BaseNetworkable.serverEntities.Find(signID) as NeonSign;
                if (signage == null) continue;

                signage.animationSpeed = newSpeed;
                signage.SendNetworkUpdate();
            }

            SwitchBillBoardPower(billboardSign);
            SwitchBillBoardPower(billboardSign);

            player.ChatMessage("Billboard speed set to: "+ newSpeed);
            return;
        }

        public void ChangeBillBoardDimmer(BasePlayer player, string[] args)
        {
            var billboardSign = GetBillBoard(player);
            if (billboardSign == null) return;

            if (args.Length != 2)
            {
                player.ChatMessage("Wrong usage: /billboard dimmer 2");
                return;
            }

            float newIntensity = 2f;
            float intensity = 1f;
            if (float.TryParse(args[1], out intensity) && intensity >= 0) newIntensity = intensity;

            BillBoardData billBoardData;
            if (!ins.storedData.billBoards.TryGetValue(billboardSign.net.ID, out billBoardData)) return;

            foreach (uint signID in billBoardData.billBoardSigns)
            {
                NeonSign signage = BaseNetworkable.serverEntities.Find(signID) as NeonSign;
                if (signage == null) return;

                signage.lightIntensity = newIntensity;
                signage.SendNetworkUpdate();
            }

            player.ChatMessage("Billboard dimmer set to: " + newIntensity);
            return;
        }

        public void SilBillBoard(BasePlayer player, string[] args)
        {
            if (args.Length < 2)
            {
                //player.ChatMessage("Incorrect syntax: /billboard sil <url> [darker]");
                player.ChatMessage("Incorrect syntax: /billboard sil <url>");
                return;
            }

            var startSign = GetBillBoard(player);
            if (startSign == null) return;

            BillBoardData billBoardData;
            if(!storedData.billBoards.TryGetValue(startSign.net.ID, out billBoardData))
            {
                player.ChatMessage("This sign does not seem te be part of a billboard");
                return;
            }

            bool adjustBrightness = false;
            if (args.Length > 2 && args[2] == "true")
                adjustBrightness = true;

            downloadController.QueueDownload(args[1], player, startSign, billBoardData.signsHorizontal, billBoardData.signsVertical, adjustBrightness);
            player.ChatMessage("Loading images...");           
        }

        public void DestroyBillBoards(BasePlayer player)
        {
            if (!HasPermission(player.UserIDString, permAdmin))
                return;            

            foreach (var billBoardData in storedData.billBoards)
            {
                foreach (uint signID in billBoardData.Value.billBoardSigns)
                {
                    BaseEntity ent = BaseNetworkable.serverEntities.Find(signID) as BaseEntity;
                    if (ent != null)
                    {
                        ent.Kill();
                    }
                }
            }
            storedData.billBoards.Clear();
            storedData.userBillboards.Clear();
        }

        public void DestroyBillBoard(BasePlayer player)
        {
            var sign = GetBillBoard(player);
            if (sign == null) return;

            uint sid = sign.net.ID;
            BillBoardData billBoardData;
            if (!ins.storedData.billBoards.TryGetValue(sid, out billBoardData)) return;

            var signItemName = sign is NeonSign ? "sign.neon.xl.animated" : "sign.pictureframe.xl";


            foreach (uint signID in billBoardData.billBoardSigns)
            {
                BaseEntity ent = BaseNetworkable.serverEntities.Find(signID) as BaseEntity;
                if (ent != null) ent.Kill();                
            }
            storedData.billBoards.Remove(sid);

            RemoveFromUserBillboards(sid);

            if(configData.refundOnDestroy)
            {
                var item = ItemManager.CreateByName(signItemName);
                if(item != null)
                    player.GiveItem(item);
            }

            player.ChatMessage("Billboard destroyed");
        }

        public void RemoveFromUserBillboards(uint sid)
        {
            var userBBs = new Dictionary<string, List<uint>>(storedData.userBillboards);
            foreach (var ubb in userBBs)
            {
                if (!ubb.Value.Contains(sid)) continue;

                storedData.userBillboards[ubb.Key].Remove(sid);

                if (storedData.userBillboards[ubb.Key].Count == 0)
                    storedData.userBillboards.Remove(ubb.Key);
            }
        }

        public Signage GetBillBoard(BasePlayer player, bool checkIfBillBoard = true)
        {
            RaycastHit hit;
            if (!Physics.Raycast(player.eyes.HeadRay(), out hit, 6f))
            {
                player.ChatMessage("Please look at a billboard!");
                return null;
            }

            Signage billboardSign = null;
            billboardSign = hit.GetEntity() as Signage;

            
            if (billboardSign == null || (!billboardSign.ShortPrefabName.Contains("sign.neon.xl.animated") && !billboardSign.ShortPrefabName.Contains("sign.pictureframe.xl")))
            {
                player.ChatMessage("Cannot find Billboard / XL Animated Neon sign / XL Pictureframe!");
                return null;
            }

            if(!checkIfBillBoard)
            {
                return billboardSign;
            }

            Signage mainSign = GetMainSign(billboardSign.net.ID);
            if (checkIfBillBoard && mainSign == null)
            {
                player.ChatMessage("Please look at a billboard!");
                return null;
            }
           
            return mainSign;            
        }

        public Signage GetMainSign(uint raySignID)
        {
            uint parentSignID = 0;

            foreach (var billBoardData in storedData.billBoards)
            {
                foreach (uint subSignID in billBoardData.Value.billBoardSigns)
                {
                    if(subSignID == raySignID)
                    {
                        parentSignID = billBoardData.Key;
                        break;
                    }                    
                }

                if (parentSignID != 0) break;
            }

            if (parentSignID == 0)
                return null;

            Signage ent = BaseNetworkable.serverEntities.Find(parentSignID) as Signage;
            if (ent == null)
                return null;

            return ent;        
        }

        public void ShowBillboardInfo(BasePlayer player)
        {
            var billboard = GetBillBoard(player);
            if(billboard != null)
                player.ChatMessage("Billboard ID: " + billboard.net.ID + "\nLocation: " + billboard.transform.position);
        }

        public void CreateBillBoard(BasePlayer player, string[] args, int maxSigns, int maxBillboards)
        {
            int horizontal = 3;
            int vertical = 2;

            List<uint> userBillboards;
            if(maxBillboards > 0 && storedData.userBillboards.TryGetValue(player.UserIDString, out userBillboards) && userBillboards.Count >= maxBillboards)
            {
                player.ChatMessage("Failed creating billboard: You have reached the limit (" + maxBillboards + ")");
                return;
            }

            if (args.Length == 3)
            {
                int inputH;
                int inputV;
                if (int.TryParse(args[1], out inputH) && int.TryParse(args[2], out inputV) && inputH > 0 && inputV > 0 && (inputH * inputV) < maxSigns)
                {
                    horizontal = inputH;
                    vertical = inputV;
                }
            }

            if(!HasPermission(player.UserIDString, permAdmin) && player.IsBuildingBlocked())
            {
                player.ChatMessage("You can not create billboards in building blocked zones");
                return;
            }

            if(horizontal * vertical > maxSigns)
            {
                player.ChatMessage("The total of signs can not be higher than " + maxSigns);
                return;
            }

            var startSign = GetBillBoard(player, false);
            if (startSign == null)
            {
                player.ChatMessage("Can not find the main billboard sign");
                return;
            }

            if (storedData.billBoards.ContainsKey(startSign.net.ID))
            {
                player.ChatMessage("This is already a billboard");
                return;
            }

            storedData.billBoards.Add(startSign.net.ID, new BillBoardData());

            BillBoardData billBoardData;
            if (!storedData.billBoards.TryGetValue(startSign.net.ID, out billBoardData))
            {
                player.ChatMessage("Something went wrong while creating the billboard");
                return;
            }

            billBoardData.billBoardSigns.Add(startSign.net.ID);
            billBoardData.signsHorizontal = horizontal;
            billBoardData.signsVertical = vertical;

            if (!storedData.userBillboards.ContainsKey(player.UserIDString))
                storedData.userBillboards.Add(player.UserIDString, new List<uint>());
            storedData.userBillboards[player.UserIDString].Add(startSign.net.ID);

            if (configData.lockSigns)
                startSign.SetFlag(BaseEntity.Flags.Locked, true, false, true);

            string prefab = "assets/prefabs/misc/xmas/neon_sign/sign.neon.xl.animated.prefab";
            float offset = -2.5f;
            var rotation = startSign.transform.rotation;

            var startSignNeon = startSign as NeonSign;
            if (startSignNeon != null)
            {
                startSignNeon.UpdateHasPower(25, 0);
                startSignNeon.SendNetworkUpdate();                
            }
            else
            {
                prefab = "assets/prefabs/deployable/signs/sign.pictureframe.xl.prefab";
                offset = -2.7f;
            }

            

            for (int col = 0; col < vertical; col++)
            {
                for (int row = 0; row < horizontal; row++)
                {
                    if (row == 0 && col == 0) continue;

                    var newPosition = startSign.transform.position + (startSign.transform.right * row * offset) + (startSign.transform.up * col * offset);

                    Signage sign = GameManager.server.CreateEntity(prefab, newPosition, rotation) as Signage;
                    if (sign == null) return;
                    sign.Spawn();
                    sign.OwnerID = player.userID;

                    if (configData.lockSigns)
                        sign.SetFlag(BaseEntity.Flags.Locked, true, false, true);

                    if (sign is NeonSign)
                    {
                        sign.UpdateHasPower(25, 0);
                        sign.SendNetworkUpdate();
                    }

                    //storedData.billBoards[startSign.net.ID].billBoardSigns.Add(sign.net.ID);
                    billBoardData.billBoardSigns.Add(sign.net.ID);
                    
                    if(configData.debug)
                        Puts("Billboard part " + row + " x " + col + " spawned at " + newPosition);
                }
            }
        }
        
        public void CommandPasteNext(BasePlayer player)
        {
            if (!HasPermission(player.UserIDString, permAdmin))
                return;

            if (pasteController != null)
            {
                pasteController.PasteNextFromList();
                player.ChatMessage("Pasting next frame...");
                return;
            }
        }

        public void CommandPasteEmpty(BasePlayer player)
        {
            if (!HasPermission(player.UserIDString, permAdmin))
                return;

            if (pasteController != null)
            {
                pasteController.ClearPasteList();
                player.ChatMessage("PasteList cleared...");
                return;
            }
        }
        #endregion

        #region Helpers
        public UnityEngine.Random rnd = new UnityEngine.Random();
        private static void AddRandomPixel(Bitmap image)
        {
            var color = System.Drawing.Color.FromArgb(
                UnityEngine.Random.Range(0, 255),
                UnityEngine.Random.Range(0, 255),
                UnityEngine.Random.Range(0, 255),
                128 //Alpha (transparency)
            );
            image.SetPixel(image.Width - 1, 1, color);
        }

        bool HasPermission(string id, string perm) => permission.UserHasPermission(id, perm);

        #endregion

        #region Config
        private ConfigData configData;

        class ConfigData
        {
            [JsonProperty(PropertyName = "Maximum amount of signs in total (width x height) Tier 1")]
            public int maxSignsTier1 = 6;

            [JsonProperty(PropertyName = "Maximum amount of billboards (any size, 0 = unlimited) Tier 1")]
            public int maxBillboardsTier1 = 1;

            [JsonProperty(PropertyName = "Maximum amount of signs in total (width x height) Tier 2")]
            public int maxSignsTier2 = 12;

            [JsonProperty(PropertyName = "Maximum amount of billboards (any size, 0 = unlimited) Tier 2")]
            public int maxBillboardsTier2 = 3;

            [JsonProperty(PropertyName = "Maximum amount of signs in total (width x height) Tier 3")]
            public int maxSignsTier3 = 16;

            [JsonProperty(PropertyName = "Maximum amount of billboards (any size, 0 = unlimited) Tier 3")]
            public int maxBillboardsTier3 = 5;

            [JsonProperty(PropertyName = "Maximum amount of signs in total (width x height) Admin")]
            public int maxSignsAdmin = 150;

            [JsonProperty(PropertyName = "Maximum amount of billboards (any size, 0 = unlimited) Admin")]
            public int maxBillboardsAdmin = 0;

            [JsonProperty(PropertyName = "Width and height of each neon sign image in pixels")]
            public int imageSize = 150;

            [JsonProperty(PropertyName = "Seconds between pasting images")]
            public float pasteDelay = 0.5f;

            [JsonProperty(PropertyName = "Brightness of the images pasted on the billboards (experimental)")]
            public float brightness = 0.5f;

            [JsonProperty(PropertyName = "Lock signs to owner after creating billboard")]
            public bool lockSigns = false;

            [JsonProperty(PropertyName = "Give back a Neon Sign when a billboard is removed with the destroy command")]
            public bool refundOnDestroy = true;

            [JsonProperty(PropertyName = "Log extra output to console")]
            public bool debug = false;
        }

        private bool LoadConfigVariables()
        {
            try
            {
                configData = Config.ReadObject<ConfigData>();
            }
            catch
            {
                return false;
            }
            SaveConf();
            return true;
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Creating new config file.");
            configData = new ConfigData();
            SaveConf();
        }

        void SaveConf() => Config.WriteObject(configData, true);
        #endregion

        #region Data
        StoredData storedData;
        class StoredData
        {
            public Dictionary<uint, BillBoardData> billBoards = new Dictionary<uint, BillBoardData>();
            public Dictionary<string, List<uint>> userBillboards = new Dictionary<string, List<uint>>();
        }

        class BillBoardData
        {
            public float speed = 3f;
            public int signsHorizontal = 0;
            public int signsVertical = 0;
            public List<uint> billBoardSigns = new List<uint>();
            
        }

        void Loaded()
        {
            LoadData();
        }

        public void LoadData()
        {
            try
            {
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(dataFileName);
            }
            catch
            {
                storedData = new StoredData();
                Puts("Invalid datafile, new file generated");

                SaveData();
            }

            if (storedData == null)
            {
                storedData = new StoredData();
                Puts("Invalid datafile, new file generated");

                SaveData();
            }
        }

        void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(dataFileName, storedData);
        }
        #endregion
    }
}


// --- End of file: ZBillBoards.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NoBuildOnRoad.cs ---
// --- Original Local Path: NoBuildOnRoad.cs ---

using UnityEngine;
using System;
using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("No Build On Road", "supreme", "1.0.4")]
    [Description("Disallow building over road")]
    public class NoBuildOnRoad : RustPlugin
    {
        const string NoBuildOnRoadIgnore = "nobuildonroad.ignore";
        
        #region Lang
        
        protected override void LoadDefaultMessages() 
        {
        lang.RegisterMessages(new Dictionary<string, string>
        {
            {"NoPermMsg", "Building on road is not allowed."}

        }, this, "en");

        lang.RegisterMessages(new Dictionary<string, string>
        {
            {"NoPermMsg", "Vous n'avez pas la permission de construire sur les routes."}
            
        }, this, "fr"); 
        }

    #endregion
    
    #region Configuration
    
    private Configuration _config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Prefix")]
        public string usedPrefix = "[NBOR]";
        
        [JsonProperty(PropertyName = "Prefix Color")]
        public string usedPrefixColor = "#ACFA58";
        
        [JsonProperty(PropertyName = "Chat Icon [SteamID64]")]
        public ulong chatIcon = 76561198278456562;
    }

    protected override void LoadConfig()
    {
        base.LoadConfig();
        try
        {
            _config = Config.ReadObject<Configuration>();
            if (_config == null) throw new Exception();
            SaveConfig();
        }
        catch
        {
            PrintError("Your configuration file contains an error. Using default configuration values.");
            LoadDefaultConfig();
        }
    }

    protected override void SaveConfig() => Config.WriteObject(_config);

    protected override void LoadDefaultConfig() => _config = new Configuration();
    
    #endregion

    #region Hooks
        
        void OnEntityBuilt(Planner plan, GameObject go)
        {
            if (go == null) return;
            var player = plan.GetOwnerPlayer();
            var block = go.ToBaseEntity();
            bool ignore = permission.UserHasPermission(player.UserIDString, NoBuildOnRoadIgnore);
            if (ignore) return;
            bool incave = CheckRoad(block.transform.position);
            if (incave)
            {
                if (block == null) return;
                NextFrame( () => block.Kill());
                GiveRefund(block, player);
                Player.Message(player, $"{lang.GetMessage("NoPermMsg", this, player.UserIDString)}", $"<color={_config.usedPrefixColor}>{_config.usedPrefix}</color>", _config.chatIcon);
            }
        }
        
        void GiveRefund(BaseEntity entity, BasePlayer player)
        {
            var name = entity.ShortPrefabName.Replace(".deployed", "").Replace("_deployed", "");
            if (name == "wall.external.high.wood")
            {
                name = name.Replace(".wood", "");
            }

            if (name == "refinery_small")
            {
                name = name.Replace("refinery_small", "small.oil.refinery");
            }

            if (name == "vendingmachine")
            {
                name = name.Replace("vendingmachine", "vending.machine");
            }

            if (name == "woodbox")
            {
                name = name.Replace("woodbox", "box.wooden");
            }

            if (name == "researchtable")
            {
                name = name.Replace("researchtable", "research.table");
            }
            
            if (name == "repairbench")
            {
                name = name.Replace("repairbench", "box.repair.bench");
            }

            if (name == "hitchtrough")
            {
                name = name.Replace("hitchtrough", "hitchtroughcombo");
            }

            if (name == "water_catcher_small")
            {
                name = name.Replace("water_catcher_small", "water.catcher.small");
            }
            
            if (name == "water_catcher_large")
            {
                name = name.Replace("water_catcher_large", "water.catcher.large");
            }
            
            if (name == "fireplace")
            {
                name = name.Replace("fireplace", "fireplace.stone");
            }
            
            if (name == "sleepingbag_leather")
            {
                name = name.Replace("sleepingbag_leather", "sleepingbag");
            }
            
            if (name == "waterbarrel")
            {
                name = name.Replace("waterbarrel", "water.barrel");
            }
            
            if (name == "sam_site_turret")
            {
                name = name.Replace("sam_site_turret", "samsite");
            }
            
            if (name == "beartrap")
            {
                name = name.Replace("beartrap", "trap.bear");
            }
            
            if (name == "landmine")
            {
                name = name.Replace("landmine", "trap.landmine");
            }
            
            if (name == "electric.windmill.small")
            {
                name = name.Replace("electric.windmill.small", "generator.wind.scrap");
            }
            
            var item = ItemManager.CreateByName(name);
            if (item != null)
            {
                player.GiveItem(item);
                return;
            }

            var block = entity.GetComponent<BaseCombatEntity>();
            if (block != null)
            {
                var cost = block.BuildCost();
                if (cost != null)
                {
                    foreach (var value in cost)
                    {
                        var x = ItemManager.Create(value.itemDef, Convert.ToInt32(value.amount * (entity.Health() / entity.MaxHealth())));
                        if (x == null) continue;
                        player.GiveItem(x);
                    }
                }
            }
        }
        
        void Init()
        {
            permission.RegisterPermission(NoBuildOnRoadIgnore, this);
        }
        
        #endregion
        
        #region Check for road layer
        
        bool CheckRoad(Vector3 Position)
        {
            RaycastHit hitInfo;
            if (!Physics.Raycast(Position, Vector3.down, out hitInfo, 66f, LayerMask.GetMask("Terrain", "World", "Construction", "Water"), QueryTriggerInteraction.Ignore) || hitInfo.collider == null) return false;
            if (hitInfo.collider.name.ToLower().Contains("road")) return true;
            return false;
        }
        
        #endregion
    }
}

// --- End of file: NoBuildOnRoad.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SkyReportSystem (1).cs ---
// --- Original Local Path: SkyReportSystem (1).cs ---

using Newtonsoft.Json;
using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Globalization;
using UnityEngine;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Libraries;
using ConVar;
using Newtonsoft.Json.Linq;

namespace Oxide.Plugins
{
    [Info("SkyReportSystem", "https://topplugin.ru/", "3.2.0")]
    [Description("Report system for rust")]
    public class SkyReportSystem : RustPlugin
    {
        #region Reference
        [PluginReference] Plugin IQChat, ImageLibrary;
        public string GetImage(string shortname, ulong skin = 0) => (string)ImageLibrary?.Call("GetImage", shortname, skin);

        Dictionary<ulong, ulong> CheckPlayerModeration = new Dictionary<ulong, ulong>();
        #endregion

        #region Config
        private Configuration config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "VK:", Order = 0)]
            public VKontakte vKontakte;

            [JsonProperty(PropertyName = "Discord:", Order = 1)]
            public Discord discord;

            [JsonProperty(PropertyName = "Setting:", Order = 2)]
            public Setting setting;

            [JsonProperty(PropertyName = "Проверка на AFK:", Order = 3)]
            public IsAfk isafk;

            [JsonProperty(PropertyName = "Причины бана:", Order = 4)]
            public List<BanReasons> banReasons;

            [JsonProperty("Настройки плагина", Order = 5)]
            public List<string> Reasonsforcomplaint;
        }

        public class BanReasons
        {
            [JsonProperty(PropertyName = "Причина бана:", Order = 0)]
            public string BanReason;

            [JsonProperty(PropertyName = "Команда для бана:", Order = 1)]
            public string BanReasonCommand;
        }

        public class IsAfk
        {
            [JsonProperty(PropertyName = "Включить проверку на AFK ?", Order = 0)]
            public bool usecheckafk;

            [JsonProperty(PropertyName = "Время между проверками на AFK", Order = 2)]
            public float timecheckisafk;
        }


        public class Setting
        {
            [JsonProperty(PropertyName = "Аватар для сообщений(Для работы с IQChat )", Order = 0)]
            public ulong avatarid;

            [JsonProperty(PropertyName = "Префикс(Для работы с IQChat )", Order = 1)]
            public string prefix;

            [JsonProperty(PropertyName = "Колличевство репортов для вызова на проверку", Order = 3)]
            public int maxreportcall;

            [JsonProperty(PropertyName = "Отправлять сообщения модераторам в чат о том что игрок превысил количевство репортов (Требуется разрешения SkyReportSystem.moderator)", Order = 4)]
            public bool usemodercall;

            [JsonProperty(PropertyName = "Включить логирование ?", Order = 5)]
            public bool uselog;

            [JsonProperty(PropertyName = "Кд на отправку репортов", Order = 6)]
            public int Cooldown;

            [JsonProperty(PropertyName = "Названия сервера", Order = 7)]
            public string servername;

            [JsonProperty(PropertyName = "Команда для открытия репорт меню", Order = 8)]
            public string comandplayer;

            [JsonProperty(PropertyName = "Команда для открытия модер меню", Order = 9)]
            public string comandmoder;

            [JsonProperty(PropertyName = "Сообщения в титле", Order = 10)]
            public string teatletxt;
        }

        public class VKontakte
        {
            [JsonProperty(PropertyName = "Используем Вконтакте:", Order = 0)]
            public bool UseVK;

            [JsonProperty(PropertyName = "ID Беседы ВК для бота:", Order = 1)]
            public string VK_ChatID;

            [JsonProperty(PropertyName = "Token Группы ВК:", Order = 2)]
            public string VK_Token;
        }
        public class Discord
        {
            [JsonProperty(PropertyName = "Используем Discord:", Order = 0)]
            public bool UseDiscord;

            [JsonProperty(PropertyName = "Webhook Discrod:", Order = 1)]
            public string Discord_webHook;
        }

        protected override void LoadDefaultConfig()
        {
            config = new Configuration()
            {
                vKontakte = new VKontakte()
                {
                    UseVK = false,
                    VK_ChatID = "ChatID",
                    VK_Token = "VKToken",
                },
                discord = new Discord()
                {
                    Discord_webHook = "webHook",
                    UseDiscord = false,
                },
                setting = new Setting()
                {
                    avatarid = 76561198854646370,
                    prefix = "SkyReportSystem",
                    maxreportcall = 4,
                    usemodercall = true,
                    uselog = false,
                    Cooldown = 360,
                    servername = "Server Name",
                    comandplayer = "report",
                    comandmoder = "reportm",
                    teatletxt = "ReportSystem by DezLife"

                },
                isafk = new IsAfk()
                {
                    usecheckafk = false,
                    timecheckisafk = 15f,
                },
                banReasons = new List<BanReasons>()
                {
                    new BanReasons
                    {
                         BanReason = "Читы",
                         BanReasonCommand = "ban {0} 999d Soft",
                    },
                    new BanReasons
                    {
                         BanReason = "Макросы",
                         BanReasonCommand = "ban {0} 30d Macros",
                    },
                    new BanReasons
                    {
                         BanReason = "Превышение максимальной численности игроков в команде",
                         BanReasonCommand = "ban {0} 14d 3+",
                    },
                    new BanReasons
                    {
                         BanReason = "Отказ от проверки",
                         BanReasonCommand = "ban {0} 7d Otkaz",
                    },
                    new BanReasons
                    {
                         BanReason = "Другое",
                         BanReasonCommand = "ban {0} 999d 5",
                    },
                },
                Reasonsforcomplaint = new List<string>
                {
                    "3+",
                    "Подозрения в читах",
                    "Макросы",
                    "Реклама в нике",
                    "Спам в чат",
                    "Обман игроков",
                    "Багоюз",
                    "Токсик",
                }

            };
            SaveConfig(config);
        }

        void SaveConfig(Configuration config)
        {
            Config.WriteObject(config, true);
            SaveConfig();
        }

        public void LoadConfigVars()
        {
            config = Config.ReadObject<Configuration>();
            Config.WriteObject(config, true);
        }
        #endregion

        #region data

        public Dictionary<ulong, ReportUser> ReportData = new Dictionary<ulong, ReportUser>();

        public class ReportUser
        {
            public int ReportCount;
            public int CheckCount;
            public List<string> complaint = new List<string>();
        }
        #endregion

        #region Lang

        protected override void LoadDefaultMessages()
        {
            Dictionary<string, string> Lang = new Dictionary<string, string>
            {
                ["SKY_REPORT_REPORTING"] = "Вы успешно отправили репорт на игрока {0}",
                ["SKY_REPORT_REPORTING_VK_DISCORD"] = "=====================================================\nСервер : {0}\nИгрок : {1} пожаловался на {2} [{3}]\nПричина : {4}",
                ["SKY_REPORT_MAXIMUM_REPORT"] = "Игрок: {0} " +
                " Превысил максимальное количевство репортов!" +
                "Его колличевство {1}",
                ["SKY_COLDOWN"] = "Вы недавно отправляли жалобу,подождите еще немного",
                ["SKY_ERROR_PLAYER"] = "Вы жалуетесь сами на себя!",
                ["SKY_PLAYER_PERMISSION_IS_FOUND"] = "У вас недостаточно прав для использования данной команды!",
                ["SKY_NO_CHECK_MODERATION_OR_CHECKING"] = "Вы не можете вызвать игрока {0} на проверку,т.к его проверяет другой модератор",
                ["SKY_ACESS_CHECKING"] = "Вы вызвали игрока {0} на проверку",
                ["SKY_MODER_CHECK_PLAYER_GOING"] = "=====================================================\nМодератор {0} вызвал на проверку игрока {1}[{2}]",
                ["SKY_MODER_CHECK_PLAYER_GOING_CONSOLE"] = "=====================================================\nИгрок {1}[{2}] был вызван с помощью консоли",
                ["SKY_PLAYER_IS_AFK_VK_DISCORD_OK"] = "=====================================================\nИгрок: {0}  двигался с момента последней проверки на AFK",
                ["SKY_PLAYER_IS_AFK_VK_DISCORD_NO"] = "=====================================================\nИгрок: {0} не двигался с момента последней проверки на AFK",
                ["SKY_PLAYER_IS_AFK_OK"] = "Игрок: <color=orange>{0}</color> двигался с момента последней проверки на AFK",
                ["SKY_PLAYER_IS_AFK_NO"] = "Игрок: <color=orange>{0}</color> не двигался с момента последней проверки на AFK",
                ["SKY_MODERATOR_STOPID_CHEKING"] = "Вы успешно закончили проверку над игроком : {0} !",
                ["SKY_PLAYER_STOPID_CHEKING"] = "Проверка успешно окончена. \nПроверял модератор {0} !",
                ["SKY_PLAYER_CHECKING_MODER_MENU_MODERATION"] = "Игрок проверяется модератором",
                ["SKY_PLAYER_NOTHING_MESSAGE_SKYPE_DISCORD"] = "Вы ничего не ввели!",
                ["SKY_MODER_CHECK_P_SKYPE"] = "Вы предоставили свой Skype : {0}",
                ["SKY_MODER_CHECK_P_DISCORD"] = "Вы предоставили свой Discord : {0}",
                ["SKY_Menu_Info"] = "В данном окне вам нужно выбрать игрока из списка или ввести его ник в поле ниже что бы оставить на него жалобу",
                ["SKY_SKYPE_MESSAGE"] =
                                           "=====================================================\n" +
                                           "Сервер : {0}\n" +
                                           "Игровой ник: {1}\n" +
                                           "Steam ID: {2}\n" +
                                           "Предоставил Skype на проверку : {3}",
                ["SKY_DISCORD_MESSAGE"] =
                                           "=====================================================\n" +
                                           "Сервер : {0}\n" +
                                           "Игровой ник: {1}\n" +
                                           "Steam ID: {2}\n" +
                                           "Предоставил Discord на проверку : {3}",
                ["SKY_SKYPE_DISCORD_ERROR"] = "Вас должны вызвать на проверку,перед тем,как отправлять данные",
                ["SKY_REPORT_VK_DISCORD_MAXIMUM_BLACK"] =
                                           "=====================================================\n" +
                                           "Сервер : {0}\n" +
                                           "Достигнут предел жалоб на игрока!\n" +
                                           "Игровой ник: {1}\n" +
                                           "Steam ID: {2}\n" +
                                           "Информация о подозрительном игроке:\n" +
                                           "Игрок проверялся: {3} раз(-а)\n" +
                                           "Стим: https://steamcommunity.com/profiles/{4}",
                ["SKY_CHECK_STOP"] =
                                           "=====================================================\n" +
                                           "Сервер : {0}\n" +
                                           "Модератор {1} окончил проверку над игроком {2} [{3}]\n",
                ["SKY_CHECK_STOP_CONSOLE"] =
                                           "=====================================================\n" +
                                           "Сервер : {0}\n" +
                                           "Проверка окончена над игроком {2} [{3}]\n",
                ["BAN_USER_VK_DISCORD"] =
                                           "=====================================================\n" +
                                           "Игрок :{0}({1})\n" +
                                           "Был забанен на сервере({2}) по причине {3} Модератором {4}\n",
            };
            lang.RegisterMessages(Lang, this);
            PrintWarning("Языковой файл загружен успешно");

        }
        #endregion

        #region Hooks

        private void OnServerInitialized()
        {
            LoadConfigVars();
            if (!ImageLibrary)
            {
                PrintError("Не найден ImageLibrary, плагин не будет работать!");
                return;
            }
            #region Permission
            permission.RegisterPermission("SkyReportSystem.moderator", this);
            permission.RegisterPermission("SkyReportSystem.ban", this);
            #endregion

            #region DataLoad
            LoadData("ReportData", ref ReportData, true);

            for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
                OnPlayerConnected(BasePlayer.activePlayerList[i]);
            #endregion


            cmd.AddChatCommand(config.setting.comandplayer, this, nameof(ReportMenu));
            cmd.AddChatCommand(config.setting.comandmoder, this, nameof(modermenu));

            if (config.setting.servername == "Server Name")
            {
                PrintWarning("Вы не указали названия сервера, плагин будет работать некорректно!");
            }

            PrintError($"-----------------------------------");
            PrintError($"           SkyReportSystem         ");
            PrintError($"          Author = DezLife         ");
            PrintError($"          Version = {Version}      ");
            PrintError($"-----------------------------------");
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (!ReportData.ContainsKey(player.userID))
            {
                ReportUser NewUser = new ReportUser()
                {
                    ReportCount = 0,
                    CheckCount = 0,
                    complaint = new List<string> { }
                };
                ReportData.Add(player.userID, NewUser);
            }
            if (CheckPlayerModeration.ContainsKey(player.userID))
            {
                BasePlayer players = BasePlayer.FindByID(CheckPlayerModeration[player.userID]);
                if (players != null)
                {
                    SendChat(players, "Вызываемый игрок покинул сервер!");
                }
                else
                {
                    PrintWarning("Вызываемый игрок покинул сервер!");
                }
                BanPlayer.Remove(player.userID);
            }
        }

        void Unload()
        {
            SaveData("ReportData", ReportData);
            for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                var p = BasePlayer.activePlayerList[i];
                CuiHelper.DestroyUi(p, mainskymenu);
                CuiHelper.DestroyUi(p, ModerMenuSky);
                CuiHelper.DestroyUi(p, ModerAlert);
            }
        }

        #endregion

        #region Metods

        private void ReportActivity(BasePlayer reportplayer, BasePlayer target, string reason)
        {
            if (ReportData[target.userID].ReportCount >= config.setting.maxreportcall && target.userID != reportplayer.userID)
            {
                SendChatMessage("SKY_REPORT_VK_DISCORD_MAXIMUM_BLACK", config.setting.servername, target.displayName, target.userID, ReportData[target.userID].CheckCount, target.userID);
            }
            if (config.discord.UseDiscord == true && ReportData[target.userID].ReportCount >= config.setting.maxreportcall && target.userID != reportplayer.userID)
            {
                SendDiscordMsg("SKY_REPORT_VK_DISCORD_MAXIMUM_BLACK", config.setting.servername, target.displayName, target.userID, ReportData[target.userID].CheckCount, target.userID);
            }
            if (config.setting.uselog == true && ReportData[target.userID].ReportCount >= config.setting.maxreportcall && target.userID != reportplayer.userID)
            {
                LogToFile("SkyReportSystemLOG", $"На игрока <color=#816AD0>{target.displayName}</color> пожаловался <color=#816AD0>{reportplayer.displayName}</color>\n" +
                            $"<size=12>Причина: {reason} </size>", this);
            }
        }

        #endregion

        #region Parent
        public static string mainskymenu = "MAIN_MENU_PLAYER";
        public static string ModerMenuSky = "MAIN_MENU_MODER";
        public static string PlayerAlert = "MAIN_MENU_alert";
        public static string ModerAlert = "MAIN_moder_alert";
        #endregion

        #region commands

        private void ReportMenu(BasePlayer player)
        {
            SkyReportPlayers(player);
        }

        [ConsoleCommand("reportplayer")]
        private void cmdreportplayer(ConsoleSystem.Arg args)
        {
            SkyReportPlayers(args.Player());
        }

        [ConsoleCommand("players")]
        private void cmdreportplayerConsole(ConsoleSystem.Arg args)
        {
            if (args.Args == null || args.Args.Length == 0 || args.Args.Length < 2)
            {
                PrintWarning($"Неверный синтаксис, используйте players check/uncheck StemId64");
                return;
            }

            BasePlayer player = BasePlayer.FindByID(ulong.Parse(args.Args[1]));
            if (player == null) { PrintWarning("Игрока нет на сервере!"); return; };

            switch (args.Args[0].ToLower())
            {
                case "check":
                    {
                        CheckPlayerModeration.Add(player.userID, player.userID);
                        PrintWarning($"Вы вызвали игрока {player.displayName} на проверку");
                        SendDiscordMsg("SKY_MODER_CHECK_PLAYER_GOING_CONSOLE", player.displayName, player.userID);
                        SendChatMessage("SKY_MODER_CHECK_PLAYER_GOING_CONSOLE", player.displayName, player.userID);


                        if (config.isafk.usecheckafk == true)
                        {
                            timer.Repeat(config.isafk.timecheckisafk, 3, () =>
                            {
                                if (!IsPlayerAfk(player))
                                {
                                    SendDiscordMsg("SKY_PLAYER_IS_AFK_VK_DISCORD_OK", player.displayName);

                                    SendChatMessage("SKY_PLAYER_IS_AFK_VK_DISCORD_OK", player.displayName);
                                    PrintWarning(String.Format(lang.GetMessage("SKY_PLAYER_IS_AFK_OK", this), player.displayName));
                                }
                                else
                                {
                                    SendDiscordMsg("SKY_PLAYER_IS_AFK_VK_DISCORD_NO", player.displayName);

                                    SendChatMessage("SKY_PLAYER_IS_AFK_VK_DISCORD_NO", player.displayName);
                                    PrintWarning(String.Format(lang.GetMessage("SKY_PLAYER_IS_AFK_NO", this), player.displayName));
                                }
                            });
                        }
                        AlertPlayerCheck(player, player);
                        break;
                    }
                case "uncheck":
                    {
                        if (CheckPlayerModeration.ContainsKey(player.userID))
                        {
                            CheckPlayerModeration.Remove(player.userID);

                            CuiHelper.DestroyUi(player, PlayerAlert);

                            PrintWarning(String.Format(lang.GetMessage("SKY_MODERATOR_STOPID_CHEKING", this), player.displayName));
                            SendDiscordMsg("SKY_CHECK_STOP_CONSOLE", config.setting.servername, player.displayName, player.userID);
                            SendChatMessage("SKY_CHECK_STOP_CONSOLE", config.setting.servername, player.displayName, player.userID);

                            ReportData[player.userID].ReportCount = 0;
                            ReportData[player.userID].CheckCount++;
                        }
                        else
                        {
                            PrintWarning("Этого игрока не вызывали на проверку!");
                        }
                        break;
                    }
            }

        }

        private void modermenu(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, "SkyReportSystem.moderator") || player.IsAdmin)
            {
                SkyModerMenu(player);
            }
            else
            {
                SendChat(player, String.Format(lang.GetMessage("SKY_PLAYER_PERMISSION_IS_FOUND", this)));
            }
        }

        [ConsoleCommand("moderreport")]
        private void cmdreportmenu(ConsoleSystem.Arg args)
        {
            if (permission.UserHasPermission(args.Player().UserIDString, "SkyReportSystem.moderator") || args.Player().IsAdmin)
            {
                SkyModerMenu(args.Player());
            }
            else
            {
                SendChat(args.Player(), String.Format(lang.GetMessage("SKY_PLAYER_PERMISSION_IS_FOUND", this)));
            }
        }

        [ConsoleCommand("closeui")]
        void closeuimain(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            CuiHelper.DestroyUi(player, mainskymenu);
            CuiHelper.DestroyUi(player, "buttoncap");
            CuiHelper.DestroyUi(player, ModerMenuSky);
            CuiHelper.DestroyUi(player, PlayerAlert);
            CuiHelper.DestroyUi(player, ModerAlert);
        }

        [ChatCommand("discord")]
        void discordaccess(BasePlayer player, string cmd, string[] Args)
        {
            if (Args == null || Args.Length == 0)
            {
                SendChat(player, lang.GetMessage("SKY_PLAYER_NOTHING_MESSAGE_SKYPE_DISCORD", this));
                return;
            }

            if (CheckPlayerModeration.ContainsKey(player.userID))
            {
                string Discord = "";
                foreach (var arg in Args)
                {
                    Discord += " " + arg;
                }
                SendChatMessage("SKY_DISCORD_MESSAGE", config.setting.servername, player.displayName, player.UserIDString, Discord);
                SendDiscordMsg("SKY_DISCORD_MESSAGE", config.setting.servername, player.displayName, player.UserIDString, Discord);
                BasePlayer moderator = FindPlayer(CheckPlayerModeration[player.userID].ToString());
                if (player == moderator) { }
                else
                {
                    SendChat(moderator, String.Format(lang.GetMessage("SKY_DISCORD_MESSAGE", this), config.setting.servername, player.displayName, player.UserIDString, Discord));
                    SendChat(player, String.Format(lang.GetMessage("SKY_MODER_CHECK_P_DISCORD", this), Discord));
                }

            }
            else { SendChat(player, lang.GetMessage("SKY_SKYPE_DISCORD_ERROR", this)); }
        }

        [ConsoleCommand("openinfoplayer")]
        void consolego(ConsoleSystem.Arg args)
        {
            if (!args.HasArgs(2)) return;

            BasePlayer targetPlayer = BasePlayer.FindByID(ulong.Parse(args.Args[1]));

            BasePlayer player = args.Player();
            bool CanUse = permission.UserHasPermission(player.UserIDString, "SkyReportSystem.moderator") || player.IsAdmin;
            if (!CanUse) return;
            if (args.Args[0].ToLower() == "chooseplayers")
            {
                if (CanUse)
                {
                    playerinfomenu(player, args.Args[1], targetPlayer);
                }
                else
                {
                    SendChat(player, String.Format(lang.GetMessage("SKY_PLAYER_PERMISSION_IS_FOUND", this)));
                }
            }
            if (args.Args[0].ToLower() == "checkinplayer")
            {
                if (CheckPlayerModeration.ContainsKey(targetPlayer.userID))
                {
                    SendChat(player, String.Format(lang.GetMessage("SKY_NO_CHECK_MODERATION_OR_CHECKING", this), targetPlayer.displayName));
                }
                else
                {
                    if (CanUse)
                    {
                        CheckPlayerModeration.Add(targetPlayer.userID, args.Player().userID);
                        SendChat(player, String.Format(lang.GetMessage("SKY_ACESS_CHECKING", this), targetPlayer.displayName));
                        SendDiscordMsg("SKY_MODER_CHECK_PLAYER_GOING", player.displayName, targetPlayer.displayName, targetPlayer.userID);
                        SendChatMessage("SKY_MODER_CHECK_PLAYER_GOING", player.displayName, targetPlayer.displayName, targetPlayer.userID);


                        if (config.isafk.usecheckafk == true)
                        {
                            timer.Repeat(config.isafk.timecheckisafk, 3, () =>
                            {
                                if (!IsPlayerAfk(targetPlayer))
                                {
                                    SendDiscordMsg("SKY_PLAYER_IS_AFK_VK_DISCORD_OK", targetPlayer.displayName);

                                    SendChatMessage("SKY_PLAYER_IS_AFK_VK_DISCORD_OK", targetPlayer.displayName);
                                    SendChat(args.Player(), String.Format(lang.GetMessage("SKY_PLAYER_IS_AFK_OK", this), targetPlayer.displayName));
                                }
                                else
                                {
                                    SendDiscordMsg("SKY_PLAYER_IS_AFK_VK_DISCORD_NO", targetPlayer.displayName);

                                    SendChatMessage("SKY_PLAYER_IS_AFK_VK_DISCORD_NO", targetPlayer.displayName);
                                    SendChat(args.Player(), String.Format(lang.GetMessage("SKY_PLAYER_IS_AFK_NO", this), targetPlayer.displayName));
                                }
                            });
                        }
                        AlertPlayerCheck(BasePlayer.FindByID(targetPlayer.userID), player);
                        CuiHelper.DestroyUi(player, ModerMenuSky);
                    }
                    else
                    {
                        SendChat(player, String.Format(lang.GetMessage("SKY_PLAYER_PERMISSION_IS_FOUND", this)));
                    }
                }
            }

            if (args.Args[0] == "stopcheckingplayers")
            {
                if (CanUse)
                {
                    CheckPlayerModeration.Remove(targetPlayer.userID);

                    CuiHelper.DestroyUi(targetPlayer, PlayerAlert);
                    CuiHelper.DestroyUi(player, ModerMenuSky);
                    SendChat(player, String.Format(lang.GetMessage("SKY_MODERATOR_STOPID_CHEKING", this), targetPlayer.displayName));
                    SendChat(targetPlayer, String.Format(lang.GetMessage("SKY_PLAYER_STOPID_CHEKING", this), args.Player().displayName));
                    SendDiscordMsg("SKY_CHECK_STOP", config.setting.servername, args.Player().displayName, targetPlayer.displayName, targetPlayer.userID);
                    SendChatMessage("SKY_CHECK_STOP", config.setting.servername, args.Player().displayName, targetPlayer.displayName, targetPlayer.userID);

                    ReportData[targetPlayer.userID].ReportCount = 0;
                    ReportData[targetPlayer.userID].CheckCount++;
                }
                else
                {
                    SendChat(player, String.Format(lang.GetMessage("SKY_PLAYER_PERMISSION_IS_FOUND", this)));
                }
            }

            if (args.Args[0] == "moderatorcheckbanreason")
            {
                PlayerBanIPlayerModeration(player, BasePlayer.FindByID(targetPlayer.userID));
            }
        }

        [ConsoleCommand("Banplayers")]
        void ReportSystemBanReason(ConsoleSystem.Arg arg)
        {
            rust.RunClientCommand(arg.Player(), String.Format(config.banReasons[Convert.ToInt32(arg.Args[1])].BanReasonCommand, arg.Args[0]));
            CuiHelper.DestroyUi(arg.Player(), ModerMenuSky);
            BasePlayer player = BasePlayer.Find(arg.Args[0]);
            BasePlayer moderator = arg.Player();
            ReportData[player.userID].ReportCount = 0;
            string BanReason = $"{String.Format(config.banReasons[Convert.ToInt32(arg.Args[1])].BanReason, arg.Args[0])}";

            SendChatMessage("BAN_USER_VK_DISCORD", player.displayName, player.UserIDString, config.setting.servername, BanReason, moderator.displayName);
            SendDiscordMsg("BAN_USER_VK_DISCORD", player.displayName, player.UserIDString, config.setting.servername, BanReason, moderator.displayName);

            BanPlayer.Add(player.userID);

        }
        public List<ulong> BanPlayer = new List<ulong>();

        #region MetodsCooldown
        public Dictionary<ulong, int> CooldownPC = new Dictionary<ulong, int>();

        static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        static double CurrentTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;
        void Metods_GiveCooldown(ulong ID, int cooldown)
        {
            CooldownPC[ID] = cooldown + (int)CurrentTime();
        }

        bool Metods_GetCooldown(ulong ID)
        {
            if (!CooldownPC.ContainsKey(ID) || Math.Max(0, CooldownPC[ID]) < 1 || CooldownPC[ID] <= (int)CurrentTime())
                return false;
            else return true;
        }

        #endregion

        [ConsoleCommand("SkyReportGo")]
        private void PlayerReportSystem(ConsoleSystem.Arg args)
        {
            string ReasonReport = "";
            if (args.Args.Length == 0)
            {
                SkyReportPlayers(args.Player());
                return;
            }
            if (args.Args[0] == "chooseplayers")
            {
                SkyReportPlayers(args.Player(), args.Args[1]);
                return;
            }
            if (args.Args[0].Length != 17)
            {
                for (int t = 0; t < 44; t++)
                {
                    CuiHelper.DestroyUi(args.Player(), "Button" + $".ChoosePlayer.{t}");
                    CuiHelper.DestroyUi(args.Player(), "Button" + $".ChoosePlayer.{t}.Text");
                }
                SkyReportPlayers(args.Player(), args.Args[0]);
                return;
            }
            if (args.Args.Length >= 2)
            {
                int ReasonIndex = int.Parse(args.Args[1]);
                ReasonReport = config.Reasonsforcomplaint[ReasonIndex];
                BasePlayer target = BasePlayer.Find(args.Args[0]);
                ReportActivity(args.Player(), target, ReasonReport);


                if (args.Player() != target)
                {
                    if (Metods_GetCooldown(args.Player().userID) == true)
                    {
                        SendChat(args.Player(), lang.GetMessage("SKY_COLDOWN", this));
                        return;
                    }
                    ReportData[target.userID].ReportCount++;


                    ReportData[target.userID].complaint.Insert(0, ReasonReport);
                    SendChat(args.Player(), String.Format(lang.GetMessage("SKY_REPORT_REPORTING", this), target.displayName));
                    SendDiscordMsg("SKY_REPORT_REPORTING_VK_DISCORD", config.setting.servername, args.Player().displayName, target.displayName, target.userID, ReasonReport);
                    SendChatMessage("SKY_REPORT_REPORTING_VK_DISCORD", config.setting.servername, args.Player().displayName, target.displayName, target.userID, ReasonReport);
                    Metods_GiveCooldown(args.Player().userID, config.setting.Cooldown);
                    if (ReportData[target.userID].ReportCount > config.setting.maxreportcall)
                    {
                        if (config.setting.usemodercall == true)
                        {
                            for (int u = 0; u < BasePlayer.activePlayerList.Count; u++)
                            {
                                BasePlayer player = BasePlayer.activePlayerList[u];
                                if (permission.UserHasPermission(player.UserIDString, "SkyReportSystem.moderator"))
                                {
                                    SendChat(player, String.Format(lang.GetMessage("SKY_REPORT_MAXIMUM_REPORT", this), target, ReportData[target.userID].ReportCount));
                                    ModerAlertCheck(player, target);
                                    timer.Once(5f, () => { CuiHelper.DestroyUi(player, ModerAlert); });
                                }
                            }
                        }
                        if (config.setting.uselog == true)
                        {
                            LogToFile("SkyReportSystemLOG", $"Игрок {target} превысил максимальное количество репортов! [{ReportData[target.userID].ReportCount}]", this);
                        }
                        return;
                    }

                }
                else
                {
                    SendChat(args.Player(), lang.GetMessage("SKY_ERROR_PLAYER", this));
                }
                return;
            }
        }
        #endregion

        #region cui

        private void PlayerBanIPlayerModeration(BasePlayer player, BasePlayer targetinfoban)
        {
            CuiHelper.DestroyUi(player, "BanMunuReason");
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.168753 0.1509259", AnchorMax = "0.6302084 0.3185185" },
                Image = { FadeIn = 1f, Color = HexToCuiColor("#00000064") }
            }, "InfoPlayerSky", "BanMunuReason");

            #region BanReasonPanel


            for (int U = 0, x = 0, y = 0, i = 0; U < config.banReasons.Count; U++)
            {
                var reason = config.banReasons[U];
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{0.005902235 + (x * 0.33)} {0.6906075 - (y * 0.31)}", AnchorMax = $"{0.3318241 + (x * 0.33)} {0.9613256 - (y * 0.31)}" },
                    Button = { Command = $"Banplayers {targetinfoban.userID} {i}", Color = HexToCuiColor("#000000B2") },
                    Text = { Text = reason.BanReason, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 16 }
                }, "BanMunuReason");
                x++; i++;
                if (x == 3)
                {
                    x = 0;
                    y++;
                }

            }
            #endregion

            CuiHelper.AddUi(player, container);
        }

        private void ModerAlertCheck(BasePlayer player, BasePlayer target)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, ModerAlert);

            container.Add(new CuiPanel
            {
                FadeOut = 0.1f,
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "1 -150", OffsetMax = "230 -60" },
                Image = { Color = "0 0 0 0", FadeIn = 0.3f }
            }, "Overlay", ModerAlert);

            container.Add(new CuiElement
            {
                Parent = ModerAlert,
                Name = "AlerModer",
                FadeOut = 0.1f,
                Components =
                    {
                        new CuiImageComponent {  Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.3", Sprite = "assets/content/ui/ui.background.transparent.radial.psd", FadeIn = 0.3f  },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
            });

            container.Add(new CuiLabel
            {
                FadeOut = 0.1f,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Text = { Text = $"Игрок: {target.displayName}\nПревысил максимальное количевство жалоб! ", FontSize = 18, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = 0.3f }
            }, "AlerModer");

            CuiHelper.AddUi(player, container);

        }

        private void AlertPlayerCheck(BasePlayer player, BasePlayer moderinformation)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, PlayerAlert);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-200 150", OffsetMax = "180 300" },
                Image = { Color = "0 0 0 0" }
            }, "Overlay", PlayerAlert);

            container.Add(new CuiElement
            {
                Parent = PlayerAlert,
                Name = "MainAlert",
                Components =
                    {
                        new CuiImageComponent {  Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.5", Sprite = "assets/content/ui/ui.background.transparent.radial.psd"  },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.7644448", AnchorMax = "1 1", OffsetMax = "0 0" },
                Text = { Text = "Вас вызвали на проверку", FontSize = 19, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, "MainAlert");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.6311106", AnchorMax = "1 0.7422219", OffsetMax = "0 0.764444" },
                Text = { Text = "Вы обязаны предоставить Skype или Discord!", FontSize = 15, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, "MainAlert");

            if (player.userID == moderinformation.userID)
            {
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.0684208 0.05777803", AnchorMax = "0.9087719 0.6266667", OffsetMax = "0 0" },
                    Text = { Text = $"Kоманды :\n<color=orange>/skype</color> \n<color=orange>/discord</color>\nВызвавший модератор : НЕИЗВЕСТНО", FontSize = 17, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, "MainAlert");
            }
            else
            {
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.0684208 0.057778234", AnchorMax = "0.9087719 0.6266667", OffsetMax = "0 0" },
                    Text = { Text = $"Kоманды :\n<color=orange>/skype</color> \n<color=orange>/discord</color>\nВызвавший модератор : {moderinformation.displayName}", FontSize = 17, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, "MainAlert");
            }


            CuiHelper.AddUi(player, container);
        }

        private void SkyModerMenu(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, ModerMenuSky);
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = "0 0 0 0" }
            }, "Hud", ModerMenuSky);

            container.Add(new CuiElement
            {
                Parent = ModerMenuSky,
                Components =
                    {
                        new CuiImageComponent {   Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat",  Color = HexToCuiColor("#00000069")   },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "-100 -100", AnchorMax = "100 100" },
                Button = { Close = ModerMenuSky, Color = "0 0 0 0" },
                Text = { Text = "" }
            }, ModerMenuSky);

            #region title
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.2796874 0.9157416", AnchorMax = "0.7052073 0.968505" },
                Image = { Color = HexToCuiColor("#00000064") }
            }, ModerMenuSky, "TitlePanel");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Text = { Text = "Меню Модератора!", FontSize = 18, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, "TitlePanel");

            #endregion

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.2302083 0.2972222", AnchorMax = "0.7557291 0.8268524" },
                Image = { Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat", Color = HexToCuiColor("#423A3898") }
            }, ModerMenuSky, "MainPanelModer");

            container.Add(new CuiElement
            {
                Name = "playerlisd",
                Parent = "MainPanelModer",
                Components =
                    {
                        new CuiImageComponent { Color = "0 0 0 0" },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
            });

            #region PlayerList

            for (int x = 0, y = 0, i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                var mplayer = BasePlayer.activePlayerList[i];
                if (mplayer == null || !ReportData.ContainsKey(mplayer.userID) || mplayer.userID == player.userID) continue;
                if (ReportData[mplayer.userID].ReportCount >= config.setting.maxreportcall)
                {
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = $"{0.01333263 + (x * 0.245)} {0.9033457 - (y * 0.090)}", AnchorMax = $"{0.252307 + (x * 0.245)} {0.9758366 - (y * 0.090)}" },
                        Button = { Command = $"openinfoplayer chooseplayers {mplayer.userID}", Color = HexToCuiColor("#000000B2") },
                        Text = { Text = $"({mplayer.displayName})" + " [" + ReportData[mplayer.userID].ReportCount + "]", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 16 }
                    }, "playerlisd", "playerlisd" + $".Player.{i}.Text");

                    x++;
                    if (x == 4)
                    {
                        x = 0;
                        y++;

                        if (y == 11)
                        {
                            break;
                        }
                    }
                }
            }
            #endregion

            CuiHelper.AddUi(player, container);
        }

        private void playerinfomenu(BasePlayer player, string target, BasePlayer targetinfocheck)
        {
            #region SupportMetods
            string ImageAvatar = GetImage(target, 0);
            #endregion
            BasePlayer targets = BasePlayer.FindByID(ulong.Parse(target));
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, "MainPanelModer");


            container.Add(new CuiPanel
            {
                FadeOut = 0.5f,
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { FadeIn = 0.5f, Color = "0 0 0 0" },
            }, ModerMenuSky, "InfoPlayerSky");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "-100 -100", AnchorMax = "100 100" },
                Button = { Close = ModerMenuSky, Color = "0 0 0 0" },
                Text = { Text = "" }
            }, "InfoPlayerSky");



            container.Add(new CuiElement
            {
                Parent = "InfoPlayerSky",
                Components = {
                    new CuiRawImageComponent {
                        Png = ImageAvatar,
                        Url = null ,
                        Sprite = "assets/content/textures/generic/fulltransparent.tga"
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0.16875 0.5842593",
                        AnchorMax = "0.3151042 0.8796296"
                    },
                }
            });


            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.3229166 0.8203703", AnchorMax = "0.5739583 0.8740742" },
                Text = { Text = $"{targets.displayName} ({targets.UserIDString})", FontSize = 22, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "InfoPlayerSky");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.3203125 0.7574074", AnchorMax = "0.5020834 0.8037037" },
                Text = { Text = $"Количевство репортов: {ReportData[targetinfocheck.userID].ReportCount}", FontSize = 15, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "InfoPlayerSky");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.3203126 0.7101846", AnchorMax = "0.4828126 0.7564811" },
                Text = { Text = $"Количевство проверок: {ReportData[targetinfocheck.userID].CheckCount}", FontSize = 15, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "InfoPlayerSky");

            container.Add(new CuiPanel
            {
                FadeOut = 0.5f,
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0.6703124 0.462963", AnchorMax = "0.8505208 0.8925924" },
                Image = { FadeIn = 0.5f, Color = HexToCuiColor("#0000006E"), },
            }, "InfoPlayerSky", "captain");

            container.Add(new CuiElement
            {
                Parent = "captain",
                Components =
                    {
                        new CuiImageComponent { Color = HexToCuiColor("#FFFFFFFF") },
                        new CuiRectTransformComponent { AnchorMin = "0 0.886463", AnchorMax = "1 0.8886465" }
                    }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.03468214 0.8995634", AnchorMax = "0.9624277 0.9825329" },
                Text = { Text = "Последнии жалобы", FontSize = 16, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, "captain");

            int i = 0;
            for (int j = 0; j < ReportData[targets.userID].complaint.Count; j++)
            {
                var captainlist = ReportData[targets.userID].complaint[j];

                if (i <= 7)
                {
                    container.Add(new CuiElement
                    {
                        Parent = "captain",
                        Name = "listcap",
                        Components =
                        {
                            new CuiImageComponent { Color = HexToCuiColor("#FF7575BB"), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                            new CuiRectTransformComponent { AnchorMin =  $"0.0231214 {0.7758622 - (i * 0.107)}", AnchorMax = $"0.9739881 {0.8668124 - (i * 0.107)}" }
                        }
                    });

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                        Text = { Text = captainlist, FontSize = 17, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                    }, "listcap");
                    i++;
                }
                else
                {
                    break;
                }
            }

            if (!CheckPlayerModeration.ContainsKey(targetinfocheck.userID))
            {
                CuiHelper.DestroyUi(player, "StopPlayerBtn");
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.16875 0.5018519", AnchorMax = "0.315625 0.5722228" },
                    Button = { Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat", Color = HexToCuiColor("#33302F98"), Command = $"openinfoplayer checkinplayer {targetinfocheck.userID}" },
                    Text = { Text = "Bызвать на проверку", FontSize = 14, Align = TextAnchor.MiddleCenter }
                }, "InfoPlayerSky", "CheckPlayerBtn");
            }
            else if (CheckPlayerModeration.ContainsKey(targetinfocheck.userID) && CheckPlayerModeration.ContainsValue(player.userID) || player.IsAdmin)
            {
                CuiHelper.DestroyUi(player, "CheckPlayerBtn");
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.1686849 0.427109", AnchorMax = "0.315625 0.4972244" },
                    Button = { Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat", Color = HexToCuiColor("#33302F98"), Command = $"openinfoplayer stopcheckingplayers {targetinfocheck.userID}" },
                    Text = { Text = "Закончить проверку", FontSize = 14, Align = TextAnchor.MiddleCenter }
                }, "InfoPlayerSky", "StopPlayerBtn");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.1686849 0.351852", AnchorMax = "0.3156251 0.4224281" },
                    Button = { Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat", Color = HexToCuiColor("#33302F98"), Command = $"openinfoplayer moderatorcheckbanreason {targetinfocheck.userID}" },
                    Text = { Text = "Выдать блокировку", FontSize = 14, Align = TextAnchor.MiddleCenter }
                }, "InfoPlayerSky", "GoBanned");
            }
            else
            {
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.325 0.6064815", AnchorMax = "0.6682292 0.6990741", OffsetMax = "0 0" },
                    Text = { Text = String.Format(lang.GetMessage("SKY_PLAYER_CHECKING_MODER_MENU_MODERATION", this)), FontSize = 20, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, "InfoPlayerSky");
            }

            CuiHelper.AddUi(player, container);
        }

        private void SkyReportPlayers(BasePlayer player, string target = "", string reason = "")
        {
            CuiElementContainer container = new CuiElementContainer();

            if (target == "" && reason == "")
            {

                CuiHelper.DestroyUi(player, mainskymenu);

                container.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Image = { Color = "0 0 0 0" }
                }, "Hud", mainskymenu);

                container.Add(new CuiElement
                {
                    Parent = mainskymenu,
                    Components =
                    {
                        new CuiImageComponent { Color = HexToCuiColor("#000000B1") },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "-100 -100", AnchorMax = "100 100" },
                    Button = { Close = mainskymenu, Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, mainskymenu);


                #region title
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0.2796874 0.9157416", AnchorMax = "0.7052073 0.968505" },
                    Image = { Color = HexToCuiColor("#00000064") }
                }, mainskymenu, "TitlePanel");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Text = { Text = config.setting.teatletxt, FontSize = 18, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, "TitlePanel");

                #endregion

                #region infotxt

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.2322917 0.8472127", AnchorMax = "0.7520834 0.9027551" },
                    Text = { Text = lang.GetMessage("SKY_Menu_Info", this), FontSize = 17, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, mainskymenu);

                #endregion

                #region input

                container.Add(new CuiElement
                {
                    Parent = mainskymenu,
                    Name = mainskymenu + ".Input",
                    Components =
                    {
                        new CuiImageComponent { Color = HexToCuiColor("#423a38")},
                        new CuiRectTransformComponent { AnchorMin = "0.2385417 0.7777631", AnchorMax = "0.7458333 0.821279" },
                        new CuiOutlineComponent{Distance = "1.2 1.2", Color = HexToCuiColor("#FFFFFFFF"), UseGraphicAlpha = false}

                    }
                });

                container.Add(new CuiElement
                {
                    Parent = mainskymenu + ".Input",
                    Name = mainskymenu + ".Input.Current",
                    Components =
                    {
                        new CuiInputFieldComponent { FontSize = 16, Align = TextAnchor.MiddleCenter, Command = "SkyReportGo ", Text = "dsfsadf", Color = HexToCuiColor("#AFF9FFFF")},
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" },
                    }
                });
                #endregion

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0.238542 0.2740741", AnchorMax = "0.7463545 0.7722222" },
                    Image = { Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat", Color = HexToCuiColor("#423A3898") }
                }, mainskymenu, "playerslist");
            }

            if (target.Length != 17 && reason == "")
            {

                for (int i = 0; i < 44; i++)
                {
                    CuiHelper.DestroyUi(player, mainskymenu + $".ChoosePlayer.{i}");
                    CuiHelper.DestroyUi(player, mainskymenu + $".ChoosePlayer.{i}.Text");
                }

                for (int x = 0, y = 0, i = 0; i < BasePlayer.activePlayerList.Count; i++)
                {

                    var check = BasePlayer.activePlayerList[i];
                    if (check.displayName.ToLower().Contains(target.ToLower()))
                    {
                        string command = $"SkyReportGo chooseplayers {check.userID}";

                        container.Add(new CuiButton
                        {
                            FadeOut = 0.1f,
                            RectTransform = { AnchorMin = $"{0.01333263 + (x * 0.244)} {0.9033457 - (y * 0.089)}", AnchorMax = $"{0.252307 + (x * 0.244)} {0.9758366 - (y * 0.089)}" },
                            Button = { Command = command, Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat", Color = HexToCuiColor("#939391C8"), FadeIn = 0.4f },
                            Text = { Text = $"[{check.displayName}]", FontSize = 14, Align = TextAnchor.MiddleCenter },
                        }, "playerslist", "Button" + $".ChoosePlayer.{i}");

                        x++;
                        if (x == 4)
                        {
                            x = 0;
                            y++;

                            if (y == 11)
                            {
                                break;
                            }
                        }

                    }

                }
            }
            else
            {

                CuiHelper.DestroyUi(player, "buttoncap");
                CuiHelper.DestroyUi(player, "infotxt2");

                if (reason == "")
                {
                    container.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = "0.2385417 0.1064812", AnchorMax = "0.74583544 0.2185182" },
                        Image = { Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat", Color = HexToCuiColor("#423A3898") }
                    }, mainskymenu, "buttoncap");

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0.2333325 0.2203703", AnchorMax = "0.75 0.2648149" },
                        Text = { Text = "Далее вам нужно выбрать причину жалобы на данного игрока, или ввести свою", FontSize = 17, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                    }, mainskymenu, "infotxt2");

                    for (int x = 0, y = 0, i = 0, t = 0; i < config.Reasonsforcomplaint.Count; i++)
                    {
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = $"{0.009240265 + (x * 0.245)} {0.5289283 - (y * 0.45)}", AnchorMax = $"{0.2505133 + (x * 0.245)} {0.9173553 - (y * 0.45)}" },
                            Button = { Command = $"SkyReportGo {target.Replace(" ", "").Replace(" ", "").Replace(" ", "")} {i}", Color = HexToCuiColor("#939391C8"), Close = "buttoncap" + "infotxt2", Material = "assets/content/ui/uibackgroundblur.mat", FadeIn = 0.4f },
                            Text = { Text = config.Reasonsforcomplaint[i], Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 16 }
                        }, "buttoncap");

                        x++;
                        if (x == 4)
                        {
                            x = 0;
                            y++;
                        }
                        if (y == 2)
                        {
                            break;
                        }
                        t++;
                    }
                }
            }
            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region Help


        #region FindPlayer
        private BasePlayer FindPlayer(string nameOrId)
        {
            for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                var check = BasePlayer.activePlayerList[i];
                if (check.displayName.ToLower().Contains(nameOrId.ToLower()) || check.userID.ToString() == nameOrId)
                    return check;
            }
            return null;
        }

        #endregion

        #region IsAfk

        readonly Hash<ulong, Vector3> lastPosition = new Hash<ulong, Vector3>();
        public bool IsPlayerAfk(BasePlayer player)
        {
            if (player == null) return true;
            var last = lastPosition[player.userID];
            var current = player.transform.position;

            if (last.x.Equals(current.x)) return true;
            lastPosition[player.userID] = current;

            return false;
        }
        #endregion

        #region Hex
        private static string HexToCuiColor(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException(" Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }

        #endregion

        #region reply
        public void SendChat(BasePlayer player, string Message, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            if (IQChat)
                IQChat?.Call("API_ALERT_PLAYER", player, Message, config.setting.prefix, config.setting.avatarid.ToString());
            else player.SendConsoleCommand("chat.add", channel, 0, Message);
        }
        #endregion

        #region VK
        private void SendChatMessage(string msg, params object[] args)
        {
            if (!config.vKontakte.UseVK) return;

            string vkchat = string.Format(lang.GetMessage(msg, this), args);
            int RandomID = UnityEngine.Random.Range(0, 99999);
            while (vkchat.Contains("#"))
                vkchat = vkchat.Replace("#", "%23");
            webrequest.Enqueue($"https://api.vk.com/method/messages.send?chat_id={config.vKontakte.VK_ChatID}&random_id={RandomID}&message={vkchat}&access_token={config.vKontakte.VK_Token}&v=5.90", null, (code, response) => { }, this);
        }

        #endregion

        #region discord

        #region FancyDiscord
        public class FancyMessage
        {
            public string content { get; set; }
            public bool tts { get; set; }
            public Embeds[] embeds { get; set; }

            public class Embeds
            {
                public string title { get; set; }
                public int color { get; set; }
                public List<Fields> fields { get; set; }
                public Footer footer { get; set; }
                public Authors author { get; set; }

                public Embeds(string title, int color, List<Fields> fields, Authors author, Footer footer)
                {
                    this.title = title;
                    this.color = color;
                    this.fields = fields;
                    this.author = author;
                    this.footer = footer;

                }
            }

            public FancyMessage(string content, bool tts, Embeds[] embeds)
            {
                this.content = content;
                this.tts = tts;
                this.embeds = embeds;
            }

            public string toJSON() => JsonConvert.SerializeObject(this);
        }

        public class Footer
        {
            public string text { get; set; }
            public string icon_url { get; set; }
            public string proxy_icon_url { get; set; }
            public Footer(string text, string icon_url, string proxy_icon_url)
            {
                this.text = text;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        public class Authors
        {
            public string name { get; set; }
            public string url { get; set; }
            public string icon_url { get; set; }
            public string proxy_icon_url { get; set; }
            public Authors(string name, string url, string icon_url, string proxy_icon_url)
            {
                this.name = name;
                this.url = url;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        public class Fields
        {
            public string name { get; set; }
            public string value { get; set; }
            public bool inline { get; set; }
            public Fields(string name, string value, bool inline)
            {
                this.name = name;
                this.value = value;
                this.inline = inline;
            }
        }

        private void Request(string url, string payload, Action<int> callback = null)
        {
            Dictionary<string, string> header = new Dictionary<string, string>();
            header.Add("Content-Type", "application/json");
            webrequest.Enqueue(url, payload, (code, response) =>
            {
                if (code != 200 && code != 204)
                {
                    if (response != null)
                    {
                        try
                        {
                            JObject json = JObject.Parse(response);
                            if (code == 429)
                            {
                                float seconds = float.Parse(Math.Ceiling((double)(int)json["retry_after"] / 1000).ToString());
                            }
                            else
                            {
                                PrintWarning($" Discord rejected that payload! Responded with \"{json["message"].ToString()}\" Code: {code}");
                            }
                        }
                        catch
                        {
                            PrintWarning($"Failed to get a valid response from discord! Error: \"{response}\" Code: {code}");
                        }
                    }
                    else
                    {
                        PrintWarning($"Discord didn't respond (down?) Code: {code}");
                    }
                }
                try
                {
                    callback?.Invoke(code);
                }
                catch (Exception ex) { }

            }, this, RequestMethod.POST, header);
        }
        #endregion

        void SendDiscordMsg(string key, params object[] args)
        {
            if (!config.discord.UseDiscord) return;
            if (String.IsNullOrEmpty(config.discord.Discord_webHook)) return;

            string msg = string.Format(lang.GetMessage(key, this), args);

            List<Fields> fields = new List<Fields>
            {
                    new Fields("SkyReportSystem", msg, true),
            };

            FancyMessage newMessage = new FancyMessage(null, true, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, 16775936, fields, new Authors("SkyReportSystem", "https://skyplugins.ru/", "https://i.imgur.com/ILk3uJc.png", null), new Footer("Author: DezLife", "https://i.imgur.com/ILk3uJc.png", null)) });
            Request($"{config.discord.Discord_webHook}", newMessage.toJSON());
        }

        #endregion

        #endregion

        #region DataWorkerModule

        private void LoadData<T>(string name, ref T data, bool enableSaving)
        {
            string resultName = this.Name + $"/{name}";

            if (Interface.Oxide.DataFileSystem.ExistsDatafile(resultName))
            {
                data = Interface.Oxide.DataFileSystem.ReadObject<T>(resultName);
            }
            else
            {
                Interface.Oxide.DataFileSystem.WriteObject(resultName, data);
            }

            if (enableSaving)
            {
                SaveData(name, data);
            }
        }

        private void SaveData<T>(string name, T data)
        {
            string resultName = this.Name + $"/{name}";

            Interface.Oxide.DataFileSystem.WriteObject(resultName, data);
        }

        #endregion
    }
}


// --- End of file: SkyReportSystem (1).cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/DeathMessage-1.1.2.cs ---
// --- Original Local Path: DeathMessage-1.1.2.cs ---

﻿using System.Collections.Generic;
using System.Collections.Specialized;
using UnityEngine;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using Rust;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core;
using System;
using System.Globalization;
using System.Linq;
using System.Net;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    [Info("DeathMessage", "Damo/beee / M&B-Studios", "1.1.2", ResourceId = 0)]
    [Description("Players can freely switch between the two modes of death tips")]
    class DeathMessage : RustPlugin
    {

        #region 设置文档
        private ConfigData configData;
        private int _TempText = 0;
        private const string Permission_registration = "deathmessage.admin";
        private static DeathMessage Instance;

        private HashSet<ulong> _DeathMessageType = new HashSet<ulong>();

        public TextAnchor _textAnchor = TextAnchor.MiddleLeft;

        private ulong Last_attacker;
        private class ConfigData
        {
            public Oxide.Core.VersionNumber Version;

            [JsonProperty("➊ Global Messages settings")]
            public EnableSettings Enable_settings;

            [JsonProperty("➊ Discord settings")]
            public DiscordEnableSettings Discord_settings;

            [JsonProperty("➋ Display name modification and activation")]
            public AboutName About_name;

            [JsonProperty("➌ Other settings")]
            public OtherSettings Other_settings;

            [JsonProperty("➍ Lang settings")]
            public Dictionary<string, string> Lang_settings;

        }
        private class EnableSettings
        {
            [JsonProperty("Enable About Animal")]
            public bool Enable_Animal;

            [JsonProperty("Enable About Entitys")]
            public bool Enable_Entity;

            [JsonProperty("Enable About NPC")]
            public bool Enable_NPC;

            [JsonProperty("Enable Player Deaths")]
            public bool Enable_Player;

            [JsonProperty("Enable About Suicide")]
            public bool Enable_About_Suicide;
        }
        private class DiscordEnableSettings
        {
            [JsonProperty("Webhook URL")]
            public string DiscordWebHookUrl;

            [JsonProperty("Bot Name")]
            public string DiscordBotName;

            [JsonProperty("Bot Avatar Link")]
            public string DiscordAvatarLink;

            [JsonProperty("Enable Animal Deaths")]
            public bool Enable_Animal;

            [JsonProperty("Enable Entities Deaths")]
            public bool Enable_Entity;

            [JsonProperty("Enable NPC Deaths")]
            public bool Enable_NPC;

            [JsonProperty("Enable Player Deaths")]
            public bool Enable_Player;
        }
        private class OtherSettings
        {
            [JsonProperty("Default command")]
            public string Default_command;

            [JsonProperty("Chat Icon Id")]
            public string Chat_Icon;

            [JsonProperty("Default display(true = FloatUI , false = Chat box)")]
            public bool Defaultdisplay;

            [JsonProperty("FloatUI message closing time second")]
            public int Ui_time;

            [JsonProperty("Click on FloatUI switch to the chat box in seconds")]
            public int switching_time;
        }

        private class AboutName
        {
            [JsonProperty("➀ Animal name")]
            public Dictionary<string, EnableData> Animal_Name;

            [JsonProperty("➁ NPC name")]
            public Dictionary<string, EnableData> NPC_name;

            [JsonProperty("➂ Entity name")]
            public Dictionary<string, EnableData> Entity_Name;

            [JsonProperty("➃ Weapon name")]
            public Dictionary<string, string> Default_weapon;

            [JsonProperty("➄ Body part name")]
            public Dictionary<string, string> Body_part_name;
        }
        private class EnableData
        {
            [JsonProperty("Enable")]
            public bool Enable;

            [JsonProperty("Display name")]
            public string Display_name;

        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        private void LoadVariables()
        {
            LoadConfigVariables();
            //1.1.1 update
    if (!configData.Enable_settings.Enable_About_Suicide)
    {
        Puts("Updating config.");
        configData.Enable_settings.Enable_About_Suicide = true; // Setze den Standardwert
        Puts("Added 'Enable About Suicide' setting to configuration.");
    }

            configData.Version = Version;
            SaveConfig(configData);
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                Version = Version,
                Enable_settings = new EnableSettings
                {
                    Enable_Animal = true,
                    Enable_Entity = true,
                    Enable_NPC = true,
                    Enable_Player = true,
                    Enable_About_Suicide = true
                },
                Discord_settings = new DiscordEnableSettings
                {
                    DiscordBotName = "Death Messages Bot",
                    DiscordAvatarLink = "https://avatarfiles.alphacoders.com/128/128573.png",
                    DiscordWebHookUrl = "https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks",
                    Enable_Animal = true,
                    Enable_Entity = true,
                    Enable_NPC = true,
                    Enable_Player = true
                },
                About_name = new AboutName
                {
                    Animal_Name = new Dictionary<string, EnableData>
                    {
                        {"bear" ,new EnableData {Enable = true,Display_name = "bear" } },
                        {"polarbear" ,new EnableData {Enable = true,Display_name = "polarbear" } },
                        {"boar" ,new EnableData {Enable = true,Display_name = "boar" } },
                        {"chicken" ,new EnableData {Enable = true,Display_name = "chicken" } },
                        {"stag" ,new EnableData {Enable = true,Display_name = "stag" } },
                        {"wolf" ,new EnableData {Enable = true,Display_name = "wolf" } },
                        {"testridablehorse" ,new EnableData {Enable = true,Display_name = "testridablehorse" } },
                        {"horse" ,new EnableData {Enable = true,Display_name = "horse" } },
                        {"zombie" ,new EnableData {Enable = true,Display_name = "zombie" } },
                    },
                    Entity_Name = new Dictionary<string, EnableData>
                    {
                        {"bradleyapc" ,new EnableData {Enable = true,Display_name = "bradleyapc" } },
                        {"patrolhelicopter" ,new EnableData {Enable = true,Display_name = "patrolhelicopter" } },
                        {"autoturret_deployed" ,new EnableData {Enable = false,Display_name = "autoturret_deployed" } },
                        {"flameturret.deployed" ,new EnableData {Enable = false,Display_name = "flameturret.deployed" } },
                        {"guntrap.deployed" ,new EnableData {Enable = false,Display_name = "guntrap.deployed" } },
                        {"landmine" ,new EnableData {Enable = false,Display_name = "landmine" } },
                        {"beartrap" ,new EnableData {Enable = false,Display_name = "beartrap" } },
                        {"sam_site_turret_deployed" ,new EnableData {Enable = false,Display_name = "sam_site_turret_deployed" } },
                        {"sentry.scientist.static" ,new EnableData {Enable = false,Display_name = "sentry.scientist.static" } },
                    },
                    NPC_name = new Dictionary<string, EnableData>
                    {
                        {"scarecrow" ,new EnableData {Enable = true,Display_name = "scarecrow" } },
                        {"bandit_conversationalist" ,new EnableData {Enable = true,Display_name = "bandit_conversationalist" } },
                        {"bandit_shopkeeper" ,new EnableData {Enable = true,Display_name = "bandit_shopkeeper" } },
                        {"boat_shopkeeper" ,new EnableData {Enable = true,Display_name = "boat_shopkeeper" } },
                        {"missionprovider_bandit_a" ,new EnableData {Enable = true,Display_name = "missionprovider_bandit_a" } },
                        {"missionprovider_bandit_b" ,new EnableData {Enable = true,Display_name = "missionprovider_bandit_b" } },
                        {"missionprovider_fishing_a" ,new EnableData {Enable = true,Display_name = "missionprovider_fishing_a" } },
                        {"missionprovider_fishing_b" ,new EnableData {Enable = true,Display_name = "missionprovider_fishing_b" } },
                        {"missionprovider_outpost_a" ,new EnableData {Enable = true,Display_name = "missionprovider_outpost_a" } },
                        {"missionprovider_outpost_b" ,new EnableData {Enable = true,Display_name = "missionprovider_outpost_b" } },
                        {"missionprovider_stables_a" ,new EnableData {Enable = true,Display_name = "missionprovider_stables_a" } },
                        {"missionprovider_stables_b" ,new EnableData {Enable = true,Display_name = "missionprovider_stables_b" } },
                        {"npc_bandit_guard" ,new EnableData {Enable = true,Display_name = "npc_bandit_guard" } },
                        {"npc_tunneldweller" ,new EnableData {Enable = true,Display_name = "npc_tunneldweller" } },
                        {"npc_underwaterdweller" ,new EnableData {Enable = true,Display_name = "npc_underwaterdweller" } },
                        {"player" ,new EnableData {Enable = true,Display_name = "player" } },
                        {"scientistnpc_patrol" ,new EnableData {Enable = true,Display_name = "scientistnpc_patrol" } },
                        {"scientistnpc_peacekeeper" ,new EnableData {Enable = true,Display_name = "scientistnpc_peacekeeper" } },
                        {"scientistnpc_roam" ,new EnableData {Enable = true,Display_name = "scientistnpc_roam" } },
                        {"scientistnpc_roamtethered" ,new EnableData {Enable = true,Display_name = "scientistnpc_roamtethered" } },
                        {"stables_shopkeeper" ,new EnableData {Enable = true,Display_name = "stables_shopkeeper" } },
                    },
                    Default_weapon = new Dictionary<string, string>
                    {
                     {"grenade","grenade"},
                     {"explosive","explosive"},
                     {"heat","heat"},
                     {"Assault Rifle","Assault Rifle"},
                     {"LR-300 Assault Rifle","LR-300 Assault Rifle"},
                     {"L96 Rifle","L96 Rifle"},
                     {"Bolt Action Rifle","Bolt Action Rifle"},
                     {"Semi-Automatic Rifle","Semi-Automatic Rifle"},
                     {"Semi-Automatic Pistol","Semi-Automatic Pistol"},
                     {"Spas-12 Shotgun","Spas-12 Shotgun"},
                     {"M92 Pistol","M92 Pistol"},
                     {"Crossbow","Crossbow"},
                     {"Compound Bow","Compound Bow"},
                     {"Eoka Pistol","Eoka Pistol"},
                     {"Nailgun","Nailgun"},
                     {"Multiple Grenade Launcher","Multiple Grenade Launcher"},
                     {"Waterpipe Shotgun","Waterpipe Shotgun"},
                     {"Flame Thrower","Flame Thrower"},
                     {"Revolver","Revolver"},
                     {"Python Revolver","Python Revolver"},
                     {"Pump Shotgun","Pump Shotgun"},
                     {"Custom SMG","Custom SMG"},
                     {"MP5A4","MP5A4"},
                     {"Thompson","Thompson"},
                     {"Double Barrel Shotgun","Double Barrel Shotgun"},
                     {"M39 Rifle","M39 Rifle"},
                     {"Rocket Launcher","Rocket Launcher"},
                     {"M249","M249"},
                     {"Chainsaw","Chainsaw"},
                     {"Jackhammer","Jackhammer"},
                     {"Salvaged Sword","Salvaged Sword"},
                     {"Hunting Bow","Hunting Bow"},
                     {"Longsword","Longsword"},
                     {"Salvaged Cleaver","Salvaged Cleaver"},
                     {"Combat Knife","Combat Knife"},
                     {"Wooden Spear","Wooden Spear"},
                     {"Stone Hatchet","Stone Hatchet"},
                     {"Rock","Rock"},
                     {"Torch","Torch"},
                     {"Salvaged Axe","Salvaged Axe"},
                     {"Salvaged Hammer","Salvaged Hammer"},
                     {"Pickaxe","Pickaxe"},
                     {"Mace","Mace"},
                     {"Bone Knife","Bone Knife"},
                     {"Hatchet","Hatchet"},
                     {"Salvaged Icepick","Salvaged Icepick"},
                     {"Stone Spear","Stone Spear"},
                     {"Flashlight","Flashlight"},
                     {"Butcher Knife","Butcher Knife"},
                     {"Bone Club","Bone Club"},
                     {"Candy Cane Club","Candy Cane Club"},
                     {"Stone Pickaxe","Stone Pickaxe"},
                    },
                    Body_part_name = new Dictionary<string, string>
                    {
                     {"Arm","Arm"},
                     {"Chest","Chest"},
                     {"Head","Head"},
                     {"Leg","Leg"},
                     {"Hand","Hand"},
                     {"Foot","Foot"},
                     {"Stomach","Stomach"},
                     {"Body","Body"},
                    }
                },
                Other_settings = new OtherSettings
                {
                    Default_command = "dm",
                    Chat_Icon = "0",
                    Defaultdisplay = true,
                    switching_time = 10,
                    Ui_time = 10,
                },
                Lang_settings = new Dictionary<string, string>
                {
                    {"ChatTitle", ""},
                    {"NoPermission", "Not have permission !"},
                    {"MessageTochat", "Toggle death message to <color=#FFFF00>ChatBox</color>"},
                    {"MessageToFloatUI","Toggle death message to <color=#66FF00>FloatUI</color>"},
                    {"ButtonSwitch", "Auto switch death message to <color=#FFFF00>ChatBox</color> <color=#FF0000>{0}</color> seconds"},
                    {"Reset", "Reset"},
                    {"DIY", "DIY control panel"},
                    {"FloatUILocation", "UI Location"},
                    {"LengthWidth", "Length Width"},
                    {"FontSize", "Font size"},
                    {"IntervalStretch", "Interval stretch"},
                    {"DisplayNumber", "Display number"},
                    {"FontPosition", "Font position"},
                    {"NPCKillPlayer","<color=#66FF00>{0}</color> <color=#66FFFF>{1}</color> Kill <color=#FFFF00>{2}</color> <color=#FF9900>{3}</color> m" },
                    {"PlayerSuicide","<color=#FFFF00>{0}</color> suicide"},
                    {"PlayerKillPlayer","<color=#66FF00>{0}</color> <color=#66FFFF>{1}</color> Kill <color=#FFFF00>{2}</color> <color=#6699FF>{3}</color> <color=#FF9900>{4}</color> m"},
                    {"PlayerKillNPC","<color=#66FF00>{0}</color> <color=#66FFFF>{1}</color> Kill <color=#FFFF00>{2}</color> <color=#6699FF>{3}</color> <color=#FF9900>{4}</color> m"},
                    {"PlayerKillEntity","<color=#66FF00>{0}</color> <color=#66FFFF>{1}</color> Kill <color=#FFFF00>{2}</color> <color=#FF9900>{3}</color> m"},
                    {"PlayerKillAnimal","<color=#66FF00>{0}</color> <color=#66FFFF>{1}</color> Kill <color=#FFFF00>{2}</color> <color=#FF9900>{3}</color> m"},
                    {"PlayerKillBradleyapc","<color=#66FF00>{0}</color> <color=#66FFFF>{1}</color> Kill <color=#FFFF00>{2}</color> <color=#FF9900>{3}</color> m"},
                    {"PlayerKillPatrolHelicopter","<color=#66FF00>{0}</color> <color=#66FFFF>{1}</color> Kill <color=#FFFF00>{2}</color> <color=#FF9900>{3}</color> m"},
                    {"EntityKillPlayer","<color=#66FF00>{0}</color> Kill <color=#FFFF00>{1}</color> <color=#FF9900>{2}</color> m"},
                    {"BradleyapcKillPlayer","<color=#66FF00>{0}</color> Kill <color=#FFFF00>{1}</color> <color=#FF9900>{2}</color> m"},
                    {"PatrolHelicopterKillPlayer","<color=#66FF00>{0}</color> Kill <color=#FFFF00>{1}</color> <color=#FF9900>{2}</color> m"},
                    {"AnimalKillPlayer","<color=#66FF00>{0}</color> Kill <color=#FFFF00>{1}</color> <color=#FF9900>{2}</color> m"},
                }
            };
            SaveConfig(config);
        }

        #endregion

        #region 存档数据
        DamoData damoData;
        class DamoData
        {
            public float[] pos = new float[] { 0.6f, 0.97f, 1f, 1f, 6f, 0.03f, 18, 0 };
        }
        private void LoadData()
        {
            try
            {
                damoData = Interface.Oxide.DataFileSystem.ReadObject<DamoData>(Name);
            }
            catch
            {
                ClearData();
            }
        }

        private void OnServerSave() => SaveData();

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, damoData);
        private void ClearData()
        {
            damoData = new DamoData();
            SaveData();
        }
        #endregion

        #region 钩子相关

        private void Init()
        {
            LoadVariables();
            LoadData();
        }

        private void OnServerInitialized()
        {
            PrintWarning(
                $"Support: M&B-Studios\n Contact Discord: mbstudios");
            Instance = this;
            AddCovalenceCommand(configData.Other_settings.Default_command, nameof(DeathMessageCommand));
            permission.RegisterPermission(Permission_registration, this);
            Get_textAnchor();

            foreach (var item in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(item);
            }
        }
        private void Unload()
        {
            SaveData();
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, "_ControlMenuUi");
                Destroy_All(player);
            }
            Instance = null;
            configData = null;
        }
        private void OnPlayerDisconnected(BasePlayer player)
        {
            _DeathMessageType.Remove(player.userID);
            if (_playersUIHandler.ContainsKey(player.userID))
            {
                _playersUIHandler.Remove(player.userID);
            }
        }
        private void OnPlayerConnected(BasePlayer player)
        {
            if (configData.Other_settings.Defaultdisplay)
            {
                _DeathMessageType.Remove(player.userID);
            }
            else
            {
                _DeathMessageType.Add(player.userID);
            }
        }
        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null) return;
            if (entity is BaseHelicopter)
            {
                if (info.InitiatorPlayer != null && info.InitiatorPlayer.userID.IsSteamId())
                {
                    Last_attacker = info.InitiatorPlayer.userID;
                }

            }
        }
        private void OnEntityDeath(BaseCombatEntity victim, HitInfo info)
        {
            if (victim == null || info == null) return;
            if (victim.ShortPrefabName.Contains("corpse")) return;
            try
            {
                if (info.Initiator != null)
                {
                    var Uncertain_attacker = info.Initiator;
                    if (Uncertain_attacker is BasePlayer)
                    {
                        var Attack_player = Uncertain_attacker as BasePlayer;
                        if (Attack_player.userID < 700000000000)
                        {
                            if (victim is BasePlayer)
                            {
                                var Victim_player = victim as BasePlayer;
                                if (Victim_player.userID > 700000000000)
                                {
                                    if (configData.Enable_settings.Enable_NPC || configData.Discord_settings.Enable_NPC)
                                    {
                                        if (IS_BotSpawn_Name(Attack_player.displayName))
                                        {
                                            UPGP(GetNPCEnableState(), "NPCKillPlayer", Attack_player.displayName, Weapon_Name(Attack_player, info), Victim_player.displayName, Attack_distance(info));
                                        }
                                        else
                                        {
                                            EnableData data;
                                            if (configData.About_name.NPC_name.TryGetValue(Attack_player.ShortPrefabName, out data))
                                            {
                                                if (data.Enable)
                                                {
                                                    UPGP(GetNPCEnableState(), "NPCKillPlayer", data.Display_name, Weapon_Name(Attack_player, info), Victim_player.displayName, Attack_distance(info));
                                                }
                                            }
                                            else
                                            {
                                                configData.About_name.NPC_name.Add(Attack_player.ShortPrefabName, new EnableData { Enable = false, Display_name = Attack_player.ShortPrefabName });
                                                SaveConfig(configData);

                                                Puts($"Added a new ShortPrefabName To be activated.. {Attack_player.ShortPrefabName}");
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            if (victim is BasePlayer)
                            {
                                var Victim_player = victim as BasePlayer;

                                if (Victim_player.userID > 700000000000)
                                {
                                    if(configData.Enable_settings.Enable_Player || configData.Discord_settings.Enable_Player)
                                    {
                                if (Attack_player == victim)
                                {
                                    // Prüfen, ob Suizidnachrichten aktiviert sind, bevor eine Nachricht gesendet wird
                                    if(configData.Enable_settings.Enable_About_Suicide)
                                    {
                                             UPGP(BroadcastTo.Both, "PlayerSuicide", Attack_player.displayName);
                                    }
                                }
                                        else
                                        {
                                            UPGP(BroadcastTo.Both, "PlayerKillPlayer", Attack_player.displayName, Weapon_Name(Attack_player, info), Victim_player.displayName, GetBodyName(info), Attack_distance(info));
                                        }
                                    }
                                }
                                else if (configData.Enable_settings.Enable_NPC || configData.Discord_settings.Enable_NPC)
                                {
                                    if (IS_BotSpawn_Name(Victim_player.displayName))
                                    {
                                        UPGP(GetNPCEnableState(), "PlayerKillNPC", Attack_player.displayName, Weapon_Name(Attack_player, info), Victim_player.displayName, GetBodyName(info), Attack_distance(info));
                                    }
                                    else
                                    {
                                        EnableData data;
                                        if (configData.About_name.NPC_name.TryGetValue(victim.ShortPrefabName, out data))
                                        {
                                            if (data.Enable)
                                            {
                                                UPGP(GetNPCEnableState(), "PlayerKillNPC", Attack_player.displayName, Weapon_Name(Attack_player, info), data.Display_name, GetBodyName(info), Attack_distance(info));
                                            }
                                        }
                                        else
                                        {
                                            configData.About_name.NPC_name.Add(victim.ShortPrefabName, new EnableData { Enable = false, Display_name = victim.ShortPrefabName });
                                            SaveConfig(configData);
                                            Puts($"Added a new ShortPrefabName To be activated.. {victim.ShortPrefabName}");
                                        }
                                    }

                                }
                            }
                            else
                            {
                                if (victim is BaseAnimalNPC)
                                {
                                    if (configData.Enable_settings.Enable_Animal || configData.Discord_settings.Enable_Animal)
                                    {
                                        EnableData data;
                                        if (configData.About_name.Animal_Name.TryGetValue(victim.ShortPrefabName, out data))
                                        {
                                            if (data.Enable)
                                            {
                                                UPGP(GetAnimalEnableState(), "PlayerKillAnimal", Attack_player.displayName, Weapon_Name(Attack_player, info), data.Display_name, Attack_distance(info));
                                            }
                                        }
                                        else
                                        {
                                            configData.About_name.Animal_Name.Add(victim.ShortPrefabName, new EnableData { Enable = false, Display_name = victim.ShortPrefabName });
                                            SaveConfig(configData);

                                            Puts($"Added a new ShortPrefabName To be activated.. {victim.ShortPrefabName}");
                                        }
                                    }

                                }
                                else if (victim is BaseHelicopter)
                                {

                                    if (configData.Enable_settings.Enable_Entity || configData.Discord_settings.Enable_Entity)
                                    {
                                        EnableData data;
                                        if (configData.About_name.Entity_Name.TryGetValue(victim.ShortPrefabName, out data))
                                        {
                                            if (data.Enable)
                                            {
                                                UPGP(GetEntityEnableState(), "PlayerKillPatrolHelicopter", Attack_player.displayName, Weapon_Name(Attack_player, info), data.Display_name, Attack_distance(info));
                                            }

                                        }
                                        else
                                        {
                                            configData.About_name.Entity_Name.Add(victim.ShortPrefabName, new EnableData { Enable = false, Display_name = victim.ShortPrefabName });
                                            SaveConfig(configData);

                                            Puts($"Added a new ShortPrefabName To be activated.. {victim.ShortPrefabName}");
                                        }
                                    }


                                }
                                else if (victim is BradleyAPC)
                                {
                                    if (configData.Enable_settings.Enable_Entity || configData.Discord_settings.Enable_Entity)
                                    {
                                        EnableData data;
                                        if (configData.About_name.Entity_Name.TryGetValue(victim.ShortPrefabName, out data))
                                        {
                                            if (data.Enable)
                                            {
                                                UPGP(GetEntityEnableState(), "PlayerKillBradleyapc", Attack_player.displayName, Weapon_Name(Attack_player, info), data.Display_name, Attack_distance(info));
                                            }
                                        }
                                        else
                                        {

                                            configData.About_name.Entity_Name.Add(victim.ShortPrefabName, new EnableData { Enable = false, Display_name = victim.ShortPrefabName });
                                            SaveConfig(configData);

                                            Puts($"Added a new ShortPrefabName To be activated.. {victim.ShortPrefabName}");
                                        }
                                    }

                                }
                                else
                                {
                                    if (configData.Enable_settings.Enable_Entity || configData.Discord_settings.Enable_Entity)
                                    {
                                        EnableData data;
                                        if (configData.About_name.Entity_Name.TryGetValue(victim.ShortPrefabName, out data))
                                        {
                                            if (data.Enable)
                                            {
                                                UPGP(GetEntityEnableState(), "PlayerKillEntity", Attack_player.displayName, Weapon_Name(Attack_player, info), data.Display_name, Attack_distance(info)); ;
                                            }
                                        }
                                        else
                                        {

                                            configData.About_name.Entity_Name.Add(victim.ShortPrefabName, new EnableData { Enable = false, Display_name = victim.ShortPrefabName });
                                            SaveConfig(configData);

                                            Puts($"Added a new ShortPrefabName To be activated.. {victim.ShortPrefabName}");
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else if (victim is BasePlayer)
                    {
                        var Victim_player = victim as BasePlayer;
                        if (Victim_player.userID > 700000000000)
                        {
                            if (Uncertain_attacker is BaseAnimalNPC)
                            {

                                if (configData.Enable_settings.Enable_Animal || configData.Discord_settings.Enable_Animal)
                                {
                                    EnableData data;
                                    if (configData.About_name.Animal_Name.TryGetValue(Uncertain_attacker.ShortPrefabName, out data))
                                    {
                                        if (data.Enable)
                                        {
                                            UPGP(GetAnimalEnableState(), "AnimalKillPlayer", data.Display_name, Victim_player.displayName, Attack_distance(info));
                                        }
                                    }
                                    else
                                    {
                                        configData.About_name.Animal_Name.Add(Uncertain_attacker.ShortPrefabName, new EnableData { Enable = false, Display_name = Uncertain_attacker.ShortPrefabName });
                                        SaveConfig(configData);

                                        Puts($"Added a new ShortPrefabName To be activated.. {Uncertain_attacker.ShortPrefabName}");
                                    }
                                }


                            }
                            else if (Uncertain_attacker is BaseHelicopter)
                            {
                                if (configData.Enable_settings.Enable_Entity || configData.Discord_settings.Enable_Entity)
                                {
                                    EnableData data;
                                    if (configData.About_name.Entity_Name.TryGetValue(Uncertain_attacker.ShortPrefabName, out data))
                                    {
                                        if (data.Enable)
                                        {
                                            UPGP(GetEntityEnableState(), "PatrolHelicopterKillPlayer", data.Display_name, Victim_player.displayName, Attack_distance(info));
                                        }
                                    }
                                    else
                                    {

                                        configData.About_name.Entity_Name.Add(Uncertain_attacker.ShortPrefabName, new EnableData { Enable = false, Display_name = Uncertain_attacker.ShortPrefabName });
                                        SaveConfig(configData);

                                        Puts($"Added a new ShortPrefabName To be activated.. {Uncertain_attacker.ShortPrefabName}");
                                    }
                                }

                            }
                            else if (Uncertain_attacker is BradleyAPC)
                            {

                                if (configData.Enable_settings.Enable_Entity || configData.Discord_settings.Enable_Entity)
                                {
                                    EnableData data;
                                    if (configData.About_name.Entity_Name.TryGetValue(Uncertain_attacker.ShortPrefabName, out data))
                                    {
                                        if (data.Enable)
                                        {
                                            UPGP(GetEntityEnableState(), "BradleyapcKillPlayer", data.Display_name, Victim_player.displayName, Attack_distance(info));
                                        }
                                    }
                                    else
                                    {

                                        configData.About_name.Entity_Name.Add(Uncertain_attacker.ShortPrefabName, new EnableData { Enable = false, Display_name = Uncertain_attacker.ShortPrefabName });
                                        SaveConfig(configData);

                                        Puts($"Added a new ShortPrefabName To be activated.. {Uncertain_attacker.ShortPrefabName}");
                                    }
                                }


                            }
                            else
                            {
                                if (configData.Enable_settings.Enable_Entity || configData.Discord_settings.Enable_Entity)
                                {
                                    EnableData data;
                                    if (configData.About_name.Entity_Name.TryGetValue(Uncertain_attacker.ShortPrefabName, out data))
                                    {
                                        if (data.Enable)
                                        {
                                            UPGP(GetEntityEnableState(), "EntityKillPlayer", data.Display_name, Victim_player.displayName, Attack_distance(info));
                                        }
                                    }
                                    else
                                    {

                                        configData.About_name.Entity_Name.Add(Uncertain_attacker.ShortPrefabName, new EnableData { Enable = false, Display_name = Uncertain_attacker.ShortPrefabName });
                                        SaveConfig(configData);

                                        Puts($"Added a new ShortPrefabName To be activated.. {Uncertain_attacker.ShortPrefabName}");

                                    }
                                }
                            }

                        }
                    }
                }
                else
                {
                    if (victim is BaseHelicopter)
                    {
                        if (configData.Enable_settings.Enable_Entity || configData.Discord_settings.Enable_Entity)
                        {
                            EnableData data;
                            if (configData.About_name.Entity_Name.TryGetValue(victim.ShortPrefabName, out data))
                            {
                                var pl = FindPlayer(Last_attacker);
                                if (pl != null)
                                {
                                    if (data.Enable)
                                    {
                                        UPGP(GetEntityEnableState(), "PlayerKillEntity", pl.displayName, Weapon_Name(pl, info), data.Display_name, Attack_distance(info));
                                    }
                                }
                            }
                            else
                            {
                                Puts($"Added a new ShortPrefabName To be activated.. {victim.ShortPrefabName}");
                                configData.About_name.Entity_Name.Add(victim.ShortPrefabName, new EnableData { Enable = false, Display_name = victim.ShortPrefabName });
                                SaveConfig(configData);
                            }
                        }

                    }
                }
            }
            catch
            {

            }
        }
        #endregion

        #region 程序方法

        private void Get_textAnchor()
        {
            switch ((int)damoData.pos[7])
            {
                case 0:
                    _textAnchor = TextAnchor.UpperRight;
                    break;
                case 1:
                    _textAnchor = TextAnchor.UpperLeft;
                    break;
                case 2:
                    _textAnchor = TextAnchor.MiddleCenter;
                    break;
            }
        }

        void Send_Kill_Player_Note(String langKey, String killerName = null, String shortnameWeapon = null,
            String victomPlayer = null, String distanceKiller = null, String bodyName = "Body")
        {
            Item weaponInfo = null;
            if (shortnameWeapon != null)
                weaponInfo = ItemManager.CreateByName(shortnameWeapon);
            
            UPGP(BroadcastTo.Both, langKey, killerName, weaponInfo != null ? weaponInfo.info.displayName.english : shortnameWeapon, victomPlayer, bodyName, distanceKiller);

            if (weaponInfo != null)
            {
                weaponInfo.Remove();
                weaponInfo = null;
            }
        } 
        private void UPGP(BroadcastTo broadcastTo, string Key, string A = null, string B = null, string C = null, string D = null, string E = null)
        {
            string Text = null;
            if (configData.Lang_settings.ContainsKey(Key))
            {
                Text = string.Format(configData.Lang_settings[Key], A, B, C, D, E);
            }

            if(Text == null) return;

            if(broadcastTo == BroadcastTo.InGame || broadcastTo == BroadcastTo.Both)
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    if (!_DeathMessageType.Contains(player.userID))
                    {
                        UpUIMessage(player, Text);
                    }
                    else
                    {
                        rust.SendChatMessage(player, configData.Lang_settings["ChatTitle"], Text, configData.Other_settings.Chat_Icon);
                    }
                }
            }

            if(broadcastTo == BroadcastTo.Discord || broadcastTo == BroadcastTo.Both) BroadcastToDiscord(Text);
        }
        private BasePlayer FindPlayer(string nameOrIdOrIp)
        {
            foreach (var activePlayer in BasePlayer.activePlayerList)
            {
                if (activePlayer.UserIDString == nameOrIdOrIp)
                    return activePlayer;
                if (activePlayer.displayName.Contains(nameOrIdOrIp, CompareOptions.OrdinalIgnoreCase))
                    return activePlayer;
                if (activePlayer.net?.connection != null && activePlayer.net.connection.ipaddress == nameOrIdOrIp)
                    return activePlayer;
            }
            foreach (var sleepingPlayer in BasePlayer.sleepingPlayerList)
            {
                if (sleepingPlayer.UserIDString == nameOrIdOrIp)
                    return sleepingPlayer;
                if (sleepingPlayer.displayName.Contains(nameOrIdOrIp, CompareOptions.OrdinalIgnoreCase))
                    return sleepingPlayer;
            }
            return null;
        }
        private BasePlayer FindPlayer(ulong userId)
        {
            foreach (var activePlayer in BasePlayer.activePlayerList)
            {
                if (activePlayer.userID == userId)
                    return activePlayer;
            }
            return null;
        }

        private string GetBodyName(HitInfo hitInfo)
        {

            string bone = HitBodyPos(hitInfo);
            if (configData.About_name.Body_part_name.ContainsKey(bone))
            {
                return configData.About_name.Body_part_name[bone];
            }
            else
            {
                configData.About_name.Body_part_name.Add(bone, bone);
                SaveConfig(configData);
                return bone;
            }
        }
        private string HitBodyPos(HitInfo hitInfo)
        {
            var hitArea = hitInfo?.boneArea ?? (HitArea)(-1);
            return (int)hitArea == -1 ? "Body" : hitArea.ToString();
        }

        private bool IS_BotSpawn_Name(string displayName)
        {
            try
            {
                ulong.Parse(displayName);
                return false;
            }
            catch
            {
                return true;
            }
        }

        private string Weapon_Name(BasePlayer player, HitInfo hit)
        {
            try
            {
                Item weapon = hit.Weapon.GetItem();
                if (weapon != null)
                {
                    if (weapon.name != null)
                    {
                        return weapon.name;
                    }
                    else if (configData.About_name.Default_weapon.ContainsKey(weapon.info.displayName.english))
                    {
                        return configData.About_name.Default_weapon[weapon.info.displayName.english];
                    }
                    else
                    {
                        configData.About_name.Default_weapon.Add(weapon.info.displayName.english, weapon.info.displayName.english);
                        SaveConfig(configData);
                        return weapon.info.displayName.english;
                    }
                }
                if (hit.WeaponPrefab != null)
                {
                    if (configData.About_name.Default_weapon.ContainsKey(hit.WeaponPrefab.ShortPrefabName))
                    {
                        return configData.About_name.Default_weapon[hit.WeaponPrefab.ShortPrefabName];
                    }
                    else
                    {
                        configData.About_name.Default_weapon.Add(hit.WeaponPrefab.ShortPrefabName, hit.WeaponPrefab.ShortPrefabName);
                        SaveConfig(configData);
                        return hit.WeaponPrefab.ShortPrefabName;
                    }
                }
                if (hit.damageTypes.GetMajorityDamageType() == DamageType.Explosion)
                {
                    if (configData.About_name.Default_weapon.ContainsKey("explosive"))
                    {
                        return configData.About_name.Default_weapon["explosive"];
                    }
                    else
                    {
                        configData.About_name.Default_weapon.Add("explosive", "explosive");
                        SaveConfig(configData);
                        return "explosive";
                    }
                }
                if (!hit.damageTypes.IsBleedCausing() && hit.damageTypes.Has(DamageType.Explosion))
                {
                    if (configData.About_name.Default_weapon.ContainsKey("explosive"))
                    {
                        return configData.About_name.Default_weapon["explosive"];
                    }
                    else
                    {
                        configData.About_name.Default_weapon.Add("explosive", "explosive");
                        SaveConfig(configData);
                        return "explosive";
                    }
                }
                if (hit.damageTypes.GetMajorityDamageType() == DamageType.Heat || (!hit.damageTypes.IsBleedCausing() && hit.damageTypes.Has(DamageType.Heat)))
                {
                    if (configData.About_name.Default_weapon.ContainsKey("heat"))
                    {
                        return configData.About_name.Default_weapon["heat"];
                    }
                    else
                    {
                        configData.About_name.Default_weapon.Add("heat", "heat");
                        SaveConfig(configData);
                        return "heat";
                    }
                }
                if (hit.ProjectilePrefab.name != null)
                {
                    if (configData.About_name.Default_weapon.ContainsKey(hit.ProjectilePrefab.name))
                    {
                        return configData.About_name.Default_weapon[hit.ProjectilePrefab.name];
                    }
                    else
                    {
                        configData.About_name.Default_weapon.Add(hit.ProjectilePrefab.name, hit.ProjectilePrefab.name);
                        SaveConfig(configData);
                        return hit.ProjectilePrefab.name;
                    }
                }
                else
                {
                    weapon = player.GetActiveItem();
                    if (weapon != null && weapon.GetHeldEntity() is AttackEntity)
                    {
                        if (weapon.name != null)
                        {
                            return weapon.name;
                        }
                        else if (configData.About_name.Default_weapon.ContainsKey(weapon.info.displayName.english))
                        {
                            return configData.About_name.Default_weapon[weapon.info.displayName.english];
                        }
                        else
                        {
                            configData.About_name.Default_weapon.Add(weapon.info.displayName.english, weapon.info.displayName.english);
                            SaveConfig(configData);
                            return weapon.info.displayName.english;
                        }
                    }
                    if (configData.About_name.Default_weapon.ContainsKey("unknown"))
                    {
                        return configData.About_name.Default_weapon["unknown"];
                    }
                    else
                    {
                        configData.About_name.Default_weapon.Add("unknown", "");
                        SaveConfig(configData);
                        return "";
                    }
                }
            }
            catch
            {
                if (configData.About_name.Default_weapon.ContainsKey("unknown"))
                {
                    return configData.About_name.Default_weapon["unknown"];
                }
                else
                {
                    configData.About_name.Default_weapon.Add("unknown", "");
                    SaveConfig(configData);
                    return "";
                }
            }
        }
        private string Attack_distance(HitInfo info)
        {
            return (info?.InitiatorPlayer != null ? (int)Vector3.Distance(info.InitiatorPlayer.transform.position, info.HitPositionWorld) : (int)info.ProjectileDistance).ToString();
        }

        #endregion

        #region Ui相关

        private CuiElement DanTextC(string parent, string Nam, string text, string anchorMin, string anchorMax, int DX = 11, TextAnchor align = TextAnchor.UpperLeft)
        { return new CuiElement { Parent = parent, Name = Nam, Components = { new CuiTextComponent { Text = text, FontSize = DX, Color = "1 1 1 1", Align = align }, new CuiRectTransformComponent { AnchorMin = anchorMin, AnchorMax = anchorMax }, new CuiOutlineComponent { Color = "0 0 0 1", Distance = "-.5 .5" } } }; }
        private CuiElement DanText(string parent, string Nam, string text, string anchorMin, string anchorMax, int DX = 11, TextAnchor align = TextAnchor.UpperLeft)
        { return new CuiElement { Parent = parent, Name = Nam, FadeOut = 0.5f, Components = { new CuiTextComponent { Text = text, FontSize = DX, Color = "1 1 1 1", Align = align }, new CuiRectTransformComponent { AnchorMin = anchorMin, AnchorMax = anchorMax }, new CuiOutlineComponent { Color = "0 0 0 1", Distance = "-.5 .5" } } }; }
        private CuiElement CuiText(string parent, string text, string anchorMin, string anchorMax, string yanst = "1 1 1 1", int DX = 12, TextAnchor align = TextAnchor.MiddleCenter)
        { return new CuiElement { Parent = parent, Components = { new CuiTextComponent { Text = text, FontSize = DX, Color = yanst, Align = align }, new CuiRectTransformComponent { AnchorMin = anchorMin, AnchorMax = anchorMax }, new CuiOutlineComponent { Color = "0 0 0 1", Distance = "-.5 .5" } } }; }
        private CuiElement YxText(string parent, string text, string anchorMin, string anchorMax, int DX = 11, TextAnchor align = TextAnchor.UpperLeft)
        { return new CuiElement { Parent = parent, Components = { new CuiTextComponent { Text = text, FontSize = DX, Color = "1 1 1 1", Align = align }, new CuiRectTransformComponent { AnchorMin = anchorMin, AnchorMax = anchorMax }, new CuiOutlineComponent { Color = "0 0 0 1", Distance = "-.5 .5" } } }; }
        private CuiPanel CreatePanel(string anchorMin, string anchorMax, string color = "0 0 0 0", bool SB = false)
        { return new CuiPanel { Image = { Color = color }, RectTransform = { AnchorMin = anchorMin, AnchorMax = anchorMax }, CursorEnabled = SB }; }
        private CuiButton GButton(string ml)
        { return new CuiButton { Button = { Command = ml, Color = "0 0 0 0" }, RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }, Text = { Text = null, FontSize = 12, Align = TextAnchor.MiddleCenter } }; }
        private CuiButton DMButton(string dz, string ml, string Zx, string zd, string wb = null, string ys = "0 0 0 0", int dx = 12, TextAnchor ddd = TextAnchor.MiddleCenter)
        { return new CuiButton { Button = { Close = dz, Command = ml, Color = ys }, RectTransform = { AnchorMin = Zx, AnchorMax = zd }, Text = { Text = wb, FontSize = dx, Align = ddd } }; }
        private void Remove_UI(BasePlayer player, int r_num)
        {
            UIHandler data;
            if (_playersUIHandler.TryGetValue(player.userID, out data))
            {
                if (data._UI_List.Contains(r_num))
                {
                    if (data._Remove.Contains(r_num))
                    {
                        data._Remove.Remove(r_num);
                    }
                    else
                    {
                        CuiHelper.DestroyUi(player, $"_Message{r_num}");
                        data._UI_List.Remove(r_num);
                    }
                }
            }
        }
        private void Destroy_All(BasePlayer player)
        {
            UIHandler data;
            if (_playersUIHandler.TryGetValue(player.userID, out data))
            {
                foreach (var item in data._UI_List)
                {
                    CuiHelper.DestroyUi(player, $"_Message{item}");
                }
                data.num = 0;
                data._Remove.Clear();
                data._UI_List.Clear();
            }
        }
        private Dictionary<ulong, UIHandler> _playersUIHandler = new Dictionary<ulong, UIHandler>();
        private UIHandler GetUiInfo(BasePlayer player)
        {
            UIHandler value;
            if (!_playersUIHandler.TryGetValue(player.userID, out value))
            {
                _playersUIHandler[player.userID] = new UIHandler();
                return _playersUIHandler[player.userID];
            }
            return value;
        }
        private class UIHandler
        {
            public List<int> _UI_List = new List<int>();
            public HashSet<int> _Remove = new HashSet<int>();
            public int num;
        }

        private string _mianbanyou_A = ".745 .2";
        private string _mianbanyou_B = ".99 .7";

        public void ControlMenuUi(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "_ControlMenuUi");

            var elements = new CuiElementContainer();

            var Menu = elements.Add(CreatePanel(_mianbanyou_A, _mianbanyou_B, "0.247 0.247 0.247 1", true), "Overlay", "_ControlMenuUi");

            elements.Add(CreatePanel("0 .93", "1 1", "0.149 0.153 0.153 1"), Menu);



            elements.Add(CuiText(Menu, string.Format(configData.Lang_settings["DIY"]), ".05 .93", "1 1", "1 1 1 1", 14, TextAnchor.MiddleLeft));

            elements.Add(DMButton(Menu, "deathmessage.ove", ".93 .94", ".99 .99", "✕", "0.827 0.271 0.173 1"), Menu);

            var bjpy = elements.Add(CreatePanel("0 .8", "1 .9", "0 0 0 0"), Menu);

            elements.Add(CuiText(bjpy, string.Format(configData.Lang_settings["FloatUILocation"]), "0 0", ".25 1", "1 1 1 1", 12, TextAnchor.MiddleRight));

            elements.Add(DMButton(null, "deathmessage.ui wz 0 2 -0.02", ".3 .2", ".37 .8", "◄", "0 0 0 .5"), bjpy);
            elements.Add(DMButton(null, "deathmessage.ui wz 0 2 0.02", ".48 .2", ".55 .8", "►", "0 0 0 .5"), bjpy);
            elements.Add(DMButton(null, "deathmessage.ui wz 1 3 0.02", ".66 .2", ".73 .8", "▲", "0 0 0 .5"), bjpy);
            elements.Add(DMButton(null, "deathmessage.ui wz 1 3 -0.02", ".84 .2", ".91 .8", "▼", "0 0 0 .5"), bjpy);

            var bjdx = elements.Add(CreatePanel("0 .65", "1 .75", "0 0 0 0"), Menu);

            elements.Add(CuiText(bjdx, string.Format(configData.Lang_settings["LengthWidth"]), "0 0", ".25 1", "1 1 1 1", 12, TextAnchor.MiddleRight));

            elements.Add(DMButton(null, "deathmessage.ui zy 0 2 0.02", ".3 .2", ".37 .8", "↔", "0 0 0 .5"), bjdx);
            elements.Add(DMButton(null, "deathmessage.ui zy 0 2 -0.02", ".48 .2", ".55 .8", "⇄", "0 0 0 .5"), bjdx);

            elements.Add(DMButton(null, "deathmessage.ui zy 1 3 0.02", ".66 .2", ".73 .8", "↕", "0 0 0 .5"), bjdx);
            elements.Add(DMButton(null, "deathmessage.ui zy 1 3 -0.02", ".84 .2", ".91 .8", "⇅", "0 0 0 .5"), bjdx);


            var zidx = elements.Add(CreatePanel("0 .5", "1 .6", "0 0 0 0"), Menu);

            elements.Add(CuiText(zidx, string.Format(configData.Lang_settings["FontSize"]), "0 0", ".25 1", "1 1 1 1", 12, TextAnchor.MiddleRight));

            elements.Add(DMButton(null, "deathmessage.ui dan 6 1", ".3 .2", ".37 .8", "+", "0 0 0 .5", 14), zidx);
            elements.Add(DMButton(null, "deathmessage.ui dan 6 -1", ".48 .2", ".55 .8", "-", "0 0 0 .5"), zidx);

            var zijj = elements.Add(CreatePanel("0 .35", "1 .45", "0 0 0 0"), Menu);

            elements.Add(CuiText(zijj, string.Format(configData.Lang_settings["IntervalStretch"]), "0 0", ".25 1", "1 1 1 1", 12, TextAnchor.MiddleRight));

            elements.Add(DMButton(null, "deathmessage.ui dan 5 0.01", ".3 .2", ".37 .8", "+", "0 0 0 .5"), zijj);
            elements.Add(DMButton(null, "deathmessage.ui dan 5 -0.01", ".48 .2", ".55 .8", "-", "0 0 0 .5"), zijj);

            var zits = elements.Add(CreatePanel("0 .2", "1 .3", "0 0 0 0"), Menu);

            elements.Add(CuiText(zits, string.Format(configData.Lang_settings["DisplayNumber"]), "0 0", ".25 1", "1 1 1 1", 12, TextAnchor.MiddleRight));

            elements.Add(DMButton(null, "deathmessage.ui dan 4 1", ".3 .2", ".37 .8", "+", "0 0 0 .5"), zits);
            elements.Add(DMButton(null, "deathmessage.ui dan 4 -1", ".48 .2", ".55 .8", "-", "0 0 0 .5"), zits);


            var ziwz = elements.Add(CreatePanel("0 .05", "1 .15", "0 0 0 0"), Menu);

            elements.Add(CuiText(ziwz, string.Format(configData.Lang_settings["FontPosition"]), "0 0", ".25 1", "1 1 1 1", 12, TextAnchor.MiddleRight));

            elements.Add(DMButton(null, "deathmessage.ui dan 7 1", ".3 .2", ".37 .8", "∞", "0 0 0 .5"), ziwz);

            if (_mianbanyou_A != ".745 .2")
            {
                elements.Add(DMButton(null, "deathmessage.ui pzy", ".84 .35", ".91 .45", "◨", "0 0 0 .5", 20), Menu);
            }
            else
            {
                elements.Add(DMButton(null, "deathmessage.ui pzy", ".84 .35", ".91 .45", "◧", "0 0 0 .5", 20), Menu);
            }
            elements.Add(DMButton(null, "deathmessage.ui res", ".68 .05", ".93 .22", string.Format(configData.Lang_settings["Reset"]), "0.129 0.373 0.573 .8", 20), Menu);

            CuiHelper.AddUi(player, elements);
        }
        private void UpUIMessage(BasePlayer player, string Stext)
        {
            var data = GetUiInfo(player);
            var elements = new CuiElementContainer();
            if (data._UI_List.Count == 0 || data.num >= damoData.pos[4])
            {
                data.num = 0;
                data._Remove.Clear();
            }
            if (data._UI_List.Contains(data.num))
            {
                CuiHelper.DestroyUi(player, $"_Message{data.num}");
                data._UI_List.Remove(data.num);
                data._Remove.Add(data.num);
            }
            int r_num = data.num;
            elements.Add(DanText("Hud", $"_Message{data.num}", Stext, $"{damoData.pos[0]} {damoData.pos[1] - damoData.pos[5] * data.num}", $"{damoData.pos[2]} {damoData.pos[3] - damoData.pos[5] * data.num}", (int)damoData.pos[6], _textAnchor));
            elements.Add(GButton("deathmessage.cmd"), $"_Message{data.num}");
            data._UI_List.Add(data.num);
            data.num++;
            CuiHelper.AddUi(player, elements);
            timer.Once(configData.Other_settings.Ui_time, () =>
            {
                if (player != null)
                {
                    Remove_UI(player, r_num);
                }
            });
        }

        private List<string> TempText = new List<string>
        {
            {"<color=#66FF00>Terry</color> <color=#66FFFF>Assault Rifle</color> Kill <color=#FFFF00>Red Mary</color> <color=#FF9900>15</color> m"},
            {"<color=#66FF00>Billy.King</color> <color=#66FFFF>Double Barrel Shotgun</color> Kill <color=#FFFF00>Terry</color> <color=#6699FF>Head</color> <color=#FF9900>5</color> m"},
            {"<color=#66FF00>Grea Kevin</color> <color=#66FFFF>Compound Bow</color> Kill <color=#FFFF00>John Wilson</color> <color=#6699FF>Body</color> <color=#FF9900>20</color> m"},
            {"<color=#66FF00>Edward Adam Davis</color> <color=#66FFFF>L96 Rifle</color> Kill <color=#FFFF00>Guy de Maupassant</color> <color=#FF9900>60</color> m"},
            {"<color=#66FF00>Francisco Franco</color> <color=#66FFFF>Custom SMG</color> Kill <color=#FFFF00>bear</color> <color=#FF9900>7</color> m"},
            {"<color=#66FF00>bear</color> Kill <color=#FFFF00>Diego Rodrigueez de Silva y Velasquez</color> <color=#FF9900>3</color> m"},
        };
        private void UpUIMessageText(BasePlayer player)
        {
            UIHandler data;
            if (_playersUIHandler.TryGetValue(player.userID, out data))
            {
                data.num = 0;
                foreach (var item in data._UI_List)
                {
                    CuiHelper.DestroyUi(player, $"_Message{item}");
                }
            }
            timer.Repeat(0.01f, (int)damoData.pos[4], () =>
            {
                if (player != null)
                {
                    UpUIMessageRE(player);
                }
            });

        }
        private void UpUIMessageRE(BasePlayer player)
        {
            _TempText++;
            var data = GetUiInfo(player);
            var elements = new CuiElementContainer();
            if (data._UI_List.Count == 0 || data.num >= damoData.pos[4])
            {
                data.num = 0;
                data._Remove.Clear();
            }
            if (data._UI_List.Contains(data.num))
            {
                CuiHelper.DestroyUi(player, $"_Message{data.num}");
                data._UI_List.Remove(data.num);
                data._Remove.Add(data.num);
            }
            elements.Add(DanTextC("Hud", $"_Message{data.num}", $"{TempText[_TempText]}", $"{damoData.pos[0]} {damoData.pos[1] - damoData.pos[5] * data.num}", $"{damoData.pos[2]} {damoData.pos[3] - damoData.pos[5] * data.num}", (int)damoData.pos[6], _textAnchor));
            elements.Add(DMButton(null, null, "0 0", "1 1", null, "0 0 0 .5"), $"_Message{data.num}");
            data._UI_List.Add(data.num);
            data.num++;
            CuiHelper.AddUi(player, elements);
            _TempText++;
            if (_TempText >= TempText.Count)
            {
                _TempText = 0;
            }
        }
        #endregion

        #region 命令相关
        private void DeathMessageCommand(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = (BasePlayer)iplayer.Object;
            string Text = null;
            if (args.Length == 1)
            {
                if (args[0].ToLower() == "diy")
                {
                    if (!permission.UserHasPermission(player.UserIDString, Permission_registration))
                    {
                        Text = string.Format(configData.Lang_settings["NoPermission"]);
                        rust.SendChatMessage(player, configData.Lang_settings["ChatTitle"], Text, configData.Other_settings.Chat_Icon);
                        return;
                    }
                    ControlMenuUi(player);
                }

            }
            else
            {
                if (_DeathMessageType.Contains(player.userID))
                {
                    _DeathMessageType.Remove(player.userID);
                    if (configData.Lang_settings.ContainsKey("MessageToFloatUI"))
                    {
                        Text = string.Format(configData.Lang_settings["MessageToFloatUI"]);
                        rust.SendChatMessage(player, configData.Lang_settings["ChatTitle"], Text, configData.Other_settings.Chat_Icon);
                    }
                }
                else
                {
                    _DeathMessageType.Add(player.userID);
                    Destroy_All(player);
                    if (configData.Lang_settings.ContainsKey("MessageTochat"))
                    {
                        Text = string.Format(configData.Lang_settings["MessageTochat"]);
                        rust.SendChatMessage(player, configData.Lang_settings["ChatTitle"], Text, configData.Other_settings.Chat_Icon);
                    }
                }
            }
        }


        [ConsoleCommand("deathmessage.ui")]
        private void cmdDeathMessageui(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            if (!permission.UserHasPermission(player.UserIDString, Permission_registration))
            {
                var Text = string.Format(configData.Lang_settings["NoPermission"]);
                rust.SendChatMessage(player, configData.Lang_settings["ChatTitle"], Text, configData.Other_settings.Chat_Icon);
                return;
            }
            if (arg.Args[0] == "pzy")
            {
                if (_mianbanyou_A == ".745 .2")
                {
                    _mianbanyou_A = ".01 .2";
                    _mianbanyou_B = ".245 .7";
                }
                else
                {
                    _mianbanyou_A = ".745 .2";
                    _mianbanyou_B = ".99 .7";
                }
                ControlMenuUi(player);
                return;
            }
            switch (arg.Args[0])
            {
                case "wz":
                    float _value = float.Parse(arg.Args[3]);
                    damoData.pos[int.Parse(arg.Args[1])] += _value;
                    damoData.pos[int.Parse(arg.Args[2])] += _value;
                    break;
                case "zy":
                    _value = float.Parse(arg.Args[3]);
                    damoData.pos[int.Parse(arg.Args[1])] -= _value;
                    damoData.pos[int.Parse(arg.Args[2])] += _value;
                    break;
                case "dan":
                    _value = float.Parse(arg.Args[2]);
                    int key = int.Parse(arg.Args[1]);
                    damoData.pos[key] += _value;

                    switch (key)
                    {
                        case 7:
                            if (damoData.pos[key] > 2)
                            {
                                damoData.pos[key] = 0;
                            }
                            Get_textAnchor();
                            break;
                        case 4:
                            if (damoData.pos[key] < 1)
                            {
                                damoData.pos[key] = 1;
                            }
                            break;
                        case 5:
                            if (damoData.pos[key] < 0.01)
                            {
                                damoData.pos[key] = 0.01f;
                            }
                            break;
                        case 6:
                            if (damoData.pos[key] < 1)
                            {
                                damoData.pos[key] = 1;
                            }
                            break;
                    }
                    break;
                case "res":
                    damoData.pos = new float[] { 0.6f, 0.97f, 1f, 1f, 6f, 0.03f, 18, 0 };
                    Get_textAnchor();
                    break;

            }
            UpUIMessageText(player);

        }
        [ConsoleCommand("deathmessage.ove")]
        private void cmdDeathOver(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            Destroy_All(player);
        }
        [ConsoleCommand("deathmessage.cmd")]
        private void cmdDeathMessage(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            ulong userID = player.userID;
            _DeathMessageType.Add(userID);
            string Text = null;
            if (configData.Lang_settings.ContainsKey("ButtonSwitch"))
            {
                Text = string.Format(configData.Lang_settings["ButtonSwitch"], configData.Other_settings.switching_time);
                rust.SendChatMessage(player, configData.Lang_settings["ChatTitle"], Text, configData.Other_settings.Chat_Icon);
                timer.Once(configData.Other_settings.switching_time, () =>
                {
                    _DeathMessageType.Remove(userID);
                });
            }
            Destroy_All(player);
        }
        #endregion
    
        #region Discord Functions

        private enum BroadcastTo
        {
            InGame,
            Discord,
            Both,
            Neither
        }

        private BroadcastTo GetNPCEnableState(){
            if(configData.Enable_settings.Enable_NPC && configData.Discord_settings.Enable_NPC)
                return BroadcastTo.Both;

            if(configData.Enable_settings.Enable_NPC && !configData.Discord_settings.Enable_NPC)
                return BroadcastTo.InGame;
            
            if(!configData.Enable_settings.Enable_NPC && configData.Discord_settings.Enable_NPC)
                return BroadcastTo.Discord;
            
            return BroadcastTo.Neither;
        }

        private BroadcastTo GetAnimalEnableState(){
            if(configData.Enable_settings.Enable_Animal && configData.Discord_settings.Enable_Animal)
                return BroadcastTo.Both;

            if(configData.Enable_settings.Enable_Animal && !configData.Discord_settings.Enable_Animal)
                return BroadcastTo.InGame;
            
            if(!configData.Enable_settings.Enable_Animal && configData.Discord_settings.Enable_Animal)
                return BroadcastTo.Discord;
            
            return BroadcastTo.Neither;
        }

        private BroadcastTo GetEntityEnableState(){
            if(configData.Enable_settings.Enable_Entity && configData.Discord_settings.Enable_Entity)
                return BroadcastTo.Both;

            if(configData.Enable_settings.Enable_Entity && !configData.Discord_settings.Enable_Entity)
                return BroadcastTo.InGame;
            
            if(!configData.Enable_settings.Enable_Entity && configData.Discord_settings.Enable_Entity)
                return BroadcastTo.Discord;
            
            return BroadcastTo.Neither;
        }
        
        private void BroadcastToDiscord(string message)
        {
            if(!string.IsNullOrEmpty(configData.Discord_settings.DiscordWebHookUrl) 
            && configData.Discord_settings.DiscordWebHookUrl != "https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks")
            {
                webrequest.Enqueue(configData.Discord_settings.DiscordWebHookUrl, 
                (new DiscordMessage(ClearFormatting(message), configData.Discord_settings.DiscordBotName, configData.Discord_settings.DiscordAvatarLink)).ToJson(), 
                DiscordSendMessageCallback, this, RequestMethod.POST, _headers);
            }
        }

        private readonly Dictionary<string, string> _headers = new Dictionary<string, string>
		{
			{"Content-Type", "application/json"}
		};

        private class DiscordMessage
		{
			[JsonProperty("content")] private string Content { get; set; }
			[JsonProperty("username")] private string Username { get; set; }
			[JsonProperty("avatar_url")] private string AvatarURL { get; set; }

			public DiscordMessage(string content, string username, string avatarurl)
			{
				Content = content;
                Username = username;
                AvatarURL = avatarurl;
			}

			public DiscordMessage AddContent(string content)
			{
				Content = content;
				return this;
			}

			public string GetContent()
			{
				return Content;
			}

			public string ToJson()
			{
				return JsonConvert.SerializeObject(this, Formatting.None,
					new JsonSerializerSettings {NullValueHandling = NullValueHandling.Ignore});
			}
		}

        private void DiscordSendMessageCallback(int code, string message)
		{
			switch (code)
			{
				case 204:
				{
					//ignore
					return;
				}
				case 401:
					var objectJson = JsonConvert.DeserializeObject<Dictionary<string, object>>(message);
					int messageCode;
					if (objectJson["code"] != null && int.TryParse(objectJson["code"].ToString(), out messageCode))
						if (messageCode == 50027)
						{
							PrintError("Invalid Webhook Token");
							return;
						}

					break;
				case 404:
					PrintError("Invalid Webhook (404: Not Found)");
					return;
				case 405:
					PrintError("Invalid Webhook (405: Method Not Allowed)");
					return;
				case 429:
					message =
						"You are being rate limited. To avoid this try to increase queue interval in your config file.";
					break;
				case 500:
					message = "There are some issues with Discord server (500 Internal Server Error)";
					break;
				case 502:
					message = "There are some issues with Discord server (502 Bad Gateway)";
					break;
				default:
					message = $"DiscordSendMessageCallback: code = {code} message = {message}";
					break;
			}

			PrintError(message);
		}
        
        public static string ClearFormatting(string msg)
        {
            string unformatted = Regex.Replace(msg, "<.*?>", string.Empty);

            return unformatted;
        }

        #endregion
    }
}


// --- End of file: DeathMessage-1.1.2.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Ragnarok.cs ---
// --- Original Local Path: Ragnarok.cs ---

using System;
using System.Collections.Generic;
using System.Reflection;

using UnityEngine;
using Rust;

using Oxide.Core;
using Oxide.Core.Plugins;

/**
 * Rust Ragnarok Plugin; Meteor shower(s).
 *
 * @author Drefetr
 * @author JShmitt
 * @version 0.7.7
 */
namespace Oxide.Plugins
{
    [Info("Ragnarok", "Drefetr et Shmitt", "0.7.8", ResourceId = 1985)]
    public class Ragnarok : RustPlugin
    {			
		/**
		 * Minimum clockwise angular deviation from the normal vector;
		 * Where 0.0f is 0 rad, and 1.0f is 1/2 rad.
		 * (0.0f, ..., maxLaunchAngle).
		 */
		private float minLaunchAngle = 0.25f;
		
		/**
		 * Maximum clockwise angular deviation from the normal vector;
		 * Where 0.0f is 0 rad, and 1.0f is 1/2 rad.
		 * (minLaunchAngle, ..., 1.0f).
		 */
		private float maxLaunchAngle = 0.5f;
		
		/**
		 * Minimum launch height (m); suggested sensible bounds:
		 * x >= 1 * maxLaunchVelocity.
		 */
		private float minLaunchHeight = 100.0f;
	
		/**
		 * Maximum launch height (m); suggested sensible bounds:
		 * x <= 10*minLaunchVelocity.
		 */
		private float maxLaunchHeight = 250.0f;
	
		/**
		 * Minimum launch velocity (m/s^-1).
		 */
		private float minLaunchVelocity = 25.0f;
	
		/**
		 * Maximum launch velocity (m/s^-1).
		 * Suggested sensible maximum: 75.0f.
		 */
		private float maxLaunchVelocity = 75.0f;

		/**
		 * ServerTicks between Meteor(s).
		 */
		private int meteorFrequency = 10;
		
		/**
		 * Maximum number of Meteors per cluster.
		 */
		private int maxClusterSize = 5;

		/**
		 * The minimum range (+/- x, & +/- z) of a Meteor cluster.
		 */
		private int minClusterRange = 1;
		
		/**
		 * The maximum range (+/- x, & +/- z) of a Meteor clutser.
		 */
		private int maxClusterRange = 5;
		
		/**
		 * Percent chance of the Meteor dropping loose resources at the point of impact.
		 */
		private float spawnResourcePercent = 0.05f;
	
		/**
		 * Percent chance of the Meteor spawning a resource node at the point of impact.
		 */
		private float spawnResourceNodePercent = 1.0f;
	
		/**
		 * ServerTicks since OnServerInit().
		 */
		private int tickCounter = 0;
	
		/** 
		 * Server OnInit-bind; runs on server startup & mod. init.
		 */
		private void OnServerInitialized()
		{		
			// Load configuration (& call LoadDefaultConfig if the file does 
			// n't yet exist).
			this.minLaunchAngle = Convert.ToSingle(Config["MinLaunchAngle"]);		
			this.maxLaunchAngle = Convert.ToSingle(Config["MaxLaunchAngle"]);
			this.minLaunchHeight = Convert.ToSingle(Config["MinLaunchHeight"]);
			this.maxLaunchHeight = Convert.ToSingle(Config["MaxLaunchHeight"]);	
			this.minLaunchVelocity = Convert.ToSingle(Config["MinLaunchVelocity"]);			
			this.maxLaunchVelocity = Convert.ToSingle(Config["MaxLaunchVelocity"]);		
			this.meteorFrequency = (int) Config["MeteorFrequency"];			
			this.maxClusterSize = (int) Config["MaxClusterSize"];
			this.minClusterRange = (int) Config["MinClusterRange"];
			this.maxClusterRange = (int) Config["MaxClusterRange"];
			this.spawnResourcePercent = Convert.ToSingle(Config["SpawnResourcePercent"]);
			this.spawnResourceNodePercent = Convert.ToSingle(Config["SpawnResourceNodePercent"]);

			// Ensure shitty weather; clouds & fog.
			ConsoleSystem.Run.Server.Normal("weather.clouds 1");			
			ConsoleSystem.Run.Server.Normal("weather.fog 1");
		}	
	
        /**
		 * Loads & creates a default configuration file (using the properties and 
		 * values defined above).
		 */
        protected override void LoadDefaultConfig() {
			Config.Set("MinLaunchAngle", this.minLaunchAngle);
			Config.Set("MaxLaunchAngle", this.maxLaunchAngle);
			Config.Set("MinLaunchHeight", this.minLaunchHeight);
			Config.Set("MaxLaunchHeight", this.maxLaunchHeight);
			Config.Set("MinLaunchVelocity", this.minLaunchVelocity);
			Config.Set("MaxLaunchVelocity", this.maxLaunchVelocity);
			Config.Set("MeteorFrequency", this.meteorFrequency);
			Config.Set("MaxClusterSize", this.maxClusterSize);		
			Config.Set("MinClusterRange", this.minClusterRange);
			Config.Set("MaxClusterRange", this.maxClusterRange);
			Config.Set("SpawnResourcePercent", this.spawnResourcePercent);
			Config.Set("SpawnResourceNodePercent", this.spawnResourceNodePercent);
			SaveConfig();
        }
	
		/** 
		 * Server OnTick-bind; runs once per server tick --
		 * (An externally configurable frequency).
		 */
		void OnTick()
		{		
			// Spawn Meteors(s) Y/N:
			if (this.tickCounter % this.meteorFrequency == 0) {	
				// Fetch a random position, with an altitude of {0}.
				Vector3 location = this.getRandomMapPosition();
				int clusterSize = UnityEngine.Random.Range(1, this.maxClusterSize);
			
				for (int i = 0; i < clusterSize; i++) {	
					float r = UnityEngine.Random.Range(0.0f, 100.0f);
					
					// Add a (slight) degree of randomness to the launch position(s):
					location.x += UnityEngine.Random.Range(this.minClusterRange, this.maxClusterRange);
					location.z += UnityEngine.Random.Range(this.minClusterRange, this.maxClusterRange);
				
					if (r < this.spawnResourcePercent)
						// Spawn a loose resource:
						this.spawnResource(location);
				
					if (r < this.spawnResourceNodePercent)
						// Spawn a resource node:			
						this.spawnResourceNode(location);
				
					this.spawnMeteor(location);
				}
			}
			
			this.tickCounter++;
		}
				
		/**
		 * Spawns a Meteor in the location specified by Vector3(location).
		 */			
		private void spawnMeteor(Vector3 origin)
		{
			float launchAngle = UnityEngine.Random.Range(this.minLaunchAngle, this.maxLaunchAngle);
			float launchHeight = UnityEngine.Random.Range(this.minLaunchHeight, this.maxLaunchHeight);
			
			Vector3 launchDirection = (Vector3.up * -launchAngle + Vector3.right).normalized;
			Vector3 launchPosition = origin - launchDirection * launchHeight;
			
			int r = UnityEngine.Random.Range(0, 3);			
			
			ItemDefinition projectileItem;			
			
			// Fetch rocket of type <x>:
			switch (r) {
				case 0:
					projectileItem = getBasicRocket();
					break;
					
				case 1:
					projectileItem = getHighVelocityRocket();
					break;
					
				case 2:
					projectileItem = getSmokeRocket();
					break;
				
				default: 
					projectileItem = getFireRocket();
					break;
			}
		
			// Create the in-game "Meteor" entity:
			ItemModProjectile component = projectileItem.GetComponent<ItemModProjectile>();
			BaseEntity entity = GameManager.server.CreateEntity(component.projectileObject.resourcePath, launchPosition, new Quaternion(), true);

			// Set Meteor speed:
			ServerProjectile serverProjectile = entity.GetComponent<ServerProjectile>();			
			serverProjectile.speed = UnityEngine.Random.Range(this.minLaunchVelocity, this.maxLaunchVelocity);
			
			entity.SendMessage("InitializeVelocity", (object) (launchDirection * 1.0f));
			entity.Spawn(true);
		}
		
		/**
		 * Spawns a ResourceItem of a random type at the location specified by 
		 * Vector3(location).
		 */
		private void spawnResource(Vector3 location) {
			string resourceName = "";
			int resourceQuantity = 0;
			
			int r = UnityEngine.Random.Range(0, 3);
			
			switch (r) {
				case 1:
					resourceName = "hq.metal.ore";
					resourceQuantity = 100;
					break;
				
				case 2:
					resourceName = "metal.ore";
					resourceQuantity = 1000;
					break;
				
				case 3:
					resourceName = "stones";
					resourceQuantity = 2500;
					break;
				
				default:
					resourceName = "sulfur.ore";
					resourceQuantity = 1000;		
					break;
			}
			
			ItemManager.CreateByName(resourceName, resourceQuantity).Drop(location, Vector3.up);
		}
		
		/**
		 * Spawns a ResourceNode of a random type at the location specified by 
		 * Vector3(location).
		 */
		private void spawnResourceNode(Vector3 location) {
			string prefabName = "assets/bundled/prefabs/autospawn/resource/ores/";
			
			// Select a random ResourceNode type {Metal, Stone, Sulfur}.			
			int r = UnityEngine.Random.Range(0, 2);			
			
			switch (r) {
				case 1:
					prefabName += "metal-ore";
					break;
							
				case 2:
					prefabName += "stone-ore";
					break;
							
				default:
					prefabName += "sulfur-ore";						
					break;
			}			
			
			prefabName += ".prefab";
			
			// & spawn the ResourceNode at Vector3(location).
			BaseEntity resourceNode = GameManager.server.CreateEntity(prefabName, location, new Quaternion(0, 0, 0, 0));			
			resourceNode.Spawn(true);
		}
		
		/**
		 * Returns an Item of type "ammo.rocket.basic":
		 */
		private ItemDefinition getBasicRocket()
		{
			return ItemManager.FindItemDefinition("ammo.rocket.basic");
		}
		
		/**
		 * Returns an Item of type "ammo.rocket.fire":
		 */		
		private ItemDefinition getFireRocket()
		{
			return ItemManager.FindItemDefinition("ammo.rocket.fire");
		}
		
		/**
		 * Returns an Item of type "ammo.rocket.hv":
		 */
		private ItemDefinition getHighVelocityRocket() {
			return ItemManager.FindItemDefinition("ammo.rocket.hv");
		}
		
		/**
		 * Returns an Item of type "ammo.rocket.smoke":
		 */
		private ItemDefinition getSmokeRocket() {
			return ItemManager.FindItemDefinition("ammo.rocket.smoke");
		}	

		/**
		 * Returns a random Map position (x, y).
		 */
		private Vector3 getRandomMapPosition() {
			float mapsize = getMapSize() - 500f;			
			float randomX = UnityEngine.Random.Range(-mapsize, mapsize);
			float randomY = UnityEngine.Random.Range(-mapsize, mapsize);					
			return new Vector3(randomX, 0f, randomY);
		}
		
		/**
		 * Returns the current Map size, -assumed square- (x, y).
		 */
		private float getMapSize()
		{
			return TerrainMeta.Size.x / 2;
		}			
    }
}

// --- End of file: Ragnarok.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TimeSystem.cs ---
// --- Original Local Path: TimeSystem.cs ---

﻿using Oxide.Core.Plugins;
using Oxide.Core;
using System;
using System.Text;
using System.Collections.Generic;
using System.Globalization;
using UnityEngine;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Time System", "Nimant", "1.0.1")]    
    public class TimeSystem : RustPlugin
    {
		
		#region Variables
		
		private bool Initialized;
		private int componentSearchAttempts = 0;
		private TOD_Time timeComponent = null;
		private bool activatedDay;							
		
		#endregion
		
		#region Hooks

		private void Init()
		{
			LoadVariables();
			Initialized = false;
		}

		private void Unload()
		{
			if (timeComponent == null || !Initialized) return;									
			timeComponent.OnSunrise -= OnSunrise;
            timeComponent.OnSunset -= OnSunset;			
			timeComponent.OnHour -= OnHour;
		}

		private void OnServerInitialized()
		{
			if (TOD_Sky.Instance == null)
            {
				componentSearchAttempts++;
                if (componentSearchAttempts < 100)
                    timer.Once(1f, OnServerInitialized);
                else
                    PrintWarning("Не найден нужный компонент времени, плагин не активен!");
                return;
            }
            timeComponent = TOD_Sky.Instance.Components.Time;
            if (timeComponent == null)
            {
                PrintWarning("Невозможно извлечь компонент времени, плагин не активен!");
                return;
            }			
			SetTimeComponent();			
		}
		
		private void OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (arg == null || arg.cmd == null || string.IsNullOrEmpty(arg.cmd.FullName)) return;
			var command = arg.cmd.FullName;						
			if (!command.ToLower().Contains("env.")) return;						
			var player = arg.Player();
			if (player != null && !player.IsAdmin) return;
									
			timer.Once(0.5f, OnHour);
		}	

		#endregion
		
		#region Main
		
        private void SetTimeComponent()
        {
            timeComponent.ProgressTime = true;
            timeComponent.UseTimeCurve = false;									
            timeComponent.OnSunrise += OnSunrise;
			timeComponent.OnSunset += OnSunset;			
			timeComponent.OnHour += OnHour;
			Initialized = true;
			
            if (TOD_Sky.Instance.Cycle.Hour >= configData.DayStart && TOD_Sky.Instance.Cycle.Hour < configData.NightStart)
			{
				activatedDay = false;		
                OnSunrise();
			}	
            else
			{	
				activatedDay = true;
                OnSunset();					
			}	
        }				        						
		
        private void OnHour()
        {
			if (!Initialized) return;																		
			if (TOD_Sky.Instance.Cycle.Hour >= configData.DayStart && TOD_Sky.Instance.Cycle.Hour < configData.NightStart && !activatedDay)
			{				
				OnSunrise();				
				return;
			}
			if ((TOD_Sky.Instance.Cycle.Hour >= configData.NightStart || TOD_Sky.Instance.Cycle.Hour < configData.DayStart) && activatedDay)
			{			
				OnSunset();
				return;
			}
		}

        private void OnSunrise()
        {
			if (!Initialized) return;						
			if (!(TOD_Sky.Instance.Cycle.Hour >= configData.DayStart && TOD_Sky.Instance.Cycle.Hour < configData.NightStart && !activatedDay)) return;						
			
			timeComponent.DayLengthInMinutes = configData.DayLength * (24.0f / (configData.NightStart - configData.DayStart));
			if (!activatedDay)
				Interface.CallHook("OnTimeSunrise");
			activatedDay = true;
        }

        private void OnSunset()
        {
			if (!Initialized) return;						
			if (!((TOD_Sky.Instance.Cycle.Hour >= configData.NightStart || TOD_Sky.Instance.Cycle.Hour < configData.DayStart) && activatedDay)) return;						
			
			timeComponent.DayLengthInMinutes = configData.NightLength * (24.0f / (24.0f - (configData.NightStart - configData.DayStart)));
			if (activatedDay)
				Interface.CallHook("OnTimeSunset");
			activatedDay = false;
        }        
		
		#endregion
		
		#region Config        				
		
        private ConfigData configData;
		
        private class ConfigData
        {            						
			[JsonProperty(PropertyName = "Час когда начинается день (восход)")]
			public int DayStart;
			[JsonProperty(PropertyName = "Час когда начинается ночь (закат)")]
			public int NightStart;
			[JsonProperty(PropertyName = "Длительность дня (в минутах)")]
			public int DayLength;
			[JsonProperty(PropertyName = "Длительность ночи (в минутах)")]
			public int NightLength;
        }
		
        private void LoadVariables() => configData = Config.ReadObject<ConfigData>();        
		
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
				DayStart = 8,
				NightStart = 19,
                DayLength = 30,
				NightLength = 15
            };
            SaveConfig(config);
			timer.Once(0.1f, ()=>SaveConfig(config));
        }        
		
        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
		
        #endregion

    }
}

// --- End of file: TimeSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Kits2.cs ---
// --- Original Local Path: Kits2.cs ---

﻿﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;
namespace Oxide.Plugins
{
    [Info("Kits", "By Denzoff", "1.1.2")]
    class Kits : RustPlugin
    {
        [PluginReference] Plugin ImageLibrary;
        static Kits ins;
        private PluginConfig config;
        private List<Kit> kitsList;
        private Dictionary<ulong, Dictionary<string, KitData>> PlayersData;
        private Dictionary<BasePlayer, List<Kit>> OpenGUI = new Dictionary<BasePlayer, List<Kit>>();
        public List<BasePlayer> AdminSetting = new List<BasePlayer>();
        private class RarityColor
        {
            [JsonProperty("Шанс выпадения предмета данной редкости")] public int Chance;
            [JsonProperty("Цвет этой редкости в интерфейсе")] public string Color;
            public RarityColor(int chance, string color)
            {
                Chance = chance;
                Color = color;
            }
        }
        class PluginConfig
        {
            [JsonProperty("Кастомные автокиты по привилегии (Привилегию устанавливаете в настройке кита) | Custom autokit, install privilege in the configuration of the kit")] public List<string> CustomAutoKits;
            [JsonProperty("Префикс чата | Chat Prefix")]
            public string DefaultPrefix
            {
                get;
                set;
            }
            [JsonProperty("Настройка цвета предмета по шансу")] public List<RarityColor> RaritiesColor = new List<RarityColor>();
            [JsonProperty("Версия конфигурации | Configuration Version")] public VersionNumber PluginVersion = new VersionNumber();
            public static PluginConfig CreateDefault()
            {
                return new PluginConfig
                {
                    CustomAutoKits = new List<string>() {
                        "autokit1", "autokit2"
                    }
                    ,
                    DefaultPrefix = "[Kit]",
                    PluginVersion = new VersionNumber(),
                    RaritiesColor = new List<RarityColor> {
                        new RarityColor(40, "1.00 1.00 1.00 0.3"), new RarityColor(30, "0.68 0.87 1.00 0.3"), new RarityColor(20, "0.77 0.65 1.00 0.3"), new RarityColor(10, "1.00 0.68 0.17 0.3"),
                    }
                    ,
                }
                ;
            }
        }
        public class Kit
        {
            public string Name
            {
                get;
                set;
            }
            public string DisplayName
            {
                get;
                set;
            }
            public int Amount
            {
                get;
                set;
            }
            public double Cooldown
            {
                get;
                set;
            }
            public bool Hide
            {
                get;
                set;
            }
            public string Permission
            {
                get;
                set;
            }
            public string Color
            {
                get;
                set;
            }
            public List<KitItem> Items
            {
                get;
                set;
            }
        }
        public class KitItem
        {
            public string ShortName
            {
                get;
                set;
            }
            public int Amount
            {
                get;
                set;
            }
            public int Blueprint
            {
                get;
                set;
            }
            public ulong SkinID
            {
                get;
                set;
            }
            public string Container
            {
                get;
                set;
            }
            public float Condition
            {
                get;
                set;
            }
            public int Change
            {
                get;
                set;
            }
          
            public bool EnableCommand { get; set; }
            [JsonProperty("Command (Player identifier %STEAMID%)")]
            public string Command { get; set; }
            public string CustomImage { get; set; }
            public Weapon Weapon
            {
                get;
                set;
            }
            public List<ItemContent> Content
            {
                get;
                set;
            }
        }
        public class Weapon
        {
            public string ammoType
            {
                get;
                set;
            }
            public int ammoAmount
            {
                get;
                set;
            }
        }
        public class ItemContent
        {
            public string ShortName
            {
                get;
                set;
            }
            public float Condition
            {
                get;
                set;
            }
            public int Amount
            {
                get;
                set;
            }
        }
        public class KitData
        {
            public int Amount
            {
                get;
                set;
            }
            public double Cooldown
            {
                get;
                set;
            }
        }
        public class Position
        {
            public string AnchorMin
            {
                get;
                set;
            }
            public string AnchorMax
            {
                get;
                set;
            }
        }
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Благодарим за приобритение плагина на сайте RustPlugin.ru. Если вы приобрели этот плагин на другом ресурсе знайте - это лишает вас гарантированных обновлений!");
            Config.Clear();
            Config.WriteObject(PluginConfig.CreateDefault(), true);
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            if (config.PluginVersion < Version) UpdateConfigValues();
            Config.WriteObject(config, true);
        }
        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.CreateDefault();
            if (config.PluginVersion < Version)
            {
                PrintWarning("Config update detected! Updating config values...");
                PrintWarning("Config update completed!");
            }
            config.PluginVersion = Version;
        }
        void OnPlayerRespawned(BasePlayer player)
        {
            foreach (var kits in config.CustomAutoKits)
            {
                if (kitsList.Exists(x => x.Name == kits))
                {
                    var kit1 = kitsList.First(x => x.Name.ToLower() == kits.ToLower());
                    if (permission.UserHasPermission(player.UserIDString, kit1.Permission))
                    {
                        player.inventory.Strip();
                        GiveItems(player, kit1);
                        return;
                    }
                }
            }
            if (kitsList.Exists(x => x.Name.ToLower() == "autokit"))
            {
                player.inventory.Strip();
                var kit = kitsList.First(x => x.Name.ToLower() == "autokit");
                GiveItems(player, kit);
            }
        }
        private void SaveKits()
        {
            Interface.Oxide.DataFileSystem.WriteObject("Kits/KitsList", kitsList);
        }
        private void SaveData()
        {
            if (PlayersData != null) Interface.Oxide.DataFileSystem.WriteObject("Kits/PlayersData", PlayersData);
        }
        void OnServerSave()
        {
            SaveData();
            SaveKits();
        }
        private void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Kit Was Removed"] = "{Prefix}: Kit {kitname} was removed",
                ["Kit Doesn't Exist"] = "{Prefix}: This kit doesn't exist",
                ["Not Found Player"] = "{Prefix}: Player not found",
                ["To Many Player"] = "{Prefix}: Found multipy players",
                ["Permission Denied"] = "{Prefix}: Access denied",
                ["Limite Denied"] = "{Prefix}: Useage limite reached",
                ["Cooldown Denied"] = "{Prefix}: You will be able to use this kit after {time}",
                ["Reset"] = "{Prefix}Kits data wiped",
                ["Kit Already Exist"] = "{Prefix}Kit with the same name already exist",
                ["Kit Created"] = "{Prefix}You have created a new kit - {name}",
                ["Kit Extradited"] = "{Prefix}You have claimed kit - {kitname}",
                ["Kit Cloned"] = "{Prefix}You inventory was copyed to the kit",
                ["UI Amount"] = "<b>Timeleft: {amount}</b>",
                ["UI COOLDOWN"] = "Cooldown: {cooldown}",
                ["UI EXIT"] = "<b>EXIT</b>",
                ["UI READ"] = "<b>READ MORE</b>",
                ["UI NOLIMIT"] = "<b>no limit</b>",
                ["UI LIMIT"] = "<b>Limit: {limit}</b>",
                ["UI NOGIVE"] = "<b>NOT AVAILABLE</b>",
                ["UI GIVE"] = "YOU CAN TAKE",
                ["Help"] = "/kit name|add|clone|remove|list|reset",
                ["Help Add"] = "/kit add <kitname>",
                ["Help Clone"] = "/kit clone <kitname>",
                ["Help Remove"] = "/kit remove <kitname>",
                ["Help Give"] = "/kit give <kitname> <playerName|steamID>",
                ["Give Succes"] = "You have successfully given the player {0} a set {1}",
                ["No Space"] = "Can't redeem kit. Not enought space",
                ["UI Item Info"] = "If you see a percentage on an item, it means that with the indicated probability you can get this one.",
                ["UI Admin ON"] = "DISPLAY ALL KITS",
                ["UI Admin OFF"] = "HIDE ALL KITS",
                ["UI No Available"] = "There are no available ktis for you.",
            }
            , this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Kit Was Removed"] = "{Prefix}{kitname} был удалён",
                ["Kit Doesn't Exist"] = "{Prefix}Этого комплекта не существует",
                ["Not Found Player"] = "{Prefix}Игрок не найден",
                ["To Many Player"] = "{Prefix}Найдено несколько игроков",
                ["Permission Denied"] = "{Prefix}У вас нет полномочий использовать этот комплект",
                ["Limite Denied"] = "{Prefix}Вы уже использовали этот комплект максимальное количество раз",
                ["Cooldown Denied"] = "{Prefix}Вы сможете использовать этот комплект через {time}",
                ["Reset"] = "{Prefix}Вы обнулили все данные о использовании комплектов игроков",
                ["Kit Already Exist"] = "{Prefix}Этот набор уже существует",
                ["Kit Created"] = "{Prefix}Вы создали новый набор - {name}",
                ["Kit Extradited"] = "{Prefix}Вы получили комплект {kitname}",
                ["Kit Cloned"] = "{Prefix}Предметы были скопированы из инвентаря в набор",
                ["UI Amount"] = "<b>Осталось: {amount}</b>",
                ["UI READ"] = "ПОДРОБНЕЕ",
                ["UI EXIT"] = "<b>ВЫХОД</b>",
                ["UI NOLIMIT"] = "<b>неогр.</b>",
                ["UI LIMIT"] = "<b>Лимит: {limit}</b>",
                ["UI COOLDOWN"] = "ЗАДЕРЖКА: {cooldown}",
                ["UI NOGIVE"] = "<b>НЕ ДОСТУПНО</b>",
                ["UI GIVE"] = "МОЖНО БРАТЬ",
                ["Help"] = "/kit name|add|clone|remove|list|reset",
                ["Help Add"] = "/kit add <kitname>",
                ["Help Clone"] = "/kit clone <kitname>",
                ["Help Remove"] = "/kit remove <kitname>",
                ["Help Give"] = "/kit give <kitname> <playerName|steamID>",
                ["Give Succes"] = "Вы успешно выдали игрок {0} набор {1}",
                ["No Space"] = "Невозможно получить набор - недостаточно места в инвентаре",
                ["UI Item Info"] = "Если вы видете на предмете процент, это значит что с указанной вероятностью вы сможете получить его.",
                ["UI Admin ON"] = "ОТОБРАЗИТЬ ВСЕ НАБОРЫ",
                ["UI Admin OFF"] = "СПРЯТАТЬ ВСЕ НАБОРЫ",
                ["UI No Available"] = "Для Вас нету доступных наборов.",
            }
            , this, "ru");
        }
        private void Loaded()
        {
            config = Config.ReadObject<PluginConfig>();
            LoadData();
            LoadMessages();
        }
        void LoadData()
        {
            try
            {
                kitsList = Interface.Oxide.DataFileSystem.ReadObject<List<Kit>>("Kits/KitsList");
                PlayersData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, Dictionary<string, KitData>>>("Kits/PlayersData");
            }
            catch
            {
                kitsList = new List<Kit>();
                PlayersData = new Dictionary<ulong, Dictionary<string, KitData>>();
            }
            CheckKits();
        }
        private void Unload()
        {
            SaveData();
            foreach (var plobj in BasePlayer.activePlayerList)
            {
                DestroyUI(plobj);
            }
        }
        public bool AddImage(string url, string name, ulong skin) => (bool)ImageLibrary?.Call("AddImage", url, name, skin);
        public string GetImage(string shortname, ulong skin = 0) => (string)ImageLibrary.Call("GetImage", shortname, skin);
        private void OnServerInitialized()
        {
            ins = this;
            foreach (var kit in kitsList)
            {
                if (!permission.PermissionExists(kit.Permission)) permission.RegisterPermission(kit.Permission, this);
            }
            ImageLibrary.Call("AddImage", $"https://cdn.discordapp.com/attachments/1145344230273851484/1213207670505476117/eryhfgh.png?ex=65f4a2b0&is=65e22db0&hm=1cf4fd33e1e9bbdf54609e9ad73a35dddb8575e9c54e40052a157506b8063dcf&", $"mailbox_1812087291");
            kitsList.ForEach(kit => 
               kit.Items.ForEach(item =>
               {
                   if (!string.IsNullOrEmpty(item.CustomImage))
                       ImageLibrary.Call("AddImage", item.CustomImage, item.CustomImage);
               })
           );
            timer.Repeat(1, 0, RefreshCooldownKitsUI);
        }
        void CheckKits()
        {
            kitsList.ForEach(kit =>
            {
                if (kit.Color == null) kit.Color = "0.55 0.68 0.31 0.6";
                kit.Items.ForEach(item =>
                {
                    if (item.Change <= 0) item.Change = 100;
                }
                );
            }
            );
            SaveKits();
        }
        private void OnPlayerDisconnected(BasePlayer player)
        {
            OpenGUI.Remove(player);
        }
        [ConsoleCommand("kit")]
        private void cmdConsoleGiveKit(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null)
            {
                if (arg.Args[0].ToLower() == "give")
                {
                    var target = BasePlayer.Find(arg.Args[1]);
                    var kitname = arg.Args[2]; 
                    if (target != null) GiveKit(target, kitname, 0, true);
                    return;
                }
            }
            var player = arg.Player();
            var page = int.Parse(arg.Args[1]);
            if (!arg.HasArgs()) return;
            var value = arg.Args[0].ToLower();
            if (value == "ui")
            {
                CuiHelper.DestroyUi(player, $"ui.kits.{arg.Args[2]}.info");
                TriggerUI(player, page);
                return;
            }
            if (!OpenGUI.ContainsKey(player)) return;
            if (!OpenGUI[player].Contains(kitsList.First(kits => kits.Name.ToLower() == value.ToLower()))) return;
            GiveKit(player, value, page);
            var container = new CuiElementContainer();
            var kit = kitsList.First(x => x.Name.ToLower() == value.ToLower());
            var playerData = GetPlayerData(value, player.userID);
            if (kit.Amount > 0)
            {
                if (playerData.Amount >= kit.Amount)
                {
                    InitilizeKitsUI(player, 0);
                    CuiHelper.AddUi(player, container);
                    return;
                }
            }
            if (kit.Cooldown > 0)
            {
                var currentTime = GetCurrentTime();
                if (playerData.Cooldown > currentTime)
                {
                    DestroyUI(player);
                    TriggerUI(player, page);
                }
            }
            CuiHelper.AddUi(player, container);
            return;
        }
        [ChatCommand("kit")]
        private void CommandChatKit(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            if (args.Length == 0)
            {
                TriggerUI(player, 0);
                return;
            }
            if (!player.IsAdmin)
            {
                GiveKit(player, args[0].ToLower(), 0);
                return;
            }
            switch (args[0].ToLower())
            {
                case "help":
                    SendReply(player, GetMsg("Help", player));
                    return;
                case "add":
                    if (args.Length < 2) SendReply(player, GetMsg("Help Add", player));
                    else KitCommandAdd(player, args[1].ToLower());
                    return;
                case "clone":
                    if (args.Length < 2) SendReply(player, GetMsg("Help Clone", player));
                    else KitCommandClone(player, args[1].ToLower());
                    return;
                case "remove":
                    if (args.Length < 2) SendReply(player, GetMsg("Help Remove", player));
                    else KitCommandRemove(player, args[1].ToLower());
                    return;
                case "list":
                    KitCommandList(player);
                    return;
                case "reset":
                    KitCommandReset(player);
                    return;
                case "give":
                    if (args.Length < 3)
                    {
                        SendReply(player, GetMsg("Help Give", player));
                    }
                    else
                    {
                        var foundPlayer = FindPlayer(player, args[1].ToLower());
                        if (foundPlayer == null) return;
                        SendReply(player, GetMsg("Give Succes", player), foundPlayer.displayName, args[2]);
                        KitCommandGive(player, foundPlayer, args[2].ToLower());
                    }
                    return;
                default:
                    GiveKit(player, args[0].ToLower(), 0);
                    return;
            }
        }
        private bool GiveKit(BasePlayer player, string kitname, int page = -1, bool admin = false)
        {
            if (string.IsNullOrEmpty(kitname)) return false;
            if (Interface.Oxide.CallHook("canRedeemKit", player) != null && page > -1) return false;
            if (!kitsList.Exists(x => x.Name.ToLower() == kitname.ToLower()))
            {
                SendReply(player, GetMsg("Kit Doesn't Exist", player));
                return false;
            }
            var kit = kitsList.First(x => x.Name.ToLower() == kitname.ToLower());
            if (!string.IsNullOrEmpty(kit.Permission) && !permission.UserHasPermission(player.UserIDString, kit.Permission) && !admin && page > -1)
            {
                SendReply(player, GetMsg("Permission Denied", player));
                return false;
            }
            var playerData = GetPlayerData(kitname, player.userID);
            if (kit.Amount > 0 && playerData.Amount >= kit.Amount && !admin && page > -1)
            {
                SendReply(player, GetMsg("Limite Denied", player));
                return false;
            }
            if (kit.Cooldown > 0 && !admin && page > -1)
            {
                var currentTime = GetCurrentTime();
                if (playerData.Cooldown > currentTime)
                {
                    SendReply(player, GetMsg("Cooldown Denied", player).Replace("{time}", TimeExtensions.FormatTime(TimeSpan.FromSeconds(playerData.Cooldown - currentTime))));
                    return false;
                }
            }
            int beltcount = kit.Items.Where(i => i.Container == "belt").Count();
            int wearcount = kit.Items.Where(i => i.Container == "wear").Count();
            int maincount = kit.Items.Where(i => i.Container == "main").Count();
            int totalcount = beltcount + wearcount + maincount;
            if ((player.inventory.containerBelt.capacity - player.inventory.containerBelt.itemList.Count) < beltcount || (player.inventory.containerWear.capacity - player.inventory.containerWear.itemList.Count) < wearcount || (player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count) < maincount) if (totalcount > (player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count))
                {
                    player.ChatMessage(GetMsg("No Space", player));
                    return false;
                }
            GiveItems(player, kit);
            if (page > -1)
            {
                if (kit.Amount > 0)
                {
                    playerData.Amount += 1;
                }
                if (kit.Cooldown > 0) playerData.Cooldown = GetCurrentTime() + kit.Cooldown;
                EffectNetwork.Send(new Effect("assets/prefabs/misc/xmas/presents/effects/unwrap.prefab", player, 0, Vector3.up, Vector3.zero)
                {
                    scale = UnityEngine.Random.Range(0f, 1f)
                }
                );
                SendReply(player, GetMsg("Kit Extradited", player).Replace("{kitname}", kit.DisplayName));
                DestroyUI(player);
                TriggerUI(player, page);
            }
            return true;
        }
        private void KitCommandAdd(BasePlayer player, string kitname)
        {
            if (kitsList.Exists(x => x.Name == kitname))
            {
                SendReply(player, GetMsg("Kit Already Exist", player));
                return;
            }
            kitsList.Add(new Kit
            {
                Name = kitname,
                DisplayName = kitname,
                Cooldown = 600,
                Hide = true,
                Permission = "kits.default",
                Amount = 0,
                Color = "0.55 0.68 0.31 0.6",
                Items = GetPlayerItems(player)
            }
            );
            permission.RegisterPermission($"kits.default", this);
            SendReply(player, GetMsg("Kit Created", player).Replace("{name}", kitname));
            SaveKits();
            SaveData();
        }
        private void KitCommandClone(BasePlayer player, string kitname)
        {
            if (!kitsList.Exists(x => x.Name == kitname))
            {
                SendReply(player, GetMsg("Kit Doesn't Exist", player));
                return;
            }
            kitsList.First(x => x.Name.ToLower() == kitname.ToLower()).Items = GetPlayerItems(player);
            SendReply(player, GetMsg("Kit Cloned", player).Replace("{name}", kitname));
            SaveKits();
        }
        private void KitCommandRemove(BasePlayer player, string kitname)
        {
            if (kitsList.RemoveAll(x => x.Name == kitname) <= 0)
            {
                SendReply(player, GetMsg("Kit Doesn't Exist", player));
                return;
            }
            SendReply(player, GetMsg("Kit Was Removed", player).Replace("{kitname}", kitname));
            SaveKits();
        }
        private void KitCommandList(BasePlayer player)
        {
            foreach (var kit in kitsList) SendReply(player, $"{kit.Name} - {kit.DisplayName}");
        }
        private void KitCommandReset(BasePlayer player)
        {
            PlayersData.Clear();
            SendReply(player, GetMsg("Reset", player));
        }
        private void KitCommandGive(BasePlayer player, BasePlayer foundPlayer, string kitname)
        {
            var reply = 1;
            if (reply == 0) { }
            if (!kitsList.Exists(x => x.Name == reply.ToString())) { }
            if (!kitsList.Exists(x => x.Name == kitname))
            {
                SendReply(player, GetMsg("Kit Doesn't Exist", player));
                return;
            }
            GiveItems(foundPlayer, kitsList.First(x => x.Name.ToLower() == kitname.ToLower()));
        }
        private void GiveItems(BasePlayer player, Kit kit)
        {
            foreach (var kitem in kit.Items)
            {
                if (kitem.EnableCommand && !string.IsNullOrEmpty(kitem.Command))
                {
                    Server.Command(kitem.Command.Replace("%STEAMID%", player.UserIDString));
                    continue;
                }
                GiveItem(player, BuildItem(kitem.ShortName, kitem.Amount, kitem.SkinID, kitem.Condition, kitem.Blueprint, kitem.Weapon, kitem.Content), kitem.Change, kitem.Container == "belt" ? player.inventory.containerBelt : kitem.Container == "wear" ? player.inventory.containerWear : player.inventory.containerMain);
            }
        }
        private void GiveItem(BasePlayer player, Item item, int percent, ItemContainer cont = null)
        {
            if (item == null) return;
            var inv = player.inventory;
            if (UnityEngine.Random.Range(1, 100) < percent)
            {
                var moved = item.MoveToContainer(cont) || item.MoveToContainer(inv.containerMain);
                if (!moved)
                {
                    if (cont == inv.containerBelt) moved = item.MoveToContainer(inv.containerWear);
                    if (cont == inv.containerWear) moved = item.MoveToContainer(inv.containerBelt);
                }
                if (!moved) item.Drop(player.GetCenter(), player.GetDropVelocity());
            }
        }
        private Item BuildItem(string ShortName, int Amount, ulong SkinID, float Condition, int blueprintTarget, Weapon weapon, List<ItemContent> Content)
        {
            Item item = ItemManager.CreateByName(ShortName, Amount > 1 ? Amount : 1, SkinID);
            item.condition = Condition;
            if (blueprintTarget != 0) item.blueprintTarget = blueprintTarget;
            if (weapon != null)
            {
                (item.GetHeldEntity() as BaseProjectile).primaryMagazine.contents = weapon.ammoAmount;
                (item.GetHeldEntity() as BaseProjectile).primaryMagazine.ammoType = ItemManager.FindItemDefinition(weapon.ammoType);
            }
            if (Content != null)
            {
                foreach (var cont in Content)
                {
                    Item new_cont = ItemManager.CreateByName(cont.ShortName, cont.Amount);
                    new_cont.condition = cont.Condition;
                    new_cont.MoveToContainer(item.contents);
                }
            }
            return item;
        }
        [ConsoleCommand("kits.page")]
        void cmdKitsPage(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            var page = int.Parse(args.Args[0]);
            InitilizeKitsUI(player, page);
        }
        private void TriggerUI(BasePlayer player, int page)
        {
            if (OpenGUI.ContainsKey(player)) DestroyUI(player);
            else InitilizeUI(player, page);
        }
        private void InitilizeUI(BasePlayer player, int page)
        {
            CuiHelper.DestroyUi(player, $"ui.kits.info");
            var kits = GetKitsForPlayer(player).ToList();
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                Image = {
                    Color="0.19 0.19 0.18 0.6", /*Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" */
				}
                ,
                RectTransform = {
                    AnchorMin="0 0", AnchorMax="1 1"
                }
                ,
                CursorEnabled = true
            }
            , "Overlay", "ui.kits");
            CuiHelper.AddUi(player, container);
            InitilizeKitsUI(player, page);
        }
        private void DestroyUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, $"ui.kits.info");
            if (!OpenGUI.ContainsKey(player)) return;
            foreach (var kitname in OpenGUI[player])
            {
                CuiHelper.DestroyUi(player, $"ui.kits.{kitname}.time");
                CuiHelper.DestroyUi(player, $"ui.kits.{kitname}.mask");
                CuiHelper.DestroyUi(player, $"ui.kits.{kitname}.button");
                CuiHelper.DestroyUi(player, $"ui.kits.{kitname}.amount");
                CuiHelper.DestroyUi(player, $"ui.kits.{kitname}");
            }
            CuiHelper.DestroyUi(player, "ui.kits");
            OpenGUI.Remove(player);
        }
        private void RefreshCooldownKitsUI()
        {
            var currentTime = GetCurrentTime();
            List<Kit> toRemove = new List<Kit>();
            foreach (var playerGUIData in OpenGUI)
            {
                if (!PlayersData.ContainsKey(playerGUIData.Key.userID)) continue;
                var playerKitsData = PlayersData[playerGUIData.Key.userID];
                foreach (var kitname in playerGUIData.Value)
                {
                    var playerKitData = playerKitsData[kitname.Name];
                    if (playerKitData.Cooldown > 0)
                    {
                        if (playerKitData.Cooldown > currentTime)
                        {
                            var container = new CuiElementContainer();
                            InitilizeCooldown(ref container, playerGUIData.Key, kitname, 0);
                            CuiHelper.AddUi(playerGUIData.Key, container);
                        }
                    }
                }
                toRemove.ForEach(p => OpenGUI[playerGUIData.Key].Remove(p));
            }
        }
        private string FormatTime(double time)
        {
            TimeSpan dateDifference = TimeSpan.FromSeconds(time);
            var days = dateDifference.Days;
            var hours = dateDifference.Hours;
            hours += (days * 24);
            var mins = dateDifference.Minutes;
            var secs = dateDifference.Seconds;
            if (hours > 0) return string.Format("{0:00}:{1:00}:{2:00}", hours, mins, secs);
            else return string.Format("{0:00}:{1:00}", mins, secs);
        }
        private void InitilizeKitsUI(BasePlayer player, int page = 0)
        {
            CuiHelper.DestroyUi(player, $"ui.kits1");
            OpenGUI[player] = new List<Kit>();
            var currentTime = GetCurrentTime();
            var kits = GetKitsForPlayer(player).Skip(5 * page).Take(5).ToList();
            int i = 0;
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                Image = {
                    Color="1 1 1 0"
                }
                ,
                RectTransform = {
                    AnchorMin=$"0 0", AnchorMax=$"1 1"
                }
            }
            , "ui.kits", $"ui.kits1");
            container.Add(new CuiElement
            {
                Parent = "ui.kits1",
                Components = {
                    new CuiButtonComponent {
                        Color="0.16 0.15 0.31 0", Command=$"kit ui {page} 1"
                    }
                    , new CuiRectTransformComponent {
                        AnchorMin="-100 -100", AnchorMax="100 100", OffsetMax="0 0"
                    }
                    ,
                }
                ,
            }
            );
            var pos = 0.5f - (GetKitsForPlayer(player).Skip(5 * page).Take(5).Count() * 0.175f + (GetKitsForPlayer(player).Skip(5 * page).Take(5).Count() - 1) * 0.005f) / 2;
            if (kits.Count > 0) foreach (var kit in kits)
                {
                    CuiHelper.DestroyUi(player, $"ui.kits.{kit.Name}");
                    OpenGUI[player].Add(kit);
                    var playerData = GetPlayerData(kit.Name, player.userID);
                    container.Add(new CuiPanel
                    {
                        Image = {
                        Color="0.43 0.43 0.42 0"
                    }
                        ,
                        RectTransform = {
                        AnchorMin=$"{pos} 0.43", AnchorMax=$"{pos + 0.175f} 0.57"
                    }
                    }
                    , "ui.kits1", $"ui.kits.main.{kit.Name}");
                    container.Add(new CuiPanel
                    {
                        Image = {
                        Color="1 1 1 0.25"
                    }
                        ,
                        RectTransform = {
                        AnchorMin=$"0 0.32", AnchorMax=$"1 0.99"
                    }
                    }
                    , $"ui.kits.main.{kit.Name}", $"ui.kits.{kit.Name}");
                    pos += 0.175f + 0.005f;
                    InitilizeCooldown(ref container, player, kit, page);
                    container.Add(new CuiButton
                    {
                        Button = {
                        Color="0.75 0.75 0.75 0.5", Command=$"kit.drawkitinfo {kit.Name} {page}", /*Material = "assets/content/ui/ui.background.transparent.radial.psd",*/
					}
                        ,
                        RectTransform = {
                        AnchorMin="0 0.01", AnchorMax="1 0.28"
                    }
                        ,
                        Text = {
                        Text="", Font="robotocondensed-regular.ttf", Align=TextAnchor.MiddleCenter, FontSize=18
                    }
                    }
                    , $"ui.kits.main.{kit.Name}", $"ui.kits.{kit.Name}.button");
                    container.Add(new CuiElement
                    {
                        Parent = $"ui.kits.{kit.Name}.button",
                        Components = {
                        new CuiTextComponent {
                            FadeIn=0.1f, Color="1 1 1 1", Text=GetMsg("UI READ", player).ToUpper(), FontSize=18, Font="robotocondensed-bold.ttf", Align=TextAnchor.MiddleCenter,
                        }
                        , new CuiRectTransformComponent {
                            AnchorMin=$"0 0", AnchorMax=$"1 1"
                        }
                        , new CuiOutlineComponent {
                            Color="0 0 0 0.3", Distance="-0.5 0.5"
                        }
                    }
                        ,
                    }
                    );
                    i++;
                }
            else container.Add(new CuiElement
            {
                Parent = "ui.kits1",
                Components = {
                    new CuiTextComponent {
                        FadeIn=1f, Color="1 1 1 0.5", Text=GetMsg("UI No Available", player).ToUpper(), FontSize=35, Font="robotocondensed-bold.ttf", Align=TextAnchor.MiddleCenter,
                    }
                    , new CuiRectTransformComponent {
                        AnchorMin=$"0 0.4", AnchorMax=$"1 0.6"
                    }
                    , new CuiOutlineComponent {
                        Color="0 0 0 0.3", Distance="-0.5 0.5"
                    }
                }
                ,
            }
            );
            if (player.IsAdmin)
            {
                container.Add(new CuiPanel
                {
                    Image = {
                        Color="1 1 1 0.01", Material="assets/content/ui/uibackgroundblur-ingamemenu.mat"
                    }
                    ,
                    RectTransform = {
                        AnchorMin="0.8 0.37", AnchorMax="0.95 0.41"
                    }
                    ,
                }
                , $"ui.kits1", "kits.adminSettings");
                container.Add(new CuiPanel
                {
                    Image = {
                        Color=AdminSetting.Contains(player) ? "1 1 1 0.7": "1 1 1 0.1", Material="assets/content/ui/uibackgroundblur-ingamemenu.mat"
                    }
                    ,
                    RectTransform = {
                        AnchorMin="0.01 0.2", AnchorMax="0.1 0.8"
                    }
                    ,
                }
                , "kits.adminSettings");
                container.Add(new CuiElement
                {
                    Parent = "kits.adminSettings",
                    Components = {
                        new CuiTextComponent {
                            Color="1 1 1 1", Text=AdminSetting.Contains(player) ? GetMsg("UI Admin OFF", player): GetMsg("UI Admin ON", player), FontSize=12, Font="robotocondensed-regular.ttf", Align=TextAnchor.MiddleCenter,
                        }
                        , new CuiRectTransformComponent {
                            AnchorMin=$"0.1 0", AnchorMax=$"1 1"
                        }
                        , new CuiOutlineComponent {
                            Color="0 0 0 0.3", Distance="-0.5 0.5"
                        }
                    }
                    ,
                }
                );
                container.Add(new CuiButton
                {
                    Button = {
                        Color="1 1 1 0", Command=$"UIkits_adminSettings {page}"
                    }
                    ,
                    RectTransform = {
                        AnchorMin="0 0", AnchorMax="1 1"
                    }
                    ,
                    Text = {
                        Text="", Font="robotocondensed-regular.ttf", Align=TextAnchor.MiddleCenter, Color="1 1 1 0"
                    }
                }
                , "kits.adminSettings");
            }
            container.Add(new CuiButton
            {
                Button = {
                    Color="1 1 1 0", Command=GetKitsForPlayer(player).Skip(5 * (page + 1)).Count() > 0 ? $"kits.page {page + 1}": $""
                }
                ,
                RectTransform = {
                    AnchorMin="0.95 0.4", AnchorMax="1 0.6"
                }
                ,
                Text = {
                    Text=">", Font="robotocondensed-regular.ttf", Align=TextAnchor.MiddleCenter, FontSize=80, Color=GetKitsForPlayer(player).Skip(5 * (page + 1)).Count() > 0 ? "1 1 1 1": "1 1 1 0.3"
                }
            }
            , $"ui.kits1", $"ui.kits1.buttonNext");
            container.Add(new CuiButton
            {
                Button = {
                    Color="1 1 1 0", Command=page > 0 ? $"kits.page {page - 1}": ""
                }
                ,
                RectTransform = {
                    AnchorMin="0 0.4", AnchorMax="0.05 0.6"
                }
                ,
                Text = {
                    Text="<", Font="robotocondensed-regular.ttf", Align=TextAnchor.MiddleCenter, FontSize=80, Color=page > 0 ? "1 1 1 1": "1 1 1 0.3"
                }
            }
            , $"ui.kits1", $"ui.kits1.buttonNext");
            CuiHelper.AddUi(player, container);
        }
        private void InitilizeCooldown(ref CuiElementContainer container, BasePlayer player, Kit kit, int page)
        {
            CuiHelper.DestroyUi(player, $"ui.kits.{kit.Name}.kitmain");
            var playerData = GetPlayerData(kit.Name, player.userID);
            container.Add(new CuiPanel
            {
                Image = {
                    Color="0.75 0.75 0.75 0.4", /*Material= "assets/content/ui/ui.background.tile.psd", */
				}
                ,
                RectTransform = {
                    AnchorMin=$"0 0", AnchorMax=$"1 1"
                }
            }
            , $"ui.kits.{kit.Name}", $"ui.kits.{kit.Name}.kitmain");
            if (kit.Cooldown > 0 && playerData.Cooldown - 1 < GetCurrentTime() || kit.Cooldown == 0)
            {
                container.Add(new CuiPanel
                {
                    Image = {
                        Color=kit.Color
                    }
                    ,
                    RectTransform = {
                        AnchorMin=$"0 0", AnchorMax=$"0.994 0.97"
                    }
                }
                , $"ui.kits.{kit.Name}.kitmain");
                container.Add(new CuiButton
                {
                    Button = {
                        Color="0.75 0.75 0.75 0", Command=$"kit {kit.Name}"
                    }
                    ,
                    RectTransform = {
                        AnchorMin="0 0", AnchorMax="1 1"
                    }
                    ,
                    Text = {
                        Text="", Font="robotocondensed-regular.ttf", Align=TextAnchor.MiddleCenter, FontSize=18
                    }
                }
                , $"ui.kits.{kit.Name}", $"ui.kits.{kit.Name}.kitmain");
                container.Add(new CuiElement
                {
                    Parent = $"ui.kits.{kit.Name}.kitmain",
                    Components = {
                        new CuiTextComponent {
                            Color="1 1 1 1", Text=$"<b>{kit.DisplayName.ToUpper()}</b>", FontSize=22, Font="robotocondensed-regular.ttf", Align=TextAnchor.MiddleCenter,
                        }
                        , new CuiRectTransformComponent {
                            AnchorMin=$"0 0", AnchorMax=$"1 1"
                        }
                        , new CuiOutlineComponent {
                            Color="0 0 0 0.3", Distance="-0.5 0.5"
                        }
                    }
                    ,
                }
                );
                container.Add(new CuiElement
                {
                    Parent = $"ui.kits.{kit.Name}.kitmain",
                    Components = {
                        new CuiTextComponent {
                            Color="0.85 0.85 0.85 1.00", Text=GetMsg("UI GIVE", player), FontSize=14, Font="robotocondensed-regular.ttf", Align=TextAnchor.MiddleCenter,
                        }
                        , new CuiRectTransformComponent {
                            AnchorMin=$"0 0", AnchorMax=$"1 0.3"
                        }
                        , new CuiOutlineComponent {
                            Color="0 0 0 0.3", Distance="-0.5 0.5"
                        }
                    }
                    ,
                }
                );
                if (kit.Amount > 0)
                {
                    var amount = kit.Amount - playerData.Amount;
                    container.Add(new CuiElement
                    {
                        Parent = $"ui.kits.{kit.Name}.kitmain",
                        Components = {
                            new CuiTextComponent {
                                Color="0.85 0.85 0.85 1.00", Text=GetMsg("UI Amount", player).Replace("{amount}", amount.ToString()), FontSize=11, Font="robotocondensed-regular.ttf", Align=TextAnchor.MiddleRight,
                            }
                            , new CuiRectTransformComponent {
                                AnchorMin=$"0 0.75", AnchorMax=$"0.95 0.95"
                            }
                            , new CuiOutlineComponent {
                                Color="0 0 0 0.3", Distance="-0.5 0.5"
                            }
                        }
                        ,
                    }
                    );
                }
                container.Add(new CuiButton
                {
                    Button = {
                        Color="0.75 0.75 0.75 0", Command=playerData.Cooldown - 1 < GetCurrentTime() ? $"kit {kit.Name} {page}": ""
                    }
                    ,
                    RectTransform = {
                        AnchorMin="0 0", AnchorMax="1 1"
                    }
                    ,
                    Text = {
                        Text="", Font="robotocondensed-regular.ttf", Align=TextAnchor.MiddleCenter, FontSize=18
                    }
                }
                , $"ui.kits.{kit.Name}");
            }
            else
            {
                var time = TimeSpan.FromSeconds(playerData.Cooldown - GetCurrentTime());
                var AnchorType = kit.Cooldown / (float)time.TotalSeconds - 0.03f;
                var max = 1 - ((time.TotalSeconds + (float)kit.Cooldown / 60) / kit.Cooldown);
                container.Add(new CuiPanel
                {
                    Image = {
                        Color=kit.Color
                    }
                    ,
                    RectTransform = {
                        AnchorMin=$"0 0", AnchorMax=$"{max} 0.97"
                    }
                }
                , $"ui.kits.{kit.Name}.kitmain", $"ui.kits.{kit.Name}.time");
                container.Add(new CuiElement
                {
                    Parent = $"ui.kits.{kit.Name}.kitmain",
                    Components = {
                        new CuiTextComponent {
                            Color="1 1 1 1", Text=$"<b>{kit.DisplayName.ToUpper()}</b>", FontSize=22, Font="robotocondensed-regular.ttf", Align=TextAnchor.MiddleCenter,
                        }
                        , new CuiRectTransformComponent {
                            AnchorMin=$"0 0", AnchorMax=$"1 1"
                        }
                        , new CuiOutlineComponent {
                            Color="0 0 0 0.3", Distance="-0.5 0.5"
                        }
                    }
                    ,
                }
                );
                container.Add(new CuiElement
                {
                    Parent = $"ui.kits.{kit.Name}.kitmain",
                    Components = {
                        new CuiTextComponent {
                            Color="0.85 0.85 0.85 1.00", Text=TimeExtensions.FormatShortTime(time), FontSize=14, Font="robotocondensed-regular.ttf", Align=TextAnchor.MiddleCenter,
                        }
                        , new CuiRectTransformComponent {
                            AnchorMin=$"0 0", AnchorMax=$"1 0.3"
                        }
                        , new CuiOutlineComponent {
                            Color="0 0 0 0.3", Distance="-0.5 0.5"
                        }
                    }
                    ,
                }
                );
            }
        }
        [ConsoleCommand("kit.drawkitinfo")]
        void cmdDrawKitInfo(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null || player.Connection == null) return;
            var kit = kitsList.First(kits => kits.Name.ToLower() == args.Args[0].ToLower());
            if (kit == null) return;
            DrawKitInfo(player, kit, int.Parse(args.Args[1]));
        }
        void DrawKitInfo(BasePlayer player, Kit kit, int page)
        {
            DestroyUI(player);
            CuiHelper.DestroyUi(player, $"ui.kits.info");


            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                Image = {
                    Color="0.19 0.19 0.18 0.6"/*, Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" */
				}
                ,
                RectTransform = {
                    AnchorMin="0 0", AnchorMax="1 1"
                }
                ,
                CursorEnabled = true
            }
            , "Overlay", $"ui.kits.info");
            container.Add(new CuiElement
            {
                Parent = $"ui.kits.info",
                Components = {
                    new CuiTextComponent {
                        Color="1 1 1 1", Text=$"<b>{kit.DisplayName.ToUpper()}</b>", FontSize=30, Align=TextAnchor.MiddleCenter,
                    }
                    , new CuiRectTransformComponent {
                        AnchorMin=$"0 0.8", AnchorMax=$"1 1"
                    }
                    , new CuiOutlineComponent {
                        Color="0 0 0 0.3", Distance="-0.5 0.5"
                    }
                }
                ,
            }
            );
            var pos = 0.5f - ((kit.Items.Count > 10 ? 10 : kit.Items.Count) * 0.09f + ((kit.Items.Count > 10 ? 10 : kit.Items.Count) - 1) * 0.005f) / 2;
            var newline1 = 0.43;
            var newline2 = 0.57;
            if (kit.Items.Count > 10)
            {
                newline1 = 0.58;
                newline2 = 0.72;
            }
            container.Add(new CuiElement
            {
                Parent = $"ui.kits.info",
                Components = {
                    new CuiTextComponent {
                        Color="0.85 0.85 0.85 1.00", Text=GetMsg("UI Item Info", player), FontSize=14, Font="robotocondensed-regular.ttf", Align=TextAnchor.MiddleCenter,
                    }
                    , new CuiRectTransformComponent {
                        AnchorMin=$"0 0", AnchorMax=$"1 0.3"
                    }
                    , new CuiOutlineComponent {
                        Color="0 0 0 0.3", Distance="-0.5 0.5"
                    }
                }
                ,
            }
            );
            container.Add(new CuiElement
            {
                Parent = $"ui.kits.info",
                Components = {
                    new CuiButtonComponent {
                        Color="0.16 0.15 0.31 0", Command=$"kit ui {page} {kit.Name}"
                    }
                    , new CuiRectTransformComponent {
                        AnchorMin="-100 -100", AnchorMax="100 100", OffsetMax="0 0"
                    }
                    ,
                }
                ,
            }
            );
            foreach (var item in kit.Items.OrderBy(p => p.Change < p.Change).Select((i, t) => new
            {
                A = i,
                B = t
            }
            ).Take(30))
            {
                var element = config.RaritiesColor.Find(p => p.Chance == ChangeSelect(item.A.Change));

                if (element == null)
                {
                    PrintError($"Ошибка загрузки цвета шанса у кита {kit.Name} {item.A.ShortName} Шанс {item.A.Change} {element.Color}");
                    continue;
                }
                container.Add(new CuiButton
                {
                    RectTransform = {
                        AnchorMin=$"{pos} {newline1}", AnchorMax=$"{pos + 0.09f} {newline2}", OffsetMax="0 0"
                    }
                    ,
                    Button = {
                        Color=element.Color
                    }
                    ,
                    Text = {
                        Text=""
                    }
                }
                , $"ui.kits.info", $"ui.kits.info" + $".{item.B}");
                pos += 0.09f + 0.005f;
                container.Add(new CuiElement
                {
                    Parent = $"ui.kits.info" + $".{item.B}",
                    Components = {
                        new CuiRawImageComponent {
                                                       Png =!string.IsNullOrEmpty(item.A.CustomImage) ? GetImage(item.A.CustomImage) :  item.A.ShortName == "mailbox"? GetImage("mailbox_1812087291") : GetImage(item.A.ShortName, item.A.SkinID),

                        }
                        , new CuiRectTransformComponent {
                            AnchorMin="0.1 0", AnchorMax="0.9 0.97", OffsetMax="0 0"
                        }
                        ,
                    }
                    ,
                }
                );
                container.Add(new CuiElement
                {
                    Parent = $"ui.kits.info" + $".{item.B}",
                    Components = {
                        new CuiTextComponent {
                            Color="0.85 0.85 0.85 1.00", Text=$"<b>x{item.A.Amount}</b>", FontSize=12, Align=TextAnchor.MiddleRight,
                        }
                        , new CuiRectTransformComponent {
                            AnchorMin=$"0.4 0", AnchorMax=$"0.95 0.2"
                        }
                        , new CuiOutlineComponent {
                            Color="0 0 0 0.3", Distance="-0.5 0.5"
                        }
                    }
                    ,
                }
                );
                if (item.A.Change < 99) container.Add(new CuiElement
                {
                    Parent = $"ui.kits.info" + $".{item.B}",
                    Components = {
                        new CuiTextComponent {
                            Color="0.85 0.85 0.85 0.7", Text=$"<b>{item.A.Change}%</b>", FontSize=45, Align=TextAnchor.MiddleCenter,
                        }
                        , new CuiRectTransformComponent {
                            AnchorMin=$"0 0", AnchorMax=$"1 1"
                        }
                        , new CuiOutlineComponent {
                            Color="0 0 0 0.3", Distance="-0.5 0.5"
                        }
                    }
                    ,
                }
                );
                if (item.B == 9)
                {
                    newline1 = 0.43;
                    newline2 = 0.57;
                    pos = 0.5f - ((kit.Items.Skip(10).ToList().Count > 10 ? 10 : kit.Items.Skip(10).ToList().Count) * 0.09f + ((kit.Items.Skip(10).ToList().Count > 10 ? 10 : kit.Items.Skip(10).ToList().Count) - 1) * 0.005f) / 2;
                }
                if (item.B == 19)
                {
                    newline1 = 0.28;
                    newline2 = 0.42;
                    pos = 0.5f - ((kit.Items.Skip(20).ToList().Count > 10 ? 10 : kit.Items.Skip(20).ToList().Count) * 0.09f + ((kit.Items.Skip(20).ToList().Count > 10 ? 10 : kit.Items.Skip(20).ToList().Count) - 1) * 0.005f) / 2;
                }
            }
            CuiHelper.AddUi(player, container);
        }
        private int? ChangeSelect(int x)
        {
            var num = (from number in config.RaritiesColor.Select(p => p.Chance)
                       let difference = Math.Abs(number - x)
                       orderby difference, Math.Abs(number), number descending
                       select number)
                .FirstOrDefault();
            return num;
        }
        private void SendEffectToPlayer2(BasePlayer player, string effectPrefab)
        {
            EffectNetwork.Send(new Effect(effectPrefab, player.transform.position, Vector3.zero), player.net.connection);
        }
        [ConsoleCommand("UIkits_adminSettings")]
        void adminSettingsKit(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            int page = int.Parse(args.Args[0]);
            if (!AdminSetting.Contains(player))
            {
                AdminSetting.Add(player);
                DestroyUI(player);
                TriggerUI(player, page);
            }
            else
            {
                AdminSetting.Remove(player);
                DestroyUI(player);
                TriggerUI(player, page);
            }
        }
        private KitData GetPlayerData(string name, ulong playerid = 1)
        {
            if (!PlayersData.ContainsKey(playerid)) PlayersData[playerid] = new Dictionary<string, KitData>();
            if (!PlayersData[playerid].ContainsKey(name)) PlayersData[playerid][name] = new KitData();
            return PlayersData[playerid][name];
        }
        private List<KitItem> GetPlayerItems(BasePlayer player)
        {
            List<KitItem> kititems = new List<KitItem>();
            foreach (Item item in player.inventory.containerWear.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, "wear");
                    kititems.Add(iteminfo);
                }
            }
            foreach (Item item in player.inventory.containerMain.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, "main");
                    kititems.Add(iteminfo);
                }
            }
            foreach (Item item in player.inventory.containerBelt.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, "belt");
                    kititems.Add(iteminfo);
                }
            }
            return kititems;
        }
        string GetMsg(string key, BasePlayer player = null) => lang.GetMessage(key, this, player == null ? null : player.UserIDString).Replace("{Prefix}", config.DefaultPrefix);
        private KitItem ItemToKit(Item item, string container)
        {
            KitItem kitem = new KitItem();
            kitem.Amount = item.amount;
            kitem.Container = container;
            kitem.SkinID = item.skin;
            kitem.Blueprint = item.blueprintTarget;
            kitem.ShortName = item.info.shortname;
            kitem.Condition = item.condition;
            kitem.Change = 100;
            kitem.Weapon = null;
            kitem.Content = null;
            if (item.info.category == ItemCategory.Weapon)
            {
                BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
                if (weapon != null)
                {
                    kitem.Weapon = new Weapon();
                    kitem.Weapon.ammoType = weapon.primaryMagazine.ammoType.shortname;
                    kitem.Weapon.ammoAmount = weapon.primaryMagazine.contents;
                }
            }
            if (item.contents != null)
            {
                kitem.Content = new List<ItemContent>();
                foreach (var cont in item.contents.itemList)
                {
                    kitem.Content.Add(new ItemContent()
                    {
                        Amount = cont.amount,
                        Condition = cont.condition,
                        ShortName = cont.info.shortname
                    }
                    );
                }
            }
            return kitem;
        }
        private List<Kit> GetKitsForPlayer(BasePlayer player)
        {
            if (AdminSetting.Contains(player))
            {
                return kitsList.ToList();
            }
            else return kitsList.Where(kit => !kit.Hide && (string.IsNullOrEmpty(kit.Permission) || permission.UserHasPermission(player.UserIDString, kit.Permission)) && (kit.Amount == 0 || (kit.Amount > 0 && GetPlayerData(kit.Name, player.userID).Amount < kit.Amount))).ToList();
        }
        private BasePlayer FindPlayer(BasePlayer player, string nameOrID)
        {
            ulong id;
            if (ulong.TryParse(nameOrID, out id) && nameOrID.StartsWith("7656119") && nameOrID.Length == 17)
            {
                var findedPlayer = BasePlayer.FindByID(id);
                if (findedPlayer == null || !findedPlayer.IsConnected)
                {
                    SendReply(player, GetMsg("Not Found Player", player));
                    return null;
                }
                return findedPlayer;
            }
            var foundPlayers = BasePlayer.activePlayerList.Where(x => x.displayName.ToLower().Contains(nameOrID.ToLower()));
            if (foundPlayers.Count() == 0)
            {
                SendReply(player, GetMsg("Not Found Player", player));
                return null;
            }
            if (foundPlayers.Count() > 1)
            {
                SendReply(player, GetMsg("To Many Player", player));
                return null;
            }
            return foundPlayers.First();
        }
        private double GetCurrentTime() => new TimeSpan(DateTime.UtcNow.Ticks).TotalSeconds;
        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }
            var str = hex.Trim('#');
            if (str.Length == 6) str += "FF";
            if (str.Length != 8)
            {
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }
            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);
            Color color = new Color32(r, g, b, a);
            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }
        private static class TimeExtensions
        {
            public static string FormatShortTime(TimeSpan time)
            {
                string result = string.Empty;
                if (time.Days != 0) result += $"{time.Days} д. ";
                if (time.Hours != 0) result += $"{time.Hours} ч. ";
                if (time.Minutes != 0) result += $"{time.Minutes} м. ";
                if (time.Seconds != 0) result += $"{time.Seconds} с. ";
                return result;
            }
            public static string FormatTime(TimeSpan time)
            {
                string result = string.Empty;
                if (time.Days != 0) result += $"{Format(time.Days, "дней", "дня", "день")} ";
                if (time.Hours != 0) result += $"{Format(time.Hours, "часов", "часа", "час")} ";
                if (time.Minutes != 0) result += $"{Format(time.Minutes, "минут", "минуты", "минута")} ";
                if (time.Seconds != 0) result += $"{Format(time.Seconds, "секунд", "секунды", "секунда")} ";
                return result;
            }
            private static string Format(int units, string form1, string form2, string form3)
            {
                var tmp = units % 10;
                if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9) return $"{units} {form1}";
                if (tmp >= 2 && tmp <= 4) return $"{units} {form2}";
                return $"{units} {form3}";
            }
        }
        [HookMethod("isKit")]
        public bool isKit(string kitName)
        {
            if (kitsList.Select(p => p.Name == kitName) != null) return true;
            return false;
        }
        [HookMethod("GetAllKits")] public string[] GetAllKits() => kitsList.Select(p => p.Name).ToArray();
    }
}

// --- End of file: Kits2.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SentryTurrets.cs ---
// --- Original Local Path: SentryTurrets.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using VLB;

namespace Oxide.Plugins
{
    [Info("Sentry Turrets", "Rust", "2.2.4")]
    [Description("Leak By SparK")]
    public class SentryTurrets : RustPlugin
    {
        #region Vars

        private const ulong skinID = 1587601905;
        private const string prefabSentry = "assets/content/props/sentry_scientists/sentry.scientist.static.prefab";
        private const string itemName = "autoturret";

        #endregion Vars

        #region Oxide Hooks

        private void Init()
        {
            cmd.AddConsoleCommand("sentryturrets.give", this, nameof(cmdGiveConsole));

            if (config.spray == 0)
            {
                Unsubscribe("OnTurretTarget");
            }
        }

        private void OnServerInitialized()
        {
            CheckExistingTurrets();
        }

        private void Unload()
        {
            UnityEngine.Object.FindObjectsOfType<CheckGround>().ToList().ForEach(UnityEngine.Object.Destroy);
        }

        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            CheckPlacement(plan, go);
        }

        private object CanPickupEntity(BasePlayer player, NPCAutoTurret entity)
        {
            return CheckPickup(player, entity);
        }

        private object OnTurretTarget(NPCAutoTurret turret, BasePlayer player)
        {
            
            if (player != null && turret.OwnerID != 0 && CanShootBullet(turret, player))
            {
                return null;
            }

            return false;
        }

        #endregion Oxide Hooks

        #region Commands

        private void cmdGiveConsole(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin == false)
            {
                SendReply(arg, "You don't have access to that command!");
                return;
            }

            var args = arg.Args;
            if (args == null || args?.Length == 0)
            {
                SendReply(arg, "Usage: sentryturrets.give {steamID / Name}");
                return;
            }

            var player = FindPlayer(args[0]);
            if (player != null)
            {
                GiveItem(player);
            }
        }

        [ChatCommand("t")]
        private void cmdToggleChat(BasePlayer player)
        {
            var entity = GetLookEntity(player);
            if (entity == null)
            {
                return;
            }

            if (entity.IsAuthed(player) == false)
            {
                return;
            }

            entity.SetIsOnline(entity.IsOn() == false);
        }

        #endregion Commands

        #region Core

        private object CheckPickup(BasePlayer player, NPCAutoTurret entity)
        {
            var items = entity.inventory?.itemList.ToList() ?? new List<Item>();

            foreach (var item in items)
            {
                player.GiveItem(item);
            }

            entity.Kill();
            GiveItem(player);
            return false;
        }

        private void CheckPlacement(Planner plan, GameObject go)
        {
            var entity = go.ToBaseEntity();
            if (entity == null)
            {
                return;
            }

            if (entity.skinID != skinID)
            {
                return;
            }

            var player = plan.GetOwnerPlayer();
            if (player == null)
            {
                return;
            }

            var transform = entity.transform;
            var position = transform.position;
            var rotation = transform.rotation;
            var owner = entity.OwnerID;
            entity.Kill();

            var turret = GameManager.server.CreateEntity(prefabSentry, position, rotation).GetComponent<NPCAutoTurret>();
            turret.OwnerID = owner;
            turret.Spawn();
            turret.SetIsOnline(false);
            turret.SetPeacekeepermode(false);
            SetupTurret(turret);
        }


        public bool CanAcceptItem(Item item, int targetSlot)
        {
            return (item.info.itemid.Equals(-1211166256));
        }

        private void SetupTurret(NPCAutoTurret turret)
        {
            turret.sightRange = config.range;
            turret.aimCone = config.aimCone;
            turret.inventory.capacity = 12;
            turret.inventory.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(turret.inventory.canAcceptItem, new Func<Item, int, bool>(CanAcceptItem));
            SetupProtection(turret);
            AddComponent(turret);
            turret.SendNetworkUpdate();
        }

        private void CheckExistingTurrets()
        {
            var turrets = UnityEngine.Object.FindObjectsOfType<NPCAutoTurret>().Where(x => x.OwnerID != 0);
            foreach (var turret in turrets)
            {
                SetupTurret(turret);
            }
        }

        private void SetupProtection(BaseCombatEntity turret)
        {
            var health = config.health;
            turret._maxHealth = health;
            turret.health = health;

            if (config.getDamage)
            {
                turret.baseProtection = ScriptableObject.CreateInstance<ProtectionProperties>();
                turret.baseProtection.amounts = new float[]
                {
                    1,1,1,1,1,0.8f,1,1,1,0.9f,0.5f,
                    0.5f,1,1,0,0.5f,0,1,1,0,1,0.9f
                };
            }
        }

        private void AddComponent(BaseNetworkable entity)
        {
            entity.gameObject.GetOrAddComponent<CheckGround>();
            entity.SendNetworkUpdate();
        }

        private static Item CreateItem()
        {
            var item = ItemManager.CreateByName(itemName, 1, skinID);
            item.name = "Sentry Turret";
            return item;
        }

        private static void GiveItem(Vector3 position)
        {
            var item = CreateItem();
            item.Drop(position, Vector3.down);
        }

        private void GiveItem(BasePlayer player)
        {
            var item = CreateItem();
            player.GiveItem(item);
            Puts($"Turret was gave successfully to {player.displayName}");
        }

        private BasePlayer FindPlayer(string nameOrID)
        {
            var targets = BasePlayer.activePlayerList.Where(x => x.UserIDString == nameOrID || x.displayName.ToLower().Contains(nameOrID.ToLower())).ToList();

            if (targets.Count == 0)
            {
                Puts("There are no players with that Name or steamID!");
                return null;
            }

            if (targets.Count > 1)
            {
                Puts($"There are many players with that Name:\n{targets.Select(x => x.displayName).ToSentence()}");
                return null;
            }

            return targets[0];
        }

        private bool CanShootBullet(NPCAutoTurret nPCAutoTurret, BasePlayer player)
        {
            var items = nPCAutoTurret.inventory.itemList.Where(x => x.info.shortname == "ammo.rifle").ToList();
            if (items.Count == 0)
            {
                return false;
            }
            if (Vector3.Distance(player.transform.position, nPCAutoTurret.transform.position) > config.range)
            {
                return false;
            }
            var item = items[0];
            var need = config.spray;

            if (item.amount > need)
            {
                item.amount -= need;
            }
            else
            {
                item.GetHeldEntity()?.Kill();
                item.DoRemove();
            }

            return true;
        }

        private NPCAutoTurret GetLookEntity(BasePlayer player)
        {
            RaycastHit rHit;
            if (Physics.Raycast(player.eyes.HeadRay(), out rHit) == false) { return null; }
            return rHit.GetEntity()?.GetComponent<NPCAutoTurret>();
        }

        #endregion Core

        #region Configuration 1.1.0

        private static ConfigData config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Can get damage")]
            public bool getDamage;

            [JsonProperty(PropertyName = "Amount of ammo for one spray (set to 0 for no-ammo mode)")]
            public int spray;

            [JsonProperty(PropertyName = "Range (normal turret - 30")]
            public int range;

            [JsonProperty(PropertyName = "Give back on ground missing")]
            public bool itemOnGroundMissing;

            [JsonProperty(PropertyName = "Health (normal turret - 1000)")]
            public float health;

            [JsonProperty(PropertyName = "Aim cone (normal turret - 4)")]
            public float aimCone;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                getDamage = true,
                spray = 3,
                range = 100,
                itemOnGroundMissing = true,
                health = 1500,
				/*aimTarge = %id%,*/
                aimCone = 2
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintError("Configuration file is corrupt! Unloading plugin...");
                Interface.Oxide.RootPluginManager.RemovePlugin(this);
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion Configuration 1.1.0

        #region Scripts

        private class CheckGround : MonoBehaviour
        {
            private BaseEntity entity;

            private void Start()
            {
                entity = GetComponent<BaseEntity>();
                InvokeRepeating(nameof(Check), 5f, 5f);
            }

            private void Check()
            {
                if (entity == null)
                {
                    Destroy(this);
                    return;
                }

                RaycastHit rhit;
                var cast = Physics.Raycast(entity.transform.position + new Vector3(0, 0.1f, 0), Vector3.down, out rhit, 4f, LayerMask.GetMask("Terrain", "Construction"));
                var distance = cast ? rhit.distance : 3f;

                if (distance > 0.2f)
                {
                    GroundMissing();
                }
            }

            private void GroundMissing()
            {
                var position = entity.transform.position;
                entity.Kill();
                Effect.server.Run("assets/bundled/prefabs/fx/item_break.prefab", position);

                if (config.itemOnGroundMissing)
                {
                    GiveItem(position);
                }
            }
        }

        #endregion Scripts
    }
}

// --- End of file: SentryTurrets.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/WoundedLogo.cs ---
// --- Original Local Path: WoundedLogo.cs ---

﻿using ConVar;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("WoundedLogo", "Frizen", "2.0.0")]
    internal class WoundedLogo: RustPlugin
    {
        #region Vars
        [PluginReference] private Plugin ImageLibrary;
        private bool _isCH47 = false;
        private bool _isHeli = false;
        private bool _isShip = false;
        private const string _layer = "WoundedLogo";
        #endregion

        #region Config
        private static Configuration _config;
        public class Configuration
        {

            [JsonProperty("Картинки")]
            public Dictionary<string, string> Imgs = new Dictionary<string, string>();

            public static Configuration DefaultConfig()
            {
                return new Configuration
                {
                    Imgs =
                    {
                        ["LogoText"] = "https://i.imgur.com/sJKehAZ.png",
                        ["LogoBTN"] = "https://i.imgur.com/9XZ2Dwg.png",
                        ["Heli"] = "https://i.imgur.com/x7aKqvw.png",
                        ["Heli_Active"] = "https://i.imgur.com/L2g9Kdm.png",
                        ["CargoShip"] = "https://i.imgur.com/kmH4Qb0.png",
                        ["CargoShip_Active"] = "https://i.imgur.com/solQ9MA.png",
                        ["CH47"] = "https://i.imgur.com/75zWb8a.png",
                        ["CH47_Active"] = "https://i.imgur.com/ezGZZIm.png",
                        ["BackgroundLogo"] = "https://i.imgur.com/3cxM5iR.png",
                        ["OnlineBar"] = "https://i.imgur.com/u7nshQU.png",
                        ["ActiveOnlineBar"] = "https://i.imgur.com/rL5rfVA.png",
                        ["PeopleIcon"] = "https://i.imgur.com/6NFZW4B.png",
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) LoadDefaultConfig();
                SaveConfig();
            }
            catch (Exception e)
            {
                Debug.LogException(e);
                PrintWarning("Creating new config file.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = Configuration.DefaultConfig();
        protected override void SaveConfig() => Config.WriteObject(_config);
        #endregion

        #region Hooks
        private void OnServerInitialized()
        {
            FirstCheckEvents();

            foreach (var img in _config.Imgs)
            {
                ImageLibrary.Call("AddImage", img.Value, img.Key);
            }

            foreach (var item in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(item);
            }
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerConnected(player));
                return;
            }

            if (!MenuOpened.ContainsKey(player.userID))
            {
                MenuOpened.Add(player.userID, true);
            }

            DrawMenu(player);

            timer.Once(1f, () =>
            {
                foreach (var players in BasePlayer.activePlayerList)
                {
                    if (players.userID == player.userID) continue;
                    bool IsOpen;
                    if (MenuOpened.TryGetValue(player.userID, out IsOpen) && IsOpen)
                    {
                        OnlineUI(players);
                    }
                }
            });
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            timer.Once(1f, () =>
            {
                foreach (var players in BasePlayer.activePlayerList)
                {
                    OnlineUI(players);
                }
            });
        }

        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity == null) return;
            if (entity is CH47Helicopter)
            {
                _isCH47 = true;
                foreach (var player in BasePlayer.activePlayerList)
                {
                    RefreshEvents(player, "CH47");
                }
                return;
            }
            if (entity is BaseHelicopter)
            {
                _isHeli = true;
                foreach (var player in BasePlayer.activePlayerList)
                {
                    RefreshEvents(player, "Heli");
                }
                return;
            }
            if (entity is CargoShip)
            {
                _isShip = true;
                foreach (var player in BasePlayer.activePlayerList)
                {
                    RefreshEvents(player, "Cargo");
                }
                return;
            }

        }

        void OnEntityKill(BaseEntity entity)
        {
            if (entity == null) return;
            if (entity is CH47Helicopter)
            {
                _isCH47 = false;
                foreach (var player in BasePlayer.activePlayerList)
                {
                    RefreshEvents(player, "CH47");
                }
                return;
            }
            if (entity is BaseHelicopter)
            {
                _isHeli = false;
                foreach (var player in BasePlayer.activePlayerList)
                {
                    RefreshEvents(player, "Heli");
                }
                return;
            }
            if (entity is CargoShip)
            {
                _isShip = false;
                foreach (var player in BasePlayer.activePlayerList)
                {
                    RefreshEvents(player, "Cargo");
                }
                return;
            }

        }

        void OnEntityDeath(BaseEntity entity, HitInfo info)
        {
            if (entity == null) return;
            if (entity is CH47Helicopter)
            {
                _isCH47 = false;
                foreach (var player in BasePlayer.activePlayerList)
                {
                    RefreshEvents(player, "CH47");
                }
                return;
            }
            if (entity is BaseHelicopter)
            {
                _isHeli = false;
                foreach (var player in BasePlayer.activePlayerList)
                {
                    RefreshEvents(player, "Heli");
                }
                return;
            }
            if (entity is CargoShip)
            {
                _isShip = false;
                foreach (var player in BasePlayer.activePlayerList)
                {
                    RefreshEvents(player, "Cargo");
                }
                return;
            }

        }

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, _layer);
            }
        }
        #endregion

        #region UI
        private void DrawMenu(BasePlayer player)
        {
            var container = new CuiElementContainer();

            CuiHelper.DestroyUi(player, "WoundedLogo");

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "1 1 1 0" },
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "30 -90.5", OffsetMax = "209.5 -21.5" }
            }, "Overlay", "WoundedLogo");

            bool IsOpen;
            if (MenuOpened.TryGetValue(player.userID, out IsOpen) && IsOpen)
            {
                container.Add(new CuiElement
                {
                    Name = "LogoBG",
                    Parent = "WoundedLogo",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage("BackgroundLogo") },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "LogoBTN",
                    Parent = "WoundedLogo",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage("LogoText") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-77.673 -14.558", OffsetMax = "-21.121 14.558" }
                }
                });
            }
            else
            {
                container.Add(new CuiElement
                {
                    Name = "LogoBTN",
                    Parent = "WoundedLogo",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage("LogoBTN") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-89.579 -34.61", OffsetMax = "-20.494 34.611" }
                }
                });
            }

            container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0", Command = "wounded.menu" },
                Text = { Text = $"", Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.LowerCenter, Color = "1 1 1 1" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
            }, "LogoBTN");

            CuiHelper.AddUi(player, container);

            CuiHelper.DestroyUi(player, "BarActive");
            CuiHelper.DestroyUi(player, "OnlineBar");
            CuiHelper.DestroyUi(player, "Peoples");
            CuiHelper.DestroyUi(player, "Online");
            if (IsOpen)
            {
                OnlineUI(player);
                RefreshEvents(player, "All");
            }
        }

        private void RefreshEvents(BasePlayer player, string type)
        {
            var container = new CuiElementContainer();

            string HeliImage = _isHeli ? "Heli_Active" : "Heli";
            string CargoImage = _isShip ? "CargoShip_Active" : "CargoShip";
            string CH47Image = _isCH47 ? "CH47_Active" : "CH47";

            switch (type)
            {
                case "Heli":
                    CuiHelper.DestroyUi(player, "Heli");
                    container.Add(new CuiElement
                    {
                        Name = "Heli",
                        Parent = "WoundedLogo",
                        Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage(HeliImage) },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "58.13 -20.75", OffsetMax = "79.47 0.787" }
                }
                    });

                    break;
                case "Cargo":
                    CuiHelper.DestroyUi(player, "Cargo");

                    container.Add(new CuiElement
                    {
                        Name = "Cargo",
                        Parent = "WoundedLogo",
                        Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage(CargoImage) },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "22.252 -20.75", OffsetMax = "43.592 0.787" }
                }
                    });

                    break;
                case "CH47":
                    CuiHelper.DestroyUi(player, "CH47");
                    container.Add(new CuiElement
                    {
                        Name = "CH47",
                        Parent = "WoundedLogo",
                        Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage(CH47Image) },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-12.156 -20.75", OffsetMax = "9.185 0.787" }
                }
                    });

                    break;
                case "All":
                    CuiHelper.DestroyUi(player, "Heli");
                    CuiHelper.DestroyUi(player, "Cargo");
                    CuiHelper.DestroyUi(player, "CH47");

                    container.Add(new CuiElement
                    {
                        Name = "CH47",
                        Parent = "WoundedLogo",
                        Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage(CH47Image) },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-12.156 -20.75", OffsetMax = "9.185 0.787" }
                }
                    });

                    container.Add(new CuiElement
                    {
                        Name = "Cargo",
                        Parent = "WoundedLogo",
                        Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage(CargoImage) },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "22.252 -20.75", OffsetMax = "43.592 0.787" }
                }
                    });

                    container.Add(new CuiElement
                    {
                        Name = "Heli",
                        Parent = "WoundedLogo",
                        Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage(HeliImage) },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "58.13 -20.75", OffsetMax = "79.47 0.787" }
                }
                    });

                    break;
            }

            bool IsOpen;
            if (MenuOpened.TryGetValue(player.userID, out IsOpen) && !IsOpen)
            {
                return;
            }

            CuiHelper.AddUi(player, container);
        }

        private void OnlineUI(BasePlayer player)
        {
            var container = new CuiElementContainer();

            CuiHelper.DestroyUi(player, "BarActive");
            CuiHelper.DestroyUi(player, "OnlineBar");
            CuiHelper.DestroyUi(player, "Peoples");
            CuiHelper.DestroyUi(player, "Online");

            float onlinebar = GetOnline() / Convert.ToSingle(ConVar.Server.maxplayers);

            container.Add(new CuiElement
            {
                Name = "OnlineBar",
                Parent = "WoundedLogo",
                Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage("OnlineBar") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-12.156 5.086", OffsetMax = "78 20.34" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "BarActive",
                Parent = "OnlineBar",
                Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage("ActiveOnlineBar") },
                    new CuiRectTransformComponent {  AnchorMin = "0 0", AnchorMax = onlinebar > 0.2 ? $"{onlinebar} 1" : "0.2 1", OffsetMin = "1 2", OffsetMax = "-1 -2" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "Peoples",
                Parent = "OnlineBar",
                Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage("PeopleIcon") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-40.499 -4.013", OffsetMax = "-31.901 4.013" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "Online",
                Parent = "OnlineBar",
                Components = {
                    new CuiTextComponent { Text = $"{GetOnline()} / {Convert.ToSingle(ConVar.Server.maxplayers)}", Font = "robotocondensed-bold.ttf", FontSize = 7, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "8.83 -7.628", OffsetMax = "45.078 7.627" }
                }
            });

            bool IsOpen;
            if (MenuOpened.TryGetValue(player.userID, out IsOpen) && !IsOpen)
            {
                return;
            }

            CuiHelper.AddUi(player, container);


        }
        #endregion

        #region Helpers

        public Dictionary<ulong, bool> MenuOpened = new Dictionary<ulong, bool>();

        [ConsoleCommand("wounded.menu")]
        private void MenuHandler(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player == null) return;
            if (!MenuOpened.ContainsKey(player.userID)) MenuOpened.Add(player.userID, true);

            if (!MenuOpened[player.userID])
            {
                MenuOpened[player.userID] = true;
                DrawMenu(player);
                return;
            }
            if (MenuOpened[player.userID])
            {
                MenuOpened[player.userID] = false;
                CuiHelper.DestroyUi(player, "BarActive");
                CuiHelper.DestroyUi(player, "OnlineBar");
                CuiHelper.DestroyUi(player, "Peoples");
                CuiHelper.DestroyUi(player, "Online");
                DrawMenu(player);
                return;
            }
        }

        [PluginReference] private Plugin FreeOnline;
        float GetOnline()
        {
            float online;
            if (FreeOnline)
                online = FreeOnline.Call<int>("GetOnline");
            else online = 20;

            return online;
        }
        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex)) hex = "#FFFFFFFF";
            var str = hex.Trim('#');
            if (str.Length == 6) str += "FF";
            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }
            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);
            Color color = new Color32(r, g, b, a);
            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        private void FirstCheckEvents()
        {

            foreach (var entity in BaseEntity.serverEntities)
            {
                if (entity is CargoShip)
                {
                    _isShip = true;
                }
                if (entity is CH47Helicopter)
                {
                    _isCH47 = true;
                }
                if (entity is BaseHelicopter)
                {
                    _isHeli = true;
                }
            }

        }

        public string GetImage(string shortname, ulong skin = 0) => (string)ImageLibrary?.Call("GetImage", shortname, skin);
        #endregion

    }
}


// --- End of file: WoundedLogo.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TPReportSystem.cs ---
// --- Original Local Path: TPReportSystem.cs ---

using System.Net;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Newtonsoft.Json;
using UnityEngine;
using Oxide.Core;
using System.Linq;
using System;
using Network;
using Newtonsoft.Json.Linq;
using ConVar;

namespace Oxide.Plugins
{
    [Info("TPReportSystem", "Sempai#3239", "5.0.0")]
    class TPReportSystem : RustPlugin
    {
        #region Вар
        [PluginReference] Plugin ImageLibrary;

        public string Layer = "lay";

        Dictionary<ulong, string> name = new Dictionary<ulong, string>();
        #endregion

        #region Вар
        Dictionary<ulong, DataBase> DB;
        public class DataBase 
        {
            [JsonProperty("Ник игрока")] public string DisplayName;
            [JsonProperty("SteamID игрока")] public ulong SteamID;
            [JsonProperty("Кол-во проверок у игрока")] public int Count;
            [JsonProperty("Дискорд игрока")] public string DS;
            [JsonProperty("SteamID проверяющего")] public ulong SteamID2;
            [JsonProperty("Вызван ли игрок на проверку")] public bool Enable;
            [JsonProperty("Список с жалобами и их кол-вом")] public Dictionary<string, int> Res = new Dictionary<string, int>() {
                ["Reason_1"] = 0,
                ["Reason_2"] = 0,
                ["Reason_3"] = 0
            };
        }
        #endregion

        #region Конфиг
        public Configuration config;
        public class Configuration
        {
            [JsonProperty("Пермишен для модераторов")] public string Perm = "tpreportsystem.use";
            [JsonProperty("Информация плагина")] public string Info = "Ахуенный плагин скилов всем советую, а кто не купит, тот гомосек";
            [JsonProperty("Оповещание")] public string Title = "Предоставте свой дискорд или скайп для проверки.\nВведите команду /contact\nЕсли Вы покинете сервер, Вы будете забанены на проекте FEDOT RUST.\nУ вас есть 5 минут!";
            [JsonProperty("Webhook")] public String WebhookNotify;
			[JsonProperty("Цвет сообщения в Discord (Можно найти на сайте - https://old.message.style/dashboard в разделе JSON)")] public Int32 Color; 
			[JsonProperty("Заголовок сообщения")] public String AuthorName;
			[JsonProperty("Ссылка на иконку для аватарки сообщения")] public String IconURL;
            [JsonProperty("Список жалоб")] public Dictionary<string, string> Reasons;
            [JsonProperty("Список причин бана")] public List<string> Ban;
            public static Configuration GetNewCong()
            {
                return new Configuration
                {
                    Reasons = new Dictionary<string, string>()
                    {
                        ["Reason_1"] = "Багоюз игрового процеса",
                        ["Reason_2"] = "Использование макросов",
                        ["Reason_3"] = "Игра с читами"
                    },
                    Ban = new List<string>()
                    {
                        "багоюз",
                        "читы",
                        "макросы"
                    }
                };
            }
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config?.Reasons == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewCong();
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Хуки
        Dictionary<ulong, int> gg = new Dictionary<ulong, int>();
        void OnServerInitialized() {
            if (Interface.Oxide.DataFileSystem.ExistsDatafile("Report/Player"))
                DB = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, DataBase>>("Report/Player");
            else
                DB = new Dictionary<ulong, DataBase>();

            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/report_back.png", "b6wyl5i");
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/report_border.png", "lamC17G");
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/report_window.png", "HoGCxnN");
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/report_btn_active.png", "DA7OETZ");
            ImageLibrary.Call("AddImage", "https://imgur.com/aAm4ZHw.png", "aAm4ZHw");
            ImageLibrary.Call("AddImage", "https://imgur.com/xclemZi.png", "xclemZi");
            ImageLibrary.Call("AddImage", "https://media.discordapp.net/attachments/1138899641472131165/1145112601072775279/5543435453453543.png", "fonDescription");

            permission.RegisterPermission(config.Perm, this);

            foreach (var check in BasePlayer.activePlayerList)
                OnPlayerConnected(check);
        }

        void OnPlayerConnected(BasePlayer player) {
            if (!DB.ContainsKey(player.userID))
                DB.Add(player.userID, new DataBase());
        }

        void SaveDataBase() => Interface.Oxide.DataFileSystem.WriteObject("Report/Player", DB);

        void OnPlayerDisconnected(BasePlayer player, string reason) => SaveDataBase();

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, Layer);

            SaveDataBase();
        }
        #endregion

        #region Команды
        [ChatCommand("contact")]
        void ChatContact(BasePlayer player, string command, string[] args) {
            var db = DB[player.userID];
            if (db.Enable == true) {
                if (args.Length < 1)
                {
                    SendReply(player, "Вы ничего не ввели!\n<size=12>Введите /contact [дискорд или скайп]</size>");
                }
                else
                {
                    var name = "";
                    for(int z = 0; z < args.Length; z++) 
                        name += args[z] + " ";
                    
                    db.DS = name;
                    var target = BasePlayer.activePlayerList.FirstOrDefault(z => z.userID == db.SteamID2);
                    TargetUI(target, db.SteamID);
                    List<Fields> fields = DT_PlayerSendContact(player, name);
		            SendDiscord(config.WebhookNotify, fields, new Authors(player.displayName, "", "", ""), config.Color);
                    SendReply(player, "Вы успешно отправили свой дискорд, ожидайте звонка!");
                }
            }
        }

        [ConsoleCommand("report")]
        void ConsoleReport(ConsoleSystem.Arg args) {
            var player = args.Player();
            if (player != null && args.HasArgs(1))
            {
                if (args.Args[0] == "skip")
                {
                    UI(player, "", int.Parse(args.Args[1]));
                }
                if (args.Args[0] == "skips")
                {
                    ModerUI(player, "", int.Parse(args.Args[1]));
                }
                if (args.Args[0] == "name")
                {
                    if (!args.HasArgs(2)) {
                        name[player.userID] = "";
                        UI(player, name[player.userID]);
                        return;
                    }
                    name[player.userID] = args.Args[1];
                }
                if (args.Args[0] == "search")
                {
                    if (name[player.userID] != "")
                        UI(player, name[player.userID]);
                }
                if (args.Args[0] == "target")
                {
                    InfoUI(player, ulong.Parse(args.Args[1]));
                }
                if (args.Args[0] == "reason") {
                    var target = BasePlayer.activePlayerList.FirstOrDefault(z => z.userID == ulong.Parse(args.Args[1]));
                    if (player.userID == target.userID) {
                        SendReply(player, "Вы не можете отправить жалобу на самого себя!");
                        return;
                    }
                    DB[target.userID].DisplayName = target.displayName;
                    DB[target.userID].SteamID = target.userID;
                    DB[target.userID].Res[args.Args[2]] += 1;
                    List<Fields> fields = DT_PlayerSendReport(player, target.userID, config.Reasons[args.Args[2]]);
		            SendDiscord(config.WebhookNotify, fields, new Authors(player.displayName, "", "", ""), config.Color);
                    SendReply(player, "Вы успешно отправили жалобу на игрока!");
                    CuiHelper.DestroyUi(player, "Menu_UI");
                }
                if (args.Args[0] == "back") 
                {
                    ReportUI(player);
                }
                if (args.Args[0] == "moder") 
                {
                    if (!permission.UserHasPermission(player.UserIDString, config.Perm)) return;
                    ModerUI(player);
                }
                if (args.Args[0] == "player")
                {
                    if (!permission.UserHasPermission(player.UserIDString, config.Perm)) return;
                    TargetUI(player, ulong.Parse(args.Args[1]));
                }
                if (args.Args[0] == "check")
                {
                    if (!permission.UserHasPermission(player.UserIDString, config.Perm)) return;
                    var target = BasePlayer.activePlayerList.FirstOrDefault(z => z.userID == ulong.Parse(args.Args[1]));
                    var db = DB[target.userID];
                    if (db.Enable == false)
                    {
                        CuiHelper.DestroyUi(player, "Menu_UI");
                        db.SteamID2 = player.userID;
                        db.Enable = true;
                        db.Count += 1;
                        TargetUI(player, target.userID);
                        List<Fields> fields = DT_PlayerCheck(player, target.userID);
		                SendDiscord(config.WebhookNotify, fields, new Authors(player.displayName, "", "", ""), config.Color);
                        CheckUI(target);
                    }
                    else
                    {
                        CuiHelper.DestroyUi(player, LayerCheck);
                        db.DisplayName = null;
                        db.SteamID = 0;
                        db.SteamID2 = 0;
                        db.Enable = false;
                        db.DS = null;
                        List<Fields> fields = DT_PlayerCheckRemove(player, target.userID);
		                SendDiscord(config.WebhookNotify, fields, new Authors(player.displayName, "", "", ""), config.Color);
                        CuiHelper.DestroyUi(target, "Check_UI");
                    }
                }
                if (args.Args[0] == "ban")
                {
                    if (!permission.UserHasPermission(player.UserIDString, config.Perm)) return;
                    var target = BasePlayer.activePlayerList.FirstOrDefault(z => z.userID == ulong.Parse(args.Args[1]));
                    var db = DB[target.userID];
                    db.DisplayName = null;
                    db.SteamID = 0;
                    db.SteamID2 = 0;
                    db.Enable = false;
                    db.DS = null;
                    CuiHelper.DestroyUi(player, LayerCheck);
                    Server.Command($"ban {target.userID} {args.Args[2]}");
                }
            }
        }
        #endregion

        #region Интерфейс
        void ReportUI(BasePlayer player) {
            name[player.userID] = "";
            var container = new CuiElementContainer();
            
            container.Add(new CuiElement
            {
                Name = Layer + ".Main",
                Parent = ".Mains",
                Components = 
                {
                    new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "b6wyl5i") },
                    new CuiRectTransformComponent { AnchorMin = "-0.315 -0.27", AnchorMax = "1.3 1.275", OffsetMax = "0 0" },
                }
            });  

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.8 0.804", AnchorMax = "0.817 0.832" },
                Button = { Close = "Menu_UI", Color = "0 0 0 0" },
                Text = { Text = "" }
            }, Layer + ".Main");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.78 0.805", AnchorMax = "0.795 0.833", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = "reportdesc" },
                Text = { Text = "?", Color = "1 1 1 0.7", Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "robotocondensed-regular.ttf" }
            }, Layer + ".Main");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.6 0.662", AnchorMax = "0.685 0.699", OffsetMax = "0 0" },
                Button = { Color = "1 1 1 0" },
                Text = { Text = "", Color = "1 1 1 0.4", Align = TextAnchor.MiddleCenter, FontSize = 10, Font = "robotocondensed-regular.ttf" }
            }, Layer + ".Main", "Nik");

            container.Add(new CuiElement
            {
                Parent = "Nik",
                Components =
                {
                    new CuiInputFieldComponent { Command = "report name ", Text = "", Color = "1 1 1 0.3", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-regular.ttf"},
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.69 0.67", AnchorMax = "0.736 0.69", OffsetMax = "0 0" },
                Button = { Color = "1 1 1 0", Command = "report search" },
                Text = { Text = "", Color = "1 1 1 0.4", Align = TextAnchor.MiddleCenter, FontSize = 10, Font = "robotocondensed-regular.ttf" }
            }, Layer + ".Main");

            if (permission.UserHasPermission(player.UserIDString, config.Perm)) {
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.44 0.66", AnchorMax = "0.57 0.7", OffsetMax = "0 0" },
                Image = { Color = "1 1 1 0"}
            }, Layer + ".Main", "Moder");

            container.Add(new CuiElement
            {
                Parent = "Moder",
                Components = {
                    new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "DA7OETZ"), Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "1 1 1 0", Command = "report moder" },
                Text = { Text = "Модерация", Color = "1 1 1 0.8", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-regular.ttf" }
            }, "Moder");
            }

            CuiHelper.AddUi(player, container);
            UI(player);
        }

        [ConsoleCommand("reportdesc")]
        void DescUI(ConsoleSystem.Arg args) {
            var player = args.Player();
            CuiHelper.DestroyUi(player, Layer + ".Main" + ".Description");
            var container = new CuiElementContainer();

            container.Add(new CuiElement
            {
                Name = Layer + ".Main" + ".Description",
                Parent = Layer + ".Main",
                Components = {
                    new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "fonDescription") },
                    new CuiRectTransformComponent { AnchorMin = $"0.58 0.6", AnchorMax = $"0.8 0.8" },
                }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.05 0.8", AnchorMax = "0.9 1" },
                Text = { Text = $"Описание репортов", Color = "1 1 1 0.65",FontSize = 14, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, Layer + ".Main" + ".Description");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.05 0", AnchorMax = "1 0.7" },
                Text = { Text = $"{config.Info}", Color = "1 1 1 0.65",FontSize = 12, Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
            }, Layer + ".Main" + ".Description");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.9 0.82", AnchorMax = "0.98 0.98" },
                Button = { Close = Layer + ".Main" + ".Description", Color = "1 1 1 0" },
                Text = { Text = "" }
            }, Layer + ".Main" + ".Description");

            CuiHelper.AddUi(player, container);
        }

        void UI(BasePlayer player,string name = "", int page = 0)
        {
            CuiHelper.DestroyUi(player, "Reports");
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.2 0.2", AnchorMax = "0.8 0.65" },
                Image = { Color = "0 0 0 0" }
            }, Layer + ".Main", "Reports");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.033 0.38", AnchorMax = "0.085 0.645", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = page != 0 ? $"report skip {page - 1}" : "" },
                Text = { Text = "", Color = "0 0 0 0", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-regular.ttf" }
            }, "Reports");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.91 0.38", AnchorMax = "0.962 0.645", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = BasePlayer.activePlayerList.Count() > (page + 1) * 18 ? $"report skip {page + 1}" : "" },
                Text = { Text = "", Color = "0 0 0 0", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-regular.ttf" }
            }, "Reports");

            var target = BasePlayer.activePlayerList.Skip(page * 18).Take(18);
            float width = 0.132f, height = 0.31f, startxBox = 0.101f, startyBox = 0.985f - height, xmin = startxBox, ymin = startyBox;
            foreach (var check in target)
            {
                if (check.displayName.Contains(name)) {
                    container.Add(new CuiButton
                    {  
                        RectTransform = { AnchorMin = xmin + " " + ymin, AnchorMax = (xmin + width) + " " + (ymin + height * 1), OffsetMin = "4 4", OffsetMax = "-4 -4" },
                        Button = { Color = "1 1 1 0", Command = $"report target {check.userID}" },
                        Text = { Text = "", Color = "1 1 1 0.6", Align = TextAnchor.UpperCenter, Font = "robotocondensed-regular.ttf", FontSize = 12 }
                    }, "Reports", "Players");

                    container.Add(new CuiElement
                    {
                        Parent = "Players",
                        Components = {
                            new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", check.UserIDString) },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = $"1 1", OffsetMin = "6 6", OffsetMax = "-6 -6" },
                        }
                    });

                    container.Add(new CuiElement
                    {
                        Parent = "Players",
                        Components = {
                            new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "lamC17G") },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                        }
                    });

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.29", OffsetMax = "0 0" },
                        Text = { Text = check.displayName, Color = "1 1 1 0.6", Align = TextAnchor.UpperCenter, Font = "robotocondensed-regular.ttf", FontSize = 12 }
                    }, "Players");

                    xmin += width + 0.0003f;
                    if (xmin + width >= 1)
                    {
                        xmin = startxBox;
                        ymin -= height + 0.008f;
                    }
                }
            }

            CuiHelper.AddUi(player, container);
        }

        void ModerUI(BasePlayer player, string name = "", int page = 0) {
            CuiHelper.DestroyUi(player, "Reports");
            CuiHelper.DestroyUi(player, "Moder");
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.2 0.2", AnchorMax = "0.8 0.65" },
                Image = { Color = "0 0 0 0" }
            }, Layer + ".Main", "Reports");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.57 0.66", AnchorMax = "0.74 0.7", OffsetMax = "0 0" },
                Image = { Color = "1 1 1 0"}
            }, Layer + ".Main", "Moder");

            container.Add(new CuiElement
            {
                Parent = "Moder",
                Components = {
                    new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "DA7OETZ"), Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "1 1 1 0", Command = "report back" },
                Text = { Text = "Назад", Color = "1 1 1 0.8", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-regular.ttf" }
            }, "Moder");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.033 0.38", AnchorMax = "0.085 0.645", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = page != 0 ? $"report skips {page - 1}" : "" },
                Text = { Text = "", Color = "0 0 0 0", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-regular.ttf" }
            }, "Reports");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.91 0.38", AnchorMax = "0.962 0.645", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = DB.Count() > (page + 1) * 18 ? $"report skips {page + 1}" : "" },
                Text = { Text = "", Color = "0 0 0 0", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-regular.ttf" }
            }, "Reports");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.91 0.38", AnchorMax = "0.962 0.645", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = DB.Count() > (page + 1) * 18 ? $"report skip {page + 1}" : "" },
                Text = { Text = "", Color = "0 0 0 0", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-regular.ttf" }
            }, "Reports");

            var target = DB.Skip(page * 18).Take(18);
            float width = 0.132f, height = 0.31f, startxBox = 0.101f, startyBox = 0.985f - height, xmin = startxBox, ymin = startyBox;
            foreach (var check in target)
            {
                if (check.Value.SteamID != 0) {
                    if (check.Value.DisplayName.Contains(name)) {
                        container.Add(new CuiButton
                        {  
                            RectTransform = { AnchorMin = xmin + " " + ymin, AnchorMax = (xmin + width) + " " + (ymin + height * 1), OffsetMin = "4 4", OffsetMax = "-4 -4" },
                            Button = { Color = "1 1 1 0", Command = $"report player {check.Key}" },
                            Text = { Text = "", Color = "1 1 1 0.6", Align = TextAnchor.UpperCenter, Font = "robotocondensed-regular.ttf", FontSize = 12 }
                        }, "Reports", "Players");

                        container.Add(new CuiElement
                        {
                            Parent = "Players",
                            Components = {
                                new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", check.Key.ToString()) },
                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = $"1 1", OffsetMin = "6 6", OffsetMax = "-6 -6" },
                            }
                            
                        });

                        container.Add(new CuiElement
                        {
                            Parent = "Players",
                            Components = {
                                new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "lamC17G") },
                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                            }
                        });

                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.29", OffsetMax = "0 0" },
                            Text = { Text = check.Value.DisplayName, Color = "1 1 1 0.6", Align = TextAnchor.UpperCenter, Font = "robotocondensed-regular.ttf", FontSize = 12 }
                        }, "Players");

                        xmin += width + 0.0003f;
                        if (xmin + width >= 1)
                        {
                            xmin = startxBox;
                            ymin -= height + 0.008f;
                        }
                    }
                }
            }

            CuiHelper.AddUi(player, container);
        }

        void InfoUI(BasePlayer player, ulong id) {
            var container = new CuiElementContainer();

            var target = BasePlayer.activePlayerList.FirstOrDefault(z => z.userID == id);

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0.28 0.22", AnchorMax = "0.72 0.8", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0" }
            }, "Reports", "Report");

            container.Add(new CuiElement
            {
                Parent = "Report",
                Components = {
                    new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "HoGCxnN"), Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.08 0.775", AnchorMax = "0.87 0.9", OffsetMax = "0 0" },
                Text = { Text = "Жалоба на игрока", Color = "1 1 1 0.4", Align = TextAnchor.MiddleLeft, FontSize = 14, Font = "robotocondensed-regular.ttf" }
            }, "Report");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.88 0.775", AnchorMax = "0.945 0.9", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Close = "Report" },
                Text = { Text = "", Color = "0 0 0 0", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-regular.ttf" }
            }, "Report");

            container.Add(new CuiElement
            {
                Parent = "Report",
                Components = {
                    new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", target.UserIDString) },
                    new CuiRectTransformComponent { AnchorMin = "0.075 0.15", AnchorMax = $"0.375 0.7", OffsetMin = "6 6", OffsetMax = "-6 -6" },
                }
            });

            container.Add(new CuiElement
            {
                Parent = "Report",
                Components = {
                    new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "lamC17G") },
                    new CuiRectTransformComponent { AnchorMin = "0.075 0.15", AnchorMax = $"0.375 0.7", OffsetMax = "0 0" },
                }
            });

            container.Add(new CuiLabel
            {
                RectTran